{"files":[{"patch":"@@ -180,1 +180,1 @@\n-fully qualified test descriptors, which clearly and unambigously show\n+fully qualified test descriptors, which clearly and unambiguously show\n@@ -182,2 +182,2 @@\n-to include all subcomponent test directories that define `tier1`,\n-for example:\n+to include all subcomponent test directories that define\n+<code>tier1<\/code>, for example:\n@@ -231,1 +231,1 @@\n-features\/components(for example, XML).<\/p><\/li>\n+features\/components (for example, XML).<\/p><\/li>\n@@ -371,1 +371,1 @@\n-recommended usage is to write the assignment inside qoutes, e.g.\n+recommended usage is to write the assignment inside quotes, e.g.\n@@ -400,2 +400,0 @@\n-<h4 id=\"aot_modules\">AOT_MODULES<\/h4>\n-<p>Applies to JTReg and GTest.<\/p>\n@@ -403,1 +401,1 @@\n-<p>This keywords applies globally to the test runner system. If set to\n+<p>This keyword applies globally to the test runner system. If set to\n@@ -503,5 +501,0 @@\n-<h4 id=\"aot_modules-1\">AOT_MODULES<\/h4>\n-<p>Generate AOT modules before testing for the specified module, or set\n-of modules. If multiple modules are specified, they should be separated\n-by space (or, to help avoid quoting issues, the special value\n-<code>%20<\/code>).<\/p>\n@@ -530,5 +523,0 @@\n-<h4 id=\"aot_modules-2\">AOT_MODULES<\/h4>\n-<p>Generate AOT modules before testing for the specified module, or set\n-of modules. If multiple modules are specified, they should be separated\n-by space (or, to help avoid quoting issues, the special value\n-<code>%20<\/code>).<\/p>\n@@ -578,1 +566,1 @@\n-tests should work. On Windows or MacOS, setting\n+tests should work. On Windows or macOS, setting\n@@ -613,1 +601,1 @@\n-fails on MacOS because it uses <code>CTRL + F1<\/code> key sequence to\n+fails on macOS because it uses <code>CTRL + F1<\/code> key sequence to\n","filename":"doc\/testing.html","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-descriptors, which clearly and unambigously show which tests will be run. As an\n-example, `:tier1` will expand to include all subcomponent test directories\n+descriptors, which clearly and unambiguously show which tests will be run. As\n+an example, `:tier1` will expand to include all subcomponent test directories\n@@ -154,1 +154,1 @@\n-  range of non-core JVM and JDK features\/components(for example, XML).\n+  range of non-core JVM and JDK features\/components (for example, XML).\n@@ -297,1 +297,1 @@\n-qoutes, e.g. `JTREG=\"...;...\"`. This will also make sure spaces are preserved,\n+quotes, e.g. `JTREG=\"...;...\"`. This will also make sure spaces are preserved,\n@@ -337,4 +337,0 @@\n-#### AOT_MODULES\n-\n-Applies to JTReg and GTest.\n-\n@@ -343,1 +339,1 @@\n-This keywords applies globally to the test runner system. If set to `true`, it\n+This keyword applies globally to the test runner system. If set to `true`, it\n@@ -483,6 +479,0 @@\n-#### AOT_MODULES\n-\n-Generate AOT modules before testing for the specified module, or set of\n-modules. If multiple modules are specified, they should be separated by space\n-(or, to help avoid quoting issues, the special value `%20`).\n-\n@@ -520,6 +510,0 @@\n-#### AOT_MODULES\n-\n-Generate AOT modules before testing for the specified module, or set of\n-modules. If multiple modules are specified, they should be separated by space\n-(or, to help avoid quoting issues, the special value `%20`).\n-\n@@ -590,1 +574,1 @@\n-in the environment before running tests should work. On Windows or MacOS,\n+in the environment before running tests should work. On Windows or macOS,\n@@ -638,1 +622,1 @@\n-fails on MacOS because it uses `CTRL + F1` key sequence to show or hide tooltip\n+fails on macOS because it uses `CTRL + F1` key sequence to show or hide tooltip\n","filename":"doc\/testing.md","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -504,0 +504,2 @@\n+  # We also make sure the javatmp directory exists, which is needed if a java\n+  # process (like javac) is using java.io.tmpdir.\n@@ -507,0 +509,1 @@\n+\t$(MKDIR) -p $(JAVA_TMP_DIR)\n","filename":"make\/InitSupport.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-      BASIC_LDFLAGS=\"-Wl,--exclude-libs,ALL\"\n+      BASIC_LDFLAGS=\"-fuse-ld=lld -Wl,--exclude-libs,ALL\"\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,0 +356,2 @@\n+JAVA_TMP_DIR = $(SUPPORT_OUTPUTDIR)\/javatmp\n+\n@@ -637,1 +639,2 @@\n-JAVA_FLAGS := @JAVA_FLAGS@\n+JAVA_FLAGS_TMPDIR := -Djava.io.tmpdir=$(JAVA_TMP_DIR)\n+JAVA_FLAGS := @JAVA_FLAGS@ $(JAVA_FLAGS_TMPDIR)\n","filename":"make\/autoconf\/spec.gmk.template","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    $1_JAVAC_CMD := $$(JAVAC)\n+    $1_JAVAC_CMD := $$(JAVAC) -J$$(JAVA_FLAGS_TMPDIR)\n@@ -214,1 +214,1 @@\n-    $1_JAVAC_CMD := $$(BUILD_JAVAC)\n+    $1_JAVAC_CMD := $$(BUILD_JAVAC) -J$$(JAVA_FLAGS_TMPDIR)\n","filename":"make\/common\/JavaCompilation.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,8 @@\n+SUNWprivate_1.1 {\n+  global:\n+    *;\n+\n+  local:\n+    _fini;\n+    _init;\n+};\n","filename":"make\/data\/hotspot-symbols\/version-script-clang.txt","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"","filename":"make\/data\/hotspot-symbols\/version-script-gcc.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/hotspot-symbols\/version-script.txt","status":"renamed"},{"patch":"@@ -50,0 +50,6 @@\n+JVM_ASFLAGS += \\\n+        -I$(TOPDIR)\/src\/hotspot\/os_cpu\/$(HOTSPOT_TARGET_OS)_$(HOTSPOT_TARGET_CPU_ARCH) \\\n+        -I$(TOPDIR)\/src\/hotspot\/os\/$(HOTSPOT_TARGET_OS) \\\n+        -I$(TOPDIR)\/src\/hotspot\/os\/$(HOTSPOT_TARGET_OS_TYPE) \\\n+        #\n+\n@@ -151,1 +157,1 @@\n-  HOTSPOT_VERSION_SCRIPT := $(TOPDIR)\/make\/data\/hotspot-symbols\/version-script.txt\n+  HOTSPOT_VERSION_SCRIPT := $(TOPDIR)\/make\/data\/hotspot-symbols\/version-script-$(TOOLCHAIN_TYPE).txt\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -154,0 +154,11 @@\n+        \/\/ Pull SwitchBootstraps and associated classes into the classlist\n+        record A(int a) { }\n+        record B(int b) { }\n+        Object o = new A(4711);\n+        int value = switch (o) {\n+            case A a -> a.a;\n+            case B b -> b.b;\n+            default -> 17;\n+        };\n+        LOGGER.log(Level.FINE, \"Value: \" + value);\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/classlist\/HelloClasslist.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+include Modules.gmk\n@@ -29,0 +30,8 @@\n+#\n+# Copy property and template files from share\/conf to CONF_DST_DIR\n+#\n+$(eval $(call SetupCopyFiles, COPY_XML_MODULE_CONF, \\\n+    DEST := $(CONF_DST_DIR), \\\n+    SRC := $(TOPDIR)\/src\/java.xml\/share\/conf, \\\n+    FILES := jaxp.properties jaxp-strict.properties.template, \\\n+))\n@@ -30,7 +39,1 @@\n-XML_LIB_SRC := $(TOPDIR)\/src\/java.xml\/share\/conf\n-\n-$(CONF_DST_DIR)\/jaxp.properties: $(XML_LIB_SRC)\/jaxp.properties\n-\t$(call install-file)\n-\n-TARGETS := $(CONF_DST_DIR)\/jaxp.properties\n-\n+TARGETS += $(COPY_XML_MODULE_CONF)\n","filename":"make\/modules\/java.xml\/Copy.gmk","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+# Most likely you want to select a specific test from test\/failure_handler\/test\n+# and manually inspect the results. This target does not actually verify\n+# anything about the failure_handler's output or even if it ran at all.\n+#\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    DISABLED_WARNINGS := restricted this-escape processing rawtypes cast \\\n+    DISABLED_WARNINGS := restricted this-escape processing rawtypes removal cast \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -71,0 +72,1 @@\n+import java.util.ArrayList;\n@@ -72,0 +74,4 @@\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -74,0 +80,1 @@\n+import javax.swing.plaf.nimbus.NimbusLookAndFeel;\n@@ -77,9 +84,0 @@\n-\/**\n- * Font2DTest.java\n- *\n- * @author Shinsuke Fukuda\n- * @author Ankit Patel [Conversion to Swing - 01\/07\/30]\n- *\/\n-\n-\/\/\/ Main Font2DTest Class\n-\n@@ -98,0 +96,6 @@\n+    private JPanel fontMenuPanel;\n+    private JPanel stylePanel;\n+    private LabelV2 fontMenuLabel = null;\n+    private LabelV2 styleLabel = null;\n+    private ChoiceV2 fontNameMenu;\n+    private ChoiceV2 fontSubFamilyMenu;\n@@ -114,0 +118,3 @@\n+    private JRadioButtonMenuItem familyAndStyleRBMI;\n+    private JRadioButtonMenuItem familyAndSubFamilyRBMI;\n+    private JRadioButtonMenuItem fontNameRBMI;\n@@ -129,0 +136,1 @@\n+    private String currentFontName = Font.DIALOG;\n@@ -136,0 +144,1 @@\n+    private static final Locale l = Locale.getDefault();\n@@ -146,0 +155,2 @@\n+        fontNameMenu = new ChoiceV2( this, false );\n+        fontSubFamilyMenu = new ChoiceV2( this, false );\n@@ -178,0 +189,40 @@\n+    private void addFontMenuToGBL(String labelText,\n+                                  JComponent menuContainer,\n+                                  GridBagLayout gbl,\n+                                  GridBagConstraints gbc,\n+                                  int leftInset,\n+                                  Container target) {\n+\n+        fontMenuLabel = new LabelV2(labelText);\n+        fontMenuLabel.setLabelFor(menuContainer);\n+        GridBagConstraints gbcLabel = (GridBagConstraints) gbc.clone();\n+        gbcLabel.insets = new Insets(2, leftInset, 2, 0);\n+        gbcLabel.gridwidth = 1;\n+        gbcLabel.weightx = 0;\n+        gbcLabel.anchor = GridBagConstraints.EAST;\n+        gbl.setConstraints(fontMenuLabel, gbcLabel);\n+        target.add(fontMenuLabel);\n+        gbl.setConstraints(menuContainer, gbc);\n+        target.add( menuContainer );\n+    }\n+\n+    private void addStyleMenuToGBL(String labelText,\n+                                  JComponent menuContainer,\n+                                  GridBagLayout gbl,\n+                                  GridBagConstraints gbc,\n+                                  int leftInset,\n+                                  Container target) {\n+\n+        styleLabel = new LabelV2(labelText);\n+        styleLabel.setLabelFor(menuContainer);\n+        GridBagConstraints gbcLabel = (GridBagConstraints) gbc.clone();\n+        gbcLabel.insets = new Insets(2, leftInset, 2, 0);\n+        gbcLabel.gridwidth = 1;\n+        gbcLabel.weightx = 0;\n+        gbcLabel.anchor = GridBagConstraints.EAST;\n+        gbl.setConstraints(styleLabel, gbcLabel);\n+        target.add(styleLabel);\n+        gbl.setConstraints(menuContainer, gbc);\n+        target.add(menuContainer);\n+    }\n+\n@@ -187,2 +238,10 @@\n-        addLabeledComponentToGBL( \"Font: \", fontMenu, gbl, gbc, this );\n-        addLabeledComponentToGBL( \"Size: \", sizeField, gbl, gbc, this );\n+        fontMenuPanel = new JPanel();\n+        fontMenuPanel.setLayout(new GridLayout());\n+        fontMenuPanel.add(fontMenu);\n+        addFontMenuToGBL(FAMILY_LABEL_TEXT, fontMenuPanel, gbl, gbc, 2, this );\n+\n+        stylePanel = new JPanel();\n+        stylePanel.setLayout(new GridLayout());\n+        stylePanel.add(styleMenu);\n+        addStyleMenuToGBL(STYLE_LABEL_TEXT, stylePanel, gbl, gbc, 40, this );\n+\n@@ -191,1 +250,1 @@\n-                                  transformMenu, gbl, gbc, this );\n+                                  transformMenu, gbl, gbc, 20, this );\n@@ -194,2 +253,2 @@\n-        addLabeledComponentToGBL( \"Range: \", rm, gbl, gbc, this );\n-        addLabeledComponentToGBL( \"Style: \", styleMenu, gbl, gbc, this );\n+        addLabeledComponentToGBL( \"Range: \", rm, gbl, gbc, 2, this );\n+        addLabeledComponentToGBL( \"Size: \", sizeField, gbl, gbc, 40, this );\n@@ -198,1 +257,1 @@\n-                                  transformMenuG2, gbl, gbc, this );\n+                                  transformMenuG2, gbl, gbc, 20, this );\n@@ -202,2 +261,2 @@\n-        addLabeledComponentToGBL( \"Method: \", methodsMenu, gbl, gbc, this );\n-        addLabeledComponentToGBL(\"\", null, gbl, gbc, this);\n+        addLabeledComponentToGBL( \"Method: \", methodsMenu, gbl, gbc, 2, this );\n+        addLabeledComponentToGBL(\"\", null, gbl, gbc, 40, this);\n@@ -205,0 +264,1 @@\n+\n@@ -206,1 +266,1 @@\n-        addLabeledComponentToGBL( \"Text to use:\", textMenu, gbl, gbc, this );\n+        addLabeledComponentToGBL( \"Text to use:\", textMenu, gbl, gbc, 20, this );\n@@ -208,1 +268,0 @@\n-        gbc.weightx=1;\n@@ -210,1 +269,0 @@\n-        gbc.fill = GridBagConstraints.HORIZONTAL;\n@@ -213,1 +271,1 @@\n-                                  contrastSlider, gbl, gbc, this);\n+                                  contrastSlider, gbl, gbc, 2, this);\n@@ -216,1 +274,0 @@\n-        gbc.fill = GridBagConstraints.NONE;\n@@ -218,1 +275,1 @@\n-                                  antiAliasMenu, gbl, gbc, this);\n+                                  antiAliasMenu, gbl, gbc, 40, this);\n@@ -223,1 +280,1 @@\n-                                  fracMetricsMenu, gbl, gbc, this);\n+                                  fracMetricsMenu, gbl, gbc, 20, this);\n@@ -244,0 +301,1 @@\n+                                           int leftInset,\n@@ -246,0 +304,1 @@\n+        l.setLabelFor(c);\n@@ -247,1 +306,5 @@\n-        gbcLabel.insets = new Insets( 2, 2, 2, 0 );\n+        if (gbcLabel.gridwidth == GridBagConstraints.REMAINDER) {\n+            gbcLabel.gridwidth = GridBagConstraints.RELATIVE;\n+        }\n+\n+        gbcLabel.insets = new Insets( 2, leftInset, 2, 0 );\n@@ -254,0 +317,1 @@\n+        gbcLabel.anchor = GridBagConstraints.EAST;\n@@ -280,0 +344,15 @@\n+        optionMenu.addSeparator();\n+        familyAndStyleRBMI = new JRadioButtonMenuItem(\"Select font using Family Name and Style\");\n+        familyAndStyleRBMI.addActionListener(this);\n+        familyAndSubFamilyRBMI = new JRadioButtonMenuItem(\"Select font using Family Name and SubFamily\");\n+        familyAndSubFamilyRBMI.addActionListener(this);\n+        fontNameRBMI = new JRadioButtonMenuItem(\"Select font using Full Name\");\n+        fontNameRBMI.addActionListener(this);\n+        ButtonGroup bg = new ButtonGroup();\n+        bg.add(familyAndStyleRBMI);\n+        bg.add(familyAndSubFamilyRBMI);\n+        bg.add(fontNameRBMI);\n+        familyAndStyleRBMI.setSelected(true);\n+        optionMenu.add(familyAndStyleRBMI);\n+        optionMenu.add(familyAndSubFamilyRBMI);\n+        optionMenu.add(fontNameRBMI);\n@@ -289,2 +368,5 @@\n-        String[] fontList =\n-          GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        String[] fontList = getAllFamilyNames();\n+        for (int i = 0; i < fontList.length; i++ ) {\n+            fontMenu.addItem( fontList[i] );\n+        }\n+        fontMenu.setSelectedItem(\"Dialog\");\n@@ -292,3 +374,5 @@\n-        for ( int i = 0; i < fontList.length; i++ )\n-          fontMenu.addItem( fontList[i] );\n-        fontMenu.setSelectedItem( \"Dialog\" );\n+        fontList = getAllFontNames();\n+        for (int i = 0; i < fontList.length; i++ ) {\n+           fontNameMenu.addItem( fontList[i] );\n+        }\n+        fontNameMenu.setSelectedItem(\"Dialog\");\n@@ -650,0 +734,4 @@\n+                fontSelectionType + \"\\n\" +\n+                (String)fontMenu.getSelectedItem() + \"\\n\" +\n+                (String)fontNameMenu.getSelectedItem() + \"\\n\" +\n+                (String)fontSubFamilyMenu.getSelectedItem() + \"\\n\" +\n@@ -727,0 +815,4 @@\n+            int fontSelType = Integer.parseInt( perLine.nextToken() );\n+            String fmItem = perLine.nextToken();\n+            String fnmItem = perLine.nextToken();\n+            String fsmItem = perLine.nextToken();\n@@ -759,1 +851,5 @@\n-            fontMenu.setSelectedItem( fontNameOpt );\n+            currentFontName = fontNameOpt;\n+            setFontSelectionType(fontSelType);\n+            fontMenu.setSelectedItem( fmItem );\n+            fontNameMenu.setSelectedItem( fnmItem );\n+            fontSubFamilyMenu.setSelectedItem( fsmItem );\n@@ -822,0 +918,104 @@\n+    static final int FAMILY_AND_STYLE     = 1;\n+    static final int FONT_NAME            = 2;\n+    static final int FAMILY_AND_SUBFAMILY = 3;\n+    static int fontSelectionType = FAMILY_AND_STYLE;\n+\n+    static final String FAMILY_LABEL_TEXT = \"Font Family:\";\n+    static final String NAME_LABEL_TEXT = \"Font Name:\";\n+    static final String STYLE_LABEL_TEXT = \"Style:\";\n+    static final String SUBFAMILY_LABEL_TEXT = \"Subfamily:\";\n+\n+    void setUseFamilyAndStyle() {\n+        if (fontSelectionType == FAMILY_AND_STYLE) {\n+            return;\n+        }\n+        fontMenuLabel.setText(FAMILY_LABEL_TEXT);\n+        fontMenuPanel.removeAll();\n+        fontMenuPanel.add(fontMenu);\n+        if (fontSelectionType == FAMILY_AND_SUBFAMILY) {\n+            styleLabel.setText(STYLE_LABEL_TEXT);\n+            stylePanel.removeAll();\n+            stylePanel.add(styleMenu);\n+        }\n+        fontSelectionType = FAMILY_AND_STYLE;\n+        if (!familyAndStyleRBMI.isSelected()) {\n+           familyAndStyleRBMI.setSelected(true);\n+        }\n+        styleMenu.setSelectedIndex(0);\n+        currentFontName = (String)fontMenu.getSelectedItem();\n+        fp.setFontParams(currentFontName,\n+                         Float.parseFloat(sizeField.getText()),\n+                         0, \/\/ want to reset style to PLAIN\n+                         transformMenu.getSelectedIndex());\n+        revalidate();\n+        repaint();\n+    }\n+\n+    void setUseFontName() {\n+        if (fontSelectionType == FONT_NAME) {\n+            return;\n+        }\n+        fontMenuLabel.setText(NAME_LABEL_TEXT);\n+        fontMenuPanel.removeAll();\n+        fontMenuPanel.add(fontNameMenu);\n+        if (fontSelectionType == FAMILY_AND_SUBFAMILY) {\n+            styleLabel.setText(STYLE_LABEL_TEXT);\n+            stylePanel.removeAll();\n+            stylePanel.add(styleMenu);\n+        }\n+        fontSelectionType = FONT_NAME;\n+        if (!fontNameRBMI.isSelected()) {\n+           fontNameRBMI.setSelected(true);\n+        }\n+        styleMenu.setSelectedIndex(0);\n+        currentFontName = (String)fontNameMenu.getSelectedItem();\n+        fp.setFontParams(currentFontName,\n+                         Float.parseFloat(sizeField.getText()),\n+                         0, \/\/ want to reset style to PLAIN\n+                         transformMenu.getSelectedIndex());\n+        revalidate();\n+        repaint();\n+    }\n+\n+    void setUseFamilyAndSubFamily() {\n+        if (fontSelectionType == FAMILY_AND_SUBFAMILY) {\n+            return;\n+        }\n+        fontMenuLabel.setText(FAMILY_LABEL_TEXT);\n+        fontMenuPanel.removeAll();\n+        fontMenuPanel.add(fontMenu);\n+        styleLabel.setText(SUBFAMILY_LABEL_TEXT);\n+        stylePanel.removeAll();\n+        styleMenu.setSelectedIndex(0);\n+        String family = (String)fontMenu.getSelectedItem();\n+        updateSubFamilyMenu(family);\n+        stylePanel.add(fontSubFamilyMenu);\n+        fontSelectionType = FAMILY_AND_SUBFAMILY;\n+        if (!familyAndSubFamilyRBMI.isSelected()) {\n+           familyAndSubFamilyRBMI.setSelected(true);\n+        }\n+        String subname = (String)fontSubFamilyMenu.getSelectedItem();\n+        Font font = FontFamily.getFont(family, subname);\n+        currentFontName = (font != null) ? font.getFontName(l) : family;\n+        fp.setFontParams(currentFontName,\n+                         Float.parseFloat(sizeField.getText()),\n+                         0, \/\/ want to reset style to PLAIN\n+                         transformMenu.getSelectedIndex());\n+        revalidate();\n+        repaint();\n+    }\n+\n+    void setFontSelectionType(int fsType) {\n+         switch (fsType) {\n+             case FAMILY_AND_STYLE     :\n+                  setUseFamilyAndStyle();\n+                  break;\n+             case FONT_NAME            :\n+                  setUseFontName();\n+                  break;\n+             case FAMILY_AND_SUBFAMILY :\n+                  setUseFamilyAndSubFamily();\n+                  break;\n+         }\n+    }\n+\n@@ -833,1 +1033,8 @@\n-            if ( itemName.equals( \"Save Selected Options...\" )) {\n+            if (source == familyAndStyleRBMI) {\n+               setUseFamilyAndStyle();\n+            } else if (source == familyAndSubFamilyRBMI) {\n+               setUseFamilyAndSubFamily();\n+            } else if (source == fontNameRBMI) {\n+               setUseFontName();\n+            }\n+            else if ( itemName.equals( \"Save Selected Options...\" )) {\n@@ -875,2 +1082,2 @@\n-            if ( tf == sizeField )\n-              fp.setFontParams( fontMenu.getSelectedItem(),\n+            if ( tf == sizeField ) {\n+               fp.setFontParams(currentFontName,\n@@ -880,0 +1087,1 @@\n+               }\n@@ -904,1 +1112,35 @@\n-            if ( c == fontMenu || c == styleMenu || c == transformMenu ) {\n+            if ( c == fontMenu || c == fontNameMenu || c == fontSubFamilyMenu ||\n+                 c == styleMenu || c == transformMenu )\n+            {\n+                if (c == fontNameMenu) {\n+                   currentFontName = (String)fontNameMenu.getSelectedItem();\n+                }\n+                else if ((c == fontMenu) && (fontSelectionType == FAMILY_AND_STYLE)) {\n+                   currentFontName = (String)fontMenu.getSelectedItem();\n+                }\n+                else if ((c == fontMenu) && (fontSelectionType == FAMILY_AND_SUBFAMILY)) {\n+                   String family = (String)fontMenu.getSelectedItem();\n+                   updateSubFamilyMenu(family);\n+                   String subname = (String)fontSubFamilyMenu.getSelectedItem();\n+                   Font font = FontFamily.getFont(family, subname);\n+                   if (font == null) return;\n+                   currentFontName = font.getFontName(l);\n+                }\n+                else if (c == fontSubFamilyMenu) {\n+                   \/*\n+                    * When switching families, all items are removed from the sub family list.\n+                    * This triggers a synchronous recursive ActionEvent on the EDT, which should\n+                    * be ignored here, the code removes them adds the new items and will then\n+                    *  use the new default selected item.\n+                    * If we do not return, we'll not find a match and can get an NPE.\n+                    * This feels unsatisfactory, but it works.\n+                    *\/\n+                   if (fontSubFamilyMenu.getItemCount() == 0) {\n+                       return;\n+                   }\n+                   String family = (String)fontMenu.getSelectedItem();\n+                   String subname = (String)fontSubFamilyMenu.getSelectedItem();\n+                   Font font = FontFamily.getFont(family, subname);\n+                   if (font == null) return;\n+                   currentFontName = font.getFontName(l);\n+                }\n@@ -915,1 +1157,1 @@\n-                fp.setFontParams(fontMenu.getSelectedItem(),\n+                fp.setFontParams(currentFontName,\n@@ -1011,0 +1253,166 @@\n+    static class FontFamily {\n+\n+        static Map<String, FontFamily> familyMap = new HashMap<>();\n+        private static Locale l = Locale.getDefault();\n+        private List<Font> fonts = new ArrayList<>();\n+        private List<String> subFamilyNames = new ArrayList<>();\n+        private Map<String, Font> nameToFontMap = new HashMap<>();\n+        private String familyName;\n+\n+        private FontFamily(String name) {\n+           this.familyName = name;\n+       }\n+\n+       String stripFamily(String family, String fullName) {\n+           if (family.equals(fullName)) {\n+               return \"\";\n+           }\n+           char[] familyChars = family.toCharArray();\n+           char[] fullChars = fullName.toCharArray();\n+           int familyIndex = 0;\n+           int fullIndex = 0;\n+           \/\/ there's probably a clever regexp way to do this\n+           \/\/ iterate over the chars in the family , if they are the same\n+           \/\/ keep going, if there's a '-' or ' ', skip it. In the font name,\n+           \/\/ do the same. If you reach the end of the family without some\n+           \/\/ other diff, return what's left of the fullName.\n+           while (familyIndex < familyChars.length && fullIndex < fullChars.length) {\n+           \/\/while (familyIndex < familyChars.length) {\n+              if (fullIndex == fullChars.length) {\n+                  System.err.println(\"WEIRD FONT \" + family + \" \" + fullName);\n+                  break;\n+              }\n+              if (familyChars[familyIndex] == fullChars[fullIndex]) {\n+                  familyIndex++; fullIndex++;\n+              }\n+              else if (familyChars[familyIndex] == ' ' && fullChars[fullIndex] == '-') {\n+                  familyIndex++; fullIndex++;\n+              }\n+              else if (familyChars[familyIndex] == '-' && fullChars[fullIndex] == ' ') {\n+                  familyIndex++; fullIndex++;\n+              }\n+              else if (familyChars[familyIndex] == ' ' || familyChars[familyIndex] == '-') {\n+                  familyIndex++;\n+              }\n+              else if (fullChars[fullIndex] == ' ' || fullChars[fullIndex] == '-') {\n+                  fullIndex++;\n+              } else {\n+                  break;\n+              }\n+           }\n+           if (fullIndex == fullChars.length) {\n+               return fullName;\n+           } else {\n+               return fullName.substring(fullIndex);\n+           }\n+       }\n+\n+       \/*\n+        * Getting the string to display here can be an art.\n+        * If the family is \"Arial Black\", then for a regular font, the\n+        * full name may be \"Arial Black\", or \"Arial-Black\", as reported on macOS.\n+        * For this case for the specific font might want to display the\n+        * full name, or synthesise \"Regular\". But to do that we have to\n+        * recognise that ' ' to '-' mapping.\n+        * For \"Arial Black Italic\" (Arial-Black-Italic) we want to be able to\n+        * trim so we display just \"Italic\".\n+        * Then we need to be able to map the text selection back to the\n+        * right font.\n+        *\/\n+       void add(Font f) {\n+           String fontName = f.getFontName(l);\n+           int flen = familyName.length();\n+           int nlen = fontName.length();\n+           String sfn;\n+\n+           if (fontName.equals(familyName)) {\n+               sfn = \"Regular\";\n+           }\n+           else {\n+               sfn = stripFamily(familyName, fontName);\n+               sfn = sfn.replace('-', ' ');\n+           }\n+\n+           fonts.add(f);\n+           subFamilyNames.add(sfn);\n+           nameToFontMap.put(sfn, f);\n+       }\n+\n+       String[] getSubFamilyNames() {\n+           return subFamilyNames.stream().sorted().toArray(String[]::new);\n+       }\n+\n+\n+       Font getFontForSubFamilyName(String name) {\n+           return nameToFontMap.get(name);\n+       }\n+\n+       static FontFamily getFontFamily(String name) {\n+           return familyMap.get(name);\n+       }\n+\n+       static FontFamily createFontFamily(String name) {\n+           FontFamily f = familyMap.get(name);\n+           if (f == null) {\n+               f = new FontFamily(name);\n+               familyMap.put(name, f);\n+           }\n+           return f;\n+       }\n+\n+       \/*\n+        * familyName must be a name of an existing FontFamily\n+        * name, must be a valid \"subFamilyName\" within that FontFamily\n+        * as returned by getSubFamilyNames()\n+        *\/\n+       static Font getFont(String familyName, String subFamilyName) {\n+           FontFamily family = getFontFamily(familyName);\n+           return family.getFontForSubFamilyName(subFamilyName);\n+        }\n+    }\n+\n+    static String[] familyNames;\n+    static Font[] allFonts;\n+    static List<String> allFontNames;\n+    static Map<String, FontFamily> familyMap = new HashMap<>();\n+\n+    private static void buildFontInfo() {\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        familyNames = ge.getAvailableFontFamilyNames();\n+        allFonts = ge.getAllFonts();\n+        allFontNames = new ArrayList<String>();\n+        Locale l = Locale.getDefault();\n+        for (Font f : allFonts) {\n+           allFontNames.add(f.getFontName(l));\n+           String family = f.getFamily(l);\n+           FontFamily ff = FontFamily.getFontFamily(family);\n+           if (ff == null) {\n+              ff = FontFamily.createFontFamily(family);\n+           }\n+           ff.add(f);\n+        }\n+    }\n+\n+    String getFontNameFor(String family, String subFamily) {\n+         return family + \" \" + subFamily;\n+    }\n+\n+    void updateSubFamilyMenu(String name) {\n+         FontFamily family = FontFamily.getFontFamily(name);\n+         fontSubFamilyMenu.removeAllItems();\n+\n+         String [] sfNames = family.getSubFamilyNames();\n+         for (int i=0; i<sfNames.length; i++) {\n+             fontSubFamilyMenu.addItem(sfNames[i]);\n+         }\n+         fontSubFamilyMenu.setSelectedIndex(0); \/\/ better be at least one !\n+    }\n+\n+    static String[] getAllFontNames() {\n+        return allFontNames.stream().sorted().toArray(String[]::new);\n+    }\n+\n+   static String[] getAllFamilyNames() {\n+       return familyNames;\n+   }\n+\n@@ -1014,2 +1422,2 @@\n-        if(argv.length > 0) {\n-            if(argv[0].equalsIgnoreCase(\"-disablecandisplaycheck\") ||\n+        if (argv.length > 0) {\n+            if (argv[0].equalsIgnoreCase(\"-disablecandisplaycheck\") ||\n@@ -1024,11 +1432,17 @@\n-        UIManager.put(\"swing.boldMetal\", Boolean.FALSE);\n-        final JFrame f = new JFrame( \"Font2DTest\" );\n-        final Font2DTest f2dt = new Font2DTest( f);\n-        f.addWindowListener( new WindowAdapter() {\n-            public void windowOpening( WindowEvent e ) { f2dt.repaint(); }\n-            public void windowClosing( WindowEvent e ) { System.exit(0); }\n-        });\n-\n-        f.getContentPane().add( f2dt );\n-        f.pack();\n-        f.setVisible(true);\n+        buildFontInfo();\n+        try {\n+           UIManager.setLookAndFeel(new NimbusLookAndFeel());\n+            SwingUtilities.invokeAndWait(() -> {\n+                final JFrame f = new JFrame( \"Font2DTest\" );\n+                final Font2DTest f2dt = new Font2DTest( f);\n+                f.addWindowListener( new WindowAdapter() {\n+                    public void windowOpening( WindowEvent e ) { f2dt.repaint(); }\n+                    public void windowClosing( WindowEvent e ) { System.exit(0); }\n+                });\n+\n+                f.getContentPane().add( f2dt );\n+                f.pack();\n+                f.setVisible(true);\n+            });\n+        } catch (UnsupportedLookAndFeelException|InterruptedException|InvocationTargetException e) {\n+        }\n","filename":"src\/demo\/share\/jfc\/Font2DTest\/Font2DTest.java","additions":464,"deletions":50,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -743,1 +743,2 @@\n-              verticalBar.setEnabled( false );\n+              \/\/ the disabled scroll bar looks odd with Nimbus L&F.\n+              verticalBar.setEnabled( true );\n","filename":"src\/demo\/share\/jfc\/Font2DTest\/FontPanel.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-  __ lsr(tmp1, tmp1, HeapRegion::LogOfHRGrainBytes);\n+  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,15 +300,0 @@\n-void BarrierSetAssembler::incr_allocated_bytes(MacroAssembler* masm,\n-                                               Register var_size_in_bytes,\n-                                               int con_size_in_bytes,\n-                                               Register t1) {\n-  assert(t1->is_valid(), \"need temp reg\");\n-\n-  __ ldr(t1, Address(rthread, in_bytes(JavaThread::allocated_bytes_offset())));\n-  if (var_size_in_bytes->is_valid()) {\n-    __ add(t1, t1, var_size_in_bytes);\n-  } else {\n-    __ add(t1, t1, con_size_in_bytes);\n-  }\n-  __ str(t1, Address(rthread, in_bytes(JavaThread::allocated_bytes_offset())));\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,5 +47,0 @@\n-private:\n-  void incr_allocated_bytes(MacroAssembler* masm,\n-                            Register var_size_in_bytes, int con_size_in_bytes,\n-                            Register t1 = noreg);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n@@ -117,7 +116,3 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ ldrw(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ ldrb(tmp1, in_progress);\n-  }\n-  __ cbzw(tmp1, done);\n+  Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+  __ ldrb(tmp1, gc_state);\n+  __ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-\/\/ the bit layout of XForwardingEntry or Partial array entry (see XMarkStackEntry) in mark stack\n+\/\/ the bit layout of ZForwardingEntry or Partial array entry (see ZMarkStackEntry) in mark stack\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zAddress_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4038,1 +4038,1 @@\n- * r5: zlen\n+ * r5: tmp0\n@@ -4049,1 +4049,1 @@\n-                                     Register z, Register zlen,\n+                                     Register z, Register tmp0,\n@@ -4053,1 +4053,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+  assert_different_registers(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, product_hi);\n@@ -4062,1 +4062,1 @@\n-  const Register x_xstart = zlen;  \/\/ reuse register\n+  const Register x_xstart = tmp0;\n@@ -4078,3 +4078,3 @@\n-  movw(idx, ylen);      \/\/ idx = ylen;\n-  movw(kdx, zlen);      \/\/ kdx = xlen+ylen;\n-  mov(carry, zr);       \/\/ carry = 0;\n+  movw(idx, ylen);       \/\/ idx = ylen;\n+  addw(kdx, xlen, ylen); \/\/ kdx = xlen+ylen;\n+  mov(carry, zr);        \/\/ carry = 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1593,1 +1593,1 @@\n-                       Register zlen, Register tmp1, Register tmp2, Register tmp3,\n+                       Register tmp0, Register tmp1, Register tmp2, Register tmp3,\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4670,1 +4670,0 @@\n-   *    c_rarg5   - z length\n@@ -4682,1 +4681,0 @@\n-    const Register zlen  = r5;\n@@ -4684,0 +4682,1 @@\n+    const Register tmp0  = r5;\n@@ -4694,1 +4693,1 @@\n-    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n@@ -4712,1 +4711,0 @@\n-    const Register zlen  = r3;\n@@ -4716,0 +4714,1 @@\n+    const Register tmp0  = r3;\n@@ -4730,1 +4729,1 @@\n-    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  __ movs(tmp1, AsmOperand(tmp1, lsr, HeapRegion::LogOfHRGrainBytes));\n+  __ movs(tmp1, AsmOperand(tmp1, lsr, G1HeapRegion::LogOfHRGrainBytes));\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,40 +162,0 @@\n-void BarrierSetAssembler::incr_allocated_bytes(MacroAssembler* masm, RegisterOrConstant size_in_bytes, Register tmp) {\n-  \/\/ Bump total bytes allocated by this thread\n-  Label done;\n-\n-  \/\/ Borrow the Rthread for alloc counter\n-  Register Ralloc = Rthread;\n-  __ add(Ralloc, Ralloc, in_bytes(JavaThread::allocated_bytes_offset()));\n-  __ ldr(tmp, Address(Ralloc));\n-  __ adds(tmp, tmp, size_in_bytes);\n-  __ str(tmp, Address(Ralloc), cc);\n-  __ b(done, cc);\n-\n-  \/\/ Increment the high word and store single-copy atomically (that is an unlikely scenario on typical embedded systems as it means >4GB has been allocated)\n-  \/\/ To do so ldrd\/strd instructions used which require an even-odd pair of registers. Such a request could be difficult to satisfy by\n-  \/\/ allocating those registers on a higher level, therefore the routine is ready to allocate a pair itself.\n-  Register low, high;\n-  \/\/ Select ether R0\/R1 or R2\/R3\n-\n-  if (size_in_bytes.is_register() && (size_in_bytes.as_register() == R0 || size_in_bytes.as_register() == R1)) {\n-    low = R2;\n-    high  = R3;\n-  } else {\n-    low = R0;\n-    high  = R1;\n-  }\n-  __ push(RegisterSet(low, high));\n-\n-  __ ldrd(low, Address(Ralloc));\n-  __ adds(low, low, size_in_bytes);\n-  __ adc(high, high, 0);\n-  __ strd(low, Address(Ralloc));\n-\n-  __ pop(RegisterSet(low, high));\n-\n-  __ bind(done);\n-\n-  \/\/ Unborrow the Rthread\n-  __ sub(Rthread, Ralloc, in_bytes(JavaThread::allocated_bytes_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -43,6 +43,0 @@\n-private:\n-  void incr_allocated_bytes(MacroAssembler* masm,\n-    RegisterOrConstant size_in_bytes,\n-    Register           tmp\n-);\n-\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -81,1 +81,1 @@\n-  if (is_power_of_2(((jlong) ui16)+1)) {\n+  if (is_power_of_2(((unsigned long) ui16)+1)) {\n@@ -83,1 +83,1 @@\n-    clrldi(a, s, 64 - log2i_exact((((jlong) ui16)+1)));\n+    clrldi(a, s, 64 - log2i_exact((((unsigned long) ui16)+1)));\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n-      (is_power_of_2(int_or_long_const+1) ||\n+      (is_power_of_2((unsigned long)int_or_long_const+1) ||\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  Register t1,                         \/\/ temp register, must be global register for incr_allocated_bytes\n+  Register t1,                         \/\/ temp register\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  __ srdi_(tmp1, tmp1, HeapRegion::LogOfHRGrainBytes);\n+  __ srdi_(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2212,3 +2212,0 @@\n-void MacroAssembler::incr_allocated_bytes(RegisterOrConstant size_in_bytes, Register t1, Register t2) {\n-  unimplemented(\"incr_allocated_bytes\");\n-}\n@@ -3904,1 +3901,1 @@\n-                                     Register z, Register zlen,\n+                                     Register z,\n@@ -3915,1 +3912,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen,\n+  assert_different_registers(x, xlen, y, ylen, z,\n@@ -3917,1 +3914,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen,\n+  assert_different_registers(x, xlen, y, ylen, z,\n@@ -3919,1 +3916,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen,\n+  assert_different_registers(x, xlen, y, ylen, z,\n@@ -3947,1 +3944,1 @@\n-  mr_if_needed(kdx, zlen);        \/\/ kdx = xlen + ylen\n+  add(kdx, xlen, ylen);           \/\/ kdx = xlen + ylen\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -629,1 +629,0 @@\n-  void incr_allocated_bytes(RegisterOrConstant size_in_bytes, Register t1, Register t2);\n@@ -788,1 +787,1 @@\n-                       Register z, Register zlen,\n+                       Register z,\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3207,1 +3207,0 @@\n-  \/\/    R8 - z length\n@@ -3220,1 +3219,0 @@\n-    const Register zlen  = R8;\n@@ -3243,1 +3241,0 @@\n-    __ clrldi(zlen, zlen, 32);\n@@ -3256,1 +3253,1 @@\n-    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5,\n+    __ multiply_to_len(x, xlen, y, ylen, z, tmp1, tmp2, tmp3, tmp4, tmp5,\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1866,1 +1866,1 @@\n-  \/\/ Vector Bit-manipulation used in Cryptography (Zvkb) Extension\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbb) Extension\n@@ -1868,2 +1868,0 @@\n-  INSN(vclmul_vv,  0b1010111, 0b010, 0b001100);\n-  INSN(vclmulh_vv, 0b1010111, 0b010, 0b001101);\n@@ -1873,0 +1871,39 @@\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbc) Extension\n+  INSN(vclmul_vv,  0b1010111, 0b010, 0b001100);\n+  INSN(vclmulh_vv, 0b1010111, 0b010, 0b001101);\n+\n+#undef INSN\n+\n+#define INSN(NAME, op, funct3, funct6)                                                             \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, Register Rs1, VectorMask vm = unmasked) {       \\\n+    patch_VArith(op, Vd, funct3, Rs1->raw_encoding(), Vs2, vm, funct6);                            \\\n+  }\n+\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbb) Extension\n+  INSN(vrol_vx,    0b1010111, 0b100, 0b010101);\n+  INSN(vror_vx,    0b1010111, 0b100, 0b010100);\n+\n+#undef INSN\n+\n+#define patch_VArith_imm6(op, Reg, funct3, Reg_or_Imm5, I5, Vs2, vm, funct6)   \\\n+    unsigned insn = 0;                                                         \\\n+    patch((address)&insn, 6, 0, op);                                           \\\n+    patch((address)&insn, 14, 12, funct3);                                     \\\n+    patch((address)&insn, 19, 15, Reg_or_Imm5);                                \\\n+    patch((address)&insn, 25, vm);                                             \\\n+    patch((address)&insn, 26, I5);                                             \\\n+    patch((address)&insn, 31, 27, funct6);                                     \\\n+    patch_reg((address)&insn, 7, Reg);                                         \\\n+    patch_reg((address)&insn, 20, Vs2);                                        \\\n+    emit(insn)\n+\n+#define INSN(NAME, op, funct3, funct6)                                                             \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, uint32_t imm, VectorMask vm = unmasked) {       \\\n+    guarantee(is_uimm6(imm), \"uimm is invalid\");                                                   \\\n+    patch_VArith_imm6(op, Vd, funct3, (uint32_t)(imm & 0x1f), (uint32_t)((imm >> 5) & 0x1), Vs2, vm, funct6);  \\\n+  }\n+\n+  \/\/ Vector Bit-manipulation used in Cryptography (Zvbb) Extension\n+  \/\/ NOTE: there is no corresponding vrol.vi supplied by the extension, but it can be emulated with vror.vi easily.\n+  INSN(vror_vi,    0b1010111, 0b011, 0b01010);\n+\n@@ -1874,0 +1911,1 @@\n+#undef patch_VArith_imm6\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    __ movptr(tmp, addr->disp());\n+    __ movptr(tmp, (address)addr->disp());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2765,0 +2765,4 @@\n+    case BoolTest::ule: vmsleu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::uge: vmsgeu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ult: vmsltu_vv(vd, src1, src2, vm); break;\n+    case BoolTest::ugt: vmsgtu_vv(vd, src1, src2, vm); break;\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  __ srli(tmp1, tmp1, HeapRegion::LogOfHRGrainBytes);\n+  __ srli(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,15 +214,0 @@\n-void BarrierSetAssembler::incr_allocated_bytes(MacroAssembler* masm,\n-                                               Register var_size_in_bytes,\n-                                               int con_size_in_bytes,\n-                                               Register tmp1) {\n-  assert(tmp1->is_valid(), \"need temp reg\");\n-\n-  __ ld(tmp1, Address(xthread, in_bytes(JavaThread::allocated_bytes_offset())));\n-  if (var_size_in_bytes->is_valid()) {\n-    __ add(tmp1, tmp1, var_size_in_bytes);\n-  } else {\n-    __ add(tmp1, tmp1, con_size_in_bytes);\n-  }\n-  __ sd(tmp1, Address(xthread, in_bytes(JavaThread::allocated_bytes_offset())));\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -48,5 +48,0 @@\n-private:\n-  void incr_allocated_bytes(MacroAssembler* masm,\n-                            Register var_size_in_bytes, int con_size_in_bytes,\n-                            Register t1 = noreg);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n@@ -120,7 +119,4 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ lwu(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ lbu(tmp1, in_progress);\n-  }\n-  __ beqz(tmp1, done);\n+  Address gc_state(xthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+  __ lbu(t1, gc_state);\n+  __ test_bit(t1, t1, ShenandoahHeap::MARKING_BITPOS);\n+  __ beqz(t1, done);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,2 +45,4 @@\n-  } else if (inst->is_movptr()) {\n-    return pc_offset + NativeMovConstReg::movptr_instruction_size;\n+  } else if (inst->is_movptr1()) {\n+    return pc_offset + NativeMovConstReg::movptr1_instruction_size;\n+  } else if (inst->is_movptr2()) {\n+    return pc_offset + NativeMovConstReg::movptr2_instruction_size;\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -643,1 +643,1 @@\n-  movptr(t0, 0, offset);\n+  movptr(t0, 0, offset, t1); \/\/ lui + lui + slli + add\n@@ -1428,2 +1428,1 @@\n-static int patch_addr_in_movptr(address branch, address target) {\n-  const int MOVPTR_INSTRUCTIONS_NUM = 6;                                        \/\/ lui + addi + slli + addi + slli + addi\/jalr\/load\n+static int patch_addr_in_movptr1(address branch, address target) {\n@@ -1436,1 +1435,21 @@\n-  return MOVPTR_INSTRUCTIONS_NUM * NativeInstruction::instruction_size;\n+  return NativeMovConstReg::movptr1_instruction_size;\n+}\n+\n+static int patch_addr_in_movptr2(address instruction_address, address target) {\n+  uintptr_t addr = (uintptr_t)target;\n+\n+  assert(addr < (1ull << 48), \"48-bit overflow in address constant\");\n+  unsigned int upper18 = (addr >> 30ull);\n+  int lower30 = (addr & 0x3fffffffu);\n+  int low12 = (lower30 << 20) >> 20;\n+  int mid18 = ((lower30 - low12) >> 12);\n+\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 0), 31, 12, (upper18 & 0xfffff)); \/\/ Lui\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 1), 31, 12, (mid18   & 0xfffff)); \/\/ Lui\n+                                                                                                                  \/\/ Slli\n+                                                                                                                  \/\/ Add\n+  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 4), 31, 20, low12 & 0xfff);      \/\/ Addi\/Jalr\/Load\n+\n+  assert(MacroAssembler::target_addr_for_insn(instruction_address) == target, \"Must be\");\n+\n+  return NativeMovConstReg::movptr2_instruction_size;\n@@ -1510,1 +1529,1 @@\n-static address get_target_of_movptr(address insn_addr) {\n+static address get_target_of_movptr1(address insn_addr) {\n@@ -1519,0 +1538,11 @@\n+static address get_target_of_movptr2(address insn_addr) {\n+  assert_cond(insn_addr != nullptr);\n+  int32_t upper18 = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 0), 31, 12)) & 0xfffff); \/\/ Lui\n+  int32_t mid18   = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 1), 31, 12)) & 0xfffff); \/\/ Lui\n+                                                                                                                       \/\/ 2                              \/\/ Slli\n+                                                                                                                       \/\/ 3                              \/\/ Add\n+  int32_t low12  = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 4), 31, 20))); \/\/ Addi\/Jalr\/Load.\n+  address ret = (address)(((intptr_t)upper18<<30ll) + ((intptr_t)mid18<<12ll) + low12);\n+  return ret;\n+}\n+\n@@ -1538,14 +1568,16 @@\n-int MacroAssembler::pd_patch_instruction_size(address branch, address target) {\n-  assert_cond(branch != nullptr);\n-  int64_t offset = target - branch;\n-  if (NativeInstruction::is_jal_at(branch)) {                         \/\/ jal\n-    return patch_offset_in_jal(branch, offset);\n-  } else if (NativeInstruction::is_branch_at(branch)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n-    return patch_offset_in_conditional_branch(branch, offset);\n-  } else if (NativeInstruction::is_pc_relative_at(branch)) {          \/\/ auipc, addi\/jalr\/load\n-    return patch_offset_in_pc_relative(branch, offset);\n-  } else if (NativeInstruction::is_movptr_at(branch)) {               \/\/ movptr\n-    return patch_addr_in_movptr(branch, target);\n-  } else if (NativeInstruction::is_li64_at(branch)) {                 \/\/ li64\n-    return patch_imm_in_li64(branch, target);\n-  } else if (NativeInstruction::is_li32_at(branch)) {                 \/\/ li32\n+int MacroAssembler::pd_patch_instruction_size(address instruction_address, address target) {\n+  assert_cond(instruction_address != nullptr);\n+  int64_t offset = target - instruction_address;\n+  if (NativeInstruction::is_jal_at(instruction_address)) {                         \/\/ jal\n+    return patch_offset_in_jal(instruction_address, offset);\n+  } else if (NativeInstruction::is_branch_at(instruction_address)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n+    return patch_offset_in_conditional_branch(instruction_address, offset);\n+  } else if (NativeInstruction::is_pc_relative_at(instruction_address)) {          \/\/ auipc, addi\/jalr\/load\n+    return patch_offset_in_pc_relative(instruction_address, offset);\n+  } else if (NativeInstruction::is_movptr1_at(instruction_address)) {              \/\/ movptr1\n+    return patch_addr_in_movptr1(instruction_address, target);\n+  } else if (NativeInstruction::is_movptr2_at(instruction_address)) {              \/\/ movptr2\n+    return patch_addr_in_movptr2(instruction_address, target);\n+  } else if (NativeInstruction::is_li64_at(instruction_address)) {                 \/\/ li64\n+    return patch_imm_in_li64(instruction_address, target);\n+  } else if (NativeInstruction::is_li32_at(instruction_address)) {                 \/\/ li32\n@@ -1553,2 +1585,2 @@\n-    return patch_imm_in_li32(branch, (int32_t)imm);\n-  } else if (NativeInstruction::is_li16u_at(branch)) {\n+    return patch_imm_in_li32(instruction_address, (int32_t)imm);\n+  } else if (NativeInstruction::is_li16u_at(instruction_address)) {\n@@ -1556,1 +1588,1 @@\n-    return patch_imm_in_li16u(branch, (uint16_t)imm);\n+    return patch_imm_in_li16u(instruction_address, (uint16_t)imm);\n@@ -1560,2 +1592,2 @@\n-                  Assembler::ld_instr(branch), p2i(branch));\n-    Disassembler::decode(branch - 16, branch + 16);\n+                  Assembler::ld_instr(instruction_address), p2i(instruction_address));\n+    Disassembler::decode(instruction_address - 16, instruction_address + 16);\n@@ -1577,2 +1609,4 @@\n-  } else if (NativeInstruction::is_movptr_at(insn_addr)) {           \/\/ movptr\n-    return get_target_of_movptr(insn_addr);\n+  } else if (NativeInstruction::is_movptr1_at(insn_addr)) {          \/\/ movptr1\n+    return get_target_of_movptr1(insn_addr);\n+  } else if (NativeInstruction::is_movptr2_at(insn_addr)) {          \/\/ movptr2\n+    return get_target_of_movptr2(insn_addr);\n@@ -1597,1 +1631,4 @@\n-  } else if (NativeInstruction::is_movptr_at(insn_addr)) {\n+  } else if (NativeInstruction::is_movptr1_at(insn_addr)) {\n+    \/\/ Move wide OOP\n+    return patch_addr_in_movptr1(insn_addr, o);\n+  } else if (NativeInstruction::is_movptr2_at(insn_addr)) {\n@@ -1599,1 +1636,1 @@\n-    return patch_addr_in_movptr(insn_addr, o);\n+    return patch_addr_in_movptr2(insn_addr, o);\n@@ -1620,2 +1657,8 @@\n-void MacroAssembler::movptr(Register Rd, address addr, int32_t &offset) {\n-  int64_t imm64 = (int64_t)addr;\n+void MacroAssembler::movptr(Register Rd, address addr, Register temp) {\n+  int offset = 0;\n+  movptr(Rd, addr, offset, temp);\n+  addi(Rd, Rd, offset);\n+}\n+\n+void MacroAssembler::movptr(Register Rd, address addr, int32_t &offset, Register temp) {\n+  uint64_t uimm64 = (uint64_t)addr;\n@@ -1625,1 +1668,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n@@ -1629,1 +1672,10 @@\n-  assert((uintptr_t)imm64 < (1ull << 48), \"48-bit overflow in address constant\");\n+  assert(uimm64 < (1ull << 48), \"48-bit overflow in address constant\");\n+\n+  if (temp == noreg) {\n+    movptr1(Rd, uimm64, offset);\n+  } else {\n+    movptr2(Rd, uimm64, offset, temp);\n+  }\n+}\n+\n+void MacroAssembler::movptr1(Register Rd, uint64_t imm64, int32_t &offset) {\n@@ -1648,0 +1700,17 @@\n+void MacroAssembler::movptr2(Register Rd, uint64_t addr, int32_t &offset, Register tmp) {\n+  assert_different_registers(Rd, tmp, noreg);\n+\n+  uint32_t upper18 = (addr >> 30ull);\n+  int32_t  lower30 = (addr & 0x3fffffffu);\n+  int32_t  low12   = (lower30 << 20) >> 20;\n+  int32_t  mid18   = ((lower30 - low12) >> 12);\n+\n+  lui(tmp, upper18 << 12);\n+  lui(Rd, mid18 << 12);\n+\n+  slli(tmp, tmp, 18);\n+  add(Rd, Rd, tmp);\n+\n+  offset = low12;\n+}\n+\n@@ -2123,0 +2192,1 @@\n+  assert((uintptr_t)obj < (1ull << 48), \"48-bit overflow in metadata\");\n@@ -3557,1 +3627,1 @@\n-  movptr(t1, (address)Universe::non_oop_word());\n+  movptr(t1, (address)Universe::non_oop_word(), t0);\n@@ -3664,2 +3734,2 @@\n-  \/\/ (lui, addi, slli, addi, slli, addi) + (lui, addi, slli, addi, slli) + jalr\n-  return 12 * NativeInstruction::instruction_size;\n+  \/\/ (lui, addi, slli, addi, slli, addi) + (lui + lui + slli + add) + jalr\n+  return 11 * NativeInstruction::instruction_size;\n@@ -4123,1 +4193,1 @@\n- * x15: zlen\n+ * x15: tmp0\n@@ -4133,1 +4203,1 @@\n-                                     Register z, Register zlen,\n+                                     Register z, Register tmp0,\n@@ -4136,1 +4206,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+  assert_different_registers(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n@@ -4145,1 +4215,1 @@\n-  const Register x_xstart = zlen; \/\/ reuse register\n+  const Register x_xstart = tmp0;\n@@ -4147,3 +4217,3 @@\n-  mv(idx, ylen); \/\/ idx = ylen;\n-  mv(kdx, zlen); \/\/ kdx = xlen+ylen;\n-  mv(carry, zr); \/\/ carry = 0;\n+  mv(idx, ylen);         \/\/ idx = ylen;\n+  addw(kdx, xlen, ylen); \/\/ kdx = xlen+ylen;\n+  mv(carry, zr);         \/\/ carry = 0;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":112,"deletions":42,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -807,11 +807,10 @@\n-  void movptr(Register Rd, address addr, int32_t &offset);\n-\n-  void movptr(Register Rd, address addr) {\n-    int offset = 0;\n-    movptr(Rd, addr, offset);\n-    addi(Rd, Rd, offset);\n-  }\n-\n-  inline void movptr(Register Rd, uintptr_t imm64) {\n-    movptr(Rd, (address)imm64);\n-  }\n+  \/\/ Generates a load of a 48-bit constant which can be\n+  \/\/ patched to any 48-bit constant, i.e. address.\n+  \/\/ If common case supply additional temp register\n+  \/\/ to shorten the instruction sequence.\n+  void movptr(Register Rd, address addr, Register tmp = noreg);\n+  void movptr(Register Rd, address addr, int32_t &offset, Register tmp = noreg);\n+ private:\n+  void movptr1(Register Rd, uintptr_t addr, int32_t &offset);\n+  void movptr2(Register Rd, uintptr_t addr, int32_t &offset, Register tmp);\n+ public:\n@@ -1290,1 +1289,1 @@\n-                       Register z, Register zlen,\n+                       Register z, Register tmp0,\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -141,2 +141,2 @@\n-  static constexpr bool supports_vector_variable_rotates(void) {\n-    return false;\n+  static bool supports_vector_variable_rotates(void) {\n+    return UseZvbb;\n@@ -146,2 +146,2 @@\n-  static constexpr bool supports_vector_constant_rotates(int shift) {\n-    return false;\n+  static bool supports_vector_constant_rotates(int shift) {\n+    return UseZvbb;\n@@ -151,2 +151,2 @@\n-  static constexpr bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n-    return false;\n+  static bool supports_vector_comparison_unsigned(int vlen, BasicType bt) {\n+    return UseRVV;\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-bool NativeInstruction::is_movptr_at(address instr) {\n+bool NativeInstruction::is_movptr1_at(address instr) {\n@@ -96,1 +96,12 @@\n-         check_movptr_data_dependency(instr);\n+         check_movptr1_data_dependency(instr);\n+}\n+\n+bool NativeInstruction::is_movptr2_at(address instr) {\n+  return is_lui_at(instr) && \/\/ lui\n+         is_lui_at(instr + instruction_size) && \/\/ lui\n+         is_slli_shift_at(instr + instruction_size * 2, 18) && \/\/ slli Rd, Rs, 18\n+         is_add_at(instr + instruction_size * 3) &&\n+         (is_addi_at(instr + instruction_size * 4) ||\n+          is_jalr_at(instr + instruction_size * 4) ||\n+          is_load_at(instr + instruction_size * 4)) && \/\/ Addi\/Jalr\/Load\n+         check_movptr2_data_dependency(instr);\n@@ -204,3 +215,3 @@\n-  if (!(nativeInstruction_at(instruction_address())->is_movptr() ||\n-        is_auipc_at(instruction_address()))) {\n-    fatal(\"should be MOVPTR or AUIPC\");\n+  NativeInstruction* ni = nativeInstruction_at(instruction_address());\n+  if (ni->is_movptr() || ni->is_auipc()) {\n+    return;\n@@ -208,0 +219,1 @@\n+  fatal(\"should be MOVPTR or AUIPC\");\n@@ -226,1 +238,1 @@\n-    ICache::invalidate_range(instruction_address(), movptr_instruction_size);\n+    ICache::invalidate_range(instruction_address(), movptr1_instruction_size \/* > movptr2_instruction_size *\/ );\n@@ -396,0 +408,2 @@\n+\/\/-------------------------------------------------------------------\n+\n@@ -402,1 +416,1 @@\n-  a.movptr(t0, entry, offset); \/\/ lui, addi, slli, addi, slli\n+  a.movptr(t0, entry, offset, t1); \/\/ lui, lui, slli, add\n@@ -413,0 +427,2 @@\n+\/\/-------------------------------------------------------------------\n+\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -67,1 +67,5 @@\n-  bool is_movptr()                          const { return is_movptr_at(addr_at(0));      }\n+  bool is_movptr()                          const { return is_movptr1_at(addr_at(0)) ||\n+                                                           is_movptr2_at(addr_at(0));     }\n+  bool is_movptr1()                         const { return is_movptr1_at(addr_at(0));     }\n+  bool is_movptr2()                         const { return is_movptr2_at(addr_at(0));     }\n+  bool is_auipc()                           const { return is_auipc_at(addr_at(0));       }\n@@ -79,0 +83,1 @@\n+  static bool is_add_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110011 && extract_funct3(instr) == 0b000; }\n@@ -81,1 +86,1 @@\n-  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n+  static bool is_addiw_to_zr_at(address instr){ assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n@@ -112,1 +117,1 @@\n-  static bool check_movptr_data_dependency(address instr) {\n+  static bool check_movptr1_data_dependency(address instr) {\n@@ -130,0 +135,20 @@\n+  \/\/ the instruction sequence of movptr2 is as below:\n+  \/\/     lui\n+  \/\/     lui\n+  \/\/     slli\n+  \/\/     add\n+  \/\/     addi\/jalr\/load\n+  static bool check_movptr2_data_dependency(address instr) {\n+    address lui1 = instr;\n+    address lui2 = lui1 + instruction_size;\n+    address slli = lui2 + instruction_size;\n+    address add  = slli + instruction_size;\n+    address last_instr = add + instruction_size;\n+    return extract_rd(add) == extract_rd(lui2) &&\n+           extract_rs1(add) == extract_rd(lui2) &&\n+           extract_rs2(add) == extract_rd(slli) &&\n+           extract_rs1(slli) == extract_rd(lui1) &&\n+           extract_rd(slli) == extract_rd(lui1) &&\n+           extract_rs1(last_instr) == extract_rd(add);\n+  }\n+\n@@ -207,1 +232,2 @@\n-  static bool is_movptr_at(address instr);\n+  static bool is_movptr1_at(address instr);\n+  static bool is_movptr2_at(address instr);\n@@ -354,4 +380,3 @@\n-    movptr_instruction_size             =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr().\n-    load_pc_relative_instruction_size   =    2 * NativeInstruction::instruction_size, \/\/ auipc, ld\n-    instruction_offset                  =    0,\n-    displacement_offset                 =    0\n+    movptr1_instruction_size            =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr1().\n+    movptr2_instruction_size            =    5 * NativeInstruction::instruction_size, \/\/ lui, lui, slli, add, addi.  See movptr2().\n+    load_pc_relative_instruction_size   =    2 * NativeInstruction::instruction_size  \/\/ auipc, ld\n@@ -360,1 +385,1 @@\n-  address instruction_address() const       { return addr_at(instruction_offset); }\n+  address instruction_address() const       { return addr_at(0); }\n@@ -367,2 +392,2 @@\n-    if (nativeInstruction_at(instruction_address())->is_movptr()) {\n-      if (is_addi_at(addr_at(movptr_instruction_size - NativeInstruction::instruction_size))) {\n+    if (is_movptr1_at(instruction_address())) {\n+      if (is_addi_at(addr_at(movptr1_instruction_size - NativeInstruction::instruction_size))) {\n@@ -370,1 +395,1 @@\n-        return addr_at(movptr_instruction_size);\n+        return addr_at(movptr1_instruction_size);\n@@ -373,1 +398,9 @@\n-        return addr_at(movptr_instruction_size - NativeInstruction::instruction_size);\n+        return addr_at(movptr1_instruction_size - NativeInstruction::instruction_size);\n+      }\n+    } else if (is_movptr2_at(instruction_address())) {\n+      if (is_addi_at(addr_at(movptr2_instruction_size - NativeInstruction::instruction_size))) {\n+        \/\/ Assume: lui, lui, slli, add, addi\n+        return addr_at(movptr2_instruction_size);\n+      } else {\n+        \/\/ Assume: lui, lui, slli, add\n+        return addr_at(movptr2_instruction_size - NativeInstruction::instruction_size);\n@@ -386,6 +419,0 @@\n-  void flush() {\n-    if (!maybe_cpool_ref(instruction_address())) {\n-      ICache::invalidate_range(instruction_address(), movptr_instruction_size);\n-    }\n-  }\n-\n@@ -402,1 +429,1 @@\n-  NativeMovConstReg* test = (NativeMovConstReg*)(addr - NativeMovConstReg::instruction_offset);\n+  NativeMovConstReg* test = (NativeMovConstReg*)(addr);\n@@ -409,1 +436,1 @@\n-  NativeMovConstReg* test = (NativeMovConstReg*)(addr - NativeMovConstReg::instruction_size - NativeMovConstReg::instruction_offset);\n+  NativeMovConstReg* test = (NativeMovConstReg*)(addr - NativeMovConstReg::instruction_size);\n@@ -487,4 +514,1 @@\n-    instruction_size            =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, jalr\n-    instruction_offset          =    0,\n-    data_offset                 =    0,\n-    next_instruction_offset     =    6 * NativeInstruction::instruction_size  \/\/ lui, addi, slli, addi, slli, jalr\n+    instruction_size            =    5 * NativeInstruction::instruction_size, \/\/ lui, lui, slli, add, jalr\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":49,"deletions":25,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1247,1 +1247,1 @@\n-  return 7 * NativeInstruction::instruction_size; \/\/ movptr, jal\n+  return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n@@ -1288,3 +1288,3 @@\n-  \/\/ skip the movptr in MacroAssembler::ic_call():\n-  \/\/ lui + addi + slli + addi + slli + addi\n-  \/\/ Though movptr() has already 4-byte aligned with or without RVC,\n+  \/\/ skip the movptr2 in MacroAssembler::ic_call():\n+  \/\/ lui, lui, slli, add, addi\n+  \/\/ Though movptr2() has already 4-byte aligned with or without RVC,\n@@ -1292,2 +1292,1 @@\n-  const int movptr_size = 6 * NativeInstruction::instruction_size;\n-  current_offset += movptr_size;\n+  current_offset += NativeMovConstReg::movptr2_instruction_size;\n@@ -10017,1 +10016,1 @@\n-  ins_cost(BRANCH_COST + ALU_COST * 6);\n+  ins_cost(BRANCH_COST + ALU_COST * 5);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-      case Op_ReverseBytesV:\n@@ -81,0 +80,3 @@\n+      case Op_ReverseBytesV:\n+      case Op_RotateLeftV:\n+      case Op_RotateRightV:\n@@ -3060,0 +3062,194 @@\n+\/\/ --------------------------------- Vector Rotation ----------------------------------\n+\/\/\n+\/\/ Following rotate instruct's are shared by vectorization (in SLP, superword.cpp) and Vector API.\n+\/\/\n+\/\/ Rotate behaviour in vectorization is defined by java API, which includes:\n+\/\/  1. Integer.rorateRight, Integer.rorateLeft.\n+\/\/     `rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored`.\n+\/\/  2. Long.rorateRight, Long.rorateLeft.\n+\/\/     `rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored`.\n+\/\/\n+\/\/ Rotate behaviour in Vector API is defined as below, e.g.\n+\/\/  1. For Byte ROR, `a ROR b` is: (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))))\n+\/\/  2. For Short ROR, `a ROR b` is: (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))))\n+\/\/  3. For Integer ROR, `a ROR b` is: Integer.rotateRight(a, ((int)b))\n+\/\/  4. For Long ROR, `a ROR b` is: Long.rotateRight(a, ((int)b))\n+\/\/\n+\/\/ Basically, the behaviour between vectorization and Vector API is the same for Long and Integer, except that Vector API\n+\/\/ also supports Byte and Short rotation. But we can still share the intrinsics between vectorization and Vector API.\n+\/\/\n+\/\/ NOTE: As vror.vi encodes 6-bits immediate rotate amount, which is different from other vector-immediate instructions,\n+\/\/       implementation of vector rotation for long and other types can be unified.\n+\n+\/\/ Rotate right\n+\n+instruct vrotate_right(vReg dst, vReg src, vReg shift) %{\n+  match(Set dst (RotateRightV src shift));\n+  format %{ \"vrotate_right $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+               as_VectorRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_right_reg(vReg dst, vReg src, iRegIorL2I shift) %{\n+  match(Set dst (RotateRightV src (Replicate shift)));\n+  format %{ \"vrotate_right_reg $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vx(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+               as_Register($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_right_imm(vReg dst, vReg src, immI shift) %{\n+  match(Set dst (RotateRightV src shift));\n+  format %{ \"vrotate_right_imm $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Rotate right - masked\n+\n+instruct vrotate_right_masked(vReg dst_src, vReg shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateRightV (Binary dst_src shift) v0));\n+  format %{ \"vrotate_right_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($shift$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_right_reg_masked(vReg dst_src, iRegIorL2I shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateRightV (Binary dst_src (Replicate shift)) v0));\n+  format %{ \"vrotate_right_reg_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vx(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               as_Register($shift$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_right_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateRightV (Binary dst_src shift) v0));\n+  format %{ \"vrotate_right_imm_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vror_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               con, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Rotate left\n+\n+instruct vrotate_left(vReg dst, vReg src, vReg shift) %{\n+  match(Set dst (RotateLeftV src shift));\n+  format %{ \"vrotate_left $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrol_vv(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+               as_VectorRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_left_reg(vReg dst, vReg src, iRegIorL2I shift) %{\n+  match(Set dst (RotateLeftV src (Replicate shift)));\n+  format %{ \"vrotate_left_reg $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrol_vx(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+               as_Register($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_left_imm(vReg dst, vReg src, immI shift) %{\n+  match(Set dst (RotateLeftV src shift));\n+  format %{ \"vrotate_left_imm $dst, $src, $shift\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    con = bits - con;\n+    __ vror_vi(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Rotate left - masked\n+\n+instruct vrotate_left_masked(vReg dst_src, vReg shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateLeftV (Binary dst_src shift) v0));\n+  format %{ \"vrotate_left_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrol_vv(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($shift$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_left_reg_masked(vReg dst_src, iRegIorL2I shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateLeftV (Binary dst_src (Replicate shift)) v0));\n+  format %{ \"vrotate_left_reg_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vrol_vx(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               as_Register($shift$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vrotate_left_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+  match(Set dst_src (RotateLeftV (Binary dst_src shift) v0));\n+  format %{ \"vrotate_left_imm_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint32_t bits = type2aelembytes(bt) * 8;\n+    uint32_t con = (unsigned)$shift$$constant & (bits - 1);\n+    if (con == 0) {\n+      return;\n+    }\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    con = bits - con;\n+    __ vror_vi(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg),\n+               con, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":197,"deletions":1,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -2843,1 +2843,0 @@\n-   *    c_rarg5   - z length\n@@ -2856,1 +2855,0 @@\n-    const Register zlen  = x15;\n@@ -2858,0 +2856,1 @@\n+    const Register tmp0  = x15;\n@@ -2868,1 +2867,1 @@\n-    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n@@ -2884,1 +2883,0 @@\n-    const Register zlen  = x13;\n@@ -2888,0 +2886,1 @@\n+    const Register tmp0  = x13; \/\/ zlen, unused\n@@ -2900,1 +2899,1 @@\n-    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  __ movptr(c_rarg1, (intptr_t) receiver);\n+  __ movptr(c_rarg1, (address) receiver);\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  Register t1,                         \/\/ Temp register: Must be global register for incr_allocated_bytes.\n+  Register t1,                         \/\/ Temp register.\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-  __ z_srag(Rtmp1, Rtmp1, HeapRegion::LogOfHRGrainBytes);\n+  __ z_srag(Rtmp1, Rtmp1, G1HeapRegion::LogOfHRGrainBytes);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5284,3 +5284,0 @@\n-  \/\/ In openJdk, we store the argument as 32-bit value to slot.\n-  Address zlen(Z_SP, _z_abi(remaining_cargs));  \/\/ Int in long on big endian.\n-\n@@ -5311,1 +5308,1 @@\n-  z_llgf(kdx, zlen);         \/\/ C2 does not respect int to long conversion for stub calls, thus load zero-extended.\n+  z_agrk(kdx, xlen, ylen);   \/\/ kdx = xlen + ylen\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2984,1 +2984,0 @@\n-  \/\/   160[Z_SP] - z length\n@@ -2996,2 +2995,0 @@\n-    \/\/ zlen is passed on the stack:\n-    \/\/ Address zlen(Z_SP, _z_abi(remaining_cargs));\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,2 @@\n-  0,  0,  0    \/\/ EVEX_NTUP\n+  1,   1,  1,  \/\/ EVEX_NOSCALE(0)\n+  0,  0,  0    \/\/ EVEX_ETUP\n@@ -297,5 +298,1 @@\n-  int enc = r->encoding();\n-  if (enc >= 8) {\n-    enc -= 8;\n-  }\n-  return enc;\n+  return r->encoding() & 7;\n@@ -441,0 +438,3 @@\n+    case EVEX_NOSCALE:\n+      break;\n+\n@@ -528,0 +528,3 @@\n+    case EVEX_NOSCALE:\n+      break;\n+\n@@ -549,0 +552,18 @@\n+bool Assembler::needs_rex2(Register reg1, Register reg2, Register reg3) {\n+  bool rex2 = (reg1->is_valid() && reg1->encoding() >= 16) ||\n+              (reg2->is_valid() && reg2->encoding() >= 16) ||\n+              (reg3->is_valid() && reg3->encoding() >= 16);\n+  assert(!rex2 || UseAPX, \"extended gpr use requires UseAPX\");\n+  return rex2;\n+}\n+\n+bool Assembler::needs_eevex(Register reg1, Register reg2, Register reg3) {\n+  return needs_rex2(reg1, reg2, reg3);\n+}\n+\n+bool Assembler::needs_eevex(int enc1, int enc2, int enc3) {\n+  bool eevex = enc1 >= 16 || enc2 >= 16 || enc3 >=16;\n+  assert(!eevex || UseAPX, \"extended gpr use requires UseAPX\");\n+  return eevex;\n+}\n+\n@@ -619,2 +640,1 @@\n-      if (disp == 0 && no_relocation &&\n-          base_enc != rbp->encoding() LP64_ONLY(&& base_enc != r13->encoding())) {\n+      if (disp == 0 && no_relocation && ((base_enc & 0x7) != 5)) {\n@@ -622,0 +642,1 @@\n+        \/\/ !(rbp | r13 | r21 | r29)\n@@ -638,1 +659,2 @@\n-    } else if (base_enc == rsp->encoding() LP64_ONLY(|| base_enc == r12->encoding())) {\n+    } else if ((base_enc & 0x7) == 4) {\n+      \/\/ rsp | r12 | r20 | r28\n@@ -660,3 +682,3 @@\n-      assert(base_enc != rsp->encoding() LP64_ONLY(&& base_enc != r12->encoding()), \"illegal addressing mode\");\n-      if (disp == 0 && no_relocation &&\n-          base_enc != rbp->encoding() LP64_ONLY(&& base_enc != r13->encoding())) {\n+      \/\/ !(rsp | r12 | r20 | r28) were handled above\n+      assert(((base_enc & 0x7) != 4), \"illegal addressing mode\");\n+      if (disp == 0 && no_relocation &&  ((base_enc & 0x7) != 5)) {\n@@ -664,0 +686,1 @@\n+        \/\/ !(rbp | r13 | r21 | r29)\n@@ -820,0 +843,7 @@\n+  case REX2:\n+    NOT_LP64(assert(false, \"64bit prefixes\"));\n+    if ((0xFF & *ip++) & REXBIT_W) {\n+      is_64bit = true;\n+    }\n+    goto again_after_prefix;\n+\n@@ -869,0 +899,8 @@\n+\n+    case REX2:\n+      NOT_LP64(assert(false, \"64bit prefix found\"));\n+      if ((0xFF & *ip++) & REXBIT_W) {\n+        is_64bit = true;\n+      }\n+      goto again_after_size_prefix2;\n+\n@@ -1158,0 +1196,1 @@\n+    case REX2:\n@@ -1284,0 +1323,27 @@\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding, int byte3) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int32(opcode_prefix, (unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF), byte3);\n+  } else {\n+    emit_int24((unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF), byte3);\n+  }\n+}\n+\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int24(opcode_prefix, (unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF));\n+  } else {\n+    emit_int16((unsigned char)byte1, byte2 | (ocp_and_encoding & 0xFF));\n+  }\n+}\n+\n+void Assembler::emit_opcode_prefix_and_encoding(int byte1, int ocp_and_encoding) {\n+  int opcode_prefix = (ocp_and_encoding & 0xFF00) >> 8;\n+  if (opcode_prefix != 0) {\n+    emit_int16(opcode_prefix, (unsigned char)byte1 | (ocp_and_encoding & 0xFF));\n+  } else {\n+    emit_int8((unsigned char)byte1 | (ocp_and_encoding & 0xFF));\n+  }\n+}\n+\n@@ -1606,2 +1672,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1614,1 +1680,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1621,4 +1688,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBC,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -1628,4 +1693,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBD,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -1635,2 +1698,2 @@\n-  int encode = prefix_and_encode(reg->encoding());\n-  emit_int16(0x0F, (0xC8 | encode));\n+  int encode = prefix_and_encode(reg->encoding(), false, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xC8, encode);\n@@ -1641,2 +1704,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1649,1 +1712,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1657,2 +1721,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1666,1 +1730,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1674,2 +1739,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -1682,1 +1747,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -1746,4 +1812,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             0x40 | cc,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding(0x40 | cc, 0xC0, encode);\n@@ -1752,1 +1816,0 @@\n-\n@@ -1756,2 +1819,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (0x40 | cc));\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((0x40 | cc));\n@@ -1843,2 +1906,2 @@\n-  prefix(adr, reg);\n-  emit_int16(0x0F, (unsigned char)0xB1);\n+  prefix(adr, reg, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB1);\n@@ -1851,2 +1914,2 @@\n-  prefix(adr, reg);\n-  emit_int16(0x0F, (unsigned char)0xB1);\n+  prefix(adr, reg, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB1);\n@@ -1861,2 +1924,2 @@\n-  prefix(adr, reg, true);\n-  emit_int16(0x0F, (unsigned char)0xB0);\n+  prefix(adr, reg, true, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB0);\n@@ -1920,2 +1983,7 @@\n-  int8_t w = 0x01;\n-  Prefix p = Prefix_EMPTY;\n+  if (needs_eevex(crc, v)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ sizeInBytes == 8, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(crc->encoding(), 0, v->encoding(), sizeInBytes == 2 ? VEX_SIMD_66 : VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16(sizeInBytes == 1 ? (unsigned char)0xF0 : (unsigned char)0xF1, (0xC0 | encode));\n+  } else {\n+    int8_t w = 0x01;\n+    Prefix p = Prefix_EMPTY;\n@@ -1923,27 +1991,33 @@\n-  emit_int8((unsigned char)0xF2);\n-  switch (sizeInBytes) {\n-  case 1:\n-    w = 0;\n-    break;\n-  case 2:\n-  case 4:\n-    break;\n-  LP64_ONLY(case 8:)\n-    \/\/ This instruction is not valid in 32 bits\n-    \/\/ Note:\n-    \/\/ http:\/\/www.intel.com\/content\/dam\/www\/public\/us\/en\/documents\/manuals\/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n-    \/\/\n-    \/\/ Page B - 72   Vol. 2C says\n-    \/\/ qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2\n-    \/\/ mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r \/ m\n-    \/\/                                                                            F0!!!\n-    \/\/ while 3 - 208 Vol. 2A\n-    \/\/ F2 REX.W 0F 38 F1 \/ r       CRC32 r64, r \/ m64             RM         Valid      N.E.Accumulate CRC32 on r \/ m64.\n-    \/\/\n-    \/\/ the 0 on a last bit is reserved for a different flavor of this instruction :\n-    \/\/ F2 REX.W 0F 38 F0 \/ r       CRC32 r64, r \/ m8              RM         Valid      N.E.Accumulate CRC32 on r \/ m8.\n-    p = REX_W;\n-    break;\n-  default:\n-    assert(0, \"Unsupported value for a sizeInBytes argument\");\n-    break;\n+    emit_int8((unsigned char)0xF2);\n+    switch (sizeInBytes) {\n+    case 1:\n+      w = 0;\n+      break;\n+    case 2:\n+    case 4:\n+      break;\n+    LP64_ONLY(case 8:)\n+      \/\/ This instruction is not valid in 32 bits\n+      \/\/ Note:\n+      \/\/ http:\/\/www.intel.com\/content\/dam\/www\/public\/us\/en\/documents\/manuals\/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n+      \/\/\n+      \/\/ Page B - 72   Vol. 2C says\n+      \/\/ qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2\n+      \/\/ mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r \/ m\n+      \/\/                                                                            F0!!!\n+      \/\/ while 3 - 208 Vol. 2A\n+      \/\/ F2 REX.W 0F 38 F1 \/ r       CRC32 r64, r \/ m64             RM         Valid      N.E.Accumulate CRC32 on r \/ m64.\n+      \/\/\n+      \/\/ the 0 on a last bit is reserved for a different flavor of this instruction :\n+      \/\/ F2 REX.W 0F 38 F0 \/ r       CRC32 r64, r \/ m8              RM         Valid      N.E.Accumulate CRC32 on r \/ m8.\n+      p = REX_W;\n+      break;\n+    default:\n+      assert(0, \"Unsupported value for a sizeInBytes argument\");\n+      break;\n+    }\n+    LP64_ONLY(prefix(crc, v, p);)\n+    emit_int32(0x0F,\n+               0x38,\n+               0xF0 | w,\n+               0xC0 | ((crc->encoding() & 0x7) << 3) | (v->encoding() & 7));\n@@ -1951,5 +2025,0 @@\n-  LP64_ONLY(prefix(crc, v, p);)\n-  emit_int32(0x0F,\n-             0x38,\n-             0xF0 | w,\n-             0xC0 | ((crc->encoding() & 0x7) << 3) | (v->encoding() & 7));\n@@ -1961,2 +2030,9 @@\n-  int8_t w = 0x01;\n-  Prefix p = Prefix_EMPTY;\n+  if (needs_eevex(crc, adr.base(), adr.index())) {\n+    InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ sizeInBytes == 8, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+    vex_prefix(adr, 0, crc->encoding(), sizeInBytes == 2 ? VEX_SIMD_66 : VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+    emit_int8(sizeInBytes == 1 ? (unsigned char)0xF0 : (unsigned char)0xF1);\n+    emit_operand(crc, adr, 0);\n+  } else {\n+    int8_t w = 0x01;\n+    Prefix p = Prefix_EMPTY;\n@@ -1964,15 +2040,19 @@\n-  emit_int8((uint8_t)0xF2);\n-  switch (sizeInBytes) {\n-  case 1:\n-    w = 0;\n-    break;\n-  case 2:\n-  case 4:\n-    break;\n-  LP64_ONLY(case 8:)\n-    \/\/ This instruction is not valid in 32 bits\n-    p = REX_W;\n-    break;\n-  default:\n-    assert(0, \"Unsupported value for a sizeInBytes argument\");\n-    break;\n+    emit_int8((uint8_t)0xF2);\n+    switch (sizeInBytes) {\n+    case 1:\n+      w = 0;\n+      break;\n+    case 2:\n+    case 4:\n+      break;\n+    LP64_ONLY(case 8:)\n+      \/\/ This instruction is not valid in 32 bits\n+      p = REX_W;\n+      break;\n+    default:\n+      assert(0, \"Unsupported value for a sizeInBytes argument\");\n+      break;\n+    }\n+    LP64_ONLY(prefix(crc, adr, p);)\n+    emit_int24(0x0F, 0x38, (0xF0 | w));\n+    emit_operand(crc, adr, 0);\n@@ -1980,3 +2060,0 @@\n-  LP64_ONLY(prefix(crc, adr, p);)\n-  emit_int24(0x0F, 0x38, (0xF0 | w));\n-  emit_operand(crc, adr, 0);\n@@ -2084,1 +2161,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2101,1 +2178,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes, true);\n@@ -2118,1 +2195,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes, true);\n@@ -2421,4 +2498,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xAF,\n-             (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAF, 0xC0, encode);\n@@ -2453,2 +2528,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xAF);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xAF);\n@@ -2590,1 +2665,4 @@\n-  if (UseAVX > 0 ) {\n+  \/\/ This instruction should be SSE encoded with the REX2 prefix when an\n+  \/\/ extended GPR is present. To be consistent when UseAPX is enabled, use\n+  \/\/ this encoding even when an extended GPR is not used.\n+  if (UseAVX > 0 && !UseAPX ) {\n@@ -2599,2 +2677,2 @@\n-    prefix(src);\n-    emit_int16(0x0F, (unsigned char)0xAE);\n+    prefix(src, true \/* is_map1 *\/);\n+    emit_int8((unsigned char)0xAE);\n@@ -2627,2 +2705,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -2635,2 +2713,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBD);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBD);\n@@ -2728,2 +2806,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -2735,1 +2813,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2742,2 +2820,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes, true);\n@@ -2749,1 +2827,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2757,1 +2835,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2766,1 +2845,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2781,2 +2861,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2788,1 +2868,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -2803,1 +2883,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2812,1 +2893,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -2820,2 +2902,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -2827,1 +2909,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -3108,1 +3190,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3116,1 +3198,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3585,1 +3667,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3592,1 +3674,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -3598,2 +3680,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBE);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBE);\n@@ -3605,2 +3687,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBE, 0xC0, encode);\n@@ -3678,2 +3760,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBF);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBF);\n@@ -3684,2 +3766,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBF, 0xC0, encode);\n@@ -3756,2 +3838,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB6);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB6);\n@@ -3763,2 +3845,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0xB6, 0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), false, src->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB6, 0xC0, encode);\n@@ -3769,2 +3851,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB7);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB7);\n@@ -3775,2 +3857,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB7, 0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB7, 0xC0, encode);\n@@ -3839,1 +3921,1 @@\n-void Assembler::nop(int i) {\n+void Assembler::nop(uint i) {\n@@ -4419,0 +4501,1 @@\n+  assert(!needs_eevex(src.base(), src.index()), \"does not support extended gprs\");\n@@ -4746,1 +4829,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4764,1 +4847,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4800,1 +4883,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4818,1 +4901,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4836,1 +4919,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4843,1 +4926,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4861,1 +4944,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(),  nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4868,1 +4951,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -4886,1 +4969,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -4904,1 +4987,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -4911,1 +4994,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -5314,2 +5397,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xB8);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xB8);\n@@ -5322,2 +5405,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB8, 0xC0, encode);\n@@ -5395,2 +5478,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true \/* is_map1 *\/);\n+  emit_int8(0x18);\n@@ -5403,2 +5486,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x0D);\n+  prefix(src, true \/* is_map1 *\/);\n+  emit_int8(0x0D);\n@@ -5411,2 +5494,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true \/* is_map1 *\/);\n+  emit_int8(0x18);\n@@ -5419,2 +5502,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true \/* is_map1 *\/);\n+  emit_int8(0x18);\n@@ -5427,2 +5510,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x18);\n+  prefix(src, true \/* is_map1 *\/);\n+  emit_int8(0x18);\n@@ -5435,2 +5518,2 @@\n-  prefix(src);\n-  emit_int16(0x0F, 0x0D);\n+  prefix(src, true \/* is_map1 *\/);\n+  emit_int8(0x0D);\n@@ -5444,0 +5527,6 @@\n+void Assembler::prefix16(int prefix) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  emit_int8((prefix & 0xff00) >> 8);\n+  emit_int8(prefix & 0xff);\n+}\n+\n@@ -5651,0 +5740,1 @@\n+  assert(!needs_eevex(src.base(), src.index()), \"does not support extended gprs\");\n@@ -5668,0 +5758,1 @@\n+  assert(!needs_eevex(src.base(), src.index()), \"does not support extended gprs\");\n@@ -6081,2 +6172,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), true);\n-  emit_int24(0x0F, (unsigned char)0x90 | cc, (0xC0 | encode));\n+  int encode = prefix_and_encode(dst->encoding(), true, true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0x90 | cc, 0xC0, encode);\n@@ -6215,2 +6306,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int24(0x0F, (unsigned char)0xA5, (0xC0 | encode));\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA5, 0xC0, encode);\n@@ -6220,2 +6311,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA4, 0xC0, encode, imm8);\n@@ -6225,2 +6316,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int24(0x0F, (unsigned char)0xAD, (0xC0 | encode));\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAD, 0xC0, encode);\n@@ -6230,2 +6321,2 @@\n-  int encode = prefix_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);\n+  int encode = prefix_and_encode(src->encoding(), dst->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAC, 0xC0, encode, imm8);\n@@ -6236,2 +6327,2 @@\n-  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA4, 0xC0, encode, imm8);\n@@ -6241,2 +6332,2 @@\n-  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n-  emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAC, 0xC0, encode, imm8);\n@@ -6308,2 +6399,5 @@\n-void Assembler::stmxcsr( Address dst) {\n-  if (UseAVX > 0 ) {\n+void Assembler::stmxcsr(Address dst) {\n+  \/\/ This instruction should be SSE encoded with the REX2 prefix when an\n+  \/\/ extended GPR is present. To be consistent when UseAPX is enabled, use\n+  \/\/ this encoding even when an extended GPR is not used.\n+  if (UseAVX > 0 && !UseAPX  ) {\n@@ -6319,2 +6413,2 @@\n-    prefix(dst);\n-    emit_int16(0x0F, (unsigned char)0xAE);\n+    prefix(dst, true \/* is_map1 *\/);\n+    emit_int8((unsigned char)0xAE);\n@@ -6460,4 +6554,2 @@\n-  int encode = prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F,\n-             (unsigned char)0xBC,\n-             0xC0 | encode);\n+  int encode = prefix_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -6470,2 +6562,2 @@\n-  prefix(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBC);\n+  prefix(src, dst, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBC);\n@@ -6478,2 +6570,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -6486,2 +6578,2 @@\n-  prefixq(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBC);\n+  prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBC);\n@@ -6533,2 +6625,2 @@\n-  prefix(dst, src, true);\n-  emit_int16(0x0F, (unsigned char)0xC0);\n+  prefix(dst, src, true, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC0);\n@@ -6541,2 +6633,2 @@\n-  prefix(dst, src);\n-  emit_int16(0x0F, (unsigned char)0xC1);\n+  prefix(dst, src, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC1);\n@@ -6548,2 +6640,2 @@\n-  prefix(dst, src);\n-  emit_int16(0x0F, (unsigned char)0xC1);\n+  prefix(dst, src, false, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xC1);\n@@ -9119,1 +9211,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -10889,1 +10981,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -10898,1 +10990,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes , true);\n@@ -10907,1 +10999,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -10916,1 +11008,1 @@\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -11676,1 +11768,2 @@\n-void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){\n+void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool eevex_b, bool evex_v,\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {\n@@ -11685,1 +11778,1 @@\n-  \/\/ P0: byte 2, initialized to RXBR`00mm\n+  \/\/ P0: byte 2, initialized to RXBR'0mmm\n@@ -11689,0 +11782,1 @@\n+  byte2 |= eevex_b ? EEVEX_B : 0;\n@@ -11690,1 +11784,1 @@\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ of form {0F, 0F_38, 0F_3A, 0F_3C}\n@@ -11695,2 +11789,1 @@\n-  \/\/ p[10] is always 1\n-  byte3 |= EVEX_F;\n+  byte3 |= (eevex_x ? 0 : EEVEX_X);\n@@ -11723,0 +11816,4 @@\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    assert(UseAPX, \"APX features not enabled\");\n+  }\n+  bool is_extended = adr.base_needs_rex2() || adr.index_needs_rex2() || nds_enc >= 16 || xreg_enc >= 16;\n@@ -11732,1 +11829,0 @@\n-\n@@ -11738,1 +11834,1 @@\n-      if ((attributes->get_vector_len() != AVX_512bit) && (nds_enc < 16) && (xreg_enc < 16)) {\n+      if ((attributes->get_vector_len() != AVX_512bit) && !is_extended) {\n@@ -11749,1 +11845,1 @@\n-    assert(((nds_enc < 16 && xreg_enc < 16) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n+    assert((!is_extended || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n@@ -11763,0 +11859,2 @@\n+    bool eevex_x = adr.index_needs_rex2();\n+    bool eevex_b = adr.base_needs_rex2();\n@@ -11764,1 +11862,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, eevex_b, evex_v, eevex_x, nds_enc, pre, opc);\n@@ -11773,1 +11871,5 @@\n-int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {\n+int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n+  if (src_is_gpr && src_enc >= 16) {\n+    assert(UseAPX, \"APX features not enabled\");\n+  }\n+  bool is_extended = dst_enc >= 16 || nds_enc >= 16 || src_enc >=16;\n@@ -11785,1 +11887,1 @@\n-          (dst_enc < 16) && (nds_enc < 16) && (src_enc < 16)) {\n+           !is_extended) {\n@@ -11802,1 +11904,1 @@\n-    assert(((dst_enc < 16 && nds_enc < 16 && src_enc < 16) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n+    assert(((!is_extended) || (!attributes->is_legacy_mode())),\"XMM register should be 0-15\");\n@@ -11810,0 +11912,1 @@\n+    bool evex_b = (src_enc >= 16) && src_is_gpr;\n@@ -11811,1 +11914,1 @@\n-    vex_x = (src_enc >= 16);\n+    vex_x = (src_enc >= 16) && !src_is_gpr;\n@@ -11813,1 +11916,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, pre, opc);\n@@ -11825,1 +11928,0 @@\n-\n@@ -11839,1 +11941,1 @@\n-                                      VexOpcode opc, InstructionAttr *attributes) {\n+                                      VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n@@ -11844,1 +11946,1 @@\n-    return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes);\n+    return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, src_is_gpr);\n@@ -12339,2 +12441,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12346,2 +12448,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12353,2 +12455,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12360,2 +12462,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12367,2 +12469,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12374,2 +12476,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12382,1 +12484,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12391,1 +12494,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12400,1 +12504,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12409,1 +12514,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12417,2 +12523,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12425,1 +12531,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12433,2 +12540,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12441,1 +12548,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12449,2 +12557,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12457,1 +12565,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12465,2 +12574,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12473,1 +12582,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12481,2 +12591,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12489,1 +12599,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -12497,2 +12608,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src1->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -12505,1 +12616,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12809,0 +12921,29 @@\n+int Assembler::get_base_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_B4;\n+  if (enc & 8) bits |= REXBIT_B;\n+  return bits;\n+}\n+\n+int Assembler::get_index_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_X4;\n+  if (enc & 8) bits |= REXBIT_X;\n+  return bits;\n+}\n+\n+int Assembler::get_base_prefix_bits(Register base) {\n+  return base->is_valid() ? get_base_prefix_bits(base->encoding()) : 0;\n+}\n+\n+int Assembler::get_index_prefix_bits(Register index) {\n+  return index->is_valid() ? get_index_prefix_bits(index->encoding()) : 0;\n+}\n+\n+int Assembler::get_reg_prefix_bits(int enc) {\n+  int bits = 0;\n+  if (enc & 16) bits |= REX2BIT_R4;\n+  if (enc & 8) bits |= REXBIT_R;\n+  return bits;\n+}\n+\n@@ -12810,1 +12951,3 @@\n-  if (reg->encoding() >= 8) {\n+  if (reg->encoding() >= 16) {\n+    prefix16(WREX2 | get_base_prefix_bits(reg->encoding()));\n+  } else if (reg->encoding() >= 8) {\n@@ -12816,0 +12959,4 @@\n+  if ((p & WREX2) || src->encoding() >= 16 || dst->encoding() >= 16) {\n+    prefix_rex2(dst, src);\n+    return;\n+  }\n@@ -12828,0 +12975,7 @@\n+void Assembler::prefix_rex2(Register dst, Register src) {\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(src->encoding());\n+  bits |= get_reg_prefix_bits(dst->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n@@ -12829,0 +12983,3 @@\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || dst->encoding() >= 16) {\n+    prefix_rex2(dst, adr);\n+  }\n@@ -12849,1 +13006,13 @@\n-void Assembler::prefix(Address adr) {\n+void Assembler::prefix_rex2(Register dst, Address adr) {\n+  assert(!adr.index_needs_rex2(), \"prefix(Register dst, Address adr) does not support handling of an X\");\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_reg_prefix_bits(dst->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+void Assembler::prefix(Address adr, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix_rex2(adr, is_map1);\n+    return;\n+  }\n@@ -12861,0 +13030,8 @@\n+  if (is_map1) emit_int8(0x0F);\n+}\n+\n+void Assembler::prefix_rex2(Address adr, bool is_map1) {\n+  int bits = is_map1 ? REX2BIT_M0 : 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  prefix16(WREX2 | bits);\n@@ -12863,1 +13040,5 @@\n-void Assembler::prefix(Address adr, Register reg, bool byteinst) {\n+void Assembler::prefix(Address adr, Register reg, bool byteinst, bool is_map1) {\n+  if (reg->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix_rex2(adr, reg, byteinst, is_map1);\n+    return;\n+  }\n@@ -12893,0 +13074,9 @@\n+  if (is_map1) emit_int8(0x0F);\n+}\n+\n+void Assembler::prefix_rex2(Address adr, Register reg, bool byteinst, bool is_map1) {\n+  int bits = is_map1 ? REX2BIT_M0 : 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(reg->encoding());\n+  prefix16(WREX2 | bits);\n@@ -12896,0 +13086,4 @@\n+  if (reg->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefixq_rex2(adr, reg);\n+    return;\n+  }\n@@ -12925,1 +13119,12 @@\n-int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {\n+void Assembler::prefix_rex2(Address adr, XMMRegister src) {\n+  int bits = 0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+int Assembler::prefix_and_encode(int reg_enc, bool byteinst, bool is_map1) {\n+  if (reg_enc >= 16) {\n+    return prefix_and_encode_rex2(reg_enc, is_map1);\n+  }\n@@ -12932,1 +13137,2 @@\n-  return reg_enc;\n+  int opc_prefix = is_map1 ? 0x0F00 : 0;\n+  return opc_prefix | reg_enc;\n@@ -12935,1 +13141,9 @@\n-int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {\n+int Assembler::prefix_and_encode_rex2(int reg_enc, bool is_map1) {\n+  prefix16(WREX2 | (is_map1 ? REX2BIT_M0 : 0) | get_base_prefix_bits(reg_enc));\n+  return reg_enc & 0x7;\n+}\n+\n+int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1) {\n+  if (src_enc >= 16 || dst_enc >= 16) {\n+    return prefix_and_encode_rex2(dst_enc, src_enc, is_map1 ? REX2BIT_M0 : 0);\n+  }\n@@ -12952,0 +13166,11 @@\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+int Assembler::prefix_and_encode_rex2(int dst_enc, int src_enc, int init_bits) {\n+  int bits = init_bits;\n+  bits |= get_reg_prefix_bits(dst_enc);\n+  bits |= get_base_prefix_bits(src_enc);\n+  dst_enc &= 0x7;\n+  src_enc &= 0x7;\n+  prefix16(WREX2 | bits);\n@@ -12955,1 +13180,8 @@\n-int8_t Assembler::get_prefixq(Address adr) {\n+bool Assembler::prefix_is_rex2(int prefix) {\n+  return (prefix & 0xFF00) == WREX2;\n+}\n+\n+int Assembler::get_prefixq(Address adr, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    return get_prefixq_rex2(adr, is_map1);\n+  }\n@@ -12958,1 +13190,10 @@\n-  return prfx;\n+  return is_map1 ? (((int16_t)prfx) << 8) | 0x0F : (int16_t)prfx;\n+}\n+\n+int Assembler::get_prefixq_rex2(Address adr, bool is_map1) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  int bits = REXBIT_W;\n+  if (is_map1) bits |= REX2BIT_M0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  return WREX2 | bits;\n@@ -12961,1 +13202,4 @@\n-int8_t Assembler::get_prefixq(Address adr, Register src) {\n+int Assembler::get_prefixq(Address adr, Register src, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || src->encoding() >= 16) {\n+    return get_prefixq_rex2(adr, src, is_map1);\n+  }\n@@ -12997,1 +13241,11 @@\n-  return prfx;\n+  return is_map1 ? (((int16_t)prfx) << 8) | 0x0F : (int16_t)prfx;\n+}\n+\n+int Assembler::get_prefixq_rex2(Address adr, Register src, bool is_map1) {\n+  assert(UseAPX, \"APX features not enabled\");\n+  int bits = REXBIT_W;\n+  if (is_map1) bits |= REX2BIT_M0;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  return WREX2 | bits;\n@@ -13001,1 +13255,5 @@\n-  emit_int8(get_prefixq(adr));\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefix16(get_prefixq_rex2(adr));\n+  } else {\n+    emit_int8(get_prefixq(adr));\n+  }\n@@ -13004,2 +13262,7 @@\n-void Assembler::prefixq(Address adr, Register src) {\n-  emit_int8(get_prefixq(adr, src));\n+void Assembler::prefixq(Address adr, Register src, bool is_map1) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || src->encoding() >= 16) {\n+    prefix16(get_prefixq_rex2(adr, src, is_map1));\n+  } else {\n+    emit_int8(get_prefixq(adr, src));\n+    if (is_map1) emit_int8(0x0F);\n+  }\n@@ -13008,0 +13271,1 @@\n+\n@@ -13009,0 +13273,4 @@\n+  if (src->encoding() >= 16 || adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+    prefixq_rex2(adr, src);\n+    return;\n+  }\n@@ -13040,1 +13308,12 @@\n-int Assembler::prefixq_and_encode(int reg_enc) {\n+void Assembler::prefixq_rex2(Address adr, XMMRegister src) {\n+  int bits = REXBIT_W;\n+  bits |= get_base_prefix_bits(adr.base());\n+  bits |= get_index_prefix_bits(adr.index());\n+  bits |= get_reg_prefix_bits(src->encoding());\n+  prefix16(WREX2 | bits);\n+}\n+\n+int Assembler::prefixq_and_encode(int reg_enc, bool is_map1) {\n+  if (reg_enc >= 16) {\n+    return prefixq_and_encode_rex2(reg_enc, is_map1);\n+  }\n@@ -13047,1 +13326,2 @@\n-  return reg_enc;\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | reg_enc;\n@@ -13050,1 +13330,10 @@\n-int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {\n+\n+int Assembler::prefixq_and_encode_rex2(int reg_enc, bool is_map1) {\n+  prefix16(WREX2 | REXBIT_W | (is_map1 ? REX2BIT_M0: 0) | get_base_prefix_bits(reg_enc));\n+  return reg_enc & 0x7;\n+}\n+\n+int Assembler::prefixq_and_encode(int dst_enc, int src_enc, bool is_map1) {\n+  if (dst_enc >= 16 || src_enc >= 16) {\n+    return prefixq_and_encode_rex2(dst_enc, src_enc, is_map1);\n+  }\n@@ -13067,1 +13356,16 @@\n-  return dst_enc << 3 | src_enc;\n+  int opcode_prefix = is_map1 ? 0x0F00 : 0;\n+  return opcode_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+int Assembler::prefixq_and_encode_rex2(int dst_enc, int src_enc, bool is_map1) {\n+  int init_bits = REXBIT_W | (is_map1 ? REX2BIT_M0 : 0);\n+  return prefix_and_encode_rex2(dst_enc, src_enc, init_bits);\n+}\n+\n+void Assembler::emit_prefix_and_int8(int prefix, int b1) {\n+  if ((prefix & 0xFF00) == 0) {\n+    emit_int16(prefix, b1);\n+  } else {\n+    assert((prefix & 0xFF00) != WREX2 || UseAPX, \"APX features not enabled\");\n+    emit_int24((prefix & 0xFF00) >> 8, prefix & 0x00FF, b1);\n+  }\n@@ -13077,1 +13381,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x13);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x13);\n@@ -13094,1 +13398,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x01);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x01);\n@@ -13105,1 +13409,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x03);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x03);\n@@ -13116,6 +13420,12 @@\n-  emit_int8(0x66);\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int32(0x0F,\n-             0x38,\n-             (unsigned char)0xF6,\n-             (0xC0 | encode));\n+  if (needs_rex2(dst, src)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  } else {\n+    emit_int8(0x66);\n+    int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n+    emit_int32(0x0F,\n+               0x38,\n+               (unsigned char)0xF6,\n+               (0xC0 | encode));\n+  }\n@@ -13126,6 +13436,12 @@\n-  emit_int8((unsigned char)0xF3);\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int32(0x0F,\n-             0x38,\n-             (unsigned char)0xF6,\n-             (0xC0 | encode));\n+  if (needs_rex2(dst, src)) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C, &attributes, true);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+  } else {\n+    emit_int8((unsigned char)0xF3);\n+    int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n+    emit_int32(0x0F,\n+               0x38,\n+               (unsigned char)0xF6,\n+               (0xC0 | encode));\n+  }\n@@ -13133,1 +13449,0 @@\n-\n@@ -13147,1 +13462,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x23);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x23);\n@@ -13158,1 +13473,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x21);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x21);\n@@ -13164,2 +13479,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13172,1 +13487,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13179,2 +13495,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBC, 0xC0, encode);\n@@ -13184,2 +13500,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -13189,2 +13505,2 @@\n-  int encode = prefixq_and_encode(reg->encoding());\n-  emit_int16(0x0F, (0xC8 | encode));\n+  int encode = prefixq_and_encode(reg->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xC8, encode);\n@@ -13195,2 +13511,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rbx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13203,1 +13519,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13211,2 +13528,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rdx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rdx->encoding(),  dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13219,1 +13536,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13227,2 +13545,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(rcx->encoding(), dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13235,1 +13553,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -13251,2 +13570,2 @@\n-  prefix(adr);\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  prefix(adr, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xAE);\n@@ -13264,1 +13583,1 @@\n-  prefix(adr);\n+  prefix(adr, true \/* is_map1 *\/);\n@@ -13266,1 +13585,1 @@\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  emit_int8((unsigned char)0xAE);\n@@ -13279,1 +13598,1 @@\n-  prefix(adr);\n+  prefix(adr, true \/* is_map1 *\/);\n@@ -13281,1 +13600,1 @@\n-  emit_int16(0x0F, (unsigned char)0xAE);\n+  emit_int8((unsigned char)0xAE);\n@@ -13287,2 +13606,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (0x40 | cc), (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((0x40 | cc), 0xC0, encode);\n@@ -13293,1 +13612,2 @@\n-  emit_int24(get_prefixq(src, dst), 0x0F, (0x40 | cc));\n+  int prefix = get_prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (0x40 | cc));\n@@ -13310,1 +13630,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x39);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x39);\n@@ -13321,1 +13641,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x3B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x3B);\n@@ -13327,1 +13647,2 @@\n-  emit_int24(get_prefixq(adr, reg), 0x0F, (unsigned char)0xB1);\n+  int prefix = get_prefixq(adr, reg, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB1);\n@@ -13334,1 +13655,1 @@\n-  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src->encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes, true);\n@@ -13363,1 +13684,3 @@\n-  emit_int32((unsigned char)0xF2, REX_W, 0x0F, 0x2C);\n+  emit_int8((unsigned char)0xF2);\n+  prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0x2C);\n@@ -13405,1 +13728,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xFF);\n@@ -13409,0 +13732,1 @@\n+\/\/ can't use REX2\n@@ -13415,0 +13739,1 @@\n+\/\/ can't use REX2\n@@ -13421,0 +13746,1 @@\n+\/\/ can't use REX2\n@@ -13427,0 +13753,1 @@\n+\/\/ cant use REX2\n@@ -13444,2 +13771,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xAF, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xAF, 0xC0, encode);\n@@ -13479,1 +13806,2 @@\n-  emit_int24(get_prefixq(src, dst), 0x0F, (unsigned char)0xAF);\n+  int prefix = get_prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xAF);\n@@ -13500,1 +13828,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xFF);\n@@ -13510,1 +13838,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x8D);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x8D);\n@@ -13568,2 +13896,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBD, 0xC0, encode);\n@@ -13576,2 +13904,2 @@\n-  prefixq(src, dst);\n-  emit_int16(0x0F, (unsigned char)0xBD);\n+  prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_int8((unsigned char)0xBD);\n@@ -13585,1 +13913,1 @@\n-  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -13594,1 +13922,1 @@\n-  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst->encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &attributes, true);\n@@ -13607,1 +13935,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x8B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x8B);\n@@ -13613,1 +13941,1 @@\n-  emit_int16(get_prefixq(dst, src), (unsigned char)0x89);\n+  emit_prefix_and_int8(get_prefixq(dst, src), (unsigned char)0x89);\n@@ -13619,1 +13947,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xC7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC7);\n@@ -13632,3 +13960,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xBE);\n+  int prefix = get_prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBE);\n@@ -13639,2 +13966,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBE, 0xC0, encode);\n@@ -13646,1 +13973,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xC7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC7);\n@@ -13653,1 +13980,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x63);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x63);\n@@ -13664,3 +13991,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xBF);\n+  int prefix = get_prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBF);\n@@ -13671,2 +13997,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBF, 0xC0, encode);\n@@ -13677,3 +14003,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xB6);\n+  int prefix = get_prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB6);\n@@ -13684,2 +14009,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB6, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB6, 0xC0, encode);\n@@ -13690,3 +14015,2 @@\n-  emit_int24(get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xB7);\n+  int prefix = get_prefixq(src, dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xB7);\n@@ -13697,2 +14021,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB7, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB7, 0xC0, encode);\n@@ -13703,1 +14027,1 @@\n-  emit_int16(get_prefixq(src), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(src), (unsigned char)0xF7);\n@@ -13714,2 +14038,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst1->encoding(), dst2->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst1->encoding(), dst2->encoding(), src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes, true);\n@@ -13726,1 +14050,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xF7);\n@@ -13736,2 +14060,2 @@\n-  int encode = prefixq_and_encode(src->encoding(), dst->encoding());\n-  emit_int24(0x0F, (unsigned char)0xA3, (encode | 0xC0));\n+  int encode = prefixq_and_encode(src->encoding(), dst->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xA3, 0xC0, encode);\n@@ -13742,3 +14066,2 @@\n-  int encode = prefixq_and_encode(src->encoding());\n-  emit_int16(0x0f, 0xba);\n-  emit_int8(0xe0|encode);\n+  int encode = prefixq_and_encode(src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xBA, 0xE0, encode);\n@@ -13751,3 +14074,2 @@\n-  emit_int24(get_prefixq(dst),\n-             0x0F,\n-             (unsigned char)0xBA);\n+  int prefix = get_prefixq(dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBA);\n@@ -13761,3 +14083,2 @@\n-  emit_int24(get_prefixq(dst),\n-             0x0F,\n-             (unsigned char)0xBA);\n+  int prefix = get_prefixq(dst, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xBA);\n@@ -13776,1 +14097,1 @@\n-  emit_int16(get_prefixq(dst, src), (unsigned char)0x09);\n+  emit_prefix_and_int8(get_prefixq(dst, src), (unsigned char)0x09);\n@@ -13792,1 +14113,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x0B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x0B);\n@@ -13804,4 +14125,2 @@\n-  emit_int32((unsigned char)0xF3,\n-             get_prefixq(src, dst),\n-             0x0F,\n-             (unsigned char)0xB8);\n+  emit_int8((unsigned char)0xF3);\n+  emit_prefix_and_int8(get_prefixq(src, dst, true \/* is_map1 *\/), (unsigned char) 0xB8);\n@@ -13814,2 +14133,2 @@\n-  int encode = prefixq_and_encode(dst->encoding(), src->encoding());\n-  emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));\n+  int encode = prefixq_and_encode(dst->encoding(), src->encoding(), true \/* is_map1 *\/);\n+  emit_opcode_prefix_and_encoding((unsigned char)0xB8, 0xC0, encode);\n@@ -13820,1 +14139,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0x8F);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0x8F);\n@@ -13825,1 +14144,2 @@\n-  emit_int8((unsigned char)0x58 | dst->encoding());\n+  int encode = prefix_and_encode(dst->encoding());\n+  emit_int8((unsigned char)0x58 | encode);\n@@ -13965,1 +14285,1 @@\n-  emit_int16(get_prefixq(src), (unsigned char)0xFF);\n+  emit_prefix_and_int8(get_prefixq(src), (unsigned char)0xFF);\n@@ -13991,2 +14311,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -13999,1 +14319,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -14008,2 +14329,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0,  src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &attributes, true);\n@@ -14016,1 +14337,2 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -14028,1 +14350,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -14032,1 +14354,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -14040,1 +14362,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -14063,1 +14385,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -14067,1 +14389,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -14075,1 +14397,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -14108,1 +14430,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x1B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x1B);\n@@ -14150,1 +14472,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xD3);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD3);\n@@ -14158,1 +14480,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xD1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xD1);\n@@ -14162,1 +14484,1 @@\n-    emit_int16(get_prefixq(dst), (unsigned char)0xC1);\n+    emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xC1);\n@@ -14176,1 +14498,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x29);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x29);\n@@ -14193,1 +14515,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x2B);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x2B);\n@@ -14204,1 +14526,1 @@\n-  emit_int16(get_prefixq(dst), (unsigned char)0xF7);\n+  emit_prefix_and_int8(get_prefixq(dst), (unsigned char)0xF7);\n@@ -14232,1 +14554,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x85);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x85);\n@@ -14238,1 +14560,2 @@\n-  emit_int24(get_prefixq(dst, src), 0x0F, (unsigned char)0xC1);\n+  int prefix = get_prefixq(dst, src, true \/* is_map1 *\/);\n+  emit_prefix_and_int8(prefix, (unsigned char)0xC1);\n@@ -14244,1 +14567,1 @@\n-  emit_int16(get_prefixq(src, dst), (unsigned char)0x87);\n+  emit_prefix_and_int8(get_prefixq(src, dst), (unsigned char)0x87);\n@@ -14260,1 +14583,1 @@\n-  emit_int16(get_prefixq(src, dst), 0x33);\n+  emit_prefix_and_int8(get_prefixq(src, dst), 0x33);\n@@ -14277,1 +14600,1 @@\n-  emit_int16(get_prefixq(dst, src), 0x31);\n+  emit_prefix_and_int8(get_prefixq(dst, src), 0x31);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":748,"deletions":425,"binary":false,"changes":1173,"status":"modified"},{"patch":"@@ -311,1 +311,5 @@\n-    return _base->is_valid() && _base->encoding() >= 8;\n+    return _base->is_valid() && ((_base->encoding() & 8) == 8);\n+  }\n+\n+  bool base_needs_rex2() const {\n+    return _base->is_valid() && _base->encoding() >= 16;\n@@ -315,1 +319,5 @@\n-    return _index->is_valid() &&_index->encoding() >= 8;\n+    return _index->is_valid() && ((_index->encoding() & 8) == 8);\n+  }\n+\n+  bool index_needs_rex2() const {\n+    return _index->is_valid() &&_index->encoding() >= 16;\n@@ -322,0 +330,4 @@\n+  bool xmmindex_needs_rex2() const {\n+    return _xmmindex->is_valid() && _xmmindex->encoding() >= 16;\n+  }\n+\n@@ -511,0 +523,3 @@\n+    REX2       = 0xd5,\n+    WREX2      = REX2 << 8,\n+\n@@ -517,0 +532,11 @@\n+  enum PrefixBits {\n+    REXBIT_B  = 0x01,\n+    REXBIT_X  = 0x02,\n+    REXBIT_R  = 0x04,\n+    REXBIT_W  = 0x08,\n+    REX2BIT_B4 = 0x10,\n+    REX2BIT_X4 = 0x20,\n+    REX2BIT_R4 = 0x40,\n+    REX2BIT_M0 = 0x80\n+  };\n+\n@@ -528,0 +554,1 @@\n+    EVEX_B  = 0x20,\n@@ -532,0 +559,7 @@\n+  enum ExtEvexPrefix {\n+    EEVEX_R = 0x10,\n+    EEVEX_B = 0x08,\n+    EEVEX_X = 0x04,\n+    EEVEX_V = 0x08\n+  };\n+\n@@ -543,1 +577,1 @@\n-    VEX_SIMD_F2   = 0x3\n+    VEX_SIMD_F2   = 0x3,\n@@ -551,0 +585,1 @@\n+    VEX_OPCODE_0F_3C = 0x4,\n@@ -575,1 +610,2 @@\n-    EVEX_ETUP = 23\n+    EVEX_NOSCALE = 23,\n+    EVEX_ETUP = 24\n@@ -689,0 +725,6 @@\n+  int get_base_prefix_bits(int enc);\n+  int get_index_prefix_bits(int enc);\n+  int get_base_prefix_bits(Register base);\n+  int get_index_prefix_bits(Register index);\n+  int get_reg_prefix_bits(int enc);\n+\n@@ -692,0 +734,1 @@\n+  void prefix_rex2(Register dst, Register src);\n@@ -693,3 +736,10 @@\n-\n-  void prefix(Address adr);\n-  void prefix(Address adr, Register reg,  bool byteinst = false);\n+  void prefix_rex2(Register dst, Address adr);\n+\n+  \/\/ The is_map1 bool indicates an x86 map1 instruction which, when\n+  \/\/ legacy encoded, uses a 0x0F opcode prefix.  By specification, the\n+  \/\/ opcode prefix is omitted when using rex2 encoding in support\n+  \/\/ of APX extended GPRs.\n+  void prefix(Address adr, bool is_map1 = false);\n+  void prefix_rex2(Address adr, bool is_map1 = false);\n+  void prefix(Address adr, Register reg,  bool byteinst = false, bool is_map1 = false);\n+  void prefix_rex2(Address adr, Register reg,  bool byteinst = false, bool is_map1 = false);\n@@ -697,0 +747,1 @@\n+  void prefix_rex2(Address adr, XMMRegister reg);\n@@ -698,3 +749,4 @@\n-  int prefix_and_encode(int reg_enc, bool byteinst = false);\n-  int prefix_and_encode(int dst_enc, int src_enc) {\n-    return prefix_and_encode(dst_enc, false, src_enc, false);\n+  int prefix_and_encode(int reg_enc, bool byteinst = false, bool is_map1 = false);\n+  int prefix_and_encode_rex2(int reg_enc, bool is_map1 = false);\n+  int prefix_and_encode(int dst_enc, int src_enc, bool is_map1 = false) {\n+    return prefix_and_encode(dst_enc, false, src_enc, false, is_map1);\n@@ -702,1 +754,1 @@\n-  int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);\n+  int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1 = false);\n@@ -704,0 +756,1 @@\n+  int prefix_and_encode_rex2(int dst_enc, int src_enc, int init_bits = 0);\n@@ -707,2 +760,4 @@\n-  int8_t get_prefixq(Address adr);\n-  int8_t get_prefixq(Address adr, Register reg);\n+  int get_prefixq(Address adr, bool is_map1 = false);\n+  int get_prefixq_rex2(Address adr, bool is_map1 = false);\n+  int get_prefixq(Address adr, Register reg, bool is_map1 = false);\n+  int get_prefixq_rex2(Address adr, Register reg, bool ismap1 = false);\n@@ -711,1 +766,1 @@\n-  void prefixq(Address adr, Register reg);\n+  void prefixq(Address adr, Register reg, bool is_map1 = false);\n@@ -713,0 +768,1 @@\n+  void prefixq_rex2(Address adr, XMMRegister src);\n@@ -714,2 +770,11 @@\n-  int prefixq_and_encode(int reg_enc);\n-  int prefixq_and_encode(int dst_enc, int src_enc);\n+  bool prefix_is_rex2(int prefix);\n+\n+  int prefixq_and_encode(int reg_enc, bool is_map1 = false);\n+  int prefixq_and_encode_rex2(int reg_enc, bool is_map1 = false);\n+  int prefixq_and_encode(int dst_enc, int src_enc, bool is_map1 = false);\n+  int prefixq_and_encode_rex2(int dst_enc, int src_enc, bool is_map1 = false);\n+\n+  bool needs_rex2(Register reg1, Register reg2 = noreg, Register reg3 = noreg);\n+\n+  bool needs_eevex(Register reg1, Register reg2 = noreg, Register reg3 = noreg);\n+  bool needs_eevex(int enc1, int enc2 = -1, int enc3 = -1);\n@@ -724,2 +789,2 @@\n-  void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,\n-                   int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n+  void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_v, bool evex_r, bool evex_b,\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n@@ -727,2 +792,1 @@\n-  void vex_prefix(Address adr, int nds_enc, int xreg_enc,\n-                  VexSimdPrefix pre, VexOpcode opc,\n+  void vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc,\n@@ -733,1 +797,1 @@\n-                             InstructionAttr *attributes);\n+                             InstructionAttr *attributes, bool src_is_gpr = false);\n@@ -739,1 +803,1 @@\n-                             VexOpcode opc, InstructionAttr *attributes);\n+                             VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr = false);\n@@ -824,0 +888,4 @@\n+  void emit_prefix_and_int8(int prefix, int b1);\n+  void emit_opcode_prefix_and_encoding(int byte1, int ocp_and_encoding);\n+  void emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding);\n+  void emit_opcode_prefix_and_encoding(int byte1, int byte2, int ocp_and_encoding, int byte3);\n@@ -910,0 +978,2 @@\n+  void prefix16(int p);\n+\n@@ -1733,1 +1803,1 @@\n-  void nop(int i = 1);\n+  void nop(uint i = 1);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":93,"deletions":23,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -33,2 +33,5 @@\n-inline int Assembler::prefix_and_encode(int reg_enc, bool byteinst) { return reg_enc; }\n-inline int Assembler::prefixq_and_encode(int reg_enc) { return reg_enc; }\n+inline int Assembler::prefix_and_encode(int reg_enc, bool byteinst, bool is_map1)\n+{\n+    int opc_prefix = is_map1 ? 0x0F00 : 0;\n+    return opc_prefix | reg_enc;\n+}\n@@ -36,2 +39,14 @@\n-inline int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) { return dst_enc << 3 | src_enc; }\n-inline int Assembler::prefixq_and_encode(int dst_enc, int src_enc) { return dst_enc << 3 | src_enc; }\n+inline int Assembler::prefixq_and_encode(int reg_enc, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | reg_enc;\n+}\n+\n+inline int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | (dst_enc << 3 | src_enc);\n+}\n+\n+inline int Assembler::prefixq_and_encode(int dst_enc, int src_enc, bool is_map1) {\n+    int opc_prefix = is_map1 ? 0xF00 : 0;\n+    return opc_prefix | dst_enc << 3 | src_enc;\n+}\n@@ -42,1 +57,7 @@\n-inline void Assembler::prefix(Address adr) {}\n+\n+inline void Assembler::prefix(Address adr, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n+\n@@ -45,2 +66,10 @@\n-inline void Assembler::prefix(Address adr, Register reg,  bool byteinst) {}\n-inline void Assembler::prefixq(Address adr, Register reg) {}\n+inline void Assembler::prefix(Address adr, Register reg,  bool byteinst, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n+inline void Assembler::prefixq(Address adr, Register reg, bool is_map1) {\n+    if (is_map1) {\n+        emit_int8(0x0F);\n+    }\n+}\n@@ -50,0 +79,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.inline.hpp","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -5663,1 +5663,0 @@\n-#ifdef _LP64\n@@ -5697,1 +5696,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-  __ shrptr(tmp, HeapRegion::LogOfHRGrainBytes);\n+  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,30 +370,0 @@\n-void BarrierSetAssembler::incr_allocated_bytes(MacroAssembler* masm, Register thread,\n-                                               Register var_size_in_bytes,\n-                                               int con_size_in_bytes,\n-                                               Register t1) {\n-  if (!thread->is_valid()) {\n-#ifdef _LP64\n-    thread = r15_thread;\n-#else\n-    assert(t1->is_valid(), \"need temp reg\");\n-    thread = t1;\n-    __ get_thread(thread);\n-#endif\n-  }\n-\n-#ifdef _LP64\n-  if (var_size_in_bytes->is_valid()) {\n-    __ addq(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), var_size_in_bytes);\n-  } else {\n-    __ addq(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), con_size_in_bytes);\n-  }\n-#else\n-  if (var_size_in_bytes->is_valid()) {\n-    __ addl(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), var_size_in_bytes);\n-  } else {\n-    __ addl(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), con_size_in_bytes);\n-  }\n-  __ adcl(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())+4), 0);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,6 +40,0 @@\n-private:\n-  void incr_allocated_bytes(MacroAssembler* masm, Register thread,\n-                            Register var_size_in_bytes,\n-                            int con_size_in_bytes,\n-                            Register t1);\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -222,1 +222,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -238,2 +238,4 @@\n-             \"mitigations for the Intel JCC erratum\")\n-\n+             \"mitigations for the Intel JCC erratum\")                       \\\n+                                                                            \\\n+  product(bool, UseAPX, false, EXPERIMENTAL,                                \\\n+          \"Use Advanced Performance Extensions on x86\")                     \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1160,1 +1160,1 @@\n-  align(64, (unsigned long long) pc());\n+  align(64, (uint)(uintptr_t)pc());\n@@ -1164,1 +1164,1 @@\n-  align(32, (unsigned long long) pc());\n+  align(32, (uint)(uintptr_t)pc());\n@@ -1167,1 +1167,1 @@\n-void MacroAssembler::align(int modulus) {\n+void MacroAssembler::align(uint modulus) {\n@@ -1169,1 +1169,1 @@\n-  assert(modulus <= CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n+  assert(modulus <= (uintx)CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n@@ -1173,1 +1173,1 @@\n-void MacroAssembler::align(int modulus, int target) {\n+void MacroAssembler::align(uint modulus, uint target) {\n@@ -7747,1 +7747,1 @@\n- * r11: zlen\n+ * r11: tmp0\n@@ -7755,1 +7755,1 @@\n-void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,\n+void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register tmp0,\n@@ -7758,1 +7758,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);\n+  assert_different_registers(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);\n@@ -7760,0 +7760,1 @@\n+  push(tmp0);\n@@ -7767,1 +7768,0 @@\n-  push(zlen);\n@@ -7776,1 +7776,1 @@\n-  const Register x_xstart = zlen;  \/\/ reuse register\n+  const Register x_xstart = tmp0;\n@@ -7792,3 +7792,3 @@\n-  movl(idx, ylen);      \/\/ idx = ylen;\n-  movl(kdx, zlen);      \/\/ kdx = xlen+ylen;\n-  xorq(carry, carry);   \/\/ carry = 0;\n+  movl(idx, ylen);               \/\/ idx = ylen;\n+  lea(kdx, Address(xlen, ylen)); \/\/ kdx = xlen+ylen;\n+  xorq(carry, carry);            \/\/ carry = 0;\n@@ -7898,1 +7898,0 @@\n-  pop(zlen);\n@@ -7906,0 +7905,1 @@\n+  pop(tmp0);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -249,2 +249,2 @@\n-  void align(int modulus);\n-  void align(int modulus, int target);\n+  void align(uint modulus);\n+  void align(uint modulus, uint target);\n@@ -2094,1 +2094,1 @@\n-  void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,\n+  void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register tmp0,\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3063,1 +3063,0 @@\n- *    c_rarg5   - z length\n@@ -3066,1 +3065,0 @@\n- *    rsp+48    - z length\n@@ -3080,1 +3078,0 @@\n-  const Register zlen  = r11;\n@@ -3083,0 +3080,1 @@\n+  const Register tmp0  = r11;\n@@ -3092,3 +3090,0 @@\n-#ifndef _WIN64\n-  __ movptr(zlen, r9); \/\/ Save r9 in r11 - zlen\n-#endif\n@@ -3096,1 +3091,1 @@\n-                     \/\/ ylen => rcx, z => r8, zlen => r11\n+                     \/\/ ylen => rcx, z => r8\n@@ -3099,1 +3094,1 @@\n-  \/\/ last 2 arguments (#4, #5) are on stack on Win64\n+  \/\/ last argument (#4) is on stack on Win64\n@@ -3101,1 +3096,0 @@\n-  __ movptr(zlen, Address(rsp, 7 * wordSize));\n@@ -3106,1 +3100,1 @@\n-  __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5);\n+  __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1005,0 +1005,8 @@\n+  \/\/ APX support not enabled yet\n+  if (UseAPX) {\n+    if (!FLAG_IS_DEFAULT(UseAPX)) {\n+        warning(\"APX is not supported on this CPU.\");\n+    }\n+    FLAG_SET_DEFAULT(UseAPX, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7271,0 +7271,1 @@\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_DOUBLE);\n@@ -7274,2 +7275,0 @@\n-    assert(UseAVX > 0, \"required\");\n-\n@@ -7283,0 +7282,11 @@\n+instruct vcastBtoD(legVec dst, legVec src) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastB2X src));\n+  format %{ \"vector_cast_b2x $dst,$src\\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vconvert_b2x(T_DOUBLE, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#ifdef __APPLE__\n+  # macOS prefixes symbols with _\n+  #define SYMBOL(s) _ ## s\n+\n+  #define DECLARE_FUNC(func) \\\n+    .globl SYMBOL(func) ; \\\n+    .private_extern SYMBOL(func) ; \\\n+    SYMBOL(func)\n+#else\n+  #define SYMBOL(s) s\n+\n+  #define DECLARE_FUNC(func) \\\n+    .globl func ; \\\n+    .hidden func ; \\\n+    .type func, %function ; \\\n+    func\n+#endif\n","filename":"src\/hotspot\/os\/bsd\/defs.S.inc","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -559,1 +559,145 @@\n-jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n+bool CgroupController::read_string(const char* filename, char* buf, size_t buf_size) {\n+  assert(buf != nullptr, \"buffer must not be null\");\n+  assert(filename != nullptr, \"filename must be given\");\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_string: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  \/\/ Read a single line into the provided buffer.\n+  \/\/ At most buf_size - 1 characters.\n+  char* line = fgets(buf, buf_size, fp);\n+  fclose(fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    return false;\n+  }\n+  size_t len = strlen(line);\n+  assert(len <= buf_size - 1, \"At most buf_size - 1 bytes can be read\");\n+  if (line[len - 1] == '\\n') {\n+    line[len - 1] = '\\0'; \/\/ trim trailing new line\n+  }\n+  return true;\n+}\n+\n+bool CgroupController::read_number(const char* filename, julong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  int matched = sscanf(buf, JULONG_FORMAT, result);\n+  if (matched == 1) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool CgroupController::read_number_handle_max(const char* filename, jlong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  jlong val = limit_from_str(buf);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+  assert(key != nullptr, \"key must be given\");\n+  assert(result != nullptr, \"result pointer must not be null\");\n+  assert(filename != nullptr, \"file to search in must be given\");\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  bool found_match = false;\n+  \/\/ File consists of multiple lines in a \"key value\"\n+  \/\/ fashion, we have to find the key.\n+  const size_t key_len = strlen(key);\n+  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+    char after_key = line[key_len];\n+    if (strncmp(line, key, key_len) == 0\n+          && isspace(after_key) != 0\n+          && after_key != '\\n') {\n+      \/\/ Skip key, skip space\n+      const char* value_substr = line + key_len + 1;\n+      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      found_match = matched == 1;\n+      if (found_match) {\n+        break;\n+      }\n+    }\n+  }\n+  fclose(fp);\n+  if (found_match) {\n+    return true;\n+  }\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+                           key, absolute_path);\n+  return false;\n+}\n+\n+bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, jlong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  char token[1024];\n+  const int matched = sscanf(buf, (use_first ? \"%1023s %*s\" : \"%*s %1023s\"), token);\n+  if (matched != 1) {\n+    return false;\n+  }\n+  jlong val = limit_from_str(token);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+jlong CgroupController::limit_from_str(char* limit_str) {\n@@ -566,1 +710,0 @@\n-    os::free(limit_str);\n@@ -571,1 +714,0 @@\n-    os::free(limit_str);\n@@ -574,1 +716,0 @@\n-  os::free(limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":145,"deletions":4,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -72,87 +72,9 @@\n-typedef char * cptr;\n-\n-class CgroupController: public CHeapObj<mtInternal> {\n-  public:\n-    virtual char *subsystem_path() = 0;\n-};\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-\/\/ Parses a subsystem's file, looking for a matching line.\n-\/\/ If key is null, then the first line will be matched with scan_fmt.\n-\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n-\/\/ The matching value will be assigned to returnval.\n-\/\/ scan_fmt uses scanf() syntax.\n-\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n-template <typename T> int subsystem_file_line_contents(CgroupController* c,\n-                                              const char *filename,\n-                                              const char *key,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  if (c == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  stringStream file_path;\n-  file_path.print_raw(c->subsystem_path());\n-  file_path.print_raw(filename);\n-\n-  if (file_path.size() > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  const char* absolute_path = file_path.freeze();\n-  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n-\n-  FILE* fp = os::fopen(absolute_path, \"r\");\n-  if (fp == nullptr) {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  const int buf_len = MAXPATHLEN+1;\n-  char buf[buf_len];\n-  char* line = fgets(buf, buf_len, fp);\n-  if (line == nullptr) {\n-    log_debug(os, container)(\"Empty file %s\", absolute_path);\n-    fclose(fp);\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  bool found_match = false;\n-  if (key == nullptr) {\n-    \/\/ File consists of a single line according to caller, with only a value\n-    int matched = sscanf(line, scan_fmt, returnval);\n-    found_match = matched == 1;\n-  } else {\n-    \/\/ File consists of multiple lines in a \"key value\"\n-    \/\/ fashion, we have to find the key.\n-    const int key_len = (int)strlen(key);\n-    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n-      char* key_substr = strstr(line, key);\n-      char after_key = line[key_len];\n-      if (key_substr == line\n-          && isspace(after_key) != 0\n-          && after_key != '\\n') {\n-        \/\/ Skip key, skip space\n-        const char* value_substr = line + key_len + 1;\n-        int matched = sscanf(value_substr, scan_fmt, returnval);\n-        found_match = matched == 1;\n-        if (found_match) {\n-          break;\n-        }\n-      }\n-    }\n-  }\n-  fclose(fp);\n-  if (found_match) {\n-    return 0;\n-  }\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", scan_fmt,\n-                           (key == nullptr ? \"null\" : key), absolute_path);\n-  return OSCONTAINER_ERROR;\n+#define CONTAINER_READ_NUMBER_CHECKED(controller, filename, log_string, retval)       \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number(filename, &retval);                                 \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n@@ -160,1 +82,0 @@\n-PRAGMA_DIAG_POP\n@@ -162,18 +83,9 @@\n-\/\/ log_fmt can be different than scan_fmt. For example\n-\/\/ cpu_period() for cgv2 uses log_fmt='%d' and scan_fmt='%*s %d'\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, log_fmt, scan_fmt, variable)        \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0) {                                                         \\\n-    log_trace(os, container)(logstring \"%d\", OSCONTAINER_ERROR);          \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-  }                                                                       \\\n-                                                                          \\\n-  log_trace(os, container)(logstring log_fmt, variable);                  \\\n+#define CONTAINER_READ_NUMBER_CHECKED_MAX(controller, filename, log_string, retval)   \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number_handle_max(filename, &retval);                      \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JLONG_FORMAT, retval);                  \\\n@@ -182,14 +94,9 @@\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) nullptr;                                         \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n+#define CONTAINER_READ_STRING_CHECKED(controller, filename, log_string, retval, buf_size) \\\n+{                                                                                         \\\n+  bool is_ok;                                                                             \\\n+  is_ok = controller->read_string(filename, retval, buf_size);                            \\\n+  if (!is_ok) {                                                                           \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);                \\\n+    return nullptr;                                                                       \\\n+  }                                                                                       \\\n+  log_trace(os, container)(log_string \" is: %s\", retval);                                 \\\n@@ -198,15 +105,48 @@\n-#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(controller,                          \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char* subsystem_path() = 0;\n+\n+    \/* Read a numerical value as unsigned long\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value is set in the provided julong pointer.\n+     *\/\n+    bool read_number(const char* filename, julong* result);\n+\n+    \/* Convenience method to deal with numbers as well as the string 'max'\n+     * in interface files. Otherwise same as read_number().\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value (which might be negative) is being set in\n+     * the provided jlong pointer.\n+     *\/\n+    bool read_number_handle_max(const char* filename, jlong* result);\n+\n+    \/* Read a string of at most buf_size - 1 characters from the interface file.\n+     * The provided buffer must be at least buf_size in size so as to account\n+     * for the null terminating character. Callers must ensure that the buffer\n+     * is appropriately in-scope and of sufficient size.\n+     *\n+     * returns: false if any error occured. true otherwise and the passed\n+     * in buffer will contain the first buf_size - 1 characters of the string\n+     * or up to the first new line character ('\\n') whichever comes first.\n+     *\/\n+    bool read_string(const char* filename, char* buf, size_t buf_size);\n+\n+    \/* Read a tuple value as a number. Tuple is: '<first> <second>'.\n+     * Handles 'max' (for unlimited) for any tuple value. This is handy for\n+     * parsing interface files like cpu.max which contain such tuples.\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed\n+     * value of the appropriate tuple entry set in the provided jlong pointer.\n+     *\/\n+    bool read_numerical_tuple_value(const char* filename, bool use_first, jlong* result);\n+\n+    \/* Read a numerical value from a multi-line interface file. The matched line is\n+     * determined by the provided 'key'. The associated numerical value is being set\n+     * via the passed in julong pointer. Example interface file 'memory.stat'\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed value is\n+     * being set in the provided julong pointer.\n+     *\/\n+    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n@@ -214,0 +154,3 @@\n+  private:\n+    static jlong limit_from_str(char* limit_str);\n+};\n@@ -258,1 +201,0 @@\n-    jlong limit_from_str(char* limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":78,"deletions":136,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -78,3 +78,3 @@\n-  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \", JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n+  julong use_hierarchy;\n+  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  return (jlong)use_hierarchy;\n@@ -92,3 +92,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n+  julong memlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n@@ -99,2 +98,8 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n+      julong hier_memlimit;\n+      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+                                                                   \"hierarchical_memory_limit\",\n+                                                                   &hier_memlimit);\n+      if (!is_ok) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n@@ -128,2 +133,3 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  julong hier_memswlimit;\n+  julong memswlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -136,2 +142,7 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n+      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+                                                                   matchline,\n+                                                                   &hier_memswlimit);\n+      if (!is_ok) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n@@ -171,0 +182,7 @@\n+static inline\n+jlong memory_swap_usage_impl(CgroupController* ctrl) {\n+  julong memory_swap_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n+  return (jlong)memory_swap_usage;\n+}\n+\n@@ -177,3 +195,1 @@\n-      GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.usage_in_bytes\",\n-                         \"mem swap usage is: \", JULONG_FORMAT, JULONG_FORMAT, memory_swap_usage);\n-      return (jlong)memory_swap_usage;\n+      return memory_swap_usage_impl(_memory->controller());\n@@ -186,3 +202,3 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.swappiness\",\n-                     \"Swappiness is: \", JULONG_FORMAT, JULONG_FORMAT, swappiness);\n-  return swappiness;\n+  julong swappiness;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  return (jlong)swappiness;\n@@ -192,2 +208,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  julong memsoftlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n@@ -212,3 +228,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -226,3 +242,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n+  julong memmaxusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  return (jlong)memmaxusage;\n@@ -232,3 +248,9 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"rss\", JULONG_FORMAT, JULONG_FORMAT, rss);\n-  return rss;\n+  julong rss;\n+  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+                                                               \"rss\",\n+                                                               &rss);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n@@ -238,2 +260,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"cache\", JULONG_FORMAT, JULONG_FORMAT, cache);\n+  julong cache;\n+  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+                                                               \"cache\",\n+                                                               &cache);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n@@ -244,3 +272,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n-                     \"Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_usage);\n-  return kmem_usage;\n+  julong kmem_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  return (jlong)kmem_usage;\n@@ -250,2 +278,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n-                     \"Kernel Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, kmem_limit);\n+  julong kmem_limit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n@@ -259,3 +287,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n-                     \"Maximum Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_max_usage);\n-  return kmem_max_usage;\n+  julong kmem_max_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  return (jlong)kmem_max_usage;\n@@ -274,3 +302,3 @@\n-char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+char* CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -280,3 +308,3 @@\n-char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+char* CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -297,3 +325,12 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: \", \"%d\", \"%d\", quota);\n-  return quota;\n+  julong quota;\n+  bool is_ok = _cpu->controller()->\n+                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Quota failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ cast to int since the read value might be negative\n+  \/\/ and we want to avoid logging -1 as a large unsigned value.\n+  int quota_int = (int)quota;\n+  log_trace(os, container)(\"CPU Quota is: %d\", quota_int);\n+  return quota_int;\n@@ -303,3 +340,3 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: \", \"%d\", \"%d\", period);\n-  return period;\n+  julong period;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  return (int)period;\n@@ -319,2 +356,3 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n-                     \"CPU Shares is: \", \"%d\", \"%d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -322,5 +360,1 @@\n-  if (shares == 1024) return -1;\n-\n-  return shares;\n-}\n-\n+  if (shares_int == 1024) return -1;\n@@ -328,4 +362,1 @@\n-char* CgroupV1Subsystem::pids_max_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n+  return shares_int;\n@@ -345,2 +376,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_pids, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n@@ -359,3 +391,3 @@\n-  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n-  return pids_current;\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  return (jlong)pids_current;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":99,"deletions":67,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -117,2 +117,0 @@\n-    char * pids_max_val();\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,3 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n-                     \"Raw value for CPU Shares is: \", \"%d\", \"%d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -41,1 +42,1 @@\n-  if (shares == 100) {\n+  if (shares_int == 100) {\n@@ -53,1 +54,1 @@\n-  int x = 262142 * shares - 1;\n+  int x = 262142 * shares_int - 1;\n@@ -86,2 +87,6 @@\n-  char * cpu_quota_str = cpu_quota_val();\n-  int limit = (int)limit_from_str(cpu_quota_str);\n+  jlong quota_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  int limit = (int)quota_val;\n@@ -92,3 +97,3 @@\n-char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+char* CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -98,9 +103,3 @@\n-char* CgroupV2Subsystem::cpu_quota_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n-                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n-  return os::strdup(quota);\n-}\n-\n-char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+char* CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -111,2 +110,8 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n-                     \"CPU Period is: \", \"%d\", \"%*s %d\", period);\n+  jlong period_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Period failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  int period = (int)period_val;\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -126,3 +131,3 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -132,2 +137,3 @@\n-  char* mem_soft_limit_str = mem_soft_limit_val();\n-  return limit_from_str(mem_soft_limit_str);\n+  jlong mem_soft_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  return mem_soft_limit;\n@@ -143,3 +149,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"anon\", JULONG_FORMAT, JULONG_FORMAT, rss);\n-  return rss;\n+  julong rss;\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n@@ -149,9 +160,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"file\", JULONG_FORMAT, JULONG_FORMAT, cache);\n-  return cache;\n-}\n-\n-char* CgroupV2Subsystem::mem_soft_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n-                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n-  return os::strdup(mem_soft_limit_str);\n+  julong cache;\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n+  return (jlong)cache;\n@@ -166,2 +176,3 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  if (mem_swp_limit_str == nullptr) {\n+  jlong swap_limit;\n+  bool is_ok = _memory->controller()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  if (!is_ok) {\n@@ -169,1 +180,1 @@\n-    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+    log_trace(os, container)(\"Swap Limit failed: %d\", OSCONTAINER_ERROR);\n@@ -173,1 +184,1 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  log_trace(os, container)(\"Swap Limit is: \" JLONG_FORMAT, swap_limit);\n@@ -186,2 +197,1 @@\n-        char* mem_swp_current_str = mem_swp_current_val();\n-        jlong swap_current = limit_from_str(mem_swp_current_str);\n+        jlong swap_current = mem_swp_current_val();\n@@ -193,4 +203,4 @@\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n-                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n-  return os::strdup(mem_swp_limit_str);\n+jlong CgroupV2Subsystem::mem_swp_limit_val() {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -200,4 +210,4 @@\n-char* CgroupV2Subsystem::mem_swp_current_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.current\",\n-                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n-  return os::strdup(mem_swp_current_str);\n+jlong CgroupV2Subsystem::mem_swp_current_val() {\n+  julong swap_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  return (jlong)swap_current;\n@@ -215,16 +225,3 @@\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n-  if (log_is_enabled(Trace, os, container)) {\n-    if (limit == -1) {\n-      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n-    } else {\n-      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n-    }\n-  }\n-  return limit;\n-}\n-\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n-                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n-  return os::strdup(mem_limit_str);\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n@@ -234,5 +231,2 @@\n-  char* mem_swp_current_str = mem_swp_current_val();\n-  jlong swap_current = limit_from_str(mem_swp_current_str);\n-\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  jlong swap_current = mem_swp_current_val();\n+  jlong swap_limit = mem_swp_limit_val();\n@@ -253,6 +247,0 @@\n-char* CgroupV2Subsystem::pids_max_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n-}\n-\n@@ -269,2 +257,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n@@ -282,2 +271,2 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":71,"deletions":82,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -59,6 +59,2 @@\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n-    char *mem_swp_current_val();\n-    char *mem_soft_limit_val();\n-    char *cpu_quota_val();\n-    char *pids_max_val();\n+    jlong mem_swp_limit_val();\n+    jlong mem_swp_current_val();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Used to get a reference to a symbol. (Overridden by macOS.)\n+#define SYMBOL(s) s\n+\n+#define DECLARE_FUNC(func) \\\n+    .globl func ; \\\n+    .hidden func ; \\\n+    .type func, %function ; \\\n+    func\n","filename":"src\/hotspot\/os\/posix\/defs.S.inc","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -428,11 +428,0 @@\n-int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {\n-  \/\/ All supported POSIX platforms provide C99 semantics.\n-  ALLOW_C_FUNCTION(::vsnprintf, int result = ::vsnprintf(buf, len, fmt, args);)\n-  \/\/ If an encoding error occurred (result < 0) then it's not clear\n-  \/\/ whether the buffer is NUL terminated, so ensure it is.\n-  if ((result < 0) && (len > 0)) {\n-    buf[len - 1] = '\\0';\n-  }\n-  return result;\n-}\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1742,11 +1742,0 @@\n-int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {\n-  \/\/ Starting with Visual Studio 2015, vsnprint is C99 compliant.\n-  ALLOW_C_FUNCTION(::vsnprintf, int result = ::vsnprintf(buf, len, fmt, args);)\n-  \/\/ If an encoding error occurred (result < 0) then it's not clear\n-  \/\/ whether the buffer is NUL terminated, so ensure it is.\n-  if ((result < 0) && (len > 0)) {\n-    buf[len - 1] = '\\0';\n-  }\n-  return result;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,9 +27,1 @@\n-#define CFUNC(x) _##x\n-\n-        .global CFUNC(_Copy_conjoint_words)\n-        .global CFUNC(_Copy_disjoint_words)\n-\n-#ifdef __APPLE__\n-        .private_extern CFUNC(_Copy_conjoint_words)\n-        .private_extern CFUNC(_Copy_disjoint_words)\n-#endif\n+#include \"defs.S.inc\"\n@@ -49,1 +42,1 @@\n-CFUNC(_Copy_disjoint_words):\n+DECLARE_FUNC(_Copy_disjoint_words):\n@@ -147,1 +140,1 @@\n-CFUNC(_Copy_conjoint_words):\n+DECLARE_FUNC(_Copy_conjoint_words):\n@@ -150,1 +143,1 @@\n-        bhs     CFUNC(_Copy_disjoint_words)\n+        bhs     SYMBOL(_Copy_disjoint_words)\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/copy_bsd_aarch64.S","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#ifdef __APPLE__\n+  # macOS prefixes symbols with _\n+  #define SYMBOL(s) _ ## s\n+\n+  #define DECLARE_FUNC(func) \\\n+    .globl SYMBOL(func) %% \\\n+    .private_extern SYMBOL(func) %% \\\n+    SYMBOL(func)\n+#else\n+  #define SYMBOL(s) s\n+\n+  #define DECLARE_FUNC(func) \\\n+    .globl func %% \\\n+    .hidden func %% \\\n+    .type func, %function %% \\\n+    func\n+#endif\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/defs.S.inc","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -26,24 +26,1 @@\n-#ifdef __APPLE__\n-# Darwin uses _ prefixed global symbols\n-#define SYMBOL(s) _ ## s\n-#define ELF_TYPE(name, description)\n-#else\n-#define SYMBOL(s) s\n-#define ELF_TYPE(name, description) .type name,description\n-#endif\n-\n-    .global SYMBOL(SafeFetchN_impl)\n-    .global SYMBOL(_SafeFetchN_fault)\n-    .global SYMBOL(_SafeFetchN_continuation)\n-    .global SYMBOL(SafeFetch32_impl)\n-    .global SYMBOL(_SafeFetch32_fault)\n-    .global SYMBOL(_SafeFetch32_continuation)\n-\n-#ifdef __APPLE__\n-    .private_extern SYMBOL(SafeFetchN_impl)\n-    .private_extern SYMBOL(_SafeFetchN_fault)\n-    .private_extern SYMBOL(_SafeFetchN_continuation)\n-    .private_extern SYMBOL(SafeFetch32_impl)\n-    .private_extern SYMBOL(_SafeFetch32_fault)\n-    .private_extern SYMBOL(_SafeFetch32_continuation)\n-#endif\n+#include \"defs.S.inc\"\n@@ -58,3 +35,2 @@\n-    ELF_TYPE(SafeFetch32_impl,@function)\n-SYMBOL(SafeFetch32_impl):\n-SYMBOL(_SafeFetch32_fault):\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -63,1 +39,1 @@\n-SYMBOL(_SafeFetch32_continuation):\n+DECLARE_FUNC(_SafeFetch32_continuation):\n@@ -73,3 +49,2 @@\n-    ELF_TYPE(SafeFetchN_impl,@function)\n-SYMBOL(SafeFetchN_impl):\n-SYMBOL(_SafeFetchN_fault):\n+DECLARE_FUNC(SafeFetchN_impl):\n+DECLARE_FUNC(_SafeFetchN_fault):\n@@ -78,1 +53,1 @@\n-SYMBOL(_SafeFetchN_continuation):\n+DECLARE_FUNC(_SafeFetchN_continuation):\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/safefetch_bsd_aarch64.S","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -24,12 +24,1 @@\n-\n-#ifdef __APPLE__\n-# Darwin uses _ prefixed global symbols\n-#define SYMBOL(s) _ ## s\n-#define ELF_TYPE(name, description)\n-#else\n-#define SYMBOL(s) s\n-#define ELF_TYPE(name, description) .type name,description\n-#endif\n-\n-        .globl SYMBOL(fixcw)\n-        .globl SYMBOL(SpinPause)\n+#include \"defs.S.inc\"\n@@ -43,25 +32,0 @@\n-        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)\n-        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)\n-        .globl SYMBOL(_Copy_arrayof_conjoint_jshorts)\n-        .globl SYMBOL(_Copy_conjoint_jints_atomic)\n-        .globl SYMBOL(_Copy_arrayof_conjoint_jints)\n-        .globl SYMBOL(_Copy_conjoint_jlongs_atomic)\n-        .globl SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts)\n-\n-        .globl SYMBOL(_Atomic_cmpxchg_long)\n-        .globl SYMBOL(_Atomic_move_long)\n-\n-#ifdef __APPLE__\n-        .private_extern SYMBOL(fixcw)\n-        .private_extern SYMBOL(SpinPause)\n-        .private_extern SYMBOL(_Copy_arrayof_conjoint_bytes)\n-        .private_extern SYMBOL(_Copy_conjoint_jshorts_atomic)\n-        .private_extern SYMBOL(_Copy_arrayof_conjoint_jshorts)\n-        .private_extern SYMBOL(_Copy_conjoint_jints_atomic)\n-        .private_extern SYMBOL(_Copy_arrayof_conjoint_jints)\n-        .private_extern SYMBOL(_Copy_conjoint_jlongs_atomic)\n-        .private_extern SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts)\n-        .private_extern SYMBOL(_Atomic_cmpxchg_long)\n-        .private_extern SYMBOL(_Atomic_move_long)\n-#endif\n-\n@@ -70,1 +34,0 @@\n-# Support for void os::Solaris::init_thread_fpu_state() in os_solaris_i486.cpp\n@@ -72,1 +35,0 @@\n-# ported from solaris_x86_32.s\n@@ -74,1 +36,1 @@\n-SYMBOL(fixcw):\n+DECLARE_FUNC(fixcw):\n@@ -80,1 +42,0 @@\n-        ELF_TYPE(SpinPause,@function)\n@@ -82,1 +43,1 @@\n-SYMBOL(SpinPause):\n+DECLARE_FUNC(SpinPause):\n@@ -93,2 +54,1 @@\n-        ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)\n-SYMBOL(_Copy_arrayof_conjoint_bytes):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_bytes):\n@@ -181,2 +141,1 @@\n-        ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)\n-SYMBOL(_Copy_conjoint_jshorts_atomic):\n+DECLARE_FUNC(_Copy_conjoint_jshorts_atomic):\n@@ -268,2 +227,1 @@\n-        ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)\n-SYMBOL(_Copy_arrayof_conjoint_jshorts):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jshorts):\n@@ -345,4 +303,2 @@\n-        ELF_TYPE(_Copy_conjoint_jints_atomic,@function)\n-        ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)\n-SYMBOL(_Copy_conjoint_jints_atomic):\n-SYMBOL(_Copy_arrayof_conjoint_jints):\n+DECLARE_FUNC(_Copy_conjoint_jints_atomic):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jints):\n@@ -420,2 +376,1 @@\n-        ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)\n-SYMBOL(_Copy_conjoint_jlongs_atomic):\n+DECLARE_FUNC(_Copy_conjoint_jlongs_atomic):\n@@ -449,2 +404,1 @@\n-        ELF_TYPE(_mmx_Copy_arrayof_conjoint_jshorts,@function)\n-SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts):\n+DECLARE_FUNC(_mmx_Copy_arrayof_conjoint_jshorts):\n@@ -547,2 +501,1 @@\n-        ELF_TYPE(_Atomic_cmpxchg_long,@function)\n-SYMBOL(_Atomic_cmpxchg_long):\n+DECLARE_FUNC(_Atomic_cmpxchg_long):\n@@ -567,2 +520,1 @@\n-        ELF_TYPE(_Atomic_move_long,@function)\n-SYMBOL(_Atomic_move_long):\n+DECLARE_FUNC(_Atomic_move_long):\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/bsd_x86_32.S","additions":12,"deletions":60,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -24,8 +24,1 @@\n-#ifdef __APPLE__\n-# Darwin uses _ prefixed global symbols\n-#define SYMBOL(s) _ ## s\n-#define ELF_TYPE(name, description)\n-#else\n-#define SYMBOL(s) s\n-#define ELF_TYPE(name, description) .type name,description\n-#endif\n+#include \"defs.S.inc\"\n@@ -39,20 +32,0 @@\n-        .globl SYMBOL(SpinPause)\n-        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)\n-        .globl SYMBOL(_Copy_arrayof_conjoint_jshorts)\n-        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)\n-        .globl SYMBOL(_Copy_arrayof_conjoint_jints)\n-        .globl SYMBOL(_Copy_conjoint_jints_atomic)\n-        .globl SYMBOL(_Copy_arrayof_conjoint_jlongs)\n-        .globl SYMBOL(_Copy_conjoint_jlongs_atomic)\n-\n-#ifdef __APPLE__\n-        .private_extern SYMBOL(SpinPause)\n-        .private_extern SYMBOL(_Copy_arrayof_conjoint_bytes)\n-        .private_extern SYMBOL(_Copy_arrayof_conjoint_jshorts)\n-        .private_extern SYMBOL(_Copy_conjoint_jshorts_atomic)\n-        .private_extern SYMBOL(_Copy_arrayof_conjoint_jints)\n-        .private_extern SYMBOL(_Copy_conjoint_jints_atomic)\n-        .private_extern SYMBOL(_Copy_arrayof_conjoint_jlongs)\n-        .private_extern SYMBOL(_Copy_conjoint_jlongs_atomic)\n-#endif\n-\n@@ -62,2 +35,1 @@\n-        ELF_TYPE(SpinPause,@function)\n-SYMBOL(SpinPause):\n+DECLARE_FUNC(SpinPause):\n@@ -77,2 +49,1 @@\n-        ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)\n-SYMBOL(_Copy_arrayof_conjoint_bytes):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_bytes):\n@@ -179,4 +150,2 @@\n-        ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)\n-        ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)\n-SYMBOL(_Copy_arrayof_conjoint_jshorts):\n-SYMBOL(_Copy_conjoint_jshorts_atomic):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jshorts):\n+DECLARE_FUNC(_Copy_conjoint_jshorts_atomic):\n@@ -269,4 +238,2 @@\n-        ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)\n-        ELF_TYPE(_Copy_conjoint_jints_atomic,@function)\n-SYMBOL(_Copy_arrayof_conjoint_jints):\n-SYMBOL(_Copy_conjoint_jints_atomic):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jints):\n+DECLARE_FUNC(_Copy_conjoint_jints_atomic):\n@@ -348,4 +315,2 @@\n-        ELF_TYPE(_Copy_arrayof_conjoint_jlongs,@function)\n-        ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)\n-SYMBOL(_Copy_arrayof_conjoint_jlongs):\n-SYMBOL(_Copy_conjoint_jlongs_atomic):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jlongs):\n+DECLARE_FUNC(_Copy_conjoint_jlongs_atomic):\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/bsd_x86_64.S","additions":9,"deletions":44,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -25,24 +25,1 @@\n-#ifdef __APPLE__\n-# Darwin uses _ prefixed global symbols\n-#define SYMBOL(s) _ ## s\n-#define ELF_TYPE(name, description)\n-#else\n-#define SYMBOL(s) s\n-#define ELF_TYPE(name, description) .type name,description\n-#endif\n-\n-    .globl SYMBOL(SafeFetch32_impl)\n-    .globl SYMBOL(SafeFetchN_impl)\n-    .globl SYMBOL(_SafeFetch32_fault)\n-    .globl SYMBOL(_SafeFetchN_fault)\n-    .globl SYMBOL(_SafeFetch32_continuation)\n-    .globl SYMBOL(_SafeFetchN_continuation)\n-\n-#ifdef __APPLE__\n-    .private_extern SYMBOL(SafeFetch32_impl)\n-    .private_extern SYMBOL(SafeFetchN_impl)\n-    .private_extern SYMBOL(_SafeFetch32_fault)\n-    .private_extern SYMBOL(_SafeFetchN_fault)\n-    .private_extern SYMBOL(_SafeFetch32_continuation)\n-    .private_extern SYMBOL(_SafeFetchN_continuation)\n-#endif\n+#include \"defs.S.inc\"\n@@ -56,3 +33,2 @@\n-    ELF_TYPE(SafeFetch32_impl,@function)\n-SYMBOL(SafeFetch32_impl:)\n-SYMBOL(_SafeFetch32_fault:)\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -61,1 +37,1 @@\n-SYMBOL(_SafeFetch32_continuation:)\n+DECLARE_FUNC(_SafeFetch32_continuation):\n@@ -69,3 +45,2 @@\n-    ELF_TYPE(SafeFetchN_impl,@function)\n-SYMBOL(SafeFetchN_impl:)\n-SYMBOL(_SafeFetchN_fault:)\n+DECLARE_FUNC(SafeFetchN_impl):\n+DECLARE_FUNC(_SafeFetchN_fault):\n@@ -74,1 +49,1 @@\n-SYMBOL(_SafeFetchN_continuation:)\n+DECLARE_FUNC(_SafeFetchN_continuation):\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/safefetch_bsd_x86_64.S","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +23,1 @@\n-\n+#include \"defs.S.inc\"\n@@ -26,2 +27,0 @@\n-        .globl aarch64_atomic_fetch_add_8_default_impl\n-        .hidden aarch64_atomic_fetch_add_8_default_impl\n@@ -29,1 +28,1 @@\n-aarch64_atomic_fetch_add_8_default_impl:\n+DECLARE_FUNC(aarch64_atomic_fetch_add_8_default_impl):\n@@ -43,2 +42,0 @@\n-        .globl aarch64_atomic_fetch_add_4_default_impl\n-        .hidden aarch64_atomic_fetch_add_4_default_impl\n@@ -46,1 +43,1 @@\n-aarch64_atomic_fetch_add_4_default_impl:\n+DECLARE_FUNC(aarch64_atomic_fetch_add_4_default_impl):\n@@ -60,2 +57,0 @@\n-        .global aarch64_atomic_fetch_add_8_relaxed_default_impl\n-        .hidden aarch64_atomic_fetch_add_8_relaxed_default_impl\n@@ -63,1 +58,1 @@\n-aarch64_atomic_fetch_add_8_relaxed_default_impl:\n+DECLARE_FUNC(aarch64_atomic_fetch_add_8_relaxed_default_impl):\n@@ -76,2 +71,0 @@\n-        .global aarch64_atomic_fetch_add_4_relaxed_default_impl\n-        .hidden aarch64_atomic_fetch_add_4_relaxed_default_impl\n@@ -79,1 +72,1 @@\n-aarch64_atomic_fetch_add_4_relaxed_default_impl:\n+DECLARE_FUNC(aarch64_atomic_fetch_add_4_relaxed_default_impl):\n@@ -92,2 +85,0 @@\n-        .globl aarch64_atomic_xchg_4_default_impl\n-        .hidden aarch64_atomic_xchg_4_default_impl\n@@ -95,1 +86,1 @@\n-aarch64_atomic_xchg_4_default_impl:\n+DECLARE_FUNC(aarch64_atomic_xchg_4_default_impl):\n@@ -108,2 +99,0 @@\n-        .globl aarch64_atomic_xchg_8_default_impl\n-        .hidden aarch64_atomic_xchg_8_default_impl\n@@ -111,1 +100,1 @@\n-aarch64_atomic_xchg_8_default_impl:\n+DECLARE_FUNC(aarch64_atomic_xchg_8_default_impl):\n@@ -124,2 +113,0 @@\n-        .globl aarch64_atomic_cmpxchg_1_default_impl\n-        .hidden aarch64_atomic_cmpxchg_1_default_impl\n@@ -127,1 +114,1 @@\n-aarch64_atomic_cmpxchg_1_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_1_default_impl):\n@@ -145,2 +132,0 @@\n-        .globl aarch64_atomic_cmpxchg_4_default_impl\n-        .hidden aarch64_atomic_cmpxchg_4_default_impl\n@@ -148,1 +133,1 @@\n-aarch64_atomic_cmpxchg_4_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_4_default_impl):\n@@ -165,2 +150,0 @@\n-        .globl aarch64_atomic_cmpxchg_8_default_impl\n-        .hidden aarch64_atomic_cmpxchg_8_default_impl\n@@ -168,1 +151,1 @@\n-aarch64_atomic_cmpxchg_8_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_8_default_impl):\n@@ -185,2 +168,0 @@\n-        .globl aarch64_atomic_cmpxchg_4_release_default_impl\n-        .hidden aarch64_atomic_cmpxchg_4_release_default_impl\n@@ -188,1 +169,1 @@\n-aarch64_atomic_cmpxchg_4_release_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_4_release_default_impl):\n@@ -203,2 +184,0 @@\n-        .globl aarch64_atomic_cmpxchg_8_release_default_impl\n-        .hidden aarch64_atomic_cmpxchg_8_release_default_impl\n@@ -206,1 +185,1 @@\n-aarch64_atomic_cmpxchg_8_release_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_8_release_default_impl):\n@@ -221,2 +200,0 @@\n-        .globl aarch64_atomic_cmpxchg_4_seq_cst_default_impl\n-        .hidden aarch64_atomic_cmpxchg_4_seq_cst_default_impl\n@@ -224,1 +201,1 @@\n-aarch64_atomic_cmpxchg_4_seq_cst_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_4_seq_cst_default_impl):\n@@ -239,2 +216,0 @@\n-        .globl aarch64_atomic_cmpxchg_8_seq_cst_default_impl\n-        .hidden aarch64_atomic_cmpxchg_8_seq_cst_default_impl\n@@ -242,1 +217,1 @@\n-aarch64_atomic_cmpxchg_8_seq_cst_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_8_seq_cst_default_impl):\n@@ -257,2 +232,0 @@\n-.globl aarch64_atomic_cmpxchg_1_relaxed_default_impl\n-.hidden aarch64_atomic_cmpxchg_1_relaxed_default_impl\n@@ -260,1 +233,1 @@\n-aarch64_atomic_cmpxchg_1_relaxed_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_1_relaxed_default_impl):\n@@ -276,2 +249,0 @@\n-        .globl aarch64_atomic_cmpxchg_4_relaxed_default_impl\n-        .hidden aarch64_atomic_cmpxchg_4_relaxed_default_impl\n@@ -279,1 +250,1 @@\n-aarch64_atomic_cmpxchg_4_relaxed_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_4_relaxed_default_impl):\n@@ -294,2 +265,0 @@\n-        .globl aarch64_atomic_cmpxchg_8_relaxed_default_impl\n-        .hidden aarch64_atomic_cmpxchg_8_relaxed_default_impl\n@@ -297,1 +266,1 @@\n-aarch64_atomic_cmpxchg_8_relaxed_default_impl:\n+DECLARE_FUNC(aarch64_atomic_cmpxchg_8_relaxed_default_impl):\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.S","additions":18,"deletions":49,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +25,0 @@\n-        .global _Copy_conjoint_words\n-        .global _Copy_disjoint_words\n@@ -27,2 +26,1 @@\n-        .hidden _Copy_conjoint_words\n-        .hidden _Copy_disjoint_words\n+#include \"defs.S.inc\"\n@@ -43,1 +41,1 @@\n-_Copy_disjoint_words:\n+DECLARE_FUNC(_Copy_disjoint_words):\n@@ -141,1 +139,1 @@\n-_Copy_conjoint_words:\n+DECLARE_FUNC(_Copy_conjoint_words):\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/copy_linux_aarch64.S","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,13 +26,1 @@\n-    .globl SafeFetchN_impl\n-    .globl _SafeFetchN_fault\n-    .globl _SafeFetchN_continuation\n-    .globl SafeFetch32_impl\n-    .globl _SafeFetch32_fault\n-    .globl _SafeFetch32_continuation\n-\n-    .hidden SafeFetchN_impl\n-    .hidden _SafeFetchN_fault\n-    .hidden _SafeFetchN_continuation\n-    .hidden SafeFetch32_impl\n-    .hidden _SafeFetch32_fault\n-    .hidden _SafeFetch32_continuation\n+#include \"defs.S.inc\"\n@@ -44,2 +32,2 @@\n-SafeFetch32_impl:\n-_SafeFetch32_fault:\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -48,1 +36,1 @@\n-_SafeFetch32_continuation:\n+DECLARE_FUNC(_SafeFetch32_continuation):\n@@ -56,2 +44,2 @@\n-SafeFetchN_impl:\n-_SafeFetchN_fault:\n+DECLARE_FUNC(SafeFetchN_impl):\n+DECLARE_FUNC(_SafeFetchN_fault):\n@@ -60,1 +48,1 @@\n-_SafeFetchN_continuation:\n+DECLARE_FUNC(_SafeFetchN_continuation):\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/safefetch_linux_aarch64.S","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+\/\/ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,0 +23,2 @@\n+#include \"defs.S.inc\"\n+\n@@ -28,5 +31,1 @@\n-        .global\t_ZN10JavaThread25aarch64_get_thread_helperEv\n-        .hidden\t_ZN10JavaThread25aarch64_get_thread_helperEv\n-        .type\t_ZN10JavaThread25aarch64_get_thread_helperEv, %function\n-\n-_ZN10JavaThread25aarch64_get_thread_helperEv:\n+DECLARE_FUNC(_ZN10JavaThread25aarch64_get_thread_helperEv):\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/threadLS_linux_aarch64.S","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"defs.S.inc\"\n@@ -31,31 +32,0 @@\n-        .globl  SpinPause\n-        .hidden  SpinPause\n-        .type SpinPause, %function\n-        .globl _Copy_arrayof_conjoint_bytes\n-        .hidden _Copy_arrayof_conjoint_bytes\n-        .type _Copy_arrayof_conjoint_bytes, %function\n-        .globl _Copy_disjoint_words\n-        .hidden _Copy_disjoint_words\n-        .type _Copy_disjoint_words, %function\n-        .globl _Copy_conjoint_words\n-        .hidden _Copy_conjoint_words\n-        .type _Copy_conjoint_words, %function\n-        .globl _Copy_conjoint_jshorts_atomic\n-        .hidden _Copy_conjoint_jshorts_atomic\n-        .type _Copy_conjoint_jshorts_atomic, %function\n-        .globl _Copy_arrayof_conjoint_jshorts\n-        .hidden _Copy_arrayof_conjoint_jshorts\n-        .type _Copy_arrayof_conjoint_jshorts, %function\n-        .globl _Copy_conjoint_jints_atomic\n-        .hidden _Copy_conjoint_jints_atomic\n-        .type _Copy_conjoint_jints_atomic, %function\n-        .globl _Copy_arrayof_conjoint_jints\n-        .hidden _Copy_arrayof_conjoint_jints\n-        .type _Copy_arrayof_conjoint_jints, %function\n-        .globl _Copy_conjoint_jlongs_atomic\n-        .hidden _Copy_conjoint_jlongs_atomic\n-        .type _Copy_conjoint_jlongs_atomic, %function\n-        .globl _Copy_arrayof_conjoint_jlongs\n-        .hidden _Copy_arrayof_conjoint_jlongs\n-        .type _Copy_arrayof_conjoint_jlongs, %function\n-\n@@ -66,1 +36,1 @@\n-SpinPause:\n+DECLARE_FUNC(SpinPause):\n@@ -72,1 +42,1 @@\n-_Copy_arrayof_conjoint_bytes:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_bytes):\n@@ -79,1 +49,1 @@\n-_Copy_disjoint_words:\n+DECLARE_FUNC(_Copy_disjoint_words):\n@@ -124,1 +94,1 @@\n-_Copy_conjoint_words:\n+DECLARE_FUNC(_Copy_conjoint_words):\n@@ -204,1 +174,1 @@\n-_Copy_conjoint_jshorts_atomic:\n+DECLARE_FUNC(_Copy_conjoint_jshorts_atomic):\n@@ -428,1 +398,1 @@\n-_Copy_arrayof_conjoint_jshorts:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jshorts):\n@@ -434,2 +404,2 @@\n-_Copy_conjoint_jints_atomic:\n-_Copy_arrayof_conjoint_jints:\n+DECLARE_FUNC(_Copy_conjoint_jints_atomic):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jints):\n@@ -441,2 +411,2 @@\n-_Copy_conjoint_jlongs_atomic:\n-_Copy_arrayof_conjoint_jlongs:\n+DECLARE_FUNC(_Copy_conjoint_jlongs_atomic):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jlongs):\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/linux_arm_32.S","additions":11,"deletions":41,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,9 +26,1 @@\n-    .globl SafeFetch32_impl\n-    .globl _SafeFetch32_fault\n-    .globl _SafeFetch32_continuation\n-\n-    .hidden SafeFetch32_impl\n-    .hidden _SafeFetch32_fault\n-    .hidden _SafeFetch32_continuation\n-\n-    .type SafeFetch32_impl, %function\n+#include \"defs.S.inc\"\n@@ -40,2 +32,2 @@\n-SafeFetch32_impl:\n-_SafeFetch32_fault:\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -44,1 +36,1 @@\n-_SafeFetch32_continuation:\n+DECLARE_FUNC(_SafeFetch32_continuation):\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/safefetch_linux_arm.S","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,13 +26,1 @@\n-    .globl SafeFetchN_impl\n-    .globl _SafeFetchN_fault\n-    .globl _SafeFetchN_continuation\n-    .globl SafeFetch32_impl\n-    .globl _SafeFetch32_fault\n-    .globl _SafeFetch32_continuation\n-\n-    .hidden SafeFetchN_impl\n-    .hidden _SafeFetchN_fault\n-    .hidden _SafeFetchN_continuation\n-    .hidden SafeFetch32_impl\n-    .hidden _SafeFetch32_fault\n-    .hidden _SafeFetch32_continuation\n+#include \"defs.S.inc\"\n@@ -45,2 +33,2 @@\n-SafeFetch32_impl:\n-_SafeFetch32_fault:\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -49,1 +37,1 @@\n-_SafeFetch32_continuation:\n+DECLARE_FUNC(_SafeFetch32_continuation):\n@@ -58,2 +46,2 @@\n-SafeFetchN_impl:\n-_SafeFetchN_fault:\n+DECLARE_FUNC(SafeFetchN_impl):\n+DECLARE_FUNC(_SafeFetchN_fault):\n@@ -62,1 +50,1 @@\n-_SafeFetchN_continuation:\n+DECLARE_FUNC(_SafeFetchN_continuation):\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/safefetch_linux_ppc.S","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,13 +26,1 @@\n-    .globl SafeFetchN_impl\n-    .globl _SafeFetchN_fault\n-    .globl _SafeFetchN_continuation\n-    .globl SafeFetch32_impl\n-    .globl _SafeFetch32_fault\n-    .globl _SafeFetch32_continuation\n-\n-    .hidden SafeFetchN_impl\n-    .hidden _SafeFetchN_fault\n-    .hidden _SafeFetchN_continuation\n-    .hidden SafeFetch32_impl\n-    .hidden _SafeFetch32_fault\n-    .hidden _SafeFetch32_continuation\n+#include \"defs.S.inc\"\n@@ -45,2 +33,2 @@\n-SafeFetch32_impl:\n-_SafeFetch32_fault:\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -49,1 +37,1 @@\n-_SafeFetch32_continuation:\n+DECLARE_FUNC(_SafeFetch32_continuation):\n@@ -58,2 +46,2 @@\n-SafeFetchN_impl:\n-_SafeFetchN_fault:\n+DECLARE_FUNC(SafeFetchN_impl):\n+DECLARE_FUNC(_SafeFetchN_fault):\n@@ -62,1 +50,1 @@\n-_SafeFetchN_continuation:\n+DECLARE_FUNC(_SafeFetchN_continuation):\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/safefetch_linux_riscv.S","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,13 +26,1 @@\n-    .globl SafeFetchN_impl\n-    .globl _SafeFetchN_fault\n-    .globl _SafeFetchN_continuation\n-    .globl SafeFetch32_impl\n-    .globl _SafeFetch32_fault\n-    .globl _SafeFetch32_continuation\n-\n-    .hidden SafeFetchN_impl\n-    .hidden _SafeFetchN_fault\n-    .hidden _SafeFetchN_continuation\n-    .hidden SafeFetch32_impl\n-    .hidden _SafeFetch32_fault\n-    .hidden _SafeFetch32_continuation\n+#include \"defs.S.inc\"\n@@ -45,2 +33,2 @@\n-SafeFetch32_impl:\n-_SafeFetch32_fault:\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -49,1 +37,1 @@\n-_SafeFetch32_continuation:\n+DECLARE_FUNC(_SafeFetch32_continuation):\n@@ -58,2 +46,2 @@\n-SafeFetchN_impl:\n-_SafeFetchN_fault:\n+DECLARE_FUNC(SafeFetchN_impl):\n+DECLARE_FUNC(_SafeFetchN_fault):\n@@ -62,1 +50,1 @@\n-_SafeFetchN_continuation:\n+DECLARE_FUNC(_SafeFetchN_continuation):\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/safefetch_linux_s390.S","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-        .globl  SpinPause\n+#include \"defs.S.inc\"\n@@ -32,24 +32,0 @@\n-        .globl _Copy_arrayof_conjoint_bytes\n-        .globl _Copy_conjoint_jshorts_atomic\n-        .globl _Copy_arrayof_conjoint_jshorts\n-        .globl _Copy_conjoint_jints_atomic\n-        .globl _Copy_arrayof_conjoint_jints\n-        .globl _Copy_conjoint_jlongs_atomic\n-        .globl _mmx_Copy_arrayof_conjoint_jshorts\n-\n-        .globl _Atomic_cmpxchg_long\n-        .globl _Atomic_move_long\n-\n-        .hidden  SpinPause\n-\n-        .hidden _Copy_arrayof_conjoint_bytes\n-        .hidden _Copy_conjoint_jshorts_atomic\n-        .hidden _Copy_arrayof_conjoint_jshorts\n-        .hidden _Copy_conjoint_jints_atomic\n-        .hidden _Copy_arrayof_conjoint_jints\n-        .hidden _Copy_conjoint_jlongs_atomic\n-        .hidden _mmx_Copy_arrayof_conjoint_jshorts\n-\n-        .hidden _Atomic_cmpxchg_long\n-        .hidden _Atomic_move_long\n-\n@@ -58,1 +34,0 @@\n-        .type   SpinPause,@function\n@@ -60,1 +35,1 @@\n-SpinPause:\n+DECLARE_FUNC(SpinPause):\n@@ -71,2 +46,1 @@\n-        .type    _Copy_arrayof_conjoint_bytes,@function\n-_Copy_arrayof_conjoint_bytes:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_bytes):\n@@ -159,2 +133,1 @@\n-        .type    _Copy_conjoint_jshorts_atomic,@function\n-_Copy_conjoint_jshorts_atomic:\n+DECLARE_FUNC(_Copy_conjoint_jshorts_atomic):\n@@ -246,2 +219,1 @@\n-        .type    _Copy_arrayof_conjoint_jshorts,@function\n-_Copy_arrayof_conjoint_jshorts:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jshorts):\n@@ -323,4 +295,2 @@\n-        .type    _Copy_conjoint_jints_atomic,@function\n-        .type    _Copy_arrayof_conjoint_jints,@function\n-_Copy_conjoint_jints_atomic:\n-_Copy_arrayof_conjoint_jints:\n+DECLARE_FUNC(_Copy_conjoint_jints_atomic):\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jints):\n@@ -400,2 +370,1 @@\n-        .type    _Copy_conjoint_jlongs_atomic,@function\n-_Copy_conjoint_jlongs_atomic:\n+DECLARE_FUNC(_Copy_conjoint_jlongs_atomic):\n@@ -429,2 +398,1 @@\n-        .type    _mmx_Copy_arrayof_conjoint_jshorts,@function\n-_mmx_Copy_arrayof_conjoint_jshorts:\n+DECLARE_FUNC(_mmx_Copy_arrayof_conjoint_jshorts):\n@@ -527,2 +495,1 @@\n-        .type    _Atomic_cmpxchg_long,@function\n-_Atomic_cmpxchg_long:\n+DECLARE_FUNC(_Atomic_cmpxchg_long):\n@@ -546,2 +513,1 @@\n-        .type    _Atomic_move_long,@function\n-_Atomic_move_long:\n+DECLARE_FUNC(_Atomic_move_long):\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/linux_x86_32.S","additions":11,"deletions":45,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-        .globl SpinPause\n+#include \"defs.S.inc\"\n@@ -32,18 +32,0 @@\n-        .globl _Copy_arrayof_conjoint_bytes\n-        .globl _Copy_arrayof_conjoint_jshorts\n-        .globl _Copy_conjoint_jshorts_atomic\n-        .globl _Copy_arrayof_conjoint_jints\n-        .globl _Copy_conjoint_jints_atomic\n-        .globl _Copy_arrayof_conjoint_jlongs\n-        .globl _Copy_conjoint_jlongs_atomic\n-\n-        .hidden SpinPause\n-\n-        .hidden _Copy_arrayof_conjoint_bytes\n-        .hidden _Copy_arrayof_conjoint_jshorts\n-        .hidden _Copy_conjoint_jshorts_atomic\n-        .hidden _Copy_arrayof_conjoint_jints\n-        .hidden _Copy_conjoint_jints_atomic\n-        .hidden _Copy_arrayof_conjoint_jlongs\n-        .hidden _Copy_conjoint_jlongs_atomic\n-\n@@ -53,2 +35,1 @@\n-        .type  SpinPause,@function\n-SpinPause:\n+DECLARE_FUNC(SpinPause):\n@@ -68,2 +49,1 @@\n-        .type    _Copy_arrayof_conjoint_bytes,@function\n-_Copy_arrayof_conjoint_bytes:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_bytes):\n@@ -170,4 +150,2 @@\n-        .type    _Copy_arrayof_conjoint_jshorts,@function\n-        .type    _Copy_conjoint_jshorts_atomic,@function\n-_Copy_arrayof_conjoint_jshorts:\n-_Copy_conjoint_jshorts_atomic:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jshorts):\n+DECLARE_FUNC(_Copy_conjoint_jshorts_atomic):\n@@ -260,4 +238,2 @@\n-        .type    _Copy_arrayof_conjoint_jints,@function\n-        .type    _Copy_conjoint_jints_atomic,@function\n-_Copy_arrayof_conjoint_jints:\n-_Copy_conjoint_jints_atomic:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jints):\n+DECLARE_FUNC(_Copy_conjoint_jints_atomic):\n@@ -339,4 +315,2 @@\n-        .type    _Copy_arrayof_conjoint_jlongs,@function\n-        .type    _Copy_conjoint_jlongs_atomic,@function\n-_Copy_arrayof_conjoint_jlongs:\n-_Copy_conjoint_jlongs_atomic:\n+DECLARE_FUNC(_Copy_arrayof_conjoint_jlongs):\n+DECLARE_FUNC(_Copy_conjoint_jlongs_atomic):\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/linux_x86_64.S","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-    .globl SafeFetch32_impl\n-    .globl _SafeFetch32_fault\n-    .globl _SafeFetch32_continuation\n@@ -28,3 +25,1 @@\n-    .hidden SafeFetch32_impl\n-    .hidden _SafeFetch32_fault\n-    .hidden _SafeFetch32_continuation\n+#include \"defs.S.inc\"\n@@ -39,2 +34,1 @@\n-    .type SafeFetch32_impl,@function\n-SafeFetch32_impl:\n+DECLARE_FUNC(SafeFetch32_impl):\n@@ -42,1 +36,1 @@\n-_SafeFetch32_fault:\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -45,1 +39,1 @@\n-_SafeFetch32_continuation:\n+DECLARE_FUNC(_SafeFetch32_continuation):\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/safefetch_linux_x86_32.S","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -24,6 +24,0 @@\n-    .globl SafeFetch32_impl\n-    .globl SafeFetchN_impl\n-    .globl _SafeFetch32_fault\n-    .globl _SafeFetchN_fault\n-    .globl _SafeFetch32_continuation\n-    .globl _SafeFetchN_continuation\n@@ -31,6 +25,1 @@\n-    .hidden SafeFetch32_impl\n-    .hidden SafeFetchN_impl\n-    .hidden _SafeFetch32_fault\n-    .hidden _SafeFetchN_fault\n-    .hidden _SafeFetch32_continuation\n-    .hidden _SafeFetchN_continuation\n+#include \"defs.S.inc\"\n@@ -40,1 +29,0 @@\n-\n@@ -45,3 +33,2 @@\n-    .type    SafeFetch32_impl,@function\n-SafeFetch32_impl:\n-_SafeFetch32_fault:\n+DECLARE_FUNC(SafeFetch32_impl):\n+DECLARE_FUNC(_SafeFetch32_fault):\n@@ -50,1 +37,1 @@\n-_SafeFetch32_continuation:\n+DECLARE_FUNC(_SafeFetch32_continuation):\n@@ -58,3 +45,2 @@\n-    .type    SafeFetchN_impl,@function\n-SafeFetchN_impl:\n-_SafeFetchN_fault:\n+DECLARE_FUNC(SafeFetchN_impl):\n+DECLARE_FUNC(_SafeFetchN_fault):\n@@ -63,1 +49,1 @@\n-_SafeFetchN_continuation:\n+DECLARE_FUNC(_SafeFetchN_continuation):\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/safefetch_linux_x86_64.S","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -200,1 +200,0 @@\n-#ifdef ASSERT\n@@ -207,1 +206,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    guarantee(MIN_GC_REGION_ALIGNMENT <= \/*G1*\/HeapRegion::min_region_size_in_words() * HeapWordSize, \"must be\");\n+    guarantee(MIN_GC_REGION_ALIGNMENT <= G1HeapRegion::min_region_size_in_words() * HeapWordSize, \"must be\");\n@@ -442,1 +442,1 @@\n-    _requested_bottom = align_down(heap_end - heap_region_byte_size, HeapRegion::GrainBytes);\n+    _requested_bottom = align_down(heap_end - heap_region_byte_size, G1HeapRegion::GrainBytes);\n@@ -452,1 +452,1 @@\n-  assert(is_aligned(_requested_bottom, HeapRegion::GrainBytes), \"sanity\");\n+  assert(is_aligned(_requested_bottom, G1HeapRegion::GrainBytes), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-    _input_stream(&_file_input) {\n+    _input_stream(&_file_input),\n+    _parse_mode(parse_mode) {\n@@ -73,1 +74,0 @@\n-  _parse_mode = parse_mode;\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2139,2 +2139,2 @@\n-  log_info(cds)(\"The current max heap size = \" SIZE_FORMAT \"M, HeapRegion::GrainBytes = \" SIZE_FORMAT,\n-                MaxHeapSize\/M, HeapRegion::GrainBytes);\n+  log_info(cds)(\"The current max heap size = \" SIZE_FORMAT \"M, G1HeapRegion::GrainBytes = \" SIZE_FORMAT,\n+                MaxHeapSize\/M, G1HeapRegion::GrainBytes);\n@@ -2205,1 +2205,1 @@\n-    assert(is_aligned(_mapped_heap_memregion.start(), HeapRegion::GrainBytes), \"must be\");\n+    assert(is_aligned(_mapped_heap_memregion.start(), G1HeapRegion::GrainBytes), \"must be\");\n@@ -2215,1 +2215,1 @@\n-    assert(heap_end - mapped_heap_region_end < (intx)(HeapRegion::GrainBytes),\n+    assert(heap_end - mapped_heap_region_end < (intx)(G1HeapRegion::GrainBytes),\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2932,5 +2932,0 @@\n-  if (name == vmSymbols::object_initializer_name() &&\n-      signature == vmSymbols::void_method_signature() &&\n-      m->is_vanilla_constructor()) {\n-    _has_vanilla_constructor = true;\n-  }\n@@ -4350,23 +4345,0 @@\n-  \/\/ Check if this klass has a vanilla default constructor\n-  if (super == nullptr) {\n-    \/\/ java.lang.Object has empty default constructor\n-    ik->set_has_vanilla_constructor();\n-  } else {\n-    if (super->has_vanilla_constructor() &&\n-        _has_vanilla_constructor) {\n-      ik->set_has_vanilla_constructor();\n-    }\n-#ifdef ASSERT\n-    bool v = false;\n-    if (super->has_vanilla_constructor()) {\n-      const Method* const constructor =\n-        ik->find_method(vmSymbols::object_initializer_name(),\n-                       vmSymbols::void_method_signature());\n-      if (constructor != nullptr && constructor->is_vanilla_constructor()) {\n-        v = true;\n-      }\n-    }\n-    assert(v == ik->has_vanilla_constructor(), \"inconsistent has_vanilla_constructor\");\n-#endif\n-  }\n-\n@@ -5679,1 +5651,1 @@\n-  \/\/ Fill in has_finalizer, has_vanilla_constructor, and layout_helper\n+  \/\/ Fill in has_finalizer and layout_helper\n@@ -5905,1 +5877,0 @@\n-  _has_vanilla_constructor(false),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -222,1 +222,0 @@\n-  bool _has_vanilla_constructor;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -563,1 +563,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n@@ -565,1 +564,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  template(java_lang_Package,                         \"java\/lang\/Package\")                        \\\n@@ -121,1 +120,0 @@\n-  template(java_lang_CharSequence,                    \"java\/lang\/CharSequence\")                   \\\n@@ -134,5 +132,0 @@\n-  template(java_io_OutputStream,                      \"java\/io\/OutputStream\")                     \\\n-  template(java_io_Reader,                            \"java\/io\/Reader\")                           \\\n-  template(java_io_BufferedReader,                    \"java\/io\/BufferedReader\")                   \\\n-  template(java_io_File,                              \"java\/io\/File\")                             \\\n-  template(java_io_FileInputStream,                   \"java\/io\/FileInputStream\")                  \\\n@@ -143,1 +136,0 @@\n-  template(java_util_Objects,                         \"java\/util\/Objects\")                        \\\n@@ -145,3 +137,0 @@\n-  template(java_util_Vector,                          \"java\/util\/Vector\")                         \\\n-  template(java_util_AbstractList,                    \"java\/util\/AbstractList\")                   \\\n-  template(java_util_Hashtable,                       \"java\/util\/Hashtable\")                      \\\n@@ -149,1 +138,0 @@\n-  template(java_lang_Compiler,                        \"java\/lang\/Compiler\")                       \\\n@@ -153,1 +141,0 @@\n-  template(getBootClassPathEntryForClass_name,        \"getBootClassPathEntryForClass\")            \\\n@@ -155,1 +142,0 @@\n-  template(sun_net_www_ParseUtil,                     \"sun\/net\/www\/ParseUtil\")                    \\\n@@ -232,1 +218,0 @@\n-  template(java_lang_NoSuchFieldException,            \"java\/lang\/NoSuchFieldException\")           \\\n@@ -242,1 +227,0 @@\n-  template(java_security_PrivilegedActionException,   \"java\/security\/PrivilegedActionException\")  \\\n@@ -291,1 +275,0 @@\n-  template(checkedExceptions_name,                    \"checkedExceptions\")                        \\\n@@ -370,4 +353,0 @@\n-  template(setTargetNormal_name,                      \"setTargetNormal\")                          \\\n-  template(setTargetVolatile_name,                    \"setTargetVolatile\")                        \\\n-  template(setTarget_signature,                       \"(Ljava\/lang\/invoke\/MethodHandle;)V\")       \\\n-  template(DEFAULT_CONTEXT_name,                      \"DEFAULT_CONTEXT\")                          \\\n@@ -418,1 +397,0 @@\n-  template(reference_lock_name,                       \"lock\")                                     \\\n@@ -433,2 +411,0 @@\n-  template(getStacks_name,                            \"getStacks\")                                \\\n-  template(onPinned_name,                             \"onPinned0\")                                \\\n@@ -442,1 +418,0 @@\n-  template(numOops_name,                              \"numOops\")                                  \\\n@@ -448,1 +423,0 @@\n-  template(numInterpretedFrames_name,                 \"numInterpretedFrames\")                     \\\n@@ -454,2 +428,0 @@\n-  template(refStack_name,                             \"refStack\")                                 \\\n-  template(refSP_name,                                \"refSP\")                                    \\\n@@ -461,1 +433,0 @@\n-  template(deadChild_name,                            \"deadChild\")                                \\\n@@ -477,1 +448,0 @@\n-  template(newInstance0_name,                         \"newInstance0\")                             \\\n@@ -499,1 +469,0 @@\n-  template(vmcount_name,                              \"vmcount\")                                  \\\n@@ -569,1 +538,0 @@\n-  template(bool_bool_void_signature,                  \"(ZZ)V\")                                    \\\n@@ -598,2 +566,0 @@\n-  template(int_array_signature,                       \"[I\")                                       \\\n-  template(long_array_signature,                      \"[J\")                                       \\\n@@ -604,1 +570,0 @@\n-  template(vthread_signature,                         \"Ljava\/lang\/VirtualThread;\")                \\\n@@ -611,2 +576,0 @@\n-  template(string_int_signature,                      \"(Ljava\/lang\/String;)I\")                    \\\n-  template(string_byte_array_signature,               \"(Ljava\/lang\/String;)[B\")                   \\\n@@ -623,4 +586,0 @@\n-  template(throwable_string_void_signature,           \"(Ljava\/lang\/Throwable;Ljava\/lang\/String;)V\")               \\\n-  template(string_array_void_signature,               \"([Ljava\/lang\/String;)V\")                                   \\\n-  template(string_array_string_array_void_signature,  \"([Ljava\/lang\/String;[Ljava\/lang\/String;)V\")                \\\n-  template(thread_throwable_void_signature,           \"(Ljava\/lang\/Thread;Ljava\/lang\/Throwable;)V\")               \\\n@@ -635,2 +594,1 @@\n-  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\") \\\n-  template(string_string_string_signature,            \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\") \\\n+  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\")                  \\\n@@ -640,2 +598,0 @@\n-  template(char_array_void_signature,                 \"([C)V\")                                                    \\\n-  template(int_int_void_signature,                    \"(II)V\")                                                    \\\n@@ -650,1 +606,0 @@\n-  template(void_module_signature,                     \"()Ljava\/lang\/Module;\")                                     \\\n@@ -653,1 +608,0 @@\n-  template(exception_void_signature,                  \"(Ljava\/lang\/Exception;)V\")                                 \\\n@@ -659,1 +613,0 @@\n-  template(thread_array_signature,                    \"[Ljava\/lang\/Thread;\")                                      \\\n@@ -671,1 +624,0 @@\n-  template(weakreference_array_signature,             \"[Ljava\/lang\/ref\/WeakReference;\")                           \\\n@@ -701,1 +653,0 @@\n-  template(java_lang_management_ThreadState,           \"java\/lang\/management\/ThreadState\")                        \\\n@@ -738,1 +689,0 @@\n-  template(gcInfoBuilder_name,                         \"gcInfoBuilder\")                                           \\\n@@ -745,4 +695,0 @@\n-  template(addThreadDumpForMonitors_name,              \"addThreadDumpForMonitors\")                                \\\n-  template(addThreadDumpForSynchronizers_name,         \"addThreadDumpForSynchronizers\")                           \\\n-  template(addThreadDumpForMonitors_signature,         \"(Ljava\/lang\/management\/ThreadInfo;[Ljava\/lang\/Object;[I)V\") \\\n-  template(addThreadDumpForSynchronizers_signature,    \"(Ljava\/lang\/management\/ThreadInfo;[Ljava\/lang\/Object;)V\")   \\\n@@ -804,1 +750,0 @@\n-  template(url_void_signature,                              \"(Ljava\/net\/URL;)V\")                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -4047,1 +4047,0 @@\n-#ifndef PRODUCT\n@@ -4049,1 +4048,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-                            LIR_OprFact::intConst(checked_cast<jint>(HeapRegion::LogOfHRGrainBytes)),\n+                            LIR_OprFact::intConst(checked_cast<jint>(G1HeapRegion::LogOfHRGrainBytes)),\n@@ -167,1 +167,1 @@\n-                            LIR_OprFact::intConst(checked_cast<jint>(HeapRegion::LogOfHRGrainBytes)),\n+                            LIR_OprFact::intConst(checked_cast<jint>(G1HeapRegion::LogOfHRGrainBytes)),\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -456,2 +456,2 @@\n-    \/\/ Node* region_size = __ ConI(1 << HeapRegion::LogOfHRGrainBytes);\n-    Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(checked_cast<jint>(HeapRegion::LogOfHRGrainBytes)));\n+    \/\/ Node* region_size = __ ConI(1 << G1HeapRegion::LogOfHRGrainBytes);\n+    Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(checked_cast<jint>(G1HeapRegion::LogOfHRGrainBytes)));\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-HeapRegion* G1AllocRegion::_dummy_region = nullptr;\n+G1HeapRegion* G1AllocRegion::_dummy_region = nullptr;\n@@ -39,1 +39,1 @@\n-void G1AllocRegion::setup(G1CollectedHeap* g1h, HeapRegion* dummy_region) {\n+void G1AllocRegion::setup(G1CollectedHeap* g1h, G1HeapRegion* dummy_region) {\n@@ -53,1 +53,1 @@\n-size_t G1AllocRegion::fill_up_remaining_space(HeapRegion* alloc_region) {\n+size_t G1AllocRegion::fill_up_remaining_space(G1HeapRegion* alloc_region) {\n@@ -97,1 +97,1 @@\n-size_t G1AllocRegion::retire_internal(HeapRegion* alloc_region, bool fill_up) {\n+size_t G1AllocRegion::retire_internal(G1HeapRegion* alloc_region, bool fill_up) {\n@@ -123,1 +123,1 @@\n-  HeapRegion* alloc_region = _alloc_region;\n+  G1HeapRegion* alloc_region = _alloc_region;\n@@ -138,1 +138,1 @@\n-  HeapRegion* new_alloc_region = allocate_new_region(word_size);\n+  G1HeapRegion* new_alloc_region = allocate_new_region(word_size);\n@@ -169,1 +169,1 @@\n-void G1AllocRegion::set(HeapRegion* alloc_region) {\n+void G1AllocRegion::set(G1HeapRegion* alloc_region) {\n@@ -184,1 +184,1 @@\n-void G1AllocRegion::update_alloc_region(HeapRegion* alloc_region) {\n+void G1AllocRegion::update_alloc_region(G1HeapRegion* alloc_region) {\n@@ -195,1 +195,1 @@\n-HeapRegion* G1AllocRegion::release() {\n+G1HeapRegion* G1AllocRegion::release() {\n@@ -197,1 +197,1 @@\n-  HeapRegion* alloc_region = _alloc_region;\n+  G1HeapRegion* alloc_region = _alloc_region;\n@@ -260,1 +260,1 @@\n-HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size) {\n+G1HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size) {\n@@ -264,1 +264,1 @@\n-void MutatorAllocRegion::retire_region(HeapRegion* alloc_region,\n+void MutatorAllocRegion::retire_region(G1HeapRegion* alloc_region,\n@@ -275,1 +275,1 @@\n-bool MutatorAllocRegion::should_retain(HeapRegion* region) {\n+bool MutatorAllocRegion::should_retain(G1HeapRegion* region) {\n@@ -292,1 +292,1 @@\n-  HeapRegion* current_region = get();\n+  G1HeapRegion* current_region = get();\n@@ -315,1 +315,1 @@\n-  HeapRegion* hr = get();\n+  G1HeapRegion* hr = get();\n@@ -327,2 +327,2 @@\n-HeapRegion* MutatorAllocRegion::release() {\n-  HeapRegion* ret = G1AllocRegion::release();\n+G1HeapRegion* MutatorAllocRegion::release() {\n+  G1HeapRegion* ret = G1AllocRegion::release();\n@@ -341,1 +341,1 @@\n-                               percent_of(_wasted_bytes, count() * HeapRegion::GrainBytes));\n+                               percent_of(_wasted_bytes, count() * G1HeapRegion::GrainBytes));\n@@ -345,1 +345,1 @@\n-HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size) {\n+G1HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size) {\n@@ -349,1 +349,1 @@\n-void G1GCAllocRegion::retire_region(HeapRegion* alloc_region,\n+void G1GCAllocRegion::retire_region(G1HeapRegion* alloc_region,\n@@ -355,1 +355,1 @@\n-  HeapRegion* retired = get();\n+  G1HeapRegion* retired = get();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  HeapRegion* volatile _alloc_region;\n+  G1HeapRegion* volatile _alloc_region;\n@@ -79,1 +79,1 @@\n-  static HeapRegion* _dummy_region;\n+  static G1HeapRegion* _dummy_region;\n@@ -83,1 +83,1 @@\n-  void update_alloc_region(HeapRegion* alloc_region);\n+  void update_alloc_region(G1HeapRegion* alloc_region);\n@@ -101,1 +101,1 @@\n-  inline HeapWord* allocate(HeapRegion* alloc_region,\n+  inline HeapWord* allocate(G1HeapRegion* alloc_region,\n@@ -105,1 +105,1 @@\n-  inline HeapWord* par_allocate(HeapRegion* alloc_region,\n+  inline HeapWord* par_allocate(G1HeapRegion* alloc_region,\n@@ -111,1 +111,1 @@\n-  inline HeapWord* par_allocate(HeapRegion* alloc_region,\n+  inline HeapWord* par_allocate(G1HeapRegion* alloc_region,\n@@ -120,1 +120,1 @@\n-  size_t fill_up_remaining_space(HeapRegion* alloc_region);\n+  size_t fill_up_remaining_space(G1HeapRegion* alloc_region);\n@@ -128,1 +128,1 @@\n-  size_t retire_internal(HeapRegion* alloc_region, bool fill_up);\n+  size_t retire_internal(G1HeapRegion* alloc_region, bool fill_up);\n@@ -133,2 +133,2 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size) = 0;\n-  virtual void retire_region(HeapRegion* alloc_region,\n+  virtual G1HeapRegion* allocate_new_region(size_t word_size) = 0;\n+  virtual void retire_region(G1HeapRegion* alloc_region,\n@@ -140,1 +140,1 @@\n-  static void setup(G1CollectedHeap* g1h, HeapRegion* dummy_region);\n+  static void setup(G1CollectedHeap* g1h, G1HeapRegion* dummy_region);\n@@ -142,2 +142,2 @@\n-  HeapRegion* get() const {\n-    HeapRegion * hr = _alloc_region;\n+  G1HeapRegion* get() const {\n+    G1HeapRegion * hr = _alloc_region;\n@@ -180,1 +180,1 @@\n-  void set(HeapRegion* alloc_region);\n+  void set(G1HeapRegion* alloc_region);\n@@ -184,1 +184,1 @@\n-  virtual HeapRegion* release();\n+  virtual G1HeapRegion* release();\n@@ -202,1 +202,1 @@\n-  HeapRegion* volatile _retained_alloc_region;\n+  G1HeapRegion* volatile _retained_alloc_region;\n@@ -206,1 +206,1 @@\n-  bool should_retain(HeapRegion* region);\n+  bool should_retain(G1HeapRegion* region);\n@@ -208,2 +208,2 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(HeapRegion* alloc_region, size_t allocated_bytes);\n+  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n+  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n@@ -211,0 +211,1 @@\n+\n@@ -233,1 +234,1 @@\n-  virtual HeapRegion* release();\n+  virtual G1HeapRegion* release();\n@@ -244,2 +245,2 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size);\n-  virtual void retire_region(HeapRegion* alloc_region, size_t allocated_bytes);\n+  virtual G1HeapRegion* allocate_new_region(size_t word_size);\n+  virtual void retire_region(G1HeapRegion* alloc_region, size_t allocated_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-inline HeapWord* G1AllocRegion::allocate(HeapRegion* alloc_region,\n+inline HeapWord* G1AllocRegion::allocate(G1HeapRegion* alloc_region,\n@@ -51,1 +51,1 @@\n-inline HeapWord* G1AllocRegion::par_allocate(HeapRegion* alloc_region, size_t word_size) {\n+inline HeapWord* G1AllocRegion::par_allocate(G1HeapRegion* alloc_region, size_t word_size) {\n@@ -56,1 +56,1 @@\n-inline HeapWord* G1AllocRegion::par_allocate(HeapRegion* alloc_region,\n+inline HeapWord* G1AllocRegion::par_allocate(G1HeapRegion* alloc_region,\n@@ -69,1 +69,1 @@\n-  HeapRegion* alloc_region = _alloc_region;\n+  G1HeapRegion* alloc_region = _alloc_region;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-bool G1Allocator::is_retained_old_region(HeapRegion* hr) {\n+bool G1Allocator::is_retained_old_region(G1HeapRegion* hr) {\n@@ -98,2 +98,2 @@\n-                                            HeapRegion** retained_old) {\n-  HeapRegion* retained_region = *retained_old;\n+                                            G1HeapRegion** retained_old) {\n+  G1HeapRegion* retained_region = *retained_old;\n@@ -193,1 +193,1 @@\n-  HeapRegion* hr = mutator_alloc_region(node_index)->get();\n+  G1HeapRegion* hr = mutator_alloc_region(node_index)->get();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  HeapRegion* _retained_old_gc_alloc_region;\n+  G1HeapRegion* _retained_old_gc_alloc_region;\n@@ -73,1 +73,1 @@\n-                                 HeapRegion** retained);\n+                                 G1HeapRegion** retained);\n@@ -111,1 +111,1 @@\n-  bool is_retained_old_region(HeapRegion* hr);\n+  bool is_retained_old_region(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  HeapRegion::setup_heap_region_size(MaxHeapSize);\n+  G1HeapRegion::setup_heap_region_size(MaxHeapSize);\n@@ -60,1 +60,1 @@\n-  SpaceAlignment = HeapRegion::GrainBytes;\n+  SpaceAlignment = G1HeapRegion::GrainBytes;\n@@ -74,1 +74,1 @@\n-  return HeapRegion::max_region_size();\n+  return G1HeapRegion::max_region_size();\n@@ -133,1 +133,1 @@\n-  assert(HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n+  assert(G1HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n@@ -137,2 +137,2 @@\n-  assert(HeapRegion::LogOfHRGrainBytes >= LOG_M, \"from the above\");\n-  uint region_size_log_mb = HeapRegion::LogOfHRGrainBytes - LOG_M;\n+  assert(G1HeapRegion::LogOfHRGrainBytes >= LOG_M, \"from the above\");\n+  uint region_size_log_mb = G1HeapRegion::LogOfHRGrainBytes - LOG_M;\n@@ -141,1 +141,1 @@\n-    uint max_cards_in_inline_ptr = G1CardSetConfiguration::max_cards_in_inline_ptr(HeapRegion::LogCardsPerRegion);\n+    uint max_cards_in_inline_ptr = G1CardSetConfiguration::max_cards_in_inline_ptr(G1HeapRegion::LogCardsPerRegion);\n@@ -148,1 +148,1 @@\n-    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(HeapRegion::CardsPerRegion,\n+    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(G1HeapRegion::CardsPerRegion,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    DEBUG_ONLY(HeapRegion* containing_hr = G1CollectedHeap::heap()->heap_region_containing(mr.start());)\n+    DEBUG_ONLY(G1HeapRegion* containing_hr = G1CollectedHeap::heap()->heap_region_containing(mr.start());)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-  if (card_container_limit < (uint)HeapRegion::LogCardsPerRegion) {\n-    log2_card_regions_per_heap_region = (uint)HeapRegion::LogCardsPerRegion - card_container_limit;\n+  if (card_container_limit < (uint)G1HeapRegion::LogCardsPerRegion) {\n+    log2_card_regions_per_heap_region = (uint)G1HeapRegion::LogCardsPerRegion - card_container_limit;\n@@ -68,1 +68,1 @@\n-  G1CardSetConfiguration(HeapRegion::LogCardsPerRegion - default_log2_card_regions_per_region(),                                                                                   \/* inline_ptr_bits_per_card *\/\n+  G1CardSetConfiguration(G1HeapRegion::LogCardsPerRegion - default_log2_card_regions_per_region(),                                                                                   \/* inline_ptr_bits_per_card *\/\n@@ -73,1 +73,1 @@\n-                         (uint)HeapRegion::CardsPerRegion >> default_log2_card_regions_per_region(),\n+                         (uint)G1HeapRegion::CardsPerRegion >> default_log2_card_regions_per_region(),\n@@ -77,1 +77,1 @@\n-  assert((_log2_card_regions_per_heap_region + _log2_cards_per_card_region) == (uint)HeapRegion::LogCardsPerRegion,\n+  assert((_log2_card_regions_per_heap_region + _log2_cards_per_card_region) == (uint)G1HeapRegion::LogCardsPerRegion,\n@@ -398,1 +398,1 @@\n-  const uint CardBitsWithinCardRegion = MIN2((uint)HeapRegion::LogCardsPerRegion, G1CardSetContainer::LogCardsPerRegionLimit);\n+  const uint CardBitsWithinCardRegion = MIN2((uint)G1HeapRegion::LogCardsPerRegion, G1CardSetContainer::LogCardsPerRegionLimit);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -166,1 +166,2 @@\n-  EntryDataType _data[2];\n+  \/\/ VLA implementation.\n+  EntryDataType _data[1];\n@@ -187,0 +188,8 @@\n+\n+  EntryDataType const* base_addr() const;\n+\n+  EntryDataType const* entry_addr(EntryCountType index) const;\n+\n+  EntryDataType* entry_addr(EntryCountType index);\n+\n+  EntryDataType at(EntryCountType index) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  _data[0] = checked_cast<EntryDataType>(card_in_region);\n+  *entry_addr(0) = checked_cast<EntryDataType>(card_in_region);\n@@ -170,0 +170,18 @@\n+inline G1CardSetArray::EntryDataType const* G1CardSetArray::base_addr() const {\n+  const void* ptr = reinterpret_cast<const char*>(this) + header_size_in_bytes();\n+  return reinterpret_cast<EntryDataType const*>(ptr);\n+}\n+\n+inline G1CardSetArray::EntryDataType const* G1CardSetArray::entry_addr(EntryCountType index) const {\n+  assert(index < _num_entries, \"precondition\");\n+  return base_addr() + index;\n+}\n+\n+inline G1CardSetArray::EntryDataType* G1CardSetArray::entry_addr(EntryCountType index) {\n+  return const_cast<EntryDataType*>(const_cast<const G1CardSetArray*>(this)->entry_addr(index));\n+}\n+\n+inline G1CardSetArray::EntryDataType G1CardSetArray::at(EntryCountType index) const {\n+  return *entry_addr(index);\n+}\n+\n@@ -171,1 +189,1 @@\n-  assert(card_idx < (1u << (sizeof(_data[0]) * BitsPerByte)),\n+  assert(card_idx < (1u << (sizeof(EntryDataType) * BitsPerByte)),\n@@ -176,1 +194,1 @@\n-    if (_data[idx] == card_idx) {\n+    if (at(idx) == card_idx) {\n@@ -189,1 +207,1 @@\n-    if (_data[idx] == card_idx) {\n+    if (at(idx) == card_idx) {\n@@ -199,1 +217,1 @@\n-  _data[num_entries] = checked_cast<EntryDataType>(card_idx);\n+  *entry_addr(num_entries) = checked_cast<EntryDataType>(card_idx);\n@@ -210,1 +228,1 @@\n-    if (_data[idx] == card_idx) {\n+    if (at(idx) == card_idx) {\n@@ -221,1 +239,1 @@\n-    found(_data[idx]);\n+    found(at(idx));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  MemRegion mr(G1CollectedHeap::heap()->bottom_addr_for_region(start_idx), num_regions * HeapRegion::GrainWords);\n+  MemRegion mr(G1CollectedHeap::heap()->bottom_addr_for_region(start_idx), num_regions * G1HeapRegion::GrainWords);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  return (uint)(card_idx >> HeapRegion::LogCardsPerRegion);\n+  return (uint)(card_idx >> G1HeapRegion::LogCardsPerRegion);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-    HeapRegion* _hr;\n+    G1HeapRegion* _hr;\n@@ -312,1 +312,1 @@\n-    PointsIntoHRDetectionClosure(HeapRegion* hr) : _hr(hr), _points_into(false) {}\n+    PointsIntoHRDetectionClosure(G1HeapRegion* hr) : _hr(hr), _points_into(false) {}\n@@ -323,1 +323,1 @@\n-  CleanCallback(HeapRegion* hr) : _detector(hr), _nmethod_cl(&_detector, !NMethodToOopClosure::FixRelocations) {}\n+  CleanCallback(G1HeapRegion* hr) : _detector(hr), _nmethod_cl(&_detector, !NMethodToOopClosure::FixRelocations) {}\n@@ -332,1 +332,1 @@\n-void G1CodeRootSet::clean(HeapRegion* owner) {\n+void G1CodeRootSet::clean(G1HeapRegion* owner) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -56,1 +56,1 @@\n-  void clean(HeapRegion* owner);\n+  void clean(G1HeapRegion* owner);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  uint log_region_size = HeapRegion::LogOfHRGrainBytes;\n+  uint log_region_size = G1HeapRegion::LogOfHRGrainBytes;\n@@ -157,3 +157,3 @@\n-HeapRegion* G1CollectedHeap::new_heap_region(uint hrs_index,\n-                                             MemRegion mr) {\n-  return new HeapRegion(hrs_index, bot(), mr, &_card_set_config);\n+G1HeapRegion* G1CollectedHeap::new_heap_region(uint hrs_index,\n+                                               MemRegion mr) {\n+  return new G1HeapRegion(hrs_index, bot(), mr, &_card_set_config);\n@@ -164,5 +164,5 @@\n-HeapRegion* G1CollectedHeap::new_region(size_t word_size,\n-                                        HeapRegionType type,\n-                                        bool do_expand,\n-                                        uint node_index) {\n-  assert(!is_humongous(word_size) || word_size <= HeapRegion::GrainWords,\n+G1HeapRegion* G1CollectedHeap::new_region(size_t word_size,\n+                                          HeapRegionType type,\n+                                          bool do_expand,\n+                                          uint node_index) {\n+  assert(!is_humongous(word_size) || word_size <= G1HeapRegion::GrainWords,\n@@ -172,1 +172,1 @@\n-  HeapRegion* res = _hrm.allocate_free_region(type, node_index);\n+  G1HeapRegion* res = _hrm.allocate_free_region(type, node_index);\n@@ -183,1 +183,1 @@\n-    assert(word_size * HeapWordSize < HeapRegion::GrainBytes,\n+    assert(word_size * HeapWordSize < G1HeapRegion::GrainBytes,\n@@ -197,1 +197,1 @@\n-void G1CollectedHeap::set_humongous_metadata(HeapRegion* first_hr,\n+void G1CollectedHeap::set_humongous_metadata(G1HeapRegion* first_hr,\n@@ -204,1 +204,1 @@\n-  size_t word_size_sum = num_regions * HeapRegion::GrainWords;\n+  size_t word_size_sum = num_regions * G1HeapRegion::GrainWords;\n@@ -239,1 +239,1 @@\n-  HeapRegion* hr = nullptr;\n+  G1HeapRegion* hr = nullptr;\n@@ -280,1 +280,1 @@\n-G1CollectedHeap::humongous_obj_allocate_initialize_regions(HeapRegion* first_hr,\n+G1CollectedHeap::humongous_obj_allocate_initialize_regions(G1HeapRegion* first_hr,\n@@ -285,1 +285,1 @@\n-  assert(num_regions * HeapRegion::GrainWords >= word_size, \"pre-condition\");\n+  assert(num_regions * G1HeapRegion::GrainWords >= word_size, \"pre-condition\");\n@@ -321,1 +321,1 @@\n-  HeapRegion* last_hr = region_at(last);\n+  G1HeapRegion* last_hr = region_at(last);\n@@ -327,1 +327,1 @@\n-    HeapRegion *hr = region_at(i);\n+    G1HeapRegion *hr = region_at(i);\n@@ -337,1 +337,1 @@\n-  return align_up(word_size, HeapRegion::GrainWords) \/ HeapRegion::GrainWords;\n+  return align_up(word_size, G1HeapRegion::GrainWords) \/ G1HeapRegion::GrainWords;\n@@ -351,1 +351,1 @@\n-  HeapRegion* humongous_start = _hrm.allocate_humongous(obj_regions);\n+  G1HeapRegion* humongous_start = _hrm.allocate_humongous(obj_regions);\n@@ -476,2 +476,2 @@\n-  HeapRegion* curr_region = _hrm.addr_to_region(range.start());\n-  HeapRegion* end_region = _hrm.addr_to_region(range.last());\n+  G1HeapRegion* curr_region = _hrm.addr_to_region(range.start());\n+  G1HeapRegion* end_region = _hrm.addr_to_region(range.last());\n@@ -481,1 +481,1 @@\n-    HeapRegion* next_region = is_last ? nullptr : _hrm.next_region_in_heap(curr_region);\n+    G1HeapRegion* next_region = is_last ? nullptr : _hrm.next_region_in_heap(curr_region);\n@@ -507,1 +507,1 @@\n-  HeapWord* start_addr = reserved.end() - align_up(word_size, HeapRegion::GrainWords);\n+  HeapWord* start_addr = reserved.end() - align_up(word_size, G1HeapRegion::GrainWords);\n@@ -516,1 +516,1 @@\n-                              HeapRegion::GrainWords * HeapWordSize * commits);\n+                              G1HeapRegion::GrainWords * HeapWordSize * commits);\n@@ -521,1 +521,1 @@\n-  auto set_region_to_old = [&] (HeapRegion* r, bool is_last) {\n+  auto set_region_to_old = [&] (G1HeapRegion* r, bool is_last) {\n@@ -540,1 +540,1 @@\n-                           [&] (HeapRegion* r, bool is_last) {\n+                           [&] (G1HeapRegion* r, bool is_last) {\n@@ -562,1 +562,1 @@\n-  auto dealloc_archive_region = [&] (HeapRegion* r, bool is_last) {\n+  auto dealloc_archive_region = [&] (G1HeapRegion* r, bool is_last) {\n@@ -575,1 +575,1 @@\n-                              HeapRegion::GrainWords * HeapWordSize * shrink_count);\n+                              G1HeapRegion::GrainWords * HeapWordSize * shrink_count);\n@@ -653,1 +653,1 @@\n-          add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n+          add_allocated_humongous_bytes_since_last_gc(size_in_regions * G1HeapRegion::GrainBytes);\n@@ -669,1 +669,1 @@\n-          record_collection_pause_humongous_allocation(size_in_regions * HeapRegion::GrainBytes);\n+          record_collection_pause_humongous_allocation(size_in_regions * G1HeapRegion::GrainBytes);\n@@ -715,1 +715,1 @@\n-  bool do_heap_region(HeapRegion* hr) {\n+  bool do_heap_region(G1HeapRegion* hr) {\n@@ -994,2 +994,1 @@\n-  aligned_expand_bytes = align_up(aligned_expand_bytes,\n-                                       HeapRegion::GrainBytes);\n+  aligned_expand_bytes = align_up(aligned_expand_bytes, G1HeapRegion::GrainBytes);\n@@ -1006,1 +1005,1 @@\n-  uint regions_to_expand = (uint)(aligned_expand_bytes \/ HeapRegion::GrainBytes);\n+  uint regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n@@ -1016,1 +1015,1 @@\n-  size_t actual_expand_bytes = expanded_by * HeapRegion::GrainBytes;\n+  size_t actual_expand_bytes = expanded_by * G1HeapRegion::GrainBytes;\n@@ -1039,3 +1038,2 @@\n-  aligned_shrink_bytes = align_down(aligned_shrink_bytes,\n-                                         HeapRegion::GrainBytes);\n-  uint num_regions_to_remove = (uint)(shrink_bytes \/ HeapRegion::GrainBytes);\n+  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+  uint num_regions_to_remove = (uint)(shrink_bytes \/ G1HeapRegion::GrainBytes);\n@@ -1044,1 +1042,1 @@\n-  size_t shrunk_bytes = num_regions_removed * HeapRegion::GrainBytes;\n+  size_t shrunk_bytes = num_regions_removed * G1HeapRegion::GrainBytes;\n@@ -1099,1 +1097,1 @@\n-  bool is_correct_type(HeapRegion* hr) { return hr->is_old(); }\n+  bool is_correct_type(G1HeapRegion* hr) { return hr->is_old(); }\n@@ -1123,1 +1121,1 @@\n-  bool is_correct_type(HeapRegion* hr) { return hr->is_humongous(); }\n+  bool is_correct_type(G1HeapRegion* hr) { return hr->is_humongous(); }\n@@ -1182,1 +1180,1 @@\n-  _humongous_object_threshold_in_words = humongous_threshold_for(HeapRegion::GrainWords);\n+  _humongous_object_threshold_in_words = humongous_threshold_for(G1HeapRegion::GrainWords);\n@@ -1188,1 +1186,1 @@\n-  _filler_array_max_size = HeapRegion::GrainWords;\n+  _filler_array_max_size = G1HeapRegion::GrainWords;\n@@ -1217,1 +1215,1 @@\n-                                         HeapRegion::GrainBytes,\n+                                         G1HeapRegion::GrainBytes,\n@@ -1263,2 +1261,2 @@\n-  Universe::check_alignment(init_byte_size, HeapRegion::GrainBytes, \"g1 heap\");\n-  Universe::check_alignment(reserved_byte_size, HeapRegion::GrainBytes, \"g1 heap\");\n+  Universe::check_alignment(init_byte_size, G1HeapRegion::GrainBytes, \"g1 heap\");\n+  Universe::check_alignment(reserved_byte_size, G1HeapRegion::GrainBytes, \"g1 heap\");\n@@ -1273,1 +1271,1 @@\n-  \/\/ HeapRegion::GrainBytes (i.e. the alignment that is passed\n+  \/\/ G1HeapRegion::GrainBytes (i.e. the alignment that is passed\n@@ -1305,1 +1303,1 @@\n-                                         HeapRegion::GrainBytes,\n+                                         G1HeapRegion::GrainBytes,\n@@ -1353,2 +1351,2 @@\n-  guarantee(HeapRegion::CardsPerRegion > 0, \"make sure it's initialized\");\n-  guarantee(HeapRegion::CardsPerRegion < max_cards_per_region,\n+  guarantee(G1HeapRegion::CardsPerRegion > 0, \"make sure it's initialized\");\n+  guarantee(G1HeapRegion::CardsPerRegion < max_cards_per_region,\n@@ -1364,1 +1362,1 @@\n-    size_t granularity = HeapRegion::GrainBytes;\n+    size_t granularity = G1HeapRegion::GrainBytes;\n@@ -1375,1 +1373,1 @@\n-  _numa->set_region_info(HeapRegion::GrainBytes, page_size);\n+  _numa->set_region_info(G1HeapRegion::GrainBytes, page_size);\n@@ -1408,1 +1406,1 @@\n-  \/\/ Here we allocate the dummy HeapRegion that is required by the\n+  \/\/ Here we allocate the dummy G1HeapRegion that is required by the\n@@ -1410,1 +1408,1 @@\n-  HeapRegion* dummy_region = _hrm.get_dummy_region();\n+  G1HeapRegion* dummy_region = _hrm.get_dummy_region();\n@@ -1524,1 +1522,1 @@\n-  return _hrm.length() * HeapRegion::GrainBytes;\n+  return _hrm.length() * G1HeapRegion::GrainBytes;\n@@ -1545,1 +1543,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -1890,1 +1888,1 @@\n-\/\/ Iterates an ObjectClosure over all objects within a HeapRegion.\n+\/\/ Iterates an ObjectClosure over all objects within a G1HeapRegion.\n@@ -1896,1 +1894,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -1989,1 +1987,1 @@\n-      HeapRegion* r = region_at(region_idx);\n+      G1HeapRegion* r = region_at(region_idx);\n@@ -2002,1 +2000,1 @@\n-  HeapRegion* hr = heap_region_containing(addr);\n+  G1HeapRegion* hr = heap_region_containing(addr);\n@@ -2004,1 +2002,1 @@\n-  \/\/ the heap. HeapRegion::block_start() has been optimized to not accept addresses\n+  \/\/ the heap. G1HeapRegion::block_start() has been optimized to not accept addresses\n@@ -2013,1 +2011,1 @@\n-  HeapRegion* hr = heap_region_containing(addr);\n+  G1HeapRegion* hr = heap_region_containing(addr);\n@@ -2018,1 +2016,1 @@\n-  return (_policy->young_list_target_length() - _survivor.length()) * HeapRegion::GrainBytes;\n+  return (_policy->young_list_target_length() - _survivor.length()) * G1HeapRegion::GrainBytes;\n@@ -2022,1 +2020,1 @@\n-  return _eden.length() * HeapRegion::GrainBytes;\n+  return _eden.length() * G1HeapRegion::GrainBytes;\n@@ -2036,1 +2034,1 @@\n-  return max_regions() * HeapRegion::GrainBytes;\n+  return max_regions() * G1HeapRegion::GrainBytes;\n@@ -2055,1 +2053,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -2062,1 +2060,1 @@\n-                                       const HeapRegion* hr,\n+                                       const G1HeapRegion* hr,\n@@ -2099,1 +2097,1 @@\n-  st->print(\"  region size \" SIZE_FORMAT \"K, \", HeapRegion::GrainBytes \/ K);\n+  st->print(\"  region size \" SIZE_FORMAT \"K, \", G1HeapRegion::GrainBytes \/ K);\n@@ -2102,1 +2100,1 @@\n-            (size_t) young_regions * HeapRegion::GrainBytes \/ K);\n+            (size_t) young_regions * G1HeapRegion::GrainBytes \/ K);\n@@ -2105,1 +2103,1 @@\n-            (size_t) survivor_regions * HeapRegion::GrainBytes \/ K);\n+            (size_t) survivor_regions * G1HeapRegion::GrainBytes \/ K);\n@@ -2172,1 +2170,1 @@\n-    (policy()->young_list_target_length() * HeapRegion::GrainBytes) - survivor_used_bytes;\n+    (policy()->young_list_target_length() * G1HeapRegion::GrainBytes) - survivor_used_bytes;\n@@ -2283,1 +2281,1 @@\n-bool G1CollectedHeap::is_potential_eager_reclaim_candidate(HeapRegion* r) const {\n+bool G1CollectedHeap::is_potential_eager_reclaim_candidate(G1HeapRegion* r) const {\n@@ -2295,1 +2293,1 @@\n-    virtual bool do_heap_region(HeapRegion* r) {\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -2548,1 +2546,1 @@\n-    bool do_heap_region(HeapRegion* hr) {\n+    bool do_heap_region(G1HeapRegion* hr) {\n@@ -2615,1 +2613,1 @@\n-void G1CollectedHeap::clear_bitmap_for_region(HeapRegion* hr) {\n+void G1CollectedHeap::clear_bitmap_for_region(G1HeapRegion* hr) {\n@@ -2619,1 +2617,1 @@\n-void G1CollectedHeap::free_region(HeapRegion* hr, FreeRegionList* free_list) {\n+void G1CollectedHeap::free_region(G1HeapRegion* hr, FreeRegionList* free_list) {\n@@ -2635,1 +2633,1 @@\n-void G1CollectedHeap::retain_region(HeapRegion* hr) {\n+void G1CollectedHeap::retain_region(G1HeapRegion* hr) {\n@@ -2640,1 +2638,1 @@\n-void G1CollectedHeap::free_humongous_region(HeapRegion* hr,\n+void G1CollectedHeap::free_humongous_region(G1HeapRegion* hr,\n@@ -2685,1 +2683,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -2701,1 +2699,1 @@\n-bool G1CollectedHeap::is_old_gc_alloc_region(HeapRegion* hr) {\n+bool G1CollectedHeap::is_old_gc_alloc_region(G1HeapRegion* hr) {\n@@ -2705,1 +2703,1 @@\n-void G1CollectedHeap::set_region_short_lived_locked(HeapRegion* hr) {\n+void G1CollectedHeap::set_region_short_lived_locked(G1HeapRegion* hr) {\n@@ -2717,1 +2715,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -2740,2 +2738,2 @@\n-\/\/ Remove the given HeapRegion from the appropriate region set.\n-void G1CollectedHeap::prepare_region_for_full_compaction(HeapRegion* hr) {\n+\/\/ Remove the given G1HeapRegion from the appropriate region set.\n+void G1CollectedHeap::prepare_region_for_full_compaction(G1HeapRegion* hr) {\n@@ -2798,1 +2796,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -2848,1 +2846,1 @@\n-HeapRegion* G1CollectedHeap::new_mutator_alloc_region(size_t word_size,\n+G1HeapRegion* G1CollectedHeap::new_mutator_alloc_region(size_t word_size,\n@@ -2853,4 +2851,4 @@\n-    HeapRegion* new_alloc_region = new_region(word_size,\n-                                              HeapRegionType::Eden,\n-                                              false \/* do_expand *\/,\n-                                              node_index);\n+    G1HeapRegion* new_alloc_region = new_region(word_size,\n+                                                HeapRegionType::Eden,\n+                                                false \/* do_expand *\/,\n+                                                node_index);\n@@ -2867,1 +2865,1 @@\n-void G1CollectedHeap::retire_mutator_alloc_region(HeapRegion* alloc_region,\n+void G1CollectedHeap::retire_mutator_alloc_region(G1HeapRegion* alloc_region,\n@@ -2893,1 +2891,1 @@\n-HeapRegion* G1CollectedHeap::new_gc_alloc_region(size_t word_size, G1HeapRegionAttr dest, uint node_index) {\n+G1HeapRegion* G1CollectedHeap::new_gc_alloc_region(size_t word_size, G1HeapRegionAttr dest, uint node_index) {\n@@ -2907,4 +2905,4 @@\n-  HeapRegion* new_alloc_region = new_region(word_size,\n-                                            type,\n-                                            true \/* do_expand *\/,\n-                                            node_index);\n+  G1HeapRegion* new_alloc_region = new_region(word_size,\n+                                              type,\n+                                              true \/* do_expand *\/,\n+                                              node_index);\n@@ -2928,1 +2926,1 @@\n-void G1CollectedHeap::retire_gc_alloc_region(HeapRegion* alloc_region,\n+void G1CollectedHeap::retire_gc_alloc_region(G1HeapRegion* alloc_region,\n@@ -2946,1 +2944,1 @@\n-HeapRegion* G1CollectedHeap::alloc_highest_free_region() {\n+G1HeapRegion* G1CollectedHeap::alloc_highest_free_region() {\n@@ -2953,1 +2951,1 @@\n-                                HeapRegion::GrainWords * HeapWordSize);\n+                                G1HeapRegion::GrainWords * HeapWordSize);\n@@ -2979,1 +2977,1 @@\n-      HeapRegion* hr = _g1h->heap_region_containing(obj);\n+      G1HeapRegion* hr = _g1h->heap_region_containing(obj);\n@@ -3048,1 +3046,1 @@\n-  HeapRegion* region = heap_region_containing(start);\n+  G1HeapRegion* region = heap_region_containing(start);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":100,"deletions":102,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -199,1 +199,1 @@\n-  void prepare_region_for_full_compaction(HeapRegion* hr);\n+  void prepare_region_for_full_compaction(G1HeapRegion* hr);\n@@ -385,1 +385,1 @@\n-  \/\/ Try to allocate a single non-humongous HeapRegion sufficient for\n+  \/\/ Try to allocate a single non-humongous G1HeapRegion sufficient for\n@@ -390,4 +390,4 @@\n-  HeapRegion* new_region(size_t word_size,\n-                         HeapRegionType type,\n-                         bool do_expand,\n-                         uint node_index = G1NUMA::AnyNodeIndex);\n+  G1HeapRegion* new_region(size_t word_size,\n+                           HeapRegionType type,\n+                           bool do_expand,\n+                           uint node_index = G1NUMA::AnyNodeIndex);\n@@ -398,1 +398,1 @@\n-  HeapWord* humongous_obj_allocate_initialize_regions(HeapRegion* first_hr,\n+  HeapWord* humongous_obj_allocate_initialize_regions(G1HeapRegion* first_hr,\n@@ -468,2 +468,2 @@\n-  HeapRegion* new_mutator_alloc_region(size_t word_size, uint node_index);\n-  void retire_mutator_alloc_region(HeapRegion* alloc_region,\n+  G1HeapRegion* new_mutator_alloc_region(size_t word_size, uint node_index);\n+  void retire_mutator_alloc_region(G1HeapRegion* alloc_region,\n@@ -474,2 +474,2 @@\n-  HeapRegion* new_gc_alloc_region(size_t word_size, G1HeapRegionAttr dest, uint node_index);\n-  void retire_gc_alloc_region(HeapRegion* alloc_region,\n+  G1HeapRegion* new_gc_alloc_region(size_t word_size, G1HeapRegionAttr dest, uint node_index);\n+  void retire_gc_alloc_region(G1HeapRegion* alloc_region,\n@@ -575,1 +575,1 @@\n-  \/\/ (Rounds up to a HeapRegion boundary.)\n+  \/\/ (Rounds up to a G1HeapRegion boundary.)\n@@ -596,1 +596,1 @@\n-  bool is_potential_eager_reclaim_candidate(HeapRegion* r) const;\n+  bool is_potential_eager_reclaim_candidate(G1HeapRegion* r) const;\n@@ -607,1 +607,1 @@\n-  void set_humongous_metadata(HeapRegion* first_hr,\n+  void set_humongous_metadata(G1HeapRegion* first_hr,\n@@ -614,1 +614,1 @@\n-  void register_young_region_with_region_attr(HeapRegion* r) {\n+  void register_young_region_with_region_attr(G1HeapRegion* r) {\n@@ -617,4 +617,4 @@\n-  inline void register_new_survivor_region_with_region_attr(HeapRegion* r);\n-  inline void register_region_with_region_attr(HeapRegion* r);\n-  inline void register_old_region_with_region_attr(HeapRegion* r);\n-  inline void register_optional_region_with_region_attr(HeapRegion* r);\n+  inline void register_new_survivor_region_with_region_attr(G1HeapRegion* r);\n+  inline void register_region_with_region_attr(G1HeapRegion* r);\n+  inline void register_old_region_with_region_attr(G1HeapRegion* r);\n+  inline void register_optional_region_with_region_attr(G1HeapRegion* r);\n@@ -622,1 +622,1 @@\n-  void clear_region_attr(const HeapRegion* hr) {\n+  void clear_region_attr(const G1HeapRegion* hr) {\n@@ -634,1 +634,1 @@\n-  void clear_bitmap_for_region(HeapRegion* hr);\n+  void clear_bitmap_for_region(G1HeapRegion* hr);\n@@ -670,1 +670,1 @@\n-  HeapRegion* new_heap_region(uint hrs_index, MemRegion mr);\n+  G1HeapRegion* new_heap_region(uint hrs_index, MemRegion mr);\n@@ -674,1 +674,1 @@\n-  HeapRegion* alloc_highest_free_region();\n+  G1HeapRegion* alloc_highest_free_region();\n@@ -682,1 +682,1 @@\n-  void free_region(HeapRegion* hr, FreeRegionList* free_list);\n+  void free_region(G1HeapRegion* hr, FreeRegionList* free_list);\n@@ -685,1 +685,1 @@\n-  void retain_region(HeapRegion* hr);\n+  void retain_region(G1HeapRegion* hr);\n@@ -699,1 +699,1 @@\n-  void free_humongous_region(HeapRegion* hr,\n+  void free_humongous_region(G1HeapRegion* hr,\n@@ -702,1 +702,1 @@\n-  \/\/ Execute func(HeapRegion* r, bool is_last) on every region covered by the\n+  \/\/ Execute func(G1HeapRegion* r, bool is_last) on every region covered by the\n@@ -728,1 +728,1 @@\n-  \/\/ (Rounds down to a HeapRegion boundary.)\n+  \/\/ (Rounds down to a G1HeapRegion boundary.)\n@@ -921,1 +921,1 @@\n-  inline bool is_collection_set_candidate(const HeapRegion* r) const;\n+  inline bool is_collection_set_candidate(const G1HeapRegion* r) const;\n@@ -996,1 +996,1 @@\n-  bool is_on_master_free_list(HeapRegion* hr) {\n+  bool is_on_master_free_list(G1HeapRegion* hr) {\n@@ -1001,2 +1001,2 @@\n-  inline void old_set_add(HeapRegion* hr);\n-  inline void old_set_remove(HeapRegion* hr);\n+  inline void old_set_add(G1HeapRegion* hr);\n+  inline void old_set_remove(G1HeapRegion* hr);\n@@ -1005,1 +1005,1 @@\n-    return (old_regions_count() + humongous_regions_count()) * HeapRegion::GrainBytes;\n+    return (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n@@ -1010,1 +1010,1 @@\n-  bool is_old_gc_alloc_region(HeapRegion* hr);\n+  bool is_old_gc_alloc_region(G1HeapRegion* hr);\n@@ -1032,1 +1032,1 @@\n-  inline bool is_in_cset(const HeapRegion* hr) const;\n+  inline bool is_in_cset(const G1HeapRegion* hr) const;\n@@ -1079,2 +1079,2 @@\n-  inline HeapRegion* region_at(uint index) const;\n-  inline HeapRegion* region_at_or_null(uint index) const;\n+  inline G1HeapRegion* region_at(uint index) const;\n+  inline G1HeapRegion* region_at_or_null(uint index) const;\n@@ -1083,1 +1083,1 @@\n-  \/\/ region and apply the given method with the signature f(HeapRegion*) on them.\n+  \/\/ region and apply the given method with the signature f(G1HeapRegion*) on them.\n@@ -1085,1 +1085,1 @@\n-  void humongous_obj_regions_iterate(HeapRegion* start, const Func& f);\n+  void humongous_obj_regions_iterate(G1HeapRegion* start, const Func& f);\n@@ -1133,2 +1133,2 @@\n-  \/\/ Returns the HeapRegion that contains addr. addr must not be null.\n-  inline HeapRegion* heap_region_containing(const void* addr) const;\n+  \/\/ Returns the G1HeapRegion that contains addr. addr must not be null.\n+  inline G1HeapRegion* heap_region_containing(const void* addr) const;\n@@ -1136,1 +1136,1 @@\n-  \/\/ Returns the HeapRegion that contains addr, or null if that is an uncommitted\n+  \/\/ Returns the G1HeapRegion that contains addr, or null if that is an uncommitted\n@@ -1138,1 +1138,1 @@\n-  inline HeapRegion* heap_region_containing_or_null(const void* addr) const;\n+  inline G1HeapRegion* heap_region_containing_or_null(const void* addr) const;\n@@ -1200,1 +1200,1 @@\n-  void set_region_short_lived_locked(HeapRegion* hr);\n+  void set_region_short_lived_locked(G1HeapRegion* hr);\n@@ -1224,1 +1224,1 @@\n-  inline bool is_obj_dead(const oop obj, const HeapRegion* hr) const;\n+  inline bool is_obj_dead(const oop obj, const G1HeapRegion* hr) const;\n@@ -1232,1 +1232,1 @@\n-  inline bool is_obj_dead_full(const oop obj, const HeapRegion* hr) const;\n+  inline bool is_obj_dead_full(const oop obj, const G1HeapRegion* hr) const;\n@@ -1289,1 +1289,1 @@\n-                        const HeapRegion* hr,\n+                        const G1HeapRegion* hr,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-inline HeapRegion* G1CollectedHeap::region_at(uint index) const { return _hrm.at(index); }\n+inline G1HeapRegion* G1CollectedHeap::region_at(uint index) const { return _hrm.at(index); }\n@@ -109,1 +109,1 @@\n-inline HeapRegion* G1CollectedHeap::region_at_or_null(uint index) const { return _hrm.at_or_null(index); }\n+inline G1HeapRegion* G1CollectedHeap::region_at_or_null(uint index) const { return _hrm.at_or_null(index); }\n@@ -112,1 +112,1 @@\n-inline void G1CollectedHeap::humongous_obj_regions_iterate(HeapRegion* start, const Func& f) {\n+inline void G1CollectedHeap::humongous_obj_regions_iterate(G1HeapRegion* start, const Func& f) {\n@@ -116,1 +116,1 @@\n-    HeapRegion* next = _hrm.next_region_in_humongous(start);\n+    G1HeapRegion* next = _hrm.next_region_in_humongous(start);\n@@ -126,1 +126,1 @@\n-  return (uint)(pointer_delta(addr, reserved().start(), sizeof(uint8_t)) >> HeapRegion::LogOfHRGrainBytes);\n+  return (uint)(pointer_delta(addr, reserved().start(), sizeof(uint8_t)) >> G1HeapRegion::LogOfHRGrainBytes);\n@@ -130,1 +130,1 @@\n-  return _hrm.reserved().start() + index * HeapRegion::GrainWords;\n+  return _hrm.reserved().start() + index * G1HeapRegion::GrainWords;\n@@ -134,1 +134,1 @@\n-inline HeapRegion* G1CollectedHeap::heap_region_containing(const void* addr) const {\n+inline G1HeapRegion* G1CollectedHeap::heap_region_containing(const void* addr) const {\n@@ -139,1 +139,1 @@\n-inline HeapRegion* G1CollectedHeap::heap_region_containing_or_null(const void* addr) const {\n+inline G1HeapRegion* G1CollectedHeap::heap_region_containing_or_null(const void* addr) const {\n@@ -144,1 +144,1 @@\n-inline void G1CollectedHeap::old_set_add(HeapRegion* hr) {\n+inline void G1CollectedHeap::old_set_add(G1HeapRegion* hr) {\n@@ -148,1 +148,1 @@\n-inline void G1CollectedHeap::old_set_remove(HeapRegion* hr) {\n+inline void G1CollectedHeap::old_set_remove(G1HeapRegion* hr) {\n@@ -163,1 +163,1 @@\n-  DEBUG_ONLY(HeapRegion* containing_hr = heap_region_containing(start);)\n+  DEBUG_ONLY(G1HeapRegion* containing_hr = heap_region_containing(start);)\n@@ -196,1 +196,1 @@\n-bool G1CollectedHeap::is_in_cset(const HeapRegion* hr) const {\n+bool G1CollectedHeap::is_in_cset(const G1HeapRegion* hr) const {\n@@ -218,1 +218,1 @@\n-void G1CollectedHeap::register_new_survivor_region_with_region_attr(HeapRegion* r) {\n+void G1CollectedHeap::register_new_survivor_region_with_region_attr(G1HeapRegion* r) {\n@@ -222,1 +222,1 @@\n-void G1CollectedHeap::register_region_with_region_attr(HeapRegion* r) {\n+void G1CollectedHeap::register_region_with_region_attr(G1HeapRegion* r) {\n@@ -227,1 +227,1 @@\n-void G1CollectedHeap::register_old_region_with_region_attr(HeapRegion* r) {\n+void G1CollectedHeap::register_old_region_with_region_attr(G1HeapRegion* r) {\n@@ -234,1 +234,1 @@\n-void G1CollectedHeap::register_optional_region_with_region_attr(HeapRegion* r) {\n+void G1CollectedHeap::register_optional_region_with_region_attr(G1HeapRegion* r) {\n@@ -255,1 +255,1 @@\n-inline bool G1CollectedHeap::is_obj_dead(const oop obj, const HeapRegion* hr) const {\n+inline bool G1CollectedHeap::is_obj_dead(const oop obj, const G1HeapRegion* hr) const {\n@@ -289,1 +289,1 @@\n-inline bool G1CollectedHeap::is_obj_dead_full(const oop obj, const HeapRegion* hr) const {\n+inline bool G1CollectedHeap::is_obj_dead_full(const oop obj, const G1HeapRegion* hr) const {\n@@ -314,1 +314,1 @@\n-inline bool G1CollectedHeap::is_collection_set_candidate(const HeapRegion* r) const {\n+inline bool G1CollectedHeap::is_collection_set_candidate(const G1HeapRegion* r) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-void G1CollectionSet::add_old_region(HeapRegion* hr) {\n+void G1CollectionSet::add_old_region(G1HeapRegion* hr) {\n@@ -137,1 +137,1 @@\n-    HeapRegion* r = _g1h->region_at(_collection_set_regions[i]);\n+    G1HeapRegion* r = _g1h->region_at(_collection_set_regions[i]);\n@@ -155,1 +155,1 @@\n-  for (HeapRegion* r : _optional_old_regions) {\n+  for (G1HeapRegion* r : _optional_old_regions) {\n@@ -179,1 +179,1 @@\n-void G1CollectionSet::add_young_region_common(HeapRegion* hr) {\n+void G1CollectionSet::add_young_region_common(G1HeapRegion* hr) {\n@@ -199,1 +199,1 @@\n-void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {\n+void G1CollectionSet::add_survivor_regions(G1HeapRegion* hr) {\n@@ -204,1 +204,1 @@\n-void G1CollectionSet::add_eden_region(HeapRegion* hr) {\n+void G1CollectionSet::add_eden_region(G1HeapRegion* hr) {\n@@ -216,1 +216,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -254,1 +254,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -390,1 +390,1 @@\n-  for (HeapRegion* r : *regions) {\n+  for (G1HeapRegion* r : *regions) {\n@@ -399,1 +399,1 @@\n-  for (HeapRegion* r : *regions) {\n+  for (G1HeapRegion* r : *regions) {\n@@ -415,1 +415,1 @@\n-  for (HeapRegion* r : *regions) {\n+  for (G1HeapRegion* r : *regions) {\n@@ -430,1 +430,1 @@\n-  for (HeapRegion* r : *regions) {\n+  for (G1HeapRegion* r : *regions) {\n@@ -460,1 +460,1 @@\n-  for (HeapRegion* r : _optional_old_regions) {\n+  for (G1HeapRegion* r : _optional_old_regions) {\n@@ -489,1 +489,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -171,1 +171,1 @@\n-  void add_young_region_common(HeapRegion* hr);\n+  void add_young_region_common(G1HeapRegion* hr);\n@@ -174,1 +174,1 @@\n-  void add_old_region(HeapRegion* hr);\n+  void add_old_region(G1HeapRegion* hr);\n@@ -274,1 +274,1 @@\n-  void add_eden_region(HeapRegion* hr);\n+  void add_eden_region(G1HeapRegion* hr);\n@@ -277,1 +277,1 @@\n-  void add_survivor_regions(HeapRegion* hr);\n+  void add_survivor_regions(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-void G1CollectionCandidateList::append_unsorted(HeapRegion* r) {\n+void G1CollectionCandidateList::append_unsorted(G1HeapRegion* r) {\n@@ -138,1 +138,1 @@\n-void G1CollectionCandidateRegionList::append(HeapRegion* r) {\n+void G1CollectionCandidateRegionList::append(G1HeapRegion* r) {\n@@ -147,1 +147,1 @@\n-  for (HeapRegion* r : *other) {\n+  for (G1HeapRegion* r : *other) {\n@@ -159,1 +159,1 @@\n-HeapRegion* G1CollectionCandidateRegionList::at(uint index) {\n+G1HeapRegion* G1CollectionCandidateRegionList::at(uint index) {\n@@ -179,1 +179,1 @@\n-bool G1CollectionSetCandidates::is_from_marking(HeapRegion* r) const {\n+bool G1CollectionSetCandidates::is_from_marking(G1HeapRegion* r) const {\n@@ -203,1 +203,1 @@\n-    HeapRegion* hr = (*iter)->_r;\n+    G1HeapRegion* hr = (*iter)->_r;\n@@ -219,1 +219,1 @@\n-    HeapRegion* r = candidate_infos[i]._r;\n+    G1HeapRegion* r = candidate_infos[i]._r;\n@@ -236,1 +236,1 @@\n-void G1CollectionSetCandidates::add_retained_region_unsorted(HeapRegion* r) {\n+void G1CollectionSetCandidates::add_retained_region_unsorted(G1HeapRegion* r) {\n@@ -252,1 +252,1 @@\n-  for (HeapRegion* r : *other) {\n+  for (G1HeapRegion* r : *other) {\n@@ -263,1 +263,1 @@\n-  for (HeapRegion* r : *other) {\n+  for (G1HeapRegion* r : *other) {\n@@ -292,1 +292,1 @@\n-    HeapRegion* r = list->at(i)._r;\n+    G1HeapRegion* r = list->at(i)._r;\n@@ -337,1 +337,1 @@\n-bool G1CollectionSetCandidates::contains(const HeapRegion* r) const {\n+bool G1CollectionSetCandidates::contains(const G1HeapRegion* r) const {\n@@ -343,1 +343,1 @@\n-const char* G1CollectionSetCandidates::get_short_type_str(const HeapRegion* r) const {\n+const char* G1CollectionSetCandidates::get_short_type_str(const G1HeapRegion* r) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -41,1 +41,1 @@\n-using G1CollectionCandidateRegionListIterator = GrowableArrayIterator<HeapRegion*>;\n+using G1CollectionCandidateRegionListIterator = GrowableArrayIterator<G1HeapRegion*>;\n@@ -43,1 +43,1 @@\n-\/\/ A set of HeapRegion*, a thin wrapper around GrowableArray.\n+\/\/ A set of G1HeapRegion*, a thin wrapper around GrowableArray.\n@@ -45,1 +45,1 @@\n-  GrowableArray<HeapRegion*> _regions;\n+  GrowableArray<G1HeapRegion*> _regions;\n@@ -50,1 +50,1 @@\n-  \/\/ Append a HeapRegion to the end of this list. The region must not be in the list\n+  \/\/ Append a G1HeapRegion to the end of this list. The region must not be in the list\n@@ -52,2 +52,2 @@\n-  void append(HeapRegion* r);\n-  \/\/ Remove the given list of HeapRegion* from this list. The given list must be a prefix\n+  void append(G1HeapRegion* r);\n+  \/\/ Remove the given list of G1HeapRegion* from this list. The given list must be a prefix\n@@ -60,1 +60,1 @@\n-  HeapRegion* at(uint index);\n+  G1HeapRegion* at(uint index);\n@@ -69,1 +69,1 @@\n-  HeapRegion* _r;\n+  G1HeapRegion* _r;\n@@ -74,1 +74,1 @@\n-  G1CollectionSetCandidateInfo(HeapRegion* r, double gc_efficiency) : _r(r), _gc_efficiency(gc_efficiency), _num_unreclaimed(0) { }\n+  G1CollectionSetCandidateInfo(G1HeapRegion* r, double gc_efficiency) : _r(r), _gc_efficiency(gc_efficiency), _num_unreclaimed(0) { }\n@@ -108,2 +108,2 @@\n-  \/\/ Add the given HeapRegion to this list at the end, (potentially) making the list unsorted.\n-  void append_unsorted(HeapRegion* r);\n+  \/\/ Add the given G1HeapRegion to this list at the end, (potentially) making the list unsorted.\n+  void append_unsorted(G1HeapRegion* r);\n@@ -154,1 +154,1 @@\n-  HeapRegion* operator*();\n+  G1HeapRegion* operator*();\n@@ -193,1 +193,1 @@\n-  bool is_from_marking(HeapRegion* r) const;\n+  bool is_from_marking(G1HeapRegion* r) const;\n@@ -221,1 +221,1 @@\n-  void add_retained_region_unsorted(HeapRegion* r);\n+  void add_retained_region_unsorted(G1HeapRegion* r);\n@@ -226,1 +226,1 @@\n-  bool contains(const HeapRegion* r) const;\n+  bool contains(const G1HeapRegion* r) const;\n@@ -228,1 +228,1 @@\n-  const char* get_short_type_str(const HeapRegion* r) const;\n+  const char* get_short_type_str(const G1HeapRegion* r) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-inline HeapRegion* G1CollectionSetCandidatesIterator::operator*() {\n+inline G1HeapRegion* G1CollectionSetCandidatesIterator::operator*() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    void set(uint idx, HeapRegion* hr) {\n+    void set(uint idx, G1HeapRegion* hr) {\n@@ -127,1 +127,1 @@\n-    void add_region(HeapRegion* hr) {\n+    void add_region(G1HeapRegion* hr) {\n@@ -146,1 +146,1 @@\n-    bool do_heap_region(HeapRegion* r) {\n+    bool do_heap_region(G1HeapRegion* r) {\n@@ -215,1 +215,1 @@\n-      HeapRegion* r = data[num_candidates - num_pruned - 1]._r;\n+      G1HeapRegion* r = data[num_candidates - num_pruned - 1]._r;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    return HeapRegion::GrainBytes * (size_t) G1MixedGCLiveThresholdPercent \/ 100;\n+    return G1HeapRegion::GrainBytes * (size_t)G1MixedGCLiveThresholdPercent \/ 100;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -583,1 +583,1 @@\n-void G1ConcurrentMark::clear_statistics(HeapRegion* r) {\n+void G1ConcurrentMark::clear_statistics(G1HeapRegion* r) {\n@@ -592,1 +592,1 @@\n-void G1ConcurrentMark::humongous_object_eagerly_reclaimed(HeapRegion* r) {\n+void G1ConcurrentMark::humongous_object_eagerly_reclaimed(G1HeapRegion* r) {\n@@ -605,1 +605,1 @@\n-                                      [&] (HeapRegion* r) {\n+                                      [&] (G1HeapRegion* r) {\n@@ -700,1 +700,1 @@\n-    HeapWord* region_clear_limit(HeapRegion* r) {\n+    HeapWord* region_clear_limit(G1HeapRegion* r) {\n@@ -724,1 +724,1 @@\n-    virtual bool do_heap_region(HeapRegion* r) {\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -786,1 +786,1 @@\n-  size_t const num_bytes_to_clear = (HeapRegion::GrainBytes * _g1h->num_regions()) \/ G1CMBitMap::heap_map_factor();\n+  size_t const num_bytes_to_clear = (G1HeapRegion::GrainBytes * _g1h->num_regions()) \/ G1CMBitMap::heap_map_factor();\n@@ -872,1 +872,1 @@\n-  bool do_heap_region(HeapRegion* r) override {\n+  bool do_heap_region(G1HeapRegion* r) override {\n@@ -1038,1 +1038,1 @@\n-  HeapRegion* hr = _g1h->heap_region_containing(last);\n+  G1HeapRegion* hr = _g1h->heap_region_containing(last);\n@@ -1102,1 +1102,1 @@\n-void G1ConcurrentMark::add_root_region(HeapRegion* r) {\n+void G1ConcurrentMark::add_root_region(G1HeapRegion* r) {\n@@ -1106,1 +1106,1 @@\n-bool G1ConcurrentMark::is_root_region(HeapRegion* r) {\n+bool G1ConcurrentMark::is_root_region(G1HeapRegion* r) {\n@@ -1236,1 +1236,1 @@\n-    void reclaim_empty_humongous_region(HeapRegion* hr) {\n+    void reclaim_empty_humongous_region(G1HeapRegion* hr) {\n@@ -1240,1 +1240,1 @@\n-      auto on_humongous_region = [&] (HeapRegion* hr) {\n+      auto on_humongous_region = [&] (G1HeapRegion* hr) {\n@@ -1250,0 +1250,1 @@\n+        G1HeapRegionPrinter::mark_reclaim(hr);\n@@ -1256,1 +1257,1 @@\n-    void reclaim_empty_old_region(HeapRegion* hr) {\n+    void reclaim_empty_old_region(G1HeapRegion* hr) {\n@@ -1266,0 +1267,1 @@\n+      G1HeapRegionPrinter::mark_reclaim(hr);\n@@ -1269,1 +1271,1 @@\n-    bool do_heap_region(HeapRegion* hr) override {\n+    bool do_heap_region(G1HeapRegion* hr) override {\n@@ -1278,1 +1280,1 @@\n-          auto on_humongous_region = [&] (HeapRegion* hr) {\n+          auto on_humongous_region = [&] (G1HeapRegion* hr) {\n@@ -1320,2 +1322,0 @@\n-      \/\/ Now print the empty regions list.\n-      G1HeapRegionPrinter::mark_reclaim(&_cleanup_list);\n@@ -1363,1 +1363,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -1905,1 +1905,1 @@\n-void G1ConcurrentMark::clear_bitmap_for_region(HeapRegion* hr) {\n+void G1ConcurrentMark::clear_bitmap_for_region(G1HeapRegion* hr) {\n@@ -1910,1 +1910,1 @@\n-HeapRegion* G1ConcurrentMark::claim_region(uint worker_id) {\n+G1HeapRegion* G1ConcurrentMark::claim_region(uint worker_id) {\n@@ -1917,1 +1917,1 @@\n-    HeapRegion* curr_region = _g1h->heap_region_containing_or_null(finger);\n+    G1HeapRegion* curr_region = _g1h->heap_region_containing_or_null(finger);\n@@ -1922,1 +1922,1 @@\n-    HeapWord* end = curr_region != nullptr ? curr_region->end() : finger + HeapRegion::GrainWords;\n+    HeapWord* end = curr_region != nullptr ? curr_region->end() : finger + G1HeapRegion::GrainWords;\n@@ -1976,1 +1976,1 @@\n-    HeapRegion* r = _g1h->heap_region_containing(task_entry.obj());\n+    G1HeapRegion* r = _g1h->heap_region_containing(task_entry.obj());\n@@ -2001,1 +2001,1 @@\n-    \/\/ Since we always iterate over all regions, we might get a null HeapRegion\n+    \/\/ Since we always iterate over all regions, we might get a null G1HeapRegion\n@@ -2003,1 +2003,1 @@\n-    HeapRegion* global_hr = _g1h->heap_region_containing_or_null(global_finger);\n+    G1HeapRegion* global_hr = _g1h->heap_region_containing_or_null(global_finger);\n@@ -2016,1 +2016,1 @@\n-      HeapRegion* r = _g1h->heap_region_containing_or_null(task_finger);\n+      G1HeapRegion* r = _g1h->heap_region_containing_or_null(task_finger);\n@@ -2143,1 +2143,1 @@\n-void G1CMTask::setup_for_region(HeapRegion* hr) {\n+void G1CMTask::setup_for_region(G1HeapRegion* hr) {\n@@ -2152,1 +2152,1 @@\n-  HeapRegion* hr = _curr_region;\n+  G1HeapRegion* hr = _curr_region;\n@@ -2744,1 +2744,1 @@\n-      HeapRegion* claimed_region = _cm->claim_region(_worker_id);\n+      G1HeapRegion* claimed_region = _cm->claim_region(_worker_id);\n@@ -2999,1 +2999,1 @@\n-                          HeapRegion::GrainBytes);\n+                          G1HeapRegion::GrainBytes);\n@@ -3027,1 +3027,1 @@\n-bool G1PrintRegionLivenessInfoClosure::do_heap_region(HeapRegion* r) {\n+bool G1PrintRegionLivenessInfoClosure::do_heap_region(G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  HeapRegion* claim_region(uint worker_id);\n+  G1HeapRegion* claim_region(uint worker_id);\n@@ -567,1 +567,1 @@\n-  inline void update_top_at_mark_start(HeapRegion* r);\n+  inline void update_top_at_mark_start(G1HeapRegion* r);\n@@ -569,1 +569,1 @@\n-  inline void reset_top_at_mark_start(HeapRegion* r);\n+  inline void reset_top_at_mark_start(G1HeapRegion* r);\n@@ -571,1 +571,1 @@\n-  inline HeapWord* top_at_mark_start(const HeapRegion* r) const;\n+  inline HeapWord* top_at_mark_start(const G1HeapRegion* r) const;\n@@ -577,1 +577,1 @@\n-  inline void update_top_at_rebuild_start(HeapRegion* r);\n+  inline void update_top_at_rebuild_start(G1HeapRegion* r);\n@@ -579,1 +579,1 @@\n-  inline HeapWord* top_at_rebuild_start(HeapRegion* r) const;\n+  inline HeapWord* top_at_rebuild_start(G1HeapRegion* r) const;\n@@ -583,1 +583,1 @@\n-  void clear_statistics(HeapRegion* r);\n+  void clear_statistics(G1HeapRegion* r);\n@@ -585,1 +585,1 @@\n-  void humongous_object_eagerly_reclaimed(HeapRegion* r);\n+  void humongous_object_eagerly_reclaimed(G1HeapRegion* r);\n@@ -662,2 +662,2 @@\n-  void add_root_region(HeapRegion* r);\n-  bool is_root_region(HeapRegion* r);\n+  void add_root_region(G1HeapRegion* r);\n+  bool is_root_region(G1HeapRegion* r);\n@@ -691,1 +691,1 @@\n-  void clear_bitmap_for_region(HeapRegion* hr);\n+  void clear_bitmap_for_region(G1HeapRegion* hr);\n@@ -761,1 +761,1 @@\n-  HeapRegion*                 _curr_region;\n+  G1HeapRegion*               _curr_region;\n@@ -809,1 +809,1 @@\n-  void setup_for_region(HeapRegion* hr);\n+  void setup_for_region(G1HeapRegion* hr);\n@@ -972,1 +972,1 @@\n-  virtual bool do_heap_region(HeapRegion* r);\n+  virtual bool do_heap_region(G1HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  DEBUG_ONLY(HeapRegion* const hr = _g1h->heap_region_containing(obj);)\n+  DEBUG_ONLY(G1HeapRegion* const hr = _g1h->heap_region_containing(obj);)\n@@ -187,1 +187,1 @@\n-inline void G1ConcurrentMark::update_top_at_mark_start(HeapRegion* r) {\n+inline void G1ConcurrentMark::update_top_at_mark_start(G1HeapRegion* r) {\n@@ -193,1 +193,1 @@\n-inline void G1ConcurrentMark::reset_top_at_mark_start(HeapRegion* r) {\n+inline void G1ConcurrentMark::reset_top_at_mark_start(G1HeapRegion* r) {\n@@ -197,1 +197,1 @@\n-inline HeapWord* G1ConcurrentMark::top_at_mark_start(const HeapRegion* r) const {\n+inline HeapWord* G1ConcurrentMark::top_at_mark_start(const G1HeapRegion* r) const {\n@@ -212,1 +212,1 @@\n-inline HeapWord* G1ConcurrentMark::top_at_rebuild_start(HeapRegion* r) const {\n+inline HeapWord* G1ConcurrentMark::top_at_rebuild_start(G1HeapRegion* r) const {\n@@ -216,1 +216,1 @@\n-inline void G1ConcurrentMark::update_top_at_rebuild_start(HeapRegion* r) {\n+inline void G1ConcurrentMark::update_top_at_rebuild_start(G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  MemRegion mr(G1CollectedHeap::heap()->bottom_addr_for_region(start_region), num_regions * HeapRegion::GrainWords);\n+  MemRegion mr(G1CollectedHeap::heap()->bottom_addr_for_region(start_region), num_regions * G1HeapRegion::GrainWords);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-class HeapRegion;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkBitMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  HeapRegion* r = g1h->heap_region_containing(slice);\n+  G1HeapRegion* r = g1h->heap_region_containing(slice);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkObjArrayProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    bool should_rebuild_or_scrub(HeapRegion* hr) const {\n+    bool should_rebuild_or_scrub(G1HeapRegion* hr) const {\n@@ -115,1 +115,1 @@\n-    bool scan_large_object(HeapRegion* hr, const oop obj, MemRegion scan_range) {\n+    bool scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n@@ -143,1 +143,1 @@\n-    size_t scan_object(HeapRegion* hr, HeapWord* current) {\n+    size_t scan_object(G1HeapRegion* hr, HeapWord* current) {\n@@ -169,1 +169,1 @@\n-    HeapWord* scrub_to_next_live(HeapRegion* hr, HeapWord* scrub_start, HeapWord* limit) {\n+    HeapWord* scrub_to_next_live(G1HeapRegion* hr, HeapWord* scrub_start, HeapWord* limit) {\n@@ -181,1 +181,1 @@\n-    bool scan_and_scrub_to_pb(HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n+    bool scan_and_scrub_to_pb(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n@@ -208,1 +208,1 @@\n-    bool scan_from_pb_to_tars(HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n+    bool scan_from_pb_to_tars(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n@@ -228,1 +228,1 @@\n-    bool scan_and_scrub_region(HeapRegion* hr, HeapWord* const pb) {\n+    bool scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -258,1 +258,1 @@\n-    bool scan_humongous_region(HeapRegion* hr, HeapWord* const pb) {\n+    bool scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -297,1 +297,1 @@\n-    bool do_heap_region(HeapRegion* hr) {\n+    bool do_heap_region(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  bool do_heap_region(HeapRegion* r) override {\n+  bool do_heap_region(G1HeapRegion* r) override {\n@@ -320,1 +320,1 @@\n-      size_t young_bytes = _policy->young_list_target_length() * HeapRegion::GrainBytes;\n+      size_t young_bytes = _policy->young_list_target_length() * G1HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  double alloc_bytes_rate = alloc_region_rate * HeapRegion::GrainBytes;\n+  double alloc_bytes_rate = alloc_region_rate * G1HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThreadsNeeded.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  uint add(HeapRegion* hr) {\n+  uint add(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EdenRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    HeapRegion* hr = g1h->region_at(region_idx);\n+    G1HeapRegion* hr = g1h->region_at(region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-  _region_attr_table.initialize(heap->reserved(), HeapRegion::GrainBytes);\n+  _region_attr_table.initialize(heap->reserved(), G1HeapRegion::GrainBytes);\n@@ -173,1 +173,1 @@\n-  bool do_heap_region(HeapRegion* hr) {\n+  bool do_heap_region(G1HeapRegion* hr) {\n@@ -258,1 +258,1 @@\n-void G1FullCollector::before_marking_update_attribute_table(HeapRegion* hr) {\n+void G1FullCollector::before_marking_update_attribute_table(G1HeapRegion* hr) {\n@@ -422,1 +422,1 @@\n-  HeapRegion* start_hr = _heap->region_at(start_serial);\n+  G1HeapRegion* start_hr = _heap->region_at(start_serial);\n@@ -431,1 +431,1 @@\n-      HeapRegion* current = _heap->region_at(i);\n+      G1HeapRegion* current = _heap->region_at(i);\n@@ -452,1 +452,1 @@\n-    HeapRegion* hr = _heap->region_at_or_null(region_index);\n+    G1HeapRegion* hr = _heap->region_at_or_null(region_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -90,1 +90,1 @@\n-  GrowableArrayCHeap<HeapRegion*, mtGC> _humongous_compaction_regions;\n+  GrowableArrayCHeap<G1HeapRegion*, mtGC> _humongous_compaction_regions;\n@@ -128,1 +128,1 @@\n-  void before_marking_update_attribute_table(HeapRegion* hr);\n+  void before_marking_update_attribute_table(G1HeapRegion* hr);\n@@ -141,2 +141,2 @@\n-  inline void set_compaction_top(HeapRegion* r, HeapWord* value);\n-  inline HeapWord* compaction_top(HeapRegion* r) const;\n+  inline void set_compaction_top(G1HeapRegion* r, HeapWord* value);\n+  inline HeapWord* compaction_top(G1HeapRegion* r) const;\n@@ -147,2 +147,2 @@\n-  inline void add_humongous_region(HeapRegion* hr);\n-  inline GrowableArrayCHeap<HeapRegion*, mtGC>& humongous_compaction_regions();\n+  inline void add_humongous_region(G1HeapRegion* hr);\n+  inline GrowableArrayCHeap<G1HeapRegion*, mtGC>& humongous_compaction_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-void G1FullCollector::set_compaction_top(HeapRegion* r, HeapWord* value) {\n+void G1FullCollector::set_compaction_top(G1HeapRegion* r, HeapWord* value) {\n@@ -69,1 +69,1 @@\n-HeapWord* G1FullCollector::compaction_top(HeapRegion* r) const {\n+HeapWord* G1FullCollector::compaction_top(G1HeapRegion* r) const {\n@@ -93,1 +93,1 @@\n-void G1FullCollector::add_humongous_region(HeapRegion* hr) {\n+void G1FullCollector::add_humongous_region(G1HeapRegion* hr) {\n@@ -97,1 +97,1 @@\n-GrowableArrayCHeap<HeapRegion*, mtGC>& G1FullCollector::humongous_compaction_regions() {\n+GrowableArrayCHeap<G1HeapRegion*, mtGC>& G1FullCollector::humongous_compaction_regions() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-void G1FullGCCompactTask::compact_region(HeapRegion* hr) {\n+void G1FullGCCompactTask::compact_region(G1HeapRegion* hr) {\n@@ -90,2 +90,2 @@\n-  GrowableArray<HeapRegion*>* compaction_queue = collector()->compaction_point(worker_id)->regions();\n-  for (GrowableArrayIterator<HeapRegion*> it = compaction_queue->begin();\n+  GrowableArray<G1HeapRegion*>* compaction_queue = collector()->compaction_point(worker_id)->regions();\n+  for (GrowableArrayIterator<G1HeapRegion*> it = compaction_queue->begin();\n@@ -100,2 +100,2 @@\n-  GrowableArray<HeapRegion*>* compaction_queue = collector()->serial_compaction_point()->regions();\n-  for (GrowableArrayIterator<HeapRegion*> it = compaction_queue->begin();\n+  GrowableArray<G1HeapRegion*>* compaction_queue = collector()->serial_compaction_point()->regions();\n+  for (GrowableArrayIterator<G1HeapRegion*> it = compaction_queue->begin();\n@@ -111,1 +111,1 @@\n-  for (HeapRegion* hr : collector()->humongous_compaction_regions()) {\n+  for (G1HeapRegion* hr : collector()->humongous_compaction_regions()) {\n@@ -117,1 +117,1 @@\n-void G1FullGCCompactTask::compact_humongous_obj(HeapRegion* src_hr) {\n+void G1FullGCCompactTask::compact_humongous_obj(G1HeapRegion* src_hr) {\n@@ -149,1 +149,1 @@\n-    HeapRegion* hr = _g1h->region_at(i);\n+    G1HeapRegion* hr = _g1h->region_at(i);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-  void compact_region(HeapRegion* hr);\n-  void compact_humongous_obj(HeapRegion* hr);\n+  void compact_region(G1HeapRegion* hr);\n+  void compact_humongous_obj(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  _compaction_regions = new (mtGC) GrowableArray<HeapRegion*>(32, mtGC);\n+  _compaction_regions = new (mtGC) GrowableArray<G1HeapRegion*>(32, mtGC);\n@@ -64,1 +64,1 @@\n-void G1FullGCCompactionPoint::initialize(HeapRegion* hr) {\n+void G1FullGCCompactionPoint::initialize(G1HeapRegion* hr) {\n@@ -69,1 +69,1 @@\n-HeapRegion* G1FullGCCompactionPoint::current_region() {\n+G1HeapRegion* G1FullGCCompactionPoint::current_region() {\n@@ -73,2 +73,2 @@\n-HeapRegion* G1FullGCCompactionPoint::next_region() {\n-  HeapRegion* next = *(++_compaction_region_iterator);\n+G1HeapRegion* G1FullGCCompactionPoint::next_region() {\n+  G1HeapRegion* next = *(++_compaction_region_iterator);\n@@ -79,1 +79,1 @@\n-GrowableArray<HeapRegion*>* G1FullGCCompactionPoint::regions() {\n+GrowableArray<G1HeapRegion*>* G1FullGCCompactionPoint::regions() {\n@@ -120,1 +120,1 @@\n-void G1FullGCCompactionPoint::add(HeapRegion* hr) {\n+void G1FullGCCompactionPoint::add(G1HeapRegion* hr) {\n@@ -125,1 +125,1 @@\n-  HeapRegion* cur = current_region();\n+  G1HeapRegion* cur = current_region();\n@@ -129,1 +129,1 @@\n-  for (HeapRegion* r : *_compaction_regions) {\n+  for (G1HeapRegion* r : *_compaction_regions) {\n@@ -139,1 +139,1 @@\n-void G1FullGCCompactionPoint::add_humongous(HeapRegion* hr) {\n+void G1FullGCCompactionPoint::add_humongous(G1HeapRegion* hr) {\n@@ -146,1 +146,1 @@\n-                                     [&] (HeapRegion* r) {\n+                                     [&] (G1HeapRegion* r) {\n@@ -152,1 +152,1 @@\n-void G1FullGCCompactionPoint::forward_humongous(HeapRegion* hr) {\n+void G1FullGCCompactionPoint::forward_humongous(G1HeapRegion* hr) {\n@@ -174,1 +174,1 @@\n-  HeapRegion* dest_hr = _compaction_regions->at(range_begin);\n+  G1HeapRegion* dest_hr = _compaction_regions->at(range_begin);\n@@ -187,1 +187,1 @@\n-uint G1FullGCCompactionPoint::find_contiguous_before(HeapRegion* hr, uint num_regions) {\n+uint G1FullGCCompactionPoint::find_contiguous_before(G1HeapRegion* hr, uint num_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -39,2 +39,2 @@\n-  HeapRegion* _current_region;\n-  HeapWord*   _compaction_top;\n+  G1HeapRegion* _current_region;\n+  HeapWord* _compaction_top;\n@@ -42,2 +42,2 @@\n-  GrowableArray<HeapRegion*>* _compaction_regions;\n-  GrowableArrayIterator<HeapRegion*> _compaction_region_iterator;\n+  GrowableArray<G1HeapRegion*>* _compaction_regions;\n+  GrowableArrayIterator<G1HeapRegion*> _compaction_region_iterator;\n@@ -48,2 +48,2 @@\n-  HeapRegion* next_region();\n-  uint find_contiguous_before(HeapRegion* hr, uint num_regions);\n+  G1HeapRegion* next_region();\n+  uint find_contiguous_before(G1HeapRegion* hr, uint num_regions);\n@@ -57,1 +57,1 @@\n-  void initialize(HeapRegion* hr);\n+  void initialize(G1HeapRegion* hr);\n@@ -60,3 +60,3 @@\n-  void forward_humongous(HeapRegion* hr);\n-  void add(HeapRegion* hr);\n-  void add_humongous(HeapRegion* hr);\n+  void forward_humongous(G1HeapRegion* hr);\n+  void add(G1HeapRegion* hr);\n+  void add_humongous(G1HeapRegion* hr);\n@@ -65,1 +65,1 @@\n-  HeapRegion* current_region();\n+  G1HeapRegion* current_region();\n@@ -67,1 +67,1 @@\n-  GrowableArray<HeapRegion*>* regions();\n+  GrowableArray<G1HeapRegion*>* regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-\/\/ (1) the HeapRegion itself can not be moved during this phase of the full gc\n+\/\/ (1) the G1HeapRegion itself can not be moved during this phase of the full gc\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-bool G1FullGCPrepareTask::G1CalculatePointersClosure::do_heap_region(HeapRegion* hr) {\n+bool G1FullGCPrepareTask::G1CalculatePointersClosure::do_heap_region(G1HeapRegion* hr) {\n@@ -81,1 +81,1 @@\n-    for (GrowableArrayIterator<HeapRegion*> it = compaction_point->regions()->begin();\n+    for (GrowableArrayIterator<G1HeapRegion*> it = compaction_point->regions()->begin();\n@@ -116,1 +116,1 @@\n-void G1FullGCPrepareTask::G1CalculatePointersClosure::prepare_for_compaction(HeapRegion* hr) {\n+void G1FullGCPrepareTask::G1CalculatePointersClosure::prepare_for_compaction(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -45,1 +45,1 @@\n-  inline void free_empty_humongous_region(HeapRegion* hr);\n+  inline void free_empty_humongous_region(G1HeapRegion* hr);\n@@ -47,1 +47,1 @@\n-  inline bool should_compact(HeapRegion* hr) const;\n+  inline bool should_compact(G1HeapRegion* hr) const;\n@@ -55,1 +55,1 @@\n-  inline void add_to_compaction_queue(HeapRegion* hr);\n+  inline void add_to_compaction_queue(G1HeapRegion* hr);\n@@ -60,1 +60,1 @@\n-  inline bool do_heap_region(HeapRegion* hr) override;\n+  inline bool do_heap_region(G1HeapRegion* hr) override;\n@@ -83,1 +83,1 @@\n-    void prepare_for_compaction(HeapRegion* hr);\n+    void prepare_for_compaction(G1HeapRegion* hr);\n@@ -89,1 +89,1 @@\n-    bool do_heap_region(HeapRegion* hr);\n+    bool do_heap_region(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-void G1DetermineCompactionQueueClosure::free_empty_humongous_region(HeapRegion* hr) {\n+void G1DetermineCompactionQueueClosure::free_empty_humongous_region(G1HeapRegion* hr) {\n@@ -42,1 +42,1 @@\n-inline bool G1DetermineCompactionQueueClosure::should_compact(HeapRegion* hr) const {\n+inline bool G1DetermineCompactionQueueClosure::should_compact(G1HeapRegion* hr) const {\n@@ -64,1 +64,1 @@\n-inline void G1DetermineCompactionQueueClosure::add_to_compaction_queue(HeapRegion* hr) {\n+inline void G1DetermineCompactionQueueClosure::add_to_compaction_queue(G1HeapRegion* hr) {\n@@ -76,1 +76,1 @@\n-static bool has_pinned_objects(HeapRegion* hr) {\n+static bool has_pinned_objects(G1HeapRegion* hr) {\n@@ -81,1 +81,1 @@\n-inline bool G1DetermineCompactionQueueClosure::do_heap_region(HeapRegion* hr) {\n+inline bool G1DetermineCompactionQueueClosure::do_heap_region(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_region_metadata(HeapRegion* hr) {\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_region_metadata(G1HeapRegion* hr) {\n@@ -39,1 +39,1 @@\n-bool G1FullGCResetMetadataTask::G1ResetMetadataClosure::do_heap_region(HeapRegion* hr) {\n+bool G1FullGCResetMetadataTask::G1ResetMetadataClosure::do_heap_region(G1HeapRegion* hr) {\n@@ -57,1 +57,1 @@\n-void G1FullGCResetMetadataTask::G1ResetMetadataClosure::scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live) {\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::scrub_skip_compacting_region(G1HeapRegion* hr, bool update_bot_for_live) {\n@@ -85,1 +85,1 @@\n-void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_skip_compacting(HeapRegion* hr) {\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_skip_compacting(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    void reset_region_metadata(HeapRegion* hr);\n+    void reset_region_metadata(G1HeapRegion* hr);\n@@ -42,1 +42,1 @@\n-    void scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live);\n+    void scrub_skip_compacting_region(G1HeapRegion* hr, bool update_bot_for_live);\n@@ -44,1 +44,1 @@\n-    void reset_skip_compacting(HeapRegion* r);\n+    void reset_skip_compacting(G1HeapRegion* r);\n@@ -49,1 +49,1 @@\n-    bool do_heap_region(HeapRegion* hr);\n+    bool do_heap_region(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-                                 HeapRegion::GrainWords :\n-                                 (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) { }\n+                                 G1HeapRegion::GrainWords :\n+                                 (1 - MarkSweepDeadRatio \/ 100.0) * G1HeapRegion::GrainWords) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,5 +51,5 @@\n-uint   HeapRegion::LogOfHRGrainBytes = 0;\n-uint   HeapRegion::LogCardsPerRegion = 0;\n-size_t HeapRegion::GrainBytes        = 0;\n-size_t HeapRegion::GrainWords        = 0;\n-size_t HeapRegion::CardsPerRegion    = 0;\n+uint   G1HeapRegion::LogOfHRGrainBytes = 0;\n+uint   G1HeapRegion::LogCardsPerRegion = 0;\n+size_t G1HeapRegion::GrainBytes        = 0;\n+size_t G1HeapRegion::GrainWords        = 0;\n+size_t G1HeapRegion::CardsPerRegion    = 0;\n@@ -57,1 +57,1 @@\n-size_t HeapRegion::max_region_size() {\n+size_t G1HeapRegion::max_region_size() {\n@@ -61,1 +61,1 @@\n-size_t HeapRegion::min_region_size_in_words() {\n+size_t G1HeapRegion::min_region_size_in_words() {\n@@ -65,1 +65,1 @@\n-void HeapRegion::setup_heap_region_size(size_t max_heap_size) {\n+void G1HeapRegion::setup_heap_region_size(size_t max_heap_size) {\n@@ -101,1 +101,1 @@\n-void HeapRegion::handle_evacuation_failure(bool retain) {\n+void G1HeapRegion::handle_evacuation_failure(bool retain) {\n@@ -111,1 +111,1 @@\n-void HeapRegion::unlink_from_list() {\n+void G1HeapRegion::unlink_from_list() {\n@@ -117,1 +117,1 @@\n-void HeapRegion::hr_clear(bool clear_space) {\n+void G1HeapRegion::hr_clear(bool clear_space) {\n@@ -135,1 +135,1 @@\n-void HeapRegion::clear_cardtable() {\n+void G1HeapRegion::clear_cardtable() {\n@@ -140,1 +140,1 @@\n-double HeapRegion::calc_gc_efficiency() {\n+double G1HeapRegion::calc_gc_efficiency() {\n@@ -152,2 +152,4 @@\n-void HeapRegion::set_free() {\n-  report_region_type_change(G1HeapRegionTraceType::Free);\n+void G1HeapRegion::set_free() {\n+  if (!is_free()) {\n+    report_region_type_change(G1HeapRegionTraceType::Free);\n+  }\n@@ -157,1 +159,1 @@\n-void HeapRegion::set_eden() {\n+void G1HeapRegion::set_eden() {\n@@ -162,1 +164,1 @@\n-void HeapRegion::set_eden_pre_gc() {\n+void G1HeapRegion::set_eden_pre_gc() {\n@@ -167,1 +169,1 @@\n-void HeapRegion::set_survivor() {\n+void G1HeapRegion::set_survivor() {\n@@ -172,1 +174,2 @@\n-void HeapRegion::move_to_old() {\n+void G1HeapRegion::move_to_old() {\n+  G1HeapRegionTraceType::Type prev_trace_type = _type.get_trace_type();\n@@ -174,1 +177,1 @@\n-    report_region_type_change(G1HeapRegionTraceType::Old);\n+    report_region_type_change(prev_trace_type);\n@@ -178,1 +181,1 @@\n-void HeapRegion::set_old() {\n+void G1HeapRegion::set_old() {\n@@ -183,1 +186,1 @@\n-void HeapRegion::set_starts_humongous(HeapWord* obj_top, size_t fill_size) {\n+void G1HeapRegion::set_starts_humongous(HeapWord* obj_top, size_t fill_size) {\n@@ -197,1 +200,1 @@\n-void HeapRegion::set_continues_humongous(HeapRegion* first_hr) {\n+void G1HeapRegion::set_continues_humongous(G1HeapRegion* first_hr) {\n@@ -207,1 +210,1 @@\n-void HeapRegion::clear_humongous() {\n+void G1HeapRegion::clear_humongous() {\n@@ -210,1 +213,1 @@\n-  assert(capacity() == HeapRegion::GrainBytes, \"pre-condition\");\n+  assert(capacity() == G1HeapRegion::GrainBytes, \"pre-condition\");\n@@ -214,1 +217,1 @@\n-void HeapRegion::prepare_remset_for_scan() {\n+void G1HeapRegion::prepare_remset_for_scan() {\n@@ -218,1 +221,1 @@\n-HeapRegion::HeapRegion(uint hrm_index,\n+G1HeapRegion::G1HeapRegion(uint hrm_index,\n@@ -251,1 +254,1 @@\n-void HeapRegion::initialize(bool clear_space, bool mangle_space) {\n+void G1HeapRegion::initialize(bool clear_space, bool mangle_space) {\n@@ -263,1 +266,1 @@\n-void HeapRegion::report_region_type_change(G1HeapRegionTraceType::Type to) {\n+void G1HeapRegion::report_region_type_change(G1HeapRegionTraceType::Type to) {\n@@ -271,1 +274,1 @@\n- void HeapRegion::note_evacuation_failure() {\n+ void G1HeapRegion::note_evacuation_failure() {\n@@ -279,1 +282,1 @@\n-void HeapRegion::note_self_forward_chunk_done(size_t garbage_bytes) {\n+void G1HeapRegion::note_self_forward_chunk_done(size_t garbage_bytes) {\n@@ -284,1 +287,1 @@\n-void HeapRegion::add_code_root(nmethod* nm) {\n+void G1HeapRegion::add_code_root(nmethod* nm) {\n@@ -288,1 +291,1 @@\n-void HeapRegion::remove_code_root(nmethod* nm) {\n+void G1HeapRegion::remove_code_root(nmethod* nm) {\n@@ -292,1 +295,1 @@\n-void HeapRegion::code_roots_do(NMethodClosure* blk) const {\n+void G1HeapRegion::code_roots_do(NMethodClosure* blk) const {\n@@ -297,1 +300,1 @@\n-  const HeapRegion* _hr;\n+  const G1HeapRegion* _hr;\n@@ -324,1 +327,1 @@\n-  VerifyCodeRootOopClosure(const HeapRegion* hr):\n+  VerifyCodeRootOopClosure(const G1HeapRegion* hr):\n@@ -335,1 +338,1 @@\n-  const HeapRegion* _hr;\n+  const G1HeapRegion* _hr;\n@@ -338,1 +341,1 @@\n-  VerifyCodeRootNMethodClosure(const HeapRegion* hr) :\n+  VerifyCodeRootNMethodClosure(const G1HeapRegion* hr) :\n@@ -361,1 +364,1 @@\n-bool HeapRegion::verify_code_roots(VerifyOption vo) const {\n+bool G1HeapRegion::verify_code_roots(VerifyOption vo) const {\n@@ -406,1 +409,1 @@\n-void HeapRegion::print() const { print_on(tty); }\n+void G1HeapRegion::print() const { print_on(tty); }\n@@ -408,1 +411,1 @@\n-void HeapRegion::print_on(outputStream* st) const {\n+void G1HeapRegion::print_on(outputStream* st) const {\n@@ -522,1 +525,1 @@\n-    void print_containing_obj(outputStream* out, HeapRegion* from) {\n+    void print_containing_obj(outputStream* out, G1HeapRegion* from) {\n@@ -528,1 +531,1 @@\n-    void print_referenced_obj(outputStream* out, HeapRegion* to, const char* explanation) {\n+    void print_referenced_obj(outputStream* out, G1HeapRegion* to, const char* explanation) {\n@@ -561,1 +564,1 @@\n-      HeapRegion* from = this->_g1h->heap_region_containing(this->_p);\n+      G1HeapRegion* from = this->_g1h->heap_region_containing(this->_p);\n@@ -567,1 +570,1 @@\n-        HeapRegion* to = this->_g1h->heap_region_containing(this->_obj);\n+        G1HeapRegion* to = this->_g1h->heap_region_containing(this->_obj);\n@@ -578,2 +581,2 @@\n-    HeapRegion* _from;\n-    HeapRegion* _to;\n+    G1HeapRegion* _from;\n+    G1HeapRegion* _to;\n@@ -661,1 +664,1 @@\n-bool HeapRegion::verify_liveness_and_remset(VerifyOption vo) const {\n+bool G1HeapRegion::verify_liveness_and_remset(VerifyOption vo) const {\n@@ -694,1 +697,1 @@\n-bool HeapRegion::verify(VerifyOption vo) const {\n+bool G1HeapRegion::verify(VerifyOption vo) const {\n@@ -713,1 +716,1 @@\n-void HeapRegion::clear(bool mangle_space) {\n+void G1HeapRegion::clear(bool mangle_space) {\n@@ -722,1 +725,1 @@\n-void HeapRegion::mangle_unused_area() {\n+void G1HeapRegion::mangle_unused_area() {\n@@ -727,1 +730,1 @@\n-void HeapRegion::object_iterate(ObjectClosure* blk) {\n+void G1HeapRegion::object_iterate(ObjectClosure* blk) {\n@@ -737,1 +740,1 @@\n-void HeapRegion::fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap) {\n+void G1HeapRegion::fill_with_dummy_object(HeapWord* address, size_t word_size, bool zap) {\n@@ -746,1 +749,1 @@\n-void HeapRegion::fill_range_with_dead_objects(HeapWord* start, HeapWord* end) {\n+void G1HeapRegion::fill_range_with_dead_objects(HeapWord* start, HeapWord* end) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":57,"deletions":54,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -57,1 +57,1 @@\n-\/\/ A HeapRegion is the smallest piece of a G1CollectedHeap that\n+\/\/ A G1HeapRegion is the smallest piece of a G1CollectedHeap that\n@@ -69,1 +69,1 @@\n-class HeapRegion : public CHeapObj<mtGC> {\n+class G1HeapRegion : public CHeapObj<mtGC> {\n@@ -133,1 +133,1 @@\n-  \/\/ This version assumes that all allocation requests to this HeapRegion are properly\n+  \/\/ This version assumes that all allocation requests to this G1HeapRegion are properly\n@@ -136,1 +136,1 @@\n-  \/\/ Try to allocate at least min_word_size and up to desired_size from this HeapRegion.\n+  \/\/ Try to allocate at least min_word_size and up to desired_size from this G1HeapRegion.\n@@ -180,1 +180,1 @@\n-  \/\/ All allocated blocks are occupied by objects in a HeapRegion.\n+  \/\/ All allocated blocks are occupied by objects in a G1HeapRegion.\n@@ -185,1 +185,1 @@\n-  \/\/ current value of this HeapRegion.\n+  \/\/ current value of this G1HeapRegion.\n@@ -208,1 +208,1 @@\n-  HeapRegion* _humongous_start_region;\n+  G1HeapRegion* _humongous_start_region;\n@@ -217,2 +217,2 @@\n-  HeapRegion* _next;\n-  HeapRegion* _prev;\n+  G1HeapRegion* _next;\n+  G1HeapRegion* _prev;\n@@ -276,1 +276,1 @@\n-  HeapRegion(uint hrm_index,\n+  G1HeapRegion(uint hrm_index,\n@@ -285,1 +285,1 @@\n-  \/\/ Initializing the HeapRegion not only resets the data structure, but also\n+  \/\/ Initializing the G1HeapRegion not only resets the data structure, but also\n@@ -403,1 +403,1 @@\n-  HeapRegion* humongous_start_region() const {\n+  G1HeapRegion* humongous_start_region() const {\n@@ -418,1 +418,1 @@\n-  void set_continues_humongous(HeapRegion* first_hr);\n+  void set_continues_humongous(G1HeapRegion* first_hr);\n@@ -437,2 +437,2 @@\n-  void set_next(HeapRegion* next) { _next = next; }\n-  HeapRegion* next()              { return _next; }\n+  void set_next(G1HeapRegion* next) { _next = next; }\n+  G1HeapRegion* next()              { return _next; }\n@@ -440,2 +440,2 @@\n-  void set_prev(HeapRegion* prev) { _prev = prev; }\n-  HeapRegion* prev()              { return _prev; }\n+  void set_prev(G1HeapRegion* prev) { _prev = prev; }\n+  G1HeapRegion* prev()              { return _prev; }\n@@ -469,2 +469,2 @@\n-  \/\/ Reset the HeapRegion to default values and clear its remembered set.\n-  \/\/ If clear_space is true, clear the HeapRegion's memory.\n+  \/\/ Reset the G1HeapRegion to default values and clear its remembered set.\n+  \/\/ If clear_space is true, clear the G1HeapRegion's memory.\n@@ -571,1 +571,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) = 0;\n+  virtual bool do_heap_region(G1HeapRegion* r) = 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-inline HeapWord* HeapRegion::allocate_impl(size_t min_word_size,\n+inline HeapWord* G1HeapRegion::allocate_impl(size_t min_word_size,\n@@ -62,1 +62,1 @@\n-inline HeapWord* HeapRegion::par_allocate_impl(size_t min_word_size,\n+inline HeapWord* G1HeapRegion::par_allocate_impl(size_t min_word_size,\n@@ -86,1 +86,1 @@\n-inline HeapWord* HeapRegion::block_start(const void* addr) const {\n+inline HeapWord* G1HeapRegion::block_start(const void* addr) const {\n@@ -90,1 +90,1 @@\n-inline HeapWord* HeapRegion::advance_to_block_containing_addr(const void* addr,\n+inline HeapWord* G1HeapRegion::advance_to_block_containing_addr(const void* addr,\n@@ -107,1 +107,1 @@\n-inline HeapWord* HeapRegion::block_start(const void* addr, HeapWord* const pb) const {\n+inline HeapWord* G1HeapRegion::block_start(const void* addr, HeapWord* const pb) const {\n@@ -113,1 +113,1 @@\n-inline bool HeapRegion::is_in_parsable_area(const void* const addr) const {\n+inline bool G1HeapRegion::is_in_parsable_area(const void* const addr) const {\n@@ -117,1 +117,1 @@\n-inline bool HeapRegion::is_in_parsable_area(const void* const addr, const void* const pb) {\n+inline bool G1HeapRegion::is_in_parsable_area(const void* const addr, const void* const pb) {\n@@ -121,1 +121,1 @@\n-inline bool HeapRegion::is_marked_in_bitmap(oop obj) const {\n+inline bool G1HeapRegion::is_marked_in_bitmap(oop obj) const {\n@@ -125,1 +125,1 @@\n-inline bool HeapRegion::block_is_obj(const HeapWord* const p, HeapWord* const pb) const {\n+inline bool G1HeapRegion::block_is_obj(const HeapWord* const p, HeapWord* const pb) const {\n@@ -144,1 +144,1 @@\n-inline HeapWord* HeapRegion::next_live_in_unparsable(G1CMBitMap* const bitmap, const HeapWord* p, HeapWord* const limit) const {\n+inline HeapWord* G1HeapRegion::next_live_in_unparsable(G1CMBitMap* const bitmap, const HeapWord* p, HeapWord* const limit) const {\n@@ -148,1 +148,1 @@\n-inline HeapWord* HeapRegion::next_live_in_unparsable(const HeapWord* p, HeapWord* const limit) const {\n+inline HeapWord* G1HeapRegion::next_live_in_unparsable(const HeapWord* p, HeapWord* const limit) const {\n@@ -153,1 +153,1 @@\n-inline bool HeapRegion::is_collection_set_candidate() const {\n+inline bool G1HeapRegion::is_collection_set_candidate() const {\n@@ -157,1 +157,1 @@\n-inline size_t HeapRegion::block_size(const HeapWord* p) const {\n+inline size_t G1HeapRegion::block_size(const HeapWord* p) const {\n@@ -161,1 +161,1 @@\n-inline size_t HeapRegion::block_size(const HeapWord* p, HeapWord* const pb) const {\n+inline size_t G1HeapRegion::block_size(const HeapWord* p, HeapWord* const pb) const {\n@@ -171,1 +171,1 @@\n-inline void HeapRegion::prepare_for_full_gc() {\n+inline void G1HeapRegion::prepare_for_full_gc() {\n@@ -178,1 +178,1 @@\n-inline void HeapRegion::reset_compacted_after_full_gc(HeapWord* new_top) {\n+inline void G1HeapRegion::reset_compacted_after_full_gc(HeapWord* new_top) {\n@@ -184,1 +184,1 @@\n-inline void HeapRegion::reset_skip_compacting_after_full_gc() {\n+inline void G1HeapRegion::reset_skip_compacting_after_full_gc() {\n@@ -190,1 +190,1 @@\n-inline void HeapRegion::reset_after_full_gc_common() {\n+inline void G1HeapRegion::reset_after_full_gc_common() {\n@@ -207,1 +207,1 @@\n-inline void HeapRegion::apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure) {\n+inline void G1HeapRegion::apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure) {\n@@ -227,1 +227,1 @@\n-inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,\n+inline HeapWord* G1HeapRegion::par_allocate(size_t min_word_size,\n@@ -233,1 +233,1 @@\n-inline HeapWord* HeapRegion::allocate(size_t word_size) {\n+inline HeapWord* G1HeapRegion::allocate(size_t word_size) {\n@@ -238,1 +238,1 @@\n-inline HeapWord* HeapRegion::allocate(size_t min_word_size,\n+inline HeapWord* G1HeapRegion::allocate(size_t min_word_size,\n@@ -244,1 +244,1 @@\n-inline void HeapRegion::update_bot() {\n+inline void G1HeapRegion::update_bot() {\n@@ -256,1 +256,1 @@\n-inline void HeapRegion::update_bot_for_block(HeapWord* start, HeapWord* end) {\n+inline void G1HeapRegion::update_bot_for_block(HeapWord* start, HeapWord* end) {\n@@ -265,1 +265,1 @@\n-inline HeapWord* HeapRegion::parsable_bottom() const {\n+inline HeapWord* G1HeapRegion::parsable_bottom() const {\n@@ -270,1 +270,1 @@\n-inline HeapWord* HeapRegion::parsable_bottom_acquire() const {\n+inline HeapWord* G1HeapRegion::parsable_bottom_acquire() const {\n@@ -274,1 +274,1 @@\n-inline void HeapRegion::reset_parsable_bottom() {\n+inline void G1HeapRegion::reset_parsable_bottom() {\n@@ -278,1 +278,1 @@\n-inline void HeapRegion::note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes) {\n+inline void G1HeapRegion::note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes) {\n@@ -290,1 +290,1 @@\n-inline void HeapRegion::note_end_of_scrubbing() {\n+inline void G1HeapRegion::note_end_of_scrubbing() {\n@@ -294,1 +294,1 @@\n-inline bool HeapRegion::needs_scrubbing() const {\n+inline bool G1HeapRegion::needs_scrubbing() const {\n@@ -298,1 +298,1 @@\n-inline bool HeapRegion::in_collection_set() const {\n+inline bool G1HeapRegion::in_collection_set() const {\n@@ -303,1 +303,1 @@\n-HeapWord* HeapRegion::do_oops_on_memregion_in_humongous(MemRegion mr,\n+HeapWord* G1HeapRegion::do_oops_on_memregion_in_humongous(MemRegion mr,\n@@ -306,1 +306,1 @@\n-  HeapRegion* sr = humongous_start_region();\n+  G1HeapRegion* sr = humongous_start_region();\n@@ -345,1 +345,1 @@\n-inline HeapWord* HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl) {\n+inline HeapWord* G1HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl) {\n@@ -390,1 +390,1 @@\n-inline HeapWord* HeapRegion::oops_on_memregion_iterate(MemRegion mr, Closure* cl) {\n+inline HeapWord* G1HeapRegion::oops_on_memregion_iterate(MemRegion mr, Closure* cl) {\n@@ -454,1 +454,1 @@\n-HeapWord* HeapRegion::oops_on_memregion_seq_iterate_careful(MemRegion mr,\n+HeapWord* G1HeapRegion::oops_on_memregion_seq_iterate_careful(MemRegion mr,\n@@ -475,1 +475,1 @@\n-inline uint HeapRegion::age_in_surv_rate_group() const {\n+inline uint G1HeapRegion::age_in_surv_rate_group() const {\n@@ -481,1 +481,1 @@\n-inline bool HeapRegion::has_valid_age_in_surv_rate() const {\n+inline bool G1HeapRegion::has_valid_age_in_surv_rate() const {\n@@ -485,1 +485,1 @@\n-inline bool HeapRegion::has_surv_rate_group() const {\n+inline bool G1HeapRegion::has_surv_rate_group() const {\n@@ -489,1 +489,1 @@\n-inline double HeapRegion::surv_rate_prediction(G1Predictions const& predictor) const {\n+inline double G1HeapRegion::surv_rate_prediction(G1Predictions const& predictor) const {\n@@ -494,1 +494,1 @@\n-inline void HeapRegion::install_surv_rate_group(G1SurvRateGroup* surv_rate_group) {\n+inline void G1HeapRegion::install_surv_rate_group(G1SurvRateGroup* surv_rate_group) {\n@@ -503,1 +503,1 @@\n-inline void HeapRegion::uninstall_surv_rate_group() {\n+inline void G1HeapRegion::uninstall_surv_rate_group() {\n@@ -515,1 +515,1 @@\n-inline void HeapRegion::record_surv_words_in_group(size_t words_survived) {\n+inline void G1HeapRegion::record_surv_words_in_group(size_t words_survived) {\n@@ -520,1 +520,1 @@\n-inline void HeapRegion::add_pinned_object_count(size_t value) {\n+inline void G1HeapRegion::add_pinned_object_count(size_t value) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-\/\/ in a HeapRegion, but only to what is interesting for the current young collection.\n+\/\/ in a G1HeapRegion, but only to what is interesting for the current young collection.\n@@ -183,1 +183,1 @@\n-  bool is_in_cset(const HeapRegion* hr) const { return get_by_index(hr->hrm_index()).is_in_cset(); }\n+  bool is_in_cset(const G1HeapRegion* hr) const { return get_by_index(hr->hrm_index()).is_in_cset(); }\n@@ -186,1 +186,1 @@\n-  void clear(const HeapRegion* hr) { return set_by_index(hr->hrm_index(), G1HeapRegionAttr(G1HeapRegionAttr::NotInCSet)); }\n+  void clear(const G1HeapRegion* hr) { return set_by_index(hr->hrm_index(), G1HeapRegionAttr(G1HeapRegionAttr::NotInCSet)); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionEventSender.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  bool is_correct_type(HeapRegion* hr) { return hr->is_free(); }\n+  bool is_correct_type(G1HeapRegion* hr) { return hr->is_free(); }\n@@ -88,1 +88,1 @@\n-  _regions.initialize(heap_storage->reserved(), HeapRegion::GrainBytes);\n+  _regions.initialize(heap_storage->reserved(), G1HeapRegion::GrainBytes);\n@@ -93,2 +93,2 @@\n-HeapRegion* HeapRegionManager::allocate_free_region(HeapRegionType type, uint requested_node_index) {\n-  HeapRegion* hr = nullptr;\n+G1HeapRegion* HeapRegionManager::allocate_free_region(HeapRegionType type, uint requested_node_index) {\n+  G1HeapRegion* hr = nullptr;\n@@ -121,1 +121,1 @@\n-HeapRegion* HeapRegionManager::allocate_humongous_from_free_list(uint num_regions) {\n+G1HeapRegion* HeapRegionManager::allocate_humongous_from_free_list(uint num_regions) {\n@@ -129,1 +129,1 @@\n-HeapRegion* HeapRegionManager::allocate_humongous_allow_expand(uint num_regions) {\n+G1HeapRegion* HeapRegionManager::allocate_humongous_allow_expand(uint num_regions) {\n@@ -138,1 +138,1 @@\n-HeapRegion* HeapRegionManager::allocate_humongous(uint num_regions) {\n+G1HeapRegion* HeapRegionManager::allocate_humongous(uint num_regions) {\n@@ -146,1 +146,1 @@\n-HeapRegion* HeapRegionManager::expand_and_allocate_humongous(uint num_regions) {\n+G1HeapRegion* HeapRegionManager::expand_and_allocate_humongous(uint num_regions) {\n@@ -151,1 +151,1 @@\n-bool HeapRegionManager::is_free(HeapRegion* hr) const {\n+bool HeapRegionManager::is_free(G1HeapRegion* hr) const {\n@@ -156,1 +156,1 @@\n-HeapRegion* HeapRegionManager::new_heap_region(uint hrm_index) {\n+G1HeapRegion* HeapRegionManager::new_heap_region(uint hrm_index) {\n@@ -159,1 +159,1 @@\n-  MemRegion mr(bottom, bottom + HeapRegion::GrainWords);\n+  MemRegion mr(bottom, bottom + G1HeapRegion::GrainWords);\n@@ -167,1 +167,1 @@\n-    HeapRegion* hr = _regions.get_by_index(i);\n+    G1HeapRegion* hr = _regions.get_by_index(i);\n@@ -200,1 +200,1 @@\n-      HeapRegion* hr = _regions.get_by_index(i);\n+      G1HeapRegion* hr = _regions.get_by_index(i);\n@@ -221,1 +221,1 @@\n-    HeapRegion* hr = at(i);\n+    G1HeapRegion* hr = at(i);\n@@ -251,1 +251,1 @@\n-    HeapRegion* hr = at(i);\n+    G1HeapRegion* hr = at(i);\n@@ -433,1 +433,1 @@\n-    HeapRegion* hr = _regions.get_by_index(i);\n+    G1HeapRegion* hr = _regions.get_by_index(i);\n@@ -489,1 +489,1 @@\n-HeapRegion* HeapRegionManager::next_region_in_heap(const HeapRegion* r) const {\n+G1HeapRegion* HeapRegionManager::next_region_in_heap(const G1HeapRegion* r) const {\n@@ -493,1 +493,1 @@\n-    HeapRegion* hr = _regions.get_by_index(i);\n+    G1HeapRegion* hr = _regions.get_by_index(i);\n@@ -508,1 +508,1 @@\n-    guarantee(at(i) != nullptr, \"Tried to access region %u that has a null HeapRegion*\", i);\n+    guarantee(at(i) != nullptr, \"Tried to access region %u that has a null G1HeapRegion*\", i);\n@@ -537,1 +537,1 @@\n-    HeapRegion *hr = _regions.get_by_index(curr);\n+    G1HeapRegion* hr = _regions.get_by_index(curr);\n@@ -566,1 +566,1 @@\n-    HeapRegion* curr_region  = _regions.get_by_index(curr_index);\n+    G1HeapRegion* curr_region  = _regions.get_by_index(curr_index);\n@@ -590,1 +590,1 @@\n-    HeapRegion* r = _regions.get_by_index(index);\n+    G1HeapRegion* r = _regions.get_by_index(index);\n@@ -702,1 +702,1 @@\n-    HeapRegion* hr = _regions.get_by_index(i);\n+    G1HeapRegion* hr = _regions.get_by_index(i);\n@@ -803,1 +803,1 @@\n-    FreeRegionList *free_list = worker_freelist(worker_id);\n+    FreeRegionList* free_list = worker_freelist(worker_id);\n@@ -805,1 +805,1 @@\n-      HeapRegion *region = _hrm->at_or_null(i);\n+      G1HeapRegion* region = _hrm->at_or_null(i);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -41,1 +41,1 @@\n-class G1HeapRegionTable : public G1BiasedMappedArray<HeapRegion*> {\n+class G1HeapRegionTable : public G1BiasedMappedArray<G1HeapRegion*> {\n@@ -43,1 +43,1 @@\n-  virtual HeapRegion* default_value() const { return nullptr; }\n+  virtual G1HeapRegion* default_value() const { return nullptr; }\n@@ -47,1 +47,1 @@\n-\/\/ and its metadata (i.e., HeapRegion instances) and the list of free regions.\n+\/\/ and its metadata (i.e., G1HeapRegion instances) and the list of free regions.\n@@ -58,1 +58,1 @@\n-\/\/ We create a HeapRegion when we commit the region's address space\n+\/\/ We create a G1HeapRegion when we commit the region's address space\n@@ -60,1 +60,1 @@\n-\/\/ region we retain the HeapRegion to be able to re-use it in the\n+\/\/ region we retain the G1HeapRegion to be able to re-use it in the\n@@ -84,1 +84,1 @@\n-  \/\/ Internal only. The highest heap region +1 we allocated a HeapRegion instance for.\n+  \/\/ Internal only. The highest heap region +1 we allocated a G1HeapRegion instance for.\n@@ -140,2 +140,2 @@\n-  \/\/ Allocate a new HeapRegion for the given index.\n-  HeapRegion* new_heap_region(uint hrm_index);\n+  \/\/ Allocate a new G1HeapRegion for the given index.\n+  G1HeapRegion* new_heap_region(uint hrm_index);\n@@ -144,2 +144,2 @@\n-  HeapRegion* allocate_humongous_from_free_list(uint num_regions);\n-  HeapRegion* allocate_humongous_allow_expand(uint num_regions);\n+  G1HeapRegion* allocate_humongous_from_free_list(uint num_regions);\n+  G1HeapRegion* allocate_humongous_allow_expand(uint num_regions);\n@@ -156,1 +156,1 @@\n-  bool is_free(HeapRegion* hr) const;\n+  bool is_free(G1HeapRegion* hr) const;\n@@ -168,1 +168,1 @@\n-  \/\/ new HeapRegion that owns HeapRegion at index 0. Since at the moment we commit\n+  \/\/ new G1HeapRegion that owns G1HeapRegion at index 0. Since at the moment we commit\n@@ -171,1 +171,1 @@\n-  HeapRegion* get_dummy_region() { return new_heap_region(0); }\n+  G1HeapRegion* get_dummy_region() { return new_heap_region(0); }\n@@ -173,1 +173,1 @@\n-  \/\/ Return the HeapRegion at the given index. Assume that the index\n+  \/\/ Return the G1HeapRegion at the given index. Assume that the index\n@@ -175,1 +175,1 @@\n-  inline HeapRegion* at(uint index) const;\n+  inline G1HeapRegion* at(uint index) const;\n@@ -177,1 +177,1 @@\n-  \/\/ Return the HeapRegion at the given index, null if the index\n+  \/\/ Return the G1HeapRegion at the given index, null if the index\n@@ -179,1 +179,1 @@\n-  inline HeapRegion* at_or_null(uint index) const;\n+  inline G1HeapRegion* at_or_null(uint index) const;\n@@ -186,1 +186,1 @@\n-  inline HeapRegion* next_region_in_humongous(HeapRegion* hr) const;\n+  inline G1HeapRegion* next_region_in_humongous(G1HeapRegion* hr) const;\n@@ -189,2 +189,2 @@\n-  \/\/ HeapRegion, otherwise return null.\n-  inline HeapRegion* addr_to_region(HeapWord* addr) const;\n+  \/\/ G1HeapRegion, otherwise return null.\n+  inline G1HeapRegion* addr_to_region(HeapWord* addr) const;\n@@ -193,1 +193,1 @@\n-  inline void insert_into_free_list(HeapRegion* hr);\n+  inline void insert_into_free_list(G1HeapRegion* hr);\n@@ -204,1 +204,1 @@\n-  HeapRegion* allocate_free_region(HeapRegionType type, uint requested_node_index);\n+  G1HeapRegion* allocate_free_region(HeapRegionType type, uint requested_node_index);\n@@ -207,1 +207,1 @@\n-  HeapRegion* allocate_humongous(uint num_regions);\n+  G1HeapRegion* allocate_humongous(uint num_regions);\n@@ -210,1 +210,1 @@\n-  HeapRegion* expand_and_allocate_humongous(uint num_regions);\n+  G1HeapRegion* expand_and_allocate_humongous(uint num_regions);\n@@ -212,1 +212,1 @@\n-  inline HeapRegion* allocate_free_regions_starting_at(uint first, uint num_regions);\n+  inline G1HeapRegion* allocate_free_regions_starting_at(uint first, uint num_regions);\n@@ -229,1 +229,1 @@\n-    return num_free_regions() * HeapRegion::GrainBytes;\n+    return num_free_regions() * G1HeapRegion::GrainBytes;\n@@ -250,1 +250,1 @@\n-  \/\/ sequence was expanded by. If a HeapRegion allocation fails, the resulting\n+  \/\/ sequence was expanded by. If a G1HeapRegion allocation fails, the resulting\n@@ -257,1 +257,1 @@\n-  HeapRegion* next_region_in_heap(const HeapRegion* r) const;\n+  G1HeapRegion* next_region_in_heap(const G1HeapRegion* r) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-inline HeapRegion* HeapRegionManager::addr_to_region(HeapWord* addr) const {\n+inline G1HeapRegion* HeapRegionManager::addr_to_region(HeapWord* addr) const {\n@@ -46,1 +46,1 @@\n-inline HeapRegion* HeapRegionManager::at(uint index) const {\n+inline G1HeapRegion* HeapRegionManager::at(uint index) const {\n@@ -48,1 +48,1 @@\n-  HeapRegion* hr = _regions.get_by_index(index);\n+  G1HeapRegion* hr = _regions.get_by_index(index);\n@@ -54,1 +54,1 @@\n-inline HeapRegion* HeapRegionManager::at_or_null(uint index) const {\n+inline G1HeapRegion* HeapRegionManager::at_or_null(uint index) const {\n@@ -58,2 +58,2 @@\n-  HeapRegion* hr = _regions.get_by_index(index);\n-  assert(hr != nullptr, \"All available regions must have a HeapRegion but index %u has not.\", index);\n+  G1HeapRegion* hr = _regions.get_by_index(index);\n+  assert(hr != nullptr, \"All available regions must have a G1HeapRegion but index %u has not.\", index);\n@@ -64,1 +64,1 @@\n-inline HeapRegion* HeapRegionManager::next_region_in_humongous(HeapRegion* hr) const {\n+inline G1HeapRegion* HeapRegionManager::next_region_in_humongous(G1HeapRegion* hr) const {\n@@ -76,1 +76,1 @@\n-inline void HeapRegionManager::insert_into_free_list(HeapRegion* hr) {\n+inline void HeapRegionManager::insert_into_free_list(G1HeapRegion* hr) {\n@@ -80,2 +80,2 @@\n-inline HeapRegion* HeapRegionManager::allocate_free_regions_starting_at(uint first, uint num_regions) {\n-  HeapRegion* start = at(first);\n+inline G1HeapRegion* HeapRegionManager::allocate_free_regions_starting_at(uint first, uint num_regions) {\n+  G1HeapRegion* start = at(first);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.inline.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n-#include \"gc\/g1\/g1HeapRegionSet.hpp\"\n-\n-void G1HeapRegionPrinter::mark_reclaim(FreeRegionList* cleanup_list) {\n-  if (is_active()) {\n-    FreeRegionListIterator iter(cleanup_list);\n-    while (iter.more_available()) {\n-      HeapRegion* hr = iter.get_next();\n-      mark_reclaim(hr);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -37,1 +37,1 @@\n-  static void print(const char* action, HeapRegion* hr) {\n+  static void print(const char* action, G1HeapRegion* hr) {\n@@ -42,4 +42,0 @@\n-  static void mark_reclaim(HeapRegion* hr) {\n-    print(\"MARK-RECLAIM\", hr);\n-  }\n-\n@@ -54,1 +50,1 @@\n-  static void alloc(HeapRegion* hr)                     { print(\"ALLOC\", hr); }\n+  static void alloc(G1HeapRegion* hr)                     { print(\"ALLOC\", hr); }\n@@ -56,1 +52,1 @@\n-  static void retire(HeapRegion* hr)                    { print(\"RETIRE\", hr); }\n+  static void retire(G1HeapRegion* hr)                    { print(\"RETIRE\", hr); }\n@@ -58,1 +54,1 @@\n-  static void reuse(HeapRegion* hr)                     { print(\"REUSE\", hr); }\n+  static void reuse(G1HeapRegion* hr)                     { print(\"REUSE\", hr); }\n@@ -60,1 +56,1 @@\n-  static void cset(HeapRegion* hr)                      { print(\"CSET\", hr); }\n+  static void cset(G1HeapRegion* hr)                      { print(\"CSET\", hr); }\n@@ -62,1 +58,1 @@\n-  static void evac_failure(HeapRegion* hr)              { print(\"EVAC-FAILURE\", hr); }\n+  static void evac_failure(G1HeapRegion* hr)              { print(\"EVAC-FAILURE\", hr); }\n@@ -64,1 +60,1 @@\n-  static void mark_reclaim(FreeRegionList* free_list);\n+  static void mark_reclaim(G1HeapRegion* hr)              { print(\"MARK-RECLAIM\", hr); }\n@@ -66,1 +62,1 @@\n-  static void eager_reclaim(HeapRegion* hr)             { print(\"EAGER-RECLAIM\", hr); }\n+  static void eager_reclaim(G1HeapRegion* hr)             { print(\"EAGER-RECLAIM\", hr); }\n@@ -68,1 +64,1 @@\n-  static void evac_reclaim(HeapRegion* hr)              { print(\"EVAC-RECLAIM\", hr); }\n+  static void evac_reclaim(G1HeapRegion* hr)              { print(\"EVAC-RECLAIM\", hr); }\n@@ -70,1 +66,1 @@\n-  static void post_compaction(HeapRegion* hr)           { print(\"POST-COMPACTION\", hr); }\n+  static void post_compaction(G1HeapRegion* hr)           { print(\"POST-COMPACTION\", hr); }\n@@ -72,1 +68,1 @@\n-  static void commit(HeapRegion* hr)                    { print(\"COMMIT\", hr); }\n+  static void commit(G1HeapRegion* hr)                    { print(\"COMMIT\", hr); }\n@@ -74,1 +70,1 @@\n-  static void active(HeapRegion* hr)                    { print(\"ACTIVE\", hr); }\n+  static void active(G1HeapRegion* hr)                    { print(\"ACTIVE\", hr); }\n@@ -76,1 +72,1 @@\n-  static void inactive(HeapRegion* hr)                  { print(\"INACTIVE\", hr); }\n+  static void inactive(G1HeapRegion* hr)                  { print(\"INACTIVE\", hr); }\n@@ -78,1 +74,1 @@\n-  static void uncommit(HeapRegion* hr)                  { print(\"UNCOMMIT\", hr); }\n+  static void uncommit(G1HeapRegion* hr)                  { print(\"UNCOMMIT\", hr); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.hpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-HeapRegionRemSet::HeapRegionRemSet(HeapRegion* hr,\n+HeapRegionRemSet::HeapRegionRemSet(G1HeapRegion* hr,\n@@ -126,1 +126,1 @@\n-void HeapRegionRemSet::clean_code_roots(HeapRegion* hr) {\n+void HeapRegionRemSet::clean_code_roots(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  HeapRegion* _hr;\n+  G1HeapRegion* _hr;\n@@ -60,1 +60,1 @@\n-  HeapRegionRemSet(HeapRegion* hr, G1CardSetConfiguration* config);\n+  HeapRegionRemSet(G1HeapRegion* hr, G1CardSetConfiguration* config);\n@@ -158,1 +158,1 @@\n-  void clean_code_roots(HeapRegion* hr);\n+  void clean_code_roots(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-void HeapRegionSetBase::verify_region(HeapRegion* hr) {\n+void HeapRegionSetBase::verify_region(G1HeapRegion* hr) {\n@@ -102,1 +102,1 @@\n-  HeapRegion* curr = _head;\n+  G1HeapRegion* curr = _head;\n@@ -106,1 +106,1 @@\n-    HeapRegion* next = curr->next();\n+    G1HeapRegion* next = curr->next();\n@@ -137,1 +137,1 @@\n-    HeapRegion* hr = iter.get_next();\n+    G1HeapRegion* hr = iter.get_next();\n@@ -192,2 +192,2 @@\n-    HeapRegion* curr_to = _head;\n-    HeapRegion* curr_from = from_list->_head;\n+    G1HeapRegion* curr_to = _head;\n+    G1HeapRegion* curr_from = from_list->_head;\n@@ -206,1 +206,1 @@\n-        HeapRegion* next_from = curr_from->next();\n+        G1HeapRegion* next_from = curr_from->next();\n@@ -230,1 +230,1 @@\n-void FreeRegionList::verify_region_to_remove(HeapRegion* curr, HeapRegion* next) {\n+void FreeRegionList::verify_region_to_remove(G1HeapRegion* curr, G1HeapRegion* next) {\n@@ -238,1 +238,1 @@\n-  HeapRegion* prev = curr->prev();\n+  G1HeapRegion* prev = curr->prev();\n@@ -247,1 +247,1 @@\n-void FreeRegionList::remove_starting_at(HeapRegion* first, uint num_regions) {\n+void FreeRegionList::remove_starting_at(G1HeapRegion* first, uint num_regions) {\n@@ -257,1 +257,1 @@\n-  HeapRegion* const prev = first->prev();\n+  G1HeapRegion* const prev = first->prev();\n@@ -261,1 +261,1 @@\n-  HeapRegion* next = first->next();\n+  G1HeapRegion* next = first->next();\n@@ -263,1 +263,1 @@\n-  HeapRegion* curr = first;\n+  G1HeapRegion* curr = first;\n@@ -332,3 +332,3 @@\n-  HeapRegion* curr = _head;\n-  HeapRegion* prev1 = nullptr;\n-  HeapRegion* prev0 = nullptr;\n+  G1HeapRegion* curr = _head;\n+  G1HeapRegion* prev1 = nullptr;\n+  G1HeapRegion* prev0 = nullptr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-  \/\/ Returns true if the given HeapRegion is of the correct type for this HeapRegionSet.\n-  virtual bool is_correct_type(HeapRegion* hr) = 0;\n+  \/\/ Returns true if the given G1HeapRegion is of the correct type for this HeapRegionSet.\n+  virtual bool is_correct_type(G1HeapRegion* hr) = 0;\n@@ -82,1 +82,1 @@\n-  void verify_region(HeapRegion* hr) PRODUCT_RETURN;\n+  void verify_region(G1HeapRegion* hr) PRODUCT_RETURN;\n@@ -101,1 +101,1 @@\n-  inline void add(HeapRegion* hr);\n+  inline void add(G1HeapRegion* hr);\n@@ -105,1 +105,1 @@\n-  inline void remove(HeapRegion* hr);\n+  inline void remove(G1HeapRegion* hr);\n@@ -109,1 +109,1 @@\n-  void verify_next_region(HeapRegion* hr);\n+  void verify_next_region(G1HeapRegion* hr);\n@@ -166,2 +166,2 @@\n-  HeapRegion* _head;\n-  HeapRegion* _tail;\n+  G1HeapRegion* _head;\n+  G1HeapRegion* _tail;\n@@ -171,1 +171,1 @@\n-  HeapRegion* _last;\n+  G1HeapRegion* _last;\n@@ -177,2 +177,2 @@\n-  inline HeapRegion* remove_from_head_impl();\n-  inline HeapRegion* remove_from_tail_impl();\n+  inline G1HeapRegion* remove_from_head_impl();\n+  inline G1HeapRegion* remove_from_tail_impl();\n@@ -187,1 +187,1 @@\n-  void verify_region_to_remove(HeapRegion* curr, HeapRegion* next) NOT_DEBUG_RETURN;\n+  void verify_region_to_remove(G1HeapRegion* curr, G1HeapRegion* next) NOT_DEBUG_RETURN;\n@@ -199,1 +199,1 @@\n-  bool contains(HeapRegion* hr) const {\n+  bool contains(G1HeapRegion* hr) const {\n@@ -209,1 +209,1 @@\n-  inline void add_ordered(HeapRegion* hr);\n+  inline void add_ordered(G1HeapRegion* hr);\n@@ -211,1 +211,1 @@\n-  inline void add_to_tail(HeapRegion* region_to_add);\n+  inline void add_to_tail(G1HeapRegion* region_to_add);\n@@ -214,1 +214,1 @@\n-  HeapRegion* remove_region(bool from_head);\n+  G1HeapRegion* remove_region(bool from_head);\n@@ -216,1 +216,1 @@\n-  HeapRegion* remove_region_with_node_index(bool from_head,\n+  G1HeapRegion* remove_region_with_node_index(bool from_head,\n@@ -234,1 +234,1 @@\n-  void remove_starting_at(HeapRegion* first, uint num_regions);\n+  void remove_starting_at(G1HeapRegion* first, uint num_regions);\n@@ -248,1 +248,1 @@\n-  HeapRegion*     _curr;\n+  G1HeapRegion*   _curr;\n@@ -255,1 +255,1 @@\n-  HeapRegion* get_next() {\n+  G1HeapRegion* get_next() {\n@@ -262,1 +262,1 @@\n-    HeapRegion* hr = _curr;\n+    G1HeapRegion* hr = _curr;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-inline void HeapRegionSetBase::add(HeapRegion* hr) {\n+inline void HeapRegionSetBase::add(G1HeapRegion* hr) {\n@@ -43,1 +43,1 @@\n-inline void HeapRegionSetBase::remove(HeapRegion* hr) {\n+inline void HeapRegionSetBase::remove(G1HeapRegion* hr) {\n@@ -54,1 +54,1 @@\n-inline void FreeRegionList::add_to_tail(HeapRegion* region_to_add) {\n+inline void FreeRegionList::add_to_tail(G1HeapRegion* region_to_add) {\n@@ -74,1 +74,1 @@\n-inline void FreeRegionList::add_ordered(HeapRegion* hr) {\n+inline void FreeRegionList::add_ordered(G1HeapRegion* hr) {\n@@ -83,1 +83,1 @@\n-    HeapRegion* curr;\n+    G1HeapRegion* curr;\n@@ -123,2 +123,2 @@\n-inline HeapRegion* FreeRegionList::remove_from_head_impl() {\n-  HeapRegion* result = _head;\n+inline G1HeapRegion* FreeRegionList::remove_from_head_impl() {\n+  G1HeapRegion* result = _head;\n@@ -135,2 +135,2 @@\n-inline HeapRegion* FreeRegionList::remove_from_tail_impl() {\n-  HeapRegion* result = _tail;\n+inline G1HeapRegion* FreeRegionList::remove_from_tail_impl() {\n+  G1HeapRegion* result = _tail;\n@@ -148,1 +148,1 @@\n-inline HeapRegion* FreeRegionList::remove_region(bool from_head) {\n+inline G1HeapRegion* FreeRegionList::remove_region(bool from_head) {\n@@ -157,1 +157,1 @@\n-  HeapRegion* hr;\n+  G1HeapRegion* hr;\n@@ -177,1 +177,1 @@\n-inline HeapRegion* FreeRegionList::remove_region_with_node_index(bool from_head,\n+inline G1HeapRegion* FreeRegionList::remove_region_with_node_index(bool from_head,\n@@ -182,1 +182,1 @@\n-  HeapRegion* cur;\n+  G1HeapRegion* cur;\n@@ -210,2 +210,2 @@\n-  HeapRegion* prev = cur->prev();\n-  HeapRegion* next = cur->next();\n+  G1HeapRegion* prev = cur->prev();\n+  G1HeapRegion* next = cur->next();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionSet.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    size_t min_expand_bytes = HeapRegion::GrainBytes;\n+    size_t min_expand_bytes = G1HeapRegion::GrainBytes;\n@@ -227,1 +227,1 @@\n-                               _g1h->eden_regions_count() * HeapRegion::GrainBytes;\n+                               _g1h->eden_regions_count() * G1HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -160,1 +160,1 @@\n-                      usage._survivor_used \/ K, ((after._survivor_length * HeapRegion::GrainBytes) - usage._survivor_used) \/ K);\n+                      usage._survivor_used \/ K, ((after._survivor_length * G1HeapRegion::GrainBytes) - usage._survivor_used) \/ K);\n@@ -165,1 +165,1 @@\n-                      usage._old_used \/ K, ((after._old_length * HeapRegion::GrainBytes) - usage._old_used) \/ K);\n+                      usage._old_used \/ K, ((after._old_length * G1HeapRegion::GrainBytes) - usage._old_used) \/ K);\n@@ -170,1 +170,1 @@\n-                      usage._humongous_used \/ K, ((after._humongous_length * HeapRegion::GrainBytes) - usage._humongous_used) \/ K);\n+                      usage._humongous_used \/ K, ((after._humongous_length * G1HeapRegion::GrainBytes) - usage._humongous_used) \/ K);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-      HeapRegion* hr = _g1h->heap_region_containing(obj);\n+      G1HeapRegion* hr = _g1h->heap_region_containing(obj);\n@@ -201,1 +201,1 @@\n-  HeapRegion *_hr;\n+  G1HeapRegion* _hr;\n@@ -205,1 +205,1 @@\n-  VerifyObjsInRegionClosure(HeapRegion *hr, VerifyOption vo)\n+  VerifyObjsInRegionClosure(G1HeapRegion* hr, VerifyOption vo)\n@@ -248,1 +248,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -397,1 +397,1 @@\n-  bool do_heap_region(HeapRegion* hr) {\n+  bool do_heap_region(G1HeapRegion* hr) {\n@@ -455,1 +455,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -544,1 +544,1 @@\n-    virtual bool do_heap_region(HeapRegion* r) {\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -565,1 +565,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -582,1 +582,1 @@\n-void G1HeapVerifier::verify_not_dirty_region(HeapRegion* hr) {\n+void G1HeapVerifier::verify_not_dirty_region(G1HeapRegion* hr) {\n@@ -589,1 +589,1 @@\n-void G1HeapVerifier::verify_dirty_region(HeapRegion* hr) {\n+void G1HeapVerifier::verify_dirty_region(G1HeapRegion* hr) {\n@@ -611,1 +611,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -629,1 +629,1 @@\n-  virtual bool do_heap_region(HeapRegion* hr) {\n+  virtual bool do_heap_region(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-  void verify_not_dirty_region(HeapRegion* hr) PRODUCT_RETURN;\n-  void verify_dirty_region(HeapRegion* hr) PRODUCT_RETURN;\n+  void verify_not_dirty_region(G1HeapRegion* hr) PRODUCT_RETURN;\n+  void verify_dirty_region(G1HeapRegion* hr) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,2 +256,2 @@\n-  _survivor_space_committed = survivor_list_length * HeapRegion::GrainBytes;\n-  _old_gen_committed = HeapRegion::align_up_to_region_byte_size(_old_gen_used);\n+  _survivor_space_committed = survivor_list_length * G1HeapRegion::GrainBytes;\n+  _old_gen_committed = G1HeapRegion::align_up_to_region_byte_size(_old_gen_used);\n@@ -269,1 +269,1 @@\n-  _eden_space_committed = (size_t) eden_list_max_length * HeapRegion::GrainBytes;\n+  _eden_space_committed = (size_t) eden_list_max_length * G1HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    HeapRegion* hr = _g1h->heap_region_containing(o);\n+    G1HeapRegion* hr = _g1h->heap_region_containing(o);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NMethodClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-uint G1NUMA::index_for_region(HeapRegion* hr) const {\n+uint G1NUMA::index_for_region(G1HeapRegion* hr) const {\n@@ -197,3 +197,3 @@\n-\/\/      * Page #:       |-0--||-1--||-2--||-3--||-4--||-5--||-6--||-7--||-8--||-9--||-10-||-11-||-12-||-13-||-14-||-15-|\n-\/\/      * HeapRegion #: |----#0----||----#1----||----#2----||----#3----||----#4----||----#5----||----#6----||----#7----|\n-\/\/      * NUMA node #:  |----#0----||----#1----||----#2----||----#3----||----#0----||----#1----||----#2----||----#3----|\n+\/\/      * Page #:         |-0--||-1--||-2--||-3--||-4--||-5--||-6--||-7--||-8--||-9--||-10-||-11-||-12-||-13-||-14-||-15-|\n+\/\/      * G1HeapRegion #: |----#0----||----#1----||----#2----||----#3----||----#4----||----#5----||----#6----||----#7----|\n+\/\/      * NUMA node #:    |----#0----||----#1----||----#2----||----#3----||----#0----||----#1----||----#2----||----#3----|\n@@ -203,3 +203,3 @@\n-\/\/      * Page #:       |-----0----||-----1----||-----2----||-----3----||-----4----||-----5----||-----6----||-----7----|\n-\/\/      * HeapRegion #: |-#0-||-#1-||-#2-||-#3-||-#4-||-#5-||-#6-||-#7-||-#8-||-#9-||#10-||#11-||#12-||#13-||#14-||#15-|\n-\/\/      * NUMA node #:  |----#0----||----#1----||----#2----||----#3----||----#0----||----#1----||----#2----||----#3----|\n+\/\/      * Page #:         |-----0----||-----1----||-----2----||-----3----||-----4----||-----5----||-----6----||-----7----|\n+\/\/      * G1HeapRegion #: |-#0-||-#1-||-#2-||-#3-||-#4-||-#5-||-#6-||-#7-||-#8-||-#9-||#10-||#11-||#12-||#13-||#14-||#15-|\n+\/\/      * NUMA node #:    |----#0----||----#1----||----#2----||----#3----||----#0----||----#1----||----#2----||----#3----|\n@@ -291,1 +291,1 @@\n-bool G1NodeIndexCheckClosure::do_heap_region(HeapRegion* hr) {\n+bool G1NodeIndexCheckClosure::do_heap_region(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  \/\/ HeapRegion size\n+  \/\/ G1HeapRegion size\n@@ -97,1 +97,1 @@\n-  \/\/ Returns the preferred index for the given HeapRegion index.\n+  \/\/ Returns the preferred index for the given G1HeapRegion index.\n@@ -99,1 +99,1 @@\n-  \/\/ with the given HeapRegion index.\n+  \/\/ with the given G1HeapRegion index.\n@@ -110,1 +110,1 @@\n-  uint index_for_region(HeapRegion* hr) const;\n+  uint index_for_region(G1HeapRegion* hr) const;\n@@ -146,1 +146,1 @@\n-  bool do_heap_region(HeapRegion* hr);\n+  bool do_heap_region(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NUMA.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-class HeapRegion;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  } else if (!HeapRegion::is_in_same_region(p, obj)) {\n+  } else if (!G1HeapRegion::is_in_same_region(p, obj)) {\n@@ -138,1 +138,1 @@\n-  if (HeapRegion::is_in_same_region(p, obj)) {\n+  if (G1HeapRegion::is_in_same_region(p, obj)) {\n@@ -177,1 +177,1 @@\n-  } else if (!HeapRegion::is_in_same_region(p, obj)) {\n+  } else if (!G1HeapRegion::is_in_same_region(p, obj)) {\n@@ -264,1 +264,1 @@\n-  if (HeapRegion::is_in_same_region(p, obj)) {\n+  if (G1HeapRegion::is_in_same_region(p, obj)) {\n@@ -268,1 +268,1 @@\n-  HeapRegion* to = _g1h->heap_region_containing(obj);\n+  G1HeapRegion* to = _g1h->heap_region_containing(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+  \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n@@ -447,1 +447,1 @@\n-  HeapRegion* region = _g1h->heap_region_containing(obj_start);\n+  G1HeapRegion* region = _g1h->heap_region_containing(obj_start);\n@@ -472,1 +472,1 @@\n-  HeapRegion* const from_region = _g1h->heap_region_containing(old);\n+  G1HeapRegion* const from_region = _g1h->heap_region_containing(old);\n@@ -556,1 +556,1 @@\n-    \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+    \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n@@ -627,1 +627,1 @@\n-void G1ParScanThreadStateSet::record_unused_optional_region(HeapRegion* hr) {\n+void G1ParScanThreadStateSet::record_unused_optional_region(G1HeapRegion* hr) {\n@@ -644,1 +644,1 @@\n-    HeapRegion* r = _g1h->heap_region_containing(old);\n+    G1HeapRegion* r = _g1h->heap_region_containing(old);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -241,1 +241,1 @@\n-  inline G1OopStarChunkedList* oops_into_optional_region(const HeapRegion* hr);\n+  inline G1OopStarChunkedList* oops_into_optional_region(const G1HeapRegion* hr);\n@@ -268,1 +268,1 @@\n-  void record_unused_optional_region(HeapRegion* hr);\n+  void record_unused_optional_region(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-G1OopStarChunkedList* G1ParScanThreadState::oops_into_optional_region(const HeapRegion* hr) {\n+G1OopStarChunkedList* G1ParScanThreadState::oops_into_optional_region(const G1HeapRegion* hr) {\n@@ -112,1 +112,1 @@\n-  assert(!HeapRegion::is_in_same_region(p, obj), \"Should have filtered out cross-region references already.\");\n+  assert(!G1HeapRegion::is_in_same_region(p, obj), \"Should have filtered out cross-region references already.\");\n@@ -123,1 +123,1 @@\n-  if (HeapRegion::is_in_same_region(p, obj)) {\n+  if (G1HeapRegion::is_in_same_region(p, obj)) {\n@@ -147,1 +147,1 @@\n-  assert(!HeapRegion::is_in_same_region(p, o), \"Should have filtered out cross-region references already.\");\n+  assert(!G1HeapRegion::is_in_same_region(p, o), \"Should have filtered out cross-region references already.\");\n@@ -154,1 +154,1 @@\n-  HeapRegion* const hr_obj = _g1h->heap_region_containing(o);\n+  G1HeapRegion* const hr_obj = _g1h->heap_region_containing(o);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    const size_t free_bytes = (_base_free_regions - young_length) * HeapRegion::GrainBytes;\n+    const size_t free_bytes = (_base_free_regions - young_length) * G1HeapRegion::GrainBytes;\n@@ -176,1 +176,1 @@\n-  _ihop_control->update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);\n+  _ihop_control->update_target_occupancy(new_number_of_regions * G1HeapRegion::GrainBytes);\n@@ -510,1 +510,1 @@\n-  const GrowableArray<HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n+  const GrowableArray<G1HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n@@ -512,1 +512,1 @@\n-  for (GrowableArrayIterator<HeapRegion*> it = survivor_regions->begin();\n+  for (GrowableArrayIterator<G1HeapRegion*> it = survivor_regions->begin();\n@@ -532,1 +532,1 @@\n-    HeapRegion* r = ci->_r;\n+    G1HeapRegion* r = ci->_r;\n@@ -602,1 +602,1 @@\n-  _old_gen_alloc_tracker.reset_after_gc(_g1h->humongous_regions_count() * HeapRegion::GrainBytes);\n+  _old_gen_alloc_tracker.reset_after_gc(_g1h->humongous_regions_count() * G1HeapRegion::GrainBytes);\n@@ -666,1 +666,1 @@\n-  HeapRegion* r = _g1h->region_at(index);\n+  G1HeapRegion* r = _g1h->region_at(index);\n@@ -671,1 +671,1 @@\n-  size_t threshold = G1RetainRegionLiveThresholdPercent * HeapRegion::GrainBytes \/ 100;\n+  size_t threshold = G1RetainRegionLiveThresholdPercent * G1HeapRegion::GrainBytes \/ 100;\n@@ -957,1 +957,1 @@\n-    _old_gen_alloc_tracker.reset_after_gc(_g1h->humongous_regions_count() * HeapRegion::GrainBytes);\n+    _old_gen_alloc_tracker.reset_after_gc(_g1h->humongous_regions_count() * G1HeapRegion::GrainBytes);\n@@ -1043,1 +1043,1 @@\n-    size_t young_gen_size = young_list_desired_length() * HeapRegion::GrainBytes;\n+    size_t young_gen_size = young_list_desired_length() * G1HeapRegion::GrainBytes;\n@@ -1096,1 +1096,1 @@\n-size_t G1Policy::predict_bytes_to_copy(HeapRegion* hr) const {\n+size_t G1Policy::predict_bytes_to_copy(G1HeapRegion* hr) const {\n@@ -1114,1 +1114,1 @@\n-  size_t const expected_bytes = _eden_surv_rate_group->accum_surv_rate_pred(count - 1) * HeapRegion::GrainBytes;\n+  size_t const expected_bytes = _eden_surv_rate_group->accum_surv_rate_pred(count - 1) * G1HeapRegion::GrainBytes;\n@@ -1121,1 +1121,1 @@\n-double G1Policy::predict_region_copy_time_ms(HeapRegion* hr, bool for_young_only_phase) const {\n+double G1Policy::predict_region_copy_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const {\n@@ -1126,1 +1126,1 @@\n-double G1Policy::predict_region_merge_scan_time(HeapRegion* hr, bool for_young_only_phase) const {\n+double G1Policy::predict_region_merge_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const {\n@@ -1135,1 +1135,1 @@\n-double G1Policy::predict_region_code_root_scan_time(HeapRegion* hr, bool for_young_only_phase) const {\n+double G1Policy::predict_region_code_root_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const {\n@@ -1142,1 +1142,1 @@\n-double G1Policy::predict_region_non_copy_time_ms(HeapRegion* hr,\n+double G1Policy::predict_region_non_copy_time_ms(G1HeapRegion* hr,\n@@ -1157,1 +1157,1 @@\n-double G1Policy::predict_region_total_time_ms(HeapRegion* hr, bool for_young_only_phase) const {\n+double G1Policy::predict_region_total_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const {\n@@ -1178,1 +1178,1 @@\n-  size_t bytes_used = full * HeapRegion::GrainBytes;\n+  size_t bytes_used = full * G1HeapRegion::GrainBytes;\n@@ -1183,1 +1183,1 @@\n-  size_t const survivor_capacity = HeapRegion::GrainWords * max_regions;\n+  size_t const survivor_capacity = G1HeapRegion::GrainWords * max_regions;\n@@ -1340,1 +1340,1 @@\n-  for (HeapRegion* r : *candidates()) {\n+  for (G1HeapRegion* r : *candidates()) {\n@@ -1505,1 +1505,1 @@\n-    HeapRegion* hr = (*iter)->_r;\n+    G1HeapRegion* hr = (*iter)->_r;\n@@ -1600,1 +1600,1 @@\n-    HeapRegion* r = ci->_r;\n+    G1HeapRegion* r = ci->_r;\n@@ -1658,1 +1658,1 @@\n-  for (HeapRegion* r : *optional_regions) {\n+  for (G1HeapRegion* r : *optional_regions) {\n@@ -1681,1 +1681,1 @@\n-  for (GrowableArrayIterator<HeapRegion*> it = survivors->regions()->begin();\n+  for (GrowableArrayIterator<G1HeapRegion*> it = survivors->regions()->begin();\n@@ -1684,1 +1684,1 @@\n-    HeapRegion* curr = *it;\n+    G1HeapRegion* curr = *it;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -125,1 +125,1 @@\n-  void set_region_eden(HeapRegion* hr) {\n+  void set_region_eden(G1HeapRegion* hr) {\n@@ -130,1 +130,1 @@\n-  void set_region_survivor(HeapRegion* hr) {\n+  void set_region_survivor(G1HeapRegion* hr) {\n@@ -148,1 +148,1 @@\n-  double predict_region_copy_time_ms(HeapRegion* hr, bool for_young_only_phase) const;\n+  double predict_region_copy_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -151,1 +151,1 @@\n-  double predict_region_merge_scan_time(HeapRegion* hr, bool for_young_only_phase) const;\n+  double predict_region_merge_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -153,1 +153,1 @@\n-  double predict_region_code_root_scan_time(HeapRegion* hr, bool for_young_only_phase) const;\n+  double predict_region_code_root_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -155,1 +155,1 @@\n-  double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_only_phase) const;\n+  double predict_region_non_copy_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -166,1 +166,1 @@\n-  double predict_region_total_time_ms(HeapRegion* hr, bool for_young_only_phase) const;\n+  double predict_region_total_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -248,1 +248,1 @@\n-  size_t predict_bytes_to_copy(HeapRegion* hr) const;\n+  size_t predict_bytes_to_copy(G1HeapRegion* hr) const;\n@@ -403,1 +403,1 @@\n-  bool should_retain_evac_failed_region(HeapRegion* r) const {\n+  bool should_retain_evac_failed_region(G1HeapRegion* r) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-uint G1RegionsOnNodes::add(HeapRegion* hr) {\n+uint G1RegionsOnNodes::add(G1HeapRegion* hr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionsOnNodes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -44,1 +44,1 @@\n-  uint add(HeapRegion* hr);\n+  uint add(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionsOnNodes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  \/\/ to (>=) HeapRegion::CardsPerRegion (completely scanned).\n+  \/\/ to (>=) G1HeapRegion::CardsPerRegion (completely scanned).\n@@ -226,1 +226,1 @@\n-      double num_cards = num_regions << HeapRegion::LogCardsPerRegion;\n+      double num_cards = num_regions << G1HeapRegion::LogCardsPerRegion;\n@@ -238,1 +238,1 @@\n-      const uint num_regions_per_worker = num_cards_per_worker \/ (uint)HeapRegion::CardsPerRegion;\n+      const uint num_regions_per_worker = num_cards_per_worker \/ (uint)G1HeapRegion::CardsPerRegion;\n@@ -245,1 +245,1 @@\n-          HeapRegion* r = _g1h->region_at(_regions->at(i));\n+          G1HeapRegion* r = _g1h->region_at(_regions->at(i));\n@@ -279,1 +279,1 @@\n-    _scan_chunks_shift = (uint8_t)log2i(HeapRegion::CardsPerRegion \/ _scan_chunks_per_region);\n+    _scan_chunks_shift = (uint8_t)log2i(G1HeapRegion::CardsPerRegion \/ _scan_chunks_per_region);\n@@ -320,1 +320,1 @@\n-    HeapRegion* hr = G1CollectedHeap::heap()->region_at_or_null(region_idx);\n+    G1HeapRegion* hr = G1CollectedHeap::heap()->region_at_or_null(region_idx);\n@@ -331,1 +331,1 @@\n-    return result * (HeapRegion::CardsPerRegion \/ _scan_chunks_per_region);\n+    return result * (G1HeapRegion::CardsPerRegion \/ _scan_chunks_per_region);\n@@ -335,1 +335,1 @@\n-    return _next_dirty_regions->size() * HeapRegion::CardsPerRegion;\n+    return _next_dirty_regions->size() * G1HeapRegion::CardsPerRegion;\n@@ -395,1 +395,1 @@\n-    return _card_table_scan_state[region] < HeapRegion::CardsPerRegion;\n+    return _card_table_scan_state[region] < G1HeapRegion::CardsPerRegion;\n@@ -405,1 +405,1 @@\n-   HeapRegion* hr = G1CollectedHeap::heap()->region_at(region);\n+   G1HeapRegion* hr = G1CollectedHeap::heap()->region_at(region);\n@@ -415,1 +415,1 @@\n-    HeapRegion* hr = G1CollectedHeap::heap()->region_at(region);\n+    G1HeapRegion* hr = G1CollectedHeap::heap()->region_at(region);\n@@ -464,1 +464,1 @@\n-    guarantee(size() <= HeapRegion::CardsPerRegion, \"Should not claim more space than possible.\");\n+    guarantee(size() <= G1HeapRegion::CardsPerRegion, \"Should not claim more space than possible.\");\n@@ -470,1 +470,1 @@\n-      if (_cur_claim >= HeapRegion::CardsPerRegion) {\n+      if (_cur_claim >= G1HeapRegion::CardsPerRegion) {\n@@ -512,1 +512,1 @@\n-    HeapRegion* const card_region = _g1h->region_at(region_idx_for_card);\n+    G1HeapRegion* const card_region = _g1h->region_at(region_idx_for_card);\n@@ -642,1 +642,1 @@\n-  void scan_heap_roots(HeapRegion* r) {\n+  void scan_heap_roots(G1HeapRegion* r) {\n@@ -658,1 +658,1 @@\n-      size_t const region_card_base_idx = ((size_t)region_idx << HeapRegion::LogCardsPerRegion) + claim.value();\n+      size_t const region_card_base_idx = ((size_t)region_idx << G1HeapRegion::LogCardsPerRegion) + claim.value();\n@@ -693,1 +693,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -779,1 +779,1 @@\n-  void scan_opt_rem_set_roots(HeapRegion* r) {\n+  void scan_opt_rem_set_roots(G1HeapRegion* r) {\n@@ -808,1 +808,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -883,1 +883,1 @@\n-void G1RemSet::prepare_region_for_scan(HeapRegion* r) {\n+void G1RemSet::prepare_region_for_scan(G1HeapRegion* r) {\n@@ -1047,1 +1047,1 @@\n-        _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+        _region_base_idx = (size_t)region_idx << G1HeapRegion::LogCardsPerRegion;\n@@ -1074,1 +1074,1 @@\n-    void merge_card_set_for_region(HeapRegion* r) {\n+    void merge_card_set_for_region(G1HeapRegion* r) {\n@@ -1083,1 +1083,1 @@\n-    virtual bool do_heap_region(HeapRegion* r) {\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -1104,1 +1104,1 @@\n-    void assert_bitmap_clear(HeapRegion* hr, const G1CMBitMap* bitmap) {\n+    void assert_bitmap_clear(G1HeapRegion* hr, const G1CMBitMap* bitmap) {\n@@ -1109,1 +1109,1 @@\n-    bool should_clear_region(HeapRegion* hr) const {\n+    bool should_clear_region(G1HeapRegion* hr) const {\n@@ -1129,1 +1129,1 @@\n-    bool do_heap_region(HeapRegion* hr) {\n+    bool do_heap_region(G1HeapRegion* hr) {\n@@ -1155,1 +1155,1 @@\n-    bool do_heap_region(HeapRegion* hr) {\n+    bool do_heap_region(G1HeapRegion* hr) {\n@@ -1176,1 +1176,1 @@\n-      HeapRegion* r = g1h->region_at(region_index);\n+      G1HeapRegion* r = g1h->region_at(region_index);\n@@ -1416,1 +1416,1 @@\n-      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n+      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * G1HeapRegion::CardsPerRegion;\n@@ -1499,1 +1499,1 @@\n-  HeapRegion* r = _g1h->heap_region_containing_or_null(start);\n+  G1HeapRegion* r = _g1h->heap_region_containing_or_null(start);\n@@ -1573,1 +1573,1 @@\n-  HeapRegion* r = _g1h->heap_region_containing(start);\n+  G1HeapRegion* r = _g1h->heap_region_containing(start);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  void prepare_region_for_scan(HeapRegion* region);\n+  void prepare_region_for_scan(G1HeapRegion* region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-  HeapRegion* _max_rs_mem_sz_region;\n+  G1HeapRegion* _max_rs_mem_sz_region;\n@@ -200,1 +200,1 @@\n-  HeapRegion* max_rs_mem_sz_region() const  { return _max_rs_mem_sz_region; }\n+  G1HeapRegion* max_rs_mem_sz_region() const  { return _max_rs_mem_sz_region; }\n@@ -203,1 +203,1 @@\n-  HeapRegion* _max_code_root_mem_sz_region;\n+  G1HeapRegion* _max_code_root_mem_sz_region;\n@@ -209,1 +209,1 @@\n-  HeapRegion* max_code_root_mem_sz_region() const { return _max_code_root_mem_sz_region; }\n+  G1HeapRegion* max_code_root_mem_sz_region() const { return _max_code_root_mem_sz_region; }\n@@ -218,1 +218,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-bool G1RemSetTrackingPolicy::needs_scan_for_rebuild(HeapRegion* r) const {\n+bool G1RemSetTrackingPolicy::needs_scan_for_rebuild(G1HeapRegion* r) const {\n@@ -41,1 +41,1 @@\n-void G1RemSetTrackingPolicy::update_at_allocate(HeapRegion* r) {\n+void G1RemSetTrackingPolicy::update_at_allocate(G1HeapRegion* r) {\n@@ -54,1 +54,1 @@\n-void G1RemSetTrackingPolicy::update_at_free(HeapRegion* r) {\n+void G1RemSetTrackingPolicy::update_at_free(G1HeapRegion* r) {\n@@ -58,1 +58,1 @@\n-bool G1RemSetTrackingPolicy::update_humongous_before_rebuild(HeapRegion* r) {\n+bool G1RemSetTrackingPolicy::update_humongous_before_rebuild(G1HeapRegion* r) {\n@@ -69,1 +69,1 @@\n-    auto on_humongous_region = [] (HeapRegion* r) {\n+    auto on_humongous_region = [] (G1HeapRegion* r) {\n@@ -79,1 +79,1 @@\n-bool G1RemSetTrackingPolicy::update_old_before_rebuild(HeapRegion* r) {\n+bool G1RemSetTrackingPolicy::update_old_before_rebuild(G1HeapRegion* r) {\n@@ -96,1 +96,1 @@\n-void G1RemSetTrackingPolicy::update_after_rebuild(HeapRegion* r) {\n+void G1RemSetTrackingPolicy::update_after_rebuild(G1HeapRegion* r) {\n@@ -110,1 +110,1 @@\n-                                         [&] (HeapRegion* r) {\n+                                         [&] (G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  bool needs_scan_for_rebuild(HeapRegion* r) const;\n+  bool needs_scan_for_rebuild(G1HeapRegion* r) const;\n@@ -43,1 +43,1 @@\n-  void update_at_allocate(HeapRegion* r);\n+  void update_at_allocate(G1HeapRegion* r);\n@@ -46,1 +46,1 @@\n-  bool update_humongous_before_rebuild(HeapRegion* r);\n+  bool update_humongous_before_rebuild(G1HeapRegion* r);\n@@ -49,1 +49,1 @@\n-  bool update_old_before_rebuild(HeapRegion* r);\n+  bool update_old_before_rebuild(G1HeapRegion* r);\n@@ -52,1 +52,1 @@\n-  void update_after_rebuild(HeapRegion* r);\n+  void update_after_rebuild(G1HeapRegion* r);\n@@ -54,1 +54,1 @@\n-  void update_at_free(HeapRegion* r);\n+  void update_at_free(G1HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -60,4 +59,0 @@\n-  guarantee(_surv_rate_predictors[0] != nullptr, \"invariant\" );\n-  const double initial_surv_rate = 0.4;\n-  _surv_rate_predictors[0]->add(initial_surv_rate);\n-  _last_pred = _accum_surv_rate_pred[0] = initial_surv_rate;\n@@ -78,0 +73,1 @@\n+      \/\/ Initialize predictors and accumulated survivor rate predictions.\n@@ -79,0 +75,2 @@\n+      _surv_rate_predictors[i]->add(InitialSurvivorRate);\n+      _accum_surv_rate_pred[i] = ((i == 0) ? 0.0 : _accum_surv_rate_pred[i-1]) + InitialSurvivorRate;\n@@ -80,0 +78,1 @@\n+    _last_pred = InitialSurvivorRate;\n@@ -88,1 +87,1 @@\n-  double surv_rate = (double)surv_words \/ HeapRegion::GrainWords;\n+  double surv_rate = (double)surv_words \/ G1HeapRegion::GrainWords;\n@@ -99,0 +98,13 @@\n+double G1SurvRateGroup::accum_surv_rate_pred(uint age) const {\n+  assert(_stats_arrays_length > 0, \"invariant\" );\n+  double result;\n+  if (age < _stats_arrays_length) {\n+    result = _accum_surv_rate_pred[age];\n+  } else {\n+    double diff = (double)(age - _stats_arrays_length + 1);\n+    result = _accum_surv_rate_pred[_stats_arrays_length - 1] + diff * _last_pred;\n+  }\n+  assert(result <= (age + 1.0), \"Accumulated survivor rate %.2f must be smaller than age+1 %u\", result, age + 1);\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvRateGroup.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+  \/\/ The initial survivor rate for predictors. Somewhat random value.\n+  const double InitialSurvivorRate = 0.4;\n+\n@@ -76,9 +79,1 @@\n-  double accum_surv_rate_pred(uint age) const {\n-    assert(_stats_arrays_length > 0, \"invariant\" );\n-    if (age < _stats_arrays_length)\n-      return _accum_surv_rate_pred[age];\n-    else {\n-      double diff = (double)(age - _stats_arrays_length + 1);\n-      return _accum_surv_rate_pred[_stats_arrays_length - 1] + diff * _last_pred;\n-    }\n-  }\n+  double accum_surv_rate_pred(uint age) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvRateGroup.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  _regions(new (mtGC) GrowableArray<HeapRegion*>(8, mtGC)),\n+  _regions(new (mtGC) GrowableArray<G1HeapRegion*>(8, mtGC)),\n@@ -36,1 +36,1 @@\n-uint G1SurvivorRegions::add(HeapRegion* hr) {\n+uint G1SurvivorRegions::add(G1HeapRegion* hr) {\n@@ -51,1 +51,1 @@\n-  for (GrowableArrayIterator<HeapRegion*> it = _regions->begin();\n+  for (GrowableArrayIterator<G1HeapRegion*> it = _regions->begin();\n@@ -54,1 +54,1 @@\n-    HeapRegion* hr = *it;\n+    G1HeapRegion* hr = *it;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class HeapRegion;\n+class G1HeapRegion;\n@@ -37,1 +37,1 @@\n-  GrowableArray<HeapRegion*>* _regions;\n+  GrowableArray<G1HeapRegion*>* _regions;\n@@ -44,1 +44,1 @@\n-  uint add(HeapRegion* hr);\n+  uint add(G1HeapRegion* hr);\n@@ -53,1 +53,1 @@\n-  const GrowableArray<HeapRegion*>* regions() const {\n+  const GrowableArray<G1HeapRegion*>* regions() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-                      byte_size_in_proper_unit(regions * HeapRegion::GrainBytes),\n-                      proper_unit_for_byte_size(regions * HeapRegion::GrainBytes),\n+                      byte_size_in_proper_unit(regions * G1HeapRegion::GrainBytes),\n+                      proper_unit_for_byte_size(regions * G1HeapRegion::GrainBytes),\n@@ -94,2 +94,2 @@\n-                      byte_size_in_proper_unit(_summary_region_count * HeapRegion::GrainBytes),\n-                      proper_unit_for_byte_size(_summary_region_count * HeapRegion::GrainBytes),\n+                      byte_size_in_proper_unit(_summary_region_count * G1HeapRegion::GrainBytes),\n+                      proper_unit_for_byte_size(_summary_region_count * G1HeapRegion::GrainBytes),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n@@ -297,1 +297,1 @@\n-    void sample_card_set_size(HeapRegion* hr) {\n+    void sample_card_set_size(G1HeapRegion* hr) {\n@@ -306,1 +306,1 @@\n-    bool humongous_region_is_candidate(HeapRegion* region) const {\n+    bool humongous_region_is_candidate(G1HeapRegion* region) const {\n@@ -378,1 +378,1 @@\n-    virtual bool do_heap_region(HeapRegion* hr) {\n+    virtual bool do_heap_region(G1HeapRegion* hr) {\n@@ -971,1 +971,1 @@\n-  for (HeapRegion* r : *candidates) {\n+  for (G1HeapRegion* r : *candidates) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  bool do_heap_region(HeapRegion* r) override {\n+  bool do_heap_region(G1HeapRegion* r) override {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    for (HeapRegion* r : *candidates) {\n+    for (G1HeapRegion* r : *candidates) {\n@@ -179,1 +179,1 @@\n-  static size_t zap_dead_objects(HeapRegion* hr, HeapWord* start, HeapWord* end) {\n+  static size_t zap_dead_objects(G1HeapRegion* hr, HeapWord* start, HeapWord* end) {\n@@ -189,1 +189,1 @@\n-  static void update_garbage_words_in_hr(HeapRegion* hr, size_t garbage_words) {\n+  static void update_garbage_words_in_hr(G1HeapRegion* hr, size_t garbage_words) {\n@@ -208,1 +208,1 @@\n-    HeapRegion* hr = _g1h->region_at(region_idx);\n+    G1HeapRegion* hr = _g1h->region_at(region_idx);\n@@ -289,1 +289,1 @@\n-    _chunk_size = static_cast<uint>(HeapRegion::GrainWords \/ _num_chunks_per_region);\n+    _chunk_size = static_cast<uint>(G1HeapRegion::GrainWords \/ _num_chunks_per_region);\n@@ -390,1 +390,1 @@\n-    HeapRegion* r = _g1h->region_at(region_index);\n+    G1HeapRegion* r = _g1h->region_at(region_index);\n@@ -411,1 +411,1 @@\n-    auto free_humongous_region = [&] (HeapRegion* r) {\n+    auto free_humongous_region = [&] (G1HeapRegion* r) {\n@@ -415,1 +415,0 @@\n-      _g1h->free_humongous_region(r, nullptr);\n@@ -417,0 +416,1 @@\n+      _g1h->free_humongous_region(r, nullptr);\n@@ -507,1 +507,1 @@\n-  HeapRegion* region_for_card(CardValue* card_ptr) const {\n+  G1HeapRegion* region_for_card(CardValue* card_ptr) const {\n@@ -511,1 +511,1 @@\n-  bool will_become_free(HeapRegion* hr) const {\n+  bool will_become_free(G1HeapRegion* hr) const {\n@@ -526,1 +526,1 @@\n-    HeapRegion* hr = region_for_card(card_ptr);\n+    G1HeapRegion* hr = region_for_card(card_ptr);\n@@ -545,1 +545,1 @@\n-    bool do_heap_region(HeapRegion* r) override {\n+    bool do_heap_region(G1HeapRegion* r) override {\n@@ -680,1 +680,1 @@\n-  void account_failed_region(HeapRegion* r) {\n+  void account_failed_region(G1HeapRegion* r) {\n@@ -683,1 +683,1 @@\n-    _failure_waste_words += HeapRegion::GrainWords - used_words;\n+    _failure_waste_words += G1HeapRegion::GrainWords - used_words;\n@@ -692,1 +692,1 @@\n-      _bytes_allocated_in_old_since_last_gc += HeapRegion::GrainBytes;\n+      _bytes_allocated_in_old_since_last_gc += G1HeapRegion::GrainBytes;\n@@ -696,1 +696,1 @@\n-  void account_evacuated_region(HeapRegion* r) {\n+  void account_evacuated_region(G1HeapRegion* r) {\n@@ -703,1 +703,1 @@\n-  void account_card_rs_length(HeapRegion* r) {\n+  void account_card_rs_length(G1HeapRegion* r) {\n@@ -715,1 +715,1 @@\n-    JFREventForRegion(HeapRegion* region, uint worker_id) : _event() {\n+    JFREventForRegion(G1HeapRegion* region, uint worker_id) : _event() {\n@@ -751,1 +751,1 @@\n-  void assert_tracks_surviving_words(HeapRegion* r) {\n+  void assert_tracks_surviving_words(G1HeapRegion* r) {\n@@ -758,1 +758,1 @@\n-  void handle_evacuated_region(HeapRegion* r) {\n+  void handle_evacuated_region(G1HeapRegion* r) {\n@@ -762,0 +762,1 @@\n+    G1HeapRegionPrinter::evac_reclaim(r);\n@@ -764,1 +765,0 @@\n-    G1HeapRegionPrinter::evac_reclaim(r);\n@@ -767,1 +767,1 @@\n-  void handle_failed_region(HeapRegion* r) {\n+  void handle_failed_region(G1HeapRegion* r) {\n@@ -797,1 +797,1 @@\n-  Tickspan& timer_for_region(HeapRegion* r) {\n+  Tickspan& timer_for_region(G1HeapRegion* r) {\n@@ -820,1 +820,1 @@\n-  virtual bool do_heap_region(HeapRegion* r) {\n+  virtual bool do_heap_region(G1HeapRegion* r) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    _min_desired_young_length = MAX2((uint) (NewSize \/ HeapRegion::GrainBytes),\n+    _min_desired_young_length = MAX2((uint) (NewSize \/ G1HeapRegion::GrainBytes),\n@@ -59,1 +59,1 @@\n-                             MAX2((uint) (MaxNewSize \/ HeapRegion::GrainBytes),\n+                             MAX2((uint) (MaxNewSize \/ G1HeapRegion::GrainBytes),\n@@ -68,1 +68,1 @@\n-                             MAX2((uint) (MaxNewSize \/ HeapRegion::GrainBytes),\n+                             MAX2((uint) (MaxNewSize \/ G1HeapRegion::GrainBytes),\n@@ -122,1 +122,1 @@\n-  size_t max_young_size = result * HeapRegion::GrainBytes;\n+  size_t max_young_size = result * G1HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGenSizer.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-  product(uint, G1SATBBufferEnqueueingThresholdPercent, 60,                \\\n+  product(uint, G1SATBBufferEnqueueingThresholdPercent, 60,                 \\\n@@ -156,2 +156,1 @@\n-          \"the buffer will be enqueued for processing. A value of 0 \"       \\\n-          \"specifies that mutator threads should not do such filtering.\")   \\\n+          \"the buffer will be enqueued for processing.\")                    \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-  static_field(HeapRegion, GrainBytes,        size_t)                         \\\n-  static_field(HeapRegion, LogOfHRGrainBytes, uint)                           \\\n+  static_field(G1HeapRegion, GrainBytes,        size_t)                       \\\n+  static_field(G1HeapRegion, LogOfHRGrainBytes, uint)                         \\\n@@ -40,5 +40,5 @@\n-  nonstatic_field(HeapRegion, _type,           HeapRegionType)                \\\n-  nonstatic_field(HeapRegion, _bottom,         HeapWord* const)               \\\n-  nonstatic_field(HeapRegion, _top,            HeapWord* volatile)            \\\n-  nonstatic_field(HeapRegion, _end,            HeapWord* const)               \\\n-  volatile_nonstatic_field(HeapRegion, _pinned_object_count, size_t)          \\\n+  nonstatic_field(G1HeapRegion, _type,           HeapRegionType)              \\\n+  nonstatic_field(G1HeapRegion, _bottom,         HeapWord* const)             \\\n+  nonstatic_field(G1HeapRegion, _top,            HeapWord* volatile)          \\\n+  nonstatic_field(G1HeapRegion, _end,            HeapWord* const)             \\\n+  volatile_nonstatic_field(G1HeapRegion, _pinned_object_count, size_t)        \\\n@@ -96,1 +96,1 @@\n-  declare_toplevel_type(HeapRegion)                                           \\\n+  declare_toplevel_type(G1HeapRegion)                                         \\\n@@ -106,1 +106,1 @@\n-  declare_toplevel_type(HeapRegion*)                                          \\\n+  declare_toplevel_type(G1HeapRegion*)                                        \\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-  \/\/ The bits will be divided evenly between two bitmaps; each of them should be\n-  \/\/ an integral number of words.\n-  assert(is_aligned(bits, (BitsPerWord * 2)), \"region size unaligned\");\n@@ -64,2 +61,1 @@\n-    _beg_bits = BitMapView(map,             bits \/ 2);\n-    _end_bits = BitMapView(map + words \/ 2, bits \/ 2);\n+    _beg_bits = BitMapView(map, bits);\n@@ -80,170 +76,0 @@\n-bool\n-ParMarkBitMap::mark_obj(HeapWord* addr, size_t size)\n-{\n-  const idx_t beg_bit = addr_to_bit(addr);\n-  if (_beg_bits.par_set_bit(beg_bit)) {\n-    const idx_t end_bit = addr_to_bit(addr + size - 1);\n-    bool end_bit_ok = _end_bits.par_set_bit(end_bit);\n-    assert(end_bit_ok, \"concurrency problem\");\n-    return true;\n-  }\n-  return false;\n-}\n-\n-inline bool\n-ParMarkBitMap::is_live_words_in_range_in_cache(ParCompactionManager* cm, HeapWord* beg_addr) const {\n-  return cm->last_query_begin() == beg_addr;\n-}\n-\n-inline void\n-ParMarkBitMap::update_live_words_in_range_cache(ParCompactionManager* cm, HeapWord* beg_addr, oop end_obj, size_t result) const {\n-  cm->set_last_query_begin(beg_addr);\n-  cm->set_last_query_object(end_obj);\n-  cm->set_last_query_return(result);\n-}\n-\n-size_t\n-ParMarkBitMap::live_words_in_range_helper(HeapWord* beg_addr, oop end_obj) const\n-{\n-  assert(beg_addr <= cast_from_oop<HeapWord*>(end_obj), \"bad range\");\n-  assert(is_marked(end_obj), \"end_obj must be live\");\n-\n-  idx_t live_bits = 0;\n-\n-  \/\/ The bitmap routines require the right boundary to be word-aligned.\n-  const idx_t end_bit = addr_to_bit(cast_from_oop<HeapWord*>(end_obj));\n-  const idx_t range_end = align_range_end(end_bit);\n-\n-  idx_t beg_bit = find_obj_beg(addr_to_bit(beg_addr), range_end);\n-  while (beg_bit < end_bit) {\n-    idx_t tmp_end = find_obj_end(beg_bit, range_end);\n-    assert(tmp_end < end_bit, \"missing end bit\");\n-    live_bits += tmp_end - beg_bit + 1;\n-    beg_bit = find_obj_beg(tmp_end + 1, range_end);\n-  }\n-  return bits_to_words(live_bits);\n-}\n-\n-size_t\n-ParMarkBitMap::live_words_in_range_use_cache(ParCompactionManager* cm, HeapWord* beg_addr, oop end_oop) const\n-{\n-  HeapWord* last_beg = cm->last_query_begin();\n-  HeapWord* last_obj = cast_from_oop<HeapWord*>(cm->last_query_object());\n-  HeapWord* end_obj  = cast_from_oop<HeapWord*>(end_oop);\n-\n-  size_t last_ret = cm->last_query_return();\n-  if (end_obj > last_obj) {\n-    last_ret = last_ret + live_words_in_range_helper(last_obj, end_oop);\n-    last_obj = end_obj;\n-  } else if (end_obj < last_obj) {\n-    \/\/ The cached value is for an object that is to the left (lower address) of the current\n-    \/\/ end_obj. Calculate back from that cached value.\n-    if (pointer_delta(end_obj, beg_addr) > pointer_delta(last_obj, end_obj)) {\n-      last_ret = last_ret - live_words_in_range_helper(end_obj, cast_to_oop(last_obj));\n-    } else {\n-      last_ret = live_words_in_range_helper(beg_addr, end_oop);\n-    }\n-    last_obj = end_obj;\n-  }\n-\n-  update_live_words_in_range_cache(cm, last_beg, cast_to_oop(last_obj), last_ret);\n-  return last_ret;\n-}\n-\n-size_t\n-ParMarkBitMap::live_words_in_range(ParCompactionManager* cm, HeapWord* beg_addr, oop end_obj) const\n-{\n-  \/\/ Try to reuse result from ParCompactionManager cache first.\n-  if (is_live_words_in_range_in_cache(cm, beg_addr)) {\n-    return live_words_in_range_use_cache(cm, beg_addr, end_obj);\n-  }\n-  size_t ret = live_words_in_range_helper(beg_addr, end_obj);\n-  update_live_words_in_range_cache(cm, beg_addr, end_obj, ret);\n-  return ret;\n-}\n-\n-ParMarkBitMap::IterationStatus\n-ParMarkBitMap::iterate(ParMarkBitMapClosure* live_closure,\n-                       idx_t range_beg, idx_t range_end) const\n-{\n-  DEBUG_ONLY(verify_bit(range_beg);)\n-  DEBUG_ONLY(verify_bit(range_end);)\n-  assert(range_beg <= range_end, \"live range invalid\");\n-\n-  \/\/ The bitmap routines require the right boundary to be word-aligned.\n-  const idx_t search_end = align_range_end(range_end);\n-\n-  idx_t cur_beg = range_beg;\n-  while (true) {\n-    cur_beg = find_obj_beg(cur_beg, search_end);\n-    if (cur_beg >= range_end) {\n-      break;\n-    }\n-\n-    const size_t size = obj_size(cur_beg);\n-    IterationStatus status = live_closure->do_addr(bit_to_addr(cur_beg), size);\n-    if (status != incomplete) {\n-      assert(status == would_overflow || status == full, \"sanity\");\n-      return status;\n-    }\n-\n-    cur_beg += words_to_bits(size);\n-    if (cur_beg >= range_end) {\n-      break;\n-    }\n-  }\n-\n-  return complete;\n-}\n-\n-ParMarkBitMap::IterationStatus\n-ParMarkBitMap::iterate(ParMarkBitMapClosure* live_closure,\n-                       ParMarkBitMapClosure* dead_closure,\n-                       idx_t range_beg, idx_t range_end,\n-                       idx_t dead_range_end) const\n-{\n-  DEBUG_ONLY(verify_bit(range_beg);)\n-  DEBUG_ONLY(verify_bit(range_end);)\n-  DEBUG_ONLY(verify_bit(dead_range_end);)\n-  assert(range_beg <= range_end, \"live range invalid\");\n-  assert(range_end <= dead_range_end, \"dead range invalid\");\n-\n-  \/\/ The bitmap routines require the right boundary to be word-aligned.\n-  const idx_t dead_search_end = align_range_end(dead_range_end);\n-\n-  idx_t cur_beg = range_beg;\n-  if (range_beg < range_end && is_unmarked(range_beg)) {\n-    \/\/ The range starts with dead space.  Look for the next object, then fill.\n-    \/\/ This must be the beginning of old\/eden\/from\/to-space, so it's must be\n-    \/\/ large enough for a filler.\n-    cur_beg = find_obj_beg(range_beg + 1, dead_search_end);\n-    const idx_t dead_space_end = cur_beg - 1;\n-    const size_t size = obj_size(range_beg, dead_space_end);\n-    dead_closure->do_addr(bit_to_addr(range_beg), size);\n-  }\n-\n-  while (cur_beg < range_end) {\n-    const size_t size = obj_size(cur_beg);\n-    IterationStatus status = live_closure->do_addr(bit_to_addr(cur_beg), size);\n-    if (status != incomplete) {\n-      assert(status == would_overflow || status == full, \"sanity\");\n-      return status;\n-    }\n-\n-    const idx_t dead_space_beg = cur_beg + words_to_bits(size);\n-    if (dead_space_beg >= dead_search_end) {\n-      break;\n-    }\n-    \/\/ Look for the start of the next object.\n-    cur_beg = find_obj_beg(dead_space_beg, dead_search_end);\n-    if (cur_beg > dead_space_beg) {\n-      \/\/ Found dead space; compute the size and invoke the dead closure.\n-      const idx_t dead_space_end = cur_beg - 1;\n-      dead_closure->do_addr(bit_to_addr(dead_space_beg),\n-                            obj_size(dead_space_beg, dead_space_end));\n-    }\n-  }\n-\n-  return complete;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":1,"deletions":175,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class ParMarkBitMapClosure;\n@@ -34,1 +33,0 @@\n-class ParCompactionManager;\n@@ -36,2 +34,1 @@\n-class ParMarkBitMap: public CHeapObj<mtGC>\n-{\n+class ParMarkBitMap: public CHeapObj<mtGC> {\n@@ -41,3 +38,0 @@\n-  \/\/ Values returned by the iterate() methods.\n-  enum IterationStatus { incomplete, complete, full, would_overflow };\n-\n@@ -48,6 +42,2 @@\n-  bool mark_obj(HeapWord* addr, size_t size);\n-  inline bool mark_obj(oop obj, size_t size);\n-\n-  \/\/ Return whether the specified begin or end bit is set.\n-  inline bool is_obj_beg(idx_t bit) const;\n-  inline bool is_obj_end(idx_t bit) const;\n+  inline bool mark_obj(HeapWord* addr);\n+  inline bool mark_obj(oop obj);\n@@ -55,3 +45,0 @@\n-  \/\/ Traditional interface for testing whether an object is marked or not (these\n-  \/\/ test only the begin bits).\n-  inline bool is_marked(idx_t bit)      const;\n@@ -61,1 +48,0 @@\n-  inline bool is_unmarked(idx_t bit)      const;\n@@ -65,66 +51,0 @@\n-  \/\/ Convert sizes from bits to HeapWords and back.  An object that is n bits\n-  \/\/ long will be bits_to_words(n) words long.  An object that is m words long\n-  \/\/ will take up words_to_bits(m) bits in the bitmap.\n-  inline static size_t bits_to_words(idx_t bits);\n-  inline static idx_t  words_to_bits(size_t words);\n-\n-  \/\/ Return the size in words of an object given a begin bit and an end bit, or\n-  \/\/ the equivalent beg_addr and end_addr.\n-  inline size_t obj_size(idx_t beg_bit, idx_t end_bit) const;\n-  inline size_t obj_size(HeapWord* beg_addr, HeapWord* end_addr) const;\n-\n-  \/\/ Return the size in words of the object (a search is done for the end bit).\n-  inline size_t obj_size(idx_t beg_bit)  const;\n-  inline size_t obj_size(HeapWord* addr) const;\n-\n-  \/\/ Apply live_closure to each live object that lies completely within the\n-  \/\/ range [live_range_beg, live_range_end).  This is used to iterate over the\n-  \/\/ compacted region of the heap.  Return values:\n-  \/\/\n-  \/\/ complete           The iteration is complete.  All objects in the range\n-  \/\/                    were processed and the closure is not full;\n-  \/\/                    closure->source() is set one past the end of the range.\n-  \/\/\n-  \/\/ full               The closure is full; closure->source() is set to one\n-  \/\/                    past the end of the last object processed.\n-  \/\/\n-  \/\/ would_overflow     The next object in the range would overflow the closure;\n-  \/\/                    closure->source() is set to the start of that object.\n-  IterationStatus iterate(ParMarkBitMapClosure* live_closure,\n-                          idx_t range_beg, idx_t range_end) const;\n-  inline IterationStatus iterate(ParMarkBitMapClosure* live_closure,\n-                                 HeapWord* range_beg,\n-                                 HeapWord* range_end) const;\n-\n-  \/\/ Apply live closure as above and additionally apply dead_closure to all dead\n-  \/\/ space in the range [range_beg, dead_range_end).  Note that dead_range_end\n-  \/\/ must be >= range_end.  This is used to iterate over the dense prefix.\n-  \/\/\n-  \/\/ This method assumes that if the first bit in the range (range_beg) is not\n-  \/\/ marked, then dead space begins at that point and the dead_closure is\n-  \/\/ applied.  Thus callers must ensure that range_beg is not in the middle of a\n-  \/\/ live object.\n-  IterationStatus iterate(ParMarkBitMapClosure* live_closure,\n-                          ParMarkBitMapClosure* dead_closure,\n-                          idx_t range_beg, idx_t range_end,\n-                          idx_t dead_range_end) const;\n-  inline IterationStatus iterate(ParMarkBitMapClosure* live_closure,\n-                                 ParMarkBitMapClosure* dead_closure,\n-                                 HeapWord* range_beg,\n-                                 HeapWord* range_end,\n-                                 HeapWord* dead_range_end) const;\n-\n-  \/\/ Return the number of live words in the range [beg_addr, end_obj) due to\n-  \/\/ objects that start in the range.  If a live object extends onto the range,\n-  \/\/ the caller must detect and account for any live words due to that object.\n-  \/\/ If a live object extends beyond the end of the range, only the words within\n-  \/\/ the range are included in the result. The end of the range must be a live object,\n-  \/\/ which is the case when updating pointers.  This allows a branch to be removed\n-  \/\/ from inside the loop.\n-  size_t live_words_in_range(ParCompactionManager* cm, HeapWord* beg_addr, oop end_obj) const;\n-\n-  inline HeapWord* region_start() const;\n-  inline HeapWord* region_end() const;\n-  inline size_t    region_size() const;\n-  inline size_t    size() const;\n-\n@@ -133,13 +53,0 @@\n-  \/\/ Convert a heap address to\/from a bit index.\n-  inline idx_t     addr_to_bit(HeapWord* addr) const;\n-  inline HeapWord* bit_to_addr(idx_t bit) const;\n-\n-  \/\/ Return word-aligned up range_end, which must not be greater than size().\n-  inline idx_t align_range_end(idx_t range_end) const;\n-\n-  \/\/ Return the bit index of the first marked object that begins (or ends,\n-  \/\/ respectively) in the range [beg, end).  If no object is found, return end.\n-  \/\/ end must be word-aligned.\n-  inline idx_t find_obj_beg(idx_t beg, idx_t end) const;\n-  inline idx_t find_obj_end(idx_t beg, idx_t end) const;\n-\n@@ -147,1 +54,0 @@\n-  inline HeapWord* find_obj_end(HeapWord* beg, HeapWord* end) const;\n@@ -149,8 +55,5 @@\n-  \/\/ Clear a range of bits or the entire bitmap (both begin and end bits are\n-  \/\/ cleared).\n-  inline void clear_range(idx_t beg, idx_t end);\n-\n-  \/\/ Return the number of bits required to represent the specified number of\n-  \/\/ HeapWords, or the specified region.\n-  static inline idx_t bits_required(size_t words);\n-  static inline idx_t bits_required(MemRegion covered_region);\n+  \/\/ Return the address of the last obj-start in the range [beg, end).  If no\n+  \/\/ object is found, return end.\n+  inline HeapWord* find_obj_beg_reverse(HeapWord* beg, HeapWord* end) const;\n+  \/\/ Clear a range of bits corresponding to heap address range [beg, end).\n+  inline void clear_range(HeapWord* beg, HeapWord* end);\n@@ -161,1 +64,0 @@\n-    _end_bits.print_on_error(st, \" End Bits:   \");\n@@ -166,2 +68,0 @@\n-  inline void verify_bit(idx_t bit) const;\n-  inline void verify_addr(HeapWord* addr) const;\n@@ -171,5 +71,0 @@\n-  size_t live_words_in_range_helper(HeapWord* beg_addr, oop end_obj) const;\n-\n-  bool is_live_words_in_range_in_cache(ParCompactionManager* cm, HeapWord* beg_addr) const;\n-  size_t live_words_in_range_use_cache(ParCompactionManager* cm, HeapWord* beg_addr, oop end_obj) const;\n-  void update_live_words_in_range_cache(ParCompactionManager* cm, HeapWord* beg_addr, oop end_obj, size_t result) const;\n@@ -180,1 +75,0 @@\n-  static inline size_t obj_granularity() { return size_t(MinObjAlignment); }\n@@ -186,1 +80,0 @@\n-  BitMapView      _end_bits;\n@@ -189,0 +82,28 @@\n+\n+  \/\/ Return the number of bits required to represent the specified number of\n+  \/\/ HeapWords, or the specified region.\n+  static inline idx_t bits_required(size_t words);\n+  static inline idx_t bits_required(MemRegion covered_region);\n+\n+  \/\/ Convert sizes from bits to HeapWords and back.  An object that is n bits\n+  \/\/ long will be bits_to_words(n) words long.  An object that is m words long\n+  \/\/ will take up words_to_bits(m) bits in the bitmap.\n+  inline static size_t bits_to_words(idx_t bits);\n+  inline static idx_t  words_to_bits(size_t words);\n+\n+  \/\/ Return word-aligned up range_end, which must not be greater than size().\n+  inline idx_t align_range_end(idx_t range_end) const;\n+\n+  inline HeapWord* region_start() const;\n+  inline HeapWord* region_end() const;\n+  inline size_t    region_size() const;\n+  inline size_t    size() const;\n+\n+  \/\/ Convert a heap address to\/from a bit index.\n+  inline idx_t     addr_to_bit(HeapWord* addr) const;\n+  inline HeapWord* bit_to_addr(idx_t bit) const;\n+\n+#ifdef  ASSERT\n+  inline void verify_bit(idx_t bit) const;\n+  inline void verify_addr(HeapWord* addr) const;\n+#endif  \/\/ #ifdef ASSERT\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.hpp","additions":36,"deletions":115,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  _region_start(nullptr), _region_size(0), _beg_bits(), _end_bits(), _virtual_space(nullptr), _reserved_byte_size(0)\n+  _region_start(nullptr), _region_size(0), _beg_bits(), _virtual_space(nullptr), _reserved_byte_size(0)\n@@ -37,3 +37,4 @@\n-inline void ParMarkBitMap::clear_range(idx_t beg, idx_t end) {\n-  _beg_bits.clear_range(beg, end);\n-  _end_bits.clear_range(beg, end);\n+inline void ParMarkBitMap::clear_range(HeapWord* beg, HeapWord* end) {\n+  const idx_t beg_bit = addr_to_bit(beg);\n+  const idx_t end_bit = addr_to_bit(end);\n+  _beg_bits.clear_range(beg_bit, end_bit);\n@@ -43,3 +44,1 @@\n-  \/\/ Need two bits (one begin bit, one end bit) for each unit of 'object\n-  \/\/ granularity' in the heap.\n-  return words_to_bits(words * 2);\n+  return words_to_bits(words);\n@@ -68,12 +67,0 @@\n-inline bool ParMarkBitMap::is_obj_beg(idx_t bit) const {\n-  return _beg_bits.at(bit);\n-}\n-\n-inline bool ParMarkBitMap::is_obj_end(idx_t bit) const {\n-  return _end_bits.at(bit);\n-}\n-\n-inline bool ParMarkBitMap::is_marked(idx_t bit) const {\n-  return is_obj_beg(bit);\n-}\n-\n@@ -81,1 +68,1 @@\n-  return is_marked(addr_to_bit(addr));\n+  return _beg_bits.at(addr_to_bit(addr));\n@@ -88,4 +75,0 @@\n-inline bool ParMarkBitMap::is_unmarked(idx_t bit) const {\n-  return !is_marked(bit);\n-}\n-\n@@ -108,4 +91,2 @@\n-inline size_t ParMarkBitMap::obj_size(idx_t beg_bit, idx_t end_bit) const {\n-  DEBUG_ONLY(verify_bit(beg_bit);)\n-  DEBUG_ONLY(verify_bit(end_bit);)\n-  return bits_to_words(end_bit - beg_bit + 1);\n+inline bool ParMarkBitMap::mark_obj(HeapWord* addr) {\n+  return _beg_bits.par_set_bit(addr_to_bit(addr));\n@@ -114,35 +95,2 @@\n-inline size_t ParMarkBitMap::obj_size(HeapWord* beg_addr, HeapWord* end_addr) const {\n-  DEBUG_ONLY(verify_addr(beg_addr);)\n-  DEBUG_ONLY(verify_addr(end_addr);)\n-  return pointer_delta(end_addr, beg_addr) + obj_granularity();\n-}\n-\n-inline size_t ParMarkBitMap::obj_size(idx_t beg_bit) const {\n-  const idx_t end_bit = _end_bits.find_first_set_bit(beg_bit, size());\n-  assert(is_marked(beg_bit), \"obj not marked\");\n-  assert(end_bit < size(), \"end bit missing\");\n-  return obj_size(beg_bit, end_bit);\n-}\n-\n-inline size_t ParMarkBitMap::obj_size(HeapWord* addr) const {\n-  return obj_size(addr_to_bit(addr));\n-}\n-\n-inline ParMarkBitMap::IterationStatus ParMarkBitMap::iterate(ParMarkBitMapClosure* live_closure,\n-                                                             HeapWord* range_beg,\n-                                                             HeapWord* range_end) const {\n-  return iterate(live_closure, addr_to_bit(range_beg), addr_to_bit(range_end));\n-}\n-\n-inline ParMarkBitMap::IterationStatus ParMarkBitMap::iterate(ParMarkBitMapClosure* live_closure,\n-                                                             ParMarkBitMapClosure* dead_closure,\n-                                                             HeapWord* range_beg,\n-                                                             HeapWord* range_end,\n-                                                             HeapWord* dead_range_end) const {\n-  return iterate(live_closure, dead_closure,\n-                 addr_to_bit(range_beg), addr_to_bit(range_end),\n-                 addr_to_bit(dead_range_end));\n-}\n-\n-inline bool ParMarkBitMap::mark_obj(oop obj, size_t size) {\n-  return mark_obj(cast_from_oop<HeapWord*>(obj), size);\n+inline bool ParMarkBitMap::mark_obj(oop obj) {\n+  return mark_obj(cast_from_oop<HeapWord*>(obj));\n@@ -167,8 +115,0 @@\n-inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_beg(idx_t beg, idx_t end) const {\n-  return _beg_bits.find_first_set_bit_aligned_right(beg, end);\n-}\n-\n-inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_end(idx_t beg, idx_t end) const {\n-  return _end_bits.find_first_set_bit_aligned_right(beg, end);\n-}\n-\n@@ -179,1 +119,2 @@\n-  const idx_t res_bit = MIN2(find_obj_beg(beg_bit, search_end), end_bit);\n+  const idx_t res_bit = MIN2(_beg_bits.find_first_set_bit_aligned_right(beg_bit, search_end),\n+                             end_bit);\n@@ -183,1 +124,1 @@\n-inline HeapWord* ParMarkBitMap::find_obj_end(HeapWord* beg, HeapWord* end) const {\n+inline HeapWord* ParMarkBitMap::find_obj_beg_reverse(HeapWord* beg, HeapWord* end) const {\n@@ -186,2 +127,1 @@\n-  const idx_t search_end = align_range_end(end_bit);\n-  const idx_t res_bit = MIN2(find_obj_end(beg_bit, search_end), end_bit);\n+  const idx_t res_bit = _beg_bits.find_last_set_bit_aligned_left(beg_bit, end_bit);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.inline.hpp","additions":15,"deletions":75,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -55,1 +56,3 @@\n-ParCompactionManager::ParCompactionManager() {\n+PreservedMarksSet* ParCompactionManager::_preserved_marks_set = nullptr;\n+\n+ParCompactionManager::ParCompactionManager(PreservedMarks* preserved_marks) {\n@@ -62,3 +65,1 @@\n-  reset_bitmap_query_cache();\n-\n-  _deferred_obj_array = new (mtGC) GrowableArray<HeapWord*>(10, mtGC);\n+  _preserved_marks = preserved_marks;\n@@ -83,0 +84,3 @@\n+  _preserved_marks_set = new PreservedMarksSet(true);\n+  _preserved_marks_set->init(parallel_gc_threads);\n+\n@@ -85,1 +89,1 @@\n-    _manager_array[i] = new ParCompactionManager();\n+    _manager_array[i] = new ParCompactionManager(_preserved_marks_set->get(i));\n@@ -97,1 +101,0 @@\n-}\n@@ -99,5 +102,0 @@\n-void ParCompactionManager::reset_all_bitmap_query_caches() {\n-  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n-  for (uint i=0; i<parallel_gc_threads; i++) {\n-    _manager_array[i]->reset_bitmap_query_cache();\n-  }\n@@ -172,9 +170,0 @@\n-void ParCompactionManager::drain_deferred_objects() {\n-  while (!_deferred_obj_array->is_empty()) {\n-    HeapWord* addr = _deferred_obj_array->pop();\n-    assert(addr != nullptr, \"expected a deferred object\");\n-    PSParallelCompact::update_deferred_object(this, addr);\n-  }\n-  _deferred_obj_array->clear_and_deallocate();\n-}\n-\n@@ -211,4 +200,0 @@\n-void ParCompactionManager::push_deferred_object(HeapWord* addr) {\n-  _deferred_obj_array->push(addr);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/preservedMarks.hpp\"\n@@ -48,1 +49,1 @@\n-  friend class UpdateDensePrefixAndCompactionTask;\n+  friend class FillDensePrefixAndCompactionTask;\n@@ -78,1 +79,2 @@\n-  GrowableArray<HeapWord*>*    _deferred_obj_array;\n+  static PreservedMarksSet* _preserved_marks_set;\n+  PreservedMarks* _preserved_marks;\n@@ -90,4 +92,0 @@\n-  HeapWord* _last_query_beg;\n-  oop _last_query_obj;\n-  size_t _last_query_ret;\n-\n@@ -109,1 +107,1 @@\n-  ParCompactionManager();\n+  ParCompactionManager(PreservedMarks* preserved_marks);\n@@ -156,8 +154,0 @@\n-  void push_deferred_object(HeapWord* addr);\n-\n-  void reset_bitmap_query_cache() {\n-    _last_query_beg = nullptr;\n-    _last_query_obj = nullptr;\n-    _last_query_ret = 0;\n-  }\n-\n@@ -168,11 +158,0 @@\n-  \/\/ Bitmap query support, cache last query and result\n-  HeapWord* last_query_begin() { return _last_query_beg; }\n-  oop last_query_object() { return _last_query_obj; }\n-  size_t last_query_return() { return _last_query_ret; }\n-\n-  void set_last_query_begin(HeapWord *new_beg) { _last_query_beg = new_beg; }\n-  void set_last_query_object(oop new_obj) { _last_query_obj = new_obj; }\n-  void set_last_query_return(size_t new_ret) { _last_query_ret = new_ret; }\n-\n-  static void reset_all_bitmap_query_caches();\n-\n@@ -187,0 +166,3 @@\n+  PreservedMarks* preserved_marks() const {\n+    return _preserved_marks;\n+  }\n@@ -211,1 +193,0 @@\n-  void drain_deferred_objects();\n@@ -216,2 +197,0 @@\n-  void update_contents(oop obj);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":8,"deletions":29,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -160,7 +160,0 @@\n-inline void ParCompactionManager::update_contents(oop obj) {\n-  if (!obj->klass()->is_typeArray_klass()) {\n-    PCAdjustPointerClosure apc(this);\n-    obj->oop_iterate(&apc);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/parallel\/objectStartArray.inline.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -102,0 +104,1 @@\n+static_assert(ParallelCompactData::RegionSize >= BitsPerWord, \"region-start bit word-aligned\");\n@@ -108,12 +111,0 @@\n-const size_t ParallelCompactData::Log2BlockSize   = 7; \/\/ 128 words\n-const size_t ParallelCompactData::BlockSize       = (size_t)1 << Log2BlockSize;\n-const size_t ParallelCompactData::BlockSizeBytes  =\n-  BlockSize << LogHeapWordSize;\n-const size_t ParallelCompactData::BlockSizeOffsetMask = BlockSize - 1;\n-const size_t ParallelCompactData::BlockAddrOffsetMask = BlockSizeBytes - 1;\n-const size_t ParallelCompactData::BlockAddrMask       = ~BlockAddrOffsetMask;\n-\n-const size_t ParallelCompactData::BlocksPerRegion = RegionSize \/ BlockSize;\n-const size_t ParallelCompactData::Log2BlocksPerRegion =\n-  Log2RegionSize - Log2BlockSize;\n-\n@@ -416,4 +407,1 @@\n-  _region_count(0),\n-  _block_vspace(nullptr),\n-  _block_data(nullptr),\n-  _block_count(0) {}\n+  _region_count(0) {}\n@@ -430,2 +418,1 @@\n-  bool result = initialize_region_data(heap_size) && initialize_block_data();\n-  return result;\n+  return initialize_region_data(heap_size);\n@@ -477,13 +464,0 @@\n-bool ParallelCompactData::initialize_block_data()\n-{\n-  assert(_region_count != 0, \"region data must be initialized first\");\n-  const size_t count = _region_count << Log2BlocksPerRegion;\n-  _block_vspace = create_vspace(count, sizeof(BlockData));\n-  if (_block_vspace != 0) {\n-    _block_data = (BlockData*)_block_vspace->reserved_low_addr();\n-    _block_count = count;\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -493,1 +467,0 @@\n-  assert(RegionSize % BlockSize == 0, \"RegionSize not a multiple of BlockSize\");\n@@ -497,18 +470,0 @@\n-\n-  const size_t beg_block = beg_region * BlocksPerRegion;\n-  const size_t block_cnt = region_cnt * BlocksPerRegion;\n-  memset(_block_data + beg_block, 0, block_cnt * sizeof(BlockData));\n-}\n-\n-HeapWord* ParallelCompactData::partial_obj_end(size_t region_idx) const\n-{\n-  const RegionData* cur_cp = region(region_idx);\n-  const RegionData* const end_cp = region(region_count() - 1);\n-\n-  HeapWord* result = region_to_addr(region_idx);\n-  if (cur_cp < end_cp) {\n-    do {\n-      result += cur_cp->partial_obj_size();\n-    } while (cur_cp->partial_obj_size() == RegionSize && ++cur_cp < end_cp);\n-  }\n-  return result;\n@@ -765,43 +720,0 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const {\n-  assert(addr != nullptr, \"Should detect null oop earlier\");\n-  assert(ParallelScavengeHeap::heap()->is_in(addr), \"not in heap\");\n-  assert(PSParallelCompact::mark_bitmap()->is_marked(addr), \"not marked\");\n-\n-  \/\/ Region covering the object.\n-  RegionData* const region_ptr = addr_to_region_ptr(addr);\n-  HeapWord* result = region_ptr->destination();\n-\n-  \/\/ If the entire Region is live, the new location is region->destination + the\n-  \/\/ offset of the object within in the Region.\n-\n-  \/\/ Run some performance tests to determine if this special case pays off.  It\n-  \/\/ is worth it for pointers into the dense prefix.  If the optimization to\n-  \/\/ avoid pointer updates in regions that only point to the dense prefix is\n-  \/\/ ever implemented, this should be revisited.\n-  if (region_ptr->data_size() == RegionSize) {\n-    result += region_offset(addr);\n-    return result;\n-  }\n-\n-  \/\/ Otherwise, the new location is region->destination + block offset + the\n-  \/\/ number of live words in the Block that are (a) to the left of addr and (b)\n-  \/\/ due to objects that start in the Block.\n-\n-  \/\/ Fill in the block table if necessary.  This is unsynchronized, so multiple\n-  \/\/ threads may fill the block table for a region (harmless, since it is\n-  \/\/ idempotent).\n-  if (!region_ptr->blocks_filled()) {\n-    PSParallelCompact::fill_blocks(addr_to_region_idx(addr));\n-    region_ptr->set_blocks_filled();\n-  }\n-\n-  HeapWord* const search_start = block_align_down(addr);\n-  const size_t block_offset = addr_to_block_ptr(addr)->offset();\n-\n-  const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();\n-  const size_t live = bitmap->live_words_in_range(cm, search_start, cast_to_oop(addr));\n-  result += block_offset + live;\n-  DEBUG_ONLY(PSParallelCompact::check_new_location(addr, result));\n-  return result;\n-}\n-\n@@ -821,1 +733,0 @@\n-  verify_clear(_block_vspace);\n@@ -835,0 +746,13 @@\n+class PCAdjustPointerClosure: public BasicOopIterateClosure {\n+  template <typename T>\n+  void do_oop_work(T* p) { PSParallelCompact::adjust_pointer(p); }\n+\n+public:\n+  virtual void do_oop(oop* p)                { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)          { do_oop_work(p); }\n+\n+  virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }\n+};\n+\n+static PCAdjustPointerClosure pc_adjust_pointer_closure;\n+\n@@ -906,3 +830,1 @@\n-  const idx_t beg_bit = _mark_bitmap.addr_to_bit(bot);\n-  const idx_t end_bit = _mark_bitmap.addr_to_bit(top);\n-  _mark_bitmap.clear_range(beg_bit, end_bit);\n+  _mark_bitmap.clear_range(bot, top);\n@@ -951,2 +873,0 @@\n-\n-  ParCompactionManager::reset_all_bitmap_query_caches();\n@@ -1083,1 +1003,0 @@\n-  idx_t const dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);\n@@ -1086,1 +1005,1 @@\n-      _mark_bitmap.is_obj_beg(dense_prefix_bit)) {\n+      _mark_bitmap.is_marked(dense_prefix_end)) {\n@@ -1091,1 +1010,3 @@\n-  if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {\n+  HeapWord* block_start = start_array(id)->block_start_reaching_into_card(dense_prefix_end);\n+  if (block_start == dense_prefix_end - 1) {\n+    assert(!_mark_bitmap.is_marked(block_start), \"inv\");\n@@ -1093,1 +1014,1 @@\n-    \/\/ The filler object will extend into the region after the last dense prefix region.\n+    \/\/ The filler object will extend into region_after_dense_prefix.\n@@ -1097,1 +1018,1 @@\n-    _mark_bitmap.mark_obj(obj_beg, obj_len);\n+    _mark_bitmap.mark_obj(obj_beg);\n@@ -1363,3 +1284,3 @@\n-    \/\/ adjust_roots() updates Universe::_intArrayKlass which is\n-    \/\/ needed by the compaction for filling holes in the dense prefix.\n-    adjust_roots();\n+    forward_to_new_addr();\n+\n+    adjust_pointers();\n@@ -1369,0 +1290,2 @@\n+    ParCompactionManager::_preserved_marks_set->restore(&ParallelScavengeHeap::heap()->workers());\n+\n@@ -1689,0 +1612,78 @@\n+template<typename Func>\n+void PSParallelCompact::adjust_in_space_helper(SpaceId id, volatile uint* claim_counter, Func&& on_stripe) {\n+  MutableSpace* sp = PSParallelCompact::space(id);\n+  HeapWord* const bottom = sp->bottom();\n+  HeapWord* const top = sp->top();\n+  if (bottom == top) {\n+    return;\n+  }\n+\n+  const uint num_regions_per_stripe = 2;\n+  const size_t region_size = ParallelCompactData::RegionSize;\n+  const size_t stripe_size = num_regions_per_stripe * region_size;\n+\n+  while (true) {\n+    uint counter = Atomic::fetch_then_add(claim_counter, num_regions_per_stripe);\n+    HeapWord* cur_stripe = bottom + counter * region_size;\n+    if (cur_stripe >= top) {\n+      break;\n+    }\n+    HeapWord* stripe_end = MIN2(cur_stripe + stripe_size, top);\n+    on_stripe(cur_stripe, stripe_end);\n+  }\n+}\n+\n+void PSParallelCompact::adjust_in_old_space(volatile uint* claim_counter) {\n+  \/\/ Regions in old-space shouldn't be split.\n+  assert(!_space_info[old_space_id].split_info().is_valid(), \"inv\");\n+\n+  auto scan_obj_with_limit = [&] (HeapWord* obj_start, HeapWord* left, HeapWord* right) {\n+    assert(mark_bitmap()->is_marked(obj_start), \"inv\");\n+    oop obj = cast_to_oop(obj_start);\n+    return obj->oop_iterate_size(&pc_adjust_pointer_closure, MemRegion(left, right));\n+  };\n+\n+  adjust_in_space_helper(old_space_id, claim_counter, [&] (HeapWord* stripe_start, HeapWord* stripe_end) {\n+    assert(_summary_data.is_region_aligned(stripe_start), \"inv\");\n+    RegionData* cur_region = _summary_data.addr_to_region_ptr(stripe_start);\n+    HeapWord* obj_start;\n+    if (cur_region->partial_obj_size() != 0) {\n+      obj_start = cur_region->partial_obj_addr();\n+      obj_start += scan_obj_with_limit(obj_start, stripe_start, stripe_end);\n+    } else {\n+      obj_start = stripe_start;\n+    }\n+\n+    while (obj_start < stripe_end) {\n+      obj_start = mark_bitmap()->find_obj_beg(obj_start, stripe_end);\n+      if (obj_start >= stripe_end) {\n+        break;\n+      }\n+      obj_start += scan_obj_with_limit(obj_start, stripe_start, stripe_end);\n+    }\n+  });\n+}\n+\n+void PSParallelCompact::adjust_in_young_space(SpaceId id, volatile uint* claim_counter) {\n+  adjust_in_space_helper(id, claim_counter, [](HeapWord* stripe_start, HeapWord* stripe_end) {\n+    HeapWord* obj_start = stripe_start;\n+    while (obj_start < stripe_end) {\n+      obj_start = mark_bitmap()->find_obj_beg(obj_start, stripe_end);\n+      if (obj_start >= stripe_end) {\n+        break;\n+      }\n+      oop obj = cast_to_oop(obj_start);\n+      obj_start += obj->oop_iterate_size(&pc_adjust_pointer_closure);\n+    }\n+  });\n+}\n+\n+void PSParallelCompact::adjust_pointers_in_spaces(uint worker_id, volatile uint* claim_counters) {\n+  auto start_time = Ticks::now();\n+  adjust_in_old_space(&claim_counters[0]);\n+  for (uint id = eden_space_id; id < last_space_id; ++id) {\n+    adjust_in_young_space(SpaceId(id), &claim_counters[id]);\n+  }\n+  log_trace(gc, phases)(\"adjust_pointers_in_spaces worker %u: %.3f ms\", worker_id, (Ticks::now() - start_time).seconds() * 1000);\n+}\n+\n@@ -1694,0 +1695,1 @@\n+  volatile uint _claim_counters[PSParallelCompact::last_space_id] = {};\n@@ -1720,1 +1722,5 @@\n-    PCAdjustPointerClosure adjust(cm);\n+    cm->preserved_marks()->adjust_during_full_gc();\n+    {\n+      \/\/ adjust pointers in all spaces\n+      PSParallelCompact::adjust_pointers_in_spaces(worker_id, _claim_counters);\n+    }\n@@ -1723,1 +1729,1 @@\n-      Threads::possibly_parallel_oops_do(_nworkers > 1, &adjust, nullptr);\n+      Threads::possibly_parallel_oops_do(_nworkers > 1, &pc_adjust_pointer_closure, nullptr);\n@@ -1725,1 +1731,1 @@\n-    _oop_storage_iter.oops_do(&adjust);\n+    _oop_storage_iter.oops_do(&pc_adjust_pointer_closure);\n@@ -1727,1 +1733,1 @@\n-      CLDToOopClosure cld_closure(&adjust, ClassLoaderData::_claim_stw_fullgc_adjust);\n+      CLDToOopClosure cld_closure(&pc_adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n@@ -1732,1 +1738,1 @@\n-      _weak_proc_task.work(worker_id, &always_alive, &adjust);\n+      _weak_proc_task.work(worker_id, &always_alive, &pc_adjust_pointer_closure);\n@@ -1735,1 +1741,1 @@\n-      NMethodToOopClosure adjust_code(&adjust, NMethodToOopClosure::FixRelocations);\n+      NMethodToOopClosure adjust_code(&pc_adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n@@ -1742,1 +1748,1 @@\n-void PSParallelCompact::adjust_roots() {\n+void PSParallelCompact::adjust_pointers() {\n@@ -1744,1 +1750,1 @@\n-  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+  GCTraceTime(Info, gc, phases) tm(\"Adjust Pointers\", &_gc_timer);\n@@ -1750,0 +1756,125 @@\n+\/\/ Split [start, end) evenly for a number of workers and return the\n+\/\/ range for worker_id.\n+static void split_regions_for_worker(size_t start, size_t end,\n+                                     uint worker_id, uint num_workers,\n+                                     size_t* worker_start, size_t* worker_end) {\n+  assert(start < end, \"precondition\");\n+  assert(num_workers > 0, \"precondition\");\n+  assert(worker_id < num_workers, \"precondition\");\n+\n+  size_t num_regions = end - start;\n+  size_t num_regions_per_worker = num_regions \/ num_workers;\n+  size_t remainder = num_regions % num_workers;\n+  \/\/ The first few workers will get one extra.\n+  *worker_start = start + worker_id * num_regions_per_worker\n+                  + MIN2(checked_cast<size_t>(worker_id), remainder);\n+  *worker_end = *worker_start + num_regions_per_worker\n+                + (worker_id < remainder ? 1 : 0);\n+}\n+\n+void PSParallelCompact::forward_to_new_addr() {\n+  GCTraceTime(Info, gc, phases) tm(\"Forward\", &_gc_timer);\n+  uint nworkers = ParallelScavengeHeap::heap()->workers().active_workers();\n+\n+  struct ForwardTask final : public WorkerTask {\n+    uint _num_workers;\n+\n+    explicit ForwardTask(uint num_workers) :\n+      WorkerTask(\"PSForward task\"),\n+      _num_workers(num_workers) {}\n+\n+    void work(uint worker_id) override {\n+      ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+      for (uint id = old_space_id; id < last_space_id; ++id) {\n+        MutableSpace* sp = PSParallelCompact::space(SpaceId(id));\n+        HeapWord* dense_prefix_addr = dense_prefix(SpaceId(id));\n+        HeapWord* top = sp->top();\n+\n+        if (dense_prefix_addr == top) {\n+          continue;\n+        }\n+\n+        size_t dense_prefix_region = _summary_data.addr_to_region_idx(dense_prefix_addr);\n+        size_t top_region = _summary_data.addr_to_region_idx(_summary_data.region_align_up(top));\n+        size_t start_region;\n+        size_t end_region;\n+        split_regions_for_worker(dense_prefix_region, top_region,\n+                                 worker_id, _num_workers,\n+                                 &start_region, &end_region);\n+        for (size_t cur_region = start_region; cur_region < end_region; ++cur_region) {\n+          RegionData* region_ptr = _summary_data.region(cur_region);\n+          size_t live_words = region_ptr->partial_obj_size();\n+\n+          if (live_words == ParallelCompactData::RegionSize) {\n+            \/\/ No obj-start\n+            continue;\n+          }\n+\n+          HeapWord* region_start = _summary_data.region_to_addr(cur_region);\n+          HeapWord* region_end = region_start + ParallelCompactData::RegionSize;\n+\n+          HeapWord* cur_addr = region_start + live_words;\n+\n+          HeapWord* destination = region_ptr->destination();\n+          while (cur_addr < region_end) {\n+            cur_addr = mark_bitmap()->find_obj_beg(cur_addr, region_end);\n+            if (cur_addr >= region_end) {\n+              break;\n+            }\n+            assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+            HeapWord* new_addr = destination + live_words;\n+            oop obj = cast_to_oop(cur_addr);\n+            if (new_addr != cur_addr) {\n+              cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+              obj->forward_to(cast_to_oop(new_addr));\n+            }\n+            size_t obj_size = obj->size();\n+            live_words += obj_size;\n+            cur_addr += obj_size;\n+          }\n+        }\n+      }\n+    }\n+  } task(nworkers);\n+\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  debug_only(verify_forward();)\n+}\n+\n+#ifdef ASSERT\n+void PSParallelCompact::verify_forward() {\n+  HeapWord* old_dense_prefix_addr = dense_prefix(SpaceId(old_space_id));\n+  RegionData* old_region = _summary_data.region(_summary_data.addr_to_region_idx(old_dense_prefix_addr));\n+  HeapWord* bump_ptr = old_region->partial_obj_size() != 0\n+                       ? old_dense_prefix_addr + old_region->partial_obj_size()\n+                       : old_dense_prefix_addr;\n+  SpaceId bump_ptr_space = old_space_id;\n+\n+  for (uint id = old_space_id; id < last_space_id; ++id) {\n+    MutableSpace* sp = PSParallelCompact::space(SpaceId(id));\n+    HeapWord* dense_prefix_addr = dense_prefix(SpaceId(id));\n+    HeapWord* top = sp->top();\n+    HeapWord* cur_addr = dense_prefix_addr;\n+\n+    while (cur_addr < top) {\n+      cur_addr = mark_bitmap()->find_obj_beg(cur_addr, top);\n+      if (cur_addr >= top) {\n+        break;\n+      }\n+      assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+      \/\/ Move to the space containing cur_addr\n+      if (bump_ptr == _space_info[bump_ptr_space].new_top()) {\n+        bump_ptr = space(space_id(cur_addr))->bottom();\n+        bump_ptr_space = space_id(bump_ptr);\n+      }\n+      oop obj = cast_to_oop(cur_addr);\n+      if (cur_addr != bump_ptr) {\n+        assert(obj->forwardee() == cast_to_oop(bump_ptr), \"inv\");\n+      }\n+      bump_ptr += obj->size();\n+      cur_addr += obj->size();\n+    }\n+  }\n+}\n+#endif\n+\n@@ -1830,154 +1961,0 @@\n-class TaskQueue : StackObj {\n-  volatile uint _counter;\n-  uint _size;\n-  uint _insert_index;\n-  PSParallelCompact::UpdateDensePrefixTask* _backing_array;\n-public:\n-  explicit TaskQueue(uint size) : _counter(0), _size(size), _insert_index(0), _backing_array(nullptr) {\n-    _backing_array = NEW_C_HEAP_ARRAY(PSParallelCompact::UpdateDensePrefixTask, _size, mtGC);\n-  }\n-  ~TaskQueue() {\n-    assert(_counter >= _insert_index, \"not all queue elements were claimed\");\n-    FREE_C_HEAP_ARRAY(T, _backing_array);\n-  }\n-\n-  void push(const PSParallelCompact::UpdateDensePrefixTask& value) {\n-    assert(_insert_index < _size, \"too small backing array\");\n-    _backing_array[_insert_index++] = value;\n-  }\n-\n-  bool try_claim(PSParallelCompact::UpdateDensePrefixTask& reference) {\n-    uint claimed = Atomic::fetch_then_add(&_counter, 1u);\n-    if (claimed < _insert_index) {\n-      reference = _backing_array[claimed];\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-};\n-\n-#define PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING 4\n-\n-void PSParallelCompact::enqueue_dense_prefix_tasks(TaskQueue& task_queue,\n-                                                   uint parallel_gc_threads) {\n-  GCTraceTime(Trace, gc, phases) tm(\"Dense Prefix Task Setup\", &_gc_timer);\n-\n-  ParallelCompactData& sd = PSParallelCompact::summary_data();\n-\n-  \/\/ Iterate over all the spaces adding tasks for updating\n-  \/\/ regions in the dense prefix.  Assume that 1 gc thread\n-  \/\/ will work on opening the gaps and the remaining gc threads\n-  \/\/ will work on the dense prefix.\n-  unsigned int space_id;\n-  for (space_id = old_space_id; space_id < last_space_id; ++ space_id) {\n-    HeapWord* const dense_prefix_end = _space_info[space_id].dense_prefix();\n-    const MutableSpace* const space = _space_info[space_id].space();\n-\n-    if (dense_prefix_end == space->bottom()) {\n-      \/\/ There is no dense prefix for this space.\n-      continue;\n-    }\n-\n-    \/\/ The dense prefix is before this region.\n-    size_t region_index_end_dense_prefix =\n-        sd.addr_to_region_idx(dense_prefix_end);\n-    RegionData* const dense_prefix_cp =\n-      sd.region(region_index_end_dense_prefix);\n-    assert(dense_prefix_end == space->end() ||\n-           dense_prefix_cp->available() ||\n-           dense_prefix_cp->claimed(),\n-           \"The region after the dense prefix should always be ready to fill\");\n-\n-    size_t region_index_start = sd.addr_to_region_idx(space->bottom());\n-\n-    \/\/ Is there dense prefix work?\n-    size_t total_dense_prefix_regions =\n-      region_index_end_dense_prefix - region_index_start;\n-    \/\/ How many regions of the dense prefix should be given to\n-    \/\/ each thread?\n-    if (total_dense_prefix_regions > 0) {\n-      uint tasks_for_dense_prefix = 1;\n-      if (total_dense_prefix_regions <=\n-          (parallel_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)) {\n-        \/\/ Don't over partition.  This assumes that\n-        \/\/ PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING is a small integer value\n-        \/\/ so there are not many regions to process.\n-        tasks_for_dense_prefix = parallel_gc_threads;\n-      } else {\n-        \/\/ Over partition\n-        tasks_for_dense_prefix = parallel_gc_threads *\n-          PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING;\n-      }\n-      size_t regions_per_thread = total_dense_prefix_regions \/\n-        tasks_for_dense_prefix;\n-      \/\/ Give each thread at least 1 region.\n-      if (regions_per_thread == 0) {\n-        regions_per_thread = 1;\n-      }\n-\n-      for (uint k = 0; k < tasks_for_dense_prefix; k++) {\n-        if (region_index_start >= region_index_end_dense_prefix) {\n-          break;\n-        }\n-        \/\/ region_index_end is not processed\n-        size_t region_index_end = MIN2(region_index_start + regions_per_thread,\n-                                       region_index_end_dense_prefix);\n-        task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),\n-                                              region_index_start,\n-                                              region_index_end));\n-        region_index_start = region_index_end;\n-      }\n-    }\n-    \/\/ This gets any part of the dense prefix that did not\n-    \/\/ fit evenly.\n-    if (region_index_start < region_index_end_dense_prefix) {\n-      task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),\n-                                            region_index_start,\n-                                            region_index_end_dense_prefix));\n-    }\n-  }\n-}\n-\n-#ifdef ASSERT\n-\/\/ Write a histogram of the number of times the block table was filled for a\n-\/\/ region.\n-void PSParallelCompact::write_block_fill_histogram()\n-{\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n-    return;\n-  }\n-\n-  Log(gc, compaction) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n-  outputStream* out = &ls;\n-\n-  typedef ParallelCompactData::RegionData rd_t;\n-  ParallelCompactData& sd = summary_data();\n-\n-  for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-    MutableSpace* const spc = _space_info[id].space();\n-    if (spc->bottom() != spc->top()) {\n-      const rd_t* const beg = sd.addr_to_region_ptr(spc->bottom());\n-      HeapWord* const top_aligned_up = sd.region_align_up(spc->top());\n-      const rd_t* const end = sd.addr_to_region_ptr(top_aligned_up);\n-\n-      size_t histo[5] = { 0, 0, 0, 0, 0 };\n-      const size_t histo_len = sizeof(histo) \/ sizeof(size_t);\n-      const size_t region_cnt = pointer_delta(end, beg, sizeof(rd_t));\n-\n-      for (const rd_t* cur = beg; cur < end; ++cur) {\n-        ++histo[MIN2(cur->blocks_filled_count(), histo_len - 1)];\n-      }\n-      out->print(\"Block fill histogram: %u %-4s\" SIZE_FORMAT_W(5), id, space_names[id], region_cnt);\n-      for (size_t i = 0; i < histo_len; ++i) {\n-        out->print(\" \" SIZE_FORMAT_W(5) \" %5.1f%%\",\n-                   histo[i], 100.0 * histo[i] \/ region_cnt);\n-      }\n-      out->cr();\n-    }\n-  }\n-}\n-#endif \/\/ #ifdef ASSERT\n-\n@@ -2016,2 +1993,2 @@\n-class UpdateDensePrefixAndCompactionTask: public WorkerTask {\n-  TaskQueue& _tq;\n+class FillDensePrefixAndCompactionTask: public WorkerTask {\n+  uint _num_workers;\n@@ -2021,3 +1998,3 @@\n-  UpdateDensePrefixAndCompactionTask(TaskQueue& tq, uint active_workers) :\n-      WorkerTask(\"UpdateDensePrefixAndCompactionTask\"),\n-      _tq(tq),\n+  FillDensePrefixAndCompactionTask(uint active_workers) :\n+      WorkerTask(\"FillDensePrefixAndCompactionTask\"),\n+      _num_workers(active_workers),\n@@ -2026,0 +2003,1 @@\n+\n@@ -2027,1 +2005,8 @@\n-    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    {\n+      auto start = Ticks::now();\n+      PSParallelCompact::fill_dead_objs_in_dense_prefix(worker_id, _num_workers);\n+      log_trace(gc, phases)(\"Fill dense prefix by worker %u: %.3f ms\", worker_id, (Ticks::now() - start).seconds() * 1000);\n+    }\n+    compaction_with_stealing_work(&_terminator, worker_id);\n+  }\n+};\n@@ -2029,5 +2014,10 @@\n-    for (PSParallelCompact::UpdateDensePrefixTask task; _tq.try_claim(task); \/* empty *\/) {\n-      PSParallelCompact::update_and_deadwood_in_dense_prefix(cm,\n-                                                             task._space_id,\n-                                                             task._region_index_start,\n-                                                             task._region_index_end);\n+void PSParallelCompact::fill_range_in_dense_prefix(HeapWord* start, HeapWord* end) {\n+#ifdef ASSERT\n+  {\n+    assert(start < end, \"precondition\");\n+    assert(mark_bitmap()->find_obj_beg(start, end) == end, \"precondition\");\n+    HeapWord* bottom = _space_info[old_space_id].space()->bottom();\n+    if (start != bottom) {\n+      HeapWord* obj_start = mark_bitmap()->find_obj_beg_reverse(bottom, start);\n+      HeapWord* after_obj = obj_start + cast_to_oop(obj_start)->size();\n+      assert(after_obj == start, \"precondition\");\n@@ -2035,0 +2025,2 @@\n+  }\n+#endif\n@@ -2036,3 +2028,11 @@\n-    \/\/ Once a thread has drained it's stack, it should try to steal regions from\n-    \/\/ other threads.\n-    compaction_with_stealing_work(&_terminator, worker_id);\n+  CollectedHeap::fill_with_objects(start, pointer_delta(end, start));\n+  HeapWord* addr = start;\n+  do {\n+    size_t size = cast_to_oop(addr)->size();\n+    start_array(old_space_id)->update_for_block(addr, addr + size);\n+    addr += size;\n+  } while (addr < end);\n+}\n+\n+void PSParallelCompact::fill_dead_objs_in_dense_prefix(uint worker_id, uint num_workers) {\n+  ParMarkBitMap* bitmap = mark_bitmap();\n@@ -2040,3 +2040,5 @@\n-    \/\/ At this point all regions have been compacted, so it's now safe\n-    \/\/ to update the deferred objects that cross region boundaries.\n-    cm->drain_deferred_objects();\n+  HeapWord* const bottom = _space_info[old_space_id].space()->bottom();\n+  HeapWord* const prefix_end = dense_prefix(old_space_id);\n+\n+  if (bottom == prefix_end) {\n+    return;\n@@ -2044,1 +2046,45 @@\n-};\n+\n+  size_t bottom_region = _summary_data.addr_to_region_idx(bottom);\n+  size_t prefix_end_region = _summary_data.addr_to_region_idx(prefix_end);\n+\n+  size_t start_region;\n+  size_t end_region;\n+  split_regions_for_worker(bottom_region, prefix_end_region,\n+                           worker_id, num_workers,\n+                           &start_region, &end_region);\n+\n+  if (start_region == end_region) {\n+    return;\n+  }\n+\n+  HeapWord* const start_addr = _summary_data.region_to_addr(start_region);\n+  HeapWord* const end_addr = _summary_data.region_to_addr(end_region);\n+\n+  \/\/ Skip live partial obj (if any) from previous region.\n+  HeapWord* cur_addr;\n+  RegionData* start_region_ptr = _summary_data.region(start_region);\n+  if (start_region_ptr->partial_obj_size() != 0) {\n+    HeapWord* partial_obj_start = start_region_ptr->partial_obj_addr();\n+    assert(bitmap->is_marked(partial_obj_start), \"inv\");\n+    cur_addr = partial_obj_start + cast_to_oop(partial_obj_start)->size();\n+  } else {\n+    cur_addr = start_addr;\n+  }\n+\n+  \/\/ end_addr is inclusive to handle regions starting with dead space.\n+  while (cur_addr <= end_addr) {\n+    \/\/ Use prefix_end to handle trailing obj in each worker region-chunk.\n+    HeapWord* live_start = bitmap->find_obj_beg(cur_addr, prefix_end);\n+    if (cur_addr != live_start) {\n+      \/\/ Only worker 0 handles proceeding dead space.\n+      if (cur_addr != start_addr || worker_id == 0) {\n+        fill_range_in_dense_prefix(cur_addr, live_start);\n+      }\n+    }\n+    if (live_start >= end_addr) {\n+      break;\n+    }\n+    assert(bitmap->is_marked(live_start), \"inv\");\n+    cur_addr = live_start + cast_to_oop(live_start)->size();\n+  }\n+}\n@@ -2049,2 +2095,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  PSOldGen* old_gen = heap->old_gen();\n@@ -2053,7 +2097,0 @@\n-  \/\/ for [0..last_space_id)\n-  \/\/     for [0..active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)\n-  \/\/         push\n-  \/\/     push\n-  \/\/\n-  \/\/ max push count is thus: last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1)\n-  TaskQueue task_queue(last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1));\n@@ -2062,1 +2099,0 @@\n-  enqueue_dense_prefix_tasks(task_queue, active_gc_threads);\n@@ -2067,1 +2103,1 @@\n-    UpdateDensePrefixAndCompactionTask task(task_queue, active_gc_threads);\n+    FillDensePrefixAndCompactionTask task(active_gc_threads);\n@@ -2071,0 +2107,2 @@\n+    verify_filler_in_dense_prefix();\n+\n@@ -2077,2 +2115,0 @@\n-\n-  DEBUG_ONLY(write_block_fill_histogram());\n@@ -2082,0 +2118,15 @@\n+void PSParallelCompact::verify_filler_in_dense_prefix() {\n+  HeapWord* bottom = _space_info[old_space_id].space()->bottom();\n+  HeapWord* dense_prefix_end = dense_prefix(old_space_id);\n+  HeapWord* cur_addr = bottom;\n+  while (cur_addr < dense_prefix_end) {\n+    oop obj = cast_to_oop(cur_addr);\n+    oopDesc::verify(obj);\n+    if (!mark_bitmap()->is_marked(cur_addr)) {\n+      Klass* k = cast_to_oop(cur_addr)->klass_without_asserts();\n+      assert(k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass(), \"inv\");\n+    }\n+    cur_addr += obj->size();\n+  }\n+}\n+\n@@ -2121,66 +2172,0 @@\n-inline void UpdateOnlyClosure::do_addr(HeapWord* addr) {\n-  compaction_manager()->update_contents(cast_to_oop(addr));\n-}\n-\n-\/\/ Update interior oops in the ranges of regions [beg_region, end_region).\n-void\n-PSParallelCompact::update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,\n-                                                       SpaceId space_id,\n-                                                       size_t beg_region,\n-                                                       size_t end_region) {\n-  ParallelCompactData& sd = summary_data();\n-  ParMarkBitMap* const mbm = mark_bitmap();\n-\n-  HeapWord* beg_addr = sd.region_to_addr(beg_region);\n-  HeapWord* const end_addr = sd.region_to_addr(end_region);\n-  assert(beg_region <= end_region, \"bad region range\");\n-  assert(end_addr <= dense_prefix(space_id), \"not in the dense prefix\");\n-\n-#ifdef  ASSERT\n-  \/\/ Claim the regions to avoid triggering an assert when they are marked as\n-  \/\/ filled.\n-  for (size_t claim_region = beg_region; claim_region < end_region; ++claim_region) {\n-    assert(sd.region(claim_region)->claim_unsafe(), \"claim() failed\");\n-  }\n-#endif  \/\/ #ifdef ASSERT\n-  HeapWord* const space_bottom = space(space_id)->bottom();\n-\n-  \/\/ Check if it's the first region in this space.\n-  if (beg_addr != space_bottom) {\n-    \/\/ Find the first live object or block of dead space that *starts* in this\n-    \/\/ range of regions.  If a partial object crosses onto the region, skip it;\n-    \/\/ it will be marked for 'deferred update' when the object head is\n-    \/\/ processed.  If dead space crosses onto the region, it is also skipped; it\n-    \/\/ will be filled when the prior region is processed.  If neither of those\n-    \/\/ apply, the first word in the region is the start of a live object or dead\n-    \/\/ space.\n-    assert(beg_addr > space(space_id)->bottom(), \"sanity\");\n-    const RegionData* const cp = sd.region(beg_region);\n-    if (cp->partial_obj_size() != 0) {\n-      beg_addr = sd.partial_obj_end(beg_region);\n-    } else {\n-      idx_t beg_bit = mbm->addr_to_bit(beg_addr);\n-      if (!mbm->is_obj_beg(beg_bit) && !mbm->is_obj_end(beg_bit - 1)) {\n-        beg_addr = mbm->find_obj_beg(beg_addr, end_addr);\n-      }\n-    }\n-  }\n-\n-  if (beg_addr < end_addr) {\n-    \/\/ A live object or block of dead space starts in this range of Regions.\n-     HeapWord* const dense_prefix_end = dense_prefix(space_id);\n-\n-    \/\/ Create closures and iterate.\n-    UpdateOnlyClosure update_closure(mbm, cm, space_id);\n-    FillClosure fill_closure(cm, space_id);\n-    mbm->iterate(&update_closure, &fill_closure, beg_addr, end_addr, dense_prefix_end);\n-  }\n-\n-  \/\/ Mark the regions as filled.\n-  RegionData* const beg_cp = sd.region(beg_region);\n-  RegionData* const end_cp = sd.region(end_region);\n-  for (RegionData* cp = beg_cp; cp < end_cp; ++cp) {\n-    cp->set_completed();\n-  }\n-}\n-\n@@ -2203,18 +2188,0 @@\n-void PSParallelCompact::update_deferred_object(ParCompactionManager* cm, HeapWord *addr) {\n-#ifdef ASSERT\n-  ParallelCompactData& sd = summary_data();\n-  size_t region_idx = sd.addr_to_region_idx(addr);\n-  assert(sd.region(region_idx)->completed(), \"first region must be completed before deferred updates\");\n-  assert(sd.region(region_idx + 1)->completed(), \"second region must be completed before deferred updates\");\n-#endif\n-\n-  const SpaceInfo* const space_info = _space_info + space_id(addr);\n-  ObjectStartArray* const start_array = space_info->start_array();\n-  if (start_array != nullptr) {\n-    start_array->update_for_block(addr, addr + cast_to_oop(addr)->size());\n-  }\n-\n-  cm->update_contents(cast_to_oop(addr));\n-  assert(oopDesc::is_oop(cast_to_oop(addr)), \"Expected an oop at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n-}\n-\n@@ -2232,10 +2199,8 @@\n-  idx_t bits_to_skip = m->words_to_bits(count);\n-  idx_t cur_beg = m->addr_to_bit(beg);\n-  const idx_t search_end = m->align_range_end(m->addr_to_bit(end));\n-\n-  do {\n-    cur_beg = m->find_obj_beg(cur_beg, search_end);\n-    idx_t cur_end = m->find_obj_end(cur_beg, search_end);\n-    const size_t obj_bits = cur_end - cur_beg + 1;\n-    if (obj_bits > bits_to_skip) {\n-      return m->bit_to_addr(cur_beg + bits_to_skip);\n+  HeapWord* cur_addr = beg;\n+  while (true) {\n+    cur_addr = m->find_obj_beg(cur_addr, end);\n+    assert(cur_addr < end, \"inv\");\n+    size_t obj_size = cast_to_oop(cur_addr)->size();\n+    \/\/ Strictly greater-than\n+    if (obj_size > count) {\n+      return cur_addr + count;\n@@ -2243,9 +2208,3 @@\n-    bits_to_skip -= obj_bits;\n-    cur_beg = cur_end + 1;\n-  } while (bits_to_skip > 0);\n-\n-  \/\/ Skipping the desired number of words landed just past the end of an object.\n-  \/\/ Find the start of the next object.\n-  cur_beg = m->find_obj_beg(cur_beg, search_end);\n-  assert(cur_beg < m->addr_to_bit(end), \"not enough live words to skip\");\n-  return m->bit_to_addr(cur_beg);\n+    count -= obj_size;\n+    cur_addr += obj_size;\n+  }\n@@ -2435,0 +2394,23 @@\n+HeapWord* PSParallelCompact::partial_obj_end(HeapWord* region_start_addr) {\n+  ParallelCompactData& sd = summary_data();\n+  assert(sd.is_region_aligned(region_start_addr), \"precondition\");\n+\n+  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends to region_start_addr.\n+  SplitInfo& split_info = _space_info[space_id(region_start_addr)].split_info();\n+  size_t start_region_idx = sd.addr_to_region_idx(region_start_addr);\n+  size_t end_region_idx = sd.region_count();\n+  size_t accumulated_size = 0;\n+  for (size_t region_idx = start_region_idx; region_idx < end_region_idx; ++region_idx) {\n+    if (split_info.is_split(region_idx)) {\n+      accumulated_size += split_info.partial_obj_size();\n+      break;\n+    }\n+    size_t cur_partial_obj_size = sd.region(region_idx)->partial_obj_size();\n+    accumulated_size += cur_partial_obj_size;\n+    if (cur_partial_obj_size != ParallelCompactData::RegionSize) {\n+      break;\n+    }\n+  }\n+  return region_start_addr + accumulated_size;\n+}\n+\n@@ -2437,1 +2419,0 @@\n-  typedef ParMarkBitMap::IterationStatus IterationStatus;\n@@ -2461,1 +2442,24 @@\n-    closure.copy_partial_obj();\n+    {\n+      HeapWord* region_start = sd.region_align_down(closure.source());\n+      HeapWord* obj_start = bitmap->find_obj_beg_reverse(region_start, closure.source());\n+      HeapWord* obj_end;\n+      if (bitmap->is_marked(obj_start)) {\n+        HeapWord* next_region_start = region_start + ParallelCompactData::RegionSize;\n+        HeapWord* partial_obj_start = (next_region_start >= src_space_top)\n+                                      ? nullptr\n+                                      : sd.addr_to_region_ptr(next_region_start)->partial_obj_addr();\n+        if (partial_obj_start == obj_start) {\n+          \/\/ This obj extends to next region.\n+          obj_end = partial_obj_end(next_region_start);\n+        } else {\n+          \/\/ Completely contained in this region; safe to use size().\n+          obj_end = obj_start + cast_to_oop(obj_start)->size();\n+        }\n+      } else {\n+        \/\/ This obj extends to current region.\n+        obj_end = partial_obj_end(region_start);\n+      }\n+      size_t partial_obj_size = pointer_delta(obj_end, closure.source());\n+      closure.copy_partial_obj(partial_obj_size);\n+    }\n+\n@@ -2482,1 +2486,1 @@\n-    HeapWord* const cur_addr = closure.source();\n+    HeapWord* cur_addr = closure.source();\n@@ -2485,13 +2489,19 @@\n-    IterationStatus status = bitmap->iterate(&closure, cur_addr, end_addr);\n-\n-    if (status == ParMarkBitMap::would_overflow) {\n-      \/\/ The last object did not fit.  Note that interior oop updates were\n-      \/\/ deferred, then copy enough of the object to fill the region.\n-      cm->push_deferred_object(closure.destination());\n-      status = closure.copy_until_full(); \/\/ copies from closure.source()\n-\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n-      closure.complete_region(cm, dest_addr, region_ptr);\n-      return;\n-    }\n+    HeapWord* partial_obj_start = (end_addr == src_space_top)\n+                                ? nullptr\n+                                : sd.addr_to_region_ptr(end_addr)->partial_obj_addr();\n+    \/\/ apply closure on objs inside [cur_addr, end_addr)\n+    do {\n+      cur_addr = bitmap->find_obj_beg(cur_addr, end_addr);\n+      if (cur_addr == end_addr) {\n+        break;\n+      }\n+      size_t obj_size;\n+      if (partial_obj_start == cur_addr) {\n+        obj_size = pointer_delta(partial_obj_end(end_addr), cur_addr);\n+      } else {\n+        \/\/ This obj doesn't extend into next region; size() is safe to use.\n+        obj_size = cast_to_oop(cur_addr)->size();\n+      }\n+      closure.do_addr(cur_addr, obj_size);\n+      cur_addr += obj_size;\n+    } while (cur_addr < end_addr && !closure.is_full());\n@@ -2499,1 +2509,1 @@\n-    if (status == ParMarkBitMap::full) {\n+    if (closure.is_full()) {\n@@ -2517,1 +2527,1 @@\n-  MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);\n+  MoveAndUpdateClosure cl(mark_bitmap(), region_idx);\n@@ -2531,1 +2541,1 @@\n-    MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);\n+    MoveAndUpdateClosure cl(mark_bitmap(), region_idx);\n@@ -2599,1 +2609,1 @@\n-void PSParallelCompact::fill_blocks(size_t region_idx)\n+void MoveAndUpdateClosure::copy_partial_obj(size_t partial_obj_size)\n@@ -2601,69 +2611,1 @@\n-  \/\/ Fill in the block table elements for the specified region.  Each block\n-  \/\/ table element holds the number of live words in the region that are to the\n-  \/\/ left of the first object that starts in the block.  Thus only blocks in\n-  \/\/ which an object starts need to be filled.\n-  \/\/\n-  \/\/ The algorithm scans the section of the bitmap that corresponds to the\n-  \/\/ region, keeping a running total of the live words.  When an object start is\n-  \/\/ found, if it's the first to start in the block that contains it, the\n-  \/\/ current total is written to the block table element.\n-  const size_t Log2BlockSize = ParallelCompactData::Log2BlockSize;\n-  const size_t Log2RegionSize = ParallelCompactData::Log2RegionSize;\n-  const size_t RegionSize = ParallelCompactData::RegionSize;\n-\n-  ParallelCompactData& sd = summary_data();\n-  const size_t partial_obj_size = sd.region(region_idx)->partial_obj_size();\n-  if (partial_obj_size >= RegionSize) {\n-    return; \/\/ No objects start in this region.\n-  }\n-\n-  \/\/ Ensure the first loop iteration decides that the block has changed.\n-  size_t cur_block = sd.block_count();\n-\n-  const ParMarkBitMap* const bitmap = mark_bitmap();\n-\n-  const size_t Log2BitsPerBlock = Log2BlockSize - LogMinObjAlignment;\n-  assert((size_t)1 << Log2BitsPerBlock ==\n-         bitmap->words_to_bits(ParallelCompactData::BlockSize), \"sanity\");\n-\n-  size_t beg_bit = bitmap->words_to_bits(region_idx << Log2RegionSize);\n-  const size_t range_end = beg_bit + bitmap->words_to_bits(RegionSize);\n-  size_t live_bits = bitmap->words_to_bits(partial_obj_size);\n-  beg_bit = bitmap->find_obj_beg(beg_bit + live_bits, range_end);\n-  while (beg_bit < range_end) {\n-    const size_t new_block = beg_bit >> Log2BitsPerBlock;\n-    if (new_block != cur_block) {\n-      cur_block = new_block;\n-      sd.block(cur_block)->set_offset(bitmap->bits_to_words(live_bits));\n-    }\n-\n-    const size_t end_bit = bitmap->find_obj_end(beg_bit, range_end);\n-    if (end_bit < range_end - 1) {\n-      live_bits += end_bit - beg_bit + 1;\n-      beg_bit = bitmap->find_obj_beg(end_bit + 1, range_end);\n-    } else {\n-      return;\n-    }\n-  }\n-}\n-\n-ParMarkBitMap::IterationStatus MoveAndUpdateClosure::copy_until_full()\n-{\n-  if (source() != copy_destination()) {\n-    DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)\n-    Copy::aligned_conjoint_words(source(), copy_destination(), words_remaining());\n-  }\n-  update_state(words_remaining());\n-  assert(is_full(), \"sanity\");\n-  return ParMarkBitMap::full;\n-}\n-\n-void MoveAndUpdateClosure::copy_partial_obj()\n-{\n-  size_t words = words_remaining();\n-\n-  HeapWord* const range_end = MIN2(source() + words, bitmap()->region_end());\n-  HeapWord* const end_addr = bitmap()->find_obj_end(source(), range_end);\n-  if (end_addr < range_end) {\n-    words = bitmap()->obj_size(source(), end_addr);\n-  }\n+  size_t words = MIN2(partial_obj_size, words_remaining());\n@@ -2686,2 +2628,1 @@\n-ParMarkBitMapClosure::IterationStatus\n-MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n+void MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n@@ -2689,2 +2630,0 @@\n-  assert(bitmap()->obj_size(addr) == words, \"bad size\");\n-\n@@ -2692,6 +2631,0 @@\n-  assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==\n-         destination(), \"wrong destination\");\n-\n-  if (words > words_remaining()) {\n-    return ParMarkBitMap::would_overflow;\n-  }\n@@ -2704,0 +2637,4 @@\n+  \/\/ Avoid overflow\n+  words = MIN2(words, words_remaining());\n+  assert(words > 0, \"inv\");\n+\n@@ -2706,0 +2643,6 @@\n+    assert(source() != destination(), \"inv\");\n+    assert(cast_to_oop(source())->is_forwarded(), \"inv\");\n+    assert(cast_to_oop(source())->forwardee() == cast_to_oop(destination()), \"inv\");\n+    \/\/ Read the klass before the copying, since it might destroy the klass (i.e. overlapping copy)\n+    \/\/ and if partial copy, the destination klass may not be copied yet\n+    Klass* klass = cast_to_oop(source())->klass();\n@@ -2707,0 +2650,1 @@\n+    cast_to_oop(copy_destination())->set_mark(Klass::default_prototype_header(klass));\n@@ -2709,4 +2653,0 @@\n-  oop moved_oop = cast_to_oop(copy_destination());\n-  compaction_manager()->update_contents(moved_oop);\n-  assert(oopDesc::is_oop_or_null(moved_oop), \"Expected an oop or null at \" PTR_FORMAT, p2i(moved_oop));\n-\n@@ -2714,2 +2654,0 @@\n-  assert(copy_destination() == cast_from_oop<HeapWord*>(moved_oop) + moved_oop->size(), \"sanity\");\n-  return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;\n@@ -2737,34 +2675,0 @@\n-UpdateOnlyClosure::UpdateOnlyClosure(ParMarkBitMap* mbm,\n-                                     ParCompactionManager* cm,\n-                                     PSParallelCompact::SpaceId space_id) :\n-  ParMarkBitMapClosure(mbm, cm),\n-  _start_array(PSParallelCompact::start_array(space_id))\n-{\n-}\n-\n-\/\/ Updates the references in the object to their new values.\n-ParMarkBitMapClosure::IterationStatus\n-UpdateOnlyClosure::do_addr(HeapWord* addr, size_t words) {\n-  do_addr(addr);\n-  return ParMarkBitMap::incomplete;\n-}\n-\n-FillClosure::FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id) :\n-  ParMarkBitMapClosure(PSParallelCompact::mark_bitmap(), cm),\n-  _start_array(PSParallelCompact::start_array(space_id))\n-{\n-  assert(space_id == PSParallelCompact::old_space_id,\n-         \"cannot use FillClosure in the young gen\");\n-}\n-\n-ParMarkBitMapClosure::IterationStatus\n-FillClosure::do_addr(HeapWord* addr, size_t size) {\n-  CollectedHeap::fill_with_objects(addr, size);\n-  HeapWord* const end = addr + size;\n-  do {\n-    size_t size = cast_to_oop(addr)->size();\n-    _start_array->update_for_block(addr, addr + size);\n-    addr += size;\n-  } while (addr < end);\n-  return ParMarkBitMap::incomplete;\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":446,"deletions":542,"binary":false,"changes":988,"status":"modified"},{"patch":"@@ -218,11 +218,0 @@\n-  static const size_t Log2BlockSize;\n-  static const size_t BlockSize;\n-  static const size_t BlockSizeBytes;\n-\n-  static const size_t BlockSizeOffsetMask;\n-  static const size_t BlockAddrOffsetMask;\n-  static const size_t BlockAddrMask;\n-\n-  static const size_t BlocksPerRegion;\n-  static const size_t Log2BlocksPerRegion;\n-\n@@ -277,6 +266,0 @@\n-    \/\/ Whether the block table for this region has been filled.\n-    inline bool blocks_filled() const;\n-\n-    \/\/ Number of times the block table was filled.\n-    DEBUG_ONLY(inline size_t blocks_filled_count() const;)\n-\n@@ -301,1 +284,0 @@\n-    inline void set_blocks_filled();\n@@ -359,1 +341,0 @@\n-    bool        volatile _blocks_filled;\n@@ -362,4 +343,0 @@\n-#ifdef ASSERT\n-    size_t               _blocks_filled_count;   \/\/ Number of block table fills.\n-#endif  \/\/ #ifdef ASSERT\n-\n@@ -373,15 +350,0 @@\n-  \/\/ \"Blocks\" allow shorter sections of the bitmap to be searched.  Each Block\n-  \/\/ holds an offset, which is the amount of live data in the Region to the left\n-  \/\/ of the first live object that starts in the Block.\n-  class BlockData\n-  {\n-  public:\n-    typedef unsigned short int blk_ofs_t;\n-\n-    blk_ofs_t offset() const    { return _offset; }\n-    void set_offset(size_t val) { _offset = (blk_ofs_t)val; }\n-\n-  private:\n-    blk_ofs_t _offset;\n-  };\n-\n@@ -399,3 +361,0 @@\n-  size_t block_count() const { return _block_count; }\n-  inline BlockData* block(size_t block_idx) const;\n-\n@@ -439,15 +398,0 @@\n-  size_t     addr_to_block_idx(const HeapWord* addr) const;\n-  inline BlockData* addr_to_block_ptr(const HeapWord* addr) const;\n-\n-  inline HeapWord*  block_align_down(HeapWord* addr) const;\n-\n-  \/\/ Return the address one past the end of the partial object.\n-  HeapWord* partial_obj_end(size_t region_idx) const;\n-\n-  \/\/ Return the location of the object after compaction.\n-  HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const;\n-\n-  HeapWord* calc_new_pointer(oop p, ParCompactionManager* cm) const {\n-    return calc_new_pointer(cast_from_oop<HeapWord*>(p), cm);\n-  }\n-\n@@ -460,1 +404,0 @@\n-  bool initialize_block_data();\n@@ -473,4 +416,0 @@\n-\n-  PSVirtualSpace* _block_vspace;\n-  BlockData*      _block_data;\n-  size_t          _block_count;\n@@ -491,25 +430,0 @@\n-inline bool\n-ParallelCompactData::RegionData::blocks_filled() const\n-{\n-  bool result = _blocks_filled;\n-  OrderAccess::acquire();\n-  return result;\n-}\n-\n-#ifdef ASSERT\n-inline size_t\n-ParallelCompactData::RegionData::blocks_filled_count() const\n-{\n-  return _blocks_filled_count;\n-}\n-#endif \/\/ #ifdef ASSERT\n-\n-inline void\n-ParallelCompactData::RegionData::set_blocks_filled()\n-{\n-  OrderAccess::release();\n-  _blocks_filled = true;\n-  \/\/ Debug builds count the number of times the table was filled.\n-  DEBUG_ONLY(Atomic::inc(&_blocks_filled_count));\n-}\n-\n@@ -605,6 +519,0 @@\n-inline ParallelCompactData::BlockData*\n-ParallelCompactData::block(size_t n) const {\n-  assert(n < block_count(), \"bad arg\");\n-  return _block_data + n;\n-}\n-\n@@ -670,22 +578,0 @@\n-inline size_t\n-ParallelCompactData::addr_to_block_idx(const HeapWord* addr) const\n-{\n-  assert(addr >= _heap_start, \"bad addr\");\n-  assert(addr <= _heap_end, \"bad addr\");\n-  return pointer_delta(addr, _heap_start) >> Log2BlockSize;\n-}\n-\n-inline ParallelCompactData::BlockData*\n-ParallelCompactData::addr_to_block_ptr(const HeapWord* addr) const\n-{\n-  return block(addr_to_block_idx(addr));\n-}\n-\n-inline HeapWord*\n-ParallelCompactData::block_align_down(HeapWord* addr) const\n-{\n-  assert(addr >= _heap_start, \"bad addr\");\n-  assert(addr < _heap_end + RegionSize, \"bad addr\");\n-  return (HeapWord*)(size_t(addr) & BlockAddrMask);\n-}\n-\n@@ -703,69 +589,0 @@\n-class ParMarkBitMapClosure: public StackObj {\n- public:\n-  typedef ParMarkBitMap::idx_t idx_t;\n-  typedef ParMarkBitMap::IterationStatus IterationStatus;\n-\n- public:\n-  inline ParMarkBitMapClosure(ParMarkBitMap* mbm, ParCompactionManager* cm,\n-                              size_t words = max_uintx);\n-\n-  inline ParCompactionManager* compaction_manager() const;\n-  inline ParMarkBitMap*        bitmap() const;\n-  inline size_t                words_remaining() const;\n-  inline bool                  is_full() const;\n-  inline HeapWord*             source() const;\n-\n-  inline void                  set_source(HeapWord* addr);\n-\n-  virtual IterationStatus do_addr(HeapWord* addr, size_t words) = 0;\n-\n- protected:\n-  inline void decrement_words_remaining(size_t words);\n-\n- private:\n-  ParMarkBitMap* const        _bitmap;\n-  ParCompactionManager* const _compaction_manager;\n-  size_t                      _words_remaining; \/\/ Words left to copy.\n-\n- protected:\n-  HeapWord*                   _source;          \/\/ Next addr that would be read.\n-};\n-\n-inline\n-ParMarkBitMapClosure::ParMarkBitMapClosure(ParMarkBitMap* bitmap,\n-                                           ParCompactionManager* cm,\n-                                           size_t words):\n-  _bitmap(bitmap), _compaction_manager(cm)\n-{\n-  _words_remaining = words;\n-  _source = nullptr;\n-}\n-\n-inline ParCompactionManager* ParMarkBitMapClosure::compaction_manager() const {\n-  return _compaction_manager;\n-}\n-\n-inline ParMarkBitMap* ParMarkBitMapClosure::bitmap() const {\n-  return _bitmap;\n-}\n-\n-inline size_t ParMarkBitMapClosure::words_remaining() const {\n-  return _words_remaining;\n-}\n-\n-inline bool ParMarkBitMapClosure::is_full() const {\n-  return words_remaining() == 0;\n-}\n-\n-inline HeapWord* ParMarkBitMapClosure::source() const {\n-  return _source;\n-}\n-\n-inline void ParMarkBitMapClosure::set_source(HeapWord* addr) {\n-  _source = addr;\n-}\n-\n-inline void ParMarkBitMapClosure::decrement_words_remaining(size_t words) {\n-  assert(_words_remaining >= words, \"processed too many words\");\n-  _words_remaining -= words;\n-}\n@@ -777,1 +594,1 @@\n-\/\/ There are four phases of the collection.\n+\/\/ A collection consists of the following phases.\n@@ -780,1 +597,3 @@\n-\/\/      - summary phase\n+\/\/      - summary phase (single-threaded)\n+\/\/      - forward (to new address) phase\n+\/\/      - adjust pointers phase\n@@ -785,0 +604,1 @@\n+\/\/\n@@ -786,0 +606,1 @@\n+\/\/      - calculating destination-region for each region for better parallellism in following phases\n@@ -787,0 +608,1 @@\n+\/\/      - adjust pointers to reflect new destination of objects\n@@ -790,6 +612,0 @@\n-\/\/ These three phases are invoked in PSParallelCompact::invoke_no_policy().  The\n-\/\/ marking phase is implemented in PSParallelCompact::marking_phase() and does a\n-\/\/ complete marking of the heap.  The summary phase is implemented in\n-\/\/ PSParallelCompact::summary_phase().  The move and update phase is implemented\n-\/\/ in PSParallelCompact::compact().\n-\/\/\n@@ -831,1 +647,2 @@\n-\/\/ The summary phase is done using 1 GC thread.\n+\/\/ The forward (to new address) phase calculates the new address of each\n+\/\/ objects and records old-addr-to-new-addr asssociation.\n@@ -833,2 +650,1 @@\n-\/\/ The compaction phase moves objects to their new location and updates all\n-\/\/ references in the object.\n+\/\/ The adjust pointers phase remap all pointers to reflect the new address of each object.\n@@ -836,6 +652,1 @@\n-\/\/ A current exception is that objects that cross a region boundary are moved\n-\/\/ but do not have their references updated.  References are not updated because\n-\/\/ it cannot easily be determined if the klass pointer KKK for the object AAA\n-\/\/ has been updated.  KKK likely resides in a region to the left of the region\n-\/\/ containing AAA.  These AAA's have their references updated at the end in a\n-\/\/ clean up phase.  See the method PSParallelCompact::update_deferred_object().\n+\/\/ The compaction phase moves objects to their new location.\n@@ -872,2 +683,0 @@\n-class TaskQueue;\n-\n@@ -879,1 +688,0 @@\n-  typedef ParallelCompactData::BlockData BlockData;\n@@ -886,19 +694,1 @@\n-  struct UpdateDensePrefixTask : public CHeapObj<mtGC> {\n-    SpaceId _space_id;\n-    size_t _region_index_start;\n-    size_t _region_index_end;\n-\n-    UpdateDensePrefixTask() :\n-        _space_id(SpaceId(0)),\n-        _region_index_start(0),\n-        _region_index_end(0) {}\n-\n-    UpdateDensePrefixTask(SpaceId space_id,\n-                          size_t region_index_start,\n-                          size_t region_index_end) :\n-        _space_id(space_id),\n-        _region_index_start(region_index_start),\n-        _region_index_end(region_index_end) {}\n-  };\n-\n- public:\n+public:\n@@ -912,1 +702,0 @@\n-  friend class RefProcTaskProxy;\n@@ -961,2 +750,2 @@\n-  \/\/ Adjust addresses in roots.  Does not adjust addresses in heap.\n-  static void adjust_roots();\n+  static void adjust_pointers();\n+  static void forward_to_new_addr();\n@@ -964,1 +753,2 @@\n-  DEBUG_ONLY(static void write_block_fill_histogram();)\n+  static void verify_forward() NOT_DEBUG_RETURN;\n+  static void verify_filler_in_dense_prefix() NOT_DEBUG_RETURN;\n@@ -972,4 +762,0 @@\n-  \/\/ Add dense prefix update tasks to the task queue.\n-  static void enqueue_dense_prefix_tasks(TaskQueue& task_queue,\n-                                         uint parallel_gc_threads);\n-\n@@ -983,0 +769,2 @@\n+  static void fill_range_in_dense_prefix(HeapWord* start, HeapWord* end);\n+\n@@ -984,0 +772,2 @@\n+  static void fill_dead_objs_in_dense_prefix(uint worker_id, uint num_workers);\n+\n@@ -987,0 +777,9 @@\n+  template<typename Func>\n+  static void adjust_in_space_helper(SpaceId id, volatile uint* claim_counter, Func&& on_stripe);\n+\n+  static void adjust_in_old_space(volatile uint* claim_counter);\n+\n+  static void adjust_in_young_space(SpaceId id, volatile uint* claim_counter);\n+\n+  static void adjust_pointers_in_spaces(uint worker_id, volatile uint* claim_counter);\n+\n@@ -1006,1 +805,1 @@\n-  template <class T> static inline void adjust_pointer(T* p, ParCompactionManager* cm);\n+  template <class T> static inline void adjust_pointer(T* p);\n@@ -1019,13 +818,0 @@\n-  \/\/ Update a region in the dense prefix.  For each live object\n-  \/\/ in the region, update it's interior references.  For each\n-  \/\/ dead object, fill it with deadwood. Dead space at the end\n-  \/\/ of a region range will be filled to the start of the next\n-  \/\/ live object regardless of the region_index_end.  None of the\n-  \/\/ objects in the dense prefix move and dead space is dead\n-  \/\/ (holds only dead objects that don't need any processing), so\n-  \/\/ dead space can be filled in any order.\n-  static void update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,\n-                                                  SpaceId space_id,\n-                                                  size_t region_index_start,\n-                                                  size_t region_index_end);\n-\n@@ -1059,0 +845,2 @@\n+  static HeapWord* partial_obj_end(HeapWord* region_start_addr);\n+\n@@ -1070,6 +858,0 @@\n-  \/\/ Fill in the block table for the specified region.\n-  static void fill_blocks(size_t region_idx);\n-\n-  \/\/ Update a single deferred object.\n-  static void update_deferred_object(ParCompactionManager* cm, HeapWord* addr);\n-\n@@ -1107,1 +889,4 @@\n-class MoveAndUpdateClosure: public ParMarkBitMapClosure {\n+class MoveAndUpdateClosure: public StackObj {\n+ private:\n+  ParMarkBitMap* const        _bitmap;\n+  size_t                      _words_remaining; \/\/ Words left to copy.\n@@ -1109,0 +894,11 @@\n+\n+ protected:\n+  HeapWord*               _source;          \/\/ Next addr that would be read.\n+  HeapWord*               _destination;     \/\/ Next addr to be written.\n+  ObjectStartArray* const _start_array;\n+  size_t                  _offset;\n+\n+  inline void decrement_words_remaining(size_t words);\n+  \/\/ Update variables to indicate that word_count words were processed.\n+  inline void update_state(size_t words);\n+\n@@ -1110,2 +906,1 @@\n-  inline MoveAndUpdateClosure(ParMarkBitMap* bitmap, ParCompactionManager* cm,\n-                              size_t region);\n+  typedef ParMarkBitMap::idx_t idx_t;\n@@ -1113,3 +908,6 @@\n-  \/\/ Accessors.\n-  HeapWord* destination() const         { return _destination; }\n-  HeapWord* copy_destination() const    { return _destination + _offset; }\n+  ParMarkBitMap*        bitmap() const { return _bitmap; }\n+\n+  size_t    words_remaining()    const { return _words_remaining; }\n+  bool      is_full()            const { return _words_remaining == 0; }\n+  HeapWord* source()             const { return _source; }\n+  void      set_source(HeapWord* addr) { _source = addr; }\n@@ -1118,4 +916,2 @@\n-  \/\/ destination, update the interior oops and the start array and return either\n-  \/\/ full (if the closure is full) or incomplete.  If the object will not fit,\n-  \/\/ return would_overflow.\n-  IterationStatus do_addr(HeapWord* addr, size_t size);\n+  \/\/ destination, update the interior oops and the start array.\n+  void do_addr(HeapWord* addr, size_t words);\n@@ -1123,3 +919,5 @@\n-  \/\/ Copy enough words to fill this closure, starting at source().  Interior\n-  \/\/ oops and the start array are not updated.  Return full.\n-  IterationStatus copy_until_full();\n+  inline MoveAndUpdateClosure(ParMarkBitMap* bitmap, size_t region);\n+\n+  \/\/ Accessors.\n+  HeapWord* destination() const         { return _destination; }\n+  HeapWord* copy_destination() const    { return _destination + _offset; }\n@@ -1128,3 +926,3 @@\n-  \/\/ whichever is smaller, starting at source().  Interior oops and the start\n-  \/\/ array are not updated.\n-  void copy_partial_obj();\n+  \/\/ whichever is smaller, starting at source(). The start array is not\n+  \/\/ updated.\n+  void copy_partial_obj(size_t partial_obj_size);\n@@ -1134,9 +932,0 @@\n-\n-protected:\n-  \/\/ Update variables to indicate that word_count words were processed.\n-  inline void update_state(size_t word_count);\n-\n- protected:\n-  HeapWord*               _destination;         \/\/ Next addr to be written.\n-  ObjectStartArray* const _start_array;\n-  size_t                  _offset;\n@@ -1145,0 +934,5 @@\n+inline void MoveAndUpdateClosure::decrement_words_remaining(size_t words) {\n+  assert(_words_remaining >= words, \"processed too many words\");\n+  _words_remaining -= words;\n+}\n+\n@@ -1155,4 +949,4 @@\n-MoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,\n-                                           ParCompactionManager* cm,\n-                                           size_t region_idx) :\n-  ParMarkBitMapClosure(bitmap, cm, calculate_words_remaining(region_idx)),\n+MoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap, size_t region_idx) :\n+  _bitmap(bitmap),\n+  _words_remaining(calculate_words_remaining(region_idx)),\n+  _source(nullptr),\n@@ -1161,2 +955,1 @@\n-  _offset(0) { }\n-\n+  _offset(0) {}\n@@ -1196,1 +989,1 @@\n-  MoveAndUpdateClosure(bitmap, cm, region),\n+  MoveAndUpdateClosure(bitmap, region),\n@@ -1201,25 +994,0 @@\n-class UpdateOnlyClosure: public ParMarkBitMapClosure {\n- private:\n-  ObjectStartArray* const          _start_array;\n-\n- public:\n-  UpdateOnlyClosure(ParMarkBitMap* mbm,\n-                    ParCompactionManager* cm,\n-                    PSParallelCompact::SpaceId space_id);\n-\n-  \/\/ Update the object.\n-  virtual IterationStatus do_addr(HeapWord* addr, size_t words);\n-\n-  inline void do_addr(HeapWord* addr);\n-};\n-\n-class FillClosure: public ParMarkBitMapClosure {\n- public:\n-  FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id);\n-\n-  virtual IterationStatus do_addr(HeapWord* addr, size_t size);\n-\n- private:\n-  ObjectStartArray* const _start_array;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":75,"deletions":307,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -81,2 +81,1 @@\n-  const size_t obj_size = obj->size();\n-  if (mark_bitmap()->mark_obj(obj, obj_size)) {\n+  if (mark_bitmap()->mark_obj(obj)) {\n@@ -91,1 +90,1 @@\n-inline void PSParallelCompact::adjust_pointer(T* p, ParCompactionManager* cm) {\n+inline void PSParallelCompact::adjust_pointer(T* p) {\n@@ -97,7 +96,2 @@\n-    oop new_obj = cast_to_oop(summary_data().calc_new_pointer(obj, cm));\n-    assert(new_obj != nullptr, \"non-null address for live objects\");\n-    \/\/ Is it actually relocated at all?\n-    if (new_obj != obj) {\n-      assert(ParallelScavengeHeap::heap()->is_in_reserved(new_obj),\n-             \"should be in object space\");\n-      RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n+    if (!obj->is_forwarded()) {\n+      return;\n@@ -105,0 +99,6 @@\n+    oop new_obj = obj->forwardee();\n+    assert(new_obj != nullptr, \"non-null address for live objects\");\n+    assert(new_obj != obj, \"inv\");\n+    assert(ParallelScavengeHeap::heap()->is_in_reserved(new_obj),\n+           \"should be in object space\");\n+    RawAccess<IS_NOT_NULL>::oop_store(p, new_obj);\n@@ -108,13 +108,0 @@\n-class PCAdjustPointerClosure: public BasicOopIterateClosure {\n-public:\n-  PCAdjustPointerClosure(ParCompactionManager* cm) : _cm(cm) {\n-  }\n-  template <typename T> void do_oop_work(T* p) { PSParallelCompact::adjust_pointer(p, _cm); }\n-  virtual void do_oop(oop* p)                { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p)          { do_oop_work(p); }\n-\n-  virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }\n-private:\n-  ParCompactionManager* _cm;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -688,5 +688,0 @@\n-#ifdef ASSERT\n-  if (gch->soft_ref_policy()->should_clear_all_soft_refs()) {\n-    assert(clear_all_softrefs, \"Policy should have been checked earlier\");\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -562,3 +562,0 @@\n-  assert(!soft_ref_policy()->should_clear_all_soft_refs(),\n-    \"Flag should have been handled and cleared prior to this point\");\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -821,0 +821,19 @@\n+static const TypeFunc* clone_type() {\n+  \/\/ Create input type (domain)\n+  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n+  const Type** const domain_fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ src\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ dst\n+  domain_fields[argp++] = TypeX_X;               \/\/ size lower\n+  LP64_ONLY(domain_fields[argp++] = Type::HALF); \/\/ size upper\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + argcnt, domain_fields);\n+\n+  \/\/ Create result type (range)\n+  const Type** const range_fields = TypeTuple::fields(0);\n+  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n@@ -823,0 +842,31 @@\n+void BarrierSetC2::clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                                    address clone_addr, const char* clone_name) const {\n+  Node* const ctrl = ac->in(TypeFunc::Control);\n+  Node* const mem  = ac->in(TypeFunc::Memory);\n+  Node* const src  = ac->in(ArrayCopyNode::Src);\n+  Node* const dst  = ac->in(ArrayCopyNode::Dest);\n+  Node* const size = ac->in(ArrayCopyNode::Length);\n+\n+  assert(size->bottom_type()->base() == Type_X,\n+         \"Should be of object size type (int for 32 bits, long for 64 bits)\");\n+\n+  \/\/ The native clone we are calling here expects the object size in words.\n+  \/\/ Add header\/offset size to payload size to get object size.\n+  Node* const base_offset = phase->MakeConX(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n+  Node* const full_size = phase->transform_later(new AddXNode(size, base_offset));\n+  \/\/ HeapAccess<>::clone expects size in heap words.\n+  \/\/ For 64-bits platforms, this is a no-operation.\n+  \/\/ For 32-bits platforms, we need to multiply full_size by HeapWordsPerLong (2).\n+  Node* const full_size_in_heap_words = phase->transform_later(new LShiftXNode(full_size, phase->intcon(LogHeapWordsPerLong)));\n+\n+  Node* const call = phase->make_leaf_call(ctrl,\n+                                           mem,\n+                                           clone_type(),\n+                                           clone_addr,\n+                                           clone_name,\n+                                           TypeRawPtr::BOTTOM,\n+                                           src, dst, full_size_in_heap_words XTOP);\n+  phase->transform_later(call);\n+  phase->replace_node(ac, call);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -287,0 +287,2 @@\n+  void clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                        address call_addr, const char* call_name) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,2 +104,5 @@\n-    log_warning(gc, ergo)(\"NewSize was set larger than initial heap size, will use initial heap size.\");\n-    FLAG_SET_ERGO(NewSize, bound_minus_alignment(NewSize, InitialHeapSize, GenAlignment));\n+    size_t revised_new_size = bound_minus_alignment(NewSize, InitialHeapSize, GenAlignment);\n+    log_warning(gc, ergo)(\"NewSize (%zuk) is equal to or greater than initial heap size (%zuk).  A new \"\n+                          \"NewSize of %zuk will be used to accomodate an old generation.\",\n+                          NewSize\/K, InitialHeapSize\/K, revised_new_size\/K);\n+    FLAG_SET_ERGO(NewSize, revised_new_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  BasicType flag_type;\n+\n@@ -64,9 +64,1 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    flag_type = T_INT;\n-  } else {\n-    guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1,\n-              \"Assumption\");\n-    \/\/ Use unsigned type T_BOOLEAN here rather than signed T_BYTE since some platforms, eg. ARM,\n-    \/\/ need to use unsigned instructions to use the large offset to load the satb_mark_queue.\n-    flag_type = T_BOOLEAN;\n-  }\n+\n@@ -74,5 +66,5 @@\n-  LIR_Address* mark_active_flag_addr =\n-    new LIR_Address(thrd,\n-                    in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()),\n-                    flag_type);\n-  \/\/ Read the marking-in-progress flag.\n+  LIR_Address* gc_state_addr =\n+          new LIR_Address(thrd,\n+                          in_bytes(ShenandoahThreadLocalData::gc_state_offset()),\n+                          T_BYTE);\n+  \/\/ Read the gc_state flag.\n@@ -80,1 +72,15 @@\n-  __ load(mark_active_flag_addr, flag_val);\n+  __ load(gc_state_addr, flag_val);\n+\n+  \/\/ Create a mask to test if the marking bit is set.\n+  \/\/ TODO: can we directly test if bit is set?\n+  LIR_Opr mask = LIR_OprFact::intConst(ShenandoahHeap::MARKING);\n+  LIR_Opr mask_reg = gen->new_register(T_INT);\n+  __ move(mask, mask_reg);\n+\n+  if (two_operand_lir_form) {\n+    __ logical_and(flag_val, mask_reg, flag_val);\n+  } else {\n+    LIR_Opr masked_flag = gen->new_register(T_INT);\n+    __ logical_and(flag_val, mask_reg, masked_flag);\n+    flag_val = masked_flag;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -983,1 +983,1 @@\n-    const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());\n+    const int gc_state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());\n@@ -991,1 +991,4 @@\n-      if (x == nullptr || x == compile->top()) continue;\n+      if (x == nullptr || x == compile->top()) {\n+        continue;\n+      }\n+\n@@ -1019,1 +1022,1 @@\n-                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == marking_offset) {\n+                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == gc_state_offset) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -40,2 +42,0 @@\n-#include \"memory\/resourceArea.hpp\"\n-#include \"runtime\/atomic.hpp\"\n@@ -44,3 +44,1 @@\n-  ConcurrentGCThread(),\n-  _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true),\n+  ShenandoahController(),\n@@ -48,2 +46,1 @@\n-  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n-  _allocs_seen(0) {\n+  _degen_point(ShenandoahGC::_degenerated_outside_cycle) {\n@@ -51,1 +48,0 @@\n-  reset_gc_id();\n@@ -56,1 +52,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -80,1 +76,1 @@\n-    const size_t allocs_seen = Atomic::xchg(&_allocs_seen, (size_t)0, memory_order_relaxed);\n+    const size_t allocs_seen = reset_allocs_seen();\n@@ -109,1 +105,0 @@\n-\n@@ -242,1 +237,1 @@\n-      \/\/ Allow allocators to know we have seen this much regions\n+      \/\/ Report to pacer that we have seen this many words allocated\n@@ -410,51 +405,0 @@\n-void ShenandoahControlThread::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  assert(current()->is_Java_thread(), \"expect Java thread here\");\n-\n-  if (try_set_alloc_failure_gc()) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate %s, \" SIZE_FORMAT \"%s\",\n-                 req.type_string(),\n-                 byte_size_in_proper_unit(req.size() * HeapWordSize), proper_unit_for_byte_size(req.size() * HeapWordSize));\n-\n-    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n-    heap->cancel_gc(GCCause::_allocation_failure);\n-  }\n-\n-\n-  if (block) {\n-    MonitorLocker ml(&_alloc_failure_waiters_lock);\n-    while (is_alloc_failure_gc()) {\n-      ml.wait();\n-    }\n-  }\n-}\n-\n-void ShenandoahControlThread::handle_alloc_failure_evac(size_t words) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  if (try_set_alloc_failure_gc()) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate \" SIZE_FORMAT \"%s for evacuation\",\n-                 byte_size_in_proper_unit(words * HeapWordSize), proper_unit_for_byte_size(words * HeapWordSize));\n-  }\n-\n-  \/\/ Forcefully report allocation failure\n-  heap->cancel_gc(GCCause::_shenandoah_allocation_failure_evac);\n-}\n-\n-void ShenandoahControlThread::notify_alloc_failure_waiters() {\n-  _alloc_failure_gc.unset();\n-  MonitorLocker ml(&_alloc_failure_waiters_lock);\n-  ml.notify_all();\n-}\n-\n-bool ShenandoahControlThread::try_set_alloc_failure_gc() {\n-  return _alloc_failure_gc.try_set();\n-}\n-\n-bool ShenandoahControlThread::is_alloc_failure_gc() {\n-  return _alloc_failure_gc.is_set();\n-}\n-\n@@ -466,29 +410,0 @@\n-\n-void ShenandoahControlThread::pacing_notify_alloc(size_t words) {\n-  assert(ShenandoahPacing, \"should only call when pacing is enabled\");\n-  Atomic::add(&_allocs_seen, words, memory_order_relaxed);\n-}\n-\n-void ShenandoahControlThread::reset_gc_id() {\n-  Atomic::store(&_gc_id, (size_t)0);\n-}\n-\n-void ShenandoahControlThread::update_gc_id() {\n-  Atomic::inc(&_gc_id);\n-}\n-\n-size_t ShenandoahControlThread::get_gc_id() {\n-  return Atomic::load(&_gc_id);\n-}\n-\n-void ShenandoahControlThread::start() {\n-  create_and_start();\n-}\n-\n-void ShenandoahControlThread::prepare_for_graceful_shutdown() {\n-  _graceful_shutdown.set();\n-}\n-\n-bool ShenandoahControlThread::in_graceful_shutdown() {\n-  return _graceful_shutdown.is_set();\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":7,"deletions":92,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n@@ -34,1 +35,1 @@\n-class ShenandoahControlThread: public ConcurrentGCThread {\n+class ShenandoahControlThread: public ShenandoahController {\n@@ -45,11 +46,0 @@\n-  \/\/ While we could have a single lock for these, it may risk unblocking\n-  \/\/ GC waiters when alloc failure GC cycle finishes. We want instead\n-  \/\/ to make complete explicit cycle for for demanding customers.\n-  Monitor _alloc_failure_waiters_lock;\n-  Monitor _gc_waiters_lock;\n-\n-public:\n-  void run_service();\n-  void stop_service();\n-\n-private:\n@@ -57,2 +47,0 @@\n-  ShenandoahSharedFlag _alloc_failure_gc;\n-  ShenandoahSharedFlag _graceful_shutdown;\n@@ -62,5 +50,9 @@\n-  shenandoah_padding(0);\n-  volatile size_t _allocs_seen;\n-  shenandoah_padding(1);\n-  volatile size_t _gc_id;\n-  shenandoah_padding(2);\n+public:\n+  ShenandoahControlThread();\n+\n+  void run_service() override;\n+  void stop_service() override;\n+\n+  void request_gc(GCCause::Cause cause) override;\n+\n+private:\n@@ -73,8 +65,0 @@\n-  bool try_set_alloc_failure_gc();\n-  void notify_alloc_failure_waiters();\n-  bool is_alloc_failure_gc();\n-\n-  void reset_gc_id();\n-  void update_gc_id();\n-  size_t get_gc_id();\n-\n@@ -86,21 +70,0 @@\n-\n-public:\n-  \/\/ Constructor\n-  ShenandoahControlThread();\n-\n-  \/\/ Handle allocation failure from a mutator allocation.\n-  \/\/ Optionally blocks while collector is handling the failure. If the GC\n-  \/\/ threshold has been exceeded, the mutator allocation will not block so\n-  \/\/ that the out of memory error can be raised promptly.\n-  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block = true);\n-\n-  \/\/ Handle allocation failure from evacuation path.\n-  void handle_alloc_failure_evac(size_t words);\n-\n-  void request_gc(GCCause::Cause cause);\n-\n-  void pacing_notify_alloc(size_t words);\n-\n-  void start();\n-  void prepare_for_graceful_shutdown();\n-  bool in_graceful_shutdown();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":11,"deletions":48,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+\n+void ShenandoahController::pacing_notify_alloc(size_t words) {\n+  assert(ShenandoahPacing, \"should only call when pacing is enabled\");\n+  Atomic::add(&_allocs_seen, words, memory_order_relaxed);\n+}\n+\n+size_t ShenandoahController::reset_allocs_seen() {\n+  return Atomic::xchg(&_allocs_seen, (size_t)0, memory_order_relaxed);\n+}\n+\n+void ShenandoahController::prepare_for_graceful_shutdown() {\n+  _graceful_shutdown.set();\n+}\n+\n+bool ShenandoahController::in_graceful_shutdown() {\n+  return _graceful_shutdown.is_set();\n+}\n+\n+void ShenandoahController::update_gc_id() {\n+  Atomic::inc(&_gc_id);\n+}\n+\n+size_t ShenandoahController::get_gc_id() {\n+  return Atomic::load(&_gc_id);\n+}\n+\n+void ShenandoahController::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  assert(current()->is_Java_thread(), \"expect Java thread here\");\n+  bool is_humongous = req.size() > ShenandoahHeapRegion::humongous_threshold_words();\n+\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n+    \/\/ Only report the first allocation failure\n+    log_info(gc)(\"Failed to allocate %s, \" SIZE_FORMAT \"%s\",\n+                 req.type_string(),\n+                 byte_size_in_proper_unit(req.size() * HeapWordSize), proper_unit_for_byte_size(req.size() * HeapWordSize));\n+\n+    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n+    heap->cancel_gc(GCCause::_allocation_failure);\n+  }\n+\n+\n+  if (block) {\n+    MonitorLocker ml(&_alloc_failure_waiters_lock);\n+    while (is_alloc_failure_gc()) {\n+      ml.wait();\n+    }\n+  }\n+}\n+\n+void ShenandoahController::handle_alloc_failure_evac(size_t words) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n+\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n+    \/\/ Only report the first allocation failure\n+    log_info(gc)(\"Failed to allocate \" SIZE_FORMAT \"%s for evacuation\",\n+                 byte_size_in_proper_unit(words * HeapWordSize), proper_unit_for_byte_size(words * HeapWordSize));\n+  }\n+\n+  \/\/ Forcefully report allocation failure\n+  heap->cancel_gc(GCCause::_shenandoah_allocation_failure_evac);\n+}\n+\n+void ShenandoahController::notify_alloc_failure_waiters() {\n+  _alloc_failure_gc.unset();\n+  _humongous_alloc_failure_gc.unset();\n+  MonitorLocker ml(&_alloc_failure_waiters_lock);\n+  ml.notify_all();\n+}\n+\n+bool ShenandoahController::try_set_alloc_failure_gc(bool is_humongous) {\n+  if (is_humongous) {\n+    _humongous_alloc_failure_gc.try_set();\n+  }\n+  return _alloc_failure_gc.try_set();\n+}\n+\n+bool ShenandoahController::is_alloc_failure_gc() {\n+  return _alloc_failure_gc.is_set();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+#define LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+\/**\n+ * This interface exposes methods necessary for the heap to interact\n+ * with the threads responsible for driving the collection cycle.\n+ *\/\n+class ShenandoahController: public ConcurrentGCThread {\n+private:\n+  ShenandoahSharedFlag _graceful_shutdown;\n+\n+  shenandoah_padding(0);\n+  volatile size_t _allocs_seen;\n+  shenandoah_padding(1);\n+  volatile size_t _gc_id;\n+  shenandoah_padding(2);\n+\n+protected:\n+  ShenandoahSharedFlag _alloc_failure_gc;\n+  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n+\n+  \/\/ While we could have a single lock for these, it may risk unblocking\n+  \/\/ GC waiters when alloc failure GC cycle finishes. We want instead\n+  \/\/ to make complete explicit cycle for demanding customers.\n+  Monitor _alloc_failure_waiters_lock;\n+  Monitor _gc_waiters_lock;\n+\n+public:\n+  ShenandoahController():\n+    ConcurrentGCThread(),\n+    _allocs_seen(0),\n+    _gc_id(0),\n+    _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n+    _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true)\n+  { }\n+\n+  \/\/ Request a collection cycle. This handles \"explicit\" gc requests\n+  \/\/ like System.gc and \"implicit\" gc requests, like metaspace oom.\n+  virtual void request_gc(GCCause::Cause cause) = 0;\n+\n+  \/\/ This cancels the collection cycle and has an option to block\n+  \/\/ until another cycle runs and clears the alloc failure gc flag.\n+  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block);\n+\n+  \/\/ Invoked for allocation failures during evacuation. This cancels\n+  \/\/ the collection cycle without blocking.\n+  void handle_alloc_failure_evac(size_t words);\n+\n+  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n+  bool try_set_alloc_failure_gc(bool is_humongous);\n+\n+  \/\/ Notify threads waiting for GC to complete.\n+  void notify_alloc_failure_waiters();\n+\n+  \/\/ True if allocation failure flag has been set.\n+  bool is_alloc_failure_gc();\n+\n+  \/\/ This is called for every allocation. The control thread accumulates\n+  \/\/ this value when idle. During the gc cycle, the control resets it\n+  \/\/ and reports it to the pacer.\n+  void pacing_notify_alloc(size_t words);\n+  size_t reset_allocs_seen();\n+\n+  \/\/ These essentially allows to cancel a collection cycle for the\n+  \/\/ purpose of shutting down the JVM, without trying to start a degenerated\n+  \/\/ cycle.\n+  void prepare_for_graceful_shutdown();\n+  bool in_graceful_shutdown();\n+\n+\n+  \/\/ Returns the internal gc count used by the control thread. Probably\n+  \/\/ doesn't need to be exposed.\n+  size_t get_gc_id();\n+  void update_gc_id();\n+};\n+#endif \/\/LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -958,1 +958,1 @@\n-      control_thread()->handle_alloc_failure(req);\n+      control_thread()->handle_alloc_failure(req, true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,4 +161,0 @@\n-  static ByteSize satb_mark_queue_active_offset() {\n-    return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_active();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -410,17 +410,0 @@\n-\/\/ This TypeFunc assumes a 64bit system\n-static const TypeFunc* clone_type() {\n-  \/\/ Create input type (domain)\n-  const Type** const domain_fields = TypeTuple::fields(4);\n-  domain_fields[TypeFunc::Parms + 0] = TypeInstPtr::NOTNULL;  \/\/ src\n-  domain_fields[TypeFunc::Parms + 1] = TypeInstPtr::NOTNULL;  \/\/ dst\n-  domain_fields[TypeFunc::Parms + 2] = TypeLong::LONG;        \/\/ size lower\n-  domain_fields[TypeFunc::Parms + 3] = Type::HALF;            \/\/ size upper\n-  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + 4, domain_fields);\n-\n-  \/\/ Create result type (range)\n-  const Type** const range_fields = TypeTuple::fields(0);\n-  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n-\n-  return TypeFunc::make(domain, range);\n-}\n-\n@@ -482,25 +465,4 @@\n-  \/\/ Clone instance\n-  Node* const ctrl       = ac->in(TypeFunc::Control);\n-  Node* const mem        = ac->in(TypeFunc::Memory);\n-  Node* const dst        = ac->in(ArrayCopyNode::Dest);\n-  Node* const size       = ac->in(ArrayCopyNode::Length);\n-\n-  assert(size->bottom_type()->is_long(), \"Should be long\");\n-\n-  \/\/ The native clone we are calling here expects the instance size in words\n-  \/\/ Add header\/offset size to payload size to get instance size.\n-  Node* const base_offset = phase->longcon(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n-  Node* const full_size = phase->transform_later(new AddLNode(size, base_offset));\n-\n-  Node* const call = phase->make_leaf_call(ctrl,\n-                                           mem,\n-                                           clone_type(),\n-                                           ZBarrierSetRuntime::clone_addr(),\n-                                           \"ZBarrierSetRuntime::clone\",\n-                                           TypeRawPtr::BOTTOM,\n-                                           src,\n-                                           dst,\n-                                           full_size,\n-                                           phase->top());\n-  phase->transform_later(call);\n-  phase->replace_node(ac, call);\n+  \/\/ Clone instance or array where 'src' is only known to be an object (ary_ptr\n+  \/\/ is null). This can happen in bytecode generated dynamically to implement\n+  \/\/ reflective array clones.\n+  clone_in_runtime(phase, ac, ZBarrierSetRuntime::clone_addr(), \"ZBarrierSetRuntime::clone\");\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":4,"deletions":42,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -231,14 +231,0 @@\n-  \/\/ At this point the class may not be fully initialized\n-  \/\/ because of recursive initialization. If it is fully\n-  \/\/ initialized & has_finalized is not set, we rewrite\n-  \/\/ it into its fast version (Note: no locking is needed\n-  \/\/ here since this is an atomic byte write and can be\n-  \/\/ done more than once).\n-  \/\/\n-  \/\/ Note: In case of classes with has_finalized we don't\n-  \/\/       rewrite since that saves us an extra check in\n-  \/\/       the fast version which then would call the\n-  \/\/       slow version anyway (and do a call back into\n-  \/\/       Java).\n-  \/\/       If we have a breakpoint, then we don't rewrite\n-  \/\/       because the _breakpoint bytecode would be lost.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -517,0 +517,1 @@\n+    JVMCI_event_1(\"decoding exception from JVM heap (format: %d, buffer[%d]) \", format, buffer == 0L ? -1 : *((u4*) buffer));\n@@ -548,0 +549,1 @@\n+    JVMCI_event_1(\"decoding exception to JVM heap (format: %d, buffer[%d]) \", format, buffer == 0L ? -1 : *((u4*) buffer));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -844,1 +844,1 @@\n-  static_field(HeapRegion, LogOfHRGrainBytes, uint)\n+  static_field(G1HeapRegion, LogOfHRGrainBytes, uint)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-    memcpy(innerp, ptr, len);\n+    if (ptr != nullptr) {\n+      memcpy(innerp, ptr, len);\n+    }\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,0 +182,10 @@\n+  \/\/ Total peak malloc\n+  size_t total_peak() const {\n+    return _all_mallocs.peak_size();\n+  }\n+\n+  \/\/ Total peak count\n+  size_t total_peak_count() const {\n+    return _all_mallocs.peak_count();\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  out->print_cr(\"       malloc: \" SIZE_FORMAT \"%s #\" SIZE_FORMAT,\n+  out->print_cr(\"       malloc: \" SIZE_FORMAT \"%s #\" SIZE_FORMAT \", peak=\" SIZE_FORMAT \"%s #\" SIZE_FORMAT,\n@@ -170,1 +170,3 @@\n-                _malloc_snapshot->total_count());\n+                _malloc_snapshot->total_count(),\n+                amount_in_current_scale(_malloc_snapshot->total_peak()),\n+                current_scale(), _malloc_snapshot->total_peak_count());\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3821,1 +3821,3 @@\n-  st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n+  if (default_methods() != nullptr) {\n+    st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -830,2 +830,0 @@\n-  bool has_vanilla_constructor() const  { return _misc_flags.has_vanilla_constructor(); }\n-  void set_has_vanilla_constructor()    { _misc_flags.set_has_vanilla_constructor(true); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,8 +56,7 @@\n-    flag(has_vanilla_constructor            , 1 << 13) \/* True if klass has a vanilla default constructor *\/ \\\n-    flag(has_final_method                   , 1 << 14) \/* True if klass has final method *\/ \\\n-    flag(has_inline_type_fields             , 1 << 15) \/* has inline fields and related embedded section is not empty *\/ \\\n-    flag(is_empty_inline_type               , 1 << 16) \/* empty inline type (*) *\/ \\\n-    flag(is_naturally_atomic                , 1 << 17) \/* loaded\/stored in one instruction *\/ \\\n-    flag(must_be_atomic                     , 1 << 18) \/* doesn't allow tearing *\/ \\\n-    flag(has_loosely_consistent_annotation  , 1 << 19) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n-    flag(is_implicitly_constructible        , 1 << 20) \/* the class has the ImplicitlyConstrutible annotation *\/\n+    flag(has_final_method                   , 1 << 13) \/* True if klass has final method *\/ \\\n+    flag(has_inline_type_fields             , 1 << 14) \/* has inline fields and related embedded section is not empty *\/ \\\n+    flag(is_empty_inline_type               , 1 << 15) \/* empty inline type (*) *\/ \\\n+    flag(is_naturally_atomic                , 1 << 16) \/* loaded\/stored in one instruction *\/ \\\n+    flag(must_be_atomic                     , 1 << 17) \/* doesn't allow tearing *\/ \\\n+    flag(has_loosely_consistent_annotation  , 1 << 18) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n+    flag(is_implicitly_constructible        , 1 << 19) \/* the class has the ImplicitlyConstrutible annotation *\/\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -690,44 +690,0 @@\n-bool Method::is_vanilla_constructor() const {\n-  \/\/ Returns true if this method is a vanilla constructor, i.e. an \"<init>\" \"()V\" method\n-  \/\/ which only calls the superclass vanilla constructor and possibly does stores of\n-  \/\/ zero constants to local fields:\n-  \/\/\n-  \/\/   aload_0, _fast_aload_0, or _nofast_aload_0\n-  \/\/   invokespecial\n-  \/\/   indexbyte1\n-  \/\/   indexbyte2\n-  \/\/\n-  \/\/ followed by an (optional) sequence of:\n-  \/\/\n-  \/\/   aload_0\n-  \/\/   aconst_null \/ iconst_0 \/ fconst_0 \/ dconst_0\n-  \/\/   putfield\n-  \/\/   indexbyte1\n-  \/\/   indexbyte2\n-  \/\/\n-  \/\/ followed by:\n-  \/\/\n-  \/\/   return\n-\n-  assert(name() == vmSymbols::object_initializer_name(),    \"Should only be called for default constructors\");\n-  assert(signature() == vmSymbols::void_method_signature(), \"Should only be called for default constructors\");\n-  int size = code_size();\n-  \/\/ Check if size match\n-  if (size == 0 || size % 5 != 0) return false;\n-  address cb = code_base();\n-  int last = size - 1;\n-  if ((cb[0] != Bytecodes::_aload_0 && cb[0] != Bytecodes::_fast_aload_0 && cb[0] != Bytecodes::_nofast_aload_0) ||\n-       cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {\n-    \/\/ Does not call superclass default constructor\n-    return false;\n-  }\n-  \/\/ Check optional sequence\n-  for (int i = 4; i < last; i += 5) {\n-    if (cb[i] != Bytecodes::_aload_0) return false;\n-    if (!Bytecodes::is_zero_const(Bytecodes::cast(cb[i+1]))) return false;\n-    if (cb[i+2] != Bytecodes::_putfield) return false;\n-  }\n-  return true;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -236,1 +236,7 @@\n-  res = widen_type(phase, res, T_INT);\n+  \/\/ But here we have to pay extra attention:\n+  \/\/ Do not narrow the type of range check dependent CastIINodes to\n+  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n+  \/\/ the corresponding range check is not removed.\n+  if (!_range_check_dependency) {\n+    res = widen_type(phase, res, T_INT);\n+  }\n@@ -256,1 +262,1 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n@@ -260,1 +266,1 @@\n-  if (!_type->is_int()->empty()) {\n+  if (!_range_check_dependency) {\n@@ -271,0 +277,7 @@\n+  if (_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      return this->in(1);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+macro(OpaqueInitializedAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3980,4 +3980,0 @@\n-  case Op_CastII: {\n-    remove_range_check_cast(n->as_CastII());\n-  }\n-  break;\n@@ -4135,0 +4131,10 @@\n+#ifdef ASSERT\n+  case Op_CastII:\n+    \/\/ Verify that all range check dependent CastII nodes were removed.\n+    if (n->isa_CastII()->has_range_check()) {\n+      n->dump(3);\n+      assert(false, \"Range check dependent CastII node was not removed\");\n+    }\n+    break;\n+#endif\n+\n@@ -4143,2 +4149,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4165,2 +4169,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4187,2 +4189,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4209,2 +4209,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4419,28 +4417,0 @@\n-void Compile::remove_range_check_cast(CastIINode* cast) {\n-  if (cast->has_range_check()) {\n-    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n-    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n-    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n-    \/\/ range check or a null divisor check.\n-    assert(cast->in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n-    ResourceMark rm;\n-    Unique_Node_List wq;\n-    wq.push(cast);\n-    for (uint next = 0; next < wq.size(); ++next) {\n-      Node* m = wq.at(next);\n-      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n-        Node* use = m->fast_out(i);\n-        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n-          use->ensure_control_or_add_prec(cast->in(0));\n-        } else if (!use->is_CFG() && !use->is_Phi()) {\n-          wq.push(use);\n-        }\n-      }\n-    }\n-    cast->subsume_by(cast->in(1), this);\n-    if (cast->outcnt() == 0) {\n-      cast->disconnect_inputs(this);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":10,"deletions":40,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-class CastIINode;\n@@ -1346,2 +1345,0 @@\n-\n-  void remove_range_check_cast(CastIINode* cast);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -374,1 +374,0 @@\n-#ifndef PRODUCT\n@@ -634,1 +633,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6369,5 +6369,4 @@\n-  \/\/ Set the original stack and the reexecute bit for the interpreter to reexecute\n-  \/\/ the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens\n-  \/\/ on the return from z array allocation in runtime.\n-  { PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n+  Node* x_start = array_element_address(x, intcon(0), x_elem);\n+  Node* y_start = array_element_address(y, intcon(0), y_elem);\n+  \/\/ 'x_start' points to x array + scaled xlen\n+  \/\/ 'y_start' points to y array + scaled ylen\n@@ -6375,4 +6374,1 @@\n-    Node* x_start = array_element_address(x, intcon(0), x_elem);\n-    Node* y_start = array_element_address(y, intcon(0), y_elem);\n-    \/\/ 'x_start' points to x array + scaled xlen\n-    \/\/ 'y_start' points to y array + scaled ylen\n+  Node* z_start = array_element_address(z, intcon(0), T_INT);\n@@ -6380,54 +6376,4 @@\n-    \/\/ Allocate the result array\n-    Node* zlen = _gvn.transform(new AddINode(xlen, ylen));\n-    ciKlass* klass = ciTypeArrayKlass::make(T_INT);\n-    Node* klass_node = makecon(TypeKlassPtr::make(klass));\n-\n-    IdealKit ideal(this);\n-\n-#define __ ideal.\n-     Node* one = __ ConI(1);\n-     Node* zero = __ ConI(0);\n-     IdealVariable need_alloc(ideal), z_alloc(ideal);  __ declarations_done();\n-     __ set(need_alloc, zero);\n-     __ set(z_alloc, z);\n-     __ if_then(z, BoolTest::eq, null()); {\n-       __ increment (need_alloc, one);\n-     } __ else_(); {\n-       \/\/ Update graphKit memory and control from IdealKit.\n-       sync_kit(ideal);\n-       Node* cast = new CastPPNode(control(), z, TypePtr::NOTNULL);\n-       _gvn.set_type(cast, cast->bottom_type());\n-       C->record_for_igvn(cast);\n-\n-       Node* zlen_arg = load_array_length(cast);\n-       \/\/ Update IdealKit memory and control from graphKit.\n-       __ sync_kit(this);\n-       __ if_then(zlen_arg, BoolTest::lt, zlen); {\n-         __ increment (need_alloc, one);\n-       } __ end_if();\n-     } __ end_if();\n-\n-     __ if_then(__ value(need_alloc), BoolTest::ne, zero); {\n-       \/\/ Update graphKit memory and control from IdealKit.\n-       sync_kit(ideal);\n-       Node * narr = new_array(klass_node, zlen, 1);\n-       \/\/ Update IdealKit memory and control from graphKit.\n-       __ sync_kit(this);\n-       __ set(z_alloc, narr);\n-     } __ end_if();\n-\n-     sync_kit(ideal);\n-     z = __ value(z_alloc);\n-     \/\/ Can't use TypeAryPtr::INTS which uses Bottom offset.\n-     _gvn.set_type(z, TypeOopPtr::make_from_klass(klass));\n-     \/\/ Final sync IdealKit and GraphKit.\n-     final_sync(ideal);\n-#undef __\n-\n-    Node* z_start = array_element_address(z, intcon(0), T_INT);\n-\n-    Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                                   OptoRuntime::multiplyToLen_Type(),\n-                                   stubAddr, stubName, TypePtr::BOTTOM,\n-                                   x_start, xlen, y_start, ylen, z_start, zlen);\n-  } \/\/ original reexecute is set back here\n+  Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                 OptoRuntime::multiplyToLen_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 x_start, xlen, y_start, ylen, z_start);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":63,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -351,1 +351,4 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4 && assertion_predicate_has_loop_opaque_node(iff)) {\n+    Node* bol = iff->in(1);\n+    assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n+    if (bol->is_Opaque4()) {\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -354,1 +357,1 @@\n-        list.push(iff->in(1));\n+        list.push(bol);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1204,1 +1204,1 @@\n-      if (bol->req() != 2) {\n+      if (bol->req() < 2) {\n@@ -1208,1 +1208,2 @@\n-        assert(bol->Opcode() == Op_Conv2B, \"predicate check only\");\n+        assert(bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate(),\n+               \"Opaque node of non-null-check or of Initialized Assertion Predicate\");\n@@ -1388,2 +1389,4 @@\n-      if (iff->in(1)->Opcode() == Op_Opaque4) {\n-        assert(assertion_predicate_has_loop_opaque_node(iff), \"unexpected\");\n+      Node* bol = iff->in(1);\n+      assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n+      if (bol->is_Opaque4()) {\n+        assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -1499,1 +1502,1 @@\n-  Opaque4Node* new_opaque4_node;\n+  Node* new_opaque_node;\n@@ -1501,1 +1504,1 @@\n-    \/\/ Only set a new OpaqueLoopInitNode node and clone the existing OpaqueLoopStrideNode without modification.\n+    \/\/ Clone the Template Assertion Predicate and set a new OpaqueLoopInitNode to create a new Template Assertion Predicate.\n@@ -1503,0 +1506,1 @@\n+    \/\/ We keep the Opaque4 node since it's still a template.\n@@ -1504,1 +1508,1 @@\n-    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n+    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n@@ -1506,1 +1510,2 @@\n-    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n+    \/\/ Create an Initialized Assertion Predicate from the Template Assertion Predicate.\n+    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n@@ -1508,0 +1513,3 @@\n+    \/\/ Since this is an Initialized Assertion Predicate, we use the dedicated opaque node.\n+    new_opaque_node = new OpaqueInitializedAssertionPredicateNode(new_opaque_node->in(1)->as_Bool(), C);\n+    register_new_node(new_opaque_node, control);\n@@ -1512,1 +1520,1 @@\n-  new_iff->set_req(1, new_opaque4_node);\n+  new_iff->set_req(1, new_opaque_node);\n@@ -1968,1 +1976,1 @@\n-    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+    if (!proj->unique_ctrl_out()->is_Halt()) {\n@@ -1971,7 +1979,5 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4) {\n-      if (!assertion_predicate_has_loop_opaque_node(iff)) {\n-        \/\/ No OpaqueLoop* node? Then it's one of the two Initialized Assertion Predicates:\n-        \/\/ - For the initial access a[init]\n-        \/\/ - For the last access a[init+old_stride-orig_stride]\n-        \/\/ We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n-        \/\/ We will create new Initialized Assertion Predicates from the Template Assertion Predicates below:\n+    Node* bol = iff->in(1);\n+    if (bol->is_Opaque4()) {\n+      if (assertion_predicate_has_loop_opaque_node(iff)) {\n+        \/\/ This is a Template Assertion Predicate for the initial or last access.\n+        \/\/ Create an Initialized Assertion Predicates for it accordingly:\n@@ -1980,3 +1986,0 @@\n-        _igvn.replace_input_of(iff, 1, iff->in(1)->in(2));\n-      } else {\n-        \/\/ Template Assertion Predicate: Clone it to create initialized version with new stride.\n@@ -1986,0 +1989,4 @@\n+      } else {\n+        \/\/ Ignore Opaque4 from a non-null-check for an intrinsic or unsafe access. This could happen when we maximally\n+        \/\/ unroll a non-main loop with such an If with an Opaque4 node directly above the loop entry.\n+        assert(!loop_head->is_main_loop(), \"Opaque4 node from a non-null check - should not be at main loop\");\n@@ -1987,0 +1994,6 @@\n+    } else if (bol->is_OpaqueInitializedAssertionPredicate()) {\n+      \/\/ This is one of the two Initialized Assertion Predicates:\n+      \/\/ - For the initial access a[init]\n+      \/\/ - For the last access a[init+old_stride-orig_stride]\n+      \/\/ We could keep the one for the initial access but we do not know which one we currently have here. Just kill both.\n+      _igvn.replace_input_of(iff, 1, _igvn.intcon(1));\n@@ -2009,1 +2022,1 @@\n-    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+    if (!proj->unique_ctrl_out()->is_Halt()) {\n@@ -2012,1 +2025,3 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4 && assertion_predicate_has_loop_opaque_node(iff)) {\n+    if (iff->in(1)->is_Opaque4()) {\n+      \/\/ Initialize from Template Assertion Predicate.\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -2015,1 +2030,1 @@\n-      assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"unexpected\");\n+      assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"must not find OpaqueLoop* nodes\");\n@@ -2046,2 +2061,5 @@\n-    if (iff->in(1)->Opcode() == Op_Opaque4) {\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"unexpected\");\n+    Node* bol = iff->in(1);\n+    assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n+    if (bol->is_Opaque4()) {\n+      \/\/ Initialize from Template Assertion Predicate.\n+      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -2770,4 +2788,4 @@\n-Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop,\n-                                                                      Node* ctrl, const int scale_con,\n-                                                                      Node* offset, Node* limit, jint stride_con,\n-                                                                      Node* value) {\n+Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(IdealLoopTree* loop, Node* ctrl,\n+                                                                      const int scale_con, Node* offset, Node* limit,\n+                                                                      jint stride_con, Node* value,\n+                                                                      const bool is_template) {\n@@ -2777,2 +2795,7 @@\n-  Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));\n-  register_new_node(opaque_bol, ctrl);\n+  Node* opaque_assertion_predicate;\n+  if (is_template) {\n+    opaque_assertion_predicate = new Opaque4Node(C, bol, _igvn.intcon(1));\n+  } else {\n+    opaque_assertion_predicate = new OpaqueInitializedAssertionPredicateNode(bol, C);\n+  }\n+  register_new_node(opaque_assertion_predicate, ctrl);\n@@ -2781,1 +2804,1 @@\n-    new_iff = new IfNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n+    new_iff = new IfNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n@@ -2783,1 +2806,1 @@\n-    new_iff = new RangeCheckNode(ctrl, opaque_bol, PROB_MAX, COUNT_UNKNOWN);\n+    new_iff = new RangeCheckNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n@@ -2984,1 +3007,1 @@\n-                                                                       int_limit, stride_con, init);\n+                                                                       int_limit, stride_con, init, false);\n@@ -2990,1 +3013,1 @@\n-                                                                       int_limit, stride_con, opaque_init);\n+                                                                       int_limit, stride_con, opaque_init, true);\n@@ -3003,1 +3026,1 @@\n-                                                                       int_limit, stride_con, max_value);\n+                                                                       int_limit, stride_con, max_value, true);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":59,"deletions":36,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -4383,4 +4383,3 @@\n-    Node* opaque4 = C->template_assertion_predicate_opaq_node(i - 1);\n-    assert(opaque4->Opcode() == Op_Opaque4, \"must be\");\n-    if (!useful_predicates.member(opaque4)) { \/\/ not in the useful list\n-      _igvn.replace_node(opaque4, opaque4->in(2));\n+    Opaque4Node* opaque4_node = C->template_assertion_predicate_opaq_node(i - 1)->as_Opaque4();\n+    if (!useful_predicates.member(opaque4_node)) { \/\/ not in the useful list\n+      _igvn.replace_node(opaque4_node, opaque4_node->in(2));\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1388,1 +1388,2 @@\n-                                                        Node* offset, Node* limit, jint stride_con, Node* value);\n+                                                        Node* offset, Node* limit, int stride_con, Node* value,\n+                                                        bool is_template);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -793,2 +793,6 @@\n-  if (bol->Opcode() == Op_Opaque4) {\n-    return nullptr; \/\/ Ignore loop predicate checks (the Opaque4 ensures they will go away)\n+  assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"Initialized Assertion Predicates cannot form a diamond with Halt\");\n+  if (bol->is_Opaque4()) {\n+    \/\/ Ignore Template Assertion Predicates with Opaque4 nodes.\n+    assert(assertion_predicate_has_loop_opaque_node(iff),\n+           \"must be Template Assertion Predicate, non-null-check with Opaque4 cannot form a diamond with Halt\");\n+    return nullptr;\n@@ -1838,1 +1842,2 @@\n-      n->Opcode() != Op_Opaque4 &&\n+      !n->is_Opaque4() &&\n+      !n->is_OpaqueInitializedAssertionPredicate() &&\n@@ -2151,1 +2156,1 @@\n-    Node *b = phi->in(i);\n+    Node* b = phi->in(i);\n@@ -2155,1 +2160,2 @@\n-      assert(b->is_Bool() || b->Opcode() == Op_Opaque4, \"\");\n+      assert(b->is_Bool() || b->is_Opaque4() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with Opaque4 node or Initialized Assertion Predicate with its Opaque node\");\n@@ -2158,1 +2164,0 @@\n-\n@@ -2162,1 +2167,1 @@\n-  if (n->Opcode() == Op_Opaque4) {\n+  if (n->is_Opaque4() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2343,1 +2348,1 @@\n-      if (use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque4 ||\n+      if (use->is_If() || use->is_CMove() || use->is_Opaque4() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1489,3 +1489,2 @@\n-    \/\/ might be a TRUE for finalizers or a fancy class check for\n-    \/\/ newInstance0.\n-    IfNode* toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n+    \/\/ might be a TRUE for finalizers.\n+    IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n@@ -2942,1 +2941,2 @@\n-               n->Opcode() == Op_Opaque4   ||\n+               n->is_Opaque4()             ||\n+               n->is_OpaqueInitializedAssertionPredicate() ||\n@@ -3020,1 +3020,1 @@\n-      } else if (n->Opcode() == Op_Opaque4) {\n+      } else if (n->is_Opaque4()) {\n@@ -3033,0 +3033,11 @@\n+      } else if (n->is_OpaqueInitializedAssertionPredicate()) {\n+          \/\/ Initialized Assertion Predicates must always evaluate to true. Therefore, we get rid of them in product\n+          \/\/ builds as they are useless. In debug builds we keep them as additional verification code. Even though\n+          \/\/ loop opts are already over, we want to keep Initialized Assertion Predicates alive as long as possible to\n+          \/\/ enable folding of dead control paths within which cast nodes become top after due to impossible types -\n+          \/\/ even after loop opts are over. Therefore, we delay the removal of these opaque nodes until now.\n+#ifdef ASSERT\n+        _igvn.replace_node(n, n->in(1));\n+#else\n+        _igvn.replace_node(n, _igvn.intcon(1));\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3570,1 +3570,4 @@\n-    result = mem;\n+    \/\/ Ensure vector type is the same\n+    if (!is_StoreVector() || as_StoreVector()->vect_type() == mem->as_LoadVector()->vect_type()) {\n+      result = mem;\n+    }\n@@ -3579,1 +3582,18 @@\n-    result = mem;\n+    if (!is_StoreVector()) {\n+      result = mem;\n+    } else {\n+      const StoreVectorNode* store_vector = as_StoreVector();\n+      const StoreVectorNode* mem_vector = mem->as_StoreVector();\n+      const Node* store_indices = store_vector->indices();\n+      const Node* mem_indices = mem_vector->indices();\n+      const Node* store_mask = store_vector->mask();\n+      const Node* mem_mask = mem_vector->mask();\n+      \/\/ Ensure types, indices, and masks match\n+      if (store_vector->vect_type() == mem_vector->vect_type() &&\n+          ((store_indices == nullptr) == (mem_indices == nullptr) &&\n+           (store_indices == nullptr || store_indices->eqv_uncast(mem_indices))) &&\n+          ((store_mask == nullptr) == (mem_mask == nullptr) &&\n+           (store_mask == nullptr || store_mask->eqv_uncast(mem_mask)))) {\n+        result = mem;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -617,1 +617,1 @@\n-  if (Opcode() == Op_Opaque4) {\n+  if (is_Opaque4()) {\n@@ -2888,9 +2888,0 @@\n-void Node::add_prec_from(Node* n) {\n-  for (uint i = n->req(); i < n->len(); i++) {\n-    Node* prec = n->in(i);\n-    if (prec != nullptr) {\n-      add_prec(prec);\n-    }\n-  }\n-}\n-\n@@ -2920,3 +2911,0 @@\n-bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n-                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+class OpaqueInitializedAssertionPredicateNode;\n@@ -187,0 +188,1 @@\n+class LoadVectorGatherMaskedNode;\n@@ -189,0 +191,1 @@\n+class StoreVectorScatterMaskedNode;\n@@ -807,3 +810,4 @@\n-    DEFINE_CLASS_ID(Move,     Node, 18)\n-    DEFINE_CLASS_ID(LShift,   Node, 19)\n-    DEFINE_CLASS_ID(Neg,      Node, 20)\n+    DEFINE_CLASS_ID(OpaqueInitializedAssertionPredicate,  Node, 18)\n+    DEFINE_CLASS_ID(Move,     Node, 19)\n+    DEFINE_CLASS_ID(LShift,   Node, 20)\n+    DEFINE_CLASS_ID(Neg,      Node, 21)\n@@ -982,0 +986,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueInitializedAssertionPredicate)\n@@ -1013,0 +1018,2 @@\n+  DEFINE_CLASS_QUERY(LoadVectorMasked)\n+  DEFINE_CLASS_QUERY(LoadVectorGatherMasked)\n@@ -1015,0 +1022,2 @@\n+  DEFINE_CLASS_QUERY(StoreVectorMasked)\n+  DEFINE_CLASS_QUERY(StoreVectorScatterMasked)\n@@ -1160,1 +1169,0 @@\n-  void add_prec_from(Node* n);\n@@ -1272,2 +1280,0 @@\n-  bool is_div_or_mod(BasicType bt) const;\n-\n@@ -2043,4 +2049,0 @@\n-Op_IL(Div)\n-Op_IL(Mod)\n-Op_IL(UDiv)\n-Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+const Type* OpaqueInitializedAssertionPredicateNode::Value(PhaseGVN* phase) const {\n+  return phase->type(in(1));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  Opaque4Node(Compile* C, Node *tst, Node* final_tst) : Node(nullptr, tst, final_tst) {\n+  Opaque4Node(Compile* C, Node* tst, Node* final_tst) : Node(nullptr, tst, final_tst) {\n@@ -131,1 +131,0 @@\n-  virtual const Type *bottom_type() const { return TypeInt::BOOL; }\n@@ -133,0 +132,1 @@\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n@@ -135,0 +135,15 @@\n+\/\/ This node is used for Initialized Assertion Predicate BoolNodes. Initialized Assertion Predicates must always evaluate\n+\/\/ to true. Therefore, we get rid of them in product builds during macro expansion as they are useless. In debug builds\n+\/\/ we keep them as additional verification code (i.e. removing this node and use the BoolNode input instead).\n+class OpaqueInitializedAssertionPredicateNode : public Node {\n+ public:\n+  OpaqueInitializedAssertionPredicateNode(BoolNode* bol, Compile* C) : Node(nullptr, bol) {\n+    init_class_id(Class_OpaqueInitializedAssertionPredicate);\n+    init_flags(Flag_is_macro);\n+    C->add_macro_node(this);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+};\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  return has_opaque4(predicate_proj) && has_halt(predicate_proj);\n+  return has_assertion_predicate_opaque(predicate_proj) && has_halt(predicate_proj);\n@@ -48,2 +48,3 @@\n-\/\/ Check if the If node of `predicate_proj` has an Opaque4 node as input.\n-bool AssertionPredicatesWithHalt::has_opaque4(const Node* predicate_proj) {\n+\/\/ Check if the If node of `predicate_proj` has an Opaque4 (Template Assertion Predicate) or an\n+\/\/ OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node as input.\n+bool AssertionPredicatesWithHalt::has_assertion_predicate_opaque(const Node* predicate_proj) {\n@@ -51,1 +52,2 @@\n-  return iff->in(1)->Opcode() == Op_Opaque4;\n+  Node* bol = iff->in(1);\n+  return bol->is_Opaque4() || bol->is_OpaqueInitializedAssertionPredicate();\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-  static bool has_opaque4(const Node* predicate_proj);\n+  static bool has_assertion_predicate_opaque(const Node* predicate_proj);\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1159,1 +1159,1 @@\n-  int num_args      = 6;\n+  int num_args      = 5;\n@@ -1168,1 +1168,0 @@\n-  fields[argp++] = TypeInt::INT;        \/\/ zlen\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-            if (use->Opcode() == Op_Opaque4) {\n+            if (use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate()) {\n@@ -355,2 +355,2 @@\n-              \/\/ Uses are either IfNodes, CMoves or Opaque4\n-              if (u->Opcode() == Op_Opaque4) {\n+              \/\/ Uses are either IfNodes, CMoves, Opaque4, or OpaqueInitializedAssertionPredicates\n+              if (u->is_Opaque4() || u->is_OpaqueInitializedAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -418,5 +418,1 @@\n-  switch (n->Opcode()) {\n-  case Op_MulAddS2I:\n-    return true;\n-  }\n-  return false;\n+  return n->Opcode() == Op_MulAddS2I;\n@@ -430,4 +426,1 @@\n-  if (n->Opcode() == Op_MulAddS2I) {\n-    return true;\n-  }\n-  return false;\n+  return n->Opcode() == Op_MulAddS2I;\n@@ -437,4 +430,1 @@\n-  if (n->Opcode() == Op_RoundDoubleMode) {\n-    return true;\n-  }\n-  return false;\n+  return n->Opcode() == Op_RoundDoubleMode;\n@@ -587,4 +577,1 @@\n-  if (is_rotate_opcode(n->Opcode())) {\n-    return true;\n-  }\n-  return false;\n+  return is_rotate_opcode(n->Opcode());\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -913,0 +913,4 @@\n+  virtual int store_Opcode() const {\n+    \/\/ Ensure it is different from any store opcode to avoid folding when indices are used\n+    return -1;\n+  }\n@@ -945,0 +949,2 @@\n+  virtual Node* mask() const { return nullptr; }\n+  virtual Node* indices() const { return nullptr; }\n@@ -960,0 +966,1 @@\n+   enum { Indices = 4 };\n@@ -971,0 +978,1 @@\n+   virtual Node* indices() const { return in(Indices); }\n@@ -977,0 +985,1 @@\n+  enum { Mask = 4 };\n@@ -990,0 +999,1 @@\n+  virtual Node* mask() const { return in(Mask); }\n@@ -1010,0 +1020,4 @@\n+  virtual int store_Opcode() const {\n+    \/\/ Ensure it is different from any store opcode to avoid folding when a mask is used\n+    return -1;\n+  }\n@@ -1033,0 +1047,4 @@\n+  virtual int store_Opcode() const {\n+    \/\/ Ensure it is different from any store opcode to avoid folding when indices and mask are used\n+    return -1;\n+  }\n@@ -1039,0 +1057,3 @@\n+   enum { Indices = 4,\n+          Mask\n+   };\n@@ -1053,0 +1074,2 @@\n+   virtual Node* mask() const { return in(Mask); }\n+   virtual Node* indices() const { return in(Indices); }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,2 @@\n-  static void capture_state(int32_t* value_ptr, int captured_state_mask);\n+  \/\/ This is defined as JVM_LEAF which adds the JNICALL modifier.\n+  static void JNICALL capture_state(int32_t* value_ptr, int captured_state_mask);\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -8252,1 +8252,2 @@\n-              The thread owning this monitor, or <code>nullptr<\/code> if unused\n+              The platform thread owning this monitor, or <code>nullptr<\/code> if owned\n+              by a virtual thread or not owned\n@@ -8258,1 +8259,2 @@\n-            The number of times the owning thread has entered the monitor\n+            The number of times the platform thread owning this monitor has entered it, \n+            or <code>0<\/code> if owned by a virtual thread or not owned\n@@ -8264,1 +8266,2 @@\n-            The number of threads waiting to own this monitor\n+            The number of platform threads waiting to own this monitor, or <code>0<\/code>\n+            if only virtual threads are waiting or no threads are waiting\n@@ -8270,1 +8273,1 @@\n-              The <code>waiter_count<\/code> waiting threads\n+              The <code>waiter_count<\/code> waiting platform threads\n@@ -8276,1 +8279,3 @@\n-            The number of threads waiting to be notified by this monitor\n+            The number of platform threads waiting to own this monitor, or <code>0<\/code>\n+            if only virtual threads are waiting to be notified or no threads are waiting\n+            to be notified\n@@ -8282,1 +8287,1 @@\n-              The <code>notify_waiter_count<\/code> threads waiting to be notified\n+              The <code>notify_waiter_count<\/code> platform threads waiting to be notified\n@@ -8290,0 +8295,6 @@\n+        <p\/>\n+        <b> This function does not support getting information about an object's monitor\n+            when it is owned by a virtual thread. It also does not support returning a\n+            reference to virtual threads that are waiting to own a monitor or waiting to\n+            be notified.\n+        <\/b>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -453,0 +453,9 @@\n+    <xsl:value-of select=\"$space\"\/>\n+    <xsl:if test=\"$trace='Trace'\">\n+      <xsl:text>if (trace_flags) {<\/xsl:text>\n+      <xsl:value-of select=\"$space\"\/>\n+      <xsl:text>  curr_thread_name = JvmtiTrace::safe_get_current_thread_name();<\/xsl:text>\n+      <xsl:value-of select=\"$space\"\/>\n+      <xsl:text>}<\/xsl:text>\n+      <xsl:value-of select=\"$space\"\/>\n+    <\/xsl:if>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1485,1 +1485,6 @@\n-    Handle th(current_thread, get_vthread_or_thread_oop(owning_thread));\n+    oop thread_oop = get_vthread_or_thread_oop(owning_thread);\n+    bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+    if (is_virtual) {\n+      thread_oop = nullptr;\n+    }\n+    Handle th(current_thread, thread_oop);\n@@ -1492,1 +1497,1 @@\n-    ret.entry_count = count_locked_objects(owning_thread, hobj);\n+    ret.entry_count = is_virtual ? 0 : count_locked_objects(owning_thread, hobj);\n@@ -1516,0 +1521,1 @@\n+  jint skipped = 0;\n@@ -1525,0 +1531,5 @@\n+      JavaThread *w = mon->thread_of_waiter(waiter);\n+      oop thread_oop = get_vthread_or_thread_oop(w);\n+      if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+        skipped++;\n+      }\n@@ -1529,1 +1540,1 @@\n-  ret.notify_waiter_count = nWait;\n+  ret.notify_waiter_count = nWait - skipped;\n@@ -1549,2 +1560,6 @@\n-    memset(ret.waiters, 0, ret.waiter_count * sizeof(jthread *));\n-    memset(ret.notify_waiters, 0, ret.notify_waiter_count * sizeof(jthread *));\n+    if (ret.waiters != nullptr) {\n+      memset(ret.waiters, 0, ret.waiter_count * sizeof(jthread *));\n+    }\n+    if (ret.notify_waiters != nullptr) {\n+      memset(ret.notify_waiters, 0, ret.notify_waiter_count * sizeof(jthread *));\n+    }\n@@ -1564,0 +1579,1 @@\n+      jint skipped = 0;\n@@ -1566,0 +1582,2 @@\n+        oop thread_oop = get_vthread_or_thread_oop(w);\n+        bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n@@ -1567,4 +1585,8 @@\n-        \/\/ If the thread was found on the ObjectWaiter list, then\n-        \/\/ it has not been notified.\n-        Handle th(current_thread, get_vthread_or_thread_oop(w));\n-        ret.notify_waiters[i] = (jthread)jni_reference(calling_thread, th);\n+        if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+          skipped++;\n+        } else {\n+          \/\/ If the thread was found on the ObjectWaiter list, then\n+          \/\/ it has not been notified.\n+          Handle th(current_thread, get_vthread_or_thread_oop(w));\n+          ret.notify_waiters[i - skipped] = (jthread)jni_reference(calling_thread, th);\n+        }\n@@ -2627,8 +2649,0 @@\n-\n-void\n-VirtualThreadGetThreadClosure::do_thread(Thread *target) {\n-  assert(target->is_Java_thread(), \"just checking\");\n-  JavaThread *jt = JavaThread::cast(target);\n-  oop carrier_thread = java_lang_VirtualThread::carrier_thread(_vthread_h());\n-  *_carrier_thread_ptr = (jthread)JNIHandles::make_local(jt, carrier_thread);\n-}\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -787,18 +787,0 @@\n-\/\/ HandshakeClosure to get virtual thread thread at safepoint.\n-class VirtualThreadGetThreadClosure : public HandshakeClosure {\n-private:\n-  Handle _vthread_h;\n-  jthread* _carrier_thread_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetThreadClosure(Handle vthread_h, jthread* carrier_thread_ptr)\n-    : HandshakeClosure(\"VirtualThreadGetThread\"),\n-      _vthread_h(vthread_h),\n-      _carrier_thread_ptr(carrier_thread_ptr),\n-      _result(JVMTI_ERROR_NONE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,4 @@\n+  if (thread_ptr == nullptr) {\n+    return JVMTI_ERROR_NULL_POINTER;\n+  }\n+\n@@ -159,6 +163,5 @@\n-  if (thread_ptr == nullptr) {\n-    return JVMTI_ERROR_NULL_POINTER;\n-  }\n-  VirtualThreadGetThreadClosure op(Handle(current_thread, vthread_oop), thread_ptr);\n-  Handshake::execute(&op, &tlh, current_thread);\n-  return op.result();\n+\n+  oop carrier_thread = java_lang_VirtualThread::carrier_thread(vthread_oop);\n+  *thread_ptr = (jthread)JNIHandles::make_local(current_thread, carrier_thread);\n+\n+  return JVMTI_ERROR_NONE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -280,0 +281,6 @@\n+  if (Thread::current()->is_Java_thread()) {\n+    JavaThreadState current_state = JavaThread::cast(Thread::current())->thread_state();\n+    if (current_state == _thread_in_native || current_state == _thread_blocked) {\n+      return \"not readable\";\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing(p);\n+    const G1HeapRegion* hr = g1h->heap_region_containing(p);\n@@ -484,1 +484,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing(result);\n+    const G1HeapRegion* hr = g1h->heap_region_containing(result);\n@@ -493,1 +493,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n+    const G1HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n@@ -502,1 +502,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n+    const G1HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n@@ -545,1 +545,1 @@\n-    return (jint)HeapRegion::GrainBytes;\n+    return (jint)G1HeapRegion::GrainBytes;\n@@ -632,1 +632,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -636,1 +636,1 @@\n-      size_t reg_size = HeapRegion::GrainBytes;\n+      size_t reg_size = G1HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2354,0 +2354,9 @@\n+    } else if (match_option(option, \"--sun-misc-unsafe-memory-access=\", &tail)) {\n+      if (strcmp(tail, \"allow\") == 0 || strcmp(tail, \"warn\") == 0 || strcmp(tail, \"debug\") == 0 || strcmp(tail, \"deny\") == 0) {\n+        PropertyList_unique_add(&_system_properties, \"sun.misc.unsafe.memory.access\", tail,\n+                                AddProperty, WriteableProperty, InternalProperty);\n+      } else {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"Value specified to --sun-misc-unsafe-memory-access not recognized: '%s'\\n\", tail);\n+        return JNI_ERR;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1278,1 +1278,0 @@\n-#if COMPILER2_OR_JVMCI\n@@ -1284,3 +1283,0 @@\n-#else\n-        obj = ik->allocate_instance(THREAD);\n-#endif \/\/ COMPILER2_OR_JVMCI\n@@ -1667,1 +1663,0 @@\n-#if COMPILER2_OR_JVMCI\n@@ -1687,1 +1682,0 @@\n-#endif \/* !COMPILER2_OR_JVMCI *\/\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2234,2 +2234,2 @@\n-      log_trace(os, thread)(\"Pretouching thread stack from \" PTR_FORMAT \" to \" PTR_FORMAT \".\",\n-                            p2i(p2), p2i(end));\n+      log_trace(os, thread)(\"Pretouching thread stack for \" UINTX_FORMAT \": \" RANGEFMT \".\",\n+                            (uintx) osthread()->thread_id(), RANGEFMTARGS(p2, to_alloc));\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,0 +114,10 @@\n+int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {\n+  ALLOW_C_FUNCTION(::vsnprintf, int result = ::vsnprintf(buf, len, fmt, args);)\n+  \/\/ If an encoding error occurred (result < 0) then it's not clear\n+  \/\/ whether the buffer is NUL terminated, so ensure it is.\n+  if ((result < 0) && (len > 0)) {\n+    buf[len - 1] = '\\0';\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -774,2 +774,2 @@\n-  \/\/ Provide C99 compliant versions of these functions, since some versions\n-  \/\/ of some platforms don't.\n+  \/\/ Provide wrapper versions of these functions to guarantee NUL-termination\n+  \/\/ in all cases.\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -596,2 +596,0 @@\n-  static ByteSize allocated_bytes_offset()       { return byte_offset_of(Thread, _allocated_bytes); }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1187,1 +1187,2 @@\n-\/\/ Get count of Java threads that are waiting to enter or re-enter the specified monitor.\n+\/\/ Get Java threads that are waiting to enter or re-enter the specified monitor.\n+\/\/ Java threads that are executing mounted virtual threads are not included.\n@@ -1198,0 +1199,4 @@\n+    oop thread_oop = JvmtiEnvBase::get_vthread_or_thread_oop(p);\n+    if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+      continue;\n+    }\n@@ -1202,4 +1207,2 @@\n-    oop thread_oop = JvmtiEnvBase::get_vthread_or_thread_oop(p);\n-    bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n-    jint state = is_virtual ? JvmtiEnvBase::get_vthread_state(thread_oop, p)\n-                            : JvmtiEnvBase::get_thread_state(thread_oop, p);\n+    \/\/ do not include virtual threads to the list\n+    jint state = JvmtiEnvBase::get_thread_state(thread_oop, p);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -132,1 +132,2 @@\n-  \/\/ Get count of Java threads that are waiting to enter or re-enter the specified monitor.\n+  \/\/ Get Java threads that are waiting to enter or re-enter the specified monitor.\n+  \/\/ Java threads that are executing mounted virtual threads are not included.\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2085,1 +2085,2 @@\n-\/\/ Crash with an authentic sigfpe\n+\/\/ Crash with an authentic sigfpe; behavior is subtly different from a real signal\n+\/\/ compared to one generated with raise (asynchronous vs synchronous). See JDK-8065895.\n@@ -2087,0 +2088,4 @@\n+\n+#if defined(__clang__) || defined(__GNUC__)\n+__attribute__((no_sanitize(\"undefined\")))\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -153,0 +154,63 @@\n+    \/**\n+     * Writes a string representation of the specified object to this console's\n+     * output stream, terminates the line using {@link System#lineSeparator()}\n+     * and then flushes the console.\n+     *\n+     * <p> The string representation of the specified object is obtained as if\n+     * by calling {@link String#valueOf(Object)}.\n+     *\n+     * @param  obj\n+     *         An object whose string representation is to be written,\n+     *         may be {@code null}.\n+     *\n+     * @return  This console\n+     *\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.IMPLICIT_CLASSES)\n+    public Console println(Object obj) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Writes a string representation of the specified object to this console's\n+     * output stream and then flushes the console.\n+     *\n+     * <p> The string representation of the specified object is obtained as if\n+     * by calling {@link String#valueOf(Object)}.\n+     *\n+     * @param  obj\n+     *         An object whose string representation is to be written,\n+     *         may be {@code null}.\n+     *\n+     * @return  This console\n+     *\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.IMPLICIT_CLASSES)\n+    public Console print(Object obj) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Writes a prompt as if by calling {@code print}, then reads a single line\n+     * of text from this console.\n+     *\n+     * @param  prompt\n+     *         A prompt string, may be {@code null}.\n+     *\n+     * @throws IOError\n+     *         If an I\/O error occurs.\n+     *\n+     * @return  A string containing the line read from the console, not\n+     *          including any line-termination characters, or {@code null}\n+     *          if an end of stream has been reached without having read\n+     *          any characters.\n+     *\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.IMPLICIT_CLASSES)\n+    public String readln(String prompt) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A collection of static convenience methods that provide access to\n+ * {@linkplain System#console() system console} for implicitly declared classes.\n+ *\n+ * <p> Each of this class' methods throws {@link IOError} if the system console\n+ * is {@code null}; otherwise, the effect is as if a similarly-named method\n+ * had been called on that console.\n+ *\n+ * <p> Input and output from methods in this class use the character set of\n+ * the system console as specified by {@link Console#charset}.\n+ *\n+ * @since 23\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.IMPLICIT_CLASSES)\n+public final class IO {\n+\n+    private IO() {\n+        throw new Error(\"no instances\");\n+    }\n+\n+    \/**\n+     * Writes a string representation of the specified object to the system\n+     * console, terminates the line and then flushes that console.\n+     *\n+     * <p> The effect is as if {@link Console#println(Object) println(obj)}\n+     * had been called on {@code System.console()}.\n+     *\n+     * @param obj the object to print, may be {@code null}\n+     *\n+     * @throws IOError if {@code System.console()} returns {@code null},\n+     *                 or if an I\/O error occurs\n+     *\/\n+    public static void println(Object obj) {\n+        con().println(obj);\n+    }\n+\n+    \/**\n+     * Writes a string representation of the specified object to the system\n+     * console and then flushes that console.\n+     *\n+     * <p> The effect is as if {@link Console#print(Object) print(obj)}\n+     * had been called on {@code System.console()}.\n+     *\n+     * @param obj the object to print, may be {@code null}\n+     *\n+     * @throws IOError if {@code System.console()} returns {@code null},\n+     *                 or if an I\/O error occurs\n+     *\/\n+    public static void print(Object obj) {\n+        con().print(obj);\n+    }\n+\n+    \/**\n+     * Writes a prompt as if by calling {@code print}, then reads a single line\n+     * of text from the system console.\n+     *\n+     * <p> The effect is as if {@link Console#readln(String) readln(prompt)}\n+     * had been called on {@code System.console()}.\n+     *\n+     * @param prompt the prompt string, may be {@code null}\n+     *\n+     * @return a string containing the line read from the system console, not\n+     * including any line-termination characters. Returns {@code null} if an\n+     * end of stream has been reached without having read any characters.\n+     *\n+     * @throws IOError if {@code System.console()} returns {@code null},\n+     *                 or if an I\/O error occurs\n+     *\/\n+    public static String readln(String prompt) {\n+        return con().readln(prompt);\n+    }\n+\n+    private static Console con() {\n+        var con = System.console();\n+        if (con != null) {\n+            return con;\n+        } else {\n+            throw new IOError(null);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/IO.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -84,0 +84,36 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console println(Object obj) {\n+        synchronized (writeLock) {\n+            delegate.println(obj);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console print(Object obj) {\n+        synchronized (writeLock) {\n+            delegate.print(obj);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws IOError {@inheritDoc}\n+     *\/\n+    @Override\n+    public String readln(String prompt) {\n+        synchronized (writeLock) {\n+            synchronized (readLock) {\n+                return delegate.readln(prompt);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ProxyingConsole.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,61 +27,3 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n-import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n-import java.lang.classfile.attribute.CharacterRangeInfo;\n-import java.lang.classfile.attribute.CharacterRangeTableAttribute;\n-import java.lang.classfile.attribute.CodeAttribute;\n-import java.lang.classfile.attribute.CompilationIDAttribute;\n-import java.lang.classfile.attribute.ConstantValueAttribute;\n-import java.lang.classfile.attribute.DeprecatedAttribute;\n-import java.lang.classfile.attribute.EnclosingMethodAttribute;\n-import java.lang.classfile.attribute.ExceptionsAttribute;\n-import java.lang.classfile.attribute.InnerClassInfo;\n-import java.lang.classfile.attribute.InnerClassesAttribute;\n-import java.lang.classfile.attribute.LineNumberInfo;\n-import java.lang.classfile.attribute.LineNumberTableAttribute;\n-import java.lang.classfile.attribute.LoadableDescriptorsAttribute;\n-import java.lang.classfile.attribute.LocalVariableInfo;\n-import java.lang.classfile.attribute.LocalVariableTableAttribute;\n-import java.lang.classfile.attribute.LocalVariableTypeInfo;\n-import java.lang.classfile.attribute.LocalVariableTypeTableAttribute;\n-import java.lang.classfile.attribute.MethodParameterInfo;\n-import java.lang.classfile.attribute.MethodParametersAttribute;\n-import java.lang.classfile.attribute.ModuleAttribute;\n-import java.lang.classfile.attribute.ModuleExportInfo;\n-import java.lang.classfile.attribute.ModuleHashInfo;\n-import java.lang.classfile.attribute.ModuleHashesAttribute;\n-import java.lang.classfile.attribute.ModuleMainClassAttribute;\n-import java.lang.classfile.attribute.ModuleOpenInfo;\n-import java.lang.classfile.attribute.ModulePackagesAttribute;\n-import java.lang.classfile.attribute.ModuleProvideInfo;\n-import java.lang.classfile.attribute.ModuleRequireInfo;\n-import java.lang.classfile.attribute.ModuleResolutionAttribute;\n-import java.lang.classfile.attribute.ModuleTargetAttribute;\n-import java.lang.classfile.attribute.NestHostAttribute;\n-import java.lang.classfile.attribute.NestMembersAttribute;\n-import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n-import java.lang.classfile.attribute.RecordAttribute;\n-import java.lang.classfile.attribute.RecordComponentInfo;\n-import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import java.lang.classfile.attribute.SignatureAttribute;\n-import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n-import java.lang.classfile.attribute.SourceFileAttribute;\n-import java.lang.classfile.attribute.SourceIDAttribute;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.attribute.SyntheticAttribute;\n-import java.lang.classfile.constantpool.Utf8Entry;\n-import jdk.internal.classfile.impl.AbstractAttributeMapper;\n-import jdk.internal.classfile.impl.BoundAttribute;\n-import jdk.internal.classfile.impl.CodeImpl;\n-import jdk.internal.classfile.impl.AbstractPoolEntry;\n-import jdk.internal.classfile.impl.StackMapDecoder;\n+import java.lang.classfile.AttributeMapper.AttributeStability;\n+import java.lang.classfile.attribute.*;\n+import jdk.internal.classfile.impl.AbstractAttributeMapper.*;\n@@ -92,0 +34,55 @@\n+ * <p>\n+ * Unless otherwise specified, mappers returned by each method\n+ * do not permit multiple attribute instances in a given location.\n+ * <p>\n+ * The most stable {@link AttributeStability#STATELESS STATELESS} mappers are:\n+ * <ul>\n+ * <li>{@link #deprecated()}\n+ * <li>{@link #moduleResolution()}\n+ * <li>{@link #sourceDebugExtension()}\n+ * <li>{@link #synthetic()}\n+ * <\/ul>\n+ *\n+ * The mappers with {@link AttributeStability#CP_REFS CP_REFS} stability are:\n+ * <ul>\n+ * <li>{@link #annotationDefault()}\n+ * <li>{@link #bootstrapMethods()}\n+ * <li>{@link #code()}\n+ * <li>{@link #compilationId()}\n+ * <li>{@link #constantValue()}\n+ * <li>{@link #enclosingMethod()}\n+ * <li>{@link #exceptions()}\n+ * <li>{@link #innerClasses()}\n+ * <li>{@link #loadableDescriptors()}\n+ * <li>{@link #methodParameters()}\n+ * <li>{@link #module()}\n+ * <li>{@link #moduleHashes()}\n+ * <li>{@link #moduleMainClass()}\n+ * <li>{@link #modulePackages()}\n+ * <li>{@link #moduleTarget()}\n+ * <li>{@link #nestHost()}\n+ * <li>{@link #nestMembers()}\n+ * <li>{@link #permittedSubclasses()}\n+ * <li>{@link #record()}\n+ * <li>{@link #runtimeInvisibleAnnotations()}\n+ * <li>{@link #runtimeInvisibleParameterAnnotations()}\n+ * <li>{@link #runtimeVisibleAnnotations()}\n+ * <li>{@link #runtimeVisibleParameterAnnotations()}\n+ * <li>{@link #signature()}\n+ * <li>{@link #sourceFile()}\n+ * <li>{@link #sourceId()}\n+ * <\/ul>\n+ *\n+ * The mappers with {@link AttributeStability#LABELS LABELS} stability are:\n+ * <ul>\n+ * <li>{@link #characterRangeTable()}\n+ * <li>{@link #lineNumberTable()}\n+ * <li>{@link #localVariableTable()}\n+ * <li>{@link #localVariableTypeTable()}\n+ * <\/ul>\n+ *\n+ * The {@link AttributeStability#UNSTABLE UNSTABLE} mappers are:\n+ * <ul>\n+ * <li>{@link #runtimeInvisibleTypeAnnotations()}\n+ * <li>{@link #runtimeVisibleTypeAnnotations()}\n+ * <\/ul>\n@@ -98,1 +95,1 @@\n-public class Attributes {\n+public final class Attributes {\n@@ -214,791 +211,284 @@\n-    \/** Attribute mapper for the {@code AnnotationDefault} attribute *\/\n-    public static final AttributeMapper<AnnotationDefaultAttribute>\n-            ANNOTATION_DEFAULT = new AbstractAttributeMapper<>(NAME_ANNOTATION_DEFAULT) {\n-                @Override\n-                public AnnotationDefaultAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundAnnotationDefaultAttr(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, AnnotationDefaultAttribute attr) {\n-                    attr.defaultValue().writeTo(buf);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code BootstrapMethods} attribute *\/\n-    public static final AttributeMapper<BootstrapMethodsAttribute>\n-            BOOTSTRAP_METHODS = new AbstractAttributeMapper<>(NAME_BOOTSTRAP_METHODS) {\n-                @Override\n-                public BootstrapMethodsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundBootstrapMethodsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, BootstrapMethodsAttribute attr) {\n-                    buf.writeList(attr.bootstrapMethods());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code CharacterRangeTable} attribute *\/\n-    public static final AttributeMapper<CharacterRangeTableAttribute>\n-            CHARACTER_RANGE_TABLE = new AbstractAttributeMapper<>(NAME_CHARACTER_RANGE_TABLE, true) {\n-                @Override\n-                public CharacterRangeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundCharacterRangeTableAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n-                    List<CharacterRangeInfo> ranges = attr.characterRangeTable();\n-                    buf.writeU2(ranges.size());\n-                    for (CharacterRangeInfo info : ranges) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.endPc());\n-                        buf.writeInt(info.characterRangeStart());\n-                        buf.writeInt(info.characterRangeEnd());\n-                        buf.writeU2(info.flags());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Code} attribute *\/\n-    public static final AttributeMapper<CodeAttribute>\n-            CODE = new AbstractAttributeMapper<>(NAME_CODE) {\n-                @Override\n-                public CodeAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new CodeImpl(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CodeAttribute attr) {\n-                    throw new UnsupportedOperationException(\"Code attribute does not support direct write\");\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-\n-    \/** Attribute mapper for the {@code CompilationID} attribute *\/\n-    public static final AttributeMapper<CompilationIDAttribute>\n-            COMPILATION_ID = new AbstractAttributeMapper<>(NAME_COMPILATION_ID, true) {\n-                @Override\n-                public CompilationIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundCompilationIDAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CompilationIDAttribute attr) {\n-                    buf.writeIndex(attr.compilationId());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ConstantValue} attribute *\/\n-    public static final AttributeMapper<ConstantValueAttribute>\n-            CONSTANT_VALUE = new AbstractAttributeMapper<>(NAME_CONSTANT_VALUE) {\n-                @Override\n-                public ConstantValueAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundConstantValueAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ConstantValueAttribute attr) {\n-                    buf.writeIndex(attr.constant());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Deprecated} attribute *\/\n-    public static final AttributeMapper<DeprecatedAttribute>\n-            DEPRECATED = new AbstractAttributeMapper<>(NAME_DEPRECATED, true) {\n-                @Override\n-                public DeprecatedAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundDeprecatedAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, DeprecatedAttribute attr) {\n-                    \/\/ empty\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code EnclosingMethod} attribute *\/\n-    public static final AttributeMapper<EnclosingMethodAttribute>\n-            ENCLOSING_METHOD = new AbstractAttributeMapper<>(NAME_ENCLOSING_METHOD) {\n-                @Override\n-                public EnclosingMethodAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundEnclosingMethodAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n-                    buf.writeIndex(attr.enclosingClass());\n-                    buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Exceptions} attribute *\/\n-    public static final AttributeMapper<ExceptionsAttribute>\n-            EXCEPTIONS = new AbstractAttributeMapper<>(NAME_EXCEPTIONS) {\n-                @Override\n-                public ExceptionsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundExceptionsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ExceptionsAttribute attr) {\n-                    buf.writeListIndices(attr.exceptions());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code InnerClasses} attribute *\/\n-    public static final AttributeMapper<InnerClassesAttribute>\n-            INNER_CLASSES = new AbstractAttributeMapper<>(NAME_INNER_CLASSES) {\n-                @Override\n-                public InnerClassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundInnerClassesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n-                    List<InnerClassInfo> classes = attr.classes();\n-                    buf.writeU2(classes.size());\n-                    for (InnerClassInfo ic : classes) {\n-                        buf.writeIndex(ic.innerClass());\n-                        buf.writeIndexOrZero(ic.outerClass().orElse(null));\n-                        buf.writeIndexOrZero(ic.innerName().orElse(null));\n-                        buf.writeU2(ic.flagsMask());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LineNumberTable} attribute *\/\n-    public static final AttributeMapper<LineNumberTableAttribute>\n-            LINE_NUMBER_TABLE = new AbstractAttributeMapper<>(NAME_LINE_NUMBER_TABLE, true) {\n-                @Override\n-                public LineNumberTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLineNumberTableAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n-                    List<LineNumberInfo> lines = attr.lineNumbers();\n-                    buf.writeU2(lines.size());\n-                    for (LineNumberInfo line : lines) {\n-                        buf.writeU2(line.startPc());\n-                        buf.writeU2(line.lineNumber());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LocalVariableTable} attribute *\/\n-    public static final AttributeMapper<LocalVariableTableAttribute>\n-            LOCAL_VARIABLE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TABLE, true) {\n-                @Override\n-                public LocalVariableTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLocalVariableTableAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n-                    List<LocalVariableInfo> infos = attr.localVariables();\n-                    buf.writeU2(infos.size());\n-                    for (LocalVariableInfo info : infos) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.length());\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.type());\n-                        buf.writeU2(info.slot());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LocalVariableTypeTable} attribute *\/\n-    public static final AttributeMapper<LocalVariableTypeTableAttribute>\n-            LOCAL_VARIABLE_TYPE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TYPE_TABLE, true) {\n-                @Override\n-                public LocalVariableTypeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLocalVariableTypeTableAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n-                    List<LocalVariableTypeInfo> infos = attr.localVariableTypes();\n-                    buf.writeU2(infos.size());\n-                    for (LocalVariableTypeInfo info : infos) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.length());\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.signature());\n-                        buf.writeU2(info.slot());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code MethodParameters} attribute *\/\n-    public static final AttributeMapper<MethodParametersAttribute>\n-            METHOD_PARAMETERS = new AbstractAttributeMapper<>(NAME_METHOD_PARAMETERS) {\n-                @Override\n-                public MethodParametersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundMethodParametersAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n-                    List<MethodParameterInfo> parameters = attr.parameters();\n-                    buf.writeU1(parameters.size());\n-                    for (MethodParameterInfo info : parameters) {\n-                        buf.writeIndexOrZero(info.name().orElse(null));\n-                        buf.writeU2(info.flagsMask());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Module} attribute *\/\n-    public static final AttributeMapper<ModuleAttribute>\n-            MODULE = new AbstractAttributeMapper<>(NAME_MODULE) {\n-                @Override\n-                public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n-                    buf.writeIndex(attr.moduleName());\n-                    buf.writeU2(attr.moduleFlagsMask());\n-                    buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n-                    buf.writeU2(attr.requires().size());\n-                    for (ModuleRequireInfo require : attr.requires()) {\n-                        buf.writeIndex(require.requires());\n-                        buf.writeU2(require.requiresFlagsMask());\n-                        buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n-                    }\n-                    buf.writeU2(attr.exports().size());\n-                    for (ModuleExportInfo export : attr.exports()) {\n-                        buf.writeIndex(export.exportedPackage());\n-                        buf.writeU2(export.exportsFlagsMask());\n-                        buf.writeListIndices(export.exportsTo());\n-                    }\n-                    buf.writeU2(attr.opens().size());\n-                    for (ModuleOpenInfo open : attr.opens()) {\n-                        buf.writeIndex(open.openedPackage());\n-                        buf.writeU2(open.opensFlagsMask());\n-                        buf.writeListIndices(open.opensTo());\n-                    }\n-                    buf.writeListIndices(attr.uses());\n-                    buf.writeU2(attr.provides().size());\n-                    for (ModuleProvideInfo provide : attr.provides()) {\n-                        buf.writeIndex(provide.provides());\n-                        buf.writeListIndices(provide.providesWith());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleHashes} attribute *\/\n-    public static final AttributeMapper<ModuleHashesAttribute>\n-            MODULE_HASHES = new AbstractAttributeMapper<>(NAME_MODULE_HASHES) {\n-                @Override\n-                public ModuleHashesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleHashesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n-                    buf.writeIndex(attr.algorithm());\n-                    List<ModuleHashInfo> hashes = attr.hashes();\n-                    buf.writeU2(hashes.size());\n-                    for (ModuleHashInfo hash : hashes) {\n-                        buf.writeIndex(hash.moduleName());\n-                        buf.writeU2(hash.hash().length);\n-                        buf.writeBytes(hash.hash());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleMainClass} attribute *\/\n-    public static final AttributeMapper<ModuleMainClassAttribute>\n-            MODULE_MAIN_CLASS = new AbstractAttributeMapper<>(NAME_MODULE_MAIN_CLASS) {\n-                @Override\n-                public ModuleMainClassAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleMainClassAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleMainClassAttribute attr) {\n-                    buf.writeIndex(attr.mainClass());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModulePackages} attribute *\/\n-    public static final AttributeMapper<ModulePackagesAttribute>\n-            MODULE_PACKAGES = new AbstractAttributeMapper<>(NAME_MODULE_PACKAGES) {\n-                @Override\n-                public ModulePackagesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModulePackagesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModulePackagesAttribute attr) {\n-                    buf.writeListIndices(attr.packages());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleResolution} attribute *\/\n-    public static final AttributeMapper<ModuleResolutionAttribute>\n-            MODULE_RESOLUTION = new AbstractAttributeMapper<>(NAME_MODULE_RESOLUTION) {\n-                @Override\n-                public ModuleResolutionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleResolutionAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleResolutionAttribute attr) {\n-                    buf.writeU2(attr.resolutionFlags());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleTarget} attribute *\/\n-    public static final AttributeMapper<ModuleTargetAttribute>\n-            MODULE_TARGET = new AbstractAttributeMapper<>(NAME_MODULE_TARGET) {\n-                @Override\n-                public ModuleTargetAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleTargetAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleTargetAttribute attr) {\n-                    buf.writeIndex(attr.targetPlatform());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code NestHost} attribute *\/\n-    public static final AttributeMapper<NestHostAttribute>\n-            NEST_HOST = new AbstractAttributeMapper<>(NAME_NEST_HOST) {\n-                @Override\n-                public NestHostAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundNestHostAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, NestHostAttribute attr) {\n-                    buf.writeIndex(attr.nestHost());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code NestMembers} attribute *\/\n-    public static final AttributeMapper<NestMembersAttribute>\n-            NEST_MEMBERS = new AbstractAttributeMapper<>(NAME_NEST_MEMBERS) {\n-                @Override\n-                public NestMembersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundNestMembersAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, NestMembersAttribute attr) {\n-                    buf.writeListIndices(attr.nestMembers());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code PermittedSubclasses} attribute *\/\n-    public static final AttributeMapper<PermittedSubclassesAttribute>\n-            PERMITTED_SUBCLASSES = new AbstractAttributeMapper<>(NAME_PERMITTED_SUBCLASSES) {\n-                @Override\n-                public PermittedSubclassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundPermittedSubclassesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, PermittedSubclassesAttribute attr) {\n-                    buf.writeListIndices(attr.permittedSubclasses());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LoadableDescriptors} attribute *\/\n-    public static final AttributeMapper<LoadableDescriptorsAttribute>\n-            LOADABLE_DESCRIPTORS = new AbstractAttributeMapper<>(NAME_LOADABLE_DESCRIPTORS) {\n-                @Override\n-                public LoadableDescriptorsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLoadableDescriptorsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LoadableDescriptorsAttribute attr) {\n-                    buf.writeListIndices(attr.loadableDescriptors());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Record} attribute *\/\n-    public static final AttributeMapper<RecordAttribute>\n-            RECORD = new AbstractAttributeMapper<>(NAME_RECORD) {\n-                @Override\n-                public RecordAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRecordAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RecordAttribute attr) {\n-                    List<RecordComponentInfo> components = attr.components();\n-                    buf.writeU2(components.size());\n-                    for (RecordComponentInfo info : components) {\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.descriptor());\n-                        buf.writeList(info.attributes());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute(cf, pos);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleParameterAnnotationsAttribute attr) {\n-                    List<List<Annotation>> lists = attr.parameterAnnotations();\n-                    buf.writeU1(lists.size());\n-                    for (List<Annotation> list : lists)\n-                        buf.writeList(list);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleTypeAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.UNSTABLE;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleAnnotationsAttribute>\n-            RUNTIME_VISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n-                    return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute>\n-            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleParameterAnnotationsAttribute attr) {\n-                    List<List<Annotation>> lists = attr.parameterAnnotations();\n-                    buf.writeU1(lists.size());\n-                    for (List<Annotation> list : lists)\n-                        buf.writeList(list);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute>\n-            RUNTIME_VISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleTypeAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.UNSTABLE;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Signature} attribute *\/\n-    public static final AttributeMapper<SignatureAttribute>\n-            SIGNATURE = new AbstractAttributeMapper<>(NAME_SIGNATURE) {\n-                @Override\n-                public SignatureAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSignatureAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SignatureAttribute attr) {\n-                    buf.writeIndex(attr.signature());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceDebugExtension} attribute *\/\n-    public static final AttributeMapper<SourceDebugExtensionAttribute>\n-            SOURCE_DEBUG_EXTENSION = new AbstractAttributeMapper<>(NAME_SOURCE_DEBUG_EXTENSION) {\n-                @Override\n-                public SourceDebugExtensionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceDebugExtensionAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceDebugExtensionAttribute attr) {\n-                    buf.writeBytes(attr.contents());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceFile} attribute *\/\n-    public static final AttributeMapper<SourceFileAttribute>\n-            SOURCE_FILE = new AbstractAttributeMapper<>(NAME_SOURCE_FILE) {\n-                @Override\n-                public SourceFileAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceFileAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceFileAttribute attr) {\n-                    buf.writeIndex(attr.sourceFile());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceID} attribute *\/\n-    public static final AttributeMapper<SourceIDAttribute>\n-            SOURCE_ID = new AbstractAttributeMapper<>(NAME_SOURCE_ID) {\n-                @Override\n-                public SourceIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceIDAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceIDAttribute attr) {\n-                    buf.writeIndex(attr.sourceId());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code StackMapTable} attribute *\/\n-    public static final AttributeMapper<StackMapTableAttribute>\n-            STACK_MAP_TABLE = new AbstractAttributeMapper<>(NAME_STACK_MAP_TABLE) {\n-                @Override\n-                public StackMapTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundStackMapTableAttribute((CodeImpl)e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter b, StackMapTableAttribute attr) {\n-                    StackMapDecoder.writeFrames(b, attr.entries());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-\n-    \/** Attribute mapper for the {@code Synthetic} attribute *\/\n-    public static final AttributeMapper<SyntheticAttribute>\n-            SYNTHETIC = new AbstractAttributeMapper<>(NAME_SYNTHETIC, true) {\n-                @Override\n-                public SyntheticAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSyntheticAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SyntheticAttribute attr) {\n-                    \/\/ empty\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n+    \/**\n+     * {@return Attribute mapper for the {@code AnnotationDefault} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<AnnotationDefaultAttribute> annotationDefault() {\n+        return AnnotationDefaultMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code BootstrapMethods} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<BootstrapMethodsAttribute> bootstrapMethods() {\n+        return BootstrapMethodsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code CharacterRangeTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CharacterRangeTableAttribute> characterRangeTable() {\n+        return CharacterRangeTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Code} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CodeAttribute> code() {\n+        return CodeMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code CompilationID} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CompilationIDAttribute> compilationId() {\n+        return CompilationIDMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ConstantValue} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ConstantValueAttribute> constantValue() {\n+        return ConstantValueMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Deprecated} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<DeprecatedAttribute> deprecated() {\n+        return DeprecatedMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code EnclosingMethod} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<EnclosingMethodAttribute> enclosingMethod() {\n+        return EnclosingMethodMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Exceptions} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ExceptionsAttribute> exceptions() {\n+        return ExceptionsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code InnerClasses} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<InnerClassesAttribute> innerClasses() {\n+        return InnerClassesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LineNumberTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LineNumberTableAttribute> lineNumberTable() {\n+        return LineNumberTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LoadableDescriptors} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LoadableDescriptorsAttribute> loadableDescriptors() {\n+        return LoadableDescriptorsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LocalVariableTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LocalVariableTableAttribute> localVariableTable() {\n+        return LocalVariableTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LocalVariableTypeTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LocalVariableTypeTableAttribute> localVariableTypeTable() {\n+        return LocalVariableTypeTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code MethodParameters} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<MethodParametersAttribute> methodParameters() {\n+        return MethodParametersMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Module} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleAttribute> module() {\n+        return ModuleMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleHashes} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleHashesAttribute> moduleHashes() {\n+        return ModuleHashesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleMainClass} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleMainClassAttribute> moduleMainClass() {\n+        return ModuleMainClassMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModulePackages} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModulePackagesAttribute> modulePackages() {\n+        return ModulePackagesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleResolution} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleResolutionAttribute> moduleResolution() {\n+        return ModuleResolutionMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleTarget} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleTargetAttribute> moduleTarget() {\n+        return ModuleTargetMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code NestHost} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<NestHostAttribute> nestHost() {\n+        return NestHostMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code NestMembers} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<NestMembersAttribute> nestMembers() {\n+        return NestMembersMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code PermittedSubclasses} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<PermittedSubclassesAttribute> permittedSubclasses() {\n+        return PermittedSubclassesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Record} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RecordAttribute> record() {\n+        return RecordMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleAnnotationsAttribute> runtimeInvisibleAnnotations() {\n+        return RuntimeInvisibleAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute> runtimeInvisibleParameterAnnotations() {\n+        return RuntimeInvisibleParameterAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute> runtimeInvisibleTypeAnnotations() {\n+        return RuntimeInvisibleTypeAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleAnnotationsAttribute> runtimeVisibleAnnotations() {\n+        return RuntimeVisibleAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute> runtimeVisibleParameterAnnotations() {\n+        return RuntimeVisibleParameterAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute> runtimeVisibleTypeAnnotations() {\n+        return RuntimeVisibleTypeAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Signature} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SignatureAttribute> signature() {\n+        return SignatureMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceDebugExtension} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceDebugExtensionAttribute> sourceDebugExtension() {\n+        return SourceDebugExtensionMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceFile} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceFileAttribute> sourceFile() {\n+        return SourceFileMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceID} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceIDAttribute> sourceId() {\n+        return SourceIDMapper.INSTANCE;\n+    }\n@@ -1007,3 +497,2 @@\n-     * {@return the attribute mapper for a standard attribute}\n-     *\n-     * @param name the name of the attribute to find\n+     * {@return Attribute mapper for the {@code StackMapTable} attribute}\n+     * @since 23\n@@ -1011,2 +500,2 @@\n-    public static AttributeMapper<?> standardAttribute(Utf8Entry name) {\n-        return _ATTR_MAP.get(name);\n+    public static AttributeMapper<StackMapTableAttribute> stackMapTable() {\n+        return StackMapTableMapper.INSTANCE;\n@@ -1016,1 +505,3 @@\n-     * All standard attribute mappers.\n+     * {@return Attribute mapper for the {@code Synthetic} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n@@ -1018,47 +509,2 @@\n-    public static final Set<AttributeMapper<?>> PREDEFINED_ATTRIBUTES = Set.of(\n-            ANNOTATION_DEFAULT,\n-            BOOTSTRAP_METHODS,\n-            CHARACTER_RANGE_TABLE,\n-            CODE,\n-            COMPILATION_ID,\n-            CONSTANT_VALUE,\n-            DEPRECATED,\n-            ENCLOSING_METHOD,\n-            EXCEPTIONS,\n-            INNER_CLASSES,\n-            LINE_NUMBER_TABLE,\n-            LOADABLE_DESCRIPTORS,\n-            LOCAL_VARIABLE_TABLE,\n-            LOCAL_VARIABLE_TYPE_TABLE,\n-            METHOD_PARAMETERS,\n-            MODULE,\n-            MODULE_HASHES,\n-            MODULE_MAIN_CLASS,\n-            MODULE_PACKAGES,\n-            MODULE_RESOLUTION,\n-            MODULE_TARGET,\n-            NEST_HOST,\n-            NEST_MEMBERS,\n-            PERMITTED_SUBCLASSES,\n-            RECORD,\n-            RUNTIME_INVISIBLE_ANNOTATIONS,\n-            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS,\n-            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS,\n-            RUNTIME_VISIBLE_ANNOTATIONS,\n-            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS,\n-            RUNTIME_VISIBLE_TYPE_ANNOTATIONS,\n-            SIGNATURE,\n-            SOURCE_DEBUG_EXTENSION,\n-            SOURCE_FILE,\n-            SOURCE_ID,\n-            STACK_MAP_TABLE,\n-            SYNTHETIC);\n-\n-    private static final Map<Utf8Entry, AttributeMapper<?>> _ATTR_MAP;\n-    \/\/no lambdas here as this is on critical JDK boostrap path\n-    static {\n-        var map = new HashMap<Utf8Entry, AttributeMapper<?>>(64);\n-        for (var am : PREDEFINED_ATTRIBUTES) {\n-            map.put(AbstractPoolEntry.rawUtf8EntryFromStandardAttributeName(am.name()), am);\n-        }\n-        _ATTR_MAP = Collections.unmodifiableMap(map);\n+    public static AttributeMapper<SyntheticAttribute> synthetic() {\n+        return SyntheticMapper.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attributes.java","additions":352,"deletions":906,"binary":false,"changes":1258,"status":"modified"},{"patch":"@@ -628,6 +628,6 @@\n-     *     <li>The offset of the access operation (computed as above) must fall inside\n-     *     the spatial bounds of the accessed memory segment, or an\n-     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n-     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n-     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n-     *     accessed memory segment.<\/li>\n+     *     <li>The access operation must fall inside the spatial bounds of the accessed\n+     *     memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case\n+     *     when {@code B + A <= S}, where {@code B} is the base offset (defined above),\n+     *     {@code A} is the size of this layout and {@code S} is the size of the\n+     *     accessed memory segment. Note that the size of this layout might be <em>bigger<\/em>\n+     *     than the size of the accessed layout (e.g. when accessing a struct member).<\/li>\n@@ -756,6 +756,6 @@\n-     *     <li>The offset of the access operation (computed as above) must fall inside\n-     *     the spatial bounds of the accessed memory segment, or an\n-     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n-     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n-     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n-     *     accessed memory segment.<\/li>\n+     *     <li>The access operation must fall inside the spatial bounds of the accessed\n+     *     memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case\n+     *     when {@code B + A <= S}, where {@code B} is the base offset (defined above),\n+     *     {@code A} is the size of this layout and {@code S} is the size of the\n+     *     accessed memory segment. Note that the size of this layout might be <em>bigger<\/em>\n+     *     than the size of the accessed layout (e.g. when accessing a struct member).<\/li>\n@@ -825,6 +825,6 @@\n-     *     <li>The start offset of the slicing operation (computed as above) must fall\n-     *     inside the spatial bounds of the accessed memory segment, or an\n-     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n-     *     {@code O + A <= S}, where {@code O} is the start offset of\n-     *     the slicing operation (computed as above), {@code A} is the size of the\n-     *     selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     *     <li>The slicing operation must fall inside the spatial bounds of the accessed\n+     *     memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case\n+     *     when {@code B + A <= S}, where {@code B} is the base offset (defined above),\n+     *     {@code A} is the size of this layout and {@code S} is the size of the\n+     *     accessed memory segment. Note that the size of this layout might be <em>bigger<\/em>\n+     *     than the size of the accessed layout (e.g. when accessing a struct member).<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2614,1 +2614,1 @@\n-     *     <li><a href=\"#wrapping-addresses\">Zero-length memory segments.<\/a><\/li>\n+     *     <li>{@link MemorySegment##wrapping-addresses Zero-length memory segments}.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.foreign.Utils;\n-\n@@ -45,3 +43,0 @@\n-    \/** access size (in bytes, computed from var handle carrier type) **\/\n-    final long length;\n-\n@@ -51,1 +46,1 @@\n-    VarHandleSegmentViewBase(VarForm form, boolean be, long length, long alignmentMask, boolean exact) {\n+    VarHandleSegmentViewBase(VarForm form, boolean be, long alignmentMask, boolean exact) {\n@@ -54,1 +49,0 @@\n-        this.length = length;\n@@ -58,4 +52,0 @@\n-    static IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + Utils.toHexString(address));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -323,0 +323,3 @@\n+     * Note: the returned var handle does not perform any size or alignment check. It is up to clients\n+     * to adapt the returned var handle and insert the appropriate checks.\n+     *\n@@ -333,1 +336,0 @@\n-        long size = Utils.byteWidthOfPrimitive(carrier);\n@@ -338,1 +340,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsBytes(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n@@ -340,1 +342,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsChars(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsChars(be, alignmentMask, exact));\n@@ -342,1 +344,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsShorts(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsShorts(be, alignmentMask, exact));\n@@ -344,1 +346,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsInts(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsInts(be, alignmentMask, exact));\n@@ -346,1 +348,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsFloats(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsFloats(be, alignmentMask, exact));\n@@ -348,1 +350,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsLongs(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsLongs(be, alignmentMask, exact));\n@@ -350,1 +352,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsDoubles(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsDoubles(be, alignmentMask, exact));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-    VarHandleSegmentAs$Type$s(boolean be, long length, long alignmentMask, boolean exact) {\n-        super(FORM, be, length, alignmentMask, exact);\n+    VarHandleSegmentAs$Type$s(boolean be, long alignmentMask, boolean exact) {\n+        super(FORM, be, alignmentMask, exact);\n@@ -63,1 +63,1 @@\n-                new VarHandleSegmentAs$Type$s(be, length, alignmentMask, true);\n+                new VarHandleSegmentAs$Type$s(be, alignmentMask, true);\n@@ -70,1 +70,1 @@\n-                new VarHandleSegmentAs$Type$s(be, length, alignmentMask, false);\n+                new VarHandleSegmentAs$Type$s(be, alignmentMask, false);\n@@ -100,1 +100,1 @@\n-    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n+    static AbstractMemorySegmentImpl checkReadOnly(Object obb, boolean ro) {\n@@ -102,1 +102,1 @@\n-        oo.checkAccess(offset, length, ro);\n+        oo.checkReadOnly(ro);\n@@ -111,1 +111,1 @@\n-        return offsetPlain(bb, offset, alignmentMask);\n+        return offsetPlain(bb, offset);\n@@ -115,1 +115,1 @@\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset) {\n@@ -117,6 +117,1 @@\n-        long address = base + offset;\n-        long maxAlignMask = bb.maxAlignMask();\n-        if (((address | maxAlignMask) & alignmentMask) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-        }\n-        return address;\n+        return base + offset;\n@@ -128,1 +123,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -132,1 +127,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -139,1 +134,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask));\n+                offsetPlain(bb, base));\n@@ -143,1 +138,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -152,1 +147,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -156,1 +151,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -163,1 +158,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -168,1 +163,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -178,1 +173,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -188,1 +183,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -198,1 +193,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -208,1 +203,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -218,1 +213,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -228,1 +223,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -239,1 +234,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -249,1 +244,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -260,1 +255,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -271,1 +266,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -282,1 +277,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -292,1 +287,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -302,1 +297,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -312,1 +307,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -322,1 +317,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -333,1 +328,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -344,1 +339,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -357,1 +352,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -371,1 +366,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -385,1 +380,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -413,1 +408,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -427,1 +422,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -441,1 +436,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -467,1 +462,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -481,1 +476,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -495,1 +490,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -522,1 +517,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -536,1 +531,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -550,1 +545,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":47,"deletions":52,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -262,2 +262,6 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameter in addition to explicitly\n+     * declared ones.\n+     * Also note that compact constructors of a record class may have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters.\n@@ -268,0 +272,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -287,3 +292,7 @@\n-     * Also note that as a <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">modeling\n-     * artifact<\/a>, the number of returned parameters can differ\n+     * Compact constructors of a record class may also have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters,\n+     * but they are a special case and thus considered as if they had\n+     * been explicitly declared in the source.\n+     * Finally note that as a {@link java.lang.reflect##LanguageJvmModel\n+     * modeling artifact}, the number of returned parameters can differ\n@@ -291,3 +300,9 @@\n-     * generic information is present, only parameters explicitly\n-     * present in the source will be returned; if generic information\n-     * is not present, implicit and synthetic parameters may be\n+     * generic information is present, parameters explicitly\n+     * present in the source or parameters of compact constructors\n+     * of a record class will be returned.\n+     * Note that parameters of compact constructors of a record class are a special case,\n+     * as they are not explicitly present in the source, and its type will be returned\n+     * regardless of the parameters being\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} or not.\n+     * If generic information is not present, implicit and synthetic parameters may be\n@@ -298,1 +313,5 @@\n-     * the actual type arguments used in the source code.\n+     * the actual type arguments used in the source code. This assertion also\n+     * applies to the parameters of compact constructors of a record class,\n+     * independently of them being\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} or not.\n@@ -316,0 +335,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -342,9 +362,7 @@\n-                final Type[] out = new Type[nonGenericParamTypes.length];\n-                final Parameter[] params = getParameters();\n-                int fromidx = 0;\n-                for (int i = 0; i < out.length; i++) {\n-                    final Parameter param = params[i];\n-                    if (param.isSynthetic() || param.isImplicit()) {\n-                        \/\/ If we hit a synthetic or mandated parameter,\n-                        \/\/ use the non generic parameter info.\n-                        out[i] = nonGenericParamTypes[i];\n+                if (getDeclaringClass().isRecord() && this instanceof Constructor) {\n+                    \/* we could be seeing a compact constructor of a record class\n+                     * its parameters are mandated but we should be able to retrieve\n+                     * its generic information if present\n+                     *\/\n+                    if (genericParamTypes.length == nonGenericParamTypes.length) {\n+                        return genericParamTypes;\n@@ -352,3 +370,1 @@\n-                        \/\/ Otherwise, use the generic parameter info.\n-                        out[i] = genericParamTypes[fromidx];\n-                        fromidx++;\n+                        return nonGenericParamTypes.clone();\n@@ -356,0 +372,17 @@\n+                } else {\n+                    final Type[] out = new Type[nonGenericParamTypes.length];\n+                    final Parameter[] params = getParameters();\n+                    int fromidx = 0;\n+                    for (int i = 0; i < out.length; i++) {\n+                        final Parameter param = params[i];\n+                        if (param.isSynthetic() || param.isImplicit()) {\n+                            \/\/ If we hit a synthetic or mandated parameter,\n+                            \/\/ use the non generic parameter info.\n+                            out[i] = nonGenericParamTypes[i];\n+                        } else {\n+                            \/\/ Otherwise, use the generic parameter info.\n+                            out[i] = genericParamTypes[fromidx];\n+                            fromidx++;\n+                        }\n+                    }\n+                    return out;\n@@ -357,1 +390,0 @@\n-                return out;\n@@ -755,2 +787,6 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameter in addition to explicitly declared ones.\n+     * Also note that compact constructors of a record class may have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters.\n@@ -762,0 +798,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":61,"deletions":24,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassBuilder;\n@@ -51,0 +52,2 @@\n+\n+import jdk.internal.constant.ClassDescImpl;\n@@ -77,4 +80,6 @@\n-    private static final MethodHandle NULL_CHECK;\n-    private static final MethodHandle IS_ZERO;\n-    private static final MethodHandle CHECK_INDEX;\n-    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n+\n+    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class,\n+            BiPredicate.class,\n+            List.class);\n@@ -84,15 +89,23 @@\n-\n-    static {\n-        try {\n-            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n-                                           MethodType.methodType(boolean.class, Object.class));\n-            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n-                                           MethodType.methodType(boolean.class, int.class));\n-            CHECK_INDEX = LOOKUP.findStatic(Objects.class, \"checkIndex\",\n-                                           MethodType.methodType(int.class, int.class, int.class));\n-            MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n-                                                   MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n-                                                                         Class.class, EnumDesc[].class, EnumMap.class));\n-        }\n-        catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n+    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n+            MethodTypeDesc.ofDescriptor(\"(II)I\");\n+\n+    private static final ClassDesc CD_Objects = ClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+\n+    private static class StaticHolders {\n+        private static final MethodHandle NULL_CHECK;\n+        private static final MethodHandle IS_ZERO;\n+        private static final MethodHandle MAPPED_ENUM_LOOKUP;\n+\n+        static {\n+            try {\n+                NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n+                                               MethodType.methodType(boolean.class, Object.class));\n+                IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n+                                               MethodType.methodType(boolean.class, int.class));\n+                MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n+                                                       MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n+                                                                             Class.class, EnumDesc[].class, EnumMap.class));\n+            }\n+            catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n@@ -166,1 +179,0 @@\n-        requireNonNull(labels);\n@@ -168,1 +180,3 @@\n-        Stream.of(labels).forEach(l -> verifyLabel(l, selectorType));\n+        for (Object l : labels) { \/\/ implicit null-check\n+            verifyLabel(l, selectorType);\n+        }\n@@ -172,2 +186,0 @@\n-        target = withIndexCheck(target, labels.length);\n-\n@@ -285,1 +297,1 @@\n-                    MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                    MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.NULL_CHECK, 0, int.class),\n@@ -287,1 +299,1 @@\n-                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(IS_ZERO, 1, Object.class),\n+                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.IS_ZERO, 1, Object.class),\n@@ -289,1 +301,1 @@\n-                                                                            MethodHandles.insertArguments(MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n+                                                                            MethodHandles.insertArguments(StaticHolders.MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n@@ -296,1 +308,0 @@\n-        target = withIndexCheck(target, labels.length);\n@@ -342,6 +353,0 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n-\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n-    }\n-\n@@ -410,0 +415,5 @@\n+            \/\/ Objects.checkIndex(RESTART_IDX, labelConstants + 1)\n+            cb.iload(RESTART_IDX);\n+            cb.loadConstant(labelConstants.length + 1);\n+            cb.invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR);\n+            cb.pop();\n@@ -624,1 +634,1 @@\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())),\n+        byte[] classBytes = ClassFile.of().build(ClassDescImpl.ofValidatedBinaryName(typeSwitchClassName(caller.lookupClass())),\n@@ -639,6 +649,2 @@\n-                                                        MethodType.methodType(int.class,\n-                                                                              Object.class,\n-                                                                              int.class,\n-                                                                              BiPredicate.class,\n-                                                                              List.class));\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                        TYPES_SWITCH_TYPE);\n+            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":46,"deletions":40,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1834,0 +1834,4 @@\n+\n+        if (z == null || z.length < (xlen + ylen))\n+            z = new int[xlen + ylen];\n+\n@@ -1842,3 +1846,0 @@\n-        if (z == null || z.length < (xlen+ ylen))\n-             z = new int[xlen+ylen];\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,3 +73,3 @@\n- * <p> These forms support parts specified in decimal format only.\n- * For example, the following forms are supported by methods capable\n- * of parsing textual representations of IPv4 addresses:\n+ * <p> For example, the following (decimal) forms are supported by the methods\n+ * {@link Inet4Address#ofLiteral(String)} and {@link InetAddress#getByName(String)}\n+ * which are capable of parsing textual representations of IPv4 addresses:\n@@ -96,0 +96,8 @@\n+ * <p> The above forms adhere to \"strict\" decimal-only syntax.\n+ * Additionally, the {@link Inet4Address#ofPosixLiteral(String)}\n+ * method implements a POSIX {@code inet_addr} compatible \"loose\"\n+ * parsing algorithm, allowing octal and hexadecimal address segments.\n+ * Please refer to <a href=\"https:\/\/www.ietf.org\/rfc\/rfc6943.html#section-3.1.1\">\n+ * <i>RFC&nbsp;6943: Issues in Identifier Comparison for Security\n+ * Purposes<\/i><\/a>. Aside from {@code Inet4Address.ofPosixLiteral(String)}, all methods only\n+ * support strict decimal parsing.\n@@ -97,1 +105,1 @@\n- * value, the first form, i.e. a dotted-quad string, is used.\n+ * value, the first form, i.e. a dotted-quad string in strict decimal notation, is used.\n@@ -115,0 +123,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc6943.html#section-3.1.1\n+ *      RFC 6943: Issues in Identifier Comparison for Security Purposes\n@@ -183,0 +193,66 @@\n+    \/**\n+     * Creates an {@code Inet4Address} based on the provided {@linkplain\n+     * Inet4Address##format-posix textual representation of an IPv4 address in\n+     * POSIX {@code inet_addr} compatible form}.\n+     * <p> <a id=\"format-posix\"><\/a> The method {@code ofPosixLiteral}\n+     * implements <a href=\"https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/inet_addr.html\">\n+     * POSIX {@code inet_addr}<\/a> compatible parsing algorithm, allowing\n+     * octal and hexadecimal address segments. {@code \"0\"} is the prefix\n+     * for octal numbers, {@code \"0x\"} and {@code \"0X\"} are the prefixes\n+     * for hexadecimal numbers. Non-zero address segments that start from\n+     * non-zero digits are parsed as decimal numbers. The following\n+     * (non-decimal) forms are supported by this method:\n+     * {@snippet :\n+     *  \/\/ Dotted-quad 'x.x.x.x' form with four part address literal\n+     *  Inet4Address.ofPosixLiteral(\"0177.0.0.1\"); \/\/ ==> \/127.0.0.1\n+     *  Inet4Address.ofPosixLiteral(\"0x7F.0.0.1\"); \/\/ ==> \/127.0.0.1\n+     *\n+     *  \/\/ Dotted-triple 'x.x.x' form with three part address literal,\n+     *  \/\/ the last part is placed in the rightmost two bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofPosixLiteral(\"0177.0.0402\"); \/\/ ==> \/127.0.1.2\n+     *  Inet4Address.ofPosixLiteral(\"0x7F.0.0x102\"); \/\/ ==> \/127.0.1.2\n+     *\n+     *  \/\/ Dotted-double 'x.x' form with two part address literal,\n+     *  \/\/ the last part is placed in the rightmost three bytes\n+     *  \/\/ of the constructed address\n+     *  Inet4Address.ofPosixLiteral(\"0177.0201003\"); \/\/ ==> \/127.1.2.3\n+     *  Inet4Address.ofPosixLiteral(\"0x7F.0x10203\"); \/\/ ==> \/127.1.2.3\n+     *  Inet4Address.ofPosixLiteral(\"127.66051\"); \/\/ ==> \/127.1.2.3\n+     *\n+     *  \/\/ Dotless 'x' form with one value that is stored directly in\n+     *  \/\/ the constructed address bytes without any rearrangement\n+     *  Inet4Address.ofPosixLiteral(\"0100401404\"); \/\/ ==> \/1.2.3.4\n+     *  Inet4Address.ofPosixLiteral(\"0x1020304\"); \/\/ ==> \/1.2.3.4\n+     *  Inet4Address.ofPosixLiteral(\"16909060\"); \/\/ ==> \/1.2.3.4\n+     * }\n+     * <p> If the provided IPv4 address literal cannot represent a\n+     * valid IPv4 address in {@linkplain Inet4Address##format-posix\n+     * POSIX form} an {@code IllegalArgumentException} is thrown.\n+     * <p> This method doesn't block, i.e. no hostname lookup is performed.\n+     *\n+     * @apiNote\n+     * This method produces different results compared to {@linkplain Inet4Address#ofLiteral}\n+     * when {@code posixIPAddressLiteral} parameter contains address segments with\n+     * leading zeroes. An address segment with a leading zero is always parsed as an octal\n+     * number by this method, therefore {@code 0255} (octal) will be parsed as\n+     * {@code 173} (decimal). On the other hand, {@link Inet4Address#ofLiteral\n+     * Inet4Address.ofLiteral} ignores leading zeros, parses all numbers as decimal and produces\n+     * {@code 255}. Where this method would parse {@code 0256.0256.0256.0256} (octal) and\n+     * produce {@code 174.174.174.174} (decimal) in four dotted quad notation,\n+     * {@link Inet4Address#ofLiteral Inet4Address.ofLiteral} will throw\n+     * {@code IllegalArgumentException}.\n+     *\n+     * @param posixIPAddressLiteral a textual representation of an IPv4 address.\n+     * @return an {@link Inet4Address} object with no hostname set, and constructed\n+     *         from the provided IPv4 address literal.\n+     * @throws IllegalArgumentException if the {@code posixIPAddressLiteral} cannot be\n+     *         parsed as an IPv4 address literal.\n+     * @throws NullPointerException if the {@code posixIPAddressLiteral} is {@code null}.\n+     * @since 23\n+     *\/\n+    public static Inet4Address ofPosixLiteral(String posixIPAddressLiteral) {\n+        Objects.requireNonNull(posixIPAddressLiteral);\n+        return parseAddressStringPosix(posixIPAddressLiteral);\n+    }\n+\n@@ -215,0 +291,39 @@\n+    \/**\n+     * Parses the given string as an IPv4 address literal in\n+     * {@linkplain Inet4Address##format-posix POSIX form.}\n+     *\n+     * <p> If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * in POSIX form and {@code throwIAE} is {@code false}, {@code null} is returned.\n+     * If the given {@code addressLiteral} string cannot be parsed as an IPv4 address literal\n+     * and {@code throwIAE} is {@code true}, an {@code IllegalArgumentException}\n+     * is thrown.\n+     *\n+     * @apiNote\n+     * This method produces different results compared to {@linkplain Inet4Address#parseAddressString}\n+     * when {@code addressLiteral} parameter contains address segments with leading\n+     * zeroes. An address segment with a leading zero is always parsed as an octal\n+     * number by this method, therefore {@code 0255} (octal) will be parsed as\n+     * {@code 173} (decimal). On the other hand, {@link Inet4Address#parseAddressString}\n+     * ignores leading zeros, parses all numbers as decimal and produces {@code 255}.\n+     * Where this method would parse {@code 0256.0256.0256.0256} (octal) and produce\n+     * {@code 174.174.174.174} (decimal) in four dotted quad notation, {@linkplain\n+     * Inet4Address#parseAddressString} will either throw {@code IllegalArgumentException}\n+     * or return {@code null}, depending on the value of {@code throwIAE}.\n+     *\n+     * @param addressLiteral IPv4 address literal to parse\n+     * @param throwIAE whether to throw {@code IllegalArgumentException} if the\n+     *                 given {@code addressLiteral} string cannot be parsed as\n+     *                 an IPv4 address literal.\n+     * @return {@code Inet4Address} object constructed from the address literal;\n+     *         or {@code null} if the literal cannot be parsed as an IPv4 address\n+     * @throws IllegalArgumentException if the given {@code addressLiteral} string\n+     * cannot be parsed as an IPv4 address literal and {@code throwIAE} is {@code true}.\n+     *\/\n+    private static Inet4Address parseAddressStringPosix(String addressLiteral) {\n+        byte [] parsedBytes = IPAddressUtil.parseBsdLiteralV4(addressLiteral);\n+        if (parsedBytes == null) {\n+            throw IPAddressUtil.invalidIpAddressLiteral(addressLiteral);\n+        }\n+        return new Inet4Address(null, parsedBytes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet4Address.java","additions":120,"deletions":5,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -1725,0 +1725,1 @@\n+     * @see Inet4Address#ofPosixLiteral(String)\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4053,0 +4053,1 @@\n+            typeCheck(key, value);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.Annotation;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.AttributedElement;\n@@ -30,0 +32,3 @@\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.attribute.*;\n+import java.util.List;\n@@ -31,1 +36,3 @@\n-public abstract class AbstractAttributeMapper<T extends Attribute<T>>\n+import static java.lang.classfile.Attributes.*;\n+\n+public sealed abstract class AbstractAttributeMapper<T extends Attribute<T>>\n@@ -35,0 +42,1 @@\n+    private final AttributeMapper.AttributeStability stability;\n@@ -39,2 +47,2 @@\n-    public AbstractAttributeMapper(String name) {\n-        this(name, false);\n+    public AbstractAttributeMapper(String name, AttributeMapper.AttributeStability stability) {\n+        this(name, stability, false);\n@@ -44,0 +52,1 @@\n+                                   AttributeMapper.AttributeStability stability,\n@@ -46,0 +55,1 @@\n+        this.stability = stability;\n@@ -50,1 +60,1 @@\n-    public String name() {\n+    public final String name() {\n@@ -55,1 +65,1 @@\n-    public void writeAttribute(BufWriter buf, T attr) {\n+    public final void writeAttribute(BufWriter buf, T attr) {\n@@ -64,0 +74,5 @@\n+    @Override\n+    public AttributeMapper.AttributeStability stability() {\n+        return stability;\n+    }\n+\n@@ -74,0 +89,753 @@\n+\n+    public static final class AnnotationDefaultMapper extends AbstractAttributeMapper<AnnotationDefaultAttribute> {\n+        public static final AnnotationDefaultMapper INSTANCE = new AnnotationDefaultMapper();\n+\n+        private AnnotationDefaultMapper() {\n+            super(NAME_ANNOTATION_DEFAULT, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public AnnotationDefaultAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundAnnotationDefaultAttr(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, AnnotationDefaultAttribute attr) {\n+            attr.defaultValue().writeTo(buf);\n+        }\n+    }\n+\n+    public static final class BootstrapMethodsMapper extends AbstractAttributeMapper<BootstrapMethodsAttribute> {\n+        public static final BootstrapMethodsMapper INSTANCE = new BootstrapMethodsMapper();\n+\n+        private BootstrapMethodsMapper() {\n+            super(NAME_BOOTSTRAP_METHODS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public BootstrapMethodsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundBootstrapMethodsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, BootstrapMethodsAttribute attr) {\n+            buf.writeList(attr.bootstrapMethods());\n+        }\n+    }\n+\n+    public static final class CharacterRangeTableMapper extends AbstractAttributeMapper<CharacterRangeTableAttribute> {\n+        public static final CharacterRangeTableMapper INSTANCE = new CharacterRangeTableMapper();\n+\n+        private CharacterRangeTableMapper() {\n+            super(NAME_CHARACTER_RANGE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public CharacterRangeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundCharacterRangeTableAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n+            List<CharacterRangeInfo> ranges = attr.characterRangeTable();\n+            buf.writeU2(ranges.size());\n+            for (CharacterRangeInfo info : ranges) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.endPc());\n+                buf.writeInt(info.characterRangeStart());\n+                buf.writeInt(info.characterRangeEnd());\n+                buf.writeU2(info.flags());\n+            }\n+        }\n+    }\n+\n+    public static final class CodeMapper extends AbstractAttributeMapper<CodeAttribute> {\n+        public static final CodeMapper INSTANCE = new CodeMapper();\n+\n+        private CodeMapper() {\n+            super(NAME_CODE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public CodeAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new CodeImpl(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CodeAttribute attr) {\n+            throw new UnsupportedOperationException(\"Code attribute does not support direct write\");\n+        }\n+    }\n+\n+    public static final class CompilationIDMapper extends AbstractAttributeMapper<CompilationIDAttribute> {\n+        public static final CompilationIDMapper INSTANCE = new CompilationIDMapper();\n+\n+        private CompilationIDMapper() {\n+            super(NAME_COMPILATION_ID, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public CompilationIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundCompilationIDAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CompilationIDAttribute attr) {\n+            buf.writeIndex(attr.compilationId());\n+        }\n+    }\n+\n+    public static final class ConstantValueMapper extends AbstractAttributeMapper<ConstantValueAttribute> {\n+        public static final ConstantValueMapper INSTANCE = new ConstantValueMapper();\n+\n+        private ConstantValueMapper() {\n+            super(NAME_CONSTANT_VALUE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ConstantValueAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundConstantValueAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ConstantValueAttribute attr) {\n+            buf.writeIndex(attr.constant());\n+        }\n+    }\n+\n+    public static final class DeprecatedMapper extends AbstractAttributeMapper<DeprecatedAttribute> {\n+        public static final DeprecatedMapper INSTANCE = new DeprecatedMapper();\n+\n+        private DeprecatedMapper() {\n+            super(NAME_DEPRECATED, AttributeStability.STATELESS, true);\n+        }\n+\n+        @Override\n+        public DeprecatedAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundDeprecatedAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, DeprecatedAttribute attr) {\n+            \/\/ empty\n+        }\n+    }\n+\n+    public static final class EnclosingMethodMapper extends AbstractAttributeMapper<EnclosingMethodAttribute> {\n+        public static final EnclosingMethodMapper INSTANCE = new EnclosingMethodMapper();\n+\n+        private EnclosingMethodMapper() {\n+            super(NAME_ENCLOSING_METHOD, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public EnclosingMethodAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundEnclosingMethodAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n+            buf.writeIndex(attr.enclosingClass());\n+            buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n+        }\n+    }\n+\n+    public static final class ExceptionsMapper extends AbstractAttributeMapper<ExceptionsAttribute> {\n+        public static final ExceptionsMapper INSTANCE = new ExceptionsMapper();\n+\n+        private ExceptionsMapper() {\n+            super(NAME_EXCEPTIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ExceptionsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundExceptionsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ExceptionsAttribute attr) {\n+            buf.writeListIndices(attr.exceptions());\n+        }\n+    }\n+\n+    public static final class InnerClassesMapper extends AbstractAttributeMapper<InnerClassesAttribute> {\n+        public static final InnerClassesMapper INSTANCE = new InnerClassesMapper();\n+\n+        private InnerClassesMapper() {\n+            super(NAME_INNER_CLASSES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public InnerClassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundInnerClassesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n+            List<InnerClassInfo> classes = attr.classes();\n+            buf.writeU2(classes.size());\n+            for (InnerClassInfo ic : classes) {\n+                buf.writeIndex(ic.innerClass());\n+                buf.writeIndexOrZero(ic.outerClass().orElse(null));\n+                buf.writeIndexOrZero(ic.innerName().orElse(null));\n+                buf.writeU2(ic.flagsMask());\n+            }\n+        }\n+    }\n+\n+    public static final class LineNumberTableMapper extends AbstractAttributeMapper<LineNumberTableAttribute> {\n+        public static final LineNumberTableMapper INSTANCE = new LineNumberTableMapper();\n+\n+        private LineNumberTableMapper() {\n+            super(NAME_LINE_NUMBER_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LineNumberTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLineNumberTableAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n+            List<LineNumberInfo> lines = attr.lineNumbers();\n+            buf.writeU2(lines.size());\n+            for (LineNumberInfo line : lines) {\n+                buf.writeU2(line.startPc());\n+                buf.writeU2(line.lineNumber());\n+            }\n+        }\n+    }\n+\n+    public static final class LoadableDescriptorsMapper extends AbstractAttributeMapper<LoadableDescriptorsAttribute> {\n+        public static final LoadableDescriptorsMapper INSTANCE = new LoadableDescriptorsMapper();\n+\n+        private LoadableDescriptorsMapper() {\n+            super(NAME_LOADABLE_DESCRIPTORS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public LoadableDescriptorsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLoadableDescriptorsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LoadableDescriptorsAttribute attr) {\n+            buf.writeListIndices(attr.loadableDescriptors());\n+        }\n+    }\n+\n+    public static final class LocalVariableTableMapper extends AbstractAttributeMapper<LocalVariableTableAttribute> {\n+        public static final LocalVariableTableMapper INSTANCE = new LocalVariableTableMapper();\n+\n+        private LocalVariableTableMapper() {\n+            super(NAME_LOCAL_VARIABLE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LocalVariableTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLocalVariableTableAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n+            List<LocalVariableInfo> infos = attr.localVariables();\n+            buf.writeU2(infos.size());\n+            for (LocalVariableInfo info : infos) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.length());\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.type());\n+                buf.writeU2(info.slot());\n+            }\n+        }\n+    }\n+\n+    public static final class LocalVariableTypeTableMapper extends AbstractAttributeMapper<LocalVariableTypeTableAttribute> {\n+        public static final LocalVariableTypeTableMapper INSTANCE = new LocalVariableTypeTableMapper();\n+\n+        private LocalVariableTypeTableMapper() {\n+            super(NAME_LOCAL_VARIABLE_TYPE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LocalVariableTypeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLocalVariableTypeTableAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n+            List<LocalVariableTypeInfo> infos = attr.localVariableTypes();\n+            buf.writeU2(infos.size());\n+            for (LocalVariableTypeInfo info : infos) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.length());\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.signature());\n+                buf.writeU2(info.slot());\n+            }\n+        }\n+    }\n+\n+    public static final class MethodParametersMapper extends AbstractAttributeMapper<MethodParametersAttribute> {\n+        public static final MethodParametersMapper INSTANCE = new MethodParametersMapper();\n+\n+        private MethodParametersMapper() {\n+            super(NAME_METHOD_PARAMETERS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public MethodParametersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundMethodParametersAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n+            List<MethodParameterInfo> parameters = attr.parameters();\n+            buf.writeU1(parameters.size());\n+            for (MethodParameterInfo info : parameters) {\n+                buf.writeIndexOrZero(info.name().orElse(null));\n+                buf.writeU2(info.flagsMask());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleMapper extends AbstractAttributeMapper<ModuleAttribute> {\n+        public static final ModuleMapper INSTANCE = new ModuleMapper();\n+\n+        private ModuleMapper() {\n+            super(NAME_MODULE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n+            buf.writeIndex(attr.moduleName());\n+            buf.writeU2(attr.moduleFlagsMask());\n+            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+            buf.writeU2(attr.requires().size());\n+            for (ModuleRequireInfo require : attr.requires()) {\n+                buf.writeIndex(require.requires());\n+                buf.writeU2(require.requiresFlagsMask());\n+                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+            }\n+            buf.writeU2(attr.exports().size());\n+            for (ModuleExportInfo export : attr.exports()) {\n+                buf.writeIndex(export.exportedPackage());\n+                buf.writeU2(export.exportsFlagsMask());\n+                buf.writeListIndices(export.exportsTo());\n+            }\n+            buf.writeU2(attr.opens().size());\n+            for (ModuleOpenInfo open : attr.opens()) {\n+                buf.writeIndex(open.openedPackage());\n+                buf.writeU2(open.opensFlagsMask());\n+                buf.writeListIndices(open.opensTo());\n+            }\n+            buf.writeListIndices(attr.uses());\n+            buf.writeU2(attr.provides().size());\n+            for (ModuleProvideInfo provide : attr.provides()) {\n+                buf.writeIndex(provide.provides());\n+                buf.writeListIndices(provide.providesWith());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleHashesMapper extends AbstractAttributeMapper<ModuleHashesAttribute> {\n+        public static final ModuleHashesMapper INSTANCE = new ModuleHashesMapper();\n+\n+        private ModuleHashesMapper() {\n+            super(NAME_MODULE_HASHES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleHashesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleHashesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n+            buf.writeIndex(attr.algorithm());\n+            List<ModuleHashInfo> hashes = attr.hashes();\n+            buf.writeU2(hashes.size());\n+            for (ModuleHashInfo hash : hashes) {\n+                buf.writeIndex(hash.moduleName());\n+                buf.writeU2(hash.hash().length);\n+                buf.writeBytes(hash.hash());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleMainClassMapper extends AbstractAttributeMapper<ModuleMainClassAttribute> {\n+        public static final ModuleMainClassMapper INSTANCE = new ModuleMainClassMapper();\n+\n+        private ModuleMainClassMapper() {\n+            super(NAME_MODULE_MAIN_CLASS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleMainClassAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleMainClassAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleMainClassAttribute attr) {\n+            buf.writeIndex(attr.mainClass());\n+        }\n+    }\n+\n+    public static final class ModulePackagesMapper extends AbstractAttributeMapper<ModulePackagesAttribute> {\n+        public static final ModulePackagesMapper INSTANCE = new ModulePackagesMapper();\n+\n+        private ModulePackagesMapper() {\n+            super(NAME_MODULE_PACKAGES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModulePackagesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModulePackagesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModulePackagesAttribute attr) {\n+            buf.writeListIndices(attr.packages());\n+        }\n+    }\n+\n+    public static final class ModuleResolutionMapper extends AbstractAttributeMapper<ModuleResolutionAttribute> {\n+        public static final ModuleResolutionMapper INSTANCE = new ModuleResolutionMapper();\n+\n+        private ModuleResolutionMapper() {\n+            super(NAME_MODULE_RESOLUTION, AttributeStability.STATELESS);\n+        }\n+\n+        @Override\n+        public ModuleResolutionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleResolutionAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleResolutionAttribute attr) {\n+            buf.writeU2(attr.resolutionFlags());\n+        }\n+    }\n+\n+    public static final class ModuleTargetMapper extends AbstractAttributeMapper<ModuleTargetAttribute> {\n+        public static final ModuleTargetMapper INSTANCE = new ModuleTargetMapper();\n+\n+        private ModuleTargetMapper() {\n+            super(NAME_MODULE_TARGET, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleTargetAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleTargetAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleTargetAttribute attr) {\n+            buf.writeIndex(attr.targetPlatform());\n+        }\n+    }\n+\n+    public static final class NestHostMapper extends AbstractAttributeMapper<NestHostAttribute> {\n+        public static final NestHostMapper INSTANCE = new NestHostMapper();\n+\n+        private NestHostMapper() {\n+            super(NAME_NEST_HOST, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public NestHostAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundNestHostAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, NestHostAttribute attr) {\n+            buf.writeIndex(attr.nestHost());\n+        }\n+    }\n+\n+    public static final class NestMembersMapper extends AbstractAttributeMapper<NestMembersAttribute> {\n+        public static final NestMembersMapper INSTANCE = new NestMembersMapper();\n+\n+        private NestMembersMapper() {\n+            super(NAME_NEST_MEMBERS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public NestMembersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundNestMembersAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, NestMembersAttribute attr) {\n+            buf.writeListIndices(attr.nestMembers());\n+        }\n+    }\n+\n+    public static final class PermittedSubclassesMapper extends AbstractAttributeMapper<PermittedSubclassesAttribute> {\n+        public static final PermittedSubclassesMapper INSTANCE = new PermittedSubclassesMapper();\n+\n+        private PermittedSubclassesMapper() {\n+            super(NAME_PERMITTED_SUBCLASSES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public PermittedSubclassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundPermittedSubclassesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, PermittedSubclassesAttribute attr) {\n+            buf.writeListIndices(attr.permittedSubclasses());\n+        }\n+    }\n+\n+    public static final class RecordMapper extends AbstractAttributeMapper<RecordAttribute> {\n+        public static final RecordMapper INSTANCE = new RecordMapper();\n+\n+        private RecordMapper() {\n+            super(NAME_RECORD, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RecordAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRecordAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RecordAttribute attr) {\n+            List<RecordComponentInfo> components = attr.components();\n+            buf.writeU2(components.size());\n+            for (RecordComponentInfo info : components) {\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.descriptor());\n+                buf.writeList(info.attributes());\n+            }\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleAnnotationsAttribute> {\n+        public static final RuntimeInvisibleAnnotationsMapper INSTANCE = new RuntimeInvisibleAnnotationsMapper();\n+\n+        private RuntimeInvisibleAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute(cf, pos);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleParameterAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute> {\n+        public static final RuntimeInvisibleParameterAnnotationsMapper INSTANCE = new RuntimeInvisibleParameterAnnotationsMapper();\n+\n+        private RuntimeInvisibleParameterAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleParameterAnnotationsAttribute attr) {\n+            List<List<Annotation>> lists = attr.parameterAnnotations();\n+            buf.writeU1(lists.size());\n+            for (List<Annotation> list : lists)\n+                buf.writeList(list);\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleTypeAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute> {\n+        public static final RuntimeInvisibleTypeAnnotationsMapper INSTANCE = new RuntimeInvisibleTypeAnnotationsMapper();\n+\n+        private RuntimeInvisibleTypeAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, AttributeStability.UNSTABLE);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleTypeAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleAnnotationsAttribute> {\n+        public static final RuntimeVisibleAnnotationsMapper INSTANCE = new RuntimeVisibleAnnotationsMapper();\n+\n+        private RuntimeVisibleAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleParameterAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleParameterAnnotationsAttribute> {\n+        public static final RuntimeVisibleParameterAnnotationsMapper INSTANCE = new RuntimeVisibleParameterAnnotationsMapper();\n+\n+        private RuntimeVisibleParameterAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleParameterAnnotationsAttribute attr) {\n+            List<List<Annotation>> lists = attr.parameterAnnotations();\n+            buf.writeU1(lists.size());\n+            for (List<Annotation> list : lists)\n+                buf.writeList(list);\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleTypeAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleTypeAnnotationsAttribute> {\n+        public static final RuntimeVisibleTypeAnnotationsMapper INSTANCE = new RuntimeVisibleTypeAnnotationsMapper();\n+\n+        private RuntimeVisibleTypeAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS, AttributeStability.UNSTABLE);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleTypeAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class SignatureMapper extends AbstractAttributeMapper<SignatureAttribute> {\n+        public static final SignatureMapper INSTANCE = new SignatureMapper();\n+\n+        private SignatureMapper() {\n+            super(NAME_SIGNATURE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SignatureAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSignatureAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SignatureAttribute attr) {\n+            buf.writeIndex(attr.signature());\n+        }\n+    }\n+\n+    public static final class SourceDebugExtensionMapper extends AbstractAttributeMapper<SourceDebugExtensionAttribute> {\n+        public static final SourceDebugExtensionMapper INSTANCE = new SourceDebugExtensionMapper();\n+\n+        private SourceDebugExtensionMapper() {\n+            super(NAME_SOURCE_DEBUG_EXTENSION, AttributeStability.STATELESS);\n+        }\n+\n+        @Override\n+        public SourceDebugExtensionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceDebugExtensionAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceDebugExtensionAttribute attr) {\n+            buf.writeBytes(attr.contents());\n+        }\n+    }\n+\n+    public static final class SourceFileMapper extends AbstractAttributeMapper<SourceFileAttribute> {\n+        public static final SourceFileMapper INSTANCE = new SourceFileMapper();\n+\n+        private SourceFileMapper() {\n+            super(NAME_SOURCE_FILE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SourceFileAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceFileAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceFileAttribute attr) {\n+            buf.writeIndex(attr.sourceFile());\n+        }\n+    }\n+\n+    public static final class SourceIDMapper extends AbstractAttributeMapper<SourceIDAttribute> {\n+        public static final SourceIDMapper INSTANCE = new SourceIDMapper();\n+\n+        private SourceIDMapper() {\n+            super(NAME_SOURCE_ID, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SourceIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceIDAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceIDAttribute attr) {\n+            buf.writeIndex(attr.sourceId());\n+        }\n+    }\n+\n+    public static final class StackMapTableMapper extends AbstractAttributeMapper<StackMapTableAttribute> {\n+        public static final StackMapTableMapper INSTANCE = new StackMapTableMapper();\n+\n+        private StackMapTableMapper() {\n+            super(NAME_STACK_MAP_TABLE, AttributeStability.LABELS);\n+        }\n+\n+        @Override\n+        public StackMapTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundStackMapTableAttribute((CodeImpl)e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter b, StackMapTableAttribute attr) {\n+            StackMapDecoder.writeFrames(b, attr.entries());\n+        }\n+    }\n+\n+    public static final class SyntheticMapper extends AbstractAttributeMapper<SyntheticAttribute> {\n+        public static final SyntheticMapper INSTANCE = new SyntheticMapper();\n+\n+        private SyntheticMapper() {\n+            super(NAME_SYNTHETIC, AttributeStability.STATELESS, true);\n+        }\n+\n+        @Override\n+        public SyntheticAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSyntheticAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SyntheticAttribute attr) {\n+            \/\/ empty\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":773,"deletions":5,"binary":false,"changes":778,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static java.lang.classfile.Attributes.*;\n+\n@@ -143,1 +145,1 @@\n-            var mapper = Attributes.standardAttribute(name);\n+            var mapper = standardAttribute(name);\n@@ -892,1 +894,1 @@\n-            super(cf, Attributes.RUNTIME_INVISIBLE_ANNOTATIONS, payloadStart);\n+            super(cf, Attributes.runtimeInvisibleAnnotations(), payloadStart);\n@@ -910,1 +912,1 @@\n-            super(cf, Attributes.RUNTIME_VISIBLE_ANNOTATIONS, payloadStart);\n+            super(cf, Attributes.runtimeVisibleAnnotations(), payloadStart);\n@@ -1003,0 +1005,86 @@\n+\n+    \/**\n+     * {@return the attribute mapper for a standard attribute}\n+     *\n+     * @param name the name of the attribute to find\n+     *\/\n+    public static AttributeMapper<?> standardAttribute(Utf8Entry name) {\n+        \/\/ critical bootstrap path, so no lambdas nor method handles here\n+        return switch (name.hashCode()) {\n+            case 0x78147009 ->\n+                name.equalsString(NAME_ANNOTATION_DEFAULT) ? annotationDefault() : null;\n+            case 0x665e3a3a ->\n+                name.equalsString(NAME_BOOTSTRAP_METHODS) ? bootstrapMethods() : null;\n+            case 0xcb7e162 ->\n+                name.equalsString(NAME_CHARACTER_RANGE_TABLE) ? characterRangeTable() : null;\n+            case 0x21e41e7e ->\n+                name.equalsString(NAME_CODE) ? code() : null;\n+            case 0x5a306b41 ->\n+                name.equalsString(NAME_COMPILATION_ID) ? compilationId() : null;\n+            case 0x3e191c7c ->\n+                name.equalsString(NAME_CONSTANT_VALUE) ? constantValue() : null;\n+            case 0x5e88ed0c ->\n+                name.equalsString(NAME_DEPRECATED) ? deprecated() : null;\n+            case 0x7284695e ->\n+                name.equalsString(NAME_ENCLOSING_METHOD) ? enclosingMethod() : null;\n+            case 0x21df25db ->\n+                name.equalsString(NAME_EXCEPTIONS) ? exceptions() : null;\n+            case 0x11392da9 ->\n+                name.equalsString(NAME_INNER_CLASSES) ? innerClasses() : null;\n+            case 0x167536fc ->\n+                name.equalsString(NAME_LINE_NUMBER_TABLE) ? lineNumberTable() : null;\n+            case 0x4d56b212 ->\n+                name.equalsString(NAME_LOADABLE_DESCRIPTORS) ? loadableDescriptors() : null;\n+            case 0x46939abc ->\n+                name.equalsString(NAME_LOCAL_VARIABLE_TABLE) ? localVariableTable() : null;\n+            case 0x63ee67f4 ->\n+                name.equalsString(NAME_LOCAL_VARIABLE_TYPE_TABLE) ? localVariableTypeTable() : null;\n+            case 0x2b597e15 ->\n+                name.equalsString(NAME_METHOD_PARAMETERS) ? methodParameters() : null;\n+            case 0x19f20ade ->\n+                name.equalsString(NAME_MODULE) ? module() : null;\n+            case 0x47f6395e ->\n+                name.equalsString(NAME_MODULE_HASHES) ? moduleHashes() : null;\n+            case 0x54db809 ->\n+                name.equalsString(NAME_MODULE_MAIN_CLASS) ? moduleMainClass() : null;\n+            case 0x1abd1c2c ->\n+                name.equalsString(NAME_MODULE_PACKAGES) ? modulePackages() : null;\n+            case 0x6ba46dd ->\n+                name.equalsString(NAME_MODULE_RESOLUTION) ? moduleResolution() : null;\n+            case 0x46f7d91d ->\n+                name.equalsString(NAME_MODULE_TARGET) ? moduleTarget() : null;\n+            case 0x5137f53 ->\n+                name.equalsString(NAME_NEST_HOST) ? nestHost() : null;\n+            case 0x4a8fa3b6 ->\n+                name.equalsString(NAME_NEST_MEMBERS) ? nestMembers() : null;\n+            case 0x55c73cb6 ->\n+                name.equalsString(NAME_PERMITTED_SUBCLASSES) ? permittedSubclasses() : null;\n+            case 0x3fe76d4e ->\n+                name.equalsString(NAME_RECORD) ? record() : null;\n+            case 0x180d6925 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_ANNOTATIONS) ? runtimeInvisibleAnnotations() : null;\n+            case 0x7be22752 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS) ? runtimeInvisibleParameterAnnotations() : null;\n+            case 0x5299824 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) ? runtimeInvisibleTypeAnnotations() : null;\n+            case 0x3534786e ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_ANNOTATIONS) ? runtimeVisibleAnnotations() : null;\n+            case 0xb4b4ac6 ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS) ? runtimeVisibleParameterAnnotations() : null;\n+            case 0x6926482 ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS) ? runtimeVisibleTypeAnnotations() : null;\n+            case 0x16a42b7c ->\n+                name.equalsString(NAME_SIGNATURE) ? signature() : null;\n+            case 0x400ab245 ->\n+                name.equalsString(NAME_SOURCE_DEBUG_EXTENSION) ? sourceDebugExtension() : null;\n+            case 0x2af490d4 ->\n+                name.equalsString(NAME_SOURCE_FILE) ? sourceFile() : null;\n+            case 0x303e0c58 ->\n+                name.equalsString(NAME_SOURCE_ID) ? sourceId() : null;\n+            case 0x19c7d0cd ->\n+                name.equalsString(NAME_STACK_MAP_TABLE) ? stackMapTable() : null;\n+            case 0x3dc79b7a ->\n+                name.equalsString(NAME_SYNTHETIC) ? synthetic() : null;\n+            default -> null;\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":91,"deletions":3,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Collection;\n@@ -30,1 +29,0 @@\n-import java.util.Set;\n@@ -32,3 +30,0 @@\n-import java.util.stream.Collectors;\n-\n-import java.lang.classfile.ClassBuilder;\n@@ -39,1 +34,0 @@\n-import java.lang.classfile.AttributeMapper;\n@@ -44,1 +38,0 @@\n-import java.lang.classfile.ClassTransform;\n@@ -47,0 +40,1 @@\n+import java.lang.classfile.CustomAttribute;\n@@ -48,1 +42,0 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -53,0 +46,11 @@\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleHashesAttribute;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.attribute.ModuleTargetAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n@@ -205,1 +209,1 @@\n-        if (findAttribute(Attributes.MODULE).isEmpty())\n+        if (findAttribute(Attributes.module()).isEmpty())\n@@ -208,21 +212,14 @@\n-        Set<AttributeMapper<?>> found = attributes().stream()\n-                                                    .map(Attribute::attributeMapper)\n-                                                    .collect(Collectors.toSet());\n-\n-        found.removeAll(allowedModuleAttributes);\n-        found.retainAll(Attributes.PREDEFINED_ATTRIBUTES);\n-        return found.isEmpty();\n-    }\n-\n-    private static final Set<AttributeMapper<?>> allowedModuleAttributes\n-            = Set.of(Attributes.MODULE,\n-                     Attributes.MODULE_HASHES,\n-                     Attributes.MODULE_MAIN_CLASS,\n-                     Attributes.MODULE_PACKAGES,\n-                     Attributes.MODULE_RESOLUTION,\n-                     Attributes.MODULE_TARGET,\n-                     Attributes.INNER_CLASSES,\n-                     Attributes.SOURCE_FILE,\n-                     Attributes.SOURCE_DEBUG_EXTENSION,\n-                     Attributes.RUNTIME_VISIBLE_ANNOTATIONS,\n-                     Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+        return attributes().stream().allMatch(a ->\n+                a instanceof ModuleAttribute\n+             || a instanceof ModulePackagesAttribute\n+             || a instanceof ModuleHashesAttribute\n+             || a instanceof ModuleMainClassAttribute\n+             || a instanceof ModuleResolutionAttribute\n+             || a instanceof ModuleTargetAttribute\n+             || a instanceof InnerClassesAttribute\n+             || a instanceof SourceFileAttribute\n+             || a instanceof SourceDebugExtensionAttribute\n+             || a instanceof RuntimeVisibleAnnotationsAttribute\n+             || a instanceof RuntimeInvisibleAnnotationsAttribute\n+             || a instanceof CustomAttribute);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-                    = containedClass.findAttribute(Attributes.BOOTSTRAP_METHODS)\n+                    = containedClass.findAttribute(Attributes.bootstrapMethods())\n@@ -327,1 +327,1 @@\n-                = containedClass.findAttribute(Attributes.BOOTSTRAP_METHODS);\n+                = containedClass.findAttribute(Attributes.bootstrapMethods());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-                            idi.bootstrapMethod(), idi.name().stringValue(),\n+                            mapDirectMethodHandle(idi.bootstrapMethod()), idi.name().stringValue(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-            if (a.attributeMapper() == Attributes.LINE_NUMBER_TABLE) {\n+            if (a.attributeMapper() == Attributes.lineNumberTable()) {\n@@ -255,1 +255,1 @@\n-        Optional<StackMapTableAttribute> a = findAttribute(Attributes.STACK_MAP_TABLE);\n+        Optional<StackMapTableAttribute> a = findAttribute(Attributes.stackMapTable());\n@@ -328,2 +328,2 @@\n-        findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).ifPresent(RuntimeVisibleTypeAnnotationsAttribute::annotations);\n-        findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS).ifPresent(RuntimeInvisibleTypeAnnotationsAttribute::annotations);\n+        findAttribute(Attributes.runtimeVisibleTypeAnnotations()).ifPresent(RuntimeVisibleTypeAnnotationsAttribute::annotations);\n+        findAttribute(Attributes.runtimeInvisibleTypeAnnotations()).ifPresent(RuntimeInvisibleTypeAnnotationsAttribute::annotations);\n@@ -348,1 +348,1 @@\n-            if (a.attributeMapper() == Attributes.CHARACTER_RANGE_TABLE) {\n+            if (a.attributeMapper() == Attributes.characterRangeTable()) {\n@@ -360,1 +360,1 @@\n-            else if (a.attributeMapper() == Attributes.LOCAL_VARIABLE_TABLE) {\n+            else if (a.attributeMapper() == Attributes.localVariableTable()) {\n@@ -372,1 +372,1 @@\n-            else if (a.attributeMapper() == Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+            else if (a.attributeMapper() == Attributes.localVariableTypeTable()) {\n@@ -384,1 +384,1 @@\n-            else if (a.attributeMapper() == Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS) {\n+            else if (a.attributeMapper() == Attributes.runtimeVisibleTypeAnnotations()) {\n@@ -387,1 +387,1 @@\n-            else if (a.attributeMapper() == Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) {\n+            else if (a.attributeMapper() == Attributes.runtimeInvisibleTypeAnnotations()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.CHARACTER_RANGE_TABLE) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.characterRangeTable()) {\n@@ -265,1 +265,1 @@\n-                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TABLE) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTable()) {\n@@ -288,1 +288,1 @@\n-                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTypeTable()) {\n@@ -315,1 +315,1 @@\n-        content = new UnboundAttribute.AdHocAttribute<>(Attributes.CODE) {\n+        content = new UnboundAttribute.AdHocAttribute<>(Attributes.code()) {\n@@ -371,1 +371,1 @@\n-                            attributes.withAttribute(original.findAttribute(Attributes.STACK_MAP_TABLE).orElse(null));\n+                            attributes.withAttribute(original.findAttribute(Attributes.stackMapTable()).orElse(null));\n@@ -404,1 +404,1 @@\n-            super(Attributes.LINE_NUMBER_TABLE);\n+            super(Attributes.lineNumberTable());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        return findAttribute(Attributes.CODE).map(a -> (CodeModel) a);\n+        return findAttribute(Attributes.code()).map(a -> (CodeModel) a);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-                    = new UnboundAttribute.AdHocAttribute<>(Attributes.BOOTSTRAP_METHODS) {\n+                    = new UnboundAttribute.AdHocAttribute<>(Attributes.bootstrapMethods()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-        return frames.isEmpty() ? null : new UnboundAttribute.AdHocAttribute<>(Attributes.STACK_MAP_TABLE) {\n+        return frames.isEmpty() ? null : new UnboundAttribute.AdHocAttribute<>(Attributes.stackMapTable()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-            super(Attributes.CONSTANT_VALUE);\n+            super(Attributes.constantValue());\n@@ -168,1 +168,1 @@\n-            super(Attributes.DEPRECATED);\n+            super(Attributes.deprecated());\n@@ -176,1 +176,1 @@\n-            super(Attributes.SYNTHETIC);\n+            super(Attributes.synthetic());\n@@ -186,1 +186,1 @@\n-            super(Attributes.SIGNATURE);\n+            super(Attributes.signature());\n@@ -202,1 +202,1 @@\n-            super(Attributes.EXCEPTIONS);\n+            super(Attributes.exceptions());\n@@ -218,1 +218,1 @@\n-            super(Attributes.ANNOTATION_DEFAULT);\n+            super(Attributes.annotationDefault());\n@@ -233,1 +233,1 @@\n-            super(Attributes.SOURCE_FILE);\n+            super(Attributes.sourceFile());\n@@ -249,1 +249,1 @@\n-            super(Attributes.STACK_MAP_TABLE);\n+            super(Attributes.stackMapTable());\n@@ -265,1 +265,1 @@\n-            super(Attributes.INNER_CLASSES);\n+            super(Attributes.innerClasses());\n@@ -281,1 +281,1 @@\n-            super(Attributes.RECORD);\n+            super(Attributes.record());\n@@ -298,1 +298,1 @@\n-            super(Attributes.ENCLOSING_METHOD);\n+            super(Attributes.enclosingMethod());\n@@ -320,1 +320,1 @@\n-            super(Attributes.METHOD_PARAMETERS);\n+            super(Attributes.methodParameters());\n@@ -336,1 +336,1 @@\n-            super(Attributes.MODULE_TARGET);\n+            super(Attributes.moduleTarget());\n@@ -352,1 +352,1 @@\n-            super(Attributes.MODULE_MAIN_CLASS);\n+            super(Attributes.moduleMainClass());\n@@ -369,1 +369,1 @@\n-            super(Attributes.MODULE_HASHES);\n+            super(Attributes.moduleHashes());\n@@ -391,1 +391,1 @@\n-            super(Attributes.MODULE_PACKAGES);\n+            super(Attributes.modulePackages());\n@@ -407,1 +407,1 @@\n-            super(Attributes.MODULE_RESOLUTION);\n+            super(Attributes.moduleResolution());\n@@ -423,1 +423,1 @@\n-            super(Attributes.PERMITTED_SUBCLASSES);\n+            super(Attributes.permittedSubclasses());\n@@ -439,1 +439,1 @@\n-            super(Attributes.LOADABLE_DESCRIPTORS);\n+            super(Attributes.loadableDescriptors());\n@@ -455,1 +455,1 @@\n-            super(Attributes.NEST_MEMBERS);\n+            super(Attributes.nestMembers());\n@@ -471,1 +471,1 @@\n-            super(Attributes.NEST_HOST);\n+            super(Attributes.nestHost());\n@@ -487,1 +487,1 @@\n-            super(Attributes.COMPILATION_ID);\n+            super(Attributes.compilationId());\n@@ -503,1 +503,1 @@\n-            super(Attributes.SOURCE_ID);\n+            super(Attributes.sourceId());\n@@ -519,1 +519,1 @@\n-            super(Attributes.SOURCE_DEBUG_EXTENSION);\n+            super(Attributes.sourceDebugExtension());\n@@ -535,1 +535,1 @@\n-            super(Attributes.CHARACTER_RANGE_TABLE);\n+            super(Attributes.characterRangeTable());\n@@ -551,1 +551,1 @@\n-            super(Attributes.LINE_NUMBER_TABLE);\n+            super(Attributes.lineNumberTable());\n@@ -567,1 +567,1 @@\n-            super(Attributes.LOCAL_VARIABLE_TABLE);\n+            super(Attributes.localVariableTable());\n@@ -583,1 +583,1 @@\n-            super(Attributes.LOCAL_VARIABLE_TYPE_TABLE);\n+            super(Attributes.localVariableTypeTable());\n@@ -599,1 +599,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleAnnotations());\n@@ -615,1 +615,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleAnnotations());\n@@ -631,1 +631,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleParameterAnnotations());\n@@ -647,1 +647,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleParameterAnnotations());\n@@ -663,1 +663,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleTypeAnnotations());\n@@ -679,1 +679,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleTypeAnnotations());\n@@ -865,1 +865,1 @@\n-            super(Attributes.MODULE);\n+            super(Attributes.module());\n@@ -941,1 +941,1 @@\n-            super(Attributes.BOOTSTRAP_METHODS);\n+            super(Attributes.bootstrapMethods());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                            ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.code()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-            var attro = c.findAttribute(Attributes.LOCAL_VARIABLE_TABLE);\n+            var attro = c.findAttribute(Attributes.localVariableTable());\n@@ -150,1 +150,1 @@\n-            var attro = c.findAttribute(Attributes.STACK_MAP_TABLE);\n+            var attro = c.findAttribute(Attributes.stackMapTable());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationWrapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,11 @@\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDesc ofValidatedBinaryName(String typeSwitchClassName) {\n+        return ofValidated(\"L\" + binaryToInternal(typeSwitchClassName) + \";\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassDescImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-    public void checkAccess(long offset, long length, boolean readOnly) {\n+    public void checkReadOnly(boolean readOnly) {\n@@ -364,0 +364,5 @@\n+    }\n+\n+    @ForceInline\n+    public void checkAccess(long offset, long length, boolean readOnly) {\n+        checkReadOnly(readOnly);\n@@ -826,0 +831,1 @@\n+        Objects.requireNonNull(value);\n@@ -951,0 +957,1 @@\n+        Objects.requireNonNull(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    private static final MethodHandle MH_CHECK_ALIGN;\n+    private static final MethodHandle MH_CHECK_ENCL_LAYOUT;\n@@ -80,1 +80,1 @@\n-            MH_CHECK_ALIGN = lookup.findStatic(LayoutPath.class, \"checkAlign\",\n+            MH_CHECK_ENCL_LAYOUT = lookup.findStatic(LayoutPath.class, \"checkEnclosingLayout\",\n@@ -208,1 +208,1 @@\n-        VarHandle handle = valueLayout.varHandle();\n+        VarHandle handle = Utils.makeSegmentViewVarHandle(valueLayout);\n@@ -214,1 +214,1 @@\n-        if (derefAdapters.length == 0 && enclosing != null) {\n+        if (derefAdapters.length == 0) {\n@@ -217,1 +217,1 @@\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n@@ -278,1 +278,1 @@\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n@@ -287,2 +287,3 @@\n-    private static void checkAlign(MemorySegment segment, long offset, MemoryLayout constraint) {\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, constraint)) {\n+    private static void checkEnclosingLayout(MemorySegment segment, long offset, MemoryLayout enclosing) {\n+        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), true);\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n@@ -291,1 +292,1 @@\n-                    , offset, constraint.byteAlignment(), constraint, segment));\n+                    , offset, enclosing.byteAlignment(), enclosing, segment));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -93,20 +91,0 @@\n-        final class VarHandleCache {\n-            private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n-\n-            static VarHandle put(ValueLayout layout, VarHandle handle) {\n-                VarHandle prev = HANDLE_MAP.putIfAbsent(layout, handle);\n-                return prev != null ? prev : handle;\n-            }\n-\n-            static VarHandle get(ValueLayout layout) {\n-                return HANDLE_MAP.get(layout);\n-            }\n-        }\n-        layout = layout.withoutName(); \/\/ name doesn't matter\n-        \/\/ keep the addressee layout as it's used below\n-\n-        VarHandle handle = VarHandleCache.get(layout);\n-        if (handle != null) {\n-            return handle;\n-        }\n-\n@@ -124,1 +102,1 @@\n-        handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n@@ -136,1 +114,1 @@\n-        return VarHandleCache.put(layout, handle);\n+        return handle;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -191,0 +191,4 @@\n+        return varHandleInternal(elements);\n+    }\n+\n+    public VarHandle varHandleInternal(PathElement... elements) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.Map;\n@@ -43,0 +44,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -160,0 +162,3 @@\n+            final class VarHandleCache {\n+                private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n+            }\n@@ -162,1 +167,1 @@\n-                handle = Utils.makeSegmentViewVarHandle(self());\n+                handle = VarHandleCache.HANDLE_MAP.computeIfAbsent(self().withoutName(), _ -> varHandleInternal());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+    JdkConsole println(Object obj);\n+    JdkConsole print(Object obj);\n+    String readln(String prompt);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsole.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,33 @@\n+    @Override\n+    public JdkConsole println(Object obj) {\n+        pw.println(obj);\n+        \/\/ automatic flushing covers println\n+        return this;\n+    }\n+\n+    @Override\n+    public JdkConsole print(Object obj) {\n+        pw.print(obj);\n+        pw.flush(); \/\/ automatic flushing does not cover print\n+        return this;\n+    }\n+\n+    @Override\n+    public String readln(String prompt) {\n+        String line = null;\n+        synchronized (writeLock) {\n+            synchronized(readLock) {\n+                pw.print(prompt);\n+                pw.flush(); \/\/ automatic flushing does not cover print\n+                try {\n+                    char[] ca = readline(false);\n+                    if (ca != null)\n+                        line = new String(ca);\n+                } catch (IOException x) {\n+                    throw new IOError(x);\n+                }\n+            }\n+        }\n+        return line;\n+    }\n+\n@@ -97,1 +130,3 @@\n-                    restoreEcho = echo(false);\n+                    synchronized(restoreEchoLock) {\n+                        restoreEcho = echo(false);\n+                    }\n@@ -110,2 +145,5 @@\n-                        if (restoreEcho)\n-                            restoreEcho = echo(true);\n+                        synchronized(restoreEchoLock) {\n+                            if (restoreEcho) {\n+                                restoreEcho = echo(true);\n+                            }\n+                        }\n@@ -124,1 +162,1 @@\n-                        } catch (IOException x) {\n+                        } catch (IOException _) {\n@@ -148,2 +186,4 @@\n-                                        if (restoreEcho) {\n-                                            echo(true);\n+                                        synchronized(restoreEchoLock) {\n+                                            if (restoreEcho) {\n+                                                echo(true);\n+                                            }\n@@ -151,1 +191,1 @@\n-                                    } catch (IOException x) { }\n+                                    } catch (IOException _) { }\n@@ -154,1 +194,1 @@\n-        } catch (IllegalStateException e) {\n+        } catch (IllegalStateException _) {\n@@ -179,0 +219,2 @@\n+    \/\/ Must not block while holding this. It is used in the shutdown hook.\n+    private final Object restoreEchoLock;\n@@ -349,0 +391,1 @@\n+        restoreEchoLock = new Object();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleImpl.java","additions":51,"deletions":8,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -75,3 +75,1 @@\n-        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\", status=\"Deprecated\")\n-        UNNAMED_CLASSES,\n-        @JEP(number=463, title=\"Implicitly Declared Classes and Instance Main Methods\", status=\"Preview\")\n+        @JEP(number=477, title=\"Implicitly Declared Classes and Instance Main Methods\", status=\"Third Preview\")\n@@ -81,1 +79,1 @@\n-        @JEP(number=462, title=\"Structured Concurrency\", status=\"Second Preview\")\n+        @JEP(number=480, title=\"Structured Concurrency\", status=\"Third Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -215,1 +215,5 @@\n-\\                      Finalization is enabled by default.\\n\\n\\\n+\\                      Finalization is enabled by default.\\n\\\n+\\    --sun-misc-unsafe-memory-access=<value>\\n\\\n+\\                      allow or deny usage of unsupported API sun.misc.Unsafe\\n\\\n+\\                      <value> is one of \"allow\", \"warn\", \"debug\", or \"deny\".\\n\\\n+\\                      The default value is \"allow\".\\n\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -669,0 +669,20 @@\n+        return parseBsdLiteralV4(input) != null;\n+    }\n+\n+    \/**\n+     * Parse String as IPv4 address literal by following\n+     * POSIX-style formatting rules.\n+     *\n+     * @param input a String representing an IPv4 address in POSIX format\n+     * @return a byte array representing the IPv4 numeric address\n+     * if input string is a parsable POSIX formatted IPv4 address literal,\n+     * {@code null} otherwise.\n+     *\/\n+    public static byte[] parseBsdLiteralV4(String input) {\n+\n+        byte[] res = new byte[]{0,0,0,0};\n+\n+        int len = input.length();\n+        if (len == 0) {\n+            return null;\n+        }\n@@ -672,1 +692,1 @@\n-            return false;\n+            return null;\n@@ -676,1 +696,1 @@\n-        char lastSymbol = input.charAt(input.length() - 1);\n+        char lastSymbol = input.charAt(len - 1);\n@@ -678,1 +698,1 @@\n-            return false;\n+            return null;\n@@ -684,0 +704,1 @@\n+        long fieldValue = -1L;\n@@ -685,1 +706,1 @@\n-            long fieldValue = -1L;\n+            fieldValue = -1L;\n@@ -690,0 +711,7 @@\n+                    if (fieldValue < 256) {\n+                        \/\/ Store the parsed field in the byte buffer.\n+                        \/\/ If the field value is greater than 255, it can only be the last field.\n+                        \/\/ If it is not the last one, parseV4FieldBsd enforces this limit\n+                        \/\/ and returns TERMINAL_PARSE_ERROR.\n+                        res[fieldNumber] = (byte) fieldValue;\n+                    }\n@@ -693,1 +721,1 @@\n-                    return false;\n+                    return null;\n@@ -699,1 +727,1 @@\n-                return false;\n+                return null;\n@@ -702,1 +730,14 @@\n-        return true;\n+        \/\/ The last field value must be non-negative\n+        if (fieldValue < 0) {\n+            return null;\n+        }\n+        \/\/ If the last fieldValue is greater than 255 (fieldNumber < 4),\n+        \/\/ it is written to the last (4 - (fieldNumber - 1)) octets\n+        \/\/ in the network order\n+        if (fieldNumber < 4) {\n+            for (int i = 3; i >= fieldNumber - 1; --i) {\n+                res[i] = (byte) (fieldValue & 255);\n+                fieldValue >>= 8;\n+            }\n+        }\n+        return res;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1518,0 +1518,20 @@\n+\n+#\n+# Policy for name comparison in keytab and ccache entry lookup\n+#\n+# When looking up a keytab or credentials cache (ccache) entry for a Kerberos\n+# principal, the principal name is compared with the name in the entry.\n+# The comparison is by default case-insensitive. However, many Kerberos\n+# implementations consider principal names to be case-sensitive. Consequently,\n+# if two principals have names that differ only in case, there is a risk that\n+# an incorrect keytab or ccache entry might be selected.\n+#\n+# If this security property is set to \"true\", the comparison of principal\n+# names at keytab and ccache entry lookup is case-sensitive.\n+#\n+# The default value is \"false\".\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+#jdk.security.krb5.name.case.sensitive=false\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1197,0 +1197,24 @@\n+.TP\n+\\f[V]--sun-misc-unsafe-memory-acces=\\f[R] \\f[I]value\\f[R]\n+Allow or deny usage of unsupported API \\f[V]sun.misc.Unsafe\\f[R].\n+\\f[I]value\\f[R] is one of:\n+.RS\n+.TP\n+\\f[V]allow\\f[R]\n+Allow use of the memory-access methods with no warnings at run time.\n+.TP\n+\\f[V]warn\\f[R]\n+Allow use of the memory-access methods, but issues a warning on the\n+first occasion that any memory-access method is used.\n+At most one warning is issued.\n+.TP\n+\\f[V]debug\\f[R]\n+Allow use of the memory-access methods, but issue a one-line warning and\n+a stack trace when any memory-access method is used.\n+.TP\n+\\f[V]deny\\f[R]\n+Disallow use of the memory-access methods by throwing an\n+\\f[V]UnsupportedOperationException\\f[R] on every usage.\n+.PP\n+The default value when the option is not specified is \\f[V]allow\\f[R].\n+.RE\n","filename":"src\/java.base\/share\/man\/java.1","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -562,2 +562,11 @@\n-    memcpy(buf+offset, c->pdir, sp.dirlen);\n-    offset += sp.dirlen;\n+    if (c->pdir != NULL) {\n+        if (sp.dirlen > 0) {\n+            memcpy(buf+offset, c->pdir, sp.dirlen);\n+            offset += sp.dirlen;\n+        }\n+    } else {\n+        if (sp.dirlen > 0) {\n+            free(buf);\n+            return -1;\n+        }\n+    }\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.lang.reflect.Constructor;\n@@ -42,0 +41,1 @@\n+import java.util.HashMap;\n@@ -43,0 +43,1 @@\n+import java.util.List;\n@@ -67,1 +68,0 @@\n-import javax.swing.tree.TreePath;\n@@ -762,15 +762,0 @@\n-    private static Accessible createAccessibleTreeNode(JTree t, TreePath p) {\n-        Accessible a = null;\n-\n-        try {\n-            Class<?> accessibleJTreeNodeClass = Class.forName(\"javax.swing.JTree$AccessibleJTree$AccessibleJTreeNode\");\n-            Constructor<?> constructor = accessibleJTreeNodeClass.getConstructor(t.getAccessibleContext().getClass(), JTree.class, TreePath.class, Accessible.class);\n-            constructor.setAccessible(true);\n-            a = ((Accessible) constructor.newInstance(t.getAccessibleContext(), t, p, null));\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-\n-        return a;\n-    }\n-\n@@ -784,46 +769,0 @@\n-\n-                Accessible at = null;\n-                if (a instanceof CAccessible) {\n-                    at = CAccessible.getSwingAccessible(a);\n-                } else {\n-                    at = a;\n-                }\n-\n-                if (at instanceof JTree) {\n-                    JTree tree = ((JTree) at);\n-\n-                    if (whichChildren == JAVA_AX_ALL_CHILDREN) {\n-                        int count = tree.getRowCount();\n-                        for (int i = 0; i < count; i++) {\n-                            TreePath path = tree.getPathForRow(i);\n-                            Accessible an = createAccessibleTreeNode(tree, path);\n-                            if (an != null) {\n-                                AccessibleContext ac = an.getAccessibleContext();\n-                                if (ac != null) {\n-                                    allChildren.add(an);\n-                                    allChildren.add(ac.getAccessibleRole());;\n-                                    allChildren.add(String.valueOf((tree.isRootVisible() ? path.getPathCount() : path.getPathCount() - 1)));\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    if (whichChildren == JAVA_AX_SELECTED_CHILDREN) {\n-                        int count = tree.getSelectionCount();\n-                        for (int i = 0; i < count; i++) {\n-                            TreePath path = tree.getSelectionPaths()[i];\n-                            Accessible an = createAccessibleTreeNode(tree, path);\n-                            if (an != null) {\n-                                AccessibleContext ac = an.getAccessibleContext();\n-                                if (ac != null) {\n-                                    allChildren.add(an);\n-                                    allChildren.add(ac.getAccessibleRole());\n-                                    allChildren.add(String.valueOf((tree.isRootVisible() ? path.getPathCount() : path.getPathCount() - 1)));\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    return allChildren.toArray();\n-                }\n-\n@@ -832,0 +771,1 @@\n+                HashMap<Accessible, List<Object>> childrenOfParent = new HashMap<>();\n@@ -838,2 +778,6 @@\n-\n-                    currentLevelChildren.addAll(Arrays.asList(getChildrenAndRolesImpl(p, c, JAVA_AX_ALL_CHILDREN, allowIgnored, ChildrenOperations.COMMON)));\n+                    if (!childrenOfParent.containsKey(p)) {\n+                        childrenOfParent.put(p, Arrays.asList(getChildrenAndRolesImpl(p,\n+                                c, JAVA_AX_ALL_CHILDREN, allowIgnored,\n+                                ChildrenOperations.COMMON)));\n+                    }\n+                    currentLevelChildren.addAll(childrenOfParent.get(p));\n@@ -882,1 +826,0 @@\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":10,"deletions":67,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+\/\/ Constant for keyman layouts\n+#define KEYMAN_LAYOUT \"keyman\"\n+\n@@ -262,1 +265,1 @@\n-    fKeyEventsNeeded = YES;\n+    fKeyEventsNeeded = ![(NSString *)kbdLayout containsString:@KEYMAN_LAYOUT];\n@@ -968,1 +971,1 @@\n-        ((codePoint == 0x5c) && ([(NSString *)kbdLayout containsString:@\"Kotoeri\"]))) {\n+        [(NSString *)kbdLayout containsString:@KEYMAN_LAYOUT]) {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.m","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, JetBrains s.r.o.. All rights reserved.\n@@ -32,1 +32,6 @@\n-\n+{\n+    NSMutableArray<id<NSAccessibilityRow>> *rowCache;\n+    BOOL rowCacheValid;\n+    NSMutableArray<id<NSAccessibilityRow>> *selectedRowCache;\n+    BOOL selectedRowCacheValid;\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/OutlineAccessibility.h","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, JetBrains s.r.o.. All rights reserved.\n@@ -58,0 +58,84 @@\n+- (nullable NSArray<id<NSAccessibilityRow>> *)accessibilityRows\n+{\n+    return [self accessibilityChildren];\n+}\n+\n+- (nullable NSArray<id<NSAccessibilityRow>> *)accessibilitySelectedRows\n+{\n+    return [self accessibilitySelectedChildren];\n+}\n+\n+- (nullable  NSArray<id<NSAccessibilityRow>> *)accessibilityChildren\n+{\n+    if (![self isCacheValid]) {\n+        NSArray *t = [super accessibilityChildren];\n+        if (t != nil) {\n+            rowCache = [[NSMutableArray arrayWithArray:t] retain];\n+        } else {\n+            rowCache = nil;\n+        }\n+        rowCacheValid = YES;\n+    }\n+    return rowCache;\n+}\n+\n+- (nullable NSArray<id<NSAccessibilityRow>> *)accessibilitySelectedChildren\n+{\n+    if (!selectedRowCacheValid) {\n+        NSArray *t = [super accessibilitySelectedChildren];\n+        if (t != nil) {\n+            selectedRowCache = [[NSMutableArray arrayWithArray:t] retain];\n+        } else {\n+            selectedRowCache = nil;\n+        }\n+        selectedRowCacheValid = YES;\n+    }\n+    return selectedRowCache;\n+}\n+\n+- (BOOL)isCacheValid\n+{\n+    if (rowCacheValid && [[self parent] respondsToSelector:NSSelectorFromString(@\"isCacheValid\")]) {\n+        return [[self parent] isCacheValid];\n+    }\n+    return rowCacheValid;\n+}\n+\n+- (void)invalidateCache\n+{\n+    rowCacheValid = NO;\n+}\n+\n+- (void)invalidateSelectionCache\n+{\n+    selectedRowCacheValid = NO;\n+}\n+\n+- (void)postSelectionChanged\n+{\n+    AWT_ASSERT_APPKIT_THREAD;\n+    [self invalidateSelectionCache];\n+    [super postSelectionChanged];\n+}\n+\n+- (void)postTreeNodeCollapsed\n+{\n+    AWT_ASSERT_APPKIT_THREAD;\n+    [self invalidateCache];\n+    [super postTreeNodeCollapsed];\n+}\n+\n+- (void)postTreeNodeExpanded\n+{\n+    AWT_ASSERT_APPKIT_THREAD;\n+    [self invalidateCache];\n+    [super postTreeNodeExpanded];\n+}\n+\n+- (void)postSelectedCellsChanged\n+{\n+    AWT_ASSERT_APPKIT_THREAD;\n+    [self invalidateSelectionCache];\n+    [super postSelectedCellsChanged];\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/OutlineAccessibility.m","additions":86,"deletions":2,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,5 @@\n-                toFind = mouseEvent.getLocationOnScreen();\n+                if (mouseEvent != null) {\n+                    toFind = mouseEvent.getLocationOnScreen();\n+                } else {\n+                    toFind = screenLocation;\n+                }\n@@ -273,2 +277,4 @@\n-                toFind = mouseEvent.getLocationOnScreen();\n-                gc = getDrawingGC(toFind);\n+                if (mouseEvent != null) {\n+                    toFind = mouseEvent.getLocationOnScreen();\n+                    gc = getDrawingGC(toFind);\n+                }\n@@ -304,2 +310,6 @@\n-                location = new Point(screenLocation.x + mouseEvent.getX(),\n-                        screenLocation.y + mouseEvent.getY() + 20);\n+                if (mouseEvent != null) {\n+                    location = new Point(screenLocation.x + mouseEvent.getX(),\n+                            screenLocation.y + mouseEvent.getY() + 20);\n+                } else {\n+                    location = screenLocation;\n+                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ToolTipManager.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -846,0 +846,12 @@\n+    static Object mergeTextDecoration(String value) {\n+        boolean underline = value.contains(\"underline\");\n+        boolean strikeThrough = value.contains(\"line-through\");\n+        if (!underline && !strikeThrough) {\n+            return null;\n+        }\n+        String newValue = underline && strikeThrough\n+                          ? \"underline,line-through\"\n+                          : (underline ? \"underline\" : \"line-through\");\n+        return new StringValue().parseCssValue(newValue);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2502,1 +2502,1 @@\n-            tagMap.put(HTML.Tag.SPAN, ca);\n+            tagMap.put(HTML.Tag.SPAN, new ConvertSpanAction());\n@@ -3426,0 +3426,2 @@\n+\n+                convertAttributes(t, attr);\n@@ -3431,0 +3433,30 @@\n+\n+            \/**\n+             * Converts HTML tags to CSS attributes.\n+             * @param t the current HTML tag\n+             * @param attr the attributes of the HTML tag\n+             *\/\n+            void convertAttributes(HTML.Tag t, MutableAttributeSet attr) {\n+            }\n+        }\n+\n+        final class ConvertSpanAction extends CharacterAction {\n+            @Override\n+            void convertAttributes(HTML.Tag t, MutableAttributeSet attr) {\n+                Object newDecoration = attr.getAttribute(CSS.Attribute.TEXT_DECORATION);\n+                Object previousDecoration =\n+                        charAttrStack.peek()\n+                                     .getAttribute(CSS.Attribute.TEXT_DECORATION);\n+\n+                if (newDecoration != null\n+                    && !\"none\".equals(newDecoration.toString())\n+                    && previousDecoration != null\n+                    && !\"none\".equals(previousDecoration.toString())) {\n+                    StyleSheet sheet = getStyleSheet();\n+                    sheet.addCSSAttribute(charAttr,\n+                                          CSS.Attribute.TEXT_DECORATION,\n+                                          CSS.mergeTextDecoration(newDecoration + \",\"\n+                                                                  + previousDecoration)\n+                                             .toString());\n+                }\n+            }\n@@ -3438,29 +3470,3 @@\n-        class ConvertAction extends TagAction {\n-\n-            public void start(HTML.Tag t, MutableAttributeSet attr) {\n-                pushCharacterStyle();\n-                if (!foundInsertTag) {\n-                    \/\/ Note that the third argument should really be based off\n-                    \/\/ inParagraph and impliedP. If we're wrong (that is\n-                    \/\/ insertTagDepthDelta shouldn't be changed), we'll end up\n-                    \/\/ removing an extra EndSpec, which won't matter anyway.\n-                    boolean insert = canInsertTag(t, attr, false);\n-                    if (foundInsertTag) {\n-                        if (!inParagraph) {\n-                            inParagraph = impliedP = true;\n-                        }\n-                    }\n-                    if (!insert) {\n-                        return;\n-                    }\n-                }\n-                if (attr.isDefined(IMPLIED)) {\n-                    attr.removeAttribute(IMPLIED);\n-                }\n-                if (styleAttributes != null) {\n-                    charAttr.addAttributes(styleAttributes);\n-                }\n-                \/\/ We also need to add attr, otherwise we lose custom\n-                \/\/ attributes, including class\/id for style lookups, and\n-                \/\/ further confuse style lookup (doesn't have tag).\n-                charAttr.addAttribute(t, attr.copyAttributes());\n+        final class ConvertAction extends CharacterAction {\n+            @Override\n+            void convertAttributes(HTML.Tag t, MutableAttributeSet attr) {\n@@ -3507,5 +3513,0 @@\n-\n-            public void end(HTML.Tag t) {\n-                popCharacterStyle();\n-            }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLDocument.java","additions":36,"deletions":35,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import javax.swing.text.*;\n@@ -29,1 +28,9 @@\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import javax.swing.text.AttributeSet;\n+import javax.swing.text.MutableAttributeSet;\n+import javax.swing.text.SimpleAttributeSet;\n@@ -199,6 +206,8 @@\n-        AttributeSet[] as = getAttributes();\n-        int n = as.length;\n-        for (int i = 0; i < n; i++) {\n-            Object o = as[i].getAttribute(key);\n-            if (o != null) {\n-                return o;\n+        final AttributeSet[] as = getAttributes();\n+        final int n = as.length;\n+        if (key != CSS.Attribute.TEXT_DECORATION) {\n+            for (int i = 0; i < n; i++) {\n+                Object o = as[i].getAttribute(key);\n+                if (o != null) {\n+                    return o;\n+                }\n@@ -206,0 +215,1 @@\n+            return null;\n@@ -207,1 +217,7 @@\n-        return null;\n+\n+        String values = Arrays.stream(as)\n+                              .map(a -> a.getAttribute(key))\n+                              .filter(Objects::nonNull)\n+                              .map(Object::toString)\n+                              .collect(Collectors.joining(\",\"));\n+        return CSS.mergeTextDecoration(values);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/MuxingAttributeSet.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,5 +27,29 @@\n-import sun.swing.SwingUtilities2;\n-import java.util.*;\n-import java.awt.*;\n-import java.io.*;\n-import java.net.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Shape;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.Serializable;\n+import java.io.StringReader;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.EmptyStackException;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Stack;\n+import java.util.StringTokenizer;\n+import java.util.Vector;\n+\n@@ -35,1 +59,2 @@\n-import javax.swing.border.*;\n+import javax.swing.border.BevelBorder;\n+import javax.swing.border.Border;\n@@ -37,1 +62,12 @@\n-import javax.swing.text.*;\n+import javax.swing.text.AttributeSet;\n+import javax.swing.text.Document;\n+import javax.swing.text.Element;\n+import javax.swing.text.MutableAttributeSet;\n+import javax.swing.text.SimpleAttributeSet;\n+import javax.swing.text.Style;\n+import javax.swing.text.StyleConstants;\n+import javax.swing.text.StyleContext;\n+import javax.swing.text.StyledDocument;\n+import javax.swing.text.View;\n+\n+import sun.swing.SwingUtilities2;\n@@ -2820,0 +2856,16 @@\n+        \/**\n+         * Merges the current value of the 'text-decoration' property\n+         * with the value from parent.\n+         *\/\n+        private Object getTextDecoration(Object value) {\n+            AttributeSet parent = getResolveParent();\n+            if (parent == null) {\n+                return value;\n+            }\n+\n+            Object parentValue = parent.getAttribute(CSS.Attribute.TEXT_DECORATION);\n+            return parentValue == null\n+                   ? value\n+                   : CSS.mergeTextDecoration(value + \",\" + parentValue);\n+        }\n+\n@@ -2823,1 +2875,6 @@\n-                return retValue;\n+                if (key != CSS.Attribute.TEXT_DECORATION) {\n+                    return retValue;\n+                } else {\n+                    \/\/ Merge current value with parent\n+                    return getTextDecoration(retValue);\n+                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/StyleSheet.java","additions":66,"deletions":9,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -959,1 +959,2 @@\n-     * @param delegationSubjects must be {@code null}.\n+     * @param delegationSubjects must be {@code null}, or an array\n+     * which does not contain any non-null entries.\n@@ -967,2 +968,1 @@\n-     * a null element, or if the three arrays do not all have the same\n-     * size.\n+     * a null element, or if these two arrays do not have the same size.\n@@ -977,1 +977,2 @@\n-     * @throws UnsupportedOperationException if {@code delegationSubject} is non-null.\n+     * @throws UnsupportedOperationException if {@code delegationSubjects}\n+     * is non-null and contains any non-null entries.\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnection.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -974,0 +974,2 @@\n+        \/\/ Accept an array of delegationSubjects from e.g. earlier JDKs,\n+        \/\/ but throw if it contains any non-null values.\n@@ -975,1 +977,5 @@\n-            throw new UnsupportedOperationException(\"Subject Delegation has been removed.\");\n+            for (Subject s: delegationSubjects) {\n+                if (s != null) {\n+                    throw new UnsupportedOperationException(\"Subject Delegation has been removed.\");\n+                }\n+            }\n@@ -977,4 +983,2 @@\n-        Subject[] sbjs = new Subject[names.length];\n-        if (names.length != filters.length || filters.length != sbjs.length) {\n-            final String msg =\n-                \"The value lengths of 3 parameters are not same.\";\n+        if (names.length != filters.length) {\n+            final String msg = \"The lengths of names and filters parameters are not same.\";\n@@ -1008,1 +1012,1 @@\n-                           NotificationFilter.class, sbjs[i]);\n+                           NotificationFilter.class, null);\n@@ -1020,1 +1024,1 @@\n-                                          sbjs[i]);\n+                                          null);\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectionImpl.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1620,5 +1620,8 @@\n-            (threadObject owner \"The monitor owner, or null if it is not currently owned.\")\n-            (int entryCount \"The number of times the monitor has been entered.\")\n-            (Repeat waiters \"The total number of threads that are waiting to enter or re-enter \"\n-                            \"the monitor, or waiting to be notified by the monitor.\"\n-                (threadObject thread \"A thread waiting for this monitor.\")\n+            (threadObject owner \"The platform thread owning this monitor, or null \"\n+                                \"if owned by a virtual thread or not owned.\")\n+            (int entryCount \"The number of times the owning platform thread has entered the monitor, \"\n+                            \"or 0 if owned by a virtual thread or not owned.\")\n+            (Repeat waiters \"The total number of platform threads that are waiting to enter or re-enter \"\n+                            \"the monitor, or waiting to be notified by the monitor, or 0 if \"\n+                            \"only virtual threads are waiting or no threads are waiting.\"\n+                (threadObject thread \"A platform thread waiting for this monitor.\")\n@@ -2874,1 +2877,1 @@\n-                             \"Request that generated event (or 0 if this \"\n+                             \"Request that generated event, or 0 if this \"\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,6 @@\n+    private static final boolean NAME_CASE_SENSITIVE_IN_MATCH\n+            = \"true\".equalsIgnoreCase(\n+                    SecurityProperties.privilegedGetOverridable(\n+                            \"jdk.security.krb5.name.case.sensitive\"));\n+\n+\n@@ -610,1 +616,9 @@\n-     * Checks if two <code>PrincipalName<\/code> objects have identical values in their corresponding data fields.\n+     * Checks if two <code>PrincipalName<\/code> objects have identical values\n+     * in their corresponding data fields.\n+     * <p>\n+     * If {@systemProperty jdk.security.krb5.name.case.sensitive} is set to true,\n+     * the name comparison is case-sensitive. Otherwise, it's case-insensitive.\n+     * <p>\n+     * It is used in {@link sun.security.krb5.internal.ccache.FileCredentialsCache}\n+     * and {@link sun.security.krb5.internal.ktab.KeyTab} to retrieve ccache\n+     * or keytab entry for a principal.\n@@ -615,1 +629,0 @@\n-    \/\/ It is used in <code>sun.security.krb5.internal.ccache<\/code> package.\n@@ -617,6 +630,7 @@\n-        boolean matched = true;\n-        \/\/name type is just a hint, no two names can be the same ignoring name type.\n-        \/\/ if (this.nameType != pname.nameType) {\n-        \/\/      matched = false;\n-        \/\/ }\n-        if ((this.nameRealm != null) && (pname.nameRealm != null)) {\n+        \/\/ No need to check name type. It's just a hint, no two names can be\n+        \/\/ the same ignoring name type.\n+        if (NAME_CASE_SENSITIVE_IN_MATCH) {\n+            if (!(this.nameRealm.toString().equals(pname.nameRealm.toString()))) {\n+                return false;\n+            }\n+        } else {\n@@ -624,1 +638,1 @@\n-                matched = false;\n+                return false;\n@@ -628,1 +642,1 @@\n-            matched = false;\n+            return false;\n@@ -631,2 +645,8 @@\n-                if (!(this.nameStrings[i].equalsIgnoreCase(pname.nameStrings[i]))) {\n-                    matched = false;\n+                if (NAME_CASE_SENSITIVE_IN_MATCH) {\n+                    if (!(this.nameStrings[i].equals(pname.nameStrings[i]))) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (!(this.nameStrings[i].equalsIgnoreCase(pname.nameStrings[i]))) {\n+                        return false;\n+                    }\n@@ -636,1 +656,1 @@\n-        return matched;\n+        return true;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/PrincipalName.java","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+################################################################################\n+#           JAXP Strict Configuration Template\n+#\n+# This file, jaxp-strict.properties.template, provides a template for creating\n+# custom configuration files. The settings in this file are more restrictive than\n+# those in the default configuration, jaxp.properties. In particular:\n+#   - JDKCatalog Resolve is on \"strict\" setting\n+#   - Extension Functions are disabled\n+#   - JAXP Limits are set to smaller numbers\n+#\n+# To create a configuration file, copy the template to a new file with\n+# the .properties extension, that is:\n+#\n+#     cp $JAVA_HOME\/conf\/jaxp-strict.properties.template \/path\/to\/jaxp-strict.properties\n+#\n+# The configuration file can then be set up using the system property\n+# java.xml.config.file to override the default configuration jaxp.properties\n+# and used to assess the impact of a stricter configuration, for example:\n+#\n+#     java -Djava.xml.config.file=\/path\/to\/jaxp-strict.properties\n+#\n+# The system property java.xml.config.file is defined in the java.xml module\n+# description.\n+#\n+################################################################################\n+\n+#\n+# ---- Implementation Specific Properties ----\n+# For a complete list of properties, refer to the Implementation Specific Properties\n+# table in the java.xml\/module-summary.\n+#\n+# Extension Functions:\n+#\n+# This property determines whether XSLT and XPath extension functions are allowed.\n+# The value type is boolean and the default value is true (allowing\n+# extension functions). The following entry overrides the default value and\n+# disallows extension functions:\n+#\n+jdk.xml.enableExtensionFunctions=false\n+#\n+#\n+# Overriding the default parser:\n+#\n+# This property allows a third party implementation to override the default\n+# parser provided by the JDK. The value type is boolean and the default value is\n+# false, disallowing overriding the default parser. The setting below reflects\n+# the default property setting:\n+#\n+jdk.xml.overrideDefaultParser=false\n+#\n+# Implementation Specific Properties - jdkcatalog.resolve\n+#\n+# This property instructs the JDK default CatalogResolver to act in accordance with\n+# the setting when unable to resolve an external reference with the built-in Catalog.\n+# The options are:\n+#     continue -- indicates that the processing should continue\n+#     ignore -- indicates that the reference is skipped\n+#     strict -- indicates that the resolver should throw a CatalogException\n+#\n+# The following setting causes the default CatalogResolver to throw a CatalogException\n+# when external references are not resolved by a user-defined resolver or catalog,\n+# or the built-in Catalog:\n+jdk.xml.jdkcatalog.resolve=strict\n+#\n+# Implementation Specific Properties - DTD\n+#\n+# This property instructs the parsers to deny, ignore or allow DTD processing.\n+# The following setting causes the parser to reject DTDs by throwing an exception.\n+# jdk.xml.dtd.support=deny\n+#\n+# The following setting permits the processor to continue processing DTDs. Note\n+# that while DTDs are allowed in this configuration, external references are\n+# restricted, and limits on DTD entities are tightened:\n+jdk.xml.dtd.support=allow\n+#\n+# Implementation Specific Properties - Limits\n+#\n+# Limits have a value type Integer. The values must be positive integers. Zero\n+# means no limit.\n+#\n+# Limits the number of entity expansions\n+jdk.xml.entityExpansionLimit=2500\n+#\n+# Limits the total size of all entities that include general and parameter entities.\n+# The size is calculated as an aggregation of all entities.\n+jdk.xml.totalEntitySizeLimit=100000\n+#\n+# Limits the maximum size of any general entities.\n+jdk.xml.maxGeneralEntitySizeLimit=100000\n+#\n+# Limits the maximum size of any parameter entities, including the result of\n+# nesting multiple parameter entities.\n+jdk.xml.maxParameterEntitySizeLimit=15000\n+#\n+# Limits the total number of nodes in all entity references.\n+jdk.xml.entityReplacementLimit=100000\n+#\n+# Limits the number of attributes an element can have. The default value is 10000.\n+jdk.xml.elementAttributeLimit=10000\n+#\n+# Limits the number of content model nodes that may be created when building a\n+# grammar for a W3C XML Schema that contains maxOccurs attributes with values\n+# other than \"unbounded\". The default value is 5000.\n+jdk.xml.maxOccurLimit=5000\n+#\n+# Limits the maximum element depth. The default value is 0.\n+jdk.xml.maxElementDepth=0\n+#\n+# Limits the maximum size of XML names, including element name, attribute name\n+# and namespace prefix and URI. The default value is 1000.\n+jdk.xml.maxXMLNameLimit=1000\n+#\n+#\n+# XPath Limits\n+#\n+# Limits the number of groups an XPath expression can contain. The default value is 10.\n+jdk.xml.xpathExprGrpLimit=10\n+#\n+# Limits the number of operators an XPath expression can contain. The default value is 100.\n+jdk.xml.xpathExprOpLimit=100\n+#\n+# Limits the total number of XPath operators in an XSL Stylesheet. The default value is 10000.\n+jdk.xml.xpathTotalOpLimit=10000\n","filename":"src\/java.xml\/share\/conf\/jaxp-strict.properties.template","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-# set a DocumentBuilderFactory implementation class:\n+# sets a DocumentBuilderFactory implementation class:\n@@ -52,1 +52,1 @@\n-# configuration file would therefore use javax.xml.catalog.resolve as the key, that\n+# configuration file therefore uses javax.xml.catalog.resolve as the key, that\n@@ -61,2 +61,2 @@\n-# extension functions). The following entry would override the default value and\n-# disallow extension functions:\n+# extension functions). The following entry overrides the default value and\n+# disallows extension functions:\n@@ -69,1 +69,1 @@\n-# This property allows using a third party implementation to override the default\n+# This property allows a third party implementation to override the default\n@@ -140,3 +140,4 @@\n-# The following setting would cause the resolve to throw a CatalogException when\n-# unable to resolve an external reference:\n-# jdk.xml.jdkcatalog.resolve=strict\n+# The following setting allows the resolution to continue in cases where\n+# external references are not resolved by a user-defined resolver or catalog if\n+# any, and the built-in Catalog:\n+jdk.xml.jdkcatalog.resolve=continue\n@@ -146,2 +147,2 @@\n-# This property instructs the parsers to: deny, ignore or allow DTD processing.\n-# The following setting would cause the parser to reject DTD by throwing an exception.\n+# This property instructs the parsers to deny, ignore or allow DTD processing.\n+# The following setting causes the parser to reject DTDs by throwing an exception.\n@@ -150,0 +151,3 @@\n+# The following setting permits the processor to continue processing DTDs\n+jdk.xml.dtd.support=allow\n+#\n@@ -160,1 +164,1 @@\n-# jdk.xml.totalEntitySizeLimit=5E7\n+# jdk.xml.totalEntitySizeLimit=50000000\n@@ -167,1 +171,1 @@\n-# jdk.xml.maxParameterEntitySizeLimit=1E6\n+# jdk.xml.maxParameterEntitySizeLimit=1000000\n@@ -170,1 +174,1 @@\n-# jdk.xml.entityReplacementLimit=3E6\n+# jdk.xml.entityReplacementLimit=3000000\n@@ -198,1 +202,0 @@\n-\n","filename":"src\/java.xml\/share\/conf\/jaxp.properties","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-            case SUPER_INIT -> true;\n+            case FLEXIBLE_CONSTRUCTORS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-        SUPER_INIT(JDK22, Fragments.FeatureSuperInit, DiagKind.NORMAL),\n@@ -272,0 +271,1 @@\n+        FLEXIBLE_CONSTRUCTORS(JDK22, Fragments.FeatureFlexibleConstructors, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -231,0 +231,1 @@\n+    public final Type ioType;\n@@ -635,0 +636,1 @@\n+        ioType = enterClass(\"java.io.IO\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,3 @@\n-        } else if ((v.flags() & FINAL) != 0 &&\n+            return;\n+        }\n+        if ((v.flags() & FINAL) != 0 &&\n@@ -307,0 +309,17 @@\n+            return;\n+        }\n+\n+        \/\/ Check instance field assignments that appear in constructor prologues\n+        if (rs.isEarlyReference(env, base, v)) {\n+\n+            \/\/ Field may not be inherited from a superclass\n+            if (v.owner != env.enclClass.sym) {\n+                log.error(pos, Errors.CantRefBeforeCtorCalled(v));\n+                return;\n+            }\n+\n+            \/\/ Field may not have an initializer\n+            if ((v.flags() & HASINIT) != 0) {\n+                log.error(pos, Errors.CantAssignInitializedBeforeCtorCalled(v));\n+                return;\n+            }\n@@ -2811,0 +2830,1 @@\n+                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4161,1 +4161,1 @@\n-                    preview.checkSourceLevel(apply.pos(), Feature.SUPER_INIT);\n+                    preview.checkSourceLevel(apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1601,0 +1601,3 @@\n+\n+        \/\/module readability is reflexive:\n+        msym.readModules.add(msym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1516,1 +1516,1 @@\n-                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0) {\n+                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym)) {\n@@ -3777,0 +3777,1 @@\n+        Assert.check(name == names._this || name == names._super);\n@@ -3786,1 +3787,1 @@\n-                    else if (env1.info.ctorPrologue)\n+                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym))\n@@ -3839,0 +3840,64 @@\n+    \/**\n+     * Determine if an early instance field reference may appear in a constructor prologue.\n+     *\n+     * <p>\n+     * This is only allowed when:\n+     *  - The field is being assigned a value (i.e., written but not read)\n+     *  - The field is not inherited from a superclass\n+     *  - The assignment is not within a lambda, because that would require\n+     *    capturing 'this' which is not allowed prior to super().\n+     *\n+     * <p>\n+     * Note, this method doesn't catch all such scenarios, because this method\n+     * is invoked for symbol \"x\" only for \"x = 42\" but not for \"this.x = 42\".\n+     * We also don't verify that the field has no initializer, which is required.\n+     * To catch those cases, we rely on similar logic in Attr.checkAssignable().\n+     *\/\n+    private boolean isAllowedEarlyReference(Env<AttrContext> env, VarSymbol v) {\n+\n+        \/\/ Check assumptions\n+        Assert.check(env.info.ctorPrologue);\n+        Assert.check((v.flags_field & STATIC) == 0);\n+\n+        \/\/ The symbol must appear in the LHS of an assignment statement\n+        if (!(env.tree instanceof JCAssign assign))\n+            return false;\n+\n+        \/\/ The assignment statement must not be within a lambda\n+        if (env.info.isLambda)\n+            return false;\n+\n+        \/\/ Get the symbol's qualifier, if any\n+        JCExpression lhs = TreeInfo.skipParens(assign.lhs);\n+        JCExpression base = lhs instanceof JCFieldAccess select ? select.selected : null;\n+\n+        \/\/ If an early reference, the field must not be declared in a superclass\n+        if (isEarlyReference(env, base, v) && v.owner != env.enclClass.sym)\n+            return false;\n+\n+        \/\/ OK\n+        return true;\n+    }\n+\n+    \/**\n+     * Determine if the variable appearance constitutes an early reference to the current class.\n+     *\n+     * <p>\n+     * This means the variable is an instance field of the current class and it appears\n+     * in an early initialization context of it (i.e., one of its constructor prologues).\n+     *\n+     * <p>\n+     * Such a reference is only allowed for assignments to non-initialized fields that are\n+     * not inherited from a superclass, though that is not enforced by this method.\n+     *\n+     * @param env    The current environment\n+     * @param base   Variable qualifier, if any, otherwise null\n+     * @param v      The variable\n+     *\/\n+    public boolean isEarlyReference(Env<AttrContext> env, JCTree base, VarSymbol v) {\n+        return env.info.ctorPrologue &&\n+            (v.flags() & STATIC) == 0 &&\n+            v.owner.kind == TYP &&\n+            types.isSubtype(env.enclClass.type, v.owner.type) &&\n+            (base == null || TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-        private void importJavaLang(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter typeImportFilter) {\n+        private void implicitImports(JCCompilationUnit tree, Env<AttrContext> env) {\n@@ -336,0 +336,22 @@\n+\n+            List<JCTree> defs = tree.getTypeDecls();\n+            boolean isImplicitClass = !defs.isEmpty() &&\n+                    defs.head instanceof JCClassDecl cls &&\n+                    (cls.mods.flags & IMPLICIT_CLASS) != 0;\n+            if (isImplicitClass) {\n+                doModuleImport(make.ModuleImport(make.QualIdent(syms.java_base)));\n+                if (peekTypeExists(syms.ioType.tsym)) {\n+                    doImport(make.Import(make.Select(make.QualIdent(syms.ioType.tsym),\n+                            names.asterisk), true));\n+                }\n+            }\n+        }\n+\n+        private boolean peekTypeExists(TypeSymbol type) {\n+            try {\n+                type.complete();\n+                return !type.type.isErroneous();\n+            } catch (CompletionFailure cf) {\n+                \/\/does not exist\n+                return false;\n+            }\n@@ -360,1 +382,1 @@\n-                importJavaLang(tree, env, typeImportFilter);\n+                implicitImports(tree, env);\n@@ -480,1 +502,1 @@\n-                        if (export.modules != null && !export.modules.contains(env.toplevel.packge.modle)) {\n+                        if (export.modules != null && !export.modules.contains(env.toplevel.modle)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -175,2 +175,2 @@\n-    Set<JCMethodInvocation> invocationsWithPatternMatchingCatch = Set.of();\n-    ListBuffer<int[]> patternMatchingInvocationRanges;\n+    PatternMatchingCatchConfiguration patternMatchingCatchConfiguration =\n+            new PatternMatchingCatchConfiguration(Set.of(), null, null, null);\n@@ -1135,3 +1135,1 @@\n-        Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n-        ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n-        State startState = code.state.dup();\n+        PatternMatchingCatchConfiguration prevConfiguration = patternMatchingCatchConfiguration;\n@@ -1139,2 +1137,5 @@\n-            invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n-            patternMatchingInvocationRanges = new ListBuffer<>();\n+            patternMatchingCatchConfiguration =\n+                    new PatternMatchingCatchConfiguration(tree.patternMatchingCatch.calls2Handle(),\n+                                                         new ListBuffer<int[]>(),\n+                                                         tree.patternMatchingCatch.handler(),\n+                                                         code.state.dup());\n@@ -1143,0 +1144,8 @@\n+            generatePatternMatchingCatch(env);\n+            patternMatchingCatchConfiguration = prevConfiguration;\n+        }\n+    }\n+\n+    private void generatePatternMatchingCatch(Env<GenContext> env) {\n+        if (patternMatchingCatchConfiguration.handler != null &&\n+            !patternMatchingCatchConfiguration.ranges.isEmpty()) {\n@@ -1144,3 +1153,6 @@\n-            JCCatch handler = tree.patternMatchingCatch.handler();\n-            code.entryPoint(startState, handler.param.sym.type);\n-            genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+            JCCatch handler = patternMatchingCatchConfiguration.handler();\n+            code.entryPoint(patternMatchingCatchConfiguration.startState(),\n+                            handler.param.sym.type);\n+            genPatternMatchingCatch(handler,\n+                                    env,\n+                                    patternMatchingCatchConfiguration.ranges.toList());\n@@ -1148,2 +1160,0 @@\n-            invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n-            patternMatchingInvocationRanges = prevRanges;\n@@ -1974,1 +1984,1 @@\n-        if (invocationsWithPatternMatchingCatch.contains(tree)) {\n+        if (patternMatchingCatchConfiguration.invocations().contains(tree)) {\n@@ -1977,1 +1987,1 @@\n-            patternMatchingInvocationRanges.add(new int[] {start, code.curCP()});\n+            patternMatchingCatchConfiguration.ranges().add(new int[] {start, code.curCP()});\n@@ -1979,1 +1989,15 @@\n-            result = m.invoke();\n+            if (msym.isConstructor() && TreeInfo.isConstructorCall(tree)) {\n+                \/\/if this is a this(...) or super(...) call, there is a pending\n+                \/\/\"uninitialized this\" before this call. One catch handler cannot\n+                \/\/handle exceptions that may come from places with \"uninitialized this\"\n+                \/\/and (initialized) this, hence generate one set of handlers here\n+                \/\/for the \"uninitialized this\" case, and another set of handlers\n+                \/\/will be generated at the end of the method for the initialized this,\n+                \/\/if needed:\n+                generatePatternMatchingCatch(env);\n+                result = m.invoke();\n+                patternMatchingCatchConfiguration =\n+                        patternMatchingCatchConfiguration.restart(code.state.dup());\n+            } else {\n+                result = m.invoke();\n+            }\n@@ -2603,0 +2627,11 @@\n+    record PatternMatchingCatchConfiguration(Set<JCMethodInvocation> invocations,\n+                                            ListBuffer<int[]> ranges,\n+                                            JCCatch handler,\n+                                            State startState) {\n+        public PatternMatchingCatchConfiguration restart(State newState) {\n+            return new PatternMatchingCatchConfiguration(invocations(),\n+                                                        new ListBuffer<int[]>(),\n+                                                        handler(),\n+                                                        newState);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":50,"deletions":15,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.module.InvalidModuleDescriptorException;\n@@ -42,0 +43,4 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.SourceVersion;\n@@ -116,11 +121,45 @@\n-        try (var stream = Files.find(sourceRootPath, 99, (path, attr) -> attr.isDirectory())) {\n-            var names = new TreeSet<String>();\n-            stream.filter(ProgramDescriptor::containsAtLeastOneRegularFile)\n-                  .map(sourceRootPath::relativize)\n-                  .map(Path::toString)\n-                  .filter(string -> !string.isEmpty())\n-                  .map(string -> string.replace(File.separatorChar, '.'))\n-                  .forEach(names::add);\n-            return names;\n-        } catch (IOException exception) {\n-            throw new UncheckedIOException(exception);\n+        return explodedPackages(sourceRootPath);\n+    }\n+\n+    \/\/ -- exploded directories --> based on jdk.internal.module.ModulePath\n+\n+    private static Set<String> explodedPackages(Path dir) {\n+        String separator = dir.getFileSystem().getSeparator();\n+        try (Stream<Path> stream = Files.find(dir, Integer.MAX_VALUE,\n+                (path, attrs) -> attrs.isRegularFile() && !isHidden(path))) {\n+            return stream.map(dir::relativize)\n+                    .map(path -> toPackageName(path, separator))\n+                    .flatMap(Optional::stream)\n+                    .collect(Collectors.toSet());\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    \/**\n+     * Maps the relative path of an entry in an exploded module to a package\n+     * name.\n+     *\n+     * @throws InvalidModuleDescriptorException if the name is a class file in\n+     *         the top-level directory (and it's not module-info.class)\n+     *\/\n+    private static Optional<String> toPackageName(Path file, String separator) {\n+        assert file.getRoot() == null;\n+\n+        Path parent = file.getParent();\n+        if (parent == null) {\n+            String name = file.toString();\n+            if (name.endsWith(\".class\") && !name.equals(\"module-info.class\")) {\n+                String msg = name + \" found in top-level directory\"\n+                        + \" (unnamed package not allowed in module)\";\n+                throw new InvalidModuleDescriptorException(msg);\n+            }\n+            return Optional.empty();\n+        }\n+\n+        String pn = parent.toString().replace(separator, \".\");\n+        if (SourceVersion.isName(pn)) {\n+            return Optional.of(pn);\n+        } else {\n+            \/\/ not a valid package name\n+            return Optional.empty();\n@@ -130,5 +169,8 @@\n-    private static boolean containsAtLeastOneRegularFile(Path directory) {\n-        try (var stream = Files.newDirectoryStream(directory, Files::isRegularFile)) {\n-            return stream.iterator().hasNext();\n-        } catch (IOException exception) {\n-            throw new UncheckedIOException(exception);\n+    \/**\n+     * Returns true if the given file exists and is a hidden file\n+     *\/\n+    private static boolean isHidden(Path file) {\n+        try {\n+            return Files.isHidden(file);\n+        } catch (IOException ioe) {\n+            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/ProgramDescriptor.java","additions":58,"deletions":16,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,2 @@\n-        Path out = Paths.get(String.format(\"javac.%s.args\",\n+        Path tmpDir = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n+        Path out = tmpDir.resolve(String.format(\"javac.%s.args\",\n@@ -376,1 +377,1 @@\n-        String strOut = \"\";\n+        String strOut = \"# javac crashed, this report includes the parameters passed to it in the @-file format\\n\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Main.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -402,0 +402,4 @@\n+# 0: symbol or name\n+compiler.err.cant.assign.initialized.before.ctor.called=\\\n+    cannot assign initialized field ''{0}'' before supertype constructor has been called\n+\n@@ -3227,2 +3231,2 @@\n-compiler.misc.feature.super.init=\\\n-    statements before super()\n+compiler.misc.feature.flexible.constructors=\\\n+    flexible constructors\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -306,0 +306,10 @@\n+    \/**\n+     * Is the given method invocation an invocation of this(...) or super(...)?\n+     *\/\n+    public static boolean isConstructorCall(JCMethodInvocation invoke) {\n+        Name name = TreeInfo.name(invoke.meth);\n+        Names names = name.table.names;\n+\n+        return (name == names._this || name == names._super);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+    @Override\n+    public void visitModuleImport(JCModuleImport tree) {\n+        scan(tree.module);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -134,0 +134,5 @@\n+    public void visitModuleImport(JCModuleImport tree) {\n+        tree.module = translate(tree.module);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-                          HeapRegion region = heap.hrm().getByAddress(handle);\n+                          G1HeapRegion region = heap.hrm().getByAddress(handle);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    private Iterator<HeapRegion> heapRegionIterator() {\n+    private Iterator<G1HeapRegion> heapRegionIterator() {\n@@ -118,1 +118,1 @@\n-        Iterator<HeapRegion> iter = heapRegionIterator();\n+        Iterator<G1HeapRegion> iter = heapRegionIterator();\n@@ -120,1 +120,1 @@\n-            HeapRegion hr = iter.next();\n+            G1HeapRegion hr = iter.next();\n@@ -125,2 +125,2 @@\n-    public HeapRegion heapRegionForAddress(Address addr) {\n-        Iterator<HeapRegion> iter = heapRegionIterator();\n+    public G1HeapRegion heapRegionForAddress(Address addr) {\n+        Iterator<G1HeapRegion> iter = heapRegionIterator();\n@@ -128,1 +128,1 @@\n-            HeapRegion hr = iter.next();\n+            G1HeapRegion hr = iter.next();\n@@ -142,1 +142,1 @@\n-        Iterator<HeapRegion> iter = heapRegionIterator();\n+        Iterator<G1HeapRegion> iter = heapRegionIterator();\n@@ -144,1 +144,1 @@\n-            HeapRegion hr = iter.next();\n+            G1HeapRegion hr = iter.next();\n@@ -155,1 +155,1 @@\n-        tty.println(\" region size \" + (HeapRegion.grainBytes() \/ 1024) + \"K\");\n+        tty.println(\" region size \" + (G1HeapRegion.grainBytes() \/ 1024) + \"K\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1CollectedHeap.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-\/\/ Mirror class for HeapRegion. Currently we don't actually include\n+\/\/ Mirror class for G1HeapRegion. Currently we don't actually include\n@@ -47,1 +47,1 @@\n-public class HeapRegion extends ContiguousSpace implements LiveRegionsProvider {\n+public class G1HeapRegion extends ContiguousSpace implements LiveRegionsProvider {\n@@ -69,1 +69,1 @@\n-        Type type = db.lookupType(\"HeapRegion\");\n+        Type type = db.lookupType(\"G1HeapRegion\");\n@@ -80,1 +80,1 @@\n-        pointerSize = db.lookupType(\"HeapRegion*\").getSize();\n+        pointerSize = db.lookupType(\"G1HeapRegion*\").getSize();\n@@ -87,1 +87,1 @@\n-    public HeapRegion(Address addr) {\n+    public G1HeapRegion(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegion.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegion.java","status":"renamed"},{"patch":"@@ -41,1 +41,1 @@\n-\/\/ Mirror class for G1HeapRegionTable. It's essentially an index -> HeapRegion map.\n+\/\/ Mirror class for G1HeapRegionTable. It's essentially an index -> G1HeapRegion map.\n@@ -44,1 +44,1 @@\n-    \/\/ HeapRegion** _base;\n+    \/\/ G1HeapRegion** _base;\n@@ -48,1 +48,1 @@\n-    \/\/ HeapRegion** _biased_base\n+    \/\/ G1HeapRegion** _biased_base\n@@ -73,1 +73,1 @@\n-    private HeapRegion at(long index) {\n+    private G1HeapRegion at(long index) {\n@@ -78,1 +78,1 @@\n-        return VMObjectFactory.newObject(HeapRegion.class, regionAddr);\n+        return VMObjectFactory.newObject(G1HeapRegion.class, regionAddr);\n@@ -93,1 +93,1 @@\n-    private class HeapRegionIterator implements Iterator<HeapRegion> {\n+    private class G1HeapRegionIterator implements Iterator<G1HeapRegion> {\n@@ -96,1 +96,1 @@\n-        private HeapRegion next;\n+        private G1HeapRegion next;\n@@ -98,2 +98,2 @@\n-        public HeapRegion positionToNext() {\n-          HeapRegion result = next;\n+        public G1HeapRegion positionToNext() {\n+          G1HeapRegion result = next;\n@@ -116,1 +116,1 @@\n-        public HeapRegion next() { return positionToNext(); }\n+        public G1HeapRegion next() { return positionToNext(); }\n@@ -121,1 +121,1 @@\n-        HeapRegionIterator(long totalLength) {\n+        G1HeapRegionIterator(long totalLength) {\n@@ -128,2 +128,2 @@\n-    public Iterator<HeapRegion> heapRegionIterator(long committedLength) {\n-        return new HeapRegionIterator(committedLength);\n+    public Iterator<G1HeapRegion> heapRegionIterator(long committedLength) {\n+        return new G1HeapRegionIterator(committedLength);\n@@ -136,1 +136,1 @@\n-    public HeapRegion getByAddress(Address target) {\n+    public G1HeapRegion getByAddress(Address target) {\n@@ -139,1 +139,1 @@\n-        long offset = biasedIndex * HeapRegion.getPointerSize();\n+        long offset = biasedIndex * G1HeapRegion.getPointerSize();\n@@ -141,1 +141,1 @@\n-        return VMObjectFactory.newObject(HeapRegion.class, regionAddr);\n+        return VMObjectFactory.newObject(G1HeapRegion.class, regionAddr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1HeapRegionTable.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        return edenSpaceUsed() \/ HeapRegion.grainBytes();\n+        return edenSpaceUsed() \/ G1HeapRegion.grainBytes();\n@@ -93,1 +93,1 @@\n-        return survivorSpaceUsed() \/ HeapRegion.grainBytes();\n+        return survivorSpaceUsed() \/ G1HeapRegion.grainBytes();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/G1MonitoringSupport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-    public void doHeapRegion(HeapRegion hr);\n+    public void doHeapRegion(G1HeapRegion hr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionClosure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        return length() * HeapRegion.grainBytes();\n+        return length() * G1HeapRegion.grainBytes();\n@@ -73,1 +73,1 @@\n-    public Iterator<HeapRegion> heapRegionIterator() {\n+    public Iterator<G1HeapRegion> heapRegionIterator() {\n@@ -81,1 +81,1 @@\n-    public HeapRegion getByAddress(Address addr) {\n+    public G1HeapRegion getByAddress(Address addr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegionManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import sun.jvm.hotspot.gc.g1.HeapRegion;\n+import sun.jvm.hotspot.gc.g1.G1HeapRegion;\n@@ -37,1 +37,1 @@\n-    public void doHeapRegion(HeapRegion hr) {\n+    public void doHeapRegion(G1HeapRegion hr) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/PrintRegionClosure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        printValMB(\"G1HeapRegionSize         = \", HeapRegion.grainBytes());\n+        printValMB(\"G1HeapRegionSize       = \", G1HeapRegion.grainBytes());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,2 +126,2 @@\n-        \/\/ memory, even if that area of memory is not in use by a G1 HeapRegion. So there\n-        \/\/ may in fact be no HeapRegion for the address even though it is in the heap.\n+        \/\/ memory, even if that area of memory is not in use by a G1HeapRegion. So there\n+        \/\/ may in fact be no G1HeapRegion for the address even though it is in the heap.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerFinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  HeapRegion hr;   \/\/ G1 heap region\n+  G1HeapRegion hr;   \/\/ G1 heap region\n@@ -131,1 +131,1 @@\n-  public HeapRegion getHeapRegion() {\n+  public G1HeapRegion getG1HeapRegion() {\n@@ -305,1 +305,1 @@\n-        } else if (getHeapRegion() != null) {\n+        } else if (getG1HeapRegion() != null) {\n@@ -309,1 +309,1 @@\n-                getHeapRegion().printOn(tty); \/\/ includes \"\\n\"\n+                getG1HeapRegion().printOn(tty); \/\/ includes \"\\n\"\n@@ -362,1 +362,2 @@\n-        ((JavaThread) handleThread).printThreadIDOn(tty); \/\/ includes \"\\n\"\n+        ((JavaThread) handleThread).printThreadIDOn(tty);\n+        tty.println();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerLocation.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -87,0 +87,24 @@\n+        @Override\n+        public JdkConsole println(Object obj) {\n+            writer().println(obj);\n+            writer().flush();\n+            return this;\n+        }\n+\n+        @Override\n+        public JdkConsole print(Object obj) {\n+            writer().print(obj);\n+            writer().flush();\n+            return this;\n+        }\n+\n+        @Override\n+        public String readln(String prompt) {\n+            try {\n+                initJLineIfNeeded();\n+                return jline.readLine(prompt == null ? \"null\" : prompt.replace(\"%\", \"%%\"));\n+            } catch (EndOfFileException eofe) {\n+                return null;\n+            }\n+        }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-                        mm.findAttribute(Attributes.EXCEPTIONS).ifPresent(ea ->\n+                        mm.findAttribute(Attributes.exceptions()).ifPresent(ea ->\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/FingerPrint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-                    var sigAttr = componentInfo.findAttribute(Attributes.SIGNATURE);\n+                    var sigAttr = componentInfo.findAttribute(Attributes.signature());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-        cm.findAttribute(Attributes.SOURCE_FILE).ifPresent(sfa ->\n+        cm.findAttribute(Attributes.sourceFile()).ifPresent(sfa ->\n@@ -156,1 +156,1 @@\n-            var attr = classModel.findAttribute(Attributes.MODULE);\n+            var attr = classModel.findAttribute(Attributes.module());\n@@ -183,1 +183,1 @@\n-            var sigAttr = classModel.findAttribute(Attributes.SIGNATURE).orElse(null);\n+            var sigAttr = classModel.findAttribute(Attributes.signature()).orElse(null);\n@@ -404,1 +404,1 @@\n-                f.findAttribute(Attributes.SIGNATURE)\n+                f.findAttribute(Attributes.signature())\n@@ -410,1 +410,1 @@\n-            var a = f.findAttribute(Attributes.CONSTANT_VALUE);\n+            var a = f.findAttribute(Attributes.constantValue());\n@@ -485,1 +485,1 @@\n-            var sigAttr = m.findAttribute(Attributes.SIGNATURE);\n+            var sigAttr = m.findAttribute(Attributes.signature());\n@@ -512,1 +512,1 @@\n-            var e_attr = m.findAttribute(Attributes.EXCEPTIONS);\n+            var e_attr = m.findAttribute(Attributes.exceptions());\n@@ -564,1 +564,1 @@\n-                code.findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                code.findAttribute(Attributes.lineNumberTable())\n@@ -566,1 +566,1 @@\n-                code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE)\n+                code.findAttribute(Attributes.localVariableTable())\n@@ -594,1 +594,1 @@\n-        var attr = classModel.findAttribute(Attributes.MODULE);\n+        var attr = classModel.findAttribute(Attributes.module());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -677,1 +677,1 @@\n-            var a = cm.findAttribute(java.lang.classfile.Attributes.INNER_CLASSES);\n+            var a = cm.findAttribute(java.lang.classfile.Attributes.innerClasses());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        var lvt = attr.findAttribute(Attributes.LOCAL_VARIABLE_TABLE);\n+        var lvt = attr.findAttribute(Attributes.localVariableTable());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/LocalVariableTableWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        var lvt = attr.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE);\n+        var lvt = attr.findAttribute(Attributes.localVariableTypeTable());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/LocalVariableTypeTableWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        for (var t : attr.findAttributes(Attributes.LINE_NUMBER_TABLE)) {\n+        for (var t : attr.findAttributes(Attributes.lineNumberTable())) {\n@@ -148,1 +148,1 @@\n-            var sf = cf.findAttribute(Attributes.SOURCE_FILE);\n+            var sf = cf.findAttribute(Attributes.sourceFile());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/SourceWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        StackMapTableAttribute attr = code.findAttribute(Attributes.STACK_MAP_TABLE)\n+        StackMapTableAttribute attr = code.findAttribute(Attributes.stackMapTable())\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/StackMapWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                m.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS)\n+                m.findAttribute(Attributes.runtimeVisibleTypeAnnotations())\n@@ -82,1 +82,1 @@\n-                m.findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS)\n+                m.findAttribute(Attributes.runtimeInvisibleTypeAnnotations())\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/TypeAnnotationWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-                    var sa = attrs.findAttribute(Attributes.SIGNATURE).orElse(null);\n+                    var sa = attrs.findAttribute(Attributes.signature()).orElse(null);\n@@ -609,1 +609,1 @@\n-                    var rvaa = attrs.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+                    var rvaa = attrs.findAttribute(Attributes.runtimeVisibleAnnotations()).orElse(null);\n@@ -616,1 +616,1 @@\n-                    var rvpaa = attrs.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS).orElse(null);\n+                    var rvpaa = attrs.findAttribute(Attributes.runtimeVisibleParameterAnnotations()).orElse(null);\n@@ -625,1 +625,1 @@\n-                    var exceptions = attrs.findAttribute(Attributes.EXCEPTIONS).orElse(null);\n+                    var exceptions = attrs.findAttribute(Attributes.exceptions()).orElse(null);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Dependencies.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-     * each thread currently waiting for this object's monitor.\n+     * each platform thread currently waiting for this object's monitor.\n@@ -358,1 +358,2 @@\n-     * has zero length if no threads are waiting for the monitor.\n+     * has zero length if no threads are waiting for the monitor,\n+     * or only virtual threads are waiting for the monitor.\n@@ -369,1 +370,1 @@\n-     * Returns an {@link ThreadReference} for the thread, if any,\n+     * Returns a {@link ThreadReference} for the platform thread, if any,\n@@ -378,2 +379,3 @@\n-     * @return the {@link ThreadReference} which currently owns the\n-     * monitor, or null if it is unowned.\n+     * @return the {@link ThreadReference} of the platform thread which\n+     * currently owns the monitor, or null if the monitor is owned\n+     * by a virtual thread or not owned.\n@@ -389,2 +391,3 @@\n-     * Returns the number times this object's monitor has been\n-     * entered by the current owning thread.\n+     * Returns the number of times this object's monitor has been entered by\n+     * the current owning thread if the owning thread is platform thread;\n+     * Returns 0 if not owned by a platform thread.\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ObjectReference.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -194,0 +194,40 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public JdkConsole println(Object obj) {\n+            writer().println(obj);\n+            writer().flush();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public JdkConsole print(Object obj) {\n+            writer().print(obj);\n+            writer().flush();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\n+         * @throws IOError {@inheritDoc}\n+         *\/\n+        @Override\n+        public String readln(String prompt) {\n+            try {\n+                return sendAndReceive(() -> {\n+                    remoteInput.write(Task.READ_LINE.ordinal());\n+                    char[] chars = (prompt == null ? \"null\" : prompt).toCharArray();\n+                    sendChars(chars, 0, chars.length);\n+                    char[] line = readChars();\n+                    return new String(line);\n+                });\n+            } catch (IOException ex) {\n+                throw new IOError(ex);\n+            }\n+        }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/impl\/ConsoleImpl.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,0 +28,14 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n+import java.security.PrivilegedAction;\n+import java.util.List;\n+import java.util.Set;\n+\n@@ -29,0 +43,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -33,4 +48,0 @@\n-import java.lang.reflect.Field;\n-import java.util.Set;\n-\n-\n@@ -51,0 +62,5 @@\n+ * @apiNote\n+ * This class pre-dates the introduction of {@link VarHandle}, low-level access to\n+ * memory with {@linkplain java.lang.foreign}, and other standard APIs. New code\n+ * should not use this API.\n+ *\n@@ -152,0 +168,3 @@\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfInt, long)} instead.\n+     *\n@@ -161,0 +180,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -163,0 +183,1 @@\n+        beforeMemoryAccess();\n@@ -177,0 +198,3 @@\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfInt, long, int)} instead.\n+     *\n@@ -186,0 +210,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -188,0 +213,1 @@\n+        beforeMemoryAccess();\n@@ -193,1 +219,2 @@\n-     * @see #getInt(Object, long)\n+     *\n+     * @deprecated Use {@link VarHandle#get(Object...)} instead.\n@@ -195,0 +222,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -197,0 +225,1 @@\n+        beforeMemoryAccess();\n@@ -208,1 +237,2 @@\n-     * @see #putInt(Object, long, int)\n+     *\n+     * @deprecated Use {@link VarHandle#set(Object...)} instead.\n@@ -210,0 +240,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -212,0 +243,1 @@\n+        beforeMemoryAccess();\n@@ -215,1 +247,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfBoolean, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -218,0 +256,1 @@\n+        beforeMemoryAccess();\n@@ -221,1 +260,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfBoolean, long, boolean)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -224,0 +269,1 @@\n+        beforeMemoryAccess();\n@@ -227,1 +273,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfByte, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -230,0 +282,1 @@\n+        beforeMemoryAccess();\n@@ -233,1 +286,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfByte, long, byte)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -236,0 +295,1 @@\n+        beforeMemoryAccess();\n@@ -239,1 +299,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfShort, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -242,0 +308,1 @@\n+        beforeMemoryAccess();\n@@ -245,1 +312,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfShort, long, short)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -248,0 +321,1 @@\n+        beforeMemoryAccess();\n@@ -251,1 +325,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfChar, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -254,0 +334,1 @@\n+        beforeMemoryAccess();\n@@ -257,1 +338,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfChar, long, char)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -260,0 +347,1 @@\n+        beforeMemoryAccess();\n@@ -263,1 +351,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfLong, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -266,0 +360,1 @@\n+        beforeMemoryAccess();\n@@ -269,1 +364,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfLong, long, long)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -272,0 +373,1 @@\n+        beforeMemoryAccess();\n@@ -275,1 +377,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfFloat, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -278,0 +386,1 @@\n+        beforeMemoryAccess();\n@@ -281,1 +390,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfFloat, long, float)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -284,0 +399,1 @@\n+        beforeMemoryAccess();\n@@ -287,1 +403,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfDouble, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -290,0 +412,1 @@\n+        beforeMemoryAccess();\n@@ -293,1 +416,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfDouble, long, double)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -296,0 +425,1 @@\n+        beforeMemoryAccess();\n@@ -306,0 +436,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -308,0 +440,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -310,0 +443,1 @@\n+        beforeMemoryAccess();\n@@ -318,0 +452,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -320,0 +456,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -322,0 +459,1 @@\n+        beforeMemoryAccess();\n@@ -325,1 +463,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -328,0 +471,1 @@\n+        beforeMemoryAccess();\n@@ -331,1 +475,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -334,0 +483,1 @@\n+        beforeMemoryAccess();\n@@ -337,1 +487,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -340,0 +495,1 @@\n+        beforeMemoryAccess();\n@@ -343,1 +499,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -346,0 +507,1 @@\n+        beforeMemoryAccess();\n@@ -349,1 +511,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -352,0 +519,1 @@\n+        beforeMemoryAccess();\n@@ -355,1 +523,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -358,0 +531,1 @@\n+        beforeMemoryAccess();\n@@ -361,1 +535,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -364,0 +543,1 @@\n+        beforeMemoryAccess();\n@@ -367,1 +547,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -370,0 +555,1 @@\n+        beforeMemoryAccess();\n@@ -373,1 +559,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -376,0 +567,1 @@\n+        beforeMemoryAccess();\n@@ -379,1 +571,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -382,0 +579,1 @@\n+        beforeMemoryAccess();\n@@ -385,1 +583,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -388,0 +591,1 @@\n+        beforeMemoryAccess();\n@@ -391,1 +595,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -394,0 +603,1 @@\n+        beforeMemoryAccess();\n@@ -410,0 +620,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -412,0 +624,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -414,0 +627,1 @@\n+        beforeMemoryAccess();\n@@ -425,0 +639,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -427,0 +643,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -429,0 +646,1 @@\n+        beforeMemoryAccess();\n@@ -452,0 +670,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to allocate off-heap memory.\n+     *\n@@ -460,0 +680,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -462,0 +683,1 @@\n+        beforeMemoryAccess();\n@@ -484,0 +706,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to allocate off-heap memory.\n+     *\n@@ -491,0 +715,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -493,0 +718,1 @@\n+        beforeMemoryAccess();\n@@ -520,0 +746,3 @@\n+     * @deprecated {@link MemorySegment#fill(byte)} fills the contents of a memory\n+     * segment with a given value.\n+     *\n@@ -524,0 +753,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -526,0 +756,1 @@\n+        beforeMemoryAccess();\n@@ -535,0 +766,5 @@\n+     *\n+     * @deprecated {@link MemorySegment#fill(byte)} fills the contents of a memory\n+     * segment with a given value.\n+     *\n+     * Use {@link MemorySegment} and its bulk copy methods instead.\n@@ -536,0 +772,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -538,0 +775,1 @@\n+        beforeMemoryAccess();\n@@ -565,0 +803,2 @@\n+     * @deprecated Use {@link MemorySegment} and its bulk copy methods instead.\n+     *\n@@ -569,0 +809,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -573,0 +814,1 @@\n+        beforeMemoryAccess();\n@@ -582,0 +824,2 @@\n+     *\n+     * @deprecated Use {@link MemorySegment} and its bulk copy methods instead.\n@@ -583,0 +827,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -585,0 +830,1 @@\n+        beforeMemoryAccess();\n@@ -602,0 +848,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to allocate and free off-heap memory.\n+     *\n@@ -606,0 +854,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -608,0 +857,1 @@\n+        beforeMemoryAccess();\n@@ -617,0 +867,1 @@\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n@@ -618,0 +869,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -640,1 +892,1 @@\n-     * in a future release. Use {@link java.lang.invoke.VarHandle} instead.\n+     * in a future release. Use {@link VarHandle} instead.\n@@ -644,1 +896,1 @@\n-    @Deprecated(since=\"18\")\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -661,0 +913,1 @@\n+        beforeMemoryAccess();\n@@ -683,1 +936,1 @@\n-     * in a future release. Use {@link java.lang.invoke.VarHandle} instead.\n+     * in a future release. Use {@link VarHandle} instead.\n@@ -687,1 +940,1 @@\n-    @Deprecated(since=\"18\")\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -704,0 +957,1 @@\n+        beforeMemoryAccess();\n@@ -720,1 +974,1 @@\n-     * in a future release. Use {@link java.lang.invoke.VarHandle} instead.\n+     * in a future release. Use {@link VarHandle} instead.\n@@ -722,1 +976,1 @@\n-    @Deprecated(since=\"18\")\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -739,0 +993,1 @@\n+        beforeMemoryAccess();\n@@ -749,0 +1004,2 @@\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\n@@ -752,0 +1009,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -754,0 +1012,1 @@\n+        beforeMemoryAccess();\n@@ -757,1 +1016,5 @@\n-    \/** The value of {@code arrayBaseOffset(boolean[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(boolean[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -760,1 +1023,5 @@\n-    \/** The value of {@code arrayBaseOffset(byte[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(byte[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -763,1 +1030,5 @@\n-    \/** The value of {@code arrayBaseOffset(short[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(short[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -766,1 +1037,5 @@\n-    \/** The value of {@code arrayBaseOffset(char[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(char[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -769,1 +1044,5 @@\n-    \/** The value of {@code arrayBaseOffset(int[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(int[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -772,1 +1051,5 @@\n-    \/** The value of {@code arrayBaseOffset(long[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(long[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -775,1 +1058,5 @@\n-    \/** The value of {@code arrayBaseOffset(float[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(float[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -778,1 +1065,5 @@\n-    \/** The value of {@code arrayBaseOffset(double[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(double[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -781,1 +1072,5 @@\n-    \/** The value of {@code arrayBaseOffset(Object[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(Object[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -791,0 +1086,2 @@\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\n@@ -795,0 +1092,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -800,1 +1098,5 @@\n-    \/** The value of {@code arrayIndexScale(boolean[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(boolean[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -803,1 +1105,5 @@\n-    \/** The value of {@code arrayIndexScale(byte[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(byte[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -806,1 +1112,5 @@\n-    \/** The value of {@code arrayIndexScale(short[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(short[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -809,1 +1119,5 @@\n-    \/** The value of {@code arrayIndexScale(char[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(char[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -812,1 +1126,5 @@\n-    \/** The value of {@code arrayIndexScale(int[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(int[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -815,1 +1133,5 @@\n-    \/** The value of {@code arrayIndexScale(long[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(long[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -818,1 +1140,5 @@\n-    \/** The value of {@code arrayIndexScale(float[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(float[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -821,1 +1147,5 @@\n-    \/** The value of {@code arrayIndexScale(double[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(double[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -824,1 +1154,5 @@\n-    \/** The value of {@code arrayIndexScale(Object[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(Object[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -832,0 +1166,2 @@\n+     *\n+     * @deprecated Use {@link ValueLayout#ADDRESS}.{@link MemoryLayout#byteSize()} instead.\n@@ -833,0 +1169,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -838,1 +1175,5 @@\n-    \/** The value of {@code addressSize()} *\/\n+    \/** The value of {@code addressSize()}.\n+     *\n+     * @deprecated Use {@link ValueLayout#ADDRESS}.{@link MemoryLayout#byteSize()} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -877,0 +1218,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#compareAndExchange(Object...)} instead.\n@@ -878,0 +1221,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -882,0 +1226,1 @@\n+        beforeMemoryAccess();\n@@ -893,0 +1238,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#compareAndExchange(Object...)} instead.\n@@ -894,0 +1241,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -898,0 +1246,1 @@\n+        beforeMemoryAccess();\n@@ -909,0 +1258,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#compareAndExchange(Object...)} instead.\n@@ -910,0 +1261,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -914,0 +1266,1 @@\n+        beforeMemoryAccess();\n@@ -920,0 +1273,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n@@ -921,0 +1276,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -923,0 +1279,1 @@\n+        beforeMemoryAccess();\n@@ -929,0 +1286,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n@@ -930,0 +1289,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -932,0 +1292,1 @@\n+        beforeMemoryAccess();\n@@ -935,1 +1296,5 @@\n-    \/** Volatile version of {@link #getInt(Object, long)}  *\/\n+    \/** Volatile version of {@link #getInt(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -938,0 +1303,1 @@\n+        beforeMemoryAccess();\n@@ -941,1 +1307,5 @@\n-    \/** Volatile version of {@link #putInt(Object, long, int)}  *\/\n+    \/** Volatile version of {@link #putInt(Object, long, int)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -944,0 +1314,1 @@\n+        beforeMemoryAccess();\n@@ -947,1 +1318,5 @@\n-    \/** Volatile version of {@link #getBoolean(Object, long)}  *\/\n+    \/** Volatile version of {@link #getBoolean(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -950,0 +1325,1 @@\n+        beforeMemoryAccess();\n@@ -953,1 +1329,5 @@\n-    \/** Volatile version of {@link #putBoolean(Object, long, boolean)}  *\/\n+    \/** Volatile version of {@link #putBoolean(Object, long, boolean)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -956,0 +1336,1 @@\n+        beforeMemoryAccess();\n@@ -959,1 +1340,6 @@\n-    \/** Volatile version of {@link #getByte(Object, long)}  *\/\n+    \/** Volatile version of {@link #getByte(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)}\n+     * instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -962,0 +1348,1 @@\n+        beforeMemoryAccess();\n@@ -965,1 +1352,5 @@\n-    \/** Volatile version of {@link #putByte(Object, long, byte)}  *\/\n+    \/** Volatile version of {@link #putByte(Object, long, byte)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -968,0 +1359,1 @@\n+        beforeMemoryAccess();\n@@ -971,1 +1363,5 @@\n-    \/** Volatile version of {@link #getShort(Object, long)}  *\/\n+    \/** Volatile version of {@link #getShort(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -974,0 +1370,1 @@\n+        beforeMemoryAccess();\n@@ -977,1 +1374,5 @@\n-    \/** Volatile version of {@link #putShort(Object, long, short)}  *\/\n+    \/** Volatile version of {@link #putShort(Object, long, short)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -980,0 +1381,1 @@\n+        beforeMemoryAccess();\n@@ -983,1 +1385,5 @@\n-    \/** Volatile version of {@link #getChar(Object, long)}  *\/\n+    \/** Volatile version of {@link #getChar(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -986,0 +1392,1 @@\n+        beforeMemoryAccess();\n@@ -989,1 +1396,5 @@\n-    \/** Volatile version of {@link #putChar(Object, long, char)}  *\/\n+    \/** Volatile version of {@link #putChar(Object, long, char)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -992,0 +1403,1 @@\n+        beforeMemoryAccess();\n@@ -995,1 +1407,5 @@\n-    \/** Volatile version of {@link #getLong(Object, long)}  *\/\n+    \/** Volatile version of {@link #getLong(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -998,0 +1414,1 @@\n+        beforeMemoryAccess();\n@@ -1001,1 +1418,5 @@\n-    \/** Volatile version of {@link #putLong(Object, long, long)}  *\/\n+    \/** Volatile version of {@link #putLong(Object, long, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1004,0 +1425,1 @@\n+        beforeMemoryAccess();\n@@ -1007,1 +1429,5 @@\n-    \/** Volatile version of {@link #getFloat(Object, long)}  *\/\n+    \/** Volatile version of {@link #getFloat(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1010,0 +1436,1 @@\n+        beforeMemoryAccess();\n@@ -1013,1 +1440,5 @@\n-    \/** Volatile version of {@link #putFloat(Object, long, float)}  *\/\n+    \/** Volatile version of {@link #putFloat(Object, long, float)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1016,0 +1447,1 @@\n+        beforeMemoryAccess();\n@@ -1019,1 +1451,5 @@\n-    \/** Volatile version of {@link #getDouble(Object, long)}  *\/\n+    \/** Volatile version of {@link #getDouble(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1022,0 +1458,1 @@\n+        beforeMemoryAccess();\n@@ -1025,1 +1462,5 @@\n-    \/** Volatile version of {@link #putDouble(Object, long, double)}  *\/\n+    \/** Volatile version of {@link #putDouble(Object, long, double)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1028,0 +1469,1 @@\n+        beforeMemoryAccess();\n@@ -1039,0 +1481,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#setRelease(Object...)} instead.\n@@ -1040,0 +1484,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1042,0 +1487,1 @@\n+        beforeMemoryAccess();\n@@ -1045,1 +1491,5 @@\n-    \/** Ordered\/Lazy version of {@link #putIntVolatile(Object, long, int)}  *\/\n+    \/** Ordered\/Lazy version of {@link #putIntVolatile(Object, long, int)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setRelease(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1048,0 +1498,1 @@\n+        beforeMemoryAccess();\n@@ -1051,1 +1502,5 @@\n-    \/** Ordered\/Lazy version of {@link #putLongVolatile(Object, long, long)} *\/\n+    \/** Ordered\/Lazy version of {@link #putLongVolatile(Object, long, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setRelease(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1054,0 +1509,1 @@\n+        beforeMemoryAccess();\n@@ -1112,1 +1568,1 @@\n-     * @deprecated Use {@link java.lang.management.OperatingSystemMXBean#getSystemLoadAverage()}\n+     * @deprecated Use {@link java.management\/java.lang.management.OperatingSystemMXBean#getSystemLoadAverage()}\n@@ -1115,0 +1571,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -1134,0 +1591,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1135,0 +1594,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1137,0 +1597,1 @@\n+        beforeMemoryAccess();\n@@ -1150,0 +1611,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1151,0 +1614,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1153,0 +1617,1 @@\n+        beforeMemoryAccess();\n@@ -1166,0 +1631,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1167,0 +1634,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1169,0 +1637,1 @@\n+        beforeMemoryAccess();\n@@ -1182,0 +1651,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1183,0 +1654,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1185,0 +1657,1 @@\n+        beforeMemoryAccess();\n@@ -1198,0 +1671,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1199,0 +1674,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1201,0 +1677,1 @@\n+        beforeMemoryAccess();\n@@ -1215,1 +1692,1 @@\n-     * @deprecated Use {@link java.lang.invoke.VarHandle#acquireFence()} instead.\n+     * @deprecated Use {@link VarHandle#acquireFence()} instead.\n@@ -1235,1 +1712,1 @@\n-     * @deprecated Use {@link java.lang.invoke.VarHandle#releaseFence()} instead.\n+     * @deprecated Use {@link VarHandle#releaseFence()} instead.\n@@ -1252,1 +1729,1 @@\n-     * @deprecated Use {@link java.lang.invoke.VarHandle#fullFence()} instead.\n+     * @deprecated Use {@link VarHandle#fullFence()} instead.\n@@ -1269,0 +1746,6 @@\n+     *\n+     * @deprecated Use a {@link MemorySegment} allocated in an {@link Arena} with the\n+     * appropriate temporal bounds. The {@link MemorySegment#asByteBuffer()} method\n+     * wraps a memory segment as a {@code ByteBuffer} to allow interop with existing\n+     * code.\n+     *\n@@ -1271,0 +1754,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1273,2 +1757,2 @@\n-            throw new IllegalArgumentException(\"buffer is non-direct\");\n-\n+            throw new IllegalArgumentException(\"Not a direct buffer\");\n+        beforeMemoryAccess();\n@@ -1277,0 +1761,188 @@\n+\n+    \/\/ Infrastructure for --sun-misc-unsafe-memory-access=<value> command line option.\n+\n+    private static final Object MEMORY_ACCESS_WARNED_BASE;\n+    private static final long MEMORY_ACCESS_WARNED_OFFSET;\n+    static {\n+        try {\n+            Field field = Unsafe.class.getDeclaredField(\"memoryAccessWarned\");\n+            MEMORY_ACCESS_WARNED_BASE = theInternalUnsafe.staticFieldBase(field);\n+            MEMORY_ACCESS_WARNED_OFFSET = theInternalUnsafe.staticFieldOffset(field);\n+        } catch (Exception e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+    \/\/ set to true by first usage of memory-access method\n+    private static @Stable boolean memoryAccessWarned;\n+\n+    private static boolean isMemoryAccessWarned() {\n+        return theInternalUnsafe.getBooleanVolatile(MEMORY_ACCESS_WARNED_BASE, MEMORY_ACCESS_WARNED_OFFSET);\n+    }\n+\n+    private static boolean trySetMemoryAccessWarned() {\n+        return theInternalUnsafe.compareAndSetBoolean(MEMORY_ACCESS_WARNED_BASE, MEMORY_ACCESS_WARNED_OFFSET, false, true);\n+    }\n+\n+    private static final MemoryAccessOption MEMORY_ACCESS_OPTION = MemoryAccessOption.value();\n+\n+    \/**\n+     * Invoked by all memory-access methods.\n+     *\/\n+    @ForceInline\n+    private static void beforeMemoryAccess() {\n+        if (MEMORY_ACCESS_OPTION == MemoryAccessOption.ALLOW) {\n+            return;\n+        }\n+\n+        if (MEMORY_ACCESS_OPTION == MemoryAccessOption.WARN && isMemoryAccessWarned()) {\n+            \/\/ nothing to do if this is not the first usage\n+            return;\n+        }\n+\n+        \/\/ warn && first usage, debug, or deny\n+        beforeMemoryAccessSlow();\n+    }\n+\n+    private static void beforeMemoryAccessSlow() {\n+        assert MEMORY_ACCESS_OPTION != MemoryAccessOption.ALLOW;\n+\n+        \/\/ stack trace without the frames for the beforeMemoryAccess methods\n+        List<StackWalker.StackFrame> stack = StackWalkerHolder.INSTANCE.walk(s ->\n+                s.dropWhile(f -> (f.getDeclaringClass() == Unsafe.class)\n+                                && f.getMethodName().startsWith(\"beforeMemoryAccess\"))\n+                    .limit(32)\n+                    .toList()\n+        );\n+\n+        \/\/ callerClass -> Unsafe.methodName\n+        String methodName = stack.get(0).getMethodName();\n+        Class<?> callerClass = stack.get(1).getDeclaringClass();\n+\n+        switch (MEMORY_ACCESS_OPTION) {\n+            case WARN -> {\n+                if (trySetMemoryAccessWarned()) {\n+                    log(multiLineWarning(callerClass, methodName));\n+                }\n+            }\n+            case DEBUG -> {\n+                String warning = singleLineWarning(callerClass, methodName);\n+                StringBuilder sb = new StringBuilder(warning);\n+                stack.stream()\n+                        .skip(1)\n+                        .forEach(f ->\n+                                sb.append(System.lineSeparator()).append(\"\\tat \" + f)\n+                        );\n+                log(sb.toString());\n+            }\n+            case DENY -> {\n+                throw new UnsupportedOperationException(methodName);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Represents the options for the depreacted method-access methods.\n+     *\/\n+    private enum MemoryAccessOption {\n+        \/**\n+         * Allow use of the memory-access methods with no warnings.\n+         *\/\n+        ALLOW,\n+        \/**\n+         * Warning on the first use of a memory-access method.\n+         *\/\n+        WARN,\n+        \/**\n+         * One-line warning and a stack trace on every use of a memory-access method.\n+         *\/\n+        DEBUG,\n+        \/**\n+         * Deny use of the memory-access methods.\n+         *\/\n+        DENY;\n+\n+        private static MemoryAccessOption defaultValue() {\n+            return ALLOW;\n+        }\n+\n+        \/**\n+         * Return the value.\n+         *\/\n+        static MemoryAccessOption value() {\n+            String value = VM.getSavedProperty(\"sun.misc.unsafe.memory.access\");\n+            if (value != null) {\n+                return switch (value) {\n+                    case \"allow\" -> MemoryAccessOption.ALLOW;\n+                    case \"warn\"  -> MemoryAccessOption.WARN;\n+                    case \"debug\" -> MemoryAccessOption.DEBUG;\n+                    case \"deny\"  -> MemoryAccessOption.DENY;\n+                    default -> {\n+                        \/\/ should not happen\n+                        log(\"sun.misc.unsafe.memory.access ignored, value '\" + value +\n+                                \"' is not a recognized value\");\n+                        yield defaultValue();\n+                    }\n+                };\n+            } else {\n+                return defaultValue();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Holder for StackWalker that retains class references.\n+     *\/\n+    private static class StackWalkerHolder {\n+        static final StackWalker INSTANCE;\n+        static {\n+            PrivilegedAction<StackWalker> pa = () ->\n+                    StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            @SuppressWarnings(\"removal\")\n+            StackWalker walker = AccessController.doPrivileged(pa);\n+            INSTANCE = walker;\n+        }\n+    }\n+\n+    \/**\n+     * Return the multi-line warning message for when the given class invokes the\n+     * given the Unsafe method.\n+     *\/\n+    private static String multiLineWarning(Class<?> callerClass, String methodName) {\n+        return String.format(\n+                \"\"\"\n+                WARNING: A terminally deprecated method in sun.misc.Unsafe has been called\n+                WARNING: sun.misc.Unsafe::%s has been called by %s\n+                WARNING: Please consider reporting this to the maintainers of %s\n+                WARNING: sun.misc.Unsafe::%s will be removed in a future release\"\"\",\n+                methodName, callerAndLocation(callerClass), callerClass, methodName);\n+    }\n+\n+    \/**\n+     * Return the single-line warning message for when the given class invokes the\n+     * given the Unsafe method.\n+     *\/\n+    private static String singleLineWarning(Class<?> callerClass, String methodName) {\n+        return String.format(\"WARNING: sun.misc.Unsafe::%s called by %s\",\n+                methodName, callerAndLocation(callerClass));\n+    }\n+\n+    \/**\n+     * Returns a string with the caller class and the location URL from the CodeSource.\n+     *\/\n+    private static String callerAndLocation(Class<?> callerClass) {\n+        PrivilegedAction<ProtectionDomain> pa = callerClass::getProtectionDomain;\n+        @SuppressWarnings(\"removal\")\n+        CodeSource cs = AccessController.doPrivileged(pa).getCodeSource();\n+        String who = callerClass.getName();\n+        if (cs != null && cs.getLocation() != null) {\n+            who += \" (\" + cs.getLocation() + \")\";\n+        }\n+        return who;\n+    }\n+\n+    \/**\n+     * Prints the given message to the standard error.\n+     *\/\n+    private static void log(String message) {\n+        VM.initialErr().println(message);\n+    }\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":753,"deletions":81,"binary":false,"changes":834,"status":"modified"},{"patch":"@@ -105,0 +105,12 @@\n+\n+TESTING\n+\n+There are a few make targets for testing the failure_handler itself.\n+ - Everything in `test\/failure_handler\/Makefile`\n+ - The `test-failure-handler` target in `make\/RunTests.gmk`\n+ - The `test` target in `make\/test\/BuildFailureHandler.gmk`\n+All of these targets are written for manual testing only. They rely on\n+manual inspection of generated artifacts and cannot be run as part of a CI.\n+They are tests which timeout, crash, fail in various ways and you can check\n+the failure_handler output yourself. They might also leave processes running\n+on your machine so be extra careful about cleaning up.\n","filename":"test\/failure_handler\/README","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-        log.printf(\"%s%n[%tF %<tT] %s timeout=%s%n%1$s%n\", line, new Date(), pb.command(), params.timeout);\n+        log.printf(\"%s%n[%tF %<tT] %s timeout=%s in %s%n%1$s%n\", line, new Date(), pb.command(), params.timeout, pb.directory());\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  \/\/ Create a fake heap. It does not need to be valid, as the HeapRegion constructor\n+  \/\/ Create a fake heap. It does not need to be valid, as the G1HeapRegion constructor\n@@ -47,1 +47,1 @@\n-  MemRegion heap(nullptr, num_regions_in_test * HeapRegion::GrainWords);\n+  MemRegion heap(nullptr, num_regions_in_test * G1HeapRegion::GrainWords);\n@@ -49,1 +49,1 @@\n-  \/\/ Allocate a fake BOT because the HeapRegion constructor initializes\n+  \/\/ Allocate a fake BOT because the G1HeapRegion constructor initializes\n@@ -58,1 +58,1 @@\n-                                         HeapRegion::GrainBytes,\n+                                         G1HeapRegion::GrainBytes,\n@@ -65,5 +65,5 @@\n-  MemRegion mr0(heap.start(), HeapRegion::GrainWords);\n-  MemRegion mr1(mr0.end(), HeapRegion::GrainWords);\n-  MemRegion mr2(mr1.end(), HeapRegion::GrainWords);\n-  MemRegion mr3(mr2.end(), HeapRegion::GrainWords);\n-  MemRegion mr4(mr3.end(), HeapRegion::GrainWords);\n+  MemRegion mr0(heap.start(), G1HeapRegion::GrainWords);\n+  MemRegion mr1(mr0.end(), G1HeapRegion::GrainWords);\n+  MemRegion mr2(mr1.end(), G1HeapRegion::GrainWords);\n+  MemRegion mr3(mr2.end(), G1HeapRegion::GrainWords);\n+  MemRegion mr4(mr3.end(), G1HeapRegion::GrainWords);\n@@ -73,5 +73,5 @@\n-  HeapRegion hr0(0, &bot, mr0, &config);\n-  HeapRegion hr1(1, &bot, mr1, &config);\n-  HeapRegion hr2(2, &bot, mr2, &config);\n-  HeapRegion hr3(3, &bot, mr3, &config);\n-  HeapRegion hr4(4, &bot, mr4, &config);\n+  G1HeapRegion hr0(0, &bot, mr0, &config);\n+  G1HeapRegion hr1(1, &bot, mr1, &config);\n+  G1HeapRegion hr2(2, &bot, mr2, &config);\n+  G1HeapRegion hr3(3, &bot, mr3, &config);\n+  G1HeapRegion hr4(4, &bot, mr4, &config);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  HeapRegion* region = heap->heap_region_containing(heap->bottom_addr_for_region(0));\n+  G1HeapRegion* region = heap->heap_region_containing(heap->bottom_addr_for_region(0));\n@@ -91,1 +91,1 @@\n-  \/\/ will stop at HeapRegion::scan_limit which is equal to top.\n+  \/\/ will stop at G1HeapRegion::scan_limit which is equal to top.\n@@ -125,1 +125,1 @@\n-TEST_OTHER_VM(HeapRegion, apply_to_marked_object) {\n+TEST_OTHER_VM(G1HeapRegion, apply_to_marked_object) {\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_heapRegion.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"runtime\/os.hpp\"\n-#include \"cgroupSubsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include <stdio.h>\n-\n-\n-\/\/ Utilities\n-static bool file_exists(const char* filename) {\n-  struct stat st;\n-  return os::stat(filename, &st) == 0;\n-}\n-\n-static char* temp_file(const char* prefix) {\n-  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n-  stringStream path;\n-  path.print_raw(os::get_temp_directory());\n-  path.print_raw(os::file_separator());\n-  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n-             test_info->test_case_name(), test_info->name());\n-  return path.as_string(true);\n-}\n-\n-static void delete_file(const char* filename) {\n-  if (!file_exists(filename)) {\n-    return;\n-  }\n-  int ret = remove(filename);\n-  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n-      << os::strerror(errno) << \" (\" << errno << \")\";\n-}\n-\n-class TestController : public CgroupController {\n-public:\n-  char* subsystem_path() override {\n-    \/\/ The real subsystem is in \/tmp\/, generated by temp_file()\n-    return (char*)\"\/\";\n-  };\n-};\n-\n-static void fill_file(const char* path, const char* content) {\n-  delete_file(path);\n-  FILE* fp = os::fopen(path, \"w\");\n-  if (fp == nullptr) {\n-    return;\n-  }\n-  if (content != nullptr) {\n-    fprintf(fp, \"%s\", content);\n-  }\n-  fclose(fp);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo \");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"faulty_start foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be at start\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be exact match\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\tbar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"car\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"test\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo 1\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"max 10000\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"max\");\n-\n-  x = -3;\n-  fill_file(test_file, \"max 10001\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 10001);\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  fill_file(test_file, \"foo\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"foo\");\n-\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1337\");\n-\n-  x = -1;\n-  fill_file(test_file, nullptr);\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n-  EXPECT_EQ(x, -1) << \"x was altered\";\n-\n-  jlong y;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n-  julong z;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -0,0 +1,464 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <stdio.h>\n+\n+typedef struct {\n+  const char* mount_path;\n+  const char* root_path;\n+  const char* cgroup_path;\n+  const char* expected_path;\n+} TestCase;\n+\n+\/\/ Utilities\n+static bool file_exists(const char* filename) {\n+  struct stat st;\n+  return os::stat(filename, &st) == 0;\n+}\n+\n+static char* temp_file(const char* prefix) {\n+  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+  stringStream path;\n+  path.print_raw(os::get_temp_directory());\n+  path.print_raw(os::file_separator());\n+  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n+             test_info->test_case_name(), test_info->name());\n+  return path.as_string(true);\n+}\n+\n+static void delete_file(const char* filename) {\n+  if (!file_exists(filename)) {\n+    return;\n+  }\n+  int ret = remove(filename);\n+  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n+      << os::strerror(errno) << \" (\" << errno << \")\";\n+}\n+\n+class TestController : public CgroupController {\n+private:\n+  char* _path;\n+public:\n+  TestController(char* p): _path(p) {}\n+  char* subsystem_path() override {\n+    return _path;\n+  };\n+};\n+\n+static void fill_file(const char* path, const char* content) {\n+  delete_file(path);\n+  FILE* fp = os::fopen(path, \"w\");\n+  if (fp == nullptr) {\n+    return;\n+  }\n+  if (content != nullptr) {\n+    fprintf(fp, \"%s\", content);\n+  }\n+  fclose(fp);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_failure_cases) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  constexpr julong bad = 0xBAD;\n+  julong x = bad;\n+\n+  fill_file(test_file, \"foo \");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"Value is missing in key\/value case, expecting false\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"faulty_start foo 101\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be at the start\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, nullptr);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key not in empty file\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\n\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must have a value\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"foof 1002\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be exact match\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_success_cases) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  constexpr julong bad = 0xBAD;\n+  julong x = bad;\n+\n+  fill_file(test_file, \"foo 100\");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)100, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\nbar 333\\nfoo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foof 100\\nfoo 133\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)133, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\t333\\nfoot 999\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)333, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo 1\\nfoo car\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)1, x);\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_number_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  constexpr julong bad = 0xBAD;\n+  julong a = bad;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(bad, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_string_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  char foo[1024];\n+  foo[0] = '\\0';\n+  bool is_ok = too_large_path_controller->read_string(test_file_path, foo, 1024);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_STREQ(\"\", foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_number_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  constexpr julong bad = 0xBAD;\n+  julong result = bad;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ(bad, result) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* key = \"something\";\n+  constexpr julong bad = 0xBAD;\n+  julong a = bad;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(bad, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_number_tests) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  constexpr julong bad = 0xBAD;\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"8888\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong foo = bad;\n+  bool ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  \/\/ Some interface files might have negative values, ensure we can read\n+  \/\/ them and manually cast them as needed.\n+  fill_file(test_file, \"-1\");\n+  foo = bad;\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  foo = bad;\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_EQ(bad, foo) << \"foo was altered\";\n+\n+  \/\/ Some interface files have numbers as well as the string\n+  \/\/ 'max', which means unlimited.\n+  jlong result = -10;\n+  fill_file(test_file, \"max\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for 'max' string should have been successful\";\n+  EXPECT_EQ((jlong)-1, result) << \"'max' means unlimited (-1)\";\n+\n+  result = -10;\n+  fill_file(test_file, \"11114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)11114, result) << \"Incorrect result\";\n+\n+  result = -10;\n+  fill_file(test_file, \"-51114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)-51114, result) << \"Incorrect result\";\n+\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_string_tests) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"foo-bar\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  char result[1024];\n+  bool ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"foo-bar\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, \"1234\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"1234\", result);\n+\n+  \/\/ values with a space\n+  result[0] = '\\0';\n+  fill_file(test_file, \"abc def\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"abc def\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, \"  \\na\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"  \", result);\n+\n+  \/\/ only the first line are being returned\n+  result[0] = '\\0';\n+  fill_file(test_file, \"test\\nabc\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"test\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_STREQ(\"\", result) << \"Expected untouched result\";\n+  delete_file(test_file);\n+\n+  \/\/ File contents larger than 1K\n+  \/\/ We only read in the first 1K - 1 bytes\n+  const size_t large_len = 2 * 1024;\n+  char too_large[large_len];\n+  for (size_t i = 0; i < large_len; i++) {\n+    too_large[i] = 'A' + (i % 26);\n+  }\n+  too_large[large_len - 1] = '\\0';\n+  result[0] = '\\0';\n+  fill_file(test_file, too_large);\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(1023 == strlen(result)) << \"Expected only the first 1023 chars to be read in\";\n+  EXPECT_EQ(0, strncmp(too_large, result, 1023));\n+  EXPECT_EQ(result[1023], '\\0') << \"The last character must be the null character\";\n+}\n+\n+TEST(cgroupTest, read_number_tuple_test) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"max 10000\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  jlong result = -10;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read value\";\n+  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read the value\";\n+  EXPECT_EQ((jlong)10000, result);\n+\n+  \/\/ non-max strings\n+  fill_file(test_file, \"abc 10000\");\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_FALSE(ok) << \"abc should not be parsable\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+\n+  fill_file(test_file, nullptr);\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_FALSE(ok) << \"Empty file should be an error\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n+  TestCase host = {\n+    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n+    \"\/\",                                                                 \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+  };\n+  TestCase container_engine = {\n+    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &host,\n+                            &container_engine };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n+                                                       (char*)testCases[i]->mount_path);\n+    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n+  TestCase at_mount_root = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n+  };\n+  TestCase sub_path = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/foobar\",              \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &at_mount_root,\n+                            &sub_path };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n+                                                       (char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":464,"deletions":0,"binary":false,"changes":464,"status":"added"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"cgroupV1Subsystem_linux.hpp\"\n-#include \"cgroupV2Subsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-\n-typedef struct {\n-  const char* mount_path;\n-  const char* root_path;\n-  const char* cgroup_path;\n-  const char* expected_path;\n-} TestCase;\n-\n-TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n-  TestCase host = {\n-    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n-    \"\/\",                                                                 \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n-  };\n-  TestCase container_engine = {\n-    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &host,\n-                            &container_engine };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n-  TestCase at_mount_root = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/\",                    \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n-  };\n-  TestCase sub_path = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/foobar\",              \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &at_mount_root,\n-                            &sub_path };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -86,0 +86,2 @@\n+compiler\/codecache\/CodeCacheFullCountTest.java 8332954 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-                cm.findAttribute(Attributes.CODE).ifPresent(codeAttr -> {\n+                cm.findAttribute(Attributes.code()).ifPresent(codeAttr -> {\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -763,0 +763,5 @@\n+    public static final String LOAD_VECTOR_MASKED = PREFIX + \"LOAD_VECTOR_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR_MASKED, \"LoadVectorMasked\");\n+    }\n+\n@@ -1487,0 +1492,5 @@\n+    public static final String STORE_VECTOR_MASKED = PREFIX + \"STORE_VECTOR_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR_MASKED, \"StoreVectorMasked\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,407 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330386\n+ * @summary Test that replacing Opaque4 nodes with OpaqueInitializedAssertionPredicate for Initialized Assertion Predicates\n+ *          works. We test following cases explicitly:\n+ *          1) Cloning down CmpUNode in Split If with involved OpaqueInitializedAssertionPredicateNodes\n+ *          2) Special casing OpaqueInitializedAssertionPredicate in IdealLoopTree::policy_range_check()\n+ *          3) Special casing Opaque4 node from non-null check for intrinsics and unsafe accesses inside\n+ *             PhaseIdealLoop::update_main_loop_assertion_predicates().\n+ * @requires vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc:+open\n+ * @run main\/othervm -Xbatch -XX:LoopMaxUnroll=0\n+ *                   -XX:CompileCommand=compileonly,*TestOpaqueInitializedAssertionPredicateNode::test*\n+ *                   -XX:CompileCommand=dontinline,*TestOpaqueInitializedAssertionPredicateNode::dontInline\n+ *                   compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ * @run main\/othervm -Xcomp -XX:LoopMaxUnroll=0 -XX:-LoopUnswitching\n+ *                   -XX:CompileCommand=compileonly,*TestOpaqueInitializedAssertionPredicateNode::test*\n+ *                   -XX:CompileCommand=dontinline,*TestOpaqueInitializedAssertionPredicateNode::dontInline\n+ *                   compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ * @run main\/othervm -Xbatch -XX:LoopMaxUnroll=0 -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=compileonly,*TestOpaqueInitializedAssertionPredicateNode::test*\n+ *                   -XX:CompileCommand=dontinline,*TestOpaqueInitializedAssertionPredicateNode::dontInline\n+ *                   compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ *\/\n+\n+\/*\n+ * @test id=noflags\n+ * @bug 8330386\n+ * @modules java.base\/jdk.internal.misc:+open\n+ * @run main compiler.predicates.assertion.TestOpaqueInitializedAssertionPredicateNode\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Field;\n+\n+public class TestOpaqueInitializedAssertionPredicateNode {\n+\n+    static boolean flag, flag2;\n+    static int iFld;\n+    static int x;\n+    static int y = 51;\n+    static int iArrLength;\n+    static int[] iArr = new int[100];\n+\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static final long OFFSET;\n+\n+    static {\n+        try {\n+            Field fieldIFld = A.class.getDeclaredField(\"iFld\");\n+            OFFSET = UNSAFE.objectFieldOffset(fieldIFld);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Integer.compareUnsigned(23, 34); \/\/ Make sure loaded with -Xcomp.\n+        A a = new A(34);\n+        for (int i = 0; i < 10000; i++) {\n+            iArrLength = i % 15 == 0 ? 30 : 100;\n+            flag = i % 3 == 0;\n+            flag2 = i % 5 == 0;\n+            x = (i % 15 == 0 ? 100 : 0);\n+            testCloneDown();\n+            testOnlyCloneDownCmp();\n+            testCloneDownInsideLoop();\n+            maybeNull(null); \/\/ Make sure return value is sometimes null.\n+            testPolicyRangeCheck(a);\n+            testUnsafeAccess(a);\n+            testOpaqueOutsideLoop();\n+            testOpaqueInsideIfOutsideLoop();\n+        }\n+    }\n+\n+    \/\/ Profiling will tell us that the return value is sometimes null and sometimes not.\n+    static A maybeNull(Object o) {\n+        return (A)o;\n+    }\n+\n+    static void testCloneDown() {\n+        int a;\n+        int b;\n+        int[] iArr = new int[iArrLength];\n+\n+        for (int i = 2; i < 4; i *= 2) ; \/\/ Make sure to run with loop opts.\n+\n+        if (flag) {\n+            a = 34;\n+        } else {\n+            a = 3;\n+        }\n+        \/\/ Region to split through\n+\n+        \/\/ --- BLOCK start ---\n+\n+        \/\/ CMoveI(Bool(CmpU(y, iArr.length))), 34, 23)  (**)\n+        if (Integer.compareUnsigned(y, iArr.length) < 0) {\n+            b = 34;\n+        } else {\n+            b = 23;\n+        }\n+        iFld = b; \/\/ iFld = CMoveI -> make sure CMoveI is inside BLOCK\n+\n+        \/\/ --- BLOCK end ---\n+\n+        if (a > 23) { \/\/ If to split -> need to empty BLOCK\n+            iFld = 34;\n+        }\n+\n+        if (flag2) {\n+            \/\/ Avoid out-of-bounds access in loop below\n+            return;\n+        }\n+\n+        \/\/ When peeling the loop, we create an Initialized Assertion Predicate with the same CmpU as (**) above:\n+        \/\/ IAP(CmpU(y, iArr.length))\n+        \/\/\n+        \/\/ At Split If: Need to clone CmpU down because it has two uses:\n+        \/\/ - Bool of Cmove used in \"iFld = b\"\n+        \/\/ - Bool for IAP\n+        \/\/\n+        \/\/ => IAP uses OpaqueInitializedAssertionPredicate -> clone_cmp_down() therefore needs to handle that.\n+        for (int i = y - 1; i < 100; i++) {\n+            iArr[i] = 34; \/\/ Hoisted with Loop Predicate\n+            if (flag) { \/\/ Reason to peel.\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test() but we only clone down the CmpU and not the Bool with the OpaqueInitializedAssertionPredicate\n+    static void testOnlyCloneDownCmp() {\n+        int a;\n+        int b;\n+        int[] iArr = new int[iArrLength];\n+\n+        for (int i = 2; i < 4; i *= 2) ; \/\/ Make sure to run with loop opts.\n+\n+        if (flag) {\n+            a = 34;\n+        } else {\n+            a = 3;\n+        }\n+        \/\/ Region to split through\n+\n+        \/\/ --- BLOCK start ---\n+\n+        \/\/ CMoveI(Bool(CmpU(51, iArr.length))), 34, 23)  (**)\n+        \/\/ Using constant 51 -> cannot common up with Bool from Initialized Assertion Predicate\n+        if (Integer.compareUnsigned(51, iArr.length) < 0) {\n+            b = 34;\n+        } else {\n+            b = 23;\n+        }\n+        iFld = b; \/\/ iFld = CMoveI -> make sure CMoveI is inside BLOCK\n+\n+        \/\/ --- BLOCK end ---\n+\n+        if (a > 23) { \/\/ If to split -> need to empty BLOCK\n+            iFld = 34;\n+        }\n+\n+        if (flag2) {\n+            \/\/ Avoid out-of-bounds access in loop below\n+            return;\n+        }\n+\n+        \/\/ When peeling the loop, we create an Initialized Assertion Predicate with the same CmpU as (**) above:\n+        \/\/ IAP(CmpU(y, iArr.length))\n+        \/\/\n+        \/\/ At Split If: Need to clone CmpU down because it has two uses:\n+        \/\/ - Bool of Cmove used in \"iFld = b\"\n+        \/\/ - Bool for IAP\n+        \/\/\n+        \/\/ => IAP uses OpaqueInitializedAssertionPredicate -> clone_cmp_down() therefore needs to handle that.\n+        for (int i = 50; i < 100; i++) {\n+            iArr[i] = 34; \/\/ Hoisted with Loop Predicate\n+            if (flag) { \/\/ Reason to peel.\n+                return;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test() but everything inside another loop.\n+    static void testCloneDownInsideLoop() {\n+        int a;\n+        int b;\n+        int[] iArr = new int[iArrLength];\n+\n+        for (int i = 3; i < 30; i *= 2) { \/\/ Non-counted loop\n+            if (i < 10) {\n+                a = 34;\n+            } else {\n+                a = 3;\n+            }\n+            \/\/ Region to split through\n+\n+            \/\/ --- BLOCK start ---\n+\n+            \/\/ CMoveI(Bool(CmpU(a + i, iArr.length))), 34, 23)  (**)\n+            if (Integer.compareUnsigned(a + i, iArr.length) < 0) {\n+                b = 34;\n+            } else {\n+                b = 23;\n+            }\n+            iFld = b; \/\/ iFld = CMoveI -> make sure CMoveI is inside BLOCK\n+\n+            \/\/ --- BLOCK end ---\n+\n+            if (a > 23) { \/\/ If to split -> need to empty BLOCK\n+                iFld = 34;\n+            }\n+\n+            if (i < x) {\n+                \/\/ Avoid out-of-bounds access in loop below\n+                return;\n+            }\n+\n+            \/\/ When peeling the loop, we create an Initialized Assertion Predicate with the same CmpU as (**) above:\n+            \/\/ IAP(CmpU(a + i, iArr.length))\n+            \/\/\n+            \/\/ At Split If: Need to clone CmpU down because it has two uses:\n+            \/\/ - Bool of Cmove used in \"iFld = b\"\n+            \/\/ - Bool for IAP\n+            \/\/\n+            \/\/ => IAP uses OpaqueInitializedAssertionPredicate -> clone_cmp_down() therefore needs to handle that.\n+            for (int j = a + i - 1; j < 100; j++) {\n+                iArr[j] = 34; \/\/ Hoisted with Loop Predicate\n+                if (flag) { \/\/ Reason to peel.\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testPolicyRangeCheck(Object o) {\n+        int two = 100;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            two = 2;\n+        }\n+\n+        \/\/ 4) We call IdealLoopTree::policy_range_check() for this loop:\n+        \/\/    - Initialized Assertion Predicate is now part of loop body.\n+        \/\/    - Opaque4 node for null-check is also part of loop body.\n+         \/\/   We also check the If nodes for these Opaque nodes could be eliminated with\n+         \/\/   Range Check Elimination. We thus need to exclude Ifs with\n+         \/\/   Opaque4 and OpaqueInitializedAssertionPredicate nodes in policy_range_check().\n+        for (int i = 0; i < 100; i++) {\n+            A a = maybeNull(o); \/\/ Profiling tells us that return value *might* be null.\n+            iFld = UNSAFE.getInt(a, OFFSET); \/\/ Emits If with Opaque4Node for null check.\n+\n+            \/\/ 1) Apply Loop Predication: Loop Predicate + Template Assertion Predicate\n+            \/\/ 2) Apply Loop Peeling: Create Initialized Assertion Predicate with\n+            \/\/                        OpaqueInitializedAssertionPredicate\n+            \/\/ 3) After CCP: C2 knows that two == 2. CountedLoopEnd found to be true\n+            \/\/               (only execute loop once) -> CountedLoop removed\n+            for (int j = 0; j < two; j++) {\n+                iArr[j] = 34; \/\/ Hoisted in Loop Predication\n+                if (flag) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testUnsafeAccess(Object o) {\n+        A a = maybeNull(o); \/\/ Profiling tells us that return value *might* be null.\n+        iFld = UNSAFE.getInt(a, OFFSET); \/\/ Emits If with Opaque4Node for null check.\n+\n+        \/\/ We don't have any Parse Predicates with -XX:PerMethodTrapLimit=0. And therefore, If with Opaque4 will\n+        \/\/ directly be above CountedLoop. When maximally unrolling the counted loop, we try to update any Assertion\n+        \/\/ Predicate. We will find the If with the Opaque4 node for the non-null check which is not an Assertion\n+        \/\/ Predicate. This needs to be handled separately in PhaseIdealLoop::update_main_loop_assertion_predicates().\n+        for (int i = 0; i < 10; i++) {\n+            iFld *= 34;\n+        }\n+    }\n+\n+    \/\/ [If->OpaqueInitializedAssertionPredicate]->Bool->Cmp, []: Inside Loop, other nodes outside.\n+    static void testOpaqueOutsideLoop() {\n+        int two = 100;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            two = 2;\n+        }\n+\n+        \/\/ 4) After CCP, we can apply Loop Peeling since we removed enough nodes to bring the body size down below 255.\n+        \/\/ When cloning the Bool for the IAP, we have a use inside the loop (initializedAssertionPredicateBool) and one\n+        \/\/ outside for the IAP (input to the OpaqueInitializedAssertionPredicate being outside the loop)\n+        \/\/ As a result, we add the OpaqueInitializedAssertionPredicate to the split if set in clone_loop_handle_data_uses().\n+        for (short i = 3; i < 30; i*=2) { \/\/ Use short such that we do not need overflow protection for Loop Predicates\n+            if (two == 100) {\n+                \/\/ Before CCP: Uninlined method call prevents peeling.\n+                \/\/ After CCP: C2 knows that two == 2 and we remove this call which enables Loop Peeling for i-loop.\n+                dontInline();\n+            }\n+\n+            \/\/ Same condition as used for IAP in j-loop below.\n+            boolean initializedAssertionPredicateBool = Integer.compareUnsigned(1 + i, iArr.length) < 0;\n+\n+            if (flag) {\n+                \/\/ 1) Loop Predicate + Template Assertion Predicate\n+                \/\/ 2) Loop Peeling: Create IAP with same condition as initializedAssertionPredicateBool -> can be shared.\n+                \/\/                  The IAP is on a loop-exit and therefore outside the loop.\n+                \/\/ 3) After CCP: C2 knows that two == 2 and loop is removed.\n+                for (short j = 0; j < two; j++) {\n+                    iArr[i + j] = 34; \/\/ Hoisted in Loop Predication\n+                    if (flag2) {\n+                        break;\n+                    }\n+                }\n+                break;\n+            }\n+\n+            \/\/ Use Bool inside i-loop such that when applying Loop Peeling for i-loop, ctrl of Bool is inside loop and\n+            \/\/ OpaqueInitializedAssertionPredicate of IAP is outside of i-loop.\n+            if (initializedAssertionPredicateBool) {\n+                iFld = 3;\n+            }\n+        }\n+    }\n+\n+    \/\/ Similar to testOpaqueOutside loop but Opaque is now also inside loop.\n+    \/\/ [If]->OpaqueInitializedAssertionPredicate->Bool->Cmp, []: Inside Loop, other nodes outside.\n+    static void testOpaqueInsideIfOutsideLoop() {\n+        int two = 100;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            two = 2;\n+        }\n+\n+        for (short i = 3; i < 30; i*=2) {\n+            if (two == 100) {\n+                \/\/ Before CCP: Uninlined method call prevents peeling.\n+                \/\/ After CCP: C2 knows that two == 2 and we remove this call which enables Loop Peeling for i-loop.\n+                dontInline();\n+            }\n+\n+            \/\/ 1) Loop Predicate + Template Assertion Predicate\n+            \/\/ 2) Loop Peeling: Create IAP with same condition as initializedAssertionPredicateBool -> can be shared.\n+            \/\/                  The IAP is on a loop-exit and therefore outside the loop.\n+            \/\/ 3) After CCP: C2 knows that two == 2 and loop is removed.\n+            for (short j = 0; j < two; j++) {\n+                iArr[i + j] = 34; \/\/ Hoisted in Loop Predication\n+                if (flag2) {\n+                    break;\n+                }\n+            }\n+\n+            if (flag) {\n+                \/\/ Same loop as above. We create the same IAP which can share the same OpaqueInitializedAssertionPredicate.\n+                \/\/ Therefore, the OpaqueInitializedAssertionPredicate is inside the loop while this If is outside the loop.\n+                \/\/ At Loop Peeling, we clone the Opaque node and create a Phi to merge both loop versions into the IAP If. In\n+                \/\/ clone_loop_handle_data_uses(), we add the If for the IAP to the split if set in (). Later, we\n+                \/\/ process its input phi with their OpaqueInitializedAssertionPredicate inputs.\n+                for (short j = 0; j < two; j++) {\n+                    iArr[i + j] = 34; \/\/ Hoisted in Loop Predication\n+                    if (flag2) {\n+                        break;\n+                    }\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ Not inlined\n+    static void dontInline() {}\n+\n+    static class A {\n+        int iFld;\n+        A(int i) {\n+            this.iFld = i;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestOpaqueInitializedAssertionPredicateNode.java","additions":407,"deletions":0,"binary":false,"changes":407,"status":"added"},{"patch":"@@ -1,474 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8324517\n- * @summary C2: out of bound array load because of dependency on removed range check CastIIs\n- *\n- * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n- *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n- *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n- * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n- *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n- * @run main\/othervm TestArrayAccessAboveRCAfterRCCastIIEliminated\n- * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n- *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n- *\n- *\/\n-\n-public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n-    private static int intField;\n-    private static long longField;\n-    private static volatile int volatileField;\n-\n-    public static void main(String[] args) {\n-        int[] array = new int[100];\n-        for (int i = 0; i < 20_000; i++) {\n-            test1(9, 10, 1, true);\n-            test1(9, 10, 1, false);\n-            test2(9, 10, 1, true);\n-            test2(9, 10, 1, false);\n-            test3(9, 10, 1, true);\n-            test3(9, 10, 1, false);\n-            test4(9, 10, 1, true);\n-            test4(9, 10, 1, false);\n-            test5(9, 10, 1, true);\n-            test5(9, 10, 1, false);\n-            test6(9, 10, 1, true);\n-            test6(9, 10, 1, false);\n-            test7(9, 10, 1, true);\n-            test7(9, 10, 1, false);\n-            test8(9, 10, 1, true);\n-            test8(9, 10, 1, false);\n-            test9(9, 10, 1, true);\n-            test9(9, 10, 1, false);\n-            test10(9, 10, 1, true);\n-            test10(9, 10, 1, false);\n-            test11(9, 10, 1, true);\n-            test11(9, 10, 1, false);\n-            test12(9, 10, 1, true);\n-            test12(9, 10, 1, false);\n-            test13(9, 10, 1, true);\n-            test13(9, 10, 1, false);\n-        }\n-        try {\n-            test1(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test2(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test3(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test4(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test5(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test6(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test7(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test8(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test9(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test10(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test11(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test12(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-        try {\n-            test13(-1, 10, 1, true);\n-        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n-        }\n-    }\n-\n-    private static void test1(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = array[otherArray.length];\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = array[otherArray.length];\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test2(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test3(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test4(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test5(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test6(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test7(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-    private static void test8(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test9(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test10(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test11(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test12(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n-                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n-                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void test13(int i, int j, int flag, boolean flag2) {\n-        i = Math.min(i, 9);\n-        int[] array = new int[10];\n-        notInlined(array);\n-        if (flag == 0) {\n-        }\n-        if (flag2) {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n-                    Long.divideUnsigned(1L, (otherArray.length + 1));\n-        } else {\n-            float[] newArray = new float[j];\n-            newArray[i] = 42;\n-            float[] otherArray = new float[i];\n-            if (flag == 0) {\n-            }\n-            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n-                    Long.divideUnsigned(1L, (otherArray.length + 1));\n-        }\n-        for (int k = 0; k < 10; k++) {\n-\n-        }\n-    }\n-\n-    private static void notInlined(int[] array) {\n-\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":0,"deletions":474,"binary":false,"changes":474,"status":"deleted"},{"patch":"@@ -0,0 +1,1404 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.incubator.vector.*;\n+import java.util.Arrays;\n+import java.nio.ByteOrder;\n+\n+\/**\n+ * @test\n+ * @bug 8325520\n+ * @library \/test\/lib \/\n+ * @summary Don't allow folding of Load\/Store vectors when using incompatible indices or masks\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorGatherMaskFoldingTest\n+ *\/\n+\n+public class VectorGatherMaskFoldingTest {\n+    \/\/ Species\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    private static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+    \/\/ Vectors\n+    private static final LongVector longVector;\n+    private static final LongVector longVector2;\n+    private static final IntVector intVector;\n+    private static final IntVector intVector2;\n+    private static final DoubleVector doubleVector;\n+    private static final DoubleVector doubleVector2;\n+    private static final FloatVector floatVector;\n+    private static final FloatVector floatVector2;\n+    \/\/ Arrays\n+    private static final long[] longArray = new long[L_SPECIES.length()];\n+    private static final long[] longArray2 = new long[L_SPECIES.length()];\n+    private static final int[] intArray = new int[I_SPECIES.length()];\n+    private static final int[] intArray2 = new int[I_SPECIES.length()];\n+    private static final double[] doubleArray = new double[D_SPECIES.length()];\n+    private static final double[] doubleArray2 = new double[D_SPECIES.length()];\n+    private static final float[] floatArray = new float[F_SPECIES.length()];\n+    private static final float[] floatArray2 = new float[F_SPECIES.length()];\n+    \/\/ Indices\n+    private static final int[] longIndices = new int[L_SPECIES.length()];\n+    private static final int[] longIndices2 = new int[L_SPECIES.length()];\n+    private static final int[] duplicateLongIndices = new int[L_SPECIES.length()];\n+    private static final int[] intIndices = new int[I_SPECIES.length()];\n+    private static final int[] intIndices2 = new int[I_SPECIES.length()];\n+    private static final int[] duplicateIntIndices = new int[I_SPECIES.length()];\n+    private static final int[] doubleIndices = new int[D_SPECIES.length()];\n+    private static final int[] doubleIndices2 = new int[D_SPECIES.length()];\n+    private static final int[] duplicateDoubleIndices = new int[D_SPECIES.length()];\n+    private static final int[] floatIndices = new int[F_SPECIES.length()];\n+    private static final int[] floatIndices2 = new int[F_SPECIES.length()];\n+    private static final int[] duplicateFloatIndices = new int[F_SPECIES.length()];\n+    \/\/ Masks\n+    private static final boolean[] longMask = new boolean[L_SPECIES.length()];\n+    private static final boolean[] longMask2 = new boolean[L_SPECIES.length()];\n+    private static final boolean[] intMask = new boolean[I_SPECIES.length()];\n+    private static final boolean[] intMask2 = new boolean[I_SPECIES.length()];\n+    private static final boolean[] doubleMask = new boolean[D_SPECIES.length()];\n+    private static final boolean[] doubleMask2 = new boolean[D_SPECIES.length()];\n+    private static final boolean[] floatMask = new boolean[F_SPECIES.length()];\n+    private static final boolean[] floatMask2 = new boolean[F_SPECIES.length()];\n+    private static final VectorMask<Long> longVectorMask;\n+    private static final VectorMask<Long> longVectorMask2;\n+    private static final VectorMask<Integer> intVectorMask;\n+    private static final VectorMask<Integer> intVectorMask2;\n+    private static final VectorMask<Double> doubleVectorMask;\n+    private static final VectorMask<Double> doubleVectorMask2;\n+    private static final VectorMask<Float> floatVectorMask;\n+    private static final VectorMask<Float> floatVectorMask2;\n+\n+    \/\/ Filling vectors\/indices\/masks\n+    static {\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            longArray[i] = i + 1;\n+            longArray2[i] = L_SPECIES.length() - i + 1;\n+            longMask[i] = i % 2 == 0;\n+            longMask2[i] = i >= L_SPECIES.length() \/ 2;\n+            longIndices[i] = (i + L_SPECIES.length() \/ 2) % L_SPECIES.length();\n+            longIndices2[i] = (L_SPECIES.length() - i) % L_SPECIES.length();\n+            duplicateLongIndices[i] = longIndices[i] \/ 2;\n+        }\n+        longVector = LongVector.fromArray(L_SPECIES, longArray, 0);\n+        longVector2 = LongVector.fromArray(L_SPECIES, longArray2, 0);\n+        longVectorMask = VectorMask.fromArray(L_SPECIES, longMask, 0);\n+        longVectorMask2 = VectorMask.fromArray(L_SPECIES, longMask2, 0);\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            intArray[i] = i + 1;\n+            intArray2[i] = I_SPECIES.length() - i + 1;\n+            intMask[i] = i % 2 == 0;\n+            intMask2[i] = i >= I_SPECIES.length() \/ 2;\n+            intIndices[i] = (i + I_SPECIES.length() \/ 2) % I_SPECIES.length();\n+            intIndices2[i] = (I_SPECIES.length() - i) % I_SPECIES.length();\n+            duplicateIntIndices[i] = intIndices[i] \/ 2;\n+        }\n+        intVector = IntVector.fromArray(I_SPECIES, intArray, 0);\n+        intVector2 = IntVector.fromArray(I_SPECIES, intArray2, 0);\n+        intVectorMask = VectorMask.fromArray(I_SPECIES, intMask, 0);\n+        intVectorMask2 = VectorMask.fromArray(I_SPECIES, intMask2, 0);\n+        for (int i = 0; i < D_SPECIES.length(); i++) {\n+            doubleArray[i] = (double) i + 1.0;\n+            doubleArray2[i] = (double) (D_SPECIES.length() - i) + 1.0;\n+            doubleMask[i] = i % 2 == 0;\n+            doubleMask2[i] = i >= D_SPECIES.length() \/ 2;\n+            doubleIndices[i] = (i + D_SPECIES.length() \/ 2) % D_SPECIES.length();\n+            doubleIndices2[i] = (D_SPECIES.length() - i) % D_SPECIES.length();\n+            duplicateDoubleIndices[i] = doubleIndices[i] \/ 2;\n+        }\n+        doubleVector = DoubleVector.fromArray(D_SPECIES, doubleArray, 0);\n+        doubleVector2 = DoubleVector.fromArray(D_SPECIES, doubleArray2, 0);\n+        doubleVectorMask = VectorMask.fromArray(D_SPECIES, doubleMask, 0);\n+        doubleVectorMask2 = VectorMask.fromArray(D_SPECIES, doubleMask2, 0);\n+        for (int i = 0; i < F_SPECIES.length(); i++) {\n+            floatArray[i] = i + 1.0f;\n+            floatArray2[i] = F_SPECIES.length() - i + 1.0f;\n+            floatMask[i] = i % 2 == 0;\n+            floatMask2[i] = i >= F_SPECIES.length() \/ 2;\n+            floatIndices[i] = (i + F_SPECIES.length() \/ 2) % F_SPECIES.length();\n+            floatIndices2[i] = (F_SPECIES.length() - i) % F_SPECIES.length();\n+            duplicateFloatIndices[i] = floatIndices[i] \/ 2;\n+        }\n+        floatVector = FloatVector.fromArray(F_SPECIES, floatArray, 0);\n+        floatVector2 = FloatVector.fromArray(F_SPECIES, floatArray2, 0);\n+        floatVectorMask = VectorMask.fromArray(F_SPECIES, floatMask, 0);\n+        floatVectorMask2 = VectorMask.fromArray(F_SPECIES, floatMask2, 0);\n+    }\n+\n+    \/\/ LOAD TESTS\n+\n+    \/\/ LongVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadGatherNotEqualArray() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray2, 0, longIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadGatherNotEqualIndices() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices2, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorLoadGather() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorLoadMasked() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadGatherEquals() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadMaskedEquals() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longVectorMask);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadMaskedNotEqualMask() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longVectorMask);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadGatherMaskedEquals() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0, longVectorMask);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0, longVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadGatherMaskedNotEqualMask() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0, longVectorMask);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0, longVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorLoadGatherMaskedNotEqualIndices() {\n+        LongVector res = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0, longVectorMask);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices2, 0, longVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+\n+    \/\/ IntVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadGatherNotEqualArray() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray2, 0, intIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadGatherNotEqualIndices() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices2, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorLoadGather() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorLoadMasked() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadGatherEquals() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadMaskedEquals() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intVectorMask);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadMaskedNotEqualMask() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intVectorMask);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadGatherMaskedEquals() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0, intVectorMask);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0, intVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadGatherMaskedNotEqualMask() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0, intVectorMask);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0, intVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorLoadGatherMaskedNotEqualIndices() {\n+        IntVector res = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0, intVectorMask);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices2, 0, intVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+\n+    \/\/ DoubleVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadGatherNotEqualArray() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray2, 0, doubleIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadGatherNotEqualIndices() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices2, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_D, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorLoadGather() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_D, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorLoadMasked() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadGatherEquals() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadMaskedEquals() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleVectorMask);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadMaskedNotEqualMask() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleVectorMask);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadGatherMaskedEquals() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0, doubleVectorMask);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0, doubleVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadGatherMaskedNotEqualMask() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0, doubleVectorMask);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0, doubleVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorLoadGatherMaskedNotEqualIndices() {\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0, doubleVectorMask);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices2, 0, doubleVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+\n+    \/\/ FloatVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadGatherNotEqualArray() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray2, 0, floatIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadGatherNotEqualIndices() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices2, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_F, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorLoadGather() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_F, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorLoadMasked() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadGatherEquals() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadMaskedEquals() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatVectorMask);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadMaskedNotEqualMask() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatVectorMask);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadGatherMaskedEquals() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0, floatVectorMask);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0, floatVectorMask);\n+        Asserts.assertEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadGatherMaskedNotEqualMask() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0, floatVectorMask);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0, floatVectorMask2);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorLoadGatherMaskedNotEqualIndices() {\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0, floatVectorMask);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices2, 0, floatVectorMask);\n+        Asserts.assertNotEquals(res, res2);\n+    }\n+\n+\n+    \/\/ STORE TESTS\n+\n+    \/\/ LongVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreScatterNotEqualVector() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longIndices, 0);\n+        longVector2.intoArray(res2, 0, longIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreScatterNotEqualIndices() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longIndices, 0);\n+        longVector.intoArray(res2, 0, longIndices2, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorStoreScatter() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0);\n+        longVector.intoArray(res2, 0, longIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorStoreMasked() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0);\n+        longVector.intoArray(res2, 0, longVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreScatterEquals() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longIndices, 0);\n+        longVector.intoArray(res2, 0, longIndices, 0);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreMaskedEquals() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longVectorMask);\n+        longVector.intoArray(res2, 0, longVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreMaskedNotEqualMask() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longVectorMask);\n+        longVector.intoArray(res2, 0, longVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreScatterMaskedEquals() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longIndices, 0, longVectorMask);\n+        longVector.intoArray(res2, 0, longIndices, 0, longVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreScatterMaskedNotEqualMask() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longIndices, 0, longVectorMask);\n+        longVector.intoArray(res2, 0, longIndices, 0, longVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoLongVectorStoreScatterMaskedNotEqualIndices() {\n+        long[] res = new long[L_SPECIES.length()];\n+        long[] res2 = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longIndices, 0, longVectorMask);\n+        longVector.intoArray(res2, 0, longIndices2, 0, longVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+\n+    \/\/ IntVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreScatterNotEqualVector() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intIndices, 0);\n+        intVector2.intoArray(res2, 0, intIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreScatterNotEqualIndices() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intIndices, 0);\n+        intVector.intoArray(res2, 0, intIndices2, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorStoreScatter() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0);\n+        intVector.intoArray(res2, 0, intIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorStoreMasked() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0);\n+        intVector.intoArray(res2, 0, intVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreScatterEquals() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intIndices, 0);\n+        intVector.intoArray(res2, 0, intIndices, 0);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreMaskedEquals() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intVectorMask);\n+        intVector.intoArray(res2, 0, intVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreMaskedNotEqualMask() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intVectorMask);\n+        intVector.intoArray(res2, 0, intVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreScatterMaskedEquals() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intIndices, 0, intVectorMask);\n+        intVector.intoArray(res2, 0, intIndices, 0, intVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreScatterMaskedNotEqualMask() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intIndices, 0, intVectorMask);\n+        intVector.intoArray(res2, 0, intIndices, 0, intVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoIntVectorStoreScatterMaskedNotEqualIndices() {\n+        int[] res = new int[I_SPECIES.length()];\n+        int[] res2 = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intIndices, 0, intVectorMask);\n+        intVector.intoArray(res2, 0, intIndices2, 0, intVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+\n+    \/\/ DoubleVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreScatterNotEqualVector() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleIndices, 0);\n+        doubleVector2.intoArray(res2, 0, doubleIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreScatterNotEqualIndices() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleIndices, 0);\n+        doubleVector.intoArray(res2, 0, doubleIndices2, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorStoreScatter() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0);\n+        doubleVector.intoArray(res2, 0, doubleIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorStoreMasked() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0);\n+        doubleVector.intoArray(res2, 0, doubleVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreScatterEquals() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleIndices, 0);\n+        doubleVector.intoArray(res2, 0, doubleIndices, 0);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreMaskedEquals() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleVectorMask);\n+        doubleVector.intoArray(res2, 0, doubleVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreMaskedNotEqualMask() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleVectorMask);\n+        doubleVector.intoArray(res2, 0, doubleVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreScatterMaskedEquals() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleIndices, 0, doubleVectorMask);\n+        doubleVector.intoArray(res2, 0, doubleIndices, 0, doubleVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreScatterMaskedNotEqualMask() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleIndices, 0, doubleVectorMask);\n+        doubleVector.intoArray(res2, 0, doubleIndices, 0, doubleVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoDoubleVectorStoreScatterMaskedNotEqualIndices() {\n+        double[] res = new double[D_SPECIES.length()];\n+        double[] res2 = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleIndices, 0, doubleVectorMask);\n+        doubleVector.intoArray(res2, 0, doubleIndices2, 0, doubleVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+\n+    \/\/ FloatVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreScatterNotEqualVector() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatIndices, 0);\n+        floatVector2.intoArray(res2, 0, floatIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreScatterNotEqualIndices() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatIndices, 0);\n+        floatVector.intoArray(res2, 0, floatIndices2, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorStoreScatter() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0);\n+        floatVector.intoArray(res2, 0, floatIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorStoreMasked() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0);\n+        floatVector.intoArray(res2, 0, floatVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreScatterEquals() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatIndices, 0);\n+        floatVector.intoArray(res2, 0, floatIndices, 0);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreMaskedEquals() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatVectorMask);\n+        floatVector.intoArray(res2, 0, floatVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreMaskedNotEqualMask() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatVectorMask);\n+        floatVector.intoArray(res2, 0, floatVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreScatterMaskedEquals() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatIndices, 0, floatVectorMask);\n+        floatVector.intoArray(res2, 0, floatIndices, 0, floatVectorMask);\n+        Asserts.assertTrue(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreScatterMaskedNotEqualMask() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatIndices, 0, floatVectorMask);\n+        floatVector.intoArray(res2, 0, floatIndices, 0, floatVectorMask2);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 2\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testTwoFloatVectorStoreScatterMaskedNotEqualIndices() {\n+        float[] res = new float[F_SPECIES.length()];\n+        float[] res2 = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatIndices, 0, floatVectorMask);\n+        floatVector.intoArray(res2, 0, floatIndices2, 0, floatVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, res2));\n+    }\n+\n+\n+    \/\/ STORE - LOAD tests\n+\n+    \/\/ LongVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorStoreLoadGather() {\n+        long[] array = new long[L_SPECIES.length()];\n+        longVector.intoArray(array, 0);\n+        LongVector res = LongVector.fromArray(L_SPECIES, array, 0, longIndices, 0);\n+        Asserts.assertNotEquals(res, longVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_L, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorStoreScatterLoad() {\n+        long[] array = new long[L_SPECIES.length()];\n+        longVector.intoArray(array, 0, longIndices, 0);\n+        LongVector res = LongVector.fromArray(L_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, longVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorStoreLoadMasked() {\n+        long[] array = new long[L_SPECIES.length()];\n+        longVector.intoArray(array, 0);\n+        LongVector res = LongVector.fromArray(L_SPECIES, array, 0, longVectorMask);\n+        Asserts.assertNotEquals(res, longVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_L, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorStoreMaskedLoad() {\n+        long[] array = new long[L_SPECIES.length()];\n+        longVector.intoArray(array, 0, longVectorMask);\n+        LongVector res = LongVector.fromArray(L_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, longVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testLongVectorLoadGatherStoreScatterDuplicateIndicesVector() {\n+        long[] res = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, duplicateLongIndices, 0);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, res, 0, duplicateLongIndices, 0);\n+        Asserts.assertNotEquals(res2, longVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testLongVectorStoreLoadMaskedVector() {\n+        long[] res = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0, longVectorMask);\n+        LongVector res2 = LongVector.fromArray(L_SPECIES, res, 0, longVectorMask);\n+        Asserts.assertNotEquals(res2, longVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_L, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testStoreLoadLongVectorDifferentSpeciesVector() {\n+        long[] res = new long[L_SPECIES.length()];\n+        longVector.intoArray(res, 0);\n+        LongVector res2 = LongVector.fromArray(LongVector.SPECIES_64, res, 0);\n+        Asserts.assertNotEquals(res2, longVector);\n+    }\n+\n+\n+    \/\/ IntVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorStoreLoadGather() {\n+        int[] array = new int[I_SPECIES.length()];\n+        intVector.intoArray(array, 0);\n+        IntVector res = IntVector.fromArray(I_SPECIES, array, 0, intIndices, 0);\n+        Asserts.assertNotEquals(res, intVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_I, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorStoreScatterLoad() {\n+        int[] array = new int[I_SPECIES.length()];\n+        intVector.intoArray(array, 0, intIndices, 0);\n+        IntVector res = IntVector.fromArray(I_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, intVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorStoreLoadMasked() {\n+        int[] array = new int[I_SPECIES.length()];\n+        intVector.intoArray(array, 0);\n+        IntVector res = IntVector.fromArray(I_SPECIES, array, 0, intVectorMask);\n+        Asserts.assertNotEquals(res, intVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_I, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorStoreMaskedLoad() {\n+        int[] array = new int[I_SPECIES.length()];\n+        intVector.intoArray(array, 0, intVectorMask);\n+        IntVector res = IntVector.fromArray(I_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, intVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testIntVectorLoadGatherStoreScatterDuplicateIndicesVector() {\n+        int[] res = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, duplicateIntIndices, 0);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, res, 0, duplicateIntIndices, 0);\n+        Asserts.assertNotEquals(res2, intVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testIntVectorStoreLoadMaskedVector() {\n+        int[] res = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0, intVectorMask);\n+        IntVector res2 = IntVector.fromArray(I_SPECIES, res, 0, intVectorMask);\n+        Asserts.assertNotEquals(res2, intVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_I, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testStoreLoadIntVectorDifferentSpeciesVector() {\n+        int[] res = new int[I_SPECIES.length()];\n+        intVector.intoArray(res, 0);\n+        IntVector res2 = IntVector.fromArray(IntVector.SPECIES_64, res, 0);\n+        Asserts.assertNotEquals(res2, intVector);\n+    }\n+\n+\n+    \/\/ DoubleVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorStoreLoadGather() {\n+        double[] array = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(array, 0);\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, array, 0, doubleIndices, 0);\n+        Asserts.assertNotEquals(res, doubleVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_D, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorStoreScatterLoad() {\n+        double[] array = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(array, 0, doubleIndices, 0);\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, doubleVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorStoreLoadMasked() {\n+        double[] array = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(array, 0);\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, array, 0, doubleVectorMask);\n+        Asserts.assertNotEquals(res, doubleVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_D, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorStoreMaskedLoad() {\n+        double[] array = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(array, 0, doubleVectorMask);\n+        DoubleVector res = DoubleVector.fromArray(D_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, doubleVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testDoubleVectorLoadGatherStoreScatterDuplicateIndicesVector() {\n+        double[] res = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, duplicateDoubleIndices, 0);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, res, 0, duplicateDoubleIndices, 0);\n+        Asserts.assertNotEquals(res2, doubleVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testDoubleVectorStoreLoadMaskedVector() {\n+        double[] res = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0, doubleVectorMask);\n+        DoubleVector res2 = DoubleVector.fromArray(D_SPECIES, res, 0, doubleVectorMask);\n+        Asserts.assertNotEquals(res2, doubleVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_D, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testStoreLoadDoubleVectorDifferentSpeciesVector() {\n+        double[] res = new double[D_SPECIES.length()];\n+        doubleVector.intoArray(res, 0);\n+        DoubleVector res2 = DoubleVector.fromArray(DoubleVector.SPECIES_64, res, 0);\n+        Asserts.assertNotEquals(res2, doubleVector);\n+    }\n+\n+\n+    \/\/ FloatVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorStoreLoadGather() {\n+        float[] array = new float[F_SPECIES.length()];\n+        floatVector.intoArray(array, 0);\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, array, 0, floatIndices, 0);\n+        Asserts.assertNotEquals(res, floatVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_F, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorStoreScatterLoad() {\n+        float[] array = new float[F_SPECIES.length()];\n+        floatVector.intoArray(array, 0, floatIndices, 0);\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, floatVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorStoreLoadMasked() {\n+        float[] array = new float[F_SPECIES.length()];\n+        floatVector.intoArray(array, 0);\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, array, 0, floatVectorMask);\n+        Asserts.assertNotEquals(res, floatVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_F, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorStoreMaskedLoad() {\n+        float[] array = new float[F_SPECIES.length()];\n+        floatVector.intoArray(array, 0, floatVectorMask);\n+        FloatVector res = FloatVector.fromArray(F_SPECIES, array, 0);\n+        Asserts.assertNotEquals(res, floatVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testFloatVectorLoadGatherStoreScatterDuplicateIndicesVector() {\n+        float[] res = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, duplicateFloatIndices, 0);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, res, 0, duplicateFloatIndices, 0);\n+        Asserts.assertNotEquals(res2, floatVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testFloatVectorStoreLoadMaskedVector() {\n+        float[] res = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0, floatVectorMask);\n+        FloatVector res2 = FloatVector.fromArray(F_SPECIES, res, 0, floatVectorMask);\n+        Asserts.assertNotEquals(res2, floatVector);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_F, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testStoreLoadFloatVectorDifferentSpeciesVector() {\n+        float[] res = new float[F_SPECIES.length()];\n+        floatVector.intoArray(res, 0);\n+        FloatVector res2 = FloatVector.fromArray(FloatVector.SPECIES_64, res, 0);\n+        Asserts.assertNotEquals(res2, floatVector);\n+    }\n+\n+\n+    \/\/ LOAD - STORE tests\n+\n+    \/\/ LongVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorLoadGatherStore() {\n+        long[] res = new long[L_SPECIES.length()];\n+        LongVector vector = LongVector.fromArray(L_SPECIES, longArray, 0, longIndices, 0);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, longArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_L, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorLoadStoreScatter() {\n+        long[] res = new long[L_SPECIES.length()];\n+        LongVector vector = LongVector.fromArray(L_SPECIES, longArray, 0);\n+        vector.intoArray(res, 0, longIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, longArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorLoadMaskedStore() {\n+        long[] res = new long[L_SPECIES.length()];\n+        LongVector vector = LongVector.fromArray(L_SPECIES, longArray, 0, longVectorMask);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, longArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_L, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneLongVectorLoadStoreMasked() {\n+        long[] res = new long[L_SPECIES.length()];\n+        LongVector vector = LongVector.fromArray(L_SPECIES, longArray, 0);\n+        vector.intoArray(res, 0, longVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, longArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testLongVectorStoreScatterLoadGatherDuplicateIndicesVector() {\n+        long[] res = new long[L_SPECIES.length()];\n+        LongVector vector = LongVector.fromArray(L_SPECIES, longArray, 0, duplicateLongIndices, 0);\n+        vector.intoArray(res, 0, duplicateLongIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, longArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testLongVectorLoadMaskedStoreVector() {\n+        long[] res = new long[L_SPECIES.length()];\n+        LongVector vector = LongVector.fromArray(L_SPECIES, longArray, 0, longVectorMask);\n+        vector.intoArray(res, 0, longVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, longArray));\n+    }\n+\n+\n+    \/\/ IntVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorLoadGatherStore() {\n+        int[] res = new int[I_SPECIES.length()];\n+        IntVector vector = IntVector.fromArray(I_SPECIES, intArray, 0, intIndices, 0);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, intArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_I, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorLoadStoreScatter() {\n+        int[] res = new int[I_SPECIES.length()];\n+        IntVector vector = IntVector.fromArray(I_SPECIES, intArray, 0);\n+        vector.intoArray(res, 0, intIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, intArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorLoadMaskedStore() {\n+        int[] res = new int[I_SPECIES.length()];\n+        IntVector vector = IntVector.fromArray(I_SPECIES, intArray, 0, intVectorMask);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, intArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_I, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneIntVectorLoadStoreMasked() {\n+        int[] res = new int[I_SPECIES.length()];\n+        IntVector vector = IntVector.fromArray(I_SPECIES, intArray, 0);\n+        vector.intoArray(res, 0, intVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, intArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testIntVectorStoreScatterLoadGatherDuplicateIndicesVector() {\n+        int[] res = new int[I_SPECIES.length()];\n+        IntVector vector = IntVector.fromArray(I_SPECIES, intArray, 0, duplicateIntIndices, 0);\n+        vector.intoArray(res, 0, duplicateIntIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, intArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testIntVectorLoadMaskedStoreVector() {\n+        int[] res = new int[I_SPECIES.length()];\n+        IntVector vector = IntVector.fromArray(I_SPECIES, intArray, 0, intVectorMask);\n+        vector.intoArray(res, 0, intVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, intArray));\n+    }\n+\n+\n+    \/\/ DoubleVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorLoadGatherStore() {\n+        double[] res = new double[D_SPECIES.length()];\n+        DoubleVector vector = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleIndices, 0);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, doubleArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_D, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorLoadStoreScatter() {\n+        double[] res = new double[D_SPECIES.length()];\n+        DoubleVector vector = DoubleVector.fromArray(D_SPECIES, doubleArray, 0);\n+        vector.intoArray(res, 0, doubleIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, doubleArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorLoadMaskedStore() {\n+        double[] res = new double[D_SPECIES.length()];\n+        DoubleVector vector = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleVectorMask);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, doubleArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_D, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneDoubleVectorLoadStoreMasked() {\n+        double[] res = new double[D_SPECIES.length()];\n+        DoubleVector vector = DoubleVector.fromArray(D_SPECIES, doubleArray, 0);\n+        vector.intoArray(res, 0, doubleVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, doubleArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testDoubleVectorStoreScatterLoadGatherDuplicateIndicesVector() {\n+        double[] res = new double[D_SPECIES.length()];\n+        DoubleVector vector = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, duplicateDoubleIndices, 0);\n+        vector.intoArray(res, 0, duplicateDoubleIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, doubleArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testDoubleVectorLoadMaskedStoreVector() {\n+        double[] res = new double[D_SPECIES.length()];\n+        DoubleVector vector = DoubleVector.fromArray(D_SPECIES, doubleArray, 0, doubleVectorMask);\n+        vector.intoArray(res, 0, doubleVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, doubleArray));\n+    }\n+\n+\n+    \/\/ FloatVector tests\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorLoadGatherStore() {\n+        float[] res = new float[F_SPECIES.length()];\n+        FloatVector vector = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatIndices, 0);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, floatArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_F, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorLoadStoreScatter() {\n+        float[] res = new float[F_SPECIES.length()];\n+        FloatVector vector = FloatVector.fromArray(F_SPECIES, floatArray, 0);\n+        vector.intoArray(res, 0, floatIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, floatArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorLoadMaskedStore() {\n+        float[] res = new float[F_SPECIES.length()];\n+        FloatVector vector = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatVectorMask);\n+        vector.intoArray(res, 0);\n+        Asserts.assertFalse(Arrays.equals(res, floatArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_F, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testOneFloatVectorLoadStoreMasked() {\n+        float[] res = new float[F_SPECIES.length()];\n+        FloatVector vector = FloatVector.fromArray(F_SPECIES, floatArray, 0);\n+        vector.intoArray(res, 0, floatVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, floatArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\", IRNode.LOAD_VECTOR_GATHER, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testFloatVectorStoreScatterLoadGatherDuplicateIndicesVector() {\n+        float[] res = new float[F_SPECIES.length()];\n+        FloatVector vector = FloatVector.fromArray(F_SPECIES, floatArray, 0, duplicateFloatIndices, 0);\n+        vector.intoArray(res, 0, duplicateFloatIndices, 0);\n+        Asserts.assertFalse(Arrays.equals(res, floatArray));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR_MASKED, \">= 1\", IRNode.LOAD_VECTOR_MASKED, \">= 1\" }, applyIfCPUFeatureOr = {\"avx512\", \"true\", \"sve\", \"true\"})\n+    public static void testFloatVectorLoadMaskedStoreVector() {\n+        float[] res = new float[F_SPECIES.length()];\n+        FloatVector vector = FloatVector.fromArray(F_SPECIES, floatArray, 0, floatVectorMask);\n+        vector.intoArray(res, 0, floatVectorMask);\n+        Asserts.assertFalse(Arrays.equals(res, floatArray));\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:+IncrementalInlineForceCleanup\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherMaskFoldingTest.java","additions":1404,"deletions":0,"binary":false,"changes":1404,"status":"added"},{"patch":"@@ -78,0 +78,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n@@ -91,0 +94,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -203,2 +203,2 @@\n-            .shouldMatch(\"Memory and Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n-            .shouldNotMatch(\"Memory and Swap Limit is:.*\" + neg2InUnsignedLong);\n+            .shouldMatch(\"(Memory and )?Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n+            .shouldNotMatch(\"(Memory and )?Swap Limit is:.*\" + neg2InUnsignedLong);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *              not enough space in the heapRegion to fit a filler object.\n+ *              not enough space in the G1HeapRegion to fit a filler object.\n@@ -65,1 +65,1 @@\n-                \/\/ 131069 is the number of longs it takes to fill a heapRegion except\n+                \/\/ 131069 is the number of longs it takes to fill a G1HeapRegion except\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousAllocNearlyFullRegion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-    \/\/    Each 'int' represents a numa id of single HeapRegion (bottom page).\n+    \/\/    Each 'int' represents a numa id of single G1HeapRegion (bottom page).\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/numa\/TestG1NUMATouchRegions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-     * @throws IOException if cannot write file to specified directory\n+     * @throws Exception if cannot write file to specified directory\n","filename":"test\/hotspot\/jtreg\/gc\/testlibrary\/Helpers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332122\n+ * @summary Test to verify correctness of peak malloc tracking\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary -Xms32m -Xmx32m -Xint PeakMallocTest\n+ *\n+ *\/\n+\n+\/\/ Note we run the test with -Xint to keep compilers from running and reduce malloc noise.\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class PeakMallocTest {\n+\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final double FUDGE_FACTOR = 0.2;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Measure early malloc total and peak\n+        OutputAnalyzer output = NMTTestUtils.startJcmdVMNativeMemory(\"scale=1\");\n+        long earlyTotal = getMallocTotal(output);\n+        long earlyPeak = getMallocPeak(output);\n+        System.out.println(\"Early malloc total: \" + earlyTotal);\n+        System.out.println(\"Early malloc peak: \" + earlyPeak);\n+\n+        \/\/ Allocate a large amount of memory and then free\n+        long allocSize = Math.max(8 * earlyPeak, 250 * 1024 * 1024); \/\/ MAX(earlyPeak * 8, 250MB)\n+        long addr = wb.NMTMalloc(allocSize);\n+        System.out.println(\"Allocation size: \" + allocSize);\n+        wb.NMTFree(addr);\n+\n+        \/\/ Measure again\n+        output = NMTTestUtils.startJcmdVMNativeMemory(\"scale=1\");\n+        long currTotal = getMallocTotal(output);\n+        long currPeak = getMallocPeak(output);\n+        System.out.println(\"Current malloc total: \" + currTotal);\n+        System.out.println(\"Current malloc peak: \" + currPeak);\n+\n+        \/\/ Verify total global malloc is similar with a fudge factor\n+        double mallocLowerBound = earlyTotal * (1 - FUDGE_FACTOR);\n+        double mallocUpperBound = earlyTotal * (1 + FUDGE_FACTOR);\n+        if (currTotal < mallocLowerBound || currTotal > mallocUpperBound) {\n+            throw new Exception(\"Global malloc measurement is incorrect. \" +\n+                    \"Expected range: [\" + mallocLowerBound + \" - \" + mallocUpperBound + \"]. \" +\n+                    \"Actual malloc total: \" + currTotal);\n+        }\n+\n+        \/\/ Verify global malloc peak reflects large allocation with a fudge factor\n+        long peakDiff = currPeak - earlyPeak;\n+        double peakLowerBound = allocSize * (1 - FUDGE_FACTOR);\n+        double peakUpperBound = allocSize * (1 + FUDGE_FACTOR);\n+        if (peakDiff < peakLowerBound || peakDiff > peakUpperBound) {\n+            throw new Exception(\"Global malloc peak measurement is incorrect. \" +\n+                    \"Expected peak diff range: [\" + peakLowerBound + \" - \" + peakUpperBound + \"]. \" +\n+                    \"Actual peak diff: \" + peakDiff);\n+        }\n+    }\n+\n+    private static long getMallocPeak(OutputAnalyzer output) {\n+        \/\/ First match should correspond to global malloc peak\n+        String global = output.firstMatch(\"peak=\\\\d*\");\n+        return Long.parseLong(global.substring(global.indexOf(\"=\") + 1));\n+    }\n+\n+    private static long getMallocTotal(OutputAnalyzer output) {\n+        \/\/ First match should correspond to global malloc total\n+        String global = output.firstMatch(\"malloc: \\\\d*\");\n+        return Long.parseLong(global.substring(global.indexOf(\" \") + 1));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/PeakMallocTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=static\n+ * @summary Run JavacBenchApp with the classic static archive workflow\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver JavacBench STATIC\n+ *\/\n+\n+\/*\n+ * @test id=dynamic\n+ * @summary Run JavacBenchApp with the classic dynamic archive workflow\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver JavacBench DYNAMIC\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class JavacBench {\n+    static String mainClass = JavacBenchApp.class.getName();\n+    static String appJar;\n+\n+    public static void main(String args[]) throws Exception {\n+        appJar = ClassFileInstaller.writeJar(\"JavacBenchApp.jar\",\n+                                             \"JavacBenchApp\",\n+                                             \"JavacBenchApp$ClassFile\",\n+                                             \"JavacBenchApp$FileManager\",\n+                                             \"JavacBenchApp$SourceFile\");\n+        JavacBenchTester tester = new JavacBenchTester();\n+        tester.run(args);\n+    }\n+\n+    static class JavacBenchTester extends CDSAppTester {\n+        public JavacBenchTester() {\n+            super(\"JavacBench\");\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                \"90\",\n+            };\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/applications\/JavacBench.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+\/**\n+ * This program tries to compile a large number of classes that exercise a fair amount of\n+ * features in javac.\n+ *\/\n+public class JavacBenchApp {\n+    static class ClassFile extends SimpleJavaFileObject {\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        protected ClassFile(String name) {\n+            super(URI.create(\"memo:\/\/\/\" + name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n+        }\n+        @Override\n+        public ByteArrayOutputStream openOutputStream() {\n+            return this.baos;\n+        }\n+        byte[] toByteArray() {\n+            return baos.toByteArray();\n+        }\n+    }\n+\n+    static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private Map<String, ClassFile> classesMap = new HashMap<String, ClassFile>();\n+        protected FileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+        @Override\n+        public ClassFile getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) {\n+            ClassFile classFile = new ClassFile(name);\n+            classesMap.put(name, classFile);\n+            return classFile;\n+        }\n+        public Map<String, byte[]> getCompiledClasses() {\n+            Map<String, byte[]> result = new HashMap<>();\n+            for (Map.Entry<String, ClassFile> entry : classesMap.entrySet()) {\n+                result.put(entry.getKey(), entry.getValue().toByteArray());\n+            }\n+            return result;\n+        }\n+    }\n+\n+    static class SourceFile extends SimpleJavaFileObject {\n+        private CharSequence sourceCode;\n+        public SourceFile(String name, CharSequence sourceCode) {\n+            super(URI.create(\"memo:\/\/\/\" + name.replace('.', '\/') + Kind.SOURCE.extension), Kind.SOURCE);\n+            this.sourceCode = sourceCode;\n+        }\n+        @Override\n+        public CharSequence getCharContent(boolean ignore) {\n+            return this.sourceCode;\n+        }\n+    }\n+\n+    public Map<String, byte[]> compile() {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        DiagnosticCollector<JavaFileObject> ds = new DiagnosticCollector<>();\n+        Collection<SourceFile> sourceFiles = sources;\n+\n+        try (FileManager fileManager = new FileManager(compiler.getStandardFileManager(ds, null, null))) {\n+            JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, null, null, sourceFiles);\n+            if (task.call()) {\n+                return fileManager.getCompiledClasses();\n+            } else {\n+                for (Diagnostic<? extends JavaFileObject> d : ds.getDiagnostics()) {\n+                    System.out.format(\"Line: %d, %s in %s\", d.getLineNumber(), d.getMessage(null), d.getSource().getName());\n+                }\n+                throw new InternalError(\"compilation failure\");\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    List<SourceFile> sources;\n+\n+    static final String imports = \"\"\"\n+        import java.lang.*;\n+        import java.util.*;\n+        \"\"\";\n+\n+    static final String testClassBody = \"\"\"\n+        \/\/ Some comments\n+        static long x;\n+        static final long y;\n+        static {\n+            y = System.currentTimeMillis();\n+        }\n+        \/* More comments *\/\n+        @Deprecated\n+        String func() { return \"String \" + this + y; }\n+        public static void main(String args[]) {\n+            try {\n+                x = Long.parseLong(args[0]);\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+            }\n+            doit(() -> {\n+                System.out.println(\"Hello Lambda\");\n+                Thread.dumpStack();\n+            });\n+        }\n+        static List<String> list = List.of(\"1\", \"2\");\n+        class InnerClass1 {\n+            static final long yy = y;\n+        }\n+        static void doit(Runnable r) {\n+            for (var x : list) {\n+                r.run();\n+            }\n+        }\n+        static String patternMatch(String arg, Object o) {\n+            if (o instanceof String s) {\n+                return \"1234\";\n+            }\n+            final String b = \"B\";\n+            return switch (arg) {\n+                case \"A\" -> \"a\";\n+                case b   -> \"b\";\n+                default  -> \"c\";\n+            };\n+        }\n+        public sealed class SealedInnerClass {}\n+        public final class Foo extends SealedInnerClass {}\n+        enum Expression {\n+            ADDITION,\n+            SUBTRACTION,\n+            MULTIPLICATION,\n+            DIVISION\n+        }\n+        public record Point(int x, int y) {\n+            public Point(int x) {\n+                this(x, 0);\n+            }\n+        }\n+        \"\"\";\n+\n+    String sanitySource = \"\"\"\n+        public class Sanity implements java.util.concurrent.Callable<String> {\n+            public String call() {\n+                return \"this is a test\";\n+            }\n+        }\n+        \"\"\";\n+\n+    void setup(int count) {\n+        sources = new ArrayList<>(count);\n+        for (int i = 0; i < count; i++) {\n+            String source = imports + \"public class Test\" + i + \" {\" + testClassBody + \"}\";\n+            sources.add(new SourceFile(\"Test\" + i, source));\n+        }\n+\n+        sources.add(new SourceFile(\"Sanity\", sanitySource));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static void validate(byte[] sanityClassFile) throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Class<?> cls = lookup.defineClass(sanityClassFile);\n+        Callable<String> obj = (Callable<String>)cls.getDeclaredConstructor().newInstance();\n+        String s = obj.call();\n+        if (!s.equals(\"this is a test\")) {\n+            throw new RuntimeException(\"Expected \\\"this is a test\\\", but got \\\"\" + s + \"\\\"\");\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Throwable {\n+        long started = System.currentTimeMillis();\n+        JavacBenchApp bench = new JavacBenchApp();\n+\n+        int count = 0;\n+        if (args.length > 0) {\n+            count = Integer.parseInt(args[0]);\n+            if (count >= 0) {\n+                bench.setup(count);\n+                Map<String, byte[]> allClasses = bench.compile();\n+                validate(allClasses.get(\"Sanity\"));\n+            }\n+        }\n+        if (System.getProperty(\"JavacBenchApp.silent\") == null) {\n+            \/\/ Set this property when running with \"perf stat\", etc\n+            long elapsed = System.currentTimeMillis() - started;\n+            System.out.println(\"Generated source code for \" + bench.sources.size() + \" classes and compiled them in \" + elapsed + \" ms\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/applications\/JavacBenchApp.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -87,1 +87,1 @@\n-        \/\/ Extra strings that are humongous are not kelp alive, so they should be GC'ed\n+        \/\/ Extra strings that are humongous are not kept alive, so they should be GC'ed\n@@ -90,1 +90,1 @@\n-        dumpOutput.shouldNotMatch(\"gc,region,cds. HeapRegion 0x[0-9a-f]* HUM\");\n+        dumpOutput.shouldNotMatch(\"gc,region,cds. G1HeapRegion 0x[0-9a-f]* HUM\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsHumongous.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,0 +117,7 @@\n+    static Thread expOwnerThread() {\n+        return Thread.currentThread().isVirtual() ? null : Thread.currentThread();\n+    }\n+\n+    static int expEntryCount() {\n+        return Thread.currentThread().isVirtual() ? 0 : 1;\n+    }\n@@ -130,0 +137,1 @@\n+        final int expWaitingCount = isVirtual ? 0 : NUMBER_OF_WAITING_THREADS;\n@@ -131,0 +139,3 @@\n+        \/\/ The numbers below describe the testing scenario, not the expected results.\n+        \/\/ The expected numbers are different for virtual threads because\n+        \/\/ they are not supported by JVMTI GetObjectMonitorUsage.\n@@ -137,1 +148,1 @@\n-              NUMBER_OF_WAITING_THREADS);\n+              expWaitingCount);\n@@ -161,0 +172,7 @@\n+            \/\/ Virtual threads are not supported by GetObjectMonitorUsage.\n+            \/\/ Correct the expected values for the virtual thread case.\n+            int expEnteringCount = isVirtual ? 0 : NUMBER_OF_ENTERING_THREADS;\n+\n+            \/\/ The numbers below describe the testing scenario, not the expected results.\n+            \/\/ The expected numbers are different for virtual threads because\n+            \/\/ they are not supported by JVMTI GetObjectMonitorUsage.\n@@ -165,1 +183,1 @@\n-            check(lockCheck, Thread.currentThread(), 1, 0, 0);\n+            check(lockCheck, expOwnerThread(), expEntryCount(), 0, 0);\n@@ -169,0 +187,3 @@\n+            \/\/ The numbers below describe the testing scenario, not the expected results.\n+            \/\/ The expected numbers are different for virtual threads because\n+            \/\/ they are not supported by JVMTI GetObjectMonitorUsage.\n@@ -173,2 +194,2 @@\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n+            check(lockCheck, expOwnerThread(), expEntryCount(),\n+                  expEnteringCount,\n@@ -198,0 +219,5 @@\n+            \/\/ Virtual threads are not supported by the GetObjectMonitorUsage.\n+            \/\/ Correct the expected values for the virtual thread case.\n+            int expEnteringCount = isVirtual ? 0 : NUMBER_OF_ENTERING_THREADS;\n+            int expWaitingCount  = isVirtual ? 0 : NUMBER_OF_WAITING_THREADS;\n+\n@@ -200,0 +226,3 @@\n+            \/\/ The numbers below describe the testing scenario, not the expected results.\n+            \/\/ The expected numbers are different for virtual threads because\n+            \/\/ they are not supported by JVMTI GetObjectMonitorUsage.\n@@ -204,3 +233,3 @@\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  NUMBER_OF_WAITING_THREADS);\n+            check(lockCheck, expOwnerThread(), expEntryCount(),\n+                  expEnteringCount,\n+                  expWaitingCount);\n@@ -237,0 +266,8 @@\n+            \/\/ Virtual threads are not supported by GetObjectMonitorUsage.\n+            \/\/ Correct the expected values for the virtual thread case.\n+            int expEnteringCount = isVirtual ? 0 : NUMBER_OF_ENTERING_THREADS;\n+            int expWaitingCount  = isVirtual ? 0 : NUMBER_OF_WAITING_THREADS;\n+\n+            \/\/ The numbers below describe the testing scenario, not the expected results.\n+            \/\/ The expected numbers are different for virtual threads because\n+            \/\/ they are not supported by JVMTI GetObjectMonitorUsage.\n@@ -241,1 +278,1 @@\n-            check(lockCheck, Thread.currentThread(), 1,\n+            check(lockCheck, expOwnerThread(), expEntryCount(),\n@@ -243,1 +280,1 @@\n-                  NUMBER_OF_WAITING_THREADS);\n+                  expWaitingCount);\n@@ -247,0 +284,3 @@\n+            \/\/ The numbers below describe the testing scenario, not the expected results.\n+            \/\/ The expected numbers are different for virtual threads because\n+            \/\/ they are not supported by JVMTI GetObjectMonitorUsage.\n@@ -251,3 +291,3 @@\n-            check(lockCheck, Thread.currentThread(), 1,\n-                  NUMBER_OF_ENTERING_THREADS,\n-                  NUMBER_OF_WAITING_THREADS);\n+            check(lockCheck, expOwnerThread(), expEntryCount(),\n+                  expEnteringCount,\n+                  expWaitingCount);\n@@ -256,0 +296,2 @@\n+                expEnteringCount = isVirtual ? 0 : NUMBER_OF_ENTERING_THREADS + i + 1;\n+                expWaitingCount  = isVirtual ? 0 : NUMBER_OF_WAITING_THREADS - i - 1;\n@@ -259,0 +301,3 @@\n+                \/\/ The numbers below describe the testing scenario, not the expected results.\n+                \/\/ The expected numbers are different for virtual threads because\n+                \/\/ they are not supported by JVMTI GetObjectMonitorUsage.\n@@ -263,3 +308,3 @@\n-                check(lockCheck, Thread.currentThread(), 1,\n-                      NUMBER_OF_ENTERING_THREADS + i + 1,\n-                      NUMBER_OF_WAITING_THREADS  - i - 1);\n+                check(lockCheck, expOwnerThread(), expEntryCount(),\n+                      expEnteringCount,\n+                      expWaitingCount);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ObjectMonitorUsage\/ObjectMonitorUsage.java","additions":60,"deletions":15,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import sun.jvm.hotspot.gc.g1.HeapRegion;\n+import sun.jvm.hotspot.gc.g1.G1HeapRegion;\n@@ -62,2 +62,2 @@\n-            HeapRegion hr = heap.hrm().heapRegionIterator().next();\n-            HeapRegion hrTop = heap.hrm().getByAddress(hr.top());\n+            G1HeapRegion hr = heap.hrm().heapRegionIterator().next();\n+            G1HeapRegion hrTop = heap.hrm().getByAddress(hr.top());\n@@ -66,1 +66,1 @@\n-                                 \"Address of HeapRegion does not match.\");\n+                                 \"Address of G1HeapRegion does not match.\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestG1HeapRegion.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                                 \"Address of HeapRegion does not match.\");\n+                                 \"Address of G1HeapRegion does not match.\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestObjectAlignment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,0 +200,2 @@\n+                                 \/\/ The lockRef.entryCount() is expected to return 0 if the owner thread is virtual.\n+                                 int expEntryCount = mainThread.isVirtual() ? 0 : i;\n@@ -201,1 +203,2 @@\n-                                 if (entryCount != i) {\n+\n+                                 if (entryCount != expEntryCount) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/entryCount\/entrycount002.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -203,0 +203,9 @@\n+                                 \/\/ The lockRef.owningThread() is expected to return null if tested threads are virtual.\n+                                 if (eventThread.isVirtual()) {\n+                                     if (thread == null) {\n+                                        display(\"expected null is returned` by owningThread method on virtual thread: \" + eventThread.name());\n+                                     } else {\n+                                        complain(\"owningThread returned ThreadReference of virtual thread instead of null: \" + thread.name());\n+                                     }\n+                                     continue;\n+                                 }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/owningThread\/owningthread002.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,0 +125,3 @@\n+                        \/\/ Virtual threads are not present in result returned by objRef.waitingThreads().\n+                        if (!thread.isVirtual()) {\n+                        }\n@@ -162,1 +165,3 @@\n-                        if (waitingThreads.size() != waitingthreads002a.threadCount) {\n+                        final boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"test.thread.factory\"));\n+                        final int expWaitingCount = vthreadMode ? 0 : waitingthreads002a.threadCount;\n+                        if (waitingThreads.size() != expWaitingCount) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/waitingThreads\/waitingthreads002.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+        \/\/ Virtual threads are not supported by GetObjectMonitorUsage.\n+        \/\/ Correct the expected values if the test is executed with\n+        \/\/ JTREG_TEST_THREAD_FACTORY=Virtual.\n+        Thread expOwner = mainThread.isVirtual() ? null : mainThread;\n+        int expEntryCount = mainThread.isVirtual() ? 0 : 1;\n@@ -66,0 +71,3 @@\n+            Thread expNotifyWaiter = runn[i].isVirtual() ? null : runn[i];\n+            int expNotifyWaitingCount = runn[i].isVirtual() ? 0 : 1;\n+\n@@ -95,2 +103,2 @@\n-                check(NUMBER_OF_THREADS + i, syncObject[i], mainThread, 1,\n-                      null, 0, runn[i], 1);\n+                check(NUMBER_OF_THREADS + i, syncObject[i], expOwner, expEntryCount,\n+                      null, 0, expNotifyWaiter, expNotifyWaitingCount);\n@@ -120,1 +128,1 @@\n-                  null, 0, runn[i], 1);\n+                  null, 0, expNotifyWaiter, expNotifyWaitingCount);\n@@ -150,0 +158,8 @@\n+        \/\/ Virtual threads are not supported by GetObjectMonitorUsage.\n+        \/\/ Correct the expected values if the test is executed with\n+        \/\/ JTREG_TEST_THREAD_FACTORY=Virtual.\n+        Thread expOwner = this.isVirtual() ? null : this;\n+        Thread expNotifyWaiter = mainThread.isVirtual() ? null : mainThread;\n+        int expEntryCount = this.isVirtual() ? 0 : 1;\n+        int expNotifyWaitingCount = mainThread.isVirtual() ? 0 : 1;\n+\n@@ -169,2 +185,2 @@\n-            objmonusage001.check(index, syncObject, this, 1,\n-                                 null, 0, mainThread, 1);\n+            objmonusage001.check(index, syncObject, expOwner, expEntryCount,\n+                                 null, 0, expNotifyWaiter, expNotifyWaitingCount);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,6 @@\n+            \/\/ Virtual threads are not supported by GetObjectMonitorUsage.\n+            \/\/ Correct the expected values if the test is executed with\n+            \/\/ JTREG_TEST_THREAD_FACTORY=Virtual.\n+            Thread expOwner = currThread.isVirtual() ? null : currThread;\n+            int expEntryCount = currThread.isVirtual() ? 0 : 2;\n+\n@@ -64,1 +70,1 @@\n-                check(lockCheck, currThread, 2, 0);\n+                check(lockCheck, expOwner, expEntryCount, 0);\n@@ -66,0 +72,3 @@\n+            expEntryCount = currThread.isVirtual() ? 0 : 1;\n+            int expWaiterCount = 0;\n+\n@@ -68,0 +77,3 @@\n+                if (!thr[i].isVirtual()) {\n+                    expWaiterCount++;\n+                }\n@@ -77,1 +89,1 @@\n-            check(lockCheck, currThread, 1, i + 1);\n+                check(lockCheck, expOwner, expEntryCount, expWaiterCount);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage004.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share;\n-\n-import nsk.share.*;\n-\n-import java.io.*;\n-\n-\/**\n- * Wrapper for local process.\n- * <p>\n- * This class provides abilities to launch such process,\n- * redirect standard output streams, wait for process terminates\n- * or kill the process, and so on.\n- * <p>\n- * This object is finalized with <code>nsk.share.Finalizer<\/code>.\n- *\n- * @see nsk.share.FinalizableObject\n- * @see nsk.share.Finalizer\n- *\/\n-\n-public class LocalProcess extends FinalizableObject {\n-\n-    public final static int PROCESS_IS_ALIVE = 222;\n-\n-    private Process process;\n-\n-    protected Process getProcess() {\n-        return process;\n-    }\n-\n-    public void launch (String[] args) throws IOException {\n-        System.out.println(\"Launching process by array of args: \");\n-        for (int mm=0; mm < args.length; mm++) {\n-            System.out.println(\"    args[\" + Integer.toString(mm) + \"]: >\" +\n-                               args[mm] + \"<\");\n-\n-        }\n-\n-        process = Runtime.getRuntime().exec(args);\n-\n-        registerCleanup();\n-    }\n-\n-    public void launch (String cmdLine) throws IOException {\n-        System.out.println(\"Launching process by command line: \" + cmdLine);\n-\n-        process = Runtime.getRuntime().exec(cmdLine);\n-\n-        registerCleanup();\n-    }\n-\n-    \/** Return exit status. *\/\n-    public int getStatus () {\n-        return process.exitValue();\n-    }\n-\n-    \/** Check whether the process has been terminated. *\/\n-    public boolean terminated() {\n-        try {\n-            int value = process.exitValue();\n-            return true;\n-        } catch (IllegalThreadStateException e) {\n-            return false;\n-        }\n-    }\n-\n-    \/** Wait until the process shutdown or crash. *\/\n-    public int waitFor () throws InterruptedException {\n-        return process.waitFor();\n-    }\n-\n-    \/**\n-     * Wait until the process shutdown or crash for given timeout in milliseconds.\n-     * Returns <code>LocalProcess.PROCESS_IS_ALIVE<\/code> if process is not terminated\n-     * after timeout.\n-     *\/\n-\n-    public int waitFor (long timeMillisec) throws InterruptedException {\n-        final Object waitObject = new Object();\n-\n-        class Watcher extends Thread {\n-            int exitCode = LocalProcess.PROCESS_IS_ALIVE;\n-            Process process;\n-\n-            Watcher (Process process) {\n-               this.process = process;\n-            }\n-\n-            public void run () {\n-                try {\n-                    synchronized (this) {\n-                       exitCode = process.waitFor();\n-                    }\n-                } catch (InterruptedException ie) {\n-                }\n-                synchronized (waitObject) {\n-                    waitObject.notifyAll();\n-                }\n-            }\n-\n-            synchronized public int getExitCode() {\n-                return exitCode;\n-            }\n-        }\n-\n-        Watcher watcher;\n-        \/\/ yield control to watcher for timeMillisec time.\n-        synchronized (waitObject) {\n-            watcher = new Watcher(process);\n-            watcher.start();\n-\n-            waitObject.wait(timeMillisec);\n-        }\n-\n-        if (watcher.isAlive()) {\n-            watcher.interrupt();\n-        }\n-\n-        return watcher.getExitCode();\n-    }\n-\n-    \/\/ --------------------------------------------------- \/\/\n-\n-    \/** Get a pipe to write to the process' stdin stream. *\/\n-    public OutputStream getStdin () {\n-        return process.getOutputStream();\n-    }\n-\n-    \/** Get a pipe to read the process' stdout stream. *\/\n-    public InputStream getStdout () {\n-        return process.getInputStream();\n-    }\n-\n-    \/** Get a pipe to read the process stderr stream. *\/\n-    public InputStream getStderr () {\n-        return process.getErrorStream();\n-    }\n-\n-    \/** Kill the process. *\/\n-    protected void kill() {\n-        process.destroy();\n-    }\n-\n-    \/**\n-     * This method is called at finalization and calls <code>kill()<\/code>.\n-     *\n-     *\/\n-    @Override\n-    public void cleanup() {\n-        kill();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/LocalProcess.java","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import nsk.share.jpda.*;\n@@ -39,1 +38,1 @@\n-public class Jdb extends LocalProcess implements Finalizable {\n+public class Jdb extends LocalProcess {\n@@ -98,3 +97,0 @@\n-    public void finalizeAtExit() throws Throwable {\n-        finalize();\n-    }\n@@ -102,1 +98,1 @@\n-    public void finalize() throws Throwable {\n+    public void close() {\n@@ -119,1 +115,0 @@\n-        super.finalize();\n@@ -964,1 +959,1 @@\n-                        jdb.finalize();\n+                        jdb.close();\n@@ -967,1 +962,1 @@\n-                        throw new Failure(\"Caught unexpected error while finalizing jdb: \" + t);\n+                        throw new Failure(\"Caught unexpected error while closing jdb streams: \" + t);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Jdb.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import nsk.share.jpda.*;\n@@ -30,1 +29,0 @@\n-import java.util.*;\n@@ -177,0 +175,8 @@\n+\n+                    try {\n+                        jdb.close();\n+                    } catch (Throwable ex) {\n+                        failure(\"Caught exception\/error while closing jdb streams:\\n\\t\" + ex);\n+                        ex.printStackTrace(log.getOutStream());\n+                    }\n+\n@@ -201,4 +207,4 @@\n-            } catch (Exception e) {\n-                failure(\"Caught unexpected exception: \" + e);\n-                e.printStackTrace(out);\n-\n+            } catch (Throwable t) {\n+                failure(\"Caught unexpected exception: \" + t);\n+                t.printStackTrace(out);\n+            } finally {\n@@ -206,0 +212,1 @@\n+                    log.complain(\"jdb reference is not null, check for exception in the logs.\");\n@@ -207,1 +214,1 @@\n-                        jdb.finalize();\n+                        jdb.close();\n@@ -209,1 +216,1 @@\n-                        failure(\"Caught exception\/error while finalization of jdb:\\n\\t\" + ex);\n+                        failure(\"Caught exception\/error while closing jdb streams:\\n\\t\" + ex);\n@@ -212,2 +219,0 @@\n-                } else {\n-                    log.complain(\"jdb reference is null, cannot run jdb.finalize() method\");\n@@ -216,1 +221,2 @@\n-                if (debuggee != null) {\n+                if (debuggee != null && !debuggee.terminated()) {\n+                    log.complain(\"debuggee is still running, check for exception in the logs.\");\n@@ -218,2 +224,0 @@\n-                } else {\n-                    log.complain(\"debuggee reference is null, cannot run debuggee.finalize() method\");\n@@ -221,1 +225,0 @@\n-\n@@ -229,3 +232,3 @@\n-        } catch (Exception e) {\n-            out.println(\"Caught unexpected exception while starting the test: \" + e);\n-            e.printStackTrace(out);\n+        } catch (Throwable t) {\n+            out.println(\"Caught unexpected exception while starting the test: \" + t);\n+            t.printStackTrace(out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/JdbTest.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.share.jdb;\n+\n+import java.io.*;\n+\n+\/**\n+ * Wrapper for local process.\n+ * <p>\n+ * This class provides abilities to launch such process,\n+ * redirect standard output streams, wait for process terminates\n+ * or kill the process, and so on.\n+ *\/\n+\n+class LocalProcess {\n+\n+    public final static int PROCESS_IS_ALIVE = 222;\n+\n+    private Process process;\n+\n+    protected Process getProcess() {\n+        return process;\n+    }\n+\n+    public void launch (String[] args) throws IOException {\n+        System.out.println(\"Launching process by array of args: \");\n+        for (int mm=0; mm < args.length; mm++) {\n+            System.out.println(\"    args[\" + Integer.toString(mm) + \"]: >\" +\n+                               args[mm] + \"<\");\n+\n+        }\n+\n+        process = Runtime.getRuntime().exec(args);\n+    }\n+\n+    public void launch (String cmdLine) throws IOException {\n+        System.out.println(\"Launching process by command line: \" + cmdLine);\n+        process = Runtime.getRuntime().exec(cmdLine);\n+    }\n+\n+    \/** Return exit status. *\/\n+    public int getStatus () {\n+        return process.exitValue();\n+    }\n+\n+    \/** Check whether the process has been terminated. *\/\n+    public boolean terminated() {\n+        try {\n+            int value = process.exitValue();\n+            return true;\n+        } catch (IllegalThreadStateException e) {\n+            return false;\n+        }\n+    }\n+\n+    \/** Wait until the process shutdown or crash. *\/\n+    public int waitFor () throws InterruptedException {\n+        return process.waitFor();\n+    }\n+\n+    \/**\n+     * Wait until the process shutdown or crash for given timeout in milliseconds.\n+     * Returns <code>LocalProcess.PROCESS_IS_ALIVE<\/code> if process is not terminated\n+     * after timeout.\n+     *\/\n+\n+    public int waitFor (long timeMillisec) throws InterruptedException {\n+        final Object waitObject = new Object();\n+\n+        class Watcher extends Thread {\n+            int exitCode = LocalProcess.PROCESS_IS_ALIVE;\n+            Process process;\n+\n+            Watcher (Process process) {\n+               this.process = process;\n+            }\n+\n+            public void run () {\n+                try {\n+                    synchronized (this) {\n+                       exitCode = process.waitFor();\n+                    }\n+                } catch (InterruptedException ie) {\n+                }\n+                synchronized (waitObject) {\n+                    waitObject.notifyAll();\n+                }\n+            }\n+\n+            synchronized public int getExitCode() {\n+                return exitCode;\n+            }\n+        }\n+\n+        Watcher watcher;\n+        \/\/ yield control to watcher for timeMillisec time.\n+        synchronized (waitObject) {\n+            watcher = new Watcher(process);\n+            watcher.start();\n+\n+            waitObject.wait(timeMillisec);\n+        }\n+\n+        if (watcher.isAlive()) {\n+            watcher.interrupt();\n+        }\n+\n+        return watcher.getExitCode();\n+    }\n+\n+    \/\/ --------------------------------------------------- \/\/\n+\n+    \/** Get a pipe to write to the process' stdin stream. *\/\n+    public OutputStream getStdin () {\n+        return process.getOutputStream();\n+    }\n+\n+    \/** Get a pipe to read the process' stdout stream. *\/\n+    public InputStream getStdout () {\n+        return process.getInputStream();\n+    }\n+\n+    \/** Get a pipe to read the process stderr stream. *\/\n+    public InputStream getStderr () {\n+        return process.getErrorStream();\n+    }\n+\n+    \/** Kill the process. *\/\n+    protected void kill() {\n+        process.destroy();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/LocalProcess.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import nsk.share.jpda.*;\n@@ -61,1 +60,1 @@\n-public class BindServer implements Finalizable {\n+public final class BindServer {\n@@ -91,1 +90,0 @@\n-    private ListeningThread listeningThread = null;\n@@ -152,2 +150,0 @@\n-        registerCleanup();\n-\n@@ -181,0 +177,3 @@\n+        try (ListeningThread listeningThread = new ListeningThread(this)) {\n+            listeningThread.bind();\n+            listeningThread.start();\n@@ -182,8 +181,4 @@\n-        listeningThread = new ListeningThread(this);\n-        listeningThread.bind();\n-        listeningThread.start();\n-\n-        System.out.println(\"\\n\"\n-                          + \"BindServer started\" + \"\\n\"\n-                          + \"Type \\\"exit\\\" to shut down BindServer\"\n-                          + \"\\n\");\n+            System.out.println(\"\\n\"\n+                              + \"BindServer started\" + \"\\n\"\n+                              + \"Type \\\"exit\\\" to shut down BindServer\"\n+                              + \"\\n\");\n@@ -191,13 +186,18 @@\n-        for (;;) {\n-            try {\n-                String userInput = stdIn.readLine();\n-                if (userInput == null || userInput.equals(\"exit\")\n-                        || userInput.equals(\"quit\")) {\n-                    logger.display(\"Shutting down BindServer\");\n-                    stdIn.close();\n-                    stdIn = null;\n-                    break;\n-                } else if (userInput.trim().equals(\"\")) {\n-                    continue;\n-                } else {\n-                    System.out.println(\"ERROR: Unknown command: \" + userInput);\n+            for (; ; ) {\n+                try {\n+                    String userInput = stdIn.readLine();\n+                    if (userInput == null || userInput.equals(\"exit\")\n+                            || userInput.equals(\"quit\")) {\n+                        logger.display(\"Shutting down BindServer\");\n+                        stdIn.close();\n+                        stdIn = null;\n+                        break;\n+                    } else if (userInput.trim().equals(\"\")) {\n+                        continue;\n+                    } else {\n+                        System.out.println(\"ERROR: Unknown command: \" + userInput);\n+                    }\n+                } catch (IOException e) {\n+                    e.printStackTrace(log.getOutStream());\n+                    throw new Failure(\"Caught exception while reading console command:\\n\\t\"\n+                            + e);\n@@ -205,4 +205,0 @@\n-            } catch(IOException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Caught exception while reading console command:\\n\\t\"\n-                                    + e);\n@@ -210,1 +206,0 @@\n-        }\n@@ -212,1 +207,1 @@\n-        printSummary(System.out);\n+            printSummary(System.out);\n@@ -214,6 +209,1 @@\n-        logger.trace(TRACE_LEVEL_THREADS, \"BindServer: exiting main thread\");\n-        try {\n-            cleanup();\n-        } catch (Throwable e) {\n-            e.printStackTrace(log.getOutStream());\n-            logger.complain(\"Caught exception while finalization of BindServer:\\n\\t\" + e);\n+            logger.trace(TRACE_LEVEL_THREADS, \"BindServer: exiting main thread\");\n@@ -390,32 +380,0 @@\n-    \/**\n-     * Close <code>BindServer<\/code> by finishing all threads and closing\n-     * all conections.\n-     *\/\n-    public synchronized void close() {\n-        if (listeningThread != null) {\n-            listeningThread.close();\n-            listeningThread = null;\n-        }\n-    }\n-\n-    \/**\n-     * Make finalization of <code>BindServer<\/code> object by invoking\n-     * method <code>close()<\/code>.\n-     *\n-     * @see #close()\n-     *\/\n-    @Override\n-    public void cleanup() {\n-        close();\n-    }\n-\n-    \/**\n-     * Make finalization of <code>BindServer<\/code> object at program exit\n-     * by invoking method <code>cleanup()<\/code>.\n-     *\n-     *\/\n-    public void finalizeAtExit() throws Throwable {\n-        cleanup();\n-        logger.trace(TRACE_LEVEL_THREADS, \"BindServer: finalization at exit completed\");\n-    }\n-\n@@ -430,1 +388,1 @@\n-    private static class ListeningThread extends Thread {\n+    private static class ListeningThread extends Thread implements AutoCloseable {\n@@ -676,1 +634,1 @@\n-         * foor thread finished.\n+         * for thread to finish.\n@@ -680,0 +638,1 @@\n+        @Override\n@@ -684,4 +643,13 @@\n-            closeHostConnection();\n-            if (servingThread != null) {\n-                servingThread.close();\n-                servingThread = null;\n+            try {\n+                closeHostConnection();\n+                if (servingThread != null) {\n+                    servingThread.close();\n+                    servingThread = null;\n+                }\n+                waitForThread(THREAD_TIMEOUT);\n+                closeConnection();\n+                closed = true;\n+                logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread closed\");\n+            } catch (Throwable e) {\n+                e.printStackTrace(log.getOutStream());\n+                logger.complain(\"Caught exception while closing ListeningThread:\\n\\t\" + e);\n@@ -689,4 +657,0 @@\n-            waitForThread(THREAD_TIMEOUT);\n-            closeConnection();\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread closed\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/BindServer.java","additions":44,"deletions":80,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.config;\n+\n+import common.util.TestBase;\n+import static common.util.TestBase.CONFIG_DEFAULT;\n+import static common.util.TestBase.CONFIG_STRICT;\n+import static common.util.TestBase.CONFIG_TEMPLATE_STRICT;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.IntStream;\n+import javax.xml.transform.TransformerFactory;\n+\n+\/**\n+ * @test @bug 8330542\n+ * @summary verifies the default JAXP configuration file jaxp.properties and\n+ * strict template jaxp-strict.properties.template.\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.config.ConfigFileTest 0 \/\/ verifies jaxp.properties\n+ * @run driver common.config.ConfigFileTest 1 \/\/ verifies jaxp-strict.properties.template\n+ *\/\n+public class ConfigFileTest {\n+    \/\/ system property for custom configuration file\n+    static final String SP_CONFIG = \"java.xml.config.file\";\n+    \/\/ target directory\n+    static String TEST_DIR = System.getProperty(\"test.classes\");\n+\n+    \/\/ properties in the configuration file\n+    String[] keys = {\n+        \"jdk.xml.enableExtensionFunctions\",\n+        \"jdk.xml.overrideDefaultParser\",\n+        \"jdk.xml.jdkcatalog.resolve\",\n+        \"jdk.xml.dtd.support\",\n+        \"jdk.xml.entityExpansionLimit\",\n+        \"jdk.xml.totalEntitySizeLimit\",\n+        \"jdk.xml.maxGeneralEntitySizeLimit\",\n+        \"jdk.xml.maxParameterEntitySizeLimit\",\n+        \"jdk.xml.entityReplacementLimit\",\n+        \"jdk.xml.elementAttributeLimit\",\n+        \"jdk.xml.maxOccurLimit\",\n+        \"jdk.xml.maxElementDepth\",\n+        \"jdk.xml.maxXMLNameLimit\",\n+        \"jdk.xml.xpathExprGrpLimit\",\n+        \"jdk.xml.xpathExprOpLimit\",\n+        \"jdk.xml.xpathTotalOpLimit\"};\n+\n+    \/\/ type of properties\n+    boolean[] propertyIsFeature ={true, true, false, false, false, false,\n+        false, false, false, false, false, false, false, false, false, false};\n+\n+    \/\/ values from jaxp-strict.properties.template\n+    String[] strictValues ={\"false\", \"false\", \"strict\", \"allow\", \"2500\", \"100000\",\n+        \"100000\", \"15000\", \"100000\", \"10000\", \"5000\", \"0\", \"1000\", \"10\", \"100\", \"10000\"};\n+\n+    \/\/ values from jaxp.properties, as of JDK 23\n+    String[] defaultValues ={\"true\", \"false\", \"continue\", \"allow\", \"64000\", \"50000000\",\n+        \"0\", \"1000000\", \"3000000\", \"10000\", \"5000\", \"0\", \"1000\", \"10\", \"100\", \"10000\"};\n+\n+    public static void main(String args[]) throws Exception {\n+        new ConfigFileTest().run(args[0]);\n+    }\n+\n+    public void run(String index) throws Exception {\n+        String conf = System.getProperty(\"java.home\") + \"\/conf\/\";\n+        if (index.equals(\"0\")) {\n+            verifyConfig(conf + CONFIG_DEFAULT, defaultValues);\n+        } else {\n+            Path config = Paths.get(TEST_DIR, CONFIG_STRICT);\n+            Files.copy(Paths.get(conf, CONFIG_TEMPLATE_STRICT), config);\n+            verifyConfig(config.toString(), strictValues);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies a configuration file by iterating through its property settings.\n+     * @param filename the configuration file\n+     * @param values expected values in the configuration file\n+     *\/\n+    private void verifyConfig(String filename, String[] values) {\n+        System.setProperty(SP_CONFIG, filename);\n+\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        IntStream.range(0, keys.length).forEach(i -> {\n+            if (propertyIsFeature[i]) {\n+                TestBase.Assert.assertEquals(tf.getFeature(keys[i]), Boolean.parseBoolean(values[i]));\n+            } else {\n+                TestBase.Assert.assertEquals(tf.getAttribute(keys[i]), values[i]);\n+            }\n+        });\n+        System.clearProperty(SP_CONFIG);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/ConfigFileTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -124,0 +125,5 @@\n+    \/\/ JAXP Configuration Files to be added to $JAVA_HOME\/conf\/\n+    public static final String CONFIG_DEFAULT = \"jaxp.properties\";\n+    public static final String CONFIG_STRICT = \"jaxp-strict.properties\";\n+    public static final String CONFIG_TEMPLATE_STRICT = \"jaxp-strict.properties.template\";\n+\n@@ -136,0 +142,1 @@\n+\n@@ -718,1 +725,1 @@\n-    static class Assert {\n+    public static class Assert {\n@@ -736,0 +743,6 @@\n+\n+        public static void assertEquals(Object actual, Object expected) {\n+            if (!Objects.equals(actual, expected)) {\n+                throw new RuntimeException(\"Expected: \" + expected + \" but actual result was \" + actual);\n+            }\n+        }\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/util\/TestBase.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -61,3 +61,2 @@\n-            \/\/ access is unaligned, but access mode is supported\n-            assertTrue(compatible ||\n-                    (layout instanceof GroupLayout && segment.maxByteAlignment() < layout.byteAlignment()));\n+            \/\/ access is unaligned\n+            assertTrue(segment.maxByteAlignment() < layout.byteAlignment());\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        MemoryLayout seq = MemoryLayout.sequenceLayout(10, layout);\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(1, layout);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.invoke.VarHandle.AccessMode;\n@@ -334,0 +335,51 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testVarHandleBadSegment(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(10, layout);\n+        PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+        long[] seqIndexes = new long[indexes.length + 1];\n+        System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+        System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+        seqPathElements[0] = PathElement.sequenceElement();\n+        seqIndexes[0] = 0;\n+        MethodHandle getter_handle = seqLayout.varHandle(seqPathElements)\n+                .toMethodHandle(AccessMode.GET)\n+                .asSpreader(long[].class, seqIndexes.length);\n+        MemorySegment segment = Arena.ofAuto().allocate(layout);\n+        assertThrows(IndexOutOfBoundsException.class, () -> getter_handle.invoke(segment, 0L, seqIndexes));\n+    }\n+\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testSliceHandleBadSegment(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                        long expectedByteOffset) throws Throwable {\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(10, layout);\n+        PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+        long[] seqIndexes = new long[indexes.length + 1];\n+        System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+        System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+        seqPathElements[0] = PathElement.sequenceElement();\n+        seqIndexes[0] = 0;\n+        MethodHandle getter_handle = seqLayout.sliceHandle(seqPathElements)\n+                .asSpreader(long[].class, seqIndexes.length);\n+        MemorySegment segment = Arena.ofAuto().allocate(layout);\n+        assertThrows(IndexOutOfBoundsException.class, () -> getter_handle.invoke(segment, 0L, seqIndexes));\n+    }\n+\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testArrayElementVarHandleBadSegment(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                          long expectedByteOffset) throws Throwable {\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(10, layout);\n+        PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+        long[] seqIndexes = new long[indexes.length + 2];\n+        System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+        System.arraycopy(indexes, 0, seqIndexes, 2, indexes.length);\n+        seqPathElements[0] = PathElement.sequenceElement();\n+        seqIndexes[0] = 0;\n+        seqIndexes[1] = 0;\n+        MethodHandle getter_handle = seqLayout.arrayElementVarHandle(seqPathElements)\n+                .toMethodHandle(AccessMode.GET)\n+                .asSpreader(long[].class, seqIndexes.length);\n+        MemorySegment segment = Arena.ofAuto().allocate(layout);\n+        assertThrows(IndexOutOfBoundsException.class, () -> getter_handle.invoke(segment, 0L, seqIndexes));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8305457\n+ * @summary java.io.IO tests\n+ * @library \/test\/lib\n+ * @run junit IO\n+ *\/\n+public class IO {\n+\n+    @Nested\n+    @EnabledOnOs({OS.LINUX, OS.MAC})\n+    public class OSSpecificTests {\n+\n+        private static Path expect;\n+\n+        @BeforeAll\n+        public static void prepareTTY() {\n+            expect = Paths.get(\"\/usr\/bin\/expect\"); \/\/ os-specific path\n+            if (!Files.exists(expect) || !Files.isExecutable(expect)) {\n+                Assumptions.abort(\"'\" + expect + \"' not found\");\n+            }\n+        }\n+\n+        \/*\n+         * Unlike printTest, which tests a _default_ console that is normally\n+         * jdk.internal.org.jline.JdkConsoleProviderImpl, this test tests\n+         * jdk.internal.io.JdkConsoleImpl. Those console implementations operate\n+         * in different conditions and, thus, are tested separately.\n+         *\n+         * To test jdk.internal.io.JdkConsoleImpl one needs to ensure that both\n+         * conditions are met:\n+         *\n+         *   - a non-existent console provider is requested\n+         *   - isatty is true\n+         *\n+         * To achieve isatty, the test currently uses the EXPECT(1) Unix command,\n+         * which does not work for Windows. Later, a library like pty4j or JPty\n+         * might be used instead of EXPECT, to cover both Unix and Windows.\n+         *\/\n+        @ParameterizedTest\n+        @ValueSource(strings = {\"println\", \"print\"})\n+        public void outputTestInteractive(String mode) throws Exception {\n+            var testSrc = System.getProperty(\"test.src\", \".\");\n+            OutputAnalyzer output = ProcessTools.executeProcess(\n+                    expect.toString(),\n+                    Path.of(testSrc, \"output.exp\").toAbsolutePath().toString(),\n+                    System.getProperty(\"test.jdk\") + \"\/bin\/java\",\n+                    \"--enable-preview\",\n+                    \"-Djdk.console=gibberish\",\n+                    Path.of(testSrc, \"Output.java\").toAbsolutePath().toString(),\n+                    mode);\n+            assertEquals(0, output.getExitValue());\n+            assertTrue(output.getStderr().isEmpty());\n+            output.reportDiagnosticSummary();\n+            String out = output.getStdout();\n+            \/\/ The first half of the output is produced by Console, the second\n+            \/\/ half is produced by IO: those halves must match.\n+            \/\/ Executing Console and IO in the same VM (as opposed to\n+            \/\/ consecutive VM runs, which are cleaner) to be able to compare string\n+            \/\/ representation of objects.\n+            assertFalse(out.isBlank());\n+            assertEquals(out.substring(0, out.length() \/ 2),\n+                    out.substring(out.length() \/ 2));\n+        }\n+\n+        \/*\n+         * This tests simulates terminal interaction (isatty), to check that the\n+         * prompt is output.\n+         *\n+         * To simulate a terminal, the test currently uses the EXPECT(1) Unix\n+         * command, which does not work for Windows. Later, a library like pty4j\n+         * or JPty might be used instead of EXPECT, to cover both Unix and Windows.\n+         *\/\n+        @ParameterizedTest\n+        @MethodSource(\"args\")\n+        public void inputTestInteractive(String console, String prompt) throws Exception {\n+            var testSrc = System.getProperty(\"test.src\", \".\");\n+            var command = new ArrayList<String>();\n+            command.add(expect.toString());\n+            command.add(Path.of(testSrc, \"input.exp\").toAbsolutePath().toString());\n+            command.add(System.getProperty(\"test.jdk\") + \"\/bin\/java\");\n+            command.add(\"--enable-preview\");\n+            if (console != null)\n+                command.add(\"-Djdk.console=\" + console);\n+            command.add(Path.of(testSrc, \"Input.java\").toAbsolutePath().toString());\n+            command.add(prompt == null ? \"0\" : \"1\");\n+            command.add(String.valueOf(prompt));\n+            OutputAnalyzer output = ProcessTools.executeProcess(command.toArray(new String[]{}));\n+            output.reportDiagnosticSummary();\n+            assertEquals(0, output.getExitValue());\n+        }\n+\n+        public static Stream<Arguments> args() {\n+            \/\/ cross product: consoles x prompts\n+            return Stream.of(null, \"gibberish\").flatMap(console -> Stream.of(null, \"?\", \"%s\")\n+                    .map(prompt -> new String[]{console, prompt}).map(Arguments::of));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"println\", \"print\"})\n+    public void printTest(String mode) throws Exception {\n+        var file = Path.of(System.getProperty(\"test.src\", \".\"), \"Output.java\")\n+                .toAbsolutePath().toString();\n+        var pb = ProcessTools.createTestJavaProcessBuilder(\"--enable-preview\", file, mode);\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+        assertEquals(0, output.getExitValue());\n+        assertTrue(output.getStderr().isEmpty());\n+        output.reportDiagnosticSummary();\n+        String out = output.getStdout();\n+        \/\/ The first half of the output is produced by Console, the second\n+        \/\/ half is produced by IO: those halves must match.\n+        \/\/ Executing Console and IO in the same VM (as opposed to\n+        \/\/ consecutive VM runs, which are cleaner) to be able to compare string\n+        \/\/ representation of objects.\n+        assertFalse(out.isBlank());\n+        assertEquals(out.substring(0, out.length() \/ 2),\n+                out.substring(out.length() \/ 2));\n+    }\n+\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"println\", \"print\", \"input\"})\n+    public void nullConsole(String method) throws Exception {\n+        var file = Path.of(System.getProperty(\"test.src\", \".\"), \"Methods.java\")\n+                .toAbsolutePath().toString();\n+        var pb = ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=gibberish\",\n+                \"--enable-preview\", file, method);\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+        output.reportDiagnosticSummary();\n+        assertEquals(1, output.getExitValue());\n+        output.shouldContain(\"Exception in thread \\\"main\\\" java.io.IOError\");\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/IO\/IO.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+\n+import static java.io.IO.readln;\n+\n+public class Input {\n+\n+    public static void main(String[] args) throws IOException {\n+        if (args[0].equals(\"0\"))\n+            System.out.print(readln(null));\n+        else\n+            System.out.print(readln(args[1]));\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/IO\/Input.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.io.IO.*;\n+\n+public class Methods {\n+\n+    public static void main(String[] args) {\n+        switch (args[0]) {\n+            case \"println\" -> println(\"hello\");\n+            case \"print\" -> print(\"hello\");\n+            case \"input\" -> readln(\"hello\");\n+            default -> throw new IllegalArgumentException(args[0]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/IO\/Methods.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.io.IO.*;\n+import java.util.function.Consumer;\n+\n+public class Output {\n+\n+    private static final Object[] OBJECTS = {\n+            null,\n+            false,\n+            (byte) 1,\n+            (short) 2,\n+            'a',\n+            3,\n+            4L,\n+            5f,\n+            6d,\n+            new Object(),\n+            \"%s\", \/\/ to test that print(ln) does not interpret its argument as a format string\n+            new char[]{'a'},\n+    };\n+\n+    public static void main(String[] args) {\n+        switch (args[0]) {\n+            case \"print\" -> {\n+                printObjects(obj -> System.console().format(\"%s\", obj).flush());\n+                printObjects(obj -> print(obj));\n+            }\n+            case \"println\" -> {\n+                printObjects(obj -> System.console().format(\"%s%n\", obj).flush());\n+                printObjects(obj -> println(obj));\n+            }\n+            default -> throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    private static void printObjects(Consumer<Object> printer) {\n+        for (var obj : OBJECTS) {\n+            printer.accept(obj);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/IO\/Output.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+set prompt [lindex $argv $argc-1]\n+set stty_init \"rows 24 cols 80\"\n+\n+spawn {*}$argv\n+expect {\n+    -exact \"$prompt\" {\n+        send \"hello\\r\"\n+    }\n+    timeout {\n+        puts \"timeout\"; exit 1\n+    }\n+}\n+expect eof\n","filename":"test\/jdk\/java\/io\/IO\/input.exp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# This script does not expect\/verify anything and is only used to simulate tty #\n+################################################################################\n+\n+# Use `noecho` below, otherwise, expect will output the expanded \"spawn ...\"\n+# command, which will interfere with asserting output from the java test\n+\n+spawn -noecho {*}$argv\n+expect eof\n","filename":"test\/jdk\/java\/io\/IO\/output.exp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -137,1 +137,1 @@\n-                    .findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                    .findAttribute(Attributes.lineNumberTable())\n","filename":"test\/jdk\/java\/lang\/StackWalker\/TestBCI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                for (var a : m.findAttributes(Attributes.CODE)) {\n+                for (var a : m.findAttributes(Attributes.code())) {\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/\/ this record is defined as:\n+\/\/     record R10(List<String> ls) { \/\/ there is no compact constructor and thus there is no mandated param\n+\/\/     }\n+class R10 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Record\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"R10\"; \/\/ #10\n+    Utf8 \"ls\"; \/\/ #11\n+    Utf8 \"Ljava\/util\/List;\"; \/\/ #12\n+    InvokeDynamic 0s #14; \/\/ #13\n+    NameAndType #15 #16; \/\/ #14\n+    Utf8 \"toString\"; \/\/ #15\n+    Utf8 \"(LR10;)Ljava\/lang\/String;\"; \/\/ #16\n+    InvokeDynamic 0s #18; \/\/ #17\n+    NameAndType #19 #20; \/\/ #18\n+    Utf8 \"hashCode\"; \/\/ #19\n+    Utf8 \"(LR10;)I\"; \/\/ #20\n+    InvokeDynamic 0s #22; \/\/ #21\n+    NameAndType #23 #24; \/\/ #22\n+    Utf8 \"equals\"; \/\/ #23\n+    Utf8 \"(LR10;Ljava\/lang\/Object;)Z\"; \/\/ #24\n+    Utf8 \"Signature\"; \/\/ #25\n+    Utf8 \"Ljava\/util\/List<Ljava\/lang\/String;>;\"; \/\/ #26\n+    Utf8 \"(Ljava\/util\/List;)V\"; \/\/ #27\n+    Utf8 \"Code\"; \/\/ #28\n+    Utf8 \"LineNumberTable\"; \/\/ #29\n+    Utf8 \"MethodParameters\"; \/\/ #30\n+    Utf8 \"(Ljava\/util\/List<Ljava\/lang\/String;>;)V\"; \/\/ #31\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32\n+    Utf8 \"()I\"; \/\/ #33\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #34\n+    Utf8 \"()Ljava\/util\/List;\"; \/\/ #35\n+    Utf8 \"()Ljava\/util\/List<Ljava\/lang\/String;>;\"; \/\/ #36\n+    Utf8 \"SourceFile\"; \/\/ #37\n+    Utf8 \"R10.java\"; \/\/ #38\n+    Utf8 \"Record\"; \/\/ #39\n+    Utf8 \"BootstrapMethods\"; \/\/ #40\n+    MethodHandle 6b #42; \/\/ #41\n+    Method #43 #44; \/\/ #42\n+    class #45; \/\/ #43\n+    NameAndType #46 #47; \/\/ #44\n+    Utf8 \"java\/lang\/runtime\/ObjectMethods\"; \/\/ #45\n+    Utf8 \"bootstrap\"; \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/TypeDescriptor;Ljava\/lang\/Class;Ljava\/lang\/String;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/Object;\"; \/\/ #47\n+    String #11; \/\/ #48\n+    MethodHandle 1b #7; \/\/ #49\n+    Utf8 \"InnerClasses\"; \/\/ #50\n+    class #52; \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #52\n+    class #54; \/\/ #53\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #54\n+    Utf8 \"Lookup\"; \/\/ #55\n+  } \/\/ Constant Pool\n+\n+  0x0030; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0012; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Signature\n+          #26;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #27; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A2BB500;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#30) { \/\/ MethodParameters\n+          []b { \/\/ MethodParameters\n+            #11  0x0000; \/\/ the parameter is not mandated, flag should be 0x8000 for it to be mandated\n+          }\n+        } \/\/ end MethodParameters\n+        ;\n+        Attr(#25) { \/\/ Signature\n+          #31;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #15; \/\/ name_index\n+      #32; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA000D0000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #19; \/\/ name_index\n+      #33; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00110000AC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #23; \/\/ name_index\n+      #34; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2A2BBA00150000AC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #35; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#25) { \/\/ Signature\n+          #36;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#37) { \/\/ SourceFile\n+      #38;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#39) { \/\/ Record\n+      [] { \/\/ components\n+        {  \/\/ component\n+          #11; \/\/ name_index\n+          #12; \/\/ descriptor_index\n+          [] { \/\/ Attributes\n+            Attr(#25) { \/\/ Signature\n+              #26;\n+            } \/\/ end Signature\n+          } \/\/ Attributes\n+        }\n+      }\n+    } \/\/ end Record\n+    ;\n+    Attr(#40) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #41; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+            #8;\n+            #48;\n+            #49;\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#50) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #51 #53 #55 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class R10\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/R10.jcod","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8235369 8235550 8247444 8326879\n+ * @bug 8235369 8235550 8247444 8326879 8320575\n@@ -28,0 +28,1 @@\n+ * @build R10\n@@ -61,0 +62,21 @@\n+    record R9(List<String> ls) {\n+        R9 {} \/\/ compact constructor, will contain a mandated parameter\n+    }\n+\n+    \/* record R10 is defined in an accompaning jcod file, defined as:\n+    record R10(List<String> ls) { \/\/ in this case there wasn't be any compact constructor and thus no mandated param\n+    }\n+    *\/\n+\n+    record R11(int i, List<String> ls) {\n+        R11 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R12(List<String> ls, int i) {\n+        R12 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R13(List<String> ls1, int i, List<String> ls2) {\n+        R13 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n@@ -70,2 +92,7 @@\n-                       R8.class)\n-                   .stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n+                       R8.class,\n+                       R9.class,\n+                       R10.class,\n+                       R11.class,\n+                       R12.class,\n+                       R13.class\n+        ).stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n@@ -128,0 +155,28 @@\n+            new Object[] { new R9(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            \/* R10 has exactly the same definition as R9 but the parameter of the compact constructor doesn't have\n+             * the mandated flag, nevertheless we should be able to load the same generic information\n+             *\/\n+            new Object[] { new R10(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R11(1, List.of(\"1\")),\n+                        2,\n+                        new Object[]{ 1, List.of(\"1\") },\n+                        new String[]{ \"i\", \"ls\" },\n+                        new String[]{ \"int\", \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R12(List.of(\"1\"), 1),\n+                        2,\n+                        new Object[]{ List.of(\"1\"), 1 },\n+                        new String[]{ \"ls\", \"i\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\"} },\n+            new Object[] { new R13(List.of(\"1\"), 1, List.of(\"2\")),\n+                        3,\n+                        new Object[]{ List.of(\"1\"), 1, List.of(\"2\") },\n+                        new String[]{ \"ls1\", \"i\", \"ls2\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\", \"java.util.List<java.lang.String>\"} },\n@@ -153,0 +208,17 @@\n+        \/\/ now let's check constructors\n+        var constructor = recordClass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for (var p: constructor.getParameters()) {\n+            assertEquals(p.getParameterizedType().toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), signatures[i]));\n+            i++;\n+        }\n+        \/\/ similar as above but testing another API\n+        i = 0;\n+        for (var p : constructor.getGenericParameterTypes()) {\n+            assertEquals(p.toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.toString(), signatures[i]));\n+            i++;\n+        }\n@@ -205,1 +277,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":76,"deletions":5,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,2 @@\n- * @bug 8272215\n- * @summary Test for ofLiteral API in InetAddress classes\n+ * @bug 8272215 8315767\n+ * @summary Test for ofLiteral, ofPosixLiteral APIs in InetAddress classes\n@@ -70,0 +70,1 @@\n+            case INET4_ADDRESS_POSIX -> Inet4Address.ofPosixLiteral(addressLiteral);\n@@ -72,1 +73,0 @@\n-        InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n@@ -74,1 +74,5 @@\n-        Assert.assertEquals(getByNameResult, ofLiteralResult);\n+        \/\/ POSIX literals are not compatible with InetAddress.getByName()\n+        if (inetAddressClass != InetAddressClass.INET4_ADDRESS_POSIX) {\n+            InetAddress getByNameResult = InetAddress.getByName(addressLiteral);\n+            Assert.assertEquals(getByNameResult, ofLiteralResult);\n+        }\n@@ -104,0 +108,27 @@\n+        \/\/ 87.0.0.1 address bytes\n+        byte[] ipv4_87_0_0_1 = new byte[]{87, 0, 0, 1};\n+\n+        \/\/ 127.0.0.1 address bytes\n+        byte[] ipv4_127_0_0_1 = new byte[]{127, 0, 0, 1};\n+\n+        \/\/ 17.99.141.27 address bytes\n+        byte[] ipv4_17_99_141_27 = new byte[]{17, 99, (byte)141, 27};\n+\n+        \/\/ 127.8.0.1 address bytes\n+        byte[] ipv4_127_8_0_1 = new byte[]{127, 8, 0, 1};\n+\n+        \/\/ 0.0.0.42 address bytes\n+        byte[] ipv4_0_0_0_42 = new byte[]{0, 0, 0, 42};\n+\n+        \/\/ 0.0.0.34 address bytes\n+        byte[] ipv4_0_0_0_34 = new byte[]{0, 0, 0, 34};\n+\n+        \/\/ 127.0.1.2 address bytes\n+        byte[] ipv4_127_0_1_2 = new byte[]{127, 0, 1, 2};\n+\n+        \/\/ 127.1.2.3 address bytes\n+        byte[] ipv4_127_1_2_3 = new byte[]{127, 1, 2, 3};\n+\n+        \/\/ 255.255.255.255 address bytes\n+        byte[] ipv4_255_255_255_255 = new byte[]{(byte)255, (byte)255, (byte)255, (byte)255};\n+\n@@ -173,1 +204,81 @@\n-                        \"03735928559\", ipv4ExpBytes)\n+                        \"03735928559\", ipv4ExpBytes),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0127.0.0.1\", ipv4_87_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0.0.1\", ipv4_127_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0000.0000.0001\", ipv4_127_0_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"127.010.0.1\", ipv4_127_8_0_1),\n+                \/\/      form:'x.x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0377.0377.0377.0377\", ipv4_255_255_255_255),\n+                \/\/      form:'x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0.0402\", ipv4_127_0_1_2),\n+                \/\/      form:'x.x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hexadecimal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0x7F.0.0x102\", ipv4_127_0_1_2),\n+                \/\/      form:'x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0s treated as octal segment prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0177.0201003\", ipv4_127_1_2_3),\n+                \/\/      form:'x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hexadecimal prefixes\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0x7F.0x10203\", ipv4_127_1_2_3),\n+                \/\/      form:'x.x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without prefixes treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"127.66051\", ipv4_127_1_2_3),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"017700000001\", ipv4_127_0_0_1),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"02130706433\", ipv4_17_99_141_27),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"037777777777\", ipv4_255_255_255_255),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hex prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0x1020304\", oneToFourAddressExpBytes),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0x treated as hex prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0xFFFFFFFF\", ipv4_255_255_255_255),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without leading 0 treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"2130706433\", ipv4_127_0_0_1),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without leading 0 treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"42\", ipv4_0_0_0_42),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"0100401404\", oneToFourAddressExpBytes),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      without prefixes treated as decimal\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"16909060\", oneToFourAddressExpBytes),\n+                \/\/      form:'x' method:InetAddress.ofPosixLiteral -\n+                \/\/      with leading 0 treated as octal segment prefix\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX,\n+                        \"042\", ipv4_0_0_0_34)\n@@ -254,1 +365,12 @@\n-                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\")\n+                Arguments.of(InetAddressClass.INET4_ADDRESS, \"0xFFFFFFFF\"),\n+\n+                \/\/ invalid IPv4 literals in POSIX\/BSD form\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x100.1.2.3\"), \/\/ 0x100 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"1.2.3.0x100\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"127.08.9.1\"),  \/\/ 8, 9 are invalid octals\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"127.8.09.1\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"048\"),\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"\"),            \/\/ empty\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x1FFFFFFFF\"), \/\/ 2^33 - 1 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"0x100000000\"), \/\/ 2^32 is too large\n+                Arguments.of(InetAddressClass.INET4_ADDRESS_POSIX, \"040000000000\")\n@@ -300,0 +422,1 @@\n+            case INET4_ADDRESS_POSIX -> () -> Inet4Address.ofPosixLiteral(input);\n@@ -307,0 +430,1 @@\n+        INET4_ADDRESS_POSIX,\n","filename":"test\/jdk\/java\/net\/InetAddress\/OfLiteralTest.java","additions":131,"deletions":7,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug     4904067 5023830 7129185 8072015\n+ * @bug     4904067 5023830 7129185 8072015 8292955\n@@ -33,0 +33,1 @@\n+import org.testng.Assert;\n@@ -186,0 +187,7 @@\n+\n+    @Test(groups = \"type_check\")\n+    public static void testCheckedMapMerge() {\n+        Map m = Collections.checkedMap(new HashMap<>(), Integer.class, Integer.class);\n+        Assert.assertThrows(ClassCastException.class, () -> m.merge(\"key\", \"value\", (v1, v2) -> null));\n+        Assert.assertThrows(ClassCastException.class, () -> m.merge(\"key\", 3, (v1, v2) -> v2));\n+    }\n","filename":"test\/jdk\/java\/util\/Collections\/CheckedMapBash.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JEditorPane;\n+import javax.swing.text.View;\n+import javax.swing.text.html.CSS;\n+\n+\/*\n+ * @test\n+ * @bug 8326734\n+ * @summary Tests different combinations of setting 'line-through'\n+ * @run main HTMLStrikeOnly\n+ *\/\n+public class HTMLStrikeOnly {\n+    private static final String HTML = \"\"\"\n+            <!DOCTYPE html>\n+            <html lang=\"en\">\n+            <head>\n+                <meta charset=\"UTF-8\">\n+                <title>line-through<\/title>\n+                <style>\n+                    .lineThrough   { text-decoration: line-through }\n+                <\/style>\n+            <\/head>\n+            <body>\n+            <p><s><span style='text-decoration: line-through'>line-through?<\/span><\/s><\/p>\n+            <p><strike><span style='text-decoration: line-through'>line-through?<\/span><\/strike><\/p>\n+            <p><span style='text-decoration: line-through'><s>line-through?<\/s><\/span><\/p>\n+            <p><span style='text-decoration: line-through'><strike>line-through?<\/strike><\/span><\/p>\n+\n+            <p><s><span class=\"lineThrough\">line-through?<\/span><\/s><\/p>\n+            <p><strike><span class=\"lineThrough\">line-through?<\/span><\/strike><\/p>\n+            <p><span class=\"lineThrough\"><s>line-through?<\/s><\/span><\/p>\n+            <p><span class=\"lineThrough\"><strike>line-through?<\/strike><\/span><\/p>\n+\n+            <p style='text-decoration: line-through'><s>line-through?<\/s><\/p>\n+            <p style='text-decoration: line-through'><strike>line-through?<\/strike><\/p>\n+            <p style='text-decoration: line-through'><span style='text-decoration: line-through'>line-through?<\/span><\/p>\n+\n+            <p class=\"lineThrough\"><s>line-through<\/s><\/p>\n+            <p class=\"lineThrough\"><strike>line-through<\/strike><\/p>\n+            <p class=\"lineThrough\"><span style='text-decoration: line-through'>line-through<\/span><\/p>\n+            <p class=\"lineThrough\"><span class=\"lineThrough\">line-through<\/span><\/p>\n+            <\/body>\n+            <\/html>\n+            \"\"\";\n+    public static void main(String[] args) {\n+        final JEditorPane html = new JEditorPane(\"text\/html\", HTML);\n+        html.setEditable(false);\n+\n+        final Dimension size = html.getPreferredSize();\n+        html.setSize(size);\n+\n+        BufferedImage image = new BufferedImage(size.width, size.height,\n+                                                BufferedImage.TYPE_INT_RGB);\n+        Graphics g = image.createGraphics();\n+        \/\/ Paint the editor pane to ensure all views are created\n+        html.paint(g);\n+        g.dispose();\n+\n+        int errorCount = 0;\n+        String firstError = null;\n+\n+        System.out.println(\"----- Views -----\");\n+        final View bodyView = html.getUI()\n+                                  .getRootView(html)\n+                                  .getView(1)\n+                                  .getView(1);\n+        for (int i = 0; i < bodyView.getViewCount(); i++) {\n+            View pView = bodyView.getView(i);\n+            View contentView = getContentView(pView);\n+\n+            String decoration =\n+                    contentView.getAttributes()\n+                               .getAttribute(CSS.Attribute.TEXT_DECORATION)\n+                               .toString();\n+\n+            System.out.println(i + \": \" + decoration);\n+            if (!decoration.contains(\"line-through\")\n+                || decoration.contains(\"underline\")) {\n+                errorCount++;\n+                if (firstError == null) {\n+                    firstError = \"Line \" + i + \": \" + decoration;\n+                }\n+            }\n+        }\n+\n+        if (errorCount > 0) {\n+            saveImage(image);\n+            throw new RuntimeException(errorCount + \" error(s) found, \"\n+                                       + \"the first one: \" + firstError);\n+        }\n+    }\n+\n+    private static View getContentView(View parent) {\n+        View view = parent.getView(0);\n+        return view.getViewCount() > 0\n+               ? getContentView(view)\n+               : view;\n+    }\n+\n+    private static void saveImage(BufferedImage image) {\n+        try {\n+            ImageIO.write(image, \"png\",\n+                          new File(\"html.png\"));\n+        } catch (IOException ignored) { }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/HTMLDocument\/HTMLStrikeOnly.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JEditorPane;\n+import javax.swing.text.View;\n+import javax.swing.text.html.CSS;\n+\n+\/*\n+ * @test\n+ * @bug 8323801 8326734\n+ * @summary Tests different combination of 'underline' and 'line-through';\n+ *          the text should render with both 'underline' and 'line-through'.\n+ * @run main HTMLTextDecoration\n+ *\/\n+public final class HTMLTextDecoration {\n+    private static final String HTML = \"\"\"\n+            <!DOCTYPE html>\n+            <html lang=\"en\">\n+            <head>\n+                <meta charset=\"UTF-8\">\n+                <title>underline + line-through text<\/title>\n+                <style>\n+                    .underline   { text-decoration: underline }\n+                    .lineThrough { text-decoration: line-through }\n+                <\/style>\n+            <\/head>\n+            <body>\n+            <p><u><span style='text-decoration: line-through'>underline + line-through?<\/span><\/u><\/p>\n+            <p><s><span style='text-decoration: underline'>underline + line-through?<\/span><\/s><\/p>\n+            <p><strike><span style='text-decoration: underline'>underline + line-through?<\/span><\/strike><\/p>\n+\n+            <p><span style='text-decoration: line-through'><u>underline + line-through?<\/u><\/span><\/p>\n+            <p><span style='text-decoration: underline'><s>underline + line-through?<\/s><\/span><\/p>\n+            <p><span style='text-decoration: underline'><strike>underline + line-through?<\/strike><\/span><\/p>\n+\n+            <p><span style='text-decoration: line-through'><span style='text-decoration: underline'>underline + line-through?<\/span><\/span><\/p>\n+            <p><span style='text-decoration: underline'><span style='text-decoration: line-through'>underline + line-through?<\/span><\/span><\/p>\n+\n+            <p style='text-decoration: line-through'><u>underline + line-through?<\/u><\/p>\n+            <p style='text-decoration: underline'><s>underline + line-through?<\/s><\/p>\n+            <p style='text-decoration: underline'><strike>underline + line-through?<\/strike><\/p>\n+\n+            <p style='text-decoration: line-through'><span style='text-decoration: underline'>underline + line-through?<\/span><\/p>\n+            <p style='text-decoration: underline'><span style='text-decoration: line-through'>underline + line-through?<\/span><\/p>\n+\n+            <p class=\"underline\"><span class=\"lineThrough\">underline + line-through?<\/span><\/p>\n+            <p class=\"underline\"><s>underline + line-through?<\/s><\/p>\n+            <p class=\"underline\"><strike>underline + line-through?<\/strike><\/p>\n+\n+            <p class=\"lineThrough\"><span class=\"underline\">underline + line-through?<\/span><\/p>\n+            <p class=\"lineThrough\"><u>underline + line-through?<\/u><\/p>\n+\n+            <div class=\"underline\"><span class=\"lineThrough\">underline + line-through?<\/span><\/div>\n+            <div class=\"underline\"><s>underline + line-through?<\/s><\/div>\n+            <div class=\"underline\"><strike>underline + line-through?<\/strike><\/div>\n+\n+            <div class=\"lineThrough\"><span class=\"underline\">underline + line-through?<\/span><\/div>\n+            <div class=\"lineThrough\"><u>underline + line-through?<\/u><\/div>\n+\n+            <div class=\"underline\"><p class=\"lineThrough\">underline + line-through?<\/p><\/div>\n+            <div class=\"lineThrough\"><p class=\"underline\">underline + line-through?<\/p><\/div>\n+\n+            <div class=\"underline\"><div class=\"lineThrough\">underline + line-through?<\/div><\/div>\n+            <div class=\"lineThrough\"><div class=\"underline\">underline + line-through?<\/div><\/div>\n+            <\/body>\n+            <\/html>\n+            \"\"\";\n+\n+    public static void main(String[] args) {\n+        final JEditorPane html = new JEditorPane(\"text\/html\", HTML);\n+        html.setEditable(false);\n+\n+        final Dimension size = html.getPreferredSize();\n+        html.setSize(size);\n+\n+        BufferedImage image = new BufferedImage(size.width, size.height,\n+                                                BufferedImage.TYPE_INT_RGB);\n+        Graphics g = image.createGraphics();\n+        \/\/ Paint the editor pane to ensure all views are created\n+        html.paint(g);\n+        g.dispose();\n+\n+        int errorCount = 0;\n+        String firstError = null;\n+\n+        System.out.println(\"----- Views -----\");\n+        final View bodyView = html.getUI()\n+                                  .getRootView(html)\n+                                  .getView(1)\n+                                  .getView(1);\n+        for (int i = 0; i < bodyView.getViewCount(); i++) {\n+            View pView = bodyView.getView(i);\n+            View contentView = getContentView(pView);\n+\n+            String decoration =\n+                    contentView.getAttributes()\n+                               .getAttribute(CSS.Attribute.TEXT_DECORATION)\n+                               .toString();\n+\n+            System.out.println(i + \": \" + decoration);\n+            if (!decoration.contains(\"underline\")\n+                || !decoration.contains(\"line-through\")) {\n+                errorCount++;\n+                if (firstError == null) {\n+                    firstError = \"Line \" + i + \": \" + decoration;\n+                }\n+            }\n+        }\n+\n+        if (errorCount > 0) {\n+            saveImage(image);\n+            throw new RuntimeException(errorCount + \" error(s) found, \"\n+                                       + \"the first one: \" + firstError);\n+        }\n+    }\n+\n+    private static View getContentView(View parent) {\n+        View view = parent.getView(0);\n+        return view.getViewCount() > 0\n+               ? getContentView(view)\n+               : view;\n+    }\n+\n+    private static void saveImage(BufferedImage image) {\n+        try {\n+            ImageIO.write(image, \"png\",\n+                          new File(\"html.png\"));\n+        } catch (IOException ignored) { }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/HTMLDocument\/HTMLTextDecoration.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JEditorPane;\n+import javax.swing.text.View;\n+import javax.swing.text.html.CSS;\n+\n+\/*\n+ * @test\n+ * @bug 8326734\n+ * @summary Tests different combinations of setting 'underline'\n+ * @run main HTMLUnderlineOnly\n+ *\/\n+public class HTMLUnderlineOnly {\n+    private static final String HTML = \"\"\"\n+            <!DOCTYPE html>\n+            <html lang=\"en\">\n+            <head>\n+                <meta charset=\"UTF-8\">\n+                <title>underline<\/title>\n+                <style>\n+                    .underline   { text-decoration: underline }\n+                <\/style>\n+            <\/head>\n+            <body>\n+            <p><u><span style='text-decoration: underline'>underline?<\/span><\/u><\/p>\n+            <p><span style='text-decoration: underline'><u>underline?<\/u><\/span><\/p>\n+\n+            <p><u><span class=\"underline\">underline?<\/span><\/u><\/p>\n+            <p><span class=\"underline\"><u>underline?<\/u><\/span><\/p>\n+\n+            <p style='text-decoration: underline'><u>underline?<\/u><\/p>\n+            <p style='text-decoration: underline'><span style='text-decoration: underline'>underline?<\/span><\/p>\n+\n+            <p class=\"underline\"><u>underline<\/u><\/p>\n+            <p class=\"underline\"><span style='text-decoration: underline'>underline<\/span><\/p>\n+            <p class=\"underline\"><span class=\"underline\">underline<\/span><\/p>\n+            <\/body>\n+            <\/html>\n+            \"\"\";\n+    public static void main(String[] args) {\n+        final JEditorPane html = new JEditorPane(\"text\/html\", HTML);\n+        html.setEditable(false);\n+\n+        final Dimension size = html.getPreferredSize();\n+        html.setSize(size);\n+\n+        BufferedImage image = new BufferedImage(size.width, size.height,\n+                                                BufferedImage.TYPE_INT_RGB);\n+        Graphics g = image.createGraphics();\n+        \/\/ Paint the editor pane to ensure all views are created\n+        html.paint(g);\n+        g.dispose();\n+\n+        int errorCount = 0;\n+        String firstError = null;\n+\n+        System.out.println(\"----- Views -----\");\n+        final View bodyView = html.getUI()\n+                                  .getRootView(html)\n+                                  .getView(1)\n+                                  .getView(1);\n+        for (int i = 0; i < bodyView.getViewCount(); i++) {\n+            View pView = bodyView.getView(i);\n+            View contentView = getContentView(pView);\n+\n+            String decoration =\n+                    contentView.getAttributes()\n+                               .getAttribute(CSS.Attribute.TEXT_DECORATION)\n+                               .toString();\n+\n+            System.out.println(i + \": \" + decoration);\n+            if (!decoration.contains(\"underline\")\n+                || decoration.contains(\"line-through\")) {\n+                errorCount++;\n+                if (firstError == null) {\n+                    firstError = \"Line \" + i + \": \" + decoration;\n+                }\n+            }\n+        }\n+\n+        if (errorCount > 0) {\n+            saveImage(image);\n+            throw new RuntimeException(errorCount + \" error(s) found, \"\n+                                       + \"the first one: \" + firstError);\n+        }\n+    }\n+\n+    private static View getContentView(View parent) {\n+        View view = parent.getView(0);\n+        return view.getViewCount() > 0\n+               ? getContentView(view)\n+               : view;\n+    }\n+\n+    private static void saveImage(BufferedImage image) {\n+        try {\n+            ImageIO.write(image, \"png\",\n+                          new File(\"html.png\"));\n+        } catch (IOException ignored) { }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/HTMLDocument\/HTMLUnderlineOnly.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n- * @bug 8323801\n+ * @bug 8323801 8326734\n","filename":"test\/jdk\/javax\/swing\/text\/html\/HTMLDocument\/HTMLUnderlineStrike.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8332505\n@@ -68,0 +69,1 @@\n+import java.lang.runtime.ObjectMethods;\n@@ -123,1 +125,1 @@\n-            remapped.fields().forEach(f -> f.findAttribute(Attributes.SIGNATURE).ifPresent(sa ->\n+            remapped.fields().forEach(f -> f.findAttribute(Attributes.signature()).ifPresent(sa ->\n@@ -125,1 +127,1 @@\n-            remapped.methods().forEach(m -> m.findAttribute(Attributes.SIGNATURE).ifPresent(sa -> {\n+            remapped.methods().forEach(m -> m.findAttribute(Attributes.signature()).ifPresent(sa -> {\n@@ -176,1 +178,1 @@\n-                                                mab.uses(foo).provides(foo, foo)))))).findAttribute(Attributes.MODULE).get();\n+                                                mab.uses(foo).provides(foo, foo)))))).findAttribute(Attributes.module()).get();\n@@ -190,0 +192,1 @@\n+        var objectMethods = ClassDesc.ofDescriptor(ObjectMethods.class.descriptorString());\n@@ -192,1 +195,1 @@\n-                ClassRemapper.of(Map.of(foo, bar, fooAnno, barAnno)).remapClass(\n+                ClassRemapper.of(Map.of(foo, bar, fooAnno, barAnno, objectMethods, bar)).remapClass(\n@@ -214,1 +217,2 @@\n-                \"GETFIELD, owner: AdvancedTransformationsTest$Rec, field name: foo, field type: LAdvancedTransformationsTest$Bar;\");\n+                \"GETFIELD, owner: AdvancedTransformationsTest$Rec, field name: foo, field type: LAdvancedTransformationsTest$Bar;\",\n+                \"bootstrap method: STATIC AdvancedTransformationsTest$Bar::bootstrap\");\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        var annotations = model.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get().annotations();\n+        var annotations = model.findAttribute(Attributes.runtimeVisibleAnnotations()).get().annotations();\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationModelTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331291\n+ * @summary Testing Attributes API.\n+ * @run junit AttributesTest\n+ *\/\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.reflect.Field;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+\n+class AttributesTest {\n+\n+    @Test\n+    void testAttributesMapping() throws Exception {\n+        var cp = TemporaryConstantPool.INSTANCE;\n+        for (Field f : Attributes.class.getDeclaredFields()) {\n+            if (f.getName().startsWith(\"NAME_\") && f.getType() == String.class) {\n+                Utf8Entry attrName = cp.utf8Entry((String)f.get(null));\n+                AttributeMapper<?> mapper = BoundAttribute.standardAttribute(attrName);\n+                assertNotNull(mapper, attrName.stringValue() + \" 0x\" + Integer.toHexString(attrName.hashCode()));\n+                assertEquals(attrName.stringValue(), mapper.name());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/AttributesTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-                .findAttribute(Attributes.METHOD_PARAMETERS)\n+                .findAttribute(Attributes.methodParameters())\n","filename":"test\/jdk\/jdk\/classfile\/BoundAttributeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                case LineNumber ln -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LINE_NUMBER_TABLE) {\n+                case LineNumber ln -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.lineNumberTable()) {\n@@ -94,1 +94,1 @@\n-                case LocalVariable lv -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TABLE) {\n+                case LocalVariable lv -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTable()) {\n@@ -101,1 +101,1 @@\n-                case LocalVariableType lvt -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+                case LocalVariableType lvt -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTypeTable()) {\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,3 +69,3 @@\n-        code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).ifPresent(a -> assertTrue(a.localVariables().isEmpty()));\n-        code.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).ifPresent(a -> assertTrue(a.localVariableTypes().isEmpty()));\n-        code.findAttribute(Attributes.CHARACTER_RANGE_TABLE).ifPresent(a -> assertTrue(a.characterRangeTable().isEmpty()));\n+        code.findAttribute(Attributes.localVariableTable()).ifPresent(a -> assertTrue(a.localVariables().isEmpty()));\n+        code.findAttribute(Attributes.localVariableTypeTable()).ifPresent(a -> assertTrue(a.localVariableTypes().isEmpty()));\n+        code.findAttribute(Attributes.characterRangeTable()).ifPresent(a -> assertTrue(a.characterRangeTable().isEmpty()));\n","filename":"test\/jdk\/jdk\/classfile\/FilterDeadLabelsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-                        ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                        ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.code()) {\n@@ -155,1 +155,1 @@\n-                        ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                        ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.code()) {\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-            m.findAttribute(Attributes.CODE).ifPresent(code ->\n-                ((CodeModel) code).findAttribute(Attributes.CHARACTER_RANGE_TABLE).ifPresent(attr -> {\n+            m.findAttribute(Attributes.code()).ifPresent(code ->\n+                ((CodeModel) code).findAttribute(Attributes.characterRangeTable()).ifPresent(attr -> {\n@@ -159,1 +159,1 @@\n-\/\/            m.findAttribute(Attributes.CODE).ifPresent(code ->\n+\/\/            m.findAttribute(Attributes.code()).ifPresent(code ->\n","filename":"test\/jdk\/jdk\/classfile\/LowJCovAttributeTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-        var lvt = main.code().get().findAttribute(Attributes.LOCAL_VARIABLE_TABLE).get();\n+        var lvt = main.code().get().findAttribute(Attributes.localVariableTable()).get();\n@@ -281,1 +281,1 @@\n-        var lvtt = main.code().get().findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).get();\n+        var lvtt = main.code().get().findAttribute(Attributes.localVariableTypeTable()).get();\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        if (cm.findAttribute(Attributes.RECORD).isPresent()) {\n+        if (cm.findAttribute(Attributes.record()).isPresent()) {\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyPrimitiveMatchCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                .filter(a -> a.attributeMapper() == Attributes.MODULE)\n+                .filter(a -> a.attributeMapper() == Attributes.module())\n@@ -106,1 +106,1 @@\n-        var attr =cm.findAttribute(Attributes.MODULE).get();\n+        var attr =cm.findAttribute(Attributes.module()).get();\n@@ -184,1 +184,1 @@\n-        ModulePackagesAttribute a = moduleModel.findAttribute(Attributes.MODULE_PACKAGES).orElseThrow();\n+        ModulePackagesAttribute a = moduleModel.findAttribute(Attributes.modulePackages()).orElseThrow();\n@@ -190,1 +190,1 @@\n-        ModuleMainClassAttribute a = moduleModel.findAttribute(Attributes.MODULE_MAIN_CLASS).orElseThrow();\n+        ModuleMainClassAttribute a = moduleModel.findAttribute(Attributes.moduleMainClass()).orElseThrow();\n","filename":"test\/jdk\/jdk\/classfile\/ModuleBuilderTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-                cm.findAttribute(Attributes.SIGNATURE).ifPresent(csig -> {\n+                cm.findAttribute(Attributes.signature()).ifPresent(csig -> {\n@@ -144,1 +144,1 @@\n-                    m.findAttribute(Attributes.SIGNATURE).ifPresent(msig -> {\n+                    m.findAttribute(Attributes.signature()).ifPresent(msig -> {\n@@ -153,1 +153,1 @@\n-                    f.findAttribute(Attributes.SIGNATURE).ifPresent(fsig -> {\n+                    f.findAttribute(Attributes.signature()).ifPresent(fsig -> {\n@@ -161,2 +161,2 @@\n-                cm.findAttribute(Attributes.RECORD).ifPresent(reca\n-                        -> reca.components().forEach(rc -> rc.findAttribute(Attributes.SIGNATURE).ifPresent(rsig -> {\n+                cm.findAttribute(Attributes.record()).ifPresent(reca\n+                        -> reca.components().forEach(rc -> rc.findAttribute(Attributes.signature()).ifPresent(rsig -> {\n@@ -185,1 +185,1 @@\n-        var sig = observerCf.findAttribute(Attributes.SIGNATURE).orElseThrow().asClassSignature();\n+        var sig = observerCf.findAttribute(Attributes.signature()).orElseThrow().asClassSignature();\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-        RecordAttribute ra = newModel.findAttribute(Attributes.RECORD).orElseThrow();\n+        RecordAttribute ra = newModel.findAttribute(Attributes.record()).orElseThrow();\n@@ -113,1 +113,1 @@\n-        assertEquals(cm.findAttribute(Attributes.RECORD).orElseThrow().components().size(), 2);\n+        assertEquals(cm.findAttribute(Attributes.record()).orElseThrow().components().size(), 2);\n","filename":"test\/jdk\/jdk\/classfile\/TestRecordComponent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,2 +57,3 @@\n-        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        var rvaa = m.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -71,3 +72,3 @@\n-\n-        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        var rvaa = m.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -81,3 +82,3 @@\n-\n-        if (m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        rvaa = m2.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -115,3 +116,3 @@\n-\n-        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n-            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+        var rvaa = m.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (rvaa.isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = rvaa.get();\n@@ -138,1 +139,1 @@\n-        int size = m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow().annotations().size();\n+        int size = m2.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow().annotations().size();\n","filename":"test\/jdk\/jdk\/classfile\/examples\/AnnotationsExamples.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        ModuleAttribute ma = cm.findAttribute(Attributes.MODULE).orElseThrow();\n+        ModuleAttribute ma = cm.findAttribute(Attributes.module()).orElseThrow();\n@@ -61,1 +61,1 @@\n-        ModuleMainClassAttribute mmca = cm.findAttribute(Attributes.MODULE_MAIN_CLASS).orElse(null);\n+        ModuleMainClassAttribute mmca = cm.findAttribute(Attributes.moduleMainClass()).orElse(null);\n@@ -64,1 +64,1 @@\n-        ModulePackagesAttribute mmp = cm.findAttribute(Attributes.MODULE_PACKAGES).orElseThrow();\n+        ModulePackagesAttribute mmp = cm.findAttribute(Attributes.modulePackages()).orElseThrow();\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ModuleExamples.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-                    mapAttr(attrs, ANNOTATION_DEFAULT, a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n+                    mapAttr(attrs, annotationDefault(), a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n@@ -248,18 +248,18 @@\n-                    mapAttr(attrs, CODE, a -> CodeRecord.ofStreamingElements(a.maxStack(), a.maxLocals(), a.codeLength(), a::elementStream, a, new CodeNormalizerHelper(a.codeArray()), cf)),\n-                    mapAttr(attrs, COMPILATION_ID, a -> a.compilationId().stringValue()),\n-                    mapAttr(attrs, CONSTANT_VALUE, a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n-                    mapAttr(attrs, DEPRECATED, a -> DefinedValue.DEFINED),\n-                    mapAttr(attrs, ENCLOSING_METHOD, a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n-                    mapAttr(attrs, EXCEPTIONS, a -> new HashSet<>(a.exceptions().stream().map(e -> e.asInternalName()).toList())),\n-                    mapAttr(attrs, INNER_CLASSES, a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n-                    mapAttr(attrs, METHOD_PARAMETERS, a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n-                    mapAttr(attrs, MODULE, a -> ModuleRecord.ofModuleAttribute(a)),\n-                    mapAttr(attrs, MODULE_HASHES, a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n-                    mapAttr(attrs, MODULE_MAIN_CLASS, a -> a.mainClass().asInternalName()),\n-                    mapAttr(attrs, MODULE_PACKAGES, a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n-                    mapAttr(attrs, MODULE_RESOLUTION, a -> a.resolutionFlags()),\n-                    mapAttr(attrs, MODULE_TARGET, a -> a.targetPlatform().stringValue()),\n-                    mapAttr(attrs, NEST_HOST, a -> a.nestHost().asInternalName()),\n-                    mapAttr(attrs, NEST_MEMBERS, a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n-                    mapAttr(attrs, PERMITTED_SUBCLASSES, a -> new HashSet<>(a.permittedSubclasses().stream().map(e -> e.asInternalName()).toList())),\n-                    mapAttr(attrs, RECORD, a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n+                    mapAttr(attrs, code(), a -> CodeRecord.ofStreamingElements(a.maxStack(), a.maxLocals(), a.codeLength(), a::elementStream, a, new CodeNormalizerHelper(a.codeArray()), cf)),\n+                    mapAttr(attrs, compilationId(), a -> a.compilationId().stringValue()),\n+                    mapAttr(attrs, constantValue(), a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n+                    mapAttr(attrs, Attributes.deprecated(), a -> DefinedValue.DEFINED),\n+                    mapAttr(attrs, enclosingMethod(), a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n+                    mapAttr(attrs, exceptions(), a -> new HashSet<>(a.exceptions().stream().map(e -> e.asInternalName()).toList())),\n+                    mapAttr(attrs, innerClasses(), a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n+                    mapAttr(attrs, methodParameters(), a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n+                    mapAttr(attrs, module(), a -> ModuleRecord.ofModuleAttribute(a)),\n+                    mapAttr(attrs, moduleHashes(), a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n+                    mapAttr(attrs, moduleMainClass(), a -> a.mainClass().asInternalName()),\n+                    mapAttr(attrs, modulePackages(), a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n+                    mapAttr(attrs, moduleResolution(), a -> a.resolutionFlags()),\n+                    mapAttr(attrs, moduleTarget(), a -> a.targetPlatform().stringValue()),\n+                    mapAttr(attrs, nestHost(), a -> a.nestHost().asInternalName()),\n+                    mapAttr(attrs, nestMembers(), a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n+                    mapAttr(attrs, permittedSubclasses(), a -> new HashSet<>(a.permittedSubclasses().stream().map(e -> e.asInternalName()).toList())),\n+                    mapAttr(attrs, record(), a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n@@ -270,9 +270,9 @@\n-                    mapAttr(attrs, RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    mapAttr(attrs, RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    mapAttr(attrs, RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    mapAttr(attrs, RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    mapAttr(attrs, SIGNATURE, a -> a.signature().stringValue()),\n-                    mapAttr(attrs, SOURCE_DEBUG_EXTENSION, a -> new String(a.contents(), StandardCharsets.UTF_8)),\n-                    mapAttr(attrs, SOURCE_FILE, a -> a.sourceFile().stringValue()),\n-                    mapAttr(attrs, SOURCE_ID, a -> a.sourceId().stringValue()),\n-                    mapAttr(attrs, SYNTHETIC, a -> DefinedValue.DEFINED)\n+                    mapAttr(attrs, runtimeVisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    mapAttr(attrs, runtimeInvisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    mapAttr(attrs, runtimeVisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    mapAttr(attrs, runtimeInvisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    mapAttr(attrs, signature(), a -> a.signature().stringValue()),\n+                    mapAttr(attrs, sourceDebugExtension(), a -> new String(a.contents(), StandardCharsets.UTF_8)),\n+                    mapAttr(attrs, sourceFile(), a -> a.sourceFile().stringValue()),\n+                    mapAttr(attrs, sourceId(), a -> a.sourceId().stringValue()),\n+                    mapAttr(attrs, synthetic(), a -> DefinedValue.DEFINED)\n@@ -284,31 +284,31 @@\n-                    af.findAndMap(Attributes.ANNOTATION_DEFAULT, a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n-                    af.findAndMap(Attributes.BOOTSTRAP_METHODS, a -> a.bootstrapMethods().stream().map(bm -> BootstrapMethodRecord.ofBootstrapMethodEntry(bm)).collect(toSet())),\n-                    af.findAndMap(Attributes.CODE, a -> CodeRecord.ofCodeAttribute(a, cf)),\n-                    af.findAndMap(Attributes.COMPILATION_ID, a -> a.compilationId().stringValue()),\n-                    af.findAndMap(Attributes.CONSTANT_VALUE, a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n-                    af.findAndMap(Attributes.DEPRECATED, a -> DefinedValue.DEFINED),\n-                    af.findAndMap(Attributes.ENCLOSING_METHOD, a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n-                    af.findAndMap(Attributes.EXCEPTIONS, a -> a.exceptions().stream().map(e -> e.asInternalName()).collect(toSet())),\n-                    af.findAndMap(Attributes.INNER_CLASSES, a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n-                    af.findAndMap(Attributes.METHOD_PARAMETERS, a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n-                    af.findAndMap(Attributes.MODULE, a -> ModuleRecord.ofModuleAttribute(a)),\n-                    af.findAndMap(Attributes.MODULE_HASHES, a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n-                    af.findAndMap(Attributes.MODULE_MAIN_CLASS, a -> a.mainClass().asInternalName()),\n-                    af.findAndMap(Attributes.MODULE_PACKAGES, a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n-                    af.findAndMap(Attributes.MODULE_RESOLUTION, a -> a.resolutionFlags()),\n-                    af.findAndMap(Attributes.MODULE_TARGET, a -> a.targetPlatform().stringValue()),\n-                    af.findAndMap(Attributes.NEST_HOST, a -> a.nestHost().asInternalName()),\n-                    af.findAndMap(Attributes.NEST_MEMBERS, a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n-                    af.findAndMap(Attributes.PERMITTED_SUBCLASSES, a -> a.permittedSubclasses().stream().map(e -> e.asInternalName()).collect(toSet())),\n-                    af.findAndMap(RECORD, a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n-                    af.findAll(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n-                    af.findAll(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n-                    af.findAndMap(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n-                    af.findAndMap(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n-                    af.findAndMap(Attributes.SIGNATURE, a -> a.signature().stringValue()),\n-                    af.findAndMap(Attributes.SOURCE_DEBUG_EXTENSION, a -> new String(a.contents(), StandardCharsets.UTF_8)),\n-                    af.findAndMap(Attributes.SOURCE_FILE, a -> a.sourceFile().stringValue()),\n-                    af.findAndMap(Attributes.SOURCE_ID, a -> a.sourceId().stringValue()),\n-                    af.findAndMap(Attributes.SYNTHETIC, a -> DefinedValue.DEFINED));\n+                    af.findAndMap(annotationDefault(), a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n+                    af.findAndMap(bootstrapMethods(), a -> a.bootstrapMethods().stream().map(bm -> BootstrapMethodRecord.ofBootstrapMethodEntry(bm)).collect(toSet())),\n+                    af.findAndMap(code(), a -> CodeRecord.ofCodeAttribute(a, cf)),\n+                    af.findAndMap(compilationId(), a -> a.compilationId().stringValue()),\n+                    af.findAndMap(constantValue(), a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n+                    af.findAndMap(Attributes.deprecated(), a -> DefinedValue.DEFINED),\n+                    af.findAndMap(enclosingMethod(), a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n+                    af.findAndMap(exceptions(), a -> a.exceptions().stream().map(e -> e.asInternalName()).collect(toSet())),\n+                    af.findAndMap(innerClasses(), a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n+                    af.findAndMap(methodParameters(), a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n+                    af.findAndMap(module(), a -> ModuleRecord.ofModuleAttribute(a)),\n+                    af.findAndMap(moduleHashes(), a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n+                    af.findAndMap(moduleMainClass(), a -> a.mainClass().asInternalName()),\n+                    af.findAndMap(modulePackages(), a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n+                    af.findAndMap(moduleResolution(), a -> a.resolutionFlags()),\n+                    af.findAndMap(moduleTarget(), a -> a.targetPlatform().stringValue()),\n+                    af.findAndMap(nestHost(), a -> a.nestHost().asInternalName()),\n+                    af.findAndMap(nestMembers(), a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n+                    af.findAndMap(permittedSubclasses(), a -> a.permittedSubclasses().stream().map(e -> e.asInternalName()).collect(toSet())),\n+                    af.findAndMap(record(), a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n+                    af.findAll(runtimeVisibleAnnotations()).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    af.findAll(runtimeInvisibleAnnotations()).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    af.findAndMap(runtimeVisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    af.findAndMap(runtimeInvisibleParameterAnnotations(), a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    af.findAndMap(runtimeVisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    af.findAndMap(runtimeInvisibleTypeAnnotations(), a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    af.findAndMap(signature(), a -> a.signature().stringValue()),\n+                    af.findAndMap(sourceDebugExtension(), a -> new String(a.contents(), StandardCharsets.UTF_8)),\n+                    af.findAndMap(sourceFile(), a -> a.sourceFile().stringValue()),\n+                    af.findAndMap(sourceId(), a -> a.sourceId().stringValue()),\n+                    af.findAndMap(synthetic(), a -> DefinedValue.DEFINED));\n@@ -356,6 +356,6 @@\n-                    af.findAll(Attributes.CHARACTER_RANGE_TABLE).flatMap(a -> a.characterRangeTable().stream()).map(cr -> CharacterRangeRecord.ofCharacterRange(cr, code)).collect(toSetOrNull()),\n-                    af.findAll(Attributes.LINE_NUMBER_TABLE).flatMap(a -> a.lineNumbers().stream()).map(ln -> new LineNumberRecord(ln.lineNumber(), code.targetIndex(ln.startPc()))).collect(toSetOrNull()),\n-                    af.findAll(Attributes.LOCAL_VARIABLE_TABLE).flatMap(a -> a.localVariables().stream()).map(lv -> LocalVariableRecord.ofLocalVariableInfo(lv, code)).collect(toSetOrNull()),\n-                    af.findAll(Attributes.LOCAL_VARIABLE_TYPE_TABLE).flatMap(a -> a.localVariableTypes().stream()).map(lv -> LocalVariableTypeRecord.ofLocalVariableTypeInfo(lv, code)).collect(toSetOrNull()),\n-                    af.findAndMap(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())),\n-                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())));\n+                    af.findAll(Attributes.characterRangeTable()).flatMap(a -> a.characterRangeTable().stream()).map(cr -> CharacterRangeRecord.ofCharacterRange(cr, code)).collect(toSetOrNull()),\n+                    af.findAll(Attributes.lineNumberTable()).flatMap(a -> a.lineNumbers().stream()).map(ln -> new LineNumberRecord(ln.lineNumber(), code.targetIndex(ln.startPc()))).collect(toSetOrNull()),\n+                    af.findAll(Attributes.localVariableTable()).flatMap(a -> a.localVariables().stream()).map(lv -> LocalVariableRecord.ofLocalVariableInfo(lv, code)).collect(toSetOrNull()),\n+                    af.findAll(Attributes.localVariableTypeTable()).flatMap(a -> a.localVariableTypes().stream()).map(lv -> LocalVariableTypeRecord.ofLocalVariableTypeInfo(lv, code)).collect(toSetOrNull()),\n+                    af.findAndMap(Attributes.runtimeVisibleTypeAnnotations(), a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())),\n+                    af.findAndMap(Attributes.runtimeInvisibleTypeAnnotations(), a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                                                com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(cob4::with);\n+                                                com.findAttribute(Attributes.stackMapTable()).ifPresent(cob4::with);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-        var attr = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+        var attr = m.findAttribute(Attributes.runtimeVisibleAnnotations()).orElse(null);\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CallerSensitiveFinder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-        var attr = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+        var attr = m.findAttribute(Attributes.runtimeVisibleAnnotations()).orElse(null);\n@@ -253,1 +253,1 @@\n-        var attr = m.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n+        var attr = m.findAttribute(Attributes.runtimeInvisibleAnnotations()).orElse(null);\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CheckCSMs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.gc.detailed;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.GCHelper;\n+\n+\/**\n+ * @test\n+ * @bug 8330577\n+ * @requires vm.hasJFR\n+ * @requires vm.gc == \"G1\" | vm.gc == null\n+ * @requires vm.debug\n+ * @key jfr\n+ * @library \/test\/lib \/test\/jdk\n+ * @summary Make sure that there are no Old->Old and Free->Free events sent.\n+ * @run main\/othervm -XX:+G1GCAllocationFailureALot -XX:NewSize=2m -XX:MaxNewSize=2m -XX:MaxTenuringThreshold=1\n+ *                   -Xmx32m -XX:G1HeapRegionSize=1m -XX:+UseG1GC -Xlog:gc jdk.jfr.event.gc.detailed.TestG1InvalidHeapRegionTypeChangeEvent\n+ *\/\n+\n+public class TestG1InvalidHeapRegionTypeChangeEvent {\n+    private final static String EVENT_NAME = EventNames.G1HeapRegionTypeChange;\n+\n+    public static void main(String[] args) throws Exception {\n+        Recording recording = null;\n+        try {\n+            recording = new Recording();\n+            \/\/ activate the event we are interested in and start recording\n+            recording.enable(EVENT_NAME).withThreshold(Duration.ofMillis(0));\n+            recording.start();\n+\n+            \/\/ Compact the heap, creating some Old regions. Previously this sent\n+            \/\/ Free->Free transitions too.\n+            System.gc();\n+\n+            \/\/ Setting NewSize and MaxNewSize will limit eden, so\n+            \/\/ allocating 1024 20k byte arrays should trigger at\n+            \/\/ least a few Young GCs.\n+            \/\/ This fragments the heap a little (together with\n+            \/\/ G1GCAllocationFailureALot), so that the next Full GC\n+            \/\/ will generate Free -> Old transitions that were incorrectly\n+            \/\/ sent as Old -> Old.\n+            \/\/ Note that an Old -> Old transition is actually valid in case\n+            \/\/ of evacuation failure in an old region, but this is no\n+            \/\/ change of region and should not be sent either.\n+\n+            byte[][] array = new byte[1024][];\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = new byte[20 * 1024];\n+            }\n+\n+            System.gc();\n+            recording.stop();\n+\n+            \/\/ Verify recording\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            Asserts.assertFalse(events.isEmpty(), \"No events found\");\n+\n+            for (RecordedEvent event : events) {\n+                Events.assertField(event, \"index\").notEqual(-1);\n+                Asserts.assertTrue(GCHelper.isValidG1HeapRegionType(Events.assertField(event, \"from\").getValue()));\n+                Asserts.assertTrue(GCHelper.isValidG1HeapRegionType(Events.assertField(event, \"to\").getValue()));\n+                Events.assertField(event, \"used\").atMost(1L*1024*1024);\n+                \/\/ There should be no Old->Old and Free->Free \"changes\".\n+                Asserts.assertFalse(Events.assertField(event, \"from\").getValue().equals(\"Old\") && Events.assertField(event, \"to\").getValue().equals(\"Old\"));\n+                Asserts.assertFalse(Events.assertField(event, \"from\").getValue().equals(\"Free\") && Events.assertField(event, \"to\").getValue().equals(\"Free\"));\n+            }\n+        } catch (Throwable t) {\n+            if (recording != null) {\n+                recording.dump(Paths.get(\"TestG1HeapRegionTypeChangeEvent.jfr\"));\n+            }\n+            throw t;\n+        } finally {\n+            if (recording != null) {\n+                recording.close();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestG1InvalidHeapRegionTypeChangeEvent.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm jdk.jfr.event.oldobject.TestSanityDefault\n+ * @run main\/othervm -Xmx1G jdk.jfr.event.oldobject.TestSanityDefault\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestSanityDefault.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.ByteBuffer;\n+import sun.misc.Unsafe;\n+\n+\/**\n+ * Launched by UnsafeMemoryAccessWarnings with a '+' delimited list of methods to invoke.\n+ *\/\n+@SuppressWarnings(\"removal\")\n+public class TryUnsafeMemoryAccess {\n+    private static final Unsafe UNSAFE;\n+    static {\n+        try {\n+            Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            f.setAccessible(true);\n+            UNSAFE = (Unsafe) f.get(null);\n+        } catch (Exception e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+    private static long address;\n+    private static long offset;\n+\n+    static class TestClass {\n+        long value;\n+        TestClass(long value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    \/**\n+     * The argument is a list of names of no-arg static methods in this class to invoke.\n+     * The names are separated with a '+'.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        String[] methodNames = args[0].split(\"\\\\+\");\n+        for (String methodName : methodNames) {\n+            Method m = TryUnsafeMemoryAccess.class.getDeclaredMethod(methodName);\n+            try {\n+                m.invoke(null);\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    \/\/ a selection of Unsafe memory access methods to test\n+\n+    static void allocateMemory() {\n+        address = UNSAFE.allocateMemory(100);\n+    }\n+\n+    static void freeMemory() {\n+        if (address == 0)\n+            throw new RuntimeException(\"allocateMemory not called\");\n+        UNSAFE.freeMemory(address);\n+    }\n+\n+    static void objectFieldOffset() throws Exception {\n+        Field f = TestClass.class.getDeclaredField(\"value\");\n+        offset = UNSAFE.objectFieldOffset(f);\n+    }\n+\n+    static void getLong() {\n+        if (offset == 0)\n+            throw new RuntimeException(\"objectFieldOffset not called\");\n+        var obj = new TestClass(99);\n+        long value = UNSAFE.getLong(obj, offset);\n+        if (value != 99) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    static void putLong() {\n+        if (offset == 0)\n+            throw new RuntimeException(\"objectFieldOffset not called\");\n+        var obj = new TestClass(0);\n+        UNSAFE.putLong(obj, offset, 99);\n+        if (obj.value != 99) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    static void invokeCleaner() {\n+        var dbb = ByteBuffer.allocateDirect(1000);\n+        UNSAFE.invokeCleaner(dbb);\n+    }\n+\n+    \/**\n+     * Invoke Unsafe.allocateMemory reflectively.\n+     *\/\n+    static void reflectivelyAllocateMemory() throws Exception {\n+        Method allocateMemory = Unsafe.class.getMethod(\"allocateMemory\", long.class);\n+        address = (long) allocateMemory.invoke(UNSAFE, 100);\n+    }\n+\n+    \/**\n+     * Invoke Unsafe.freeMemory reflectively.\n+     *\/\n+    static void reflectivelyFreeMemory() throws Exception {\n+        if (address == 0)\n+            throw new RuntimeException(\"allocateMemory not called\");\n+        Method freeMemory = Unsafe.class.getMethod(\"freeMemory\", long.class);\n+        freeMemory.invoke(UNSAFE, address);\n+    }\n+\n+    \/**\n+     * Used to test that the property value from startup is used.\n+     *\/\n+    static void setSystemPropertyToAllow() {\n+        System.setProperty(\"sun.misc.unsafe.memory.access\", \"allow\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/misc\/TryUnsafeMemoryAccess.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331670\n+ * @summary Basic test for --sun-misc-unsafe-memory-access=<value>\n+ * @library \/test\/lib\n+ * @compile TryUnsafeMemoryAccess.java\n+ * @run junit UnsafeMemoryAccessWarnings\n+ *\/\n+\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+class UnsafeMemoryAccessWarnings {\n+\n+    \/**\n+     * Test default is \"allow\"\n+     *\/\n+    @Test\n+    void testDefault() throws Exception {\n+        test(\"allocateMemory+freeMemory+objectFieldOffset+putLong+getLong+invokeCleaner\")\n+            .shouldHaveExitValue(0)\n+            .shouldNotContain(\"WARNING: A terminally deprecated method in sun.misc.Unsafe has been called\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::allocateMemory\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::freeMemory\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::objectFieldOffset\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::putLong\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::getLong\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::invokeCleaner\");\n+    }\n+\n+    \/**\n+     * Test --sun-misc-unsafe-memory-access=allow\n+     *\/\n+    @Test\n+    void testAllow() throws Exception {\n+        test(\"allocateMemory+freeMemory+objectFieldOffset+putLong+getLong+invokeCleaner\",\n+                \"--sun-misc-unsafe-memory-access=allow\")\n+            .shouldHaveExitValue(0)\n+            .shouldNotContain(\"WARNING: A terminally deprecated method in sun.misc.Unsafe has been called\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::allocateMemory\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::freeMemory\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::objectFieldOffset\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::putLong\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::getLong\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::invokeCleaner\");\n+    }\n+\n+    \/**\n+     * Test --sun-misc-unsafe-memory-access=warn\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"allocateMemory+freeMemory\",\n+            \"objectFieldOffset+putLong+getLong\",\n+            \"invokeCleaner\"\n+    })\n+    void testWarn(String input) throws Exception {\n+        var output = test(input, \"--sun-misc-unsafe-memory-access=warn\").shouldHaveExitValue(0);\n+\n+        \/\/ should be warning printed for the first memory access method\n+        String[] methodNames = input.split(\"\\\\+\");\n+        String firstMethodName = methodNames[0];\n+        output.shouldContain(\"WARNING: A terminally deprecated method in sun.misc.Unsafe has been called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::\" + firstMethodName + \" has been called by\")\n+            .shouldContain(\"WARNING: Please consider reporting this to the maintainers of\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::\" + firstMethodName + \" will be removed in a future release\");\n+\n+        \/\/ should be no warning for the second\/subsequent memory access methods\n+        int index = 1;\n+        while (index < methodNames.length) {\n+            String methodName = methodNames[index++];\n+            output.shouldNotContain(\"WARNING: sun.misc.Unsafe::\" + methodName);\n+        }\n+    }\n+\n+    \/**\n+     * Test --sun-misc-unsafe-memory-access=debug\n+     *\/\n+    @Test\n+    void testDebug() throws Exception {\n+        test(\"allocateMemory+freeMemory+objectFieldOffset+putLong+getLong+invokeCleaner\",\n+                \"--sun-misc-unsafe-memory-access=debug\")\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::allocateMemory called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::freeMemory called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::objectFieldOffset called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::putLong called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::getLong called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::invokeCleaner called\");\n+    }\n+\n+    \/**\n+     * Test --sun-misc-unsafe-memory-access=deny\n+     *\/\n+    @Test\n+    void testDeny() throws Exception {\n+        test(\"allocateMemory+objectFieldOffset+invokeCleaner\", \"--sun-misc-unsafe-memory-access=deny\")\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"java.lang.UnsupportedOperationException: allocateMemory\")\n+            .shouldContain(\"java.lang.UnsupportedOperationException: objectFieldOffset\")\n+            .shouldContain(\"java.lang.UnsupportedOperationException: invokeCleaner\");\n+    }\n+\n+    \/**\n+     * Test invoking Unsafe methods with core reflection.\n+     *\/\n+    @Test\n+    void testInvokeReflectively() throws Exception {\n+        test(\"reflectivelyAllocateMemory+reflectivelyFreeMemory\", \"--sun-misc-unsafe-memory-access=allow\")\n+            .shouldHaveExitValue(0)\n+            .shouldNotContain(\"WARNING: A terminally deprecated method in sun.misc.Unsafe has been called\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::allocateMemory\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::freeMemory\");\n+\n+        test(\"reflectivelyAllocateMemory+reflectivelyFreeMemory\", \"--sun-misc-unsafe-memory-access=warn\")\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"WARNING: A terminally deprecated method in sun.misc.Unsafe has been called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::allocateMemory has been called by\")\n+            .shouldContain(\"WARNING: Please consider reporting this to the maintainers of\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::allocateMemory will be removed in a future release\")\n+            .shouldNotContain(\"WARNING: sun.misc.Unsafe::freeMemory\");\n+\n+        test(\"reflectivelyAllocateMemory+reflectivelyFreeMemory\", \"--sun-misc-unsafe-memory-access=debug\")\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::allocateMemory called\")\n+            .shouldContain(\"WARNING: sun.misc.Unsafe::freeMemory called\");\n+\n+        test(\"reflectivelyAllocateMemory\", \"--sun-misc-unsafe-memory-access=deny\")\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"java.lang.UnsupportedOperationException: allocateMemory\");\n+    }\n+\n+    \/**\n+     * If --sun-misc-unsafe-memory-access specified more than once then last one wins.\n+     *\/\n+    @Test\n+    void testLastOneWins() throws Exception {\n+        test(\"allocateMemory+objectFieldOffset+invokeCleaner\",\n+                \"--sun-misc-unsafe-memory-access=allow\",\n+                \"--sun-misc-unsafe-memory-access=deny\")\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"java.lang.UnsupportedOperationException: allocateMemory\")\n+            .shouldContain(\"java.lang.UnsupportedOperationException: objectFieldOffset\")\n+            .shouldContain(\"java.lang.UnsupportedOperationException: invokeCleaner\");\n+    }\n+\n+    \/**\n+     * Test --sun-misc-unsafe-memory-access with invalid values.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"\", \"bad\" })\n+    void testInvalidValues(String value) throws Exception {\n+        test(\"allocateMemory\", \"--sun-misc-unsafe-memory-access=\" + value)\n+            .shouldNotHaveExitValue(0)\n+            .shouldContain(\"Value specified to --sun-misc-unsafe-memory-access not recognized: '\" + value);\n+    }\n+\n+    \/**\n+     * Test System.setProperty(\"sun.misc.unsafe.memory.access\", \"allow\")\n+     * The saved value from startup should be used, not the system property set at run-time.\n+     *\/\n+    @Test\n+    void testSetPropertyToAllow() throws Exception {\n+        test(\"setSystemPropertyToAllow+objectFieldOffset\", \"--sun-misc-unsafe-memory-access=deny\")\n+            .shouldHaveExitValue(0)\n+            .shouldContain(\"java.lang.UnsupportedOperationException: objectFieldOffset\");\n+    }\n+\n+    \/**\n+     * Launch TryUnsafeMemoryAccess with the given arguments and VM options.\n+     *\/\n+    private OutputAnalyzer test(String action, String... vmopts) throws Exception {\n+        Stream<String> s1 = Stream.of(vmopts);\n+        Stream<String> s2 = Stream.of(\"TryUnsafeMemoryAccess\", action);\n+        String[] opts = Stream.concat(s1, s2).toArray(String[]::new);\n+        var outputAnalyzer = ProcessTools\n+                .executeTestJava(opts)\n+                .outputTo(System.err)\n+                .errorTo(System.err);\n+        return outputAnalyzer;\n+    }\n+}\n","filename":"test\/jdk\/sun\/misc\/UnsafeMemoryAccessWarnings.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331975\n+ * @summary ensure correct name comparison when a system property is set\n+ * @library \/test\/lib\n+ * @compile -XDignore.symbol.file CaseSensitive.java\n+ * @run main jdk.test.lib.FileInstaller TestHosts TestHosts\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts CaseSensitive no\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\n+ *      -Djdk.security.krb5.name.case.sensitive=true CaseSensitive yes\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import org.ietf.jgss.GSSException;\n+import sun.security.jgss.GSSUtil;\n+\n+public class CaseSensitive {\n+\n+    public static void main(String[] args) throws Exception {\n+        switch (args[0]) {\n+            case \"yes\" -> testSensitive();\n+            case \"no\" -> testInsensitive();\n+        }\n+    }\n+\n+    static void testSensitive() throws Exception {\n+        var kdc = new OneKDC(null).writeJAASConf();\n+        kdc.addPrincipal(\"hello\", \"password\".toCharArray());\n+        kdc.writeKtab(OneKDC.KTAB);\n+\n+        Context c = Context.fromJAAS(\"client\");\n+        Context s = Context.fromJAAS(\"com.sun.security.jgss.krb5.accept\");\n+\n+        \/\/ There is only \"hello\". Cannot talk to \"HELLO\"\n+        c.startAsClient(\"HELLO\", GSSUtil.GSS_KRB5_MECH_OID);\n+        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        try {\n+            Context.handshake(c, s);\n+            throw new RuntimeException(\"Should not succeed\");\n+        } catch(GSSException ge) {\n+            System.out.println(ge.getMessage());\n+            System.out.println(\"No HELLO in db. Expected\");\n+        }\n+\n+        \/\/ Add \"HELLO\". Can talk to \"HELLO\" now.\n+        kdc.addPrincipal(\"HELLO\", \"different\".toCharArray());\n+        kdc.writeKtab(OneKDC.KTAB);\n+\n+        c.startAsClient(\"HELLO\", GSSUtil.GSS_KRB5_MECH_OID);\n+        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        Context.handshake(c, s);\n+        \/\/ Name could be partial without realm, so only compare the beginning\n+        Asserts.assertTrue(c.x().getTargName().toString().startsWith(\"HELLO\"),\n+                c.x().getTargName().toString());\n+        Asserts.assertTrue(s.x().getTargName().toString().startsWith(\"HELLO\"),\n+                s.x().getTargName().toString());\n+\n+        \/\/ Can also talk to \"hello\", which has a different password.\n+        c.startAsClient(\"hello\", GSSUtil.GSS_KRB5_MECH_OID);\n+        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        Context.handshake(c, s);\n+        Asserts.assertTrue(c.x().getTargName().toString().startsWith(\"hello\"),\n+                c.x().getTargName().toString());\n+        Asserts.assertTrue(s.x().getTargName().toString().startsWith(\"hello\"),\n+                s.x().getTargName().toString());\n+    }\n+\n+    static void testInsensitive() throws Exception {\n+        var kdc = new OneKDC(null).writeJAASConf();\n+        kdc.addPrincipal(\"hello\", \"password\".toCharArray());\n+        kdc.writeKtab(OneKDC.KTAB);\n+\n+        Context c = Context.fromJAAS(\"client\");\n+        Context s = Context.fromJAAS(\"com.sun.security.jgss.krb5.accept\");\n+\n+        \/\/ There is only \"hello\" but we can talk to \"HELLO\".\n+        c.startAsClient(\"HELLO\", GSSUtil.GSS_KRB5_MECH_OID);\n+        s.startAsServer(GSSUtil.GSS_KRB5_MECH_OID);\n+        Context.handshake(c, s);\n+        Asserts.assertTrue(c.x().getTargName().toString().startsWith(\"HELLO\"),\n+                c.x().getTargName().toString());\n+        Asserts.assertTrue(s.x().getTargName().toString().startsWith(\"HELLO\"),\n+                s.x().getTargName().toString());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/CaseSensitive.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,3 @@\n+    private static final boolean NAME_CASE_SENSITIVE\n+            = Boolean.getBoolean(\"jdk.security.krb5.name.case.sensitive\");\n+\n@@ -157,2 +160,1 @@\n-    private TreeMap<String,char[]> passwords = new TreeMap<>\n-            (String.CASE_INSENSITIVE_ORDER);\n+    private TreeMap<String,char[]> passwords = newTreeMap();\n@@ -162,2 +164,1 @@\n-    private TreeMap<String,String> salts = new TreeMap<>\n-            (String.CASE_INSENSITIVE_ORDER);\n+    private TreeMap<String,String> salts = newTreeMap();\n@@ -168,2 +169,1 @@\n-    private TreeMap<String,byte[]> s2kparamses = new TreeMap<>\n-            (String.CASE_INSENSITIVE_ORDER);\n+    private TreeMap<String,byte[]> s2kparamses = newTreeMap();\n@@ -172,2 +172,1 @@\n-    private TreeMap<String,KDC> aliasReferrals = new TreeMap<>\n-            (String.CASE_INSENSITIVE_ORDER);\n+    private TreeMap<String,KDC> aliasReferrals = newTreeMap();\n@@ -176,2 +175,7 @@\n-    private TreeMap<String,PrincipalName> alias2Principals = new TreeMap<>\n-            (String.CASE_INSENSITIVE_ORDER);\n+    private TreeMap<String,PrincipalName> alias2Principals = newTreeMap();\n+\n+    private static <T> TreeMap<String,T> newTreeMap() {\n+        return NAME_CASE_SENSITIVE\n+                ? new TreeMap<>()\n+                : new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n+    }\n@@ -357,1 +361,1 @@\n-                int kvno = 0;\n+                int kvno = -1; \/\/ always create new keys\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/KDC.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    private static final String NSS_BUNDLE_VERSION = \"3.91\";\n+    private static final String NSS_BUNDLE_VERSION = \"3.96\";\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.net.BindException;\n@@ -40,0 +41,2 @@\n+    private static final int MAX_ATTEMPTS = 3;\n+\n@@ -53,1 +56,16 @@\n-        new ReuseAddr().run();\n+        for (int i=1 ; i <= MAX_ATTEMPTS; i++) {\n+            try {\n+                new ReuseAddr().run();\n+                System.out.println(\"Test succeeded at attempt \" + i);\n+                break;\n+            } catch (BindException x) {\n+                System.out.println(\"attempt \" + i + \" failed: \" + x);\n+                if (i == MAX_ATTEMPTS) {\n+                    String msg = \"Could not succeed after \" + i + \" attempts\";\n+                    System.err.println(msg);\n+                    throw new AssertionError(\"Failed to reuse address: \" + msg, x);\n+                } else {\n+                    System.out.println(\"Retrying...\");\n+                }\n+            }\n+        }\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/ReuseAddr.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -140,2 +140,2 @@\n-            CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n-            if (code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElse(null) != null) {\n+            CodeAttribute code = method.findAttribute(Attributes.code()).orElseThrow();\n+            if (code.findAttribute(Attributes.lineNumberTable()).orElse(null) != null) {\n@@ -145,1 +145,1 @@\n-            if (code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElse(null) != null) {\n+            if (code.findAttribute(Attributes.localVariableTable()).orElse(null) != null) {\n@@ -149,1 +149,1 @@\n-            if (code.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).orElse(null) != null) {\n+            if (code.findAttribute(Attributes.localVariableTypeTable()).orElse(null) != null) {\n","filename":"test\/jdk\/tools\/jlink\/plugins\/StripJavaDebugAttributesPluginTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,3 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=360 -Xmx512m\n+ *  --add-opens jdk.jpackage\/jdk.jpackage.internal=ALL-UNNAMED\n+ *  jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/ServiceTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+    private static final String GC_PREFIX = \"-XX:+Use\";\n+    private static final String GC_SUFFIX = \"GC\";\n+\n@@ -351,2 +354,0 @@\n-        String GC_PREFIX  = \"-XX:+Use\";\n-        String GC_SUFFIX  = \"GC\";\n@@ -466,1 +467,25 @@\n-        return \"\" + (\"true\".equals(vmCDS()) && WB.canWriteJavaHeapArchive());\n+        return \"\" + (\"true\".equals(vmCDS()) && WB.canWriteJavaHeapArchive()\n+                     && isCDSRuntimeOptionsCompatible());\n+    }\n+\n+    \/**\n+     * @return true if the VM options specified via the \"test.cds.runtime.options\"\n+     * property is compatible with writing Java heap objects into the CDS archive\n+     *\/\n+    protected boolean isCDSRuntimeOptionsCompatible() {\n+        String jtropts = System.getProperty(\"test.cds.runtime.options\");\n+        if (jtropts == null) {\n+            return true;\n+        }\n+        String CCP_DISABLED = \"-XX:-UseCompressedClassPointers\";\n+        String G1GC_ENABLED = \"-XX:+UseG1GC\";\n+        for (String opt : jtropts.split(\",\")) {\n+            if (opt.equals(CCP_DISABLED)) {\n+                return false;\n+            }\n+            if (opt.startsWith(GC_PREFIX) && opt.endsWith(GC_SUFFIX) &&\n+                !opt.equals(G1GC_ENABLED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-            SourceFileAttribute sfa = cf.findAttribute(Attributes.SOURCE_FILE).orElseThrow();\n+            SourceFileAttribute sfa = cf.findAttribute(Attributes.sourceFile()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/4241573\/T4241573.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                InnerClassesAttribute innerClasses = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+                InnerClassesAttribute innerClasses = cf.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/7003595\/T7003595.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                CodeAttribute code = method.findAttribute(Attributes.CODE).orElse(null);\n+                CodeAttribute code = method.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/8009170\/RedundantByteCodeInArrayTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-        InnerClassesAttribute inners = classFile.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+        InnerClassesAttribute inners = classFile.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousClassFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n- * @bug 8324873\n- * @summary [lworld] implementation of value classes construction\n+ * @bug 8324873 8325805\n+ * @summary Permit non-superclass instance field assignments before this\/super in constructors\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325324\n+ * @summary Verify behavior w.r.t. implicit imports\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ImplicitImports\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+\n+public class ImplicitImports extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ImplicitImports().runTests();\n+    }\n+\n+    ImplicitImports() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testImplicitJavaBaseImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     public static void main(String... args) {\n+                         List<String> l = new ArrayList<>();\n+                         System.out.println(l.getClass().getName());\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\/\/with --release:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+\n+        {\/\/with --source:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--source\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testImplicitSimpleIOImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+\n+        Path patchClasses = prepareIOPatch(current);\n+\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     public static void main(String... args) {\n+                         println(\"Hello, World!\");\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                     \"--patch-module\", \"java.base=\" + patchClasses)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        var out = new JavaTask(tb)\n+                .classpath(classes.toString())\n+                .className(\"Test\")\n+                .vmOptions(\"--enable-preview\",\n+                           \"--patch-module\", \"java.base=\" + patchClasses)\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        var expectedOut = List.of(\"Hello, World!\");\n+\n+        if (!Objects.equals(expectedOut, out)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testNoImplicitImportsForOrdinaryClasses(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+\n+        Path patchClasses = prepareIOPatch(current);\n+\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     public class Test {\n+                         public static void main(String... args) {\n+                             List<String> l = new ArrayList<>();\n+                             println(\"Hello, World!\");\n+                         }\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        var log = new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                        \"--patch-module\", \"java.base=\" + patchClasses,\n+                        \"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        var expectedLog = List.of(\n+            \"Test.java:3:9: compiler.err.cant.resolve.location: kindname.class, List, , , (compiler.misc.location: kindname.class, Test, null)\",\n+            \"Test.java:3:30: compiler.err.cant.resolve.location: kindname.class, ArrayList, , , (compiler.misc.location: kindname.class, Test, null)\",\n+            \"Test.java:4:9: compiler.err.cant.resolve.location.args: kindname.method, println, , java.lang.String, (compiler.misc.location: kindname.class, Test, null)\",\n+            \"3 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedLog, log)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedLog +\n+                                      \", actual: \" + log);\n+\n+        }\n+    }\n+\n+    private Path prepareIOPatch(Path base) throws IOException {\n+        Path patchSrc = base.resolve(\"patch-src\");\n+        Path patchClasses = base.resolve(\"patch-classes\");\n+        tb.writeJavaFiles(patchSrc,\n+                          \"\"\"\n+                          package java.io;\n+                          public class IO {\n+                              public static void println(Object o) {\n+                                  System.out.println(o);\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(patchClasses);\n+\n+        new JavacTask(tb)\n+            .options(\"--patch-module\", \"java.base=\" + patchSrc)\n+            .outdir(patchClasses)\n+            .files(tb.findJavaFiles(patchSrc))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        return patchClasses;\n+    }\n+\n+    @Test\n+    public void testWithExplicitImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     import java.lang.*;\n+                     public static void main(String... args) {\n+                         List<String> l = new ArrayList<>();\n+                         System.out.println(l.getClass().getName());\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        var out = new JavaTask(tb)\n+                .classpath(classes.toString())\n+                .className(\"Test\")\n+                .vmOptions(\"--enable-preview\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+        if (!Objects.equals(expectedOut, out)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ImplicitImports.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8328481 8332236\n+ * @bug 8328481 8332236 8332890\n@@ -744,0 +744,56 @@\n+    @Test \/\/JDK-8332890\n+    public void testModuleInfoSelfImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          import module M;\n+                          module M {\n+                             exports p1 to M1;\n+                             exports p2;\n+                             exports p3 to M;\n+                             uses A;\n+                             uses B;\n+                             uses C;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package p1;\n+                          public class A {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package p2;\n+                          public class B {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package p3;\n+                          public class C {}\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                        \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n+                \"module-info.java:6:9: compiler.err.cant.resolve: kindname.class, A, , \",\n+                \"- compiler.note.preview.filename: module-info.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\",\n+                \"1 warning\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        classFile.findAttribute(Attributes.INNER_CLASSES).ifPresent(this::visitInnerClasses);\n+        classFile.findAttribute(Attributes.innerClasses()).ifPresent(this::visitInnerClasses);\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/ClassFileVisitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        MethodParametersAttribute attribute = method.findAttribute(Attributes.METHOD_PARAMETERS).orElse(null);\n+        MethodParametersAttribute attribute = method.findAttribute(Attributes.methodParameters()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LegacyOutputTest\/LegacyOutputTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,2 +178,2 @@\n-        MethodParametersAttribute mpattr = baz.methods().get(0).findAttribute(Attributes.METHOD_PARAMETERS).orElse(null);\n-        CodeAttribute cattr = baz.methods().get(0).findAttribute(Attributes.CODE).orElse(null);;\n+        MethodParametersAttribute mpattr = baz.methods().get(0).findAttribute(Attributes.methodParameters()).orElse(null);\n+        CodeAttribute cattr = baz.methods().get(0).findAttribute(Attributes.code()).orElse(null);;\n","filename":"test\/langtools\/tools\/javac\/MethodParametersTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-        MethodParametersAttribute methodParameters = method.findAttribute(Attributes.METHOD_PARAMETERS).orElseThrow();\n+        MethodParametersAttribute methodParameters = method.findAttribute(Attributes.methodParameters()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/RequiredParameterFlags\/ImplicitParameters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.Attributes;\n@@ -32,0 +31,1 @@\n+import java.lang.classfile.CodeModel;\n@@ -33,1 +33,0 @@\n-import java.lang.classfile.attribute.CodeAttribute;\n@@ -90,1 +89,1 @@\n-                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeModel code = method.code().orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/TestIndyStringConcat.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute code = method.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/WellKnownTypeSignatures.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute code = method.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/access\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8325805\n+ * @summary Permit non-superclass instance field assignments before this\/super in constructors\n+ * @compile\/fail\/ref=EarlyAssignments.out -XDrawDiagnostics EarlyAssignments.java\n+ * @enablePreview\n+ *\/\n+public class EarlyAssignments {\n+\n+    public static class Inner1 {\n+        public int x;\n+\n+        public Inner1() {\n+            x = 123;                        \/\/ OK - \"x\" belongs to this class\n+            this.x = 123;                   \/\/ OK - \"x\" belongs to this class\n+            Inner1.this.x = 123;            \/\/ OK - \"x\" belongs to this class\n+            super();\n+        }\n+\n+        public Inner1(int y) {\n+            y = x;                          \/\/ FAIL - early 'this' reference\n+            y = this.x;                     \/\/ FAIL - early 'this' reference\n+            y = Inner1.this.x;              \/\/ FAIL - early 'this' reference\n+            super();\n+        }\n+\n+        public class Inner1a extends Inner1 {\n+            public int z;\n+            public Inner1a(byte value) {\n+                Inner1.this.x = value;      \/\/ OK - \"x\" belongs to outer class\n+                z = super.x;                \/\/ FAIL - \"x\" belongs to superclass\n+                z = x;                      \/\/ FAIL - \"x\" belongs to superclass\n+                this.z = x;                 \/\/ FAIL - \"x\" belongs to superclass\n+                Inner1a.this.z = x;         \/\/ FAIL - \"x\" belongs to superclass\n+                Object o1 = Inner1.this;    \/\/ OK - Inner1 is an outer class\n+                Object o2 = Inner1a.this;   \/\/ FAIL - Inner1a is this class\n+                super();\n+            }\n+            public Inner1a(short value) {\n+                x = value;                  \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+            public Inner1a(char value) {\n+                this.x = value;             \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+            public Inner1a(int value) {\n+                super.x = value;            \/\/ FAIL - \"x\" belongs to superclass\n+                super();\n+            }\n+        }\n+\n+        public class Inner1b {\n+            public Inner1b(int value) {\n+                Inner1.this.x = value;      \/\/ OK - \"x\" belongs to outer class\n+                super();\n+            }\n+        }\n+    }\n+\n+    public static class Inner2 extends Inner1 {\n+        int y;\n+        public Inner2(int value) {\n+            y = value;                      \/\/ OK  - \"y\" belongs to this class\n+            this.y = value;                 \/\/ OK  - \"y\" belongs to this class\n+            x = value;                      \/\/ FAIL - \"x\" belongs to superclass\n+            this.x = value;                 \/\/ FAIL - \"x\" belongs to superclass\n+            Object o1 = this;               \/\/ FAIL - can't acces 'this' yet\n+            Object o2 = Inner2.this;        \/\/ FAIL - can't acces 'this' yet\n+            super();\n+        }\n+    }\n+\n+    public static class Inner3 {\n+\n+        public int e;\n+\n+        public class Inner3a {\n+\n+            public static int x;\n+\n+            public Inner3a(int val) {\n+                x = val;                    \/\/ OK - \"x\" is a static field\n+                val = x;                    \/\/ OK - \"x\" is a static field\n+                e = val;                    \/\/ OK - \"e\" belongs to outer class\n+                val = e;                    \/\/ OK - \"e\" belongs to outer class\n+                Inner3.this.e = val;        \/\/ OK - \"e\" belongs to outer class\n+                super();\n+            }\n+        }\n+    }\n+\n+    public static class Inner4 {\n+        public int x;\n+\n+        public Inner4() {\n+            x = 0;                              \/\/ OK\n+            x = x + 1;                          \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner4(int a) {\n+            this.x = 0;                         \/\/ OK\n+            this.x = this.x + 1;                \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner4(char a) {\n+            Inner4.this.x = 0;                  \/\/ OK\n+            Inner4.this.x = Inner4.this.x + 1;  \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+\n+    public static class Inner5 extends Inner4 {\n+        public int y;\n+\n+        public Inner5() {\n+            y = x + 1;                          \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(int a) {\n+            this.y = x + 1;                     \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(char a) {\n+            Inner5.this.y = x + 1;              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(short a) {\n+            y = super.x + 1;                    \/\/ FAIL - illegal early access\n+            super();\n+        }\n+\n+        public Inner5(float a) {\n+            y = Inner5.this.x + 1;              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+\n+    public static class Inner6 {\n+        public int x = 1;\n+\n+        public Inner6() {\n+            x = 2;                              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+\n+    public static class Inner7 {\n+        public final int x = 1;\n+\n+        public Inner7() {\n+            x = 2;                              \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+EarlyAssignments.java:21:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:22:17: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:23:23: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:31:21: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:32:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:33:26: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:34:34: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:36:36: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:40:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:44:21: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:48:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:66:13: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:67:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:68:25: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:69:31: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:98:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:104:22: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:110:35: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:119:17: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:124:22: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:129:29: compiler.err.cant.ref.before.ctor.called: x\n+EarlyAssignments.java:134:17: compiler.err.cant.ref.before.ctor.called: super\n+EarlyAssignments.java:139:23: compiler.err.cant.ref.before.ctor.called: this\n+EarlyAssignments.java:148:13: compiler.err.cant.assign.initialized.before.ctor.called: x\n+EarlyAssignments.java:157:13: compiler.err.cant.assign.val.to.var: final, x\n+- compiler.note.preview.filename: EarlyAssignments.java, DEFAULT\n+- compiler.note.preview.recompile\n+25 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8325805\n+ * @summary Verify local class in early construction context has no outer instance\n+ * @compile\/fail\/ref=EarlyLocalClass.out -XDrawDiagnostics EarlyLocalClass.java\n+ * @enablePreview\n+ *\/\n+public class EarlyLocalClass {\n+    EarlyLocalClass() {\n+        class Local {\n+            void foo() {\n+                EarlyLocalClass.this.hashCode();    \/\/ this should FAIL\n+            }\n+        }\n+        new Local();                                \/\/ this is OK\n+        super();\n+        new Local();                                \/\/ this is OK\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalClass.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+EarlyLocalClass.java:12:32: compiler.err.no.encl.instance.of.type.in.scope: EarlyLocalClass\n+- compiler.note.preview.filename: EarlyLocalClass.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalClass.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -94,1 +94,1 @@\n-        this.x = x.length;              \/\/ this should work\n+        this.x++;                       \/\/ this should FAIL\n@@ -148,10 +148,0 @@\n-    public SuperInitFails(short[][] x) {\n-        class Foo {\n-            Foo() {\n-                SuperInitFails.this.hashCode();\n-            }\n-        };\n-        new Foo();                      \/\/ this should FAIL\n-        super();\n-    }\n-\n@@ -171,0 +161,28 @@\n+\n+    public static class Inner2 {\n+        int x;\n+    }\n+    public static class Inner3 extends Inner2 {\n+        int y;\n+        Inner3(byte z) {\n+            x = z;                      \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(short z) {\n+            this.x = z;                 \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(char z) {\n+            Inner3.this.x = z;          \/\/ this should FAIL\n+            super();\n+        }\n+        Inner3(int z) {\n+            super.x = z;                \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    public SuperInitFails(double[][] x) {\n+        Runnable r = () -> this.x = 7;  \/\/ this should FAIL\n+        super();\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+SuperInitFails.java:94:9: compiler.err.cant.ref.before.ctor.called: this\n@@ -14,3 +15,6 @@\n-SuperInitFails.java:154:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:165:31: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:169:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:155:31: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:159:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:168:13: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:172:17: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:176:24: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:180:18: compiler.err.cant.ref.before.ctor.called: x\n@@ -25,1 +29,1 @@\n-SuperInitFails.java:160:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:150:18: compiler.err.ctor.calls.not.allowed.here\n@@ -28,1 +32,1 @@\n-25 errors\n+29 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -411,0 +411,48 @@\n+    \/\/ we allow 'this' reference prior to super() for field assignments only\n+    public static class Test20 {\n+        private int x;\n+        public Test20(short x) {\n+            x = x;\n+            super();\n+        }\n+        public Test20(int x) {\n+            this.x = x;\n+            super();\n+        }\n+        public Test20(char x) {\n+            Test20.this.x = x;\n+            super();\n+        }\n+        public Test20(byte y) {\n+            x = y;\n+            this((int)y);\n+            this.x++;\n+        }\n+    }\n+\n+    \/\/ allow creating and using local and anonymous classes before super()\n+    \/\/ they will not have enclosing instances though\n+    public static class Test21 {\n+        public Test21(int x) {\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    this.hashCode();\n+                }\n+            };\n+            r.run();\n+            super();\n+            r.run();\n+        }\n+        public Test21(float x) {\n+            class Foo {\n+                public void bar() {\n+                    this.hashCode();\n+                }\n+            };\n+            new Foo().bar();\n+            super();\n+            new Foo().bar();\n+        }\n+    }\n+\n+\n@@ -452,0 +500,3 @@\n+        new Test20(123);\n+        new Test21((int)123);\n+        new Test21((float)123);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -14,1 +14,0 @@\n-ValueClassSuperInitFails.java:164:9: compiler.err.cant.ref.before.ctor.called: this\n@@ -28,1 +27,1 @@\n-25 errors\n+24 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                Assert.checkNonNull(method.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS),\n+                Assert.checkNonNull(method.findAttribute(Attributes.runtimeVisibleAnnotations()),\n@@ -68,1 +68,1 @@\n-                Assert.checkNonNull(method.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS),\n+                Assert.checkNonNull(method.findAttribute(Attributes.runtimeVisibleParameterAnnotations()),\n","filename":"test\/langtools\/tools\/javac\/T6695379\/AnnotationsAreNotCopiedToBridgeMethodsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n-                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                CodeAttribute code = m.findAttribute(Attributes.code()).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.lineNumberTable()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T6970173\/DebugPointerAtBadPositionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n-                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n-                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                CodeAttribute code = m.findAttribute(Attributes.code()).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.lineNumberTable()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T7008643\/InlinedFinallyConfuseDebuggersTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        CodeAttribute ea = m.findAttribute(Attributes.CODE).orElseThrow();\n+        CodeAttribute ea = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T7053059\/DoubleCastTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-            CodeAttribute code = test_method.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute code = test_method.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/T7093325.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        InnerClassesAttribute innerClasses = classFile.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+        InnerClassesAttribute innerClasses = classFile.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/T7165659\/InnerClassAttrMustNotHaveStrictFPFlagTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,2 +166,2 @@\n-                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n-                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                CodeAttribute code = method.findAttribute(Attributes.code()).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.lineNumberTable()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T8019486\/WrongLNTForLambdaTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                CodeAttribute codeAtt = method.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute codeAtt = method.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T8022186\/DeadCodeGeneratedForEmptyTryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-                    CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n+                    CodeAttribute code = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T8024039\/NoDeadCodeGenerationOnTrySmtTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            CodeAttribute code = method.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute code = method.findAttribute(Attributes.code()).orElse(null);\n@@ -57,1 +57,1 @@\n-                if (code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElse(null) != null) {\n+                if (code.findAttribute(Attributes.localVariableTable()).orElse(null) != null) {\n","filename":"test\/langtools\/tools\/javac\/T8028504\/DontGenerateLVTForGNoneOpTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n-                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                CodeAttribute code = m.findAttribute(Attributes.code()).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.lineNumberTable()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T8180141\/MissingLNTEntryForBreakContinueTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,2 +91,2 @@\n-                CodeAttribute code = m.findAttribute(Attributes.CODE).orElseThrow();\n-                LineNumberTableAttribute lnt = code.findAttribute(Attributes.LINE_NUMBER_TABLE).orElseThrow();\n+                CodeAttribute code = m.findAttribute(Attributes.code()).orElseThrow();\n+                LineNumberTableAttribute lnt = code.findAttribute(Attributes.lineNumberTable()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/T8180660\/MissingLNTEntryForFinalizerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                CodeAttribute codeAttr = method.findAttribute(Attributes.CODE).orElse(null);\n+                CodeAttribute codeAttr = method.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/T8210435\/NoLocalsMustBeReservedForDCEedVarsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n@@ -219,1 +219,1 @@\n-            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n@@ -254,1 +254,1 @@\n-            LineNumberTableAttribute lnt = ea.findAttribute(Attributes.LINE_NUMBER_TABLE).orElse(null);\n+            LineNumberTableAttribute lnt = ea.findAttribute(Attributes.lineNumberTable()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/T8222949\/TestConstantDynamic.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrSimpleClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                    var paAnnos = mm.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS).orElseThrow().parameterAnnotations();\n+                    var paAnnos = mm.findAttribute(Attributes.runtimeVisibleParameterAnnotations()).orElseThrow().parameterAnnotations();\n@@ -73,1 +73,1 @@\n-                    var annos = mm.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow().annotations();\n+                    var annos = mm.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow().annotations();\n@@ -80,1 +80,1 @@\n-                var annos = fm.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow().annotations();\n+                var annos = fm.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow().annotations();\n","filename":"test\/langtools\/tools\/javac\/annotations\/ApplicableAnnotationsOnRecords.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -200,2 +200,2 @@\n-        findAnnotations(cm, m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n-        findAnnotations(cm, m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(cm, m, Attributes.runtimeVisibleTypeAnnotations(), annos);\n+        findAnnotations(cm, m, Attributes.runtimeInvisibleTypeAnnotations(), annos);\n@@ -208,1 +208,1 @@\n-            CodeAttribute cattr = m.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute cattr = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/TypeAnnotationsPositionsOnRecords.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,2 +113,2 @@\n-        findAnnotations(cf, m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n-        findAnnotations(cf, m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(cf, m, Attributes.runtimeVisibleTypeAnnotations(), annos);\n+        findAnnotations(cf, m, Attributes.runtimeInvisibleTypeAnnotations(), annos);\n@@ -121,1 +121,1 @@\n-            CodeAttribute cattr = m.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute cattr = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/VariablesDeclaredWithVarTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-                cm.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).orElse(null);\n+                cm.findAttribute(Attributes.runtimeVisibleTypeAnnotations()).orElse(null);\n@@ -118,1 +118,1 @@\n-        CodeAttribute cAttr = method.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute cAttr = method.findAttribute(Attributes.code()).orElse(null);\n@@ -129,1 +129,1 @@\n-        CodeAttribute cAttr = method.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute cAttr = method.findAttribute(Attributes.code()).orElse(null);\n@@ -144,1 +144,1 @@\n-            CodeAttribute cAttr = method.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute cAttr = method.findAttribute(Attributes.code()).orElse(null);\n@@ -155,1 +155,1 @@\n-                    cm.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).orElse(null);\n+                    cm.findAttribute(Attributes.runtimeVisibleTypeAnnotations()).orElse(null);\n@@ -171,1 +171,1 @@\n-        CodeAttribute cAttr1 = method.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute cAttr1 = method.findAttribute(Attributes.code()).orElse(null);\n@@ -178,1 +178,1 @@\n-        CodeAttribute cAttr2 = method.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute cAttr2 = method.findAttribute(Attributes.code()).orElse(null);\n@@ -187,1 +187,1 @@\n-        if (method.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).orElse(null) != null) {\n+        if (method.findAttribute(Attributes.runtimeVisibleTypeAnnotations()).orElse(null) != null) {\n@@ -191,1 +191,1 @@\n-        CodeAttribute code = method.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute code = method.findAttribute(Attributes.code()).orElse(null);\n@@ -194,1 +194,1 @@\n-                code.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).orElse(null);\n+                code.findAttribute(Attributes.runtimeVisibleTypeAnnotations()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnonymousClassTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -91,4 +91,4 @@\n-        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, local);\n-        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, local);\n-        test(m, Attributes.RUNTIME_VISIBLE_ANNOTATIONS, local);\n-        test(m, Attributes.RUNTIME_INVISIBLE_ANNOTATIONS, local);\n+        test(m, Attributes.runtimeVisibleTypeAnnotations(), local);\n+        test(m, Attributes.runtimeInvisibleTypeAnnotations(), local);\n+        test(m, Attributes.runtimeVisibleAnnotations(), local);\n+        test(m, Attributes.runtimeInvisibleAnnotations(), local);\n@@ -167,1 +167,1 @@\n-            cAttr = m.findAttribute(Attributes.CODE).orElse(null);\n+            cAttr = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/ClassfileTestHelper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-        testDecl(m, Attributes.RUNTIME_VISIBLE_ANNOTATIONS);\n-        testDecl(m, Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+        testDecl(m, Attributes.runtimeVisibleAnnotations());\n+        testDecl(m, Attributes.runtimeInvisibleAnnotations());\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/NoTargetAnnotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,4 +66,4 @@\n-            Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS,\n-            Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS,\n-            Attributes.RUNTIME_VISIBLE_ANNOTATIONS,\n-            Attributes.RUNTIME_INVISIBLE_ANNOTATIONS\n+            Attributes.runtimeVisibleTypeAnnotations(),\n+            Attributes.runtimeInvisibleTypeAnnotations(),\n+            Attributes.runtimeVisibleAnnotations(),\n+            Attributes.runtimeInvisibleAnnotations()\n@@ -178,1 +178,1 @@\n-                CAttr = m.findAttribute(Attributes.CODE).orElse(null);\n+                CAttr = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/TestAnonInnerClasses.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                    cAttr = mm.findAttribute(Attributes.CODE).orElse(null);\n+                    cAttr = mm.findAttribute(Attributes.code()).orElse(null);\n@@ -102,1 +102,1 @@\n-                    cAttr = fm.findAttribute(Attributes.CODE).orElse(null);\n+                    cAttr = fm.findAttribute(Attributes.code()).orElse(null);\n@@ -210,1 +210,1 @@\n-                    test(clazz, fm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, false);\n+                    test(clazz, fm, Attributes.runtimeVisibleTypeAnnotations(), false);\n@@ -212,1 +212,1 @@\n-                    test(clazz, mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, false);\n+                    test(clazz, mm, Attributes.runtimeVisibleTypeAnnotations(), false);\n@@ -215,1 +215,1 @@\n-                    test(clazz, fm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, true);\n+                    test(clazz, fm, Attributes.runtimeVisibleTypeAnnotations(), true);\n@@ -217,1 +217,1 @@\n-                    test(clazz, mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, true);\n+                    test(clazz, mm, Attributes.runtimeVisibleTypeAnnotations(), true);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/TestNewCastArray.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        CodeAttribute cattr = f.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute cattr = f.findAttribute(Attributes.code()).orElse(null);\n@@ -63,1 +63,1 @@\n-        RuntimeVisibleTypeAnnotationsAttribute attr = cattr.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).orElse(null);\n+        RuntimeVisibleTypeAnnotationsAttribute attr = cattr.findAttribute(Attributes.runtimeVisibleTypeAnnotations()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/TypeAnnotationPropagationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-        findAnnotations(cm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n-        findAnnotations(cm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(cm, Attributes.runtimeVisibleTypeAnnotations(), annos);\n+        findAnnotations(cm, Attributes.runtimeInvisibleTypeAnnotations(), annos);\n@@ -52,2 +52,2 @@\n-        findAnnotations(ae, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, annos);\n-        findAnnotations(ae, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, annos);\n+        findAnnotations(ae, Attributes.runtimeVisibleTypeAnnotations(), annos);\n+        findAnnotations(ae, Attributes.runtimeInvisibleTypeAnnotations(), annos);\n@@ -81,1 +81,1 @@\n-            CodeAttribute cAttr = mm.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute cAttr = mm.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-                CodeAttribute code_attribute = method.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute code_attribute = method.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/cast\/intersection\/DuplicatedCheckcastTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                EnclosingMethodAttribute encl = cf.findAttribute(Attributes.ENCLOSING_METHOD).orElse(null);\n+                EnclosingMethodAttribute encl = cf.findAttribute(Attributes.enclosingMethod()).orElse(null);\n@@ -62,1 +62,1 @@\n-            InnerClassesAttribute attr = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+            InnerClassesAttribute attr = cf.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/InnerClasses\/SyntheticClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                        method.findAttribute(Attributes.ANNOTATION_DEFAULT).orElse(null);\n+                        method.findAttribute(Attributes.annotationDefault()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/AnnotationDefault\/AnnotationDefaultTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                EnclosingMethodAttribute attr = classFile.findAttribute(Attributes.ENCLOSING_METHOD).orElse(null);\n+                EnclosingMethodAttribute attr = classFile.findAttribute(Attributes.enclosingMethod()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/EnclosingMethod\/EnclosingMethodTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                        CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElse(null);\n+                        CodeAttribute code_attribute = m.findAttribute(Attributes.code()).orElse(null);\n@@ -79,1 +79,1 @@\n-                                countAttributes(Attributes.LINE_NUMBER_TABLE, code_attribute),\n+                                countAttributes(Attributes.lineNumberTable(), code_attribute),\n@@ -83,1 +83,1 @@\n-                        LineNumberTableAttribute tableAttribute = code_attribute.findAttribute(Attributes.LINE_NUMBER_TABLE).orElse(null);\n+                        LineNumberTableAttribute tableAttribute = code_attribute.findAttribute(Attributes.lineNumberTable()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/LineNumberTestBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElse(null);\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.code()).orElse(null);\n@@ -30,1 +30,1 @@\n-                    if (Attributes.LINE_NUMBER_TABLE.equals(at)) {\n+                    if (Attributes.lineNumberTable().equals(at)) {\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/T8050993.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElse(null);\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LocalVariableTable\/LocalVariableTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        ModuleAttribute moduleAttribute = classFile.findAttribute(Attributes.MODULE).orElse(null);\n+        ModuleAttribute moduleAttribute = classFile.findAttribute(Attributes.module()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Module\/ModuleTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-                            () -> classFile.findAttribute(Attributes.SIGNATURE).orElse(null),\n+                            () -> classFile.findAttribute(Attributes.signature()).orElse(null),\n@@ -176,1 +176,1 @@\n-                    () -> method.findAttribute(Attributes.SIGNATURE).orElse(null),\n+                    () -> method.findAttribute(Attributes.signature()).orElse(null),\n@@ -207,1 +207,1 @@\n-                    () -> field.findAttribute(Attributes.SIGNATURE).orElse(null),\n+                    () -> field.findAttribute(Attributes.signature()).orElse(null),\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Signature\/Driver.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-                ClassFile.of().parse(getClassFile(NoSourceFileAttribute.class).toPath()).findAttribute(Attributes.SOURCE_FILE).orElse(null),\n+                ClassFile.of().parse(getClassFile(NoSourceFileAttribute.class).toPath()).findAttribute(Attributes.sourceFile()).orElse(null),\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/NoSourceFileAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        assertEquals(attribute.attributeName(), Attributes.SOURCE_FILE.name(), \"Incorrect attribute name\");\n+        assertEquals(attribute.attributeName(), Attributes.sourceFile().name(), \"Incorrect attribute name\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/SourceFileTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-                        () -> classFile.findAttribute(Attributes.SYNTHETIC).orElse(null),\n+                        () -> classFile.findAttribute(Attributes.synthetic()).orElse(null),\n@@ -139,1 +139,1 @@\n-                            () -> method.findAttribute(Attributes.SYNTHETIC).orElse(null),\n+                            () -> method.findAttribute(Attributes.synthetic()).orElse(null),\n@@ -165,1 +165,1 @@\n-                            () -> field.findAttribute(Attributes.SYNTHETIC).orElse(null),\n+                            () -> field.findAttribute(Attributes.synthetic()).orElse(null),\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/SyntheticTestDriver.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-                Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+                Attributes.runtimeInvisibleAnnotations());\n@@ -103,1 +103,1 @@\n-                Attributes.RUNTIME_VISIBLE_ANNOTATIONS);\n+                Attributes.runtimeVisibleAnnotations());\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/annotations\/RuntimeAnnotationsTestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,4 +107,4 @@\n-        RuntimeInvisibleParameterAnnotationsAttribute invAttr = method.findAttribute(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS).orElse(null);\n-        checkNull(invAttr, String.format(\"%s should be null\", Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS));\n-        RuntimeVisibleParameterAnnotationsAttribute vAttr = method.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS).orElse(null);\n-        checkNull(vAttr, String.format(\"%s should be null\", Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS));\n+        RuntimeInvisibleParameterAnnotationsAttribute invAttr = method.findAttribute(Attributes.runtimeInvisibleParameterAnnotations()).orElse(null);\n+        checkNull(invAttr, String.format(\"%s should be null\", Attributes.runtimeInvisibleParameterAnnotations()));\n+        RuntimeVisibleParameterAnnotationsAttribute vAttr = method.findAttribute(Attributes.runtimeVisibleParameterAnnotations()).orElse(null);\n+        checkNull(vAttr, String.format(\"%s should be null\", Attributes.runtimeVisibleParameterAnnotations()));\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/annotations\/RuntimeParameterAnnotationsForLambdaTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);\n+                Attributes.runtimeInvisibleParameterAnnotations());\n@@ -75,1 +75,1 @@\n-                Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);\n+                Attributes.runtimeVisibleParameterAnnotations());\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/annotations\/RuntimeParameterAnnotationsTestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            DeprecatedAttribute attr = cm.findAttribute(Attributes.DEPRECATED).orElse(null);\n+            DeprecatedAttribute attr = cm.findAttribute(Attributes.deprecated()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/deprecated\/DeprecatedPackageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-            DeprecatedAttribute attr = cf.findAttribute(Attributes.DEPRECATED).orElse(null);\n+            DeprecatedAttribute attr = cf.findAttribute(Attributes.deprecated()).orElse(null);\n@@ -258,1 +258,1 @@\n-        InnerClassesAttribute innerAttr = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+        InnerClassesAttribute innerAttr = cf.findAttribute(Attributes.innerClasses()).orElse(null);\n@@ -264,1 +264,1 @@\n-            DeprecatedAttribute attr = innerCf.findAttribute(Attributes.DEPRECATED).orElse(null);\n+            DeprecatedAttribute attr = innerCf.findAttribute(Attributes.deprecated()).orElse(null);\n@@ -279,1 +279,1 @@\n-            DeprecatedAttribute attr = m.findAttribute(Attributes.DEPRECATED).orElse(null);\n+            DeprecatedAttribute attr = m.findAttribute(Attributes.deprecated()).orElse(null);\n@@ -288,1 +288,1 @@\n-            DeprecatedAttribute attr = f.findAttribute(Attributes.DEPRECATED).orElse(null);\n+            DeprecatedAttribute attr = f.findAttribute(Attributes.deprecated()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/deprecated\/DeprecatedTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                InnerClassesAttribute attr = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+                InnerClassesAttribute attr = cf.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesHierarchyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            InnerClassesAttribute attr = classFile.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+            InnerClassesAttribute attr = classFile.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesIndexTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            InnerClassesAttribute innerClasses = cm.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+            InnerClassesAttribute innerClasses = cm.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        assertNull(classModel.findAttribute(Attributes.INNER_CLASSES).orElse(null), \"Found inner class attribute\");\n+        assertNull(classModel.findAttribute(Attributes.innerClasses()).orElse(null), \"Found inner class attribute\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/NoInnerClassesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-        BootstrapMethodsAttribute bootAttr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+        BootstrapMethodsAttribute bootAttr = cf.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n@@ -173,1 +173,1 @@\n-        CodeAttribute codeAttr = cf.methods().get(1).findAttribute(Attributes.CODE).orElseThrow();\n+        CodeAttribute codeAttr = cf.methods().get(1).findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/classwriter\/IndyCorrectInvocationName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        CodeAttribute codeAttr = cf.methods().get(1).findAttribute(Attributes.CODE).orElseThrow();\n+        CodeAttribute codeAttr = cf.methods().get(1).findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/code\/CharImmediateValue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                codeAttr = m.findAttribute(Attributes.CODE).orElse(null);\n+                codeAttr = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/TestDefaultBody.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/super\/TestDirectSuperInterfaceInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-compiler.warn.is.preview                                # difficult to produce reliably despite future changes to java.base\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.cant.assign.initialized.before.ctor.called\n+ \/\/ options: --enable-preview  -source ${jdk.version}\n+\n+class CantAssignInitializedBeforeCtorCalled {\n+    int x = 1;\n+    CantAssignInitializedBeforeCtorCalled() {\n+        x = 2;\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantAssignInitializedBeforeCtorCalled.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.flexible.constructors\n+ \/\/ key: compiler.warn.preview.feature.use\n+ \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FeatureFlexibleConstructors {\n+    FeatureFlexibleConstructors() {\n+        System.out.println();\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureFlexibleConstructors.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/\/ key: compiler.misc.feature.super.init\n- \/\/ key: compiler.warn.preview.feature.use\n- \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n-\n-class FeatureStatementsBeforeSuper {\n-    FeatureStatementsBeforeSuper() {\n-        System.out.println();\n-        super();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureStatementsBeforeSuper.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,4 @@\n- \/\/ key: compiler.misc.feature.implicit.classes\n- \/\/ key: compiler.warn.preview.feature.use.plural\n- \/\/ options: -source ${jdk.version} --enable-preview -Xlint:preview\n+\/\/ key: compiler.misc.feature.implicit.classes\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ key: compiler.warn.is.preview\n+\/\/ options: -source ${jdk.version} --enable-preview -Xlint:preview\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitClass.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/expression\/_super\/NonDirectSuper\/NonDirectSuper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        SourceFileAttribute sf = cf.findAttribute(Attributes.SOURCE_FILE).orElseThrow();\n+        SourceFileAttribute sf = cf.findAttribute(Attributes.sourceFile()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/file\/SymLinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,2 +141,2 @@\n-        CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n-        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElseThrow();\n+        CodeAttribute code = method.findAttribute(Attributes.code()).orElseThrow();\n+        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.localVariableTable()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/flow\/LVTHarness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-            BootstrapMethodsAttribute bsmAttr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElse(null);\n+            BootstrapMethodsAttribute bsmAttr = cf.findAttribute(Attributes.bootstrapMethods()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/lambda\/ByteCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        CodeAttribute code = m.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute code = m.findAttribute(Attributes.code()).orElse(null);\n@@ -99,1 +99,1 @@\n-        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElse(null);\n+        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.localVariableTable()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/lambda\/LocalVariableTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/lambda\/TestBootstrapMethodsCount.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n@@ -292,1 +292,1 @@\n-                    .findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+                    .findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n@@ -340,1 +340,1 @@\n-            LineNumberTableAttribute lnt = ea.findAttribute(Attributes.LINE_NUMBER_TABLE).orElse(null);\n+            LineNumberTableAttribute lnt = ea.findAttribute(Attributes.lineNumberTable()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/lambda\/TestInvokeDynamic.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n@@ -246,1 +246,1 @@\n-            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n@@ -248,1 +248,1 @@\n-            BootstrapMethodsAttribute bsm_attr = cm.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            BootstrapMethodsAttribute bsm_attr = cm.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecodeTargetRelease14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-            BootstrapMethodsAttribute bsm = cm.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            BootstrapMethodsAttribute bsm = cm.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8304400\n+ * @bug 8304400 8332226\n@@ -115,0 +115,2 @@\n+        var badFolder = Files.createDirectories(base.resolve(\".bad\"));\n+        Files.writeString(badFolder.resolve(\"bad.txt\"), \"bad\");\n@@ -143,0 +145,1 @@\n+            var actual = reader.list().toList();\n@@ -145,0 +148,2 @@\n+                    .bad\/\n+                    .bad\/bad.txt\n@@ -155,2 +160,2 @@\n-                    \"\"\".lines(),\n-                    reader.list());\n+                    \"\"\".lines().toList(),\n+                    actual, \"Actual lines -> \" + actual);\n","filename":"test\/langtools\/tools\/javac\/launcher\/ModuleSourceLauncherTests.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -747,2 +747,2 @@\n-            byte[] newBytes = ClassFile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof Attributes)\n-                    .andThen(ClassTransform.endHandler(classBuilder -> classBuilder.with(newAttr))));\n+            byte[] newBytes = ClassFile.of().transform(cf,\n+                    ClassTransform.endHandler(classBuilder -> classBuilder.with(newAttr)));\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElse(null);\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/linenumbers\/ConditionalLineNumberTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/linenumbers\/FinallyLineNumberTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/linenumbers\/NestedLineNumberTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                CodeAttribute code_attribute = m.findAttribute(Attributes.CODE).orElseThrow();\n+                CodeAttribute code_attribute = m.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/linenumbers\/NullCheckLineNumberTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/meth\/TestCP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.runtimeVisibleAnnotations()).orElse(null);\n@@ -143,1 +143,1 @@\n-        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.runtimeVisibleAnnotations()).orElse(null);\n@@ -149,1 +149,1 @@\n-        if (cf.findAttribute(Attributes.DEPRECATED).isPresent()) {\n+        if (cf.findAttribute(Attributes.deprecated()).isPresent()) {\n@@ -194,1 +194,1 @@\n-        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+        RuntimeVisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.runtimeVisibleAnnotations()).orElse(null);\n@@ -317,1 +317,1 @@\n-        RuntimeInvisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n+        RuntimeInvisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.runtimeInvisibleAnnotations()).orElse(null);\n@@ -359,1 +359,1 @@\n-        RuntimeInvisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n+        RuntimeInvisibleAnnotationsAttribute annotations = cf.findAttribute(Attributes.runtimeInvisibleAnnotations()).orElse(null);\n@@ -434,1 +434,1 @@\n-        RuntimeInvisibleAnnotationsAttribute invisibleAnnotations = cf.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n+        RuntimeInvisibleAnnotationsAttribute invisibleAnnotations = cf.findAttribute(Attributes.runtimeInvisibleAnnotations()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-        ModuleAttribute modAttr1 = cm1.findAttribute(Attributes.MODULE).orElseThrow();\n+        ModuleAttribute modAttr1 = cm1.findAttribute(Attributes.module()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/modules\/JavaBaseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        ModuleAttribute moduleAttribute = cm.findAttribute(Attributes.MODULE).orElse(null);\n+        ModuleAttribute moduleAttribute = cm.findAttribute(Attributes.module()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/modules\/ModuleVersion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-        ModuleAttribute module = cm.findAttribute(Attributes.MODULE).orElseThrow();\n+        ModuleAttribute module = cm.findAttribute(Attributes.module()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/modules\/OpenModulesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-            CodeAttribute code = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute code = testMethod.findAttribute(Attributes.code()).orElse(null);\n@@ -77,1 +77,1 @@\n-            LocalVariableTypeTableAttribute lvt_table = code.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).orElse(null);\n+            LocalVariableTypeTableAttribute lvt_table = code.findAttribute(Attributes.localVariableTypeTable()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/multicatch\/7005371\/T7005371.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/multicatch\/Pos05.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-                CodeAttribute codeAttr = m.findAttribute(Attributes.CODE).orElseThrow();\n-                RuntimeInvisibleTypeAnnotationsAttribute annotations = codeAttr.findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS).orElseThrow();\n+                CodeAttribute codeAttr = m.findAttribute(Attributes.code()).orElseThrow();\n+                RuntimeInvisibleTypeAnnotationsAttribute annotations = codeAttr.findAttribute(Attributes.runtimeInvisibleTypeAnnotations()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        CodeAttribute code = m.findAttribute(Attributes.CODE).orElse(null);\n+        CodeAttribute code = m.findAttribute(Attributes.code()).orElse(null);\n@@ -96,1 +96,1 @@\n-        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).orElse(null);\n+        LocalVariableTableAttribute lvt = code.findAttribute(Attributes.localVariableTable()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/patterns\/LocalVariableTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        CodeAttribute code_attribute = testMethod.findAttribute(Attributes.CODE).orElseThrow();\n+        CodeAttribute code_attribute = testMethod.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/patterns\/NestedPatternVariablesBytecode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+        CodeAttribute code = method.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/patterns\/NoUnnecessaryCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,390 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332106\n+ * @summary Verify the synthetic catch clauses are generated correctly for constructors\n+ * @enablePreview\n+ * @compile UninitializedThisException.java\n+ * @run main UninitializedThisException\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+public class UninitializedThisException extends Base {\n+\n+    public UninitializedThisException(String s1, String s2) {\n+        super(s1, s2);\n+    }\n+\n+    public UninitializedThisException(R o1, R o2, R o3) {\n+        out.println(\"-pre(\" + o1.fail() + \")\" +\n+                    \"-nest(\" + o2.fail() + \")\" +\n+                    \"-post(\" + o3.fail() + \")\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        this(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(String o1, R o2, R o3) {\n+        out.println(\"-nest(\" + o2.fail() + \")\" +\n+                    \"-post(\" + o3.fail() + \")\");\n+        String val1 = o1;\n+        out.println(\"check1\");\n+        this(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(R o1, String o2, R o3) {\n+        out.println(\"-pre(\" + o1.fail() + \")\" +\n+                    \"-post(\" + o3.fail() + \")\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        this(val1, o2);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(R o1, R o2, String o3) {\n+        out.println(\"-pre(\" + o1.fail() + \")\" +\n+                    \"-nest(\" + o2.fail() + \")\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        this(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(R o1, String o2, String o3) {\n+        out.println(\"-pre(\" + o1.fail() + \")\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        this(val1, o2);\n+        out.println(\"check2\");\n+        String val2 = o3;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(String o1, R o2, String o3) {\n+        out.println(\"-nest(\" + o2.fail() + \")\");\n+        String val1 = o1;\n+        out.println(\"check1\");\n+        this(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(String o1, String o2, R o3) {\n+        out.println(\"-post(\" + o3.fail() + \")\");\n+        String val1 = o1;\n+        out.println(\"check1\");\n+        this(val1, o2);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(R o1, R o2, R o3, boolean superMarker) {\n+        out.println(\"-pre(\" + o1.fail() + \")\" +\n+                    \"-nest(\" + o2.fail() + \")\" +\n+                    \"-post(\" + o3.fail() + \")\" +\n+                    \"-super\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        super(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(String o1, R o2, R o3, boolean superMarker) {\n+        out.println(\"-nest(\" + o2.fail() + \")\" +\n+                    \"-post(\" + o3.fail() + \")\" +\n+                    \"-super\");\n+        String val1 = o1;\n+        out.println(\"check1\");\n+        super(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(R o1, String o2, R o3, boolean superMarker) {\n+        out.println(\"-pre(\" + o1.fail() + \")\" +\n+                    \"-post(\" + o3.fail() + \")\" +\n+                    \"-super\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        super(val1, o2);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(R o1, R o2, String o3, boolean superMarker) {\n+        out.println(\"-pre(\" + o1.fail() + \")\" +\n+                    \"-nest(\" + o2.fail() + \")\" +\n+                    \"-super\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        super(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(R o1, String o2, String o3, boolean superMarker) {\n+        out.println(\"-pre(\" + o1.fail() + \")\" +\n+                    \"-super\");\n+        String val1 = o1 instanceof R(String s, _) ? s : null;\n+        out.println(\"check1\");\n+        super(val1, o2);\n+        out.println(\"check2\");\n+        String val2 = o3;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(String o1, R o2, String o3, boolean superMarker) {\n+        out.println(\"-nest(\" + o2.fail() + \")\" +\n+                    \"-super\");\n+        String val1 = o1;\n+        out.println(\"check1\");\n+        super(val1, o2 instanceof R(String s, _) ? s : null);\n+        out.println(\"check2\");\n+        String val2 = o3;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public UninitializedThisException(String o1, String o2, R o3, boolean superMarker) {\n+        out.println(\"-post(\" + o3.fail() + \")\" +\n+                    \"-super\");\n+        String val1 = o1;\n+        out.println(\"check1\");\n+        super(val1, o2);\n+        out.println(\"check2\");\n+        String val2 = o3 instanceof R(String s, _) ? s : null;\n+        out.println(\"check3\");\n+        Objects.requireNonNull(val2);\n+    }\n+\n+    public static void main(String... args) {\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), new R(\"\", false), new R(\"\", false)));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), new R(\"\", true), new R(\"\", false)));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), new R(\"\", false), new R(\"\", true)));\n+        new UninitializedThisException(new R(\"\", false), new R(\"\", false), new R(\"\", false));\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(\"\", new R(\"\", true), new R(\"\", false)));\n+        runAndCatch(() -> new UninitializedThisException(\"\", new R(\"\", false), new R(\"\", true)));\n+        new UninitializedThisException(\"\", new R(\"\", false), new R(\"\", false));\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), \"\", new R(\"\", false)));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), \"\", new R(\"\", true)));\n+        new UninitializedThisException(new R(\"\", false), \"\", new R(\"\", false));\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), new R(\"\", false), \"\"));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), new R(\"\", true), \"\"));\n+        new UninitializedThisException(new R(\"\", false), new R(\"\", false), \"\");\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), \"\", \"\"));\n+        new UninitializedThisException(new R(\"\", false), \"\", \"\");\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(\"\", new R(\"\", true), \"\"));\n+        new UninitializedThisException(\"\", new R(\"\", false), \"\");\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(\"\", \"\", new R(\"\", true)));\n+        new UninitializedThisException(\"\", \"\", new R(\"\", false));\n+\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), new R(\"\", false), new R(\"\", false), true));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), new R(\"\", true), new R(\"\", false), true));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), new R(\"\", false), new R(\"\", true), true));\n+        new UninitializedThisException(new R(\"\", false), new R(\"\", false), new R(\"\", false), true);\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(\"\", new R(\"\", true), new R(\"\", false), true));\n+        runAndCatch(() -> new UninitializedThisException(\"\", new R(\"\", false), new R(\"\", true), true));\n+        new UninitializedThisException(\"\", new R(\"\", false), new R(\"\", false), true);\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), \"\", new R(\"\", false), true));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), \"\", new R(\"\", true), true));\n+        new UninitializedThisException(new R(\"\", false), \"\", new R(\"\", false), true);\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), new R(\"\", false), \"\", true));\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", false), new R(\"\", true), \"\", true));\n+        new UninitializedThisException(new R(\"\", false), new R(\"\", false), \"\", true);\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(new R(\"\", true), \"\", \"\", true));\n+        new UninitializedThisException(new R(\"\", false), \"\", \"\", true);\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(\"\", new R(\"\", true), \"\", true));\n+        new UninitializedThisException(\"\", new R(\"\", false), \"\", true);\n+\n+        out.println();\n+\n+        runAndCatch(() -> new UninitializedThisException(\"\", \"\", new R(\"\", true), true));\n+        new UninitializedThisException(\"\", \"\", new R(\"\", false), true);\n+\n+        String actualLog = log.toString().replaceAll(\"\\\\R\", \"\\n\");\n+        String expectedLog = EXPECTED_LOG_PATTERN.replace(\"${super}\", \"\") +\n+                             EXPECTED_LOG_PATTERN.replace(\"${super}\", \"-super\");\n+\n+        if (!Objects.equals(actualLog, expectedLog)) {\n+            throw new AssertionError(\"Expected log:\\n\" + expectedLog +\n+                                     \", but got: \" + actualLog);\n+        }\n+    }\n+\n+    static final String EXPECTED_LOG_PATTERN =\n+            \"\"\"\n+            -pre(true)-nest(false)-post(false)${super}\n+            -pre(false)-nest(true)-post(false)${super}\n+            check1\n+            -pre(false)-nest(false)-post(true)${super}\n+            check1\n+            check2\n+            -pre(false)-nest(false)-post(false)${super}\n+            check1\n+            check2\n+            check3\n+\n+            -nest(true)-post(false)${super}\n+            check1\n+            -nest(false)-post(true)${super}\n+            check1\n+            check2\n+            -nest(false)-post(false)${super}\n+            check1\n+            check2\n+            check3\n+\n+            -pre(true)-post(false)${super}\n+            -pre(false)-post(true)${super}\n+            check1\n+            check2\n+            -pre(false)-post(false)${super}\n+            check1\n+            check2\n+            check3\n+\n+            -pre(true)-nest(false)${super}\n+            -pre(false)-nest(true)${super}\n+            check1\n+            -pre(false)-nest(false)${super}\n+            check1\n+            check2\n+            check3\n+\n+            -pre(true)${super}\n+            -pre(false)${super}\n+            check1\n+            check2\n+            check3\n+\n+            -nest(true)${super}\n+            check1\n+            -nest(false)${super}\n+            check1\n+            check2\n+            check3\n+\n+            -post(true)${super}\n+            check1\n+            check2\n+            -post(false)${super}\n+            check1\n+            check2\n+            check3\n+            \"\"\";\n+\n+    static final StringWriter log = new StringWriter();\n+    static final PrintWriter out = new PrintWriter(log);\n+\n+    static void runAndCatch(Supplier<Object> toRun) {\n+        try {\n+            toRun.get();\n+            throw new AssertionError(\"Didn't get the expected exception!\");\n+        } catch (MatchException ex) {\n+            \/\/OK\n+        }\n+    }\n+    record R(String s, boolean fail) {\n+        public String s() {\n+            if (fail) {\n+                throw new NullPointerException();\n+            } else {\n+                return s;\n+            }\n+        }\n+    }\n+}\n+class Base {\n+    public Base(String s1, String s2) {\n+        Objects.requireNonNull(s1);\n+        Objects.requireNonNull(s2);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/UninitializedThisException.java","additions":390,"deletions":0,"binary":false,"changes":390,"status":"added"},{"patch":"@@ -106,1 +106,1 @@\n-        ModuleAttribute module = clazz.findAttribute(Attributes.MODULE).get();\n+        ModuleAttribute module = clazz.findAttribute(Attributes.module()).get();\n","filename":"test\/langtools\/tools\/javac\/platform\/ModuleVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332497\n+ * @summary error: javac prints an AssertionError when annotation processing runs on program with module imports\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.JavacTask toolbox.ToolBox toolbox.Task\n+ * @run main ModuleImportProcessingTest\n+ *\/\n+\n+import toolbox.*;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+import java.nio.file.Path;\n+import java.util.Set;\n+\n+\n+public class ModuleImportProcessingTest extends TestRunner {\n+    final toolbox.ToolBox tb = new ToolBox();\n+    final String processedSource = \"\"\"\n+        import module java.base;\n+        import java.lang.annotation.*;\n+        public class Main {\n+            public static void main(String[] args) {\n+                List.of();\n+            }\n+            @Ann\n+            private void test() {}\n+            @Retention(RetentionPolicy.RUNTIME)\n+            @Target(ElementType.METHOD)\n+            public @interface Ann {}\n+        }\n+        \"\"\";\n+\n+    public ModuleImportProcessingTest() {\n+        super(System.err);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new ModuleImportProcessingTest().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Path.of(m.getName()) });\n+    }\n+\n+    @Test\n+    public void test(Path base) throws Exception {\n+        tb.writeJavaFiles(base, processedSource);\n+        new toolbox.JavacTask(tb)\n+                .options(\n+                        \"-processor\", AP.class.getName(),\n+                        \"--enable-preview\",\n+                        \"-source\", Integer.toString(Runtime.version().feature()),\n+                        \"-proc:only\"\n+                )\n+                .files(tb.findJavaFiles(base))\n+                .run();\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class AP extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            return false;\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latest();\n+        }\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/processing\/ModuleImportProcessingTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -90,0 +90,4 @@\n+            \/\/ Temporarily ignore java.io.IO:\n+            if (f.getName().equals(\"ioType\"))\n+                continue;\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/TestSymtabItems.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-        ModuleAttribute module = cf.findAttribute(Attributes.MODULE).orElseThrow();\n+        ModuleAttribute module = cf.findAttribute(Attributes.module()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestOrigin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1323,1 +1323,1 @@\n-                        CodeAttribute code_attribute = method.findAttribute(Attributes.CODE).orElseThrow();\n+                        CodeAttribute code_attribute = method.findAttribute(Attributes.code()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-        RuntimeVisibleAnnotationsAttribute annotations = attributedElement.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow();\n+        RuntimeVisibleAnnotationsAttribute annotations = attributedElement.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/records\/recordComponent\/RecordComponentTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        PermittedSubclassesAttribute permittedSubclasses = sealedCF.findAttribute(Attributes.PERMITTED_SUBCLASSES).orElseThrow();\n+        PermittedSubclassesAttribute permittedSubclasses = sealedCF.findAttribute(Attributes.permittedSubclasses()).orElseThrow();\n@@ -155,1 +155,1 @@\n-        Assert.checkNull(subCF1.findAttribute(Attributes.PERMITTED_SUBCLASSES).orElse(null));\n+        Assert.checkNull(subCF1.findAttribute(Attributes.permittedSubclasses()).orElse(null));\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/varargs\/6199075\/T6199075.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/varargs\/7042566\/T7042566.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-        test(mm, Attributes.CODE, CodeAttribute.class);\n-        test(mm, Attributes.EXCEPTIONS, ExceptionsAttribute.class);\n+        test(mm, Attributes.code(), CodeAttribute.class);\n+        test(mm, Attributes.exceptions(), ExceptionsAttribute.class);\n","filename":"test\/langtools\/tools\/javap\/T6716452.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                cm.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+                cm.findAttribute(Attributes.innerClasses()).orElse(null);\n@@ -109,1 +109,1 @@\n-        SignatureAttribute sa = m.findAttribute(Attributes.SIGNATURE).orElse(null);\n+        SignatureAttribute sa = m.findAttribute(Attributes.signature()).orElse(null);\n@@ -176,1 +176,1 @@\n-        RuntimeInvisibleAnnotationsAttribute annots = m.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n+        RuntimeInvisibleAnnotationsAttribute annots = m.findAttribute(Attributes.runtimeInvisibleAnnotations()).orElse(null);\n","filename":"test\/langtools\/tools\/javap\/classfile\/6888367\/T6888367.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.runtimeVisibleTypeAnnotations());\n+        test(m, Attributes.runtimeInvisibleTypeAnnotations());\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/JSR175Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-        test(mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(mm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(mm, Attributes.runtimeVisibleTypeAnnotations());\n+        test(mm, Attributes.runtimeInvisibleTypeAnnotations());\n@@ -65,1 +65,1 @@\n-        cAttr = mm.findAttribute(Attributes.CODE).orElse(null);\n+        cAttr = mm.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/NewArray.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.runtimeVisibleTypeAnnotations());\n+        test(m, Attributes.runtimeInvisibleTypeAnnotations());\n@@ -83,1 +83,1 @@\n-            attr_instance = m.findAttribute(Attributes.CODE).orElse(null);\n+            attr_instance = m.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/Presence.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.runtimeVisibleTypeAnnotations());\n+        test(m, Attributes.runtimeInvisibleTypeAnnotations());\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/PresenceInner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-        test(mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(mm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(mm, Attributes.runtimeVisibleTypeAnnotations());\n+        test(mm, Attributes.runtimeInvisibleTypeAnnotations());\n@@ -69,1 +69,1 @@\n-        cAttr = mm.findAttribute(Attributes.CODE).orElse(null);\n+        cAttr = mm.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/TypeCasts.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-        test(mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(mm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(mm, Attributes.runtimeVisibleTypeAnnotations());\n+        test(mm, Attributes.runtimeInvisibleTypeAnnotations());\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/Visibility.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n-        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.runtimeVisibleTypeAnnotations());\n+        test(m, Attributes.runtimeInvisibleTypeAnnotations());\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/Wildcards.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib;\n+\n+import java.util.ArrayList;\n+\n+public class StringArrayUtils {\n+    \/**\n+     * The various concat() functions in this class can be used for building\n+     * a command-line argument array for ProcessTools.createTestJavaProcessBuilder(),\n+     * etc. When some of the arguments are conditional, this is more convenient\n+     * than alternatives like ArrayList.\n+     *\n+     * Example:\n+     *\n+     * <pre>\n+     *     String args[] = StringArrayUtils.concat(\"-Xint\", \"-Xmx32m\");\n+     *     if (verbose) {\n+     *         args = StringArrayUtils.concat(args, \"-verbose\");\n+     *     }\n+     *     args = StringArrayUtils.concat(args, \"HelloWorld\");\n+     *     ProcessTools.createTestJavaProcessBuilder(args);\n+     * <\/pre>\n+     *\/\n+    public static String[] concat(String... args) {\n+        return args;\n+    }\n+\n+    public static String[] concat(String[] prefix, String... extra) {\n+        String[] ret = new String[prefix.length + extra.length];\n+        System.arraycopy(prefix, 0, ret, 0, prefix.length);\n+        System.arraycopy(extra, 0, ret, prefix.length, extra.length);\n+        return ret;\n+    }\n+\n+    public static String[] concat(String prefix, String[] extra) {\n+        String[] ret = new String[1 + extra.length];\n+        ret[0] = prefix;\n+        System.arraycopy(extra, 0, ret, 1, extra.length);\n+        return ret;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/StringArrayUtils.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.cds;\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.StringArrayUtils;\n+\n+\/*\n+ * This is a base class used for testing CDS functionalities with complex applications.\n+ * You can define the application by overridding the vmArgs(), classpath() and appCommandLine()\n+ * methods. Application-specific validation checks can be implemented with checkExecution().\n+*\/\n+abstract public class CDSAppTester {\n+    private final String name;\n+    private final String classListFile;\n+    private final String classListFileLog;\n+    private final String staticArchiveFile;\n+    private final String staticArchiveFileLog;\n+    private final String dynamicArchiveFile;\n+    private final String dynamicArchiveFileLog;\n+    private final String productionRunLog;\n+\n+    public CDSAppTester(String name) {\n+        \/\/ Old workflow\n+        this.name = name;\n+        classListFile = name() + \".classlist\";\n+        classListFileLog = classListFile + \".log\";\n+        staticArchiveFile = name() + \".static.jsa\";\n+        staticArchiveFileLog = staticArchiveFile + \".log\";\n+        dynamicArchiveFile = name() + \".dynamic.jsa\";\n+        dynamicArchiveFileLog = dynamicArchiveFile + \".log\";\n+        productionRunLog = name() + \".production.log\";\n+    }\n+\n+    private enum Workflow {\n+        STATIC,        \/\/ classic -Xshare:dump workflow\n+        DYNAMIC,       \/\/ classic -XX:ArchiveClassesAtExit\n+    }\n+\n+    public enum RunMode {\n+        CLASSLIST,\n+        DUMP_STATIC,\n+        DUMP_DYNAMIC,\n+        PRODUCTION;\n+\n+        public boolean isStaticDump() {\n+            return this == DUMP_STATIC;\n+        }\n+        public boolean isProductionRun() {\n+            return this == PRODUCTION;\n+        }\n+    }\n+\n+    public final String name() {\n+        return this.name;\n+    }\n+\n+    \/\/ optional\n+    public String[] vmArgs(RunMode runMode) {\n+        return new String[0];\n+    }\n+\n+    \/\/ optional\n+    public String classpath(RunMode runMode) {\n+        return null;\n+    }\n+\n+    \/\/ must override\n+    \/\/ main class, followed by arguments to the main class\n+    abstract public String[] appCommandLine(RunMode runMode);\n+\n+    \/\/ optional\n+    public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {}\n+\n+    private Workflow workflow;\n+\n+    public final boolean isStaticWorkflow() {\n+        return workflow == Workflow.STATIC;\n+    }\n+\n+    public final boolean isDynamicWorkflow() {\n+        return workflow == Workflow.DYNAMIC;\n+    }\n+\n+    private String logToFile(String logFile, String... logTags) {\n+        StringBuilder sb = new StringBuilder(\"-Xlog:\");\n+        String prefix = \"\";\n+        for (String tag : logTags) {\n+            sb.append(prefix);\n+            sb.append(tag);\n+            prefix = \",\";\n+        }\n+        sb.append(\":file=\" + logFile + \"::filesize=0\");\n+        return sb.toString();\n+    }\n+\n+    private void listOutputFile(String file) {\n+        File f = new File(file);\n+        if (f.exists()) {\n+            System.out.println(\"[output file: \" + file + \" \" + f.length() + \" bytes]\");\n+        } else {\n+            System.out.println(\"[output file: \" + file + \" does not exist]\");\n+        }\n+    }\n+\n+    private OutputAnalyzer executeAndCheck(String[] cmdLine, RunMode runMode, String... logFiles) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        Process process = pb.start();\n+        OutputAnalyzer output = CDSTestUtils.executeAndLog(process, runMode.toString());\n+        for (String logFile : logFiles) {\n+            listOutputFile(logFile);\n+        }\n+        output.shouldHaveExitValue(0);\n+        CDSTestUtils.checkCommonExecExceptions(output);\n+        checkExecution(output, runMode);\n+        return output;\n+    }\n+\n+    private OutputAnalyzer createClassList() throws Exception {\n+        RunMode runMode = RunMode.CLASSLIST;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-Xshare:off\",\n+                                                   \"-XX:DumpLoadedClassList=\" + classListFile,\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(classListFileLog,\n+                                                             \"class+load=debug\"));\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+        return executeAndCheck(cmdLine, runMode, classListFile, classListFileLog);\n+    }\n+\n+    private OutputAnalyzer dumpStaticArchive() throws Exception {\n+        RunMode runMode = RunMode.DUMP_STATIC;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-Xlog:cds\",\n+                                                   \"-Xlog:cds+heap=error\",\n+                                                   \"-Xshare:dump\",\n+                                                   \"-XX:SharedArchiveFile=\" + staticArchiveFile,\n+                                                   \"-XX:SharedClassListFile=\" + classListFile,\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(staticArchiveFileLog,\n+                                                             \"cds=debug\",\n+                                                             \"cds+class=debug\",\n+                                                             \"cds+heap=warning\",\n+                                                             \"cds+resolve=debug\"));\n+        return executeAndCheck(cmdLine, runMode, staticArchiveFile, staticArchiveFileLog);\n+    }\n+\n+    private OutputAnalyzer dumpDynamicArchive() throws Exception {\n+        RunMode runMode = RunMode.DUMP_DYNAMIC;\n+        String[] cmdLine = new String[0];\n+        if (isDynamicWorkflow()) {\n+          \/\/ \"classic\" dynamic archive\n+          cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                            \"-Xlog:cds\",\n+                                            \"-XX:ArchiveClassesAtExit=\" + dynamicArchiveFile,\n+                                            \"-cp\", classpath(runMode),\n+                                            logToFile(dynamicArchiveFileLog,\n+                                                      \"cds=debug\",\n+                                                      \"cds+class=debug\",\n+                                                      \"cds+resolve=debug\",\n+                                                      \"class+load=debug\"));\n+        }\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+        return executeAndCheck(cmdLine, runMode, dynamicArchiveFile, dynamicArchiveFileLog);\n+    }\n+\n+    private OutputAnalyzer productionRun() throws Exception {\n+        RunMode runMode = RunMode.PRODUCTION;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(productionRunLog, \"cds\"));\n+\n+        if (isStaticWorkflow()) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-XX:SharedArchiveFile=\" + staticArchiveFile);\n+        } else if (isDynamicWorkflow()) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-XX:SharedArchiveFile=\" + dynamicArchiveFile);\n+        }\n+\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+        return executeAndCheck(cmdLine, runMode, productionRunLog);\n+    }\n+\n+    public void run(String args[]) throws Exception {\n+        String err = \"Must have exactly one command line argument of the following: \";\n+        String prefix = \"\";\n+        for (Workflow wf : Workflow.values()) {\n+            err += prefix;\n+            err += wf;\n+            prefix = \", \";\n+        }\n+        if (args.length != 1) {\n+            throw new RuntimeException(err);\n+        } else {\n+            if (args[0].equals(\"STATIC\")) {\n+                runStaticWorkflow();\n+            } else if (args[0].equals(\"DYNAMIC\")) {\n+                runDynamicWorkflow();\n+            } else {\n+                throw new RuntimeException(err);\n+            }\n+        }\n+    }\n+\n+    private void runStaticWorkflow() throws Exception {\n+        this.workflow = Workflow.STATIC;\n+        createClassList();\n+        dumpStaticArchive();\n+        productionRun();\n+    }\n+\n+    private void runDynamicWorkflow() throws Exception {\n+        this.workflow = Workflow.DYNAMIC;\n+        dumpDynamicArchive();\n+        productionRun();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -198,2 +198,1 @@\n-                                                           \"Old\",\n-                                                           \"Archive\"\n+                                                           \"Old\"\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/GCHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class SwitchSanity {\n+\n+    public record A(int a) { }\n+    public record B(int b) { }\n+    public record C(int c) { }\n+\n+    public Object[] inputs = new Object[10];\n+    @Setup\n+    public void setup() {\n+        for (int i = 0; i < 10; i++) {\n+            if (i % 2 == 0) {\n+                inputs[i] = new A(i + 17);\n+            } else if (i % 3 == 0) {\n+                inputs[i] = new B(i + 4711);\n+            } else {\n+                inputs[i] = new C(i + 174711);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public int switchSum() {\n+        int sum = 0;\n+        for (Object o : inputs) {\n+            sum += switch (o) {\n+                case A a -> a.a;\n+                case B b -> b.b;\n+                case C c -> c.c;\n+                default -> 17;\n+            };\n+        }\n+        return sum;\n+    }\n+\n+    public static void main(String[] args) {\n+        SwitchSanity s = new SwitchSanity();\n+        s.setup();\n+        System.out.println(s.switchSum());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/SwitchSanity.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.sun.misc;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.TimeUnit;\n+import sun.misc.Unsafe;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@SuppressWarnings(\"removal\")\n+public class UnsafeOps {\n+    static final Unsafe U;\n+    static {\n+        try {\n+            Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            f.setAccessible(true);\n+            U = (Unsafe) f.get(null);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    private static class TestClass {\n+        long value;\n+    }\n+\n+    private Object object;\n+    private long valueOffset;\n+    private long address;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        object = new TestClass();\n+        Field f = TestClass.class.getDeclaredField(\"value\");\n+        valueOffset = U.objectFieldOffset(f);\n+\n+        address = U.allocateMemory(1000);\n+    }\n+\n+    @TearDown\n+    public void finish() {\n+        U.freeMemory(address);\n+    }\n+\n+    @Benchmark\n+    public void putLongOnHeap() {\n+        U.putLong(object, 0, 99);\n+    }\n+\n+    @Benchmark\n+    public long getLongOnHeap() {\n+        return U.getLong(object, 0);\n+    }\n+\n+    @Benchmark\n+    public void putLongOffHeap() {\n+        U.putLong(null, address, 99);\n+    }\n+\n+    @Benchmark\n+    public long getLongOffHeap() {\n+        return U.getLong(null, address);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/sun\/misc\/UnsafeOps.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -108,1 +108,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySupersCache\"})\n@@ -115,1 +115,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySupersCache\"})\n@@ -122,1 +122,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySupersCache\"})\n@@ -129,1 +129,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySupersCache\"})\n@@ -152,1 +152,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:-UseSecondarySupersCache\"})\n@@ -158,1 +158,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseSecondarySupersTable\", \"-XX:+UseSecondarySupersCache\"})\n@@ -164,1 +164,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:-UseSecondarySupersCache\"})\n@@ -170,1 +170,1 @@\n-    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySuperCache\"})\n+    @Fork(jvmArgsAppend={\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseSecondarySupersTable\", \"-XX:+UseSecondarySupersCache\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/TypePollution.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}