{"files":[{"patch":"@@ -97,1 +97,1 @@\n-    DISABLED_WARNINGS := restricted this-escape processing rawtypes cast \\\n+    DISABLED_WARNINGS := restricted this-escape processing rawtypes removal cast \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-  __ lsr(tmp1, tmp1, HeapRegion::LogOfHRGrainBytes);\n+  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,15 +300,0 @@\n-void BarrierSetAssembler::incr_allocated_bytes(MacroAssembler* masm,\n-                                               Register var_size_in_bytes,\n-                                               int con_size_in_bytes,\n-                                               Register t1) {\n-  assert(t1->is_valid(), \"need temp reg\");\n-\n-  __ ldr(t1, Address(rthread, in_bytes(JavaThread::allocated_bytes_offset())));\n-  if (var_size_in_bytes->is_valid()) {\n-    __ add(t1, t1, var_size_in_bytes);\n-  } else {\n-    __ add(t1, t1, con_size_in_bytes);\n-  }\n-  __ str(t1, Address(rthread, in_bytes(JavaThread::allocated_bytes_offset())));\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,5 +47,0 @@\n-private:\n-  void incr_allocated_bytes(MacroAssembler* masm,\n-                            Register var_size_in_bytes, int con_size_in_bytes,\n-                            Register t1 = noreg);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4038,1 +4038,1 @@\n- * r5: zlen\n+ * r5: tmp0\n@@ -4049,1 +4049,1 @@\n-                                     Register z, Register zlen,\n+                                     Register z, Register tmp0,\n@@ -4053,1 +4053,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+  assert_different_registers(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, product_hi);\n@@ -4062,1 +4062,1 @@\n-  const Register x_xstart = zlen;  \/\/ reuse register\n+  const Register x_xstart = tmp0;\n@@ -4078,3 +4078,3 @@\n-  movw(idx, ylen);      \/\/ idx = ylen;\n-  movw(kdx, zlen);      \/\/ kdx = xlen+ylen;\n-  mov(carry, zr);       \/\/ carry = 0;\n+  movw(idx, ylen);       \/\/ idx = ylen;\n+  addw(kdx, xlen, ylen); \/\/ kdx = xlen+ylen;\n+  mov(carry, zr);        \/\/ carry = 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1593,1 +1593,1 @@\n-                       Register zlen, Register tmp1, Register tmp2, Register tmp3,\n+                       Register tmp0, Register tmp1, Register tmp2, Register tmp3,\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4670,1 +4670,0 @@\n-   *    c_rarg5   - z length\n@@ -4682,1 +4681,1 @@\n-    const Register zlen  = r5;\n+    const Register tmp0  = r5;\n@@ -4694,1 +4693,1 @@\n-    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n@@ -4712,1 +4711,0 @@\n-    const Register zlen  = r3;\n@@ -4716,0 +4714,1 @@\n+    const Register tmp0  = r3;\n@@ -4730,1 +4729,1 @@\n-    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5663,1 +5663,0 @@\n-#ifdef _LP64\n@@ -5697,1 +5696,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-  __ shrptr(tmp, HeapRegion::LogOfHRGrainBytes);\n+  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,30 +370,0 @@\n-void BarrierSetAssembler::incr_allocated_bytes(MacroAssembler* masm, Register thread,\n-                                               Register var_size_in_bytes,\n-                                               int con_size_in_bytes,\n-                                               Register t1) {\n-  if (!thread->is_valid()) {\n-#ifdef _LP64\n-    thread = r15_thread;\n-#else\n-    assert(t1->is_valid(), \"need temp reg\");\n-    thread = t1;\n-    __ get_thread(thread);\n-#endif\n-  }\n-\n-#ifdef _LP64\n-  if (var_size_in_bytes->is_valid()) {\n-    __ addq(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), var_size_in_bytes);\n-  } else {\n-    __ addq(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), con_size_in_bytes);\n-  }\n-#else\n-  if (var_size_in_bytes->is_valid()) {\n-    __ addl(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), var_size_in_bytes);\n-  } else {\n-    __ addl(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())), con_size_in_bytes);\n-  }\n-  __ adcl(Address(thread, in_bytes(JavaThread::allocated_bytes_offset())+4), 0);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,6 +40,0 @@\n-private:\n-  void incr_allocated_bytes(MacroAssembler* masm, Register thread,\n-                            Register var_size_in_bytes,\n-                            int con_size_in_bytes,\n-                            Register t1);\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -238,2 +238,4 @@\n-             \"mitigations for the Intel JCC erratum\")\n-\n+             \"mitigations for the Intel JCC erratum\")                       \\\n+                                                                            \\\n+  product(bool, UseAPX, false, EXPERIMENTAL,                                \\\n+          \"Use Advanced Performance Extensions on x86\")                     \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1160,1 +1160,1 @@\n-  align(64, (unsigned long long) pc());\n+  align(64, (uint)(uintptr_t)pc());\n@@ -1164,1 +1164,1 @@\n-  align(32, (unsigned long long) pc());\n+  align(32, (uint)(uintptr_t)pc());\n@@ -1167,1 +1167,1 @@\n-void MacroAssembler::align(int modulus) {\n+void MacroAssembler::align(uint modulus) {\n@@ -1169,1 +1169,1 @@\n-  assert(modulus <= CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n+  assert(modulus <= (uintx)CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n@@ -1173,1 +1173,1 @@\n-void MacroAssembler::align(int modulus, int target) {\n+void MacroAssembler::align(uint modulus, uint target) {\n@@ -7747,1 +7747,1 @@\n- * r11: zlen\n+ * r11: tmp0\n@@ -7755,1 +7755,1 @@\n-void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,\n+void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register tmp0,\n@@ -7758,1 +7758,1 @@\n-  assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);\n+  assert_different_registers(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);\n@@ -7760,0 +7760,1 @@\n+  push(tmp0);\n@@ -7767,1 +7768,0 @@\n-  push(zlen);\n@@ -7776,1 +7776,1 @@\n-  const Register x_xstart = zlen;  \/\/ reuse register\n+  const Register x_xstart = tmp0;\n@@ -7792,3 +7792,3 @@\n-  movl(idx, ylen);      \/\/ idx = ylen;\n-  movl(kdx, zlen);      \/\/ kdx = xlen+ylen;\n-  xorq(carry, carry);   \/\/ carry = 0;\n+  movl(idx, ylen);               \/\/ idx = ylen;\n+  lea(kdx, Address(xlen, ylen)); \/\/ kdx = xlen+ylen;\n+  xorq(carry, carry);            \/\/ carry = 0;\n@@ -7898,1 +7898,0 @@\n-  pop(zlen);\n@@ -7906,0 +7905,1 @@\n+  pop(tmp0);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -249,2 +249,2 @@\n-  void align(int modulus);\n-  void align(int modulus, int target);\n+  void align(uint modulus);\n+  void align(uint modulus, uint target);\n@@ -2094,1 +2094,1 @@\n-  void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,\n+  void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register tmp0,\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3063,1 +3063,0 @@\n- *    c_rarg5   - z length\n@@ -3066,1 +3065,0 @@\n- *    rsp+48    - z length\n@@ -3080,1 +3078,0 @@\n-  const Register zlen  = r11;\n@@ -3083,0 +3080,1 @@\n+  const Register tmp0  = r11;\n@@ -3092,4 +3090,1 @@\n-#ifndef _WIN64\n-  __ movptr(zlen, r9); \/\/ Save r9 in r11 - zlen\n-#endif\n-                     \/\/ ylen => rcx, z => r8, zlen => r11\n+                     \/\/ ylen => rcx, z => r8\n@@ -3099,1 +3094,1 @@\n-  \/\/ last 2 arguments (#4, #5) are on stack on Win64\n+  \/\/ last argument (#4) is on stack on Win64\n@@ -3101,1 +3096,0 @@\n-  __ movptr(zlen, Address(rsp, 7 * wordSize));\n@@ -3106,1 +3100,1 @@\n-  __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5);\n+  __ multiply_to_len(x, xlen, y, ylen, z, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1005,0 +1005,8 @@\n+  \/\/ APX support not enabled yet\n+  if (UseAPX) {\n+    if (!FLAG_IS_DEFAULT(UseAPX)) {\n+        warning(\"APX is not supported on this CPU.\");\n+    }\n+    FLAG_SET_DEFAULT(UseAPX, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7271,0 +7271,1 @@\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_DOUBLE);\n@@ -7274,2 +7275,0 @@\n-    assert(UseAVX > 0, \"required\");\n-\n@@ -7283,0 +7282,11 @@\n+instruct vcastBtoD(legVec dst, legVec src) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastB2X src));\n+  format %{ \"vector_cast_b2x $dst,$src\\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vconvert_b2x(T_DOUBLE, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -200,1 +200,0 @@\n-#ifdef ASSERT\n@@ -207,1 +206,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    guarantee(MIN_GC_REGION_ALIGNMENT <= \/*G1*\/HeapRegion::min_region_size_in_words() * HeapWordSize, \"must be\");\n+    guarantee(MIN_GC_REGION_ALIGNMENT <= G1HeapRegion::min_region_size_in_words() * HeapWordSize, \"must be\");\n@@ -442,1 +442,1 @@\n-    _requested_bottom = align_down(heap_end - heap_region_byte_size, HeapRegion::GrainBytes);\n+    _requested_bottom = align_down(heap_end - heap_region_byte_size, G1HeapRegion::GrainBytes);\n@@ -452,1 +452,1 @@\n-  assert(is_aligned(_requested_bottom, HeapRegion::GrainBytes), \"sanity\");\n+  assert(is_aligned(_requested_bottom, G1HeapRegion::GrainBytes), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-    _input_stream(&_file_input) {\n+    _input_stream(&_file_input),\n+    _parse_mode(parse_mode) {\n@@ -73,1 +74,0 @@\n-  _parse_mode = parse_mode;\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2139,2 +2139,2 @@\n-  log_info(cds)(\"The current max heap size = \" SIZE_FORMAT \"M, HeapRegion::GrainBytes = \" SIZE_FORMAT,\n-                MaxHeapSize\/M, HeapRegion::GrainBytes);\n+  log_info(cds)(\"The current max heap size = \" SIZE_FORMAT \"M, G1HeapRegion::GrainBytes = \" SIZE_FORMAT,\n+                MaxHeapSize\/M, G1HeapRegion::GrainBytes);\n@@ -2205,1 +2205,1 @@\n-    assert(is_aligned(_mapped_heap_memregion.start(), HeapRegion::GrainBytes), \"must be\");\n+    assert(is_aligned(_mapped_heap_memregion.start(), G1HeapRegion::GrainBytes), \"must be\");\n@@ -2215,1 +2215,1 @@\n-    assert(heap_end - mapped_heap_region_end < (intx)(HeapRegion::GrainBytes),\n+    assert(heap_end - mapped_heap_region_end < (intx)(G1HeapRegion::GrainBytes),\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2932,5 +2932,0 @@\n-  if (name == vmSymbols::object_initializer_name() &&\n-      signature == vmSymbols::void_method_signature() &&\n-      m->is_vanilla_constructor()) {\n-    _has_vanilla_constructor = true;\n-  }\n@@ -4350,23 +4345,0 @@\n-  \/\/ Check if this klass has a vanilla default constructor\n-  if (super == nullptr) {\n-    \/\/ java.lang.Object has empty default constructor\n-    ik->set_has_vanilla_constructor();\n-  } else {\n-    if (super->has_vanilla_constructor() &&\n-        _has_vanilla_constructor) {\n-      ik->set_has_vanilla_constructor();\n-    }\n-#ifdef ASSERT\n-    bool v = false;\n-    if (super->has_vanilla_constructor()) {\n-      const Method* const constructor =\n-        ik->find_method(vmSymbols::object_initializer_name(),\n-                       vmSymbols::void_method_signature());\n-      if (constructor != nullptr && constructor->is_vanilla_constructor()) {\n-        v = true;\n-      }\n-    }\n-    assert(v == ik->has_vanilla_constructor(), \"inconsistent has_vanilla_constructor\");\n-#endif\n-  }\n-\n@@ -5679,1 +5651,1 @@\n-  \/\/ Fill in has_finalizer, has_vanilla_constructor, and layout_helper\n+  \/\/ Fill in has_finalizer and layout_helper\n@@ -5905,1 +5877,0 @@\n-  _has_vanilla_constructor(false),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -222,1 +222,0 @@\n-  bool _has_vanilla_constructor;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  template(java_lang_Package,                         \"java\/lang\/Package\")                        \\\n@@ -121,1 +120,0 @@\n-  template(java_lang_CharSequence,                    \"java\/lang\/CharSequence\")                   \\\n@@ -134,5 +132,0 @@\n-  template(java_io_OutputStream,                      \"java\/io\/OutputStream\")                     \\\n-  template(java_io_Reader,                            \"java\/io\/Reader\")                           \\\n-  template(java_io_BufferedReader,                    \"java\/io\/BufferedReader\")                   \\\n-  template(java_io_File,                              \"java\/io\/File\")                             \\\n-  template(java_io_FileInputStream,                   \"java\/io\/FileInputStream\")                  \\\n@@ -143,5 +136,0 @@\n-  template(java_util_Objects,                         \"java\/util\/Objects\")                        \\\n-  template(java_util_Vector,                          \"java\/util\/Vector\")                         \\\n-  template(java_util_AbstractList,                    \"java\/util\/AbstractList\")                   \\\n-  template(java_util_Hashtable,                       \"java\/util\/Hashtable\")                      \\\n-  template(java_lang_Compiler,                        \"java\/lang\/Compiler\")                       \\\n@@ -153,2 +141,0 @@\n-  template(getBootClassPathEntryForClass_name,        \"getBootClassPathEntryForClass\")            \\\n-  template(sun_net_www_ParseUtil,                     \"sun\/net\/www\/ParseUtil\")                    \\\n@@ -232,1 +218,0 @@\n-  template(java_lang_NoSuchFieldException,            \"java\/lang\/NoSuchFieldException\")           \\\n@@ -242,1 +227,0 @@\n-  template(java_security_PrivilegedActionException,   \"java\/security\/PrivilegedActionException\")  \\\n@@ -291,1 +275,0 @@\n-  template(checkedExceptions_name,                    \"checkedExceptions\")                        \\\n@@ -370,4 +353,0 @@\n-  template(setTargetNormal_name,                      \"setTargetNormal\")                          \\\n-  template(setTargetVolatile_name,                    \"setTargetVolatile\")                        \\\n-  template(setTarget_signature,                       \"(Ljava\/lang\/invoke\/MethodHandle;)V\")       \\\n-  template(DEFAULT_CONTEXT_name,                      \"DEFAULT_CONTEXT\")                          \\\n@@ -418,1 +397,0 @@\n-  template(reference_lock_name,                       \"lock\")                                     \\\n@@ -433,2 +411,0 @@\n-  template(getStacks_name,                            \"getStacks\")                                \\\n-  template(onPinned_name,                             \"onPinned0\")                                \\\n@@ -442,1 +418,0 @@\n-  template(numOops_name,                              \"numOops\")                                  \\\n@@ -448,1 +423,0 @@\n-  template(numInterpretedFrames_name,                 \"numInterpretedFrames\")                     \\\n@@ -454,2 +428,0 @@\n-  template(refStack_name,                             \"refStack\")                                 \\\n-  template(refSP_name,                                \"refSP\")                                    \\\n@@ -461,1 +433,0 @@\n-  template(deadChild_name,                            \"deadChild\")                                \\\n@@ -477,1 +448,0 @@\n-  template(newInstance0_name,                         \"newInstance0\")                             \\\n@@ -499,1 +469,0 @@\n-  template(vmcount_name,                              \"vmcount\")                                  \\\n@@ -569,1 +538,0 @@\n-  template(bool_bool_void_signature,                  \"(ZZ)V\")                                    \\\n@@ -598,2 +566,0 @@\n-  template(int_array_signature,                       \"[I\")                                       \\\n-  template(long_array_signature,                      \"[J\")                                       \\\n@@ -604,1 +570,0 @@\n-  template(vthread_signature,                         \"Ljava\/lang\/VirtualThread;\")                \\\n@@ -611,2 +576,0 @@\n-  template(string_int_signature,                      \"(Ljava\/lang\/String;)I\")                    \\\n-  template(string_byte_array_signature,               \"(Ljava\/lang\/String;)[B\")                   \\\n@@ -623,4 +586,0 @@\n-  template(throwable_string_void_signature,           \"(Ljava\/lang\/Throwable;Ljava\/lang\/String;)V\")               \\\n-  template(string_array_void_signature,               \"([Ljava\/lang\/String;)V\")                                   \\\n-  template(string_array_string_array_void_signature,  \"([Ljava\/lang\/String;[Ljava\/lang\/String;)V\")                \\\n-  template(thread_throwable_void_signature,           \"(Ljava\/lang\/Thread;Ljava\/lang\/Throwable;)V\")               \\\n@@ -635,2 +594,1 @@\n-  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\") \\\n-  template(string_string_string_signature,            \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\") \\\n+  template(object_object_boolean_signature,           \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Z\")                  \\\n@@ -640,2 +598,0 @@\n-  template(char_array_void_signature,                 \"([C)V\")                                                    \\\n-  template(int_int_void_signature,                    \"(II)V\")                                                    \\\n@@ -650,1 +606,0 @@\n-  template(void_module_signature,                     \"()Ljava\/lang\/Module;\")                                     \\\n@@ -653,1 +608,0 @@\n-  template(exception_void_signature,                  \"(Ljava\/lang\/Exception;)V\")                                 \\\n@@ -659,1 +613,0 @@\n-  template(thread_array_signature,                    \"[Ljava\/lang\/Thread;\")                                      \\\n@@ -671,1 +624,0 @@\n-  template(weakreference_array_signature,             \"[Ljava\/lang\/ref\/WeakReference;\")                           \\\n@@ -701,1 +653,0 @@\n-  template(java_lang_management_ThreadState,           \"java\/lang\/management\/ThreadState\")                        \\\n@@ -738,1 +689,0 @@\n-  template(gcInfoBuilder_name,                         \"gcInfoBuilder\")                                           \\\n@@ -745,4 +695,0 @@\n-  template(addThreadDumpForMonitors_name,              \"addThreadDumpForMonitors\")                                \\\n-  template(addThreadDumpForSynchronizers_name,         \"addThreadDumpForSynchronizers\")                           \\\n-  template(addThreadDumpForMonitors_signature,         \"(Ljava\/lang\/management\/ThreadInfo;[Ljava\/lang\/Object;[I)V\") \\\n-  template(addThreadDumpForSynchronizers_signature,    \"(Ljava\/lang\/management\/ThreadInfo;[Ljava\/lang\/Object;)V\")   \\\n@@ -804,1 +750,0 @@\n-  template(url_void_signature,                              \"(Ljava\/net\/URL;)V\")                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -4047,2 +4047,0 @@\n-#ifndef PRODUCT\n-#endif\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -456,2 +456,2 @@\n-    \/\/ Node* region_size = __ ConI(1 << HeapRegion::LogOfHRGrainBytes);\n-    Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(checked_cast<jint>(HeapRegion::LogOfHRGrainBytes)));\n+    \/\/ Node* region_size = __ ConI(1 << G1HeapRegion::LogOfHRGrainBytes);\n+    Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(checked_cast<jint>(G1HeapRegion::LogOfHRGrainBytes)));\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+  \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n@@ -447,1 +447,1 @@\n-  HeapRegion* region = _g1h->heap_region_containing(obj_start);\n+  G1HeapRegion* region = _g1h->heap_region_containing(obj_start);\n@@ -472,1 +472,1 @@\n-  HeapRegion* const from_region = _g1h->heap_region_containing(old);\n+  G1HeapRegion* const from_region = _g1h->heap_region_containing(old);\n@@ -556,1 +556,1 @@\n-    \/\/ However, HeapRegion::is_survivor() is too expensive here.\n+    \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n@@ -627,1 +627,1 @@\n-void G1ParScanThreadStateSet::record_unused_optional_region(HeapRegion* hr) {\n+void G1ParScanThreadStateSet::record_unused_optional_region(G1HeapRegion* hr) {\n@@ -644,1 +644,1 @@\n-    HeapRegion* r = _g1h->heap_region_containing(old);\n+    G1HeapRegion* r = _g1h->heap_region_containing(old);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -55,1 +56,3 @@\n-ParCompactionManager::ParCompactionManager() {\n+PreservedMarksSet* ParCompactionManager::_preserved_marks_set = nullptr;\n+\n+ParCompactionManager::ParCompactionManager(PreservedMarks* preserved_marks) {\n@@ -62,3 +65,1 @@\n-  reset_bitmap_query_cache();\n-\n-  _deferred_obj_array = new (mtGC) GrowableArray<HeapWord*>(10, mtGC);\n+  _preserved_marks = preserved_marks;\n@@ -83,0 +84,3 @@\n+  _preserved_marks_set = new PreservedMarksSet(true);\n+  _preserved_marks_set->init(parallel_gc_threads);\n+\n@@ -85,1 +89,1 @@\n-    _manager_array[i] = new ParCompactionManager();\n+    _manager_array[i] = new ParCompactionManager(_preserved_marks_set->get(i));\n@@ -97,6 +101,0 @@\n-}\n-void ParCompactionManager::reset_all_bitmap_query_caches() {\n-  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n-  for (uint i=0; i<parallel_gc_threads; i++) {\n-    _manager_array[i]->reset_bitmap_query_cache();\n-  }\n@@ -172,9 +170,0 @@\n-void ParCompactionManager::drain_deferred_objects() {\n-  while (!_deferred_obj_array->is_empty()) {\n-    HeapWord* addr = _deferred_obj_array->pop();\n-    assert(addr != nullptr, \"expected a deferred object\");\n-    PSParallelCompact::update_deferred_object(this, addr);\n-  }\n-  _deferred_obj_array->clear_and_deallocate();\n-}\n-\n@@ -211,4 +200,0 @@\n-void ParCompactionManager::push_deferred_object(HeapWord* addr) {\n-  _deferred_obj_array->push(addr);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/parallel\/objectStartArray.inline.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -102,0 +104,1 @@\n+static_assert(ParallelCompactData::RegionSize >= BitsPerWord, \"region-start bit word-aligned\");\n@@ -108,12 +111,0 @@\n-const size_t ParallelCompactData::Log2BlockSize   = 7; \/\/ 128 words\n-const size_t ParallelCompactData::BlockSize       = (size_t)1 << Log2BlockSize;\n-const size_t ParallelCompactData::BlockSizeBytes  =\n-  BlockSize << LogHeapWordSize;\n-const size_t ParallelCompactData::BlockSizeOffsetMask = BlockSize - 1;\n-const size_t ParallelCompactData::BlockAddrOffsetMask = BlockSizeBytes - 1;\n-const size_t ParallelCompactData::BlockAddrMask       = ~BlockAddrOffsetMask;\n-\n-const size_t ParallelCompactData::BlocksPerRegion = RegionSize \/ BlockSize;\n-const size_t ParallelCompactData::Log2BlocksPerRegion =\n-  Log2RegionSize - Log2BlockSize;\n-\n@@ -416,4 +407,1 @@\n-  _region_count(0),\n-  _block_vspace(nullptr),\n-  _block_data(nullptr),\n-  _block_count(0) {}\n+  _region_count(0) {}\n@@ -430,2 +418,1 @@\n-  bool result = initialize_region_data(heap_size) && initialize_block_data();\n-  return result;\n+  return initialize_region_data(heap_size);\n@@ -477,13 +464,0 @@\n-bool ParallelCompactData::initialize_block_data()\n-{\n-  assert(_region_count != 0, \"region data must be initialized first\");\n-  const size_t count = _region_count << Log2BlocksPerRegion;\n-  _block_vspace = create_vspace(count, sizeof(BlockData));\n-  if (_block_vspace != 0) {\n-    _block_data = (BlockData*)_block_vspace->reserved_low_addr();\n-    _block_count = count;\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -493,1 +467,0 @@\n-  assert(RegionSize % BlockSize == 0, \"RegionSize not a multiple of BlockSize\");\n@@ -497,18 +470,0 @@\n-\n-  const size_t beg_block = beg_region * BlocksPerRegion;\n-  const size_t block_cnt = region_cnt * BlocksPerRegion;\n-  memset(_block_data + beg_block, 0, block_cnt * sizeof(BlockData));\n-}\n-\n-HeapWord* ParallelCompactData::partial_obj_end(size_t region_idx) const\n-{\n-  const RegionData* cur_cp = region(region_idx);\n-  const RegionData* const end_cp = region(region_count() - 1);\n-\n-  HeapWord* result = region_to_addr(region_idx);\n-  if (cur_cp < end_cp) {\n-    do {\n-      result += cur_cp->partial_obj_size();\n-    } while (cur_cp->partial_obj_size() == RegionSize && ++cur_cp < end_cp);\n-  }\n-  return result;\n@@ -765,43 +720,0 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const {\n-  assert(addr != nullptr, \"Should detect null oop earlier\");\n-  assert(ParallelScavengeHeap::heap()->is_in(addr), \"not in heap\");\n-  assert(PSParallelCompact::mark_bitmap()->is_marked(addr), \"not marked\");\n-\n-  \/\/ Region covering the object.\n-  RegionData* const region_ptr = addr_to_region_ptr(addr);\n-  HeapWord* result = region_ptr->destination();\n-\n-  \/\/ If the entire Region is live, the new location is region->destination + the\n-  \/\/ offset of the object within in the Region.\n-\n-  \/\/ Run some performance tests to determine if this special case pays off.  It\n-  \/\/ is worth it for pointers into the dense prefix.  If the optimization to\n-  \/\/ avoid pointer updates in regions that only point to the dense prefix is\n-  \/\/ ever implemented, this should be revisited.\n-  if (region_ptr->data_size() == RegionSize) {\n-    result += region_offset(addr);\n-    return result;\n-  }\n-\n-  \/\/ Otherwise, the new location is region->destination + block offset + the\n-  \/\/ number of live words in the Block that are (a) to the left of addr and (b)\n-  \/\/ due to objects that start in the Block.\n-\n-  \/\/ Fill in the block table if necessary.  This is unsynchronized, so multiple\n-  \/\/ threads may fill the block table for a region (harmless, since it is\n-  \/\/ idempotent).\n-  if (!region_ptr->blocks_filled()) {\n-    PSParallelCompact::fill_blocks(addr_to_region_idx(addr));\n-    region_ptr->set_blocks_filled();\n-  }\n-\n-  HeapWord* const search_start = block_align_down(addr);\n-  const size_t block_offset = addr_to_block_ptr(addr)->offset();\n-\n-  const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();\n-  const size_t live = bitmap->live_words_in_range(cm, search_start, cast_to_oop(addr));\n-  result += block_offset + live;\n-  DEBUG_ONLY(PSParallelCompact::check_new_location(addr, result));\n-  return result;\n-}\n-\n@@ -821,1 +733,0 @@\n-  verify_clear(_block_vspace);\n@@ -835,0 +746,13 @@\n+class PCAdjustPointerClosure: public BasicOopIterateClosure {\n+  template <typename T>\n+  void do_oop_work(T* p) { PSParallelCompact::adjust_pointer(p); }\n+\n+public:\n+  virtual void do_oop(oop* p)                { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)          { do_oop_work(p); }\n+\n+  virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }\n+};\n+\n+static PCAdjustPointerClosure pc_adjust_pointer_closure;\n+\n@@ -906,3 +830,1 @@\n-  const idx_t beg_bit = _mark_bitmap.addr_to_bit(bot);\n-  const idx_t end_bit = _mark_bitmap.addr_to_bit(top);\n-  _mark_bitmap.clear_range(beg_bit, end_bit);\n+  _mark_bitmap.clear_range(bot, top);\n@@ -951,2 +873,0 @@\n-\n-  ParCompactionManager::reset_all_bitmap_query_caches();\n@@ -1083,1 +1003,0 @@\n-  idx_t const dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);\n@@ -1086,1 +1005,1 @@\n-      _mark_bitmap.is_obj_beg(dense_prefix_bit)) {\n+      _mark_bitmap.is_marked(dense_prefix_end)) {\n@@ -1091,1 +1010,3 @@\n-  if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {\n+  HeapWord* block_start = start_array(id)->block_start_reaching_into_card(dense_prefix_end);\n+  if (block_start == dense_prefix_end - 1) {\n+    assert(!_mark_bitmap.is_marked(block_start), \"inv\");\n@@ -1093,1 +1014,1 @@\n-    \/\/ The filler object will extend into the region after the last dense prefix region.\n+    \/\/ The filler object will extend into region_after_dense_prefix.\n@@ -1097,1 +1018,1 @@\n-    _mark_bitmap.mark_obj(obj_beg, obj_len);\n+    _mark_bitmap.mark_obj(obj_beg);\n@@ -1363,3 +1284,3 @@\n-    \/\/ adjust_roots() updates Universe::_intArrayKlass which is\n-    \/\/ needed by the compaction for filling holes in the dense prefix.\n-    adjust_roots();\n+    forward_to_new_addr();\n+\n+    adjust_pointers();\n@@ -1369,0 +1290,2 @@\n+    ParCompactionManager::_preserved_marks_set->restore(&ParallelScavengeHeap::heap()->workers());\n+\n@@ -1689,0 +1612,78 @@\n+template<typename Func>\n+void PSParallelCompact::adjust_in_space_helper(SpaceId id, volatile uint* claim_counter, Func&& on_stripe) {\n+  MutableSpace* sp = PSParallelCompact::space(id);\n+  HeapWord* const bottom = sp->bottom();\n+  HeapWord* const top = sp->top();\n+  if (bottom == top) {\n+    return;\n+  }\n+\n+  const uint num_regions_per_stripe = 2;\n+  const size_t region_size = ParallelCompactData::RegionSize;\n+  const size_t stripe_size = num_regions_per_stripe * region_size;\n+\n+  while (true) {\n+    uint counter = Atomic::fetch_then_add(claim_counter, num_regions_per_stripe);\n+    HeapWord* cur_stripe = bottom + counter * region_size;\n+    if (cur_stripe >= top) {\n+      break;\n+    }\n+    HeapWord* stripe_end = MIN2(cur_stripe + stripe_size, top);\n+    on_stripe(cur_stripe, stripe_end);\n+  }\n+}\n+\n+void PSParallelCompact::adjust_in_old_space(volatile uint* claim_counter) {\n+  \/\/ Regions in old-space shouldn't be split.\n+  assert(!_space_info[old_space_id].split_info().is_valid(), \"inv\");\n+\n+  auto scan_obj_with_limit = [&] (HeapWord* obj_start, HeapWord* left, HeapWord* right) {\n+    assert(mark_bitmap()->is_marked(obj_start), \"inv\");\n+    oop obj = cast_to_oop(obj_start);\n+    return obj->oop_iterate_size(&pc_adjust_pointer_closure, MemRegion(left, right));\n+  };\n+\n+  adjust_in_space_helper(old_space_id, claim_counter, [&] (HeapWord* stripe_start, HeapWord* stripe_end) {\n+    assert(_summary_data.is_region_aligned(stripe_start), \"inv\");\n+    RegionData* cur_region = _summary_data.addr_to_region_ptr(stripe_start);\n+    HeapWord* obj_start;\n+    if (cur_region->partial_obj_size() != 0) {\n+      obj_start = cur_region->partial_obj_addr();\n+      obj_start += scan_obj_with_limit(obj_start, stripe_start, stripe_end);\n+    } else {\n+      obj_start = stripe_start;\n+    }\n+\n+    while (obj_start < stripe_end) {\n+      obj_start = mark_bitmap()->find_obj_beg(obj_start, stripe_end);\n+      if (obj_start >= stripe_end) {\n+        break;\n+      }\n+      obj_start += scan_obj_with_limit(obj_start, stripe_start, stripe_end);\n+    }\n+  });\n+}\n+\n+void PSParallelCompact::adjust_in_young_space(SpaceId id, volatile uint* claim_counter) {\n+  adjust_in_space_helper(id, claim_counter, [](HeapWord* stripe_start, HeapWord* stripe_end) {\n+    HeapWord* obj_start = stripe_start;\n+    while (obj_start < stripe_end) {\n+      obj_start = mark_bitmap()->find_obj_beg(obj_start, stripe_end);\n+      if (obj_start >= stripe_end) {\n+        break;\n+      }\n+      oop obj = cast_to_oop(obj_start);\n+      obj_start += obj->oop_iterate_size(&pc_adjust_pointer_closure);\n+    }\n+  });\n+}\n+\n+void PSParallelCompact::adjust_pointers_in_spaces(uint worker_id, volatile uint* claim_counters) {\n+  auto start_time = Ticks::now();\n+  adjust_in_old_space(&claim_counters[0]);\n+  for (uint id = eden_space_id; id < last_space_id; ++id) {\n+    adjust_in_young_space(SpaceId(id), &claim_counters[id]);\n+  }\n+  log_trace(gc, phases)(\"adjust_pointers_in_spaces worker %u: %.3f ms\", worker_id, (Ticks::now() - start_time).seconds() * 1000);\n+}\n+\n@@ -1694,0 +1695,1 @@\n+  volatile uint _claim_counters[PSParallelCompact::last_space_id] = {};\n@@ -1720,1 +1722,5 @@\n-    PCAdjustPointerClosure adjust(cm);\n+    cm->preserved_marks()->adjust_during_full_gc();\n+    {\n+      \/\/ adjust pointers in all spaces\n+      PSParallelCompact::adjust_pointers_in_spaces(worker_id, _claim_counters);\n+    }\n@@ -1723,1 +1729,1 @@\n-      Threads::possibly_parallel_oops_do(_nworkers > 1, &adjust, nullptr);\n+      Threads::possibly_parallel_oops_do(_nworkers > 1, &pc_adjust_pointer_closure, nullptr);\n@@ -1725,1 +1731,1 @@\n-    _oop_storage_iter.oops_do(&adjust);\n+    _oop_storage_iter.oops_do(&pc_adjust_pointer_closure);\n@@ -1727,1 +1733,1 @@\n-      CLDToOopClosure cld_closure(&adjust, ClassLoaderData::_claim_stw_fullgc_adjust);\n+      CLDToOopClosure cld_closure(&pc_adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n@@ -1732,1 +1738,1 @@\n-      _weak_proc_task.work(worker_id, &always_alive, &adjust);\n+      _weak_proc_task.work(worker_id, &always_alive, &pc_adjust_pointer_closure);\n@@ -1735,1 +1741,1 @@\n-      NMethodToOopClosure adjust_code(&adjust, NMethodToOopClosure::FixRelocations);\n+      NMethodToOopClosure adjust_code(&pc_adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n@@ -1742,1 +1748,1 @@\n-void PSParallelCompact::adjust_roots() {\n+void PSParallelCompact::adjust_pointers() {\n@@ -1744,1 +1750,1 @@\n-  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+  GCTraceTime(Info, gc, phases) tm(\"Adjust Pointers\", &_gc_timer);\n@@ -1750,0 +1756,125 @@\n+\/\/ Split [start, end) evenly for a number of workers and return the\n+\/\/ range for worker_id.\n+static void split_regions_for_worker(size_t start, size_t end,\n+                                     uint worker_id, uint num_workers,\n+                                     size_t* worker_start, size_t* worker_end) {\n+  assert(start < end, \"precondition\");\n+  assert(num_workers > 0, \"precondition\");\n+  assert(worker_id < num_workers, \"precondition\");\n+\n+  size_t num_regions = end - start;\n+  size_t num_regions_per_worker = num_regions \/ num_workers;\n+  size_t remainder = num_regions % num_workers;\n+  \/\/ The first few workers will get one extra.\n+  *worker_start = start + worker_id * num_regions_per_worker\n+                  + MIN2(checked_cast<size_t>(worker_id), remainder);\n+  *worker_end = *worker_start + num_regions_per_worker\n+                + (worker_id < remainder ? 1 : 0);\n+}\n+\n+void PSParallelCompact::forward_to_new_addr() {\n+  GCTraceTime(Info, gc, phases) tm(\"Forward\", &_gc_timer);\n+  uint nworkers = ParallelScavengeHeap::heap()->workers().active_workers();\n+\n+  struct ForwardTask final : public WorkerTask {\n+    uint _num_workers;\n+\n+    explicit ForwardTask(uint num_workers) :\n+      WorkerTask(\"PSForward task\"),\n+      _num_workers(num_workers) {}\n+\n+    void work(uint worker_id) override {\n+      ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+      for (uint id = old_space_id; id < last_space_id; ++id) {\n+        MutableSpace* sp = PSParallelCompact::space(SpaceId(id));\n+        HeapWord* dense_prefix_addr = dense_prefix(SpaceId(id));\n+        HeapWord* top = sp->top();\n+\n+        if (dense_prefix_addr == top) {\n+          continue;\n+        }\n+\n+        size_t dense_prefix_region = _summary_data.addr_to_region_idx(dense_prefix_addr);\n+        size_t top_region = _summary_data.addr_to_region_idx(_summary_data.region_align_up(top));\n+        size_t start_region;\n+        size_t end_region;\n+        split_regions_for_worker(dense_prefix_region, top_region,\n+                                 worker_id, _num_workers,\n+                                 &start_region, &end_region);\n+        for (size_t cur_region = start_region; cur_region < end_region; ++cur_region) {\n+          RegionData* region_ptr = _summary_data.region(cur_region);\n+          size_t live_words = region_ptr->partial_obj_size();\n+\n+          if (live_words == ParallelCompactData::RegionSize) {\n+            \/\/ No obj-start\n+            continue;\n+          }\n+\n+          HeapWord* region_start = _summary_data.region_to_addr(cur_region);\n+          HeapWord* region_end = region_start + ParallelCompactData::RegionSize;\n+\n+          HeapWord* cur_addr = region_start + live_words;\n+\n+          HeapWord* destination = region_ptr->destination();\n+          while (cur_addr < region_end) {\n+            cur_addr = mark_bitmap()->find_obj_beg(cur_addr, region_end);\n+            if (cur_addr >= region_end) {\n+              break;\n+            }\n+            assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+            HeapWord* new_addr = destination + live_words;\n+            oop obj = cast_to_oop(cur_addr);\n+            if (new_addr != cur_addr) {\n+              cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+              obj->forward_to(cast_to_oop(new_addr));\n+            }\n+            size_t obj_size = obj->size();\n+            live_words += obj_size;\n+            cur_addr += obj_size;\n+          }\n+        }\n+      }\n+    }\n+  } task(nworkers);\n+\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  debug_only(verify_forward();)\n+}\n+\n+#ifdef ASSERT\n+void PSParallelCompact::verify_forward() {\n+  HeapWord* old_dense_prefix_addr = dense_prefix(SpaceId(old_space_id));\n+  RegionData* old_region = _summary_data.region(_summary_data.addr_to_region_idx(old_dense_prefix_addr));\n+  HeapWord* bump_ptr = old_region->partial_obj_size() != 0\n+                       ? old_dense_prefix_addr + old_region->partial_obj_size()\n+                       : old_dense_prefix_addr;\n+  SpaceId bump_ptr_space = old_space_id;\n+\n+  for (uint id = old_space_id; id < last_space_id; ++id) {\n+    MutableSpace* sp = PSParallelCompact::space(SpaceId(id));\n+    HeapWord* dense_prefix_addr = dense_prefix(SpaceId(id));\n+    HeapWord* top = sp->top();\n+    HeapWord* cur_addr = dense_prefix_addr;\n+\n+    while (cur_addr < top) {\n+      cur_addr = mark_bitmap()->find_obj_beg(cur_addr, top);\n+      if (cur_addr >= top) {\n+        break;\n+      }\n+      assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+      \/\/ Move to the space containing cur_addr\n+      if (bump_ptr == _space_info[bump_ptr_space].new_top()) {\n+        bump_ptr = space(space_id(cur_addr))->bottom();\n+        bump_ptr_space = space_id(bump_ptr);\n+      }\n+      oop obj = cast_to_oop(cur_addr);\n+      if (cur_addr != bump_ptr) {\n+        assert(obj->forwardee() == cast_to_oop(bump_ptr), \"inv\");\n+      }\n+      bump_ptr += obj->size();\n+      cur_addr += obj->size();\n+    }\n+  }\n+}\n+#endif\n+\n@@ -1830,154 +1961,0 @@\n-class TaskQueue : StackObj {\n-  volatile uint _counter;\n-  uint _size;\n-  uint _insert_index;\n-  PSParallelCompact::UpdateDensePrefixTask* _backing_array;\n-public:\n-  explicit TaskQueue(uint size) : _counter(0), _size(size), _insert_index(0), _backing_array(nullptr) {\n-    _backing_array = NEW_C_HEAP_ARRAY(PSParallelCompact::UpdateDensePrefixTask, _size, mtGC);\n-  }\n-  ~TaskQueue() {\n-    assert(_counter >= _insert_index, \"not all queue elements were claimed\");\n-    FREE_C_HEAP_ARRAY(T, _backing_array);\n-  }\n-\n-  void push(const PSParallelCompact::UpdateDensePrefixTask& value) {\n-    assert(_insert_index < _size, \"too small backing array\");\n-    _backing_array[_insert_index++] = value;\n-  }\n-\n-  bool try_claim(PSParallelCompact::UpdateDensePrefixTask& reference) {\n-    uint claimed = Atomic::fetch_then_add(&_counter, 1u);\n-    if (claimed < _insert_index) {\n-      reference = _backing_array[claimed];\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-};\n-\n-#define PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING 4\n-\n-void PSParallelCompact::enqueue_dense_prefix_tasks(TaskQueue& task_queue,\n-                                                   uint parallel_gc_threads) {\n-  GCTraceTime(Trace, gc, phases) tm(\"Dense Prefix Task Setup\", &_gc_timer);\n-\n-  ParallelCompactData& sd = PSParallelCompact::summary_data();\n-\n-  \/\/ Iterate over all the spaces adding tasks for updating\n-  \/\/ regions in the dense prefix.  Assume that 1 gc thread\n-  \/\/ will work on opening the gaps and the remaining gc threads\n-  \/\/ will work on the dense prefix.\n-  unsigned int space_id;\n-  for (space_id = old_space_id; space_id < last_space_id; ++ space_id) {\n-    HeapWord* const dense_prefix_end = _space_info[space_id].dense_prefix();\n-    const MutableSpace* const space = _space_info[space_id].space();\n-\n-    if (dense_prefix_end == space->bottom()) {\n-      \/\/ There is no dense prefix for this space.\n-      continue;\n-    }\n-\n-    \/\/ The dense prefix is before this region.\n-    size_t region_index_end_dense_prefix =\n-        sd.addr_to_region_idx(dense_prefix_end);\n-    RegionData* const dense_prefix_cp =\n-      sd.region(region_index_end_dense_prefix);\n-    assert(dense_prefix_end == space->end() ||\n-           dense_prefix_cp->available() ||\n-           dense_prefix_cp->claimed(),\n-           \"The region after the dense prefix should always be ready to fill\");\n-\n-    size_t region_index_start = sd.addr_to_region_idx(space->bottom());\n-\n-    \/\/ Is there dense prefix work?\n-    size_t total_dense_prefix_regions =\n-      region_index_end_dense_prefix - region_index_start;\n-    \/\/ How many regions of the dense prefix should be given to\n-    \/\/ each thread?\n-    if (total_dense_prefix_regions > 0) {\n-      uint tasks_for_dense_prefix = 1;\n-      if (total_dense_prefix_regions <=\n-          (parallel_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)) {\n-        \/\/ Don't over partition.  This assumes that\n-        \/\/ PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING is a small integer value\n-        \/\/ so there are not many regions to process.\n-        tasks_for_dense_prefix = parallel_gc_threads;\n-      } else {\n-        \/\/ Over partition\n-        tasks_for_dense_prefix = parallel_gc_threads *\n-          PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING;\n-      }\n-      size_t regions_per_thread = total_dense_prefix_regions \/\n-        tasks_for_dense_prefix;\n-      \/\/ Give each thread at least 1 region.\n-      if (regions_per_thread == 0) {\n-        regions_per_thread = 1;\n-      }\n-\n-      for (uint k = 0; k < tasks_for_dense_prefix; k++) {\n-        if (region_index_start >= region_index_end_dense_prefix) {\n-          break;\n-        }\n-        \/\/ region_index_end is not processed\n-        size_t region_index_end = MIN2(region_index_start + regions_per_thread,\n-                                       region_index_end_dense_prefix);\n-        task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),\n-                                              region_index_start,\n-                                              region_index_end));\n-        region_index_start = region_index_end;\n-      }\n-    }\n-    \/\/ This gets any part of the dense prefix that did not\n-    \/\/ fit evenly.\n-    if (region_index_start < region_index_end_dense_prefix) {\n-      task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),\n-                                            region_index_start,\n-                                            region_index_end_dense_prefix));\n-    }\n-  }\n-}\n-\n-#ifdef ASSERT\n-\/\/ Write a histogram of the number of times the block table was filled for a\n-\/\/ region.\n-void PSParallelCompact::write_block_fill_histogram()\n-{\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n-    return;\n-  }\n-\n-  Log(gc, compaction) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n-  outputStream* out = &ls;\n-\n-  typedef ParallelCompactData::RegionData rd_t;\n-  ParallelCompactData& sd = summary_data();\n-\n-  for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-    MutableSpace* const spc = _space_info[id].space();\n-    if (spc->bottom() != spc->top()) {\n-      const rd_t* const beg = sd.addr_to_region_ptr(spc->bottom());\n-      HeapWord* const top_aligned_up = sd.region_align_up(spc->top());\n-      const rd_t* const end = sd.addr_to_region_ptr(top_aligned_up);\n-\n-      size_t histo[5] = { 0, 0, 0, 0, 0 };\n-      const size_t histo_len = sizeof(histo) \/ sizeof(size_t);\n-      const size_t region_cnt = pointer_delta(end, beg, sizeof(rd_t));\n-\n-      for (const rd_t* cur = beg; cur < end; ++cur) {\n-        ++histo[MIN2(cur->blocks_filled_count(), histo_len - 1)];\n-      }\n-      out->print(\"Block fill histogram: %u %-4s\" SIZE_FORMAT_W(5), id, space_names[id], region_cnt);\n-      for (size_t i = 0; i < histo_len; ++i) {\n-        out->print(\" \" SIZE_FORMAT_W(5) \" %5.1f%%\",\n-                   histo[i], 100.0 * histo[i] \/ region_cnt);\n-      }\n-      out->cr();\n-    }\n-  }\n-}\n-#endif \/\/ #ifdef ASSERT\n-\n@@ -2016,2 +1993,2 @@\n-class UpdateDensePrefixAndCompactionTask: public WorkerTask {\n-  TaskQueue& _tq;\n+class FillDensePrefixAndCompactionTask: public WorkerTask {\n+  uint _num_workers;\n@@ -2021,3 +1998,3 @@\n-  UpdateDensePrefixAndCompactionTask(TaskQueue& tq, uint active_workers) :\n-      WorkerTask(\"UpdateDensePrefixAndCompactionTask\"),\n-      _tq(tq),\n+  FillDensePrefixAndCompactionTask(uint active_workers) :\n+      WorkerTask(\"FillDensePrefixAndCompactionTask\"),\n+      _num_workers(active_workers),\n@@ -2026,0 +2003,1 @@\n+\n@@ -2027,1 +2005,8 @@\n-    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    {\n+      auto start = Ticks::now();\n+      PSParallelCompact::fill_dead_objs_in_dense_prefix(worker_id, _num_workers);\n+      log_trace(gc, phases)(\"Fill dense prefix by worker %u: %.3f ms\", worker_id, (Ticks::now() - start).seconds() * 1000);\n+    }\n+    compaction_with_stealing_work(&_terminator, worker_id);\n+  }\n+};\n@@ -2029,5 +2014,10 @@\n-    for (PSParallelCompact::UpdateDensePrefixTask task; _tq.try_claim(task); \/* empty *\/) {\n-      PSParallelCompact::update_and_deadwood_in_dense_prefix(cm,\n-                                                             task._space_id,\n-                                                             task._region_index_start,\n-                                                             task._region_index_end);\n+void PSParallelCompact::fill_range_in_dense_prefix(HeapWord* start, HeapWord* end) {\n+#ifdef ASSERT\n+  {\n+    assert(start < end, \"precondition\");\n+    assert(mark_bitmap()->find_obj_beg(start, end) == end, \"precondition\");\n+    HeapWord* bottom = _space_info[old_space_id].space()->bottom();\n+    if (start != bottom) {\n+      HeapWord* obj_start = mark_bitmap()->find_obj_beg_reverse(bottom, start);\n+      HeapWord* after_obj = obj_start + cast_to_oop(obj_start)->size();\n+      assert(after_obj == start, \"precondition\");\n@@ -2035,0 +2025,2 @@\n+  }\n+#endif\n@@ -2036,3 +2028,11 @@\n-    \/\/ Once a thread has drained it's stack, it should try to steal regions from\n-    \/\/ other threads.\n-    compaction_with_stealing_work(&_terminator, worker_id);\n+  CollectedHeap::fill_with_objects(start, pointer_delta(end, start));\n+  HeapWord* addr = start;\n+  do {\n+    size_t size = cast_to_oop(addr)->size();\n+    start_array(old_space_id)->update_for_block(addr, addr + size);\n+    addr += size;\n+  } while (addr < end);\n+}\n+\n+void PSParallelCompact::fill_dead_objs_in_dense_prefix(uint worker_id, uint num_workers) {\n+  ParMarkBitMap* bitmap = mark_bitmap();\n@@ -2040,3 +2040,5 @@\n-    \/\/ At this point all regions have been compacted, so it's now safe\n-    \/\/ to update the deferred objects that cross region boundaries.\n-    cm->drain_deferred_objects();\n+  HeapWord* const bottom = _space_info[old_space_id].space()->bottom();\n+  HeapWord* const prefix_end = dense_prefix(old_space_id);\n+\n+  if (bottom == prefix_end) {\n+    return;\n@@ -2044,1 +2046,45 @@\n-};\n+\n+  size_t bottom_region = _summary_data.addr_to_region_idx(bottom);\n+  size_t prefix_end_region = _summary_data.addr_to_region_idx(prefix_end);\n+\n+  size_t start_region;\n+  size_t end_region;\n+  split_regions_for_worker(bottom_region, prefix_end_region,\n+                           worker_id, num_workers,\n+                           &start_region, &end_region);\n+\n+  if (start_region == end_region) {\n+    return;\n+  }\n+\n+  HeapWord* const start_addr = _summary_data.region_to_addr(start_region);\n+  HeapWord* const end_addr = _summary_data.region_to_addr(end_region);\n+\n+  \/\/ Skip live partial obj (if any) from previous region.\n+  HeapWord* cur_addr;\n+  RegionData* start_region_ptr = _summary_data.region(start_region);\n+  if (start_region_ptr->partial_obj_size() != 0) {\n+    HeapWord* partial_obj_start = start_region_ptr->partial_obj_addr();\n+    assert(bitmap->is_marked(partial_obj_start), \"inv\");\n+    cur_addr = partial_obj_start + cast_to_oop(partial_obj_start)->size();\n+  } else {\n+    cur_addr = start_addr;\n+  }\n+\n+  \/\/ end_addr is inclusive to handle regions starting with dead space.\n+  while (cur_addr <= end_addr) {\n+    \/\/ Use prefix_end to handle trailing obj in each worker region-chunk.\n+    HeapWord* live_start = bitmap->find_obj_beg(cur_addr, prefix_end);\n+    if (cur_addr != live_start) {\n+      \/\/ Only worker 0 handles proceeding dead space.\n+      if (cur_addr != start_addr || worker_id == 0) {\n+        fill_range_in_dense_prefix(cur_addr, live_start);\n+      }\n+    }\n+    if (live_start >= end_addr) {\n+      break;\n+    }\n+    assert(bitmap->is_marked(live_start), \"inv\");\n+    cur_addr = live_start + cast_to_oop(live_start)->size();\n+  }\n+}\n@@ -2049,2 +2095,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  PSOldGen* old_gen = heap->old_gen();\n@@ -2053,7 +2097,0 @@\n-  \/\/ for [0..last_space_id)\n-  \/\/     for [0..active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)\n-  \/\/         push\n-  \/\/     push\n-  \/\/\n-  \/\/ max push count is thus: last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1)\n-  TaskQueue task_queue(last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1));\n@@ -2062,1 +2099,0 @@\n-  enqueue_dense_prefix_tasks(task_queue, active_gc_threads);\n@@ -2067,1 +2103,1 @@\n-    UpdateDensePrefixAndCompactionTask task(task_queue, active_gc_threads);\n+    FillDensePrefixAndCompactionTask task(active_gc_threads);\n@@ -2071,0 +2107,2 @@\n+    verify_filler_in_dense_prefix();\n+\n@@ -2077,2 +2115,0 @@\n-\n-  DEBUG_ONLY(write_block_fill_histogram());\n@@ -2082,0 +2118,15 @@\n+void PSParallelCompact::verify_filler_in_dense_prefix() {\n+  HeapWord* bottom = _space_info[old_space_id].space()->bottom();\n+  HeapWord* dense_prefix_end = dense_prefix(old_space_id);\n+  HeapWord* cur_addr = bottom;\n+  while (cur_addr < dense_prefix_end) {\n+    oop obj = cast_to_oop(cur_addr);\n+    oopDesc::verify(obj);\n+    if (!mark_bitmap()->is_marked(cur_addr)) {\n+      Klass* k = cast_to_oop(cur_addr)->klass_without_asserts();\n+      assert(k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass(), \"inv\");\n+    }\n+    cur_addr += obj->size();\n+  }\n+}\n+\n@@ -2121,66 +2172,0 @@\n-inline void UpdateOnlyClosure::do_addr(HeapWord* addr) {\n-  compaction_manager()->update_contents(cast_to_oop(addr));\n-}\n-\n-\/\/ Update interior oops in the ranges of regions [beg_region, end_region).\n-void\n-PSParallelCompact::update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,\n-                                                       SpaceId space_id,\n-                                                       size_t beg_region,\n-                                                       size_t end_region) {\n-  ParallelCompactData& sd = summary_data();\n-  ParMarkBitMap* const mbm = mark_bitmap();\n-\n-  HeapWord* beg_addr = sd.region_to_addr(beg_region);\n-  HeapWord* const end_addr = sd.region_to_addr(end_region);\n-  assert(beg_region <= end_region, \"bad region range\");\n-  assert(end_addr <= dense_prefix(space_id), \"not in the dense prefix\");\n-\n-#ifdef  ASSERT\n-  \/\/ Claim the regions to avoid triggering an assert when they are marked as\n-  \/\/ filled.\n-  for (size_t claim_region = beg_region; claim_region < end_region; ++claim_region) {\n-    assert(sd.region(claim_region)->claim_unsafe(), \"claim() failed\");\n-  }\n-#endif  \/\/ #ifdef ASSERT\n-  HeapWord* const space_bottom = space(space_id)->bottom();\n-\n-  \/\/ Check if it's the first region in this space.\n-  if (beg_addr != space_bottom) {\n-    \/\/ Find the first live object or block of dead space that *starts* in this\n-    \/\/ range of regions.  If a partial object crosses onto the region, skip it;\n-    \/\/ it will be marked for 'deferred update' when the object head is\n-    \/\/ processed.  If dead space crosses onto the region, it is also skipped; it\n-    \/\/ will be filled when the prior region is processed.  If neither of those\n-    \/\/ apply, the first word in the region is the start of a live object or dead\n-    \/\/ space.\n-    assert(beg_addr > space(space_id)->bottom(), \"sanity\");\n-    const RegionData* const cp = sd.region(beg_region);\n-    if (cp->partial_obj_size() != 0) {\n-      beg_addr = sd.partial_obj_end(beg_region);\n-    } else {\n-      idx_t beg_bit = mbm->addr_to_bit(beg_addr);\n-      if (!mbm->is_obj_beg(beg_bit) && !mbm->is_obj_end(beg_bit - 1)) {\n-        beg_addr = mbm->find_obj_beg(beg_addr, end_addr);\n-      }\n-    }\n-  }\n-\n-  if (beg_addr < end_addr) {\n-    \/\/ A live object or block of dead space starts in this range of Regions.\n-     HeapWord* const dense_prefix_end = dense_prefix(space_id);\n-\n-    \/\/ Create closures and iterate.\n-    UpdateOnlyClosure update_closure(mbm, cm, space_id);\n-    FillClosure fill_closure(cm, space_id);\n-    mbm->iterate(&update_closure, &fill_closure, beg_addr, end_addr, dense_prefix_end);\n-  }\n-\n-  \/\/ Mark the regions as filled.\n-  RegionData* const beg_cp = sd.region(beg_region);\n-  RegionData* const end_cp = sd.region(end_region);\n-  for (RegionData* cp = beg_cp; cp < end_cp; ++cp) {\n-    cp->set_completed();\n-  }\n-}\n-\n@@ -2203,18 +2188,0 @@\n-void PSParallelCompact::update_deferred_object(ParCompactionManager* cm, HeapWord *addr) {\n-#ifdef ASSERT\n-  ParallelCompactData& sd = summary_data();\n-  size_t region_idx = sd.addr_to_region_idx(addr);\n-  assert(sd.region(region_idx)->completed(), \"first region must be completed before deferred updates\");\n-  assert(sd.region(region_idx + 1)->completed(), \"second region must be completed before deferred updates\");\n-#endif\n-\n-  const SpaceInfo* const space_info = _space_info + space_id(addr);\n-  ObjectStartArray* const start_array = space_info->start_array();\n-  if (start_array != nullptr) {\n-    start_array->update_for_block(addr, addr + cast_to_oop(addr)->size());\n-  }\n-\n-  cm->update_contents(cast_to_oop(addr));\n-  assert(oopDesc::is_oop(cast_to_oop(addr)), \"Expected an oop at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n-}\n-\n@@ -2232,10 +2199,8 @@\n-  idx_t bits_to_skip = m->words_to_bits(count);\n-  idx_t cur_beg = m->addr_to_bit(beg);\n-  const idx_t search_end = m->align_range_end(m->addr_to_bit(end));\n-\n-  do {\n-    cur_beg = m->find_obj_beg(cur_beg, search_end);\n-    idx_t cur_end = m->find_obj_end(cur_beg, search_end);\n-    const size_t obj_bits = cur_end - cur_beg + 1;\n-    if (obj_bits > bits_to_skip) {\n-      return m->bit_to_addr(cur_beg + bits_to_skip);\n+  HeapWord* cur_addr = beg;\n+  while (true) {\n+    cur_addr = m->find_obj_beg(cur_addr, end);\n+    assert(cur_addr < end, \"inv\");\n+    size_t obj_size = cast_to_oop(cur_addr)->size();\n+    \/\/ Strictly greater-than\n+    if (obj_size > count) {\n+      return cur_addr + count;\n@@ -2243,9 +2208,3 @@\n-    bits_to_skip -= obj_bits;\n-    cur_beg = cur_end + 1;\n-  } while (bits_to_skip > 0);\n-\n-  \/\/ Skipping the desired number of words landed just past the end of an object.\n-  \/\/ Find the start of the next object.\n-  cur_beg = m->find_obj_beg(cur_beg, search_end);\n-  assert(cur_beg < m->addr_to_bit(end), \"not enough live words to skip\");\n-  return m->bit_to_addr(cur_beg);\n+    count -= obj_size;\n+    cur_addr += obj_size;\n+  }\n@@ -2435,0 +2394,23 @@\n+HeapWord* PSParallelCompact::partial_obj_end(HeapWord* region_start_addr) {\n+  ParallelCompactData& sd = summary_data();\n+  assert(sd.is_region_aligned(region_start_addr), \"precondition\");\n+\n+  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends to region_start_addr.\n+  SplitInfo& split_info = _space_info[space_id(region_start_addr)].split_info();\n+  size_t start_region_idx = sd.addr_to_region_idx(region_start_addr);\n+  size_t end_region_idx = sd.region_count();\n+  size_t accumulated_size = 0;\n+  for (size_t region_idx = start_region_idx; region_idx < end_region_idx; ++region_idx) {\n+    if (split_info.is_split(region_idx)) {\n+      accumulated_size += split_info.partial_obj_size();\n+      break;\n+    }\n+    size_t cur_partial_obj_size = sd.region(region_idx)->partial_obj_size();\n+    accumulated_size += cur_partial_obj_size;\n+    if (cur_partial_obj_size != ParallelCompactData::RegionSize) {\n+      break;\n+    }\n+  }\n+  return region_start_addr + accumulated_size;\n+}\n+\n@@ -2437,1 +2419,0 @@\n-  typedef ParMarkBitMap::IterationStatus IterationStatus;\n@@ -2461,1 +2442,24 @@\n-    closure.copy_partial_obj();\n+    {\n+      HeapWord* region_start = sd.region_align_down(closure.source());\n+      HeapWord* obj_start = bitmap->find_obj_beg_reverse(region_start, closure.source());\n+      HeapWord* obj_end;\n+      if (bitmap->is_marked(obj_start)) {\n+        HeapWord* next_region_start = region_start + ParallelCompactData::RegionSize;\n+        HeapWord* partial_obj_start = (next_region_start >= src_space_top)\n+                                      ? nullptr\n+                                      : sd.addr_to_region_ptr(next_region_start)->partial_obj_addr();\n+        if (partial_obj_start == obj_start) {\n+          \/\/ This obj extends to next region.\n+          obj_end = partial_obj_end(next_region_start);\n+        } else {\n+          \/\/ Completely contained in this region; safe to use size().\n+          obj_end = obj_start + cast_to_oop(obj_start)->size();\n+        }\n+      } else {\n+        \/\/ This obj extends to current region.\n+        obj_end = partial_obj_end(region_start);\n+      }\n+      size_t partial_obj_size = pointer_delta(obj_end, closure.source());\n+      closure.copy_partial_obj(partial_obj_size);\n+    }\n+\n@@ -2482,1 +2486,1 @@\n-    HeapWord* const cur_addr = closure.source();\n+    HeapWord* cur_addr = closure.source();\n@@ -2485,13 +2489,19 @@\n-    IterationStatus status = bitmap->iterate(&closure, cur_addr, end_addr);\n-\n-    if (status == ParMarkBitMap::would_overflow) {\n-      \/\/ The last object did not fit.  Note that interior oop updates were\n-      \/\/ deferred, then copy enough of the object to fill the region.\n-      cm->push_deferred_object(closure.destination());\n-      status = closure.copy_until_full(); \/\/ copies from closure.source()\n-\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n-      closure.complete_region(cm, dest_addr, region_ptr);\n-      return;\n-    }\n+    HeapWord* partial_obj_start = (end_addr == src_space_top)\n+                                ? nullptr\n+                                : sd.addr_to_region_ptr(end_addr)->partial_obj_addr();\n+    \/\/ apply closure on objs inside [cur_addr, end_addr)\n+    do {\n+      cur_addr = bitmap->find_obj_beg(cur_addr, end_addr);\n+      if (cur_addr == end_addr) {\n+        break;\n+      }\n+      size_t obj_size;\n+      if (partial_obj_start == cur_addr) {\n+        obj_size = pointer_delta(partial_obj_end(end_addr), cur_addr);\n+      } else {\n+        \/\/ This obj doesn't extend into next region; size() is safe to use.\n+        obj_size = cast_to_oop(cur_addr)->size();\n+      }\n+      closure.do_addr(cur_addr, obj_size);\n+      cur_addr += obj_size;\n+    } while (cur_addr < end_addr && !closure.is_full());\n@@ -2499,1 +2509,1 @@\n-    if (status == ParMarkBitMap::full) {\n+    if (closure.is_full()) {\n@@ -2517,1 +2527,1 @@\n-  MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);\n+  MoveAndUpdateClosure cl(mark_bitmap(), region_idx);\n@@ -2531,1 +2541,1 @@\n-    MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);\n+    MoveAndUpdateClosure cl(mark_bitmap(), region_idx);\n@@ -2599,1 +2609,1 @@\n-void PSParallelCompact::fill_blocks(size_t region_idx)\n+void MoveAndUpdateClosure::copy_partial_obj(size_t partial_obj_size)\n@@ -2601,69 +2611,1 @@\n-  \/\/ Fill in the block table elements for the specified region.  Each block\n-  \/\/ table element holds the number of live words in the region that are to the\n-  \/\/ left of the first object that starts in the block.  Thus only blocks in\n-  \/\/ which an object starts need to be filled.\n-  \/\/\n-  \/\/ The algorithm scans the section of the bitmap that corresponds to the\n-  \/\/ region, keeping a running total of the live words.  When an object start is\n-  \/\/ found, if it's the first to start in the block that contains it, the\n-  \/\/ current total is written to the block table element.\n-  const size_t Log2BlockSize = ParallelCompactData::Log2BlockSize;\n-  const size_t Log2RegionSize = ParallelCompactData::Log2RegionSize;\n-  const size_t RegionSize = ParallelCompactData::RegionSize;\n-\n-  ParallelCompactData& sd = summary_data();\n-  const size_t partial_obj_size = sd.region(region_idx)->partial_obj_size();\n-  if (partial_obj_size >= RegionSize) {\n-    return; \/\/ No objects start in this region.\n-  }\n-\n-  \/\/ Ensure the first loop iteration decides that the block has changed.\n-  size_t cur_block = sd.block_count();\n-\n-  const ParMarkBitMap* const bitmap = mark_bitmap();\n-\n-  const size_t Log2BitsPerBlock = Log2BlockSize - LogMinObjAlignment;\n-  assert((size_t)1 << Log2BitsPerBlock ==\n-         bitmap->words_to_bits(ParallelCompactData::BlockSize), \"sanity\");\n-\n-  size_t beg_bit = bitmap->words_to_bits(region_idx << Log2RegionSize);\n-  const size_t range_end = beg_bit + bitmap->words_to_bits(RegionSize);\n-  size_t live_bits = bitmap->words_to_bits(partial_obj_size);\n-  beg_bit = bitmap->find_obj_beg(beg_bit + live_bits, range_end);\n-  while (beg_bit < range_end) {\n-    const size_t new_block = beg_bit >> Log2BitsPerBlock;\n-    if (new_block != cur_block) {\n-      cur_block = new_block;\n-      sd.block(cur_block)->set_offset(bitmap->bits_to_words(live_bits));\n-    }\n-\n-    const size_t end_bit = bitmap->find_obj_end(beg_bit, range_end);\n-    if (end_bit < range_end - 1) {\n-      live_bits += end_bit - beg_bit + 1;\n-      beg_bit = bitmap->find_obj_beg(end_bit + 1, range_end);\n-    } else {\n-      return;\n-    }\n-  }\n-}\n-\n-ParMarkBitMap::IterationStatus MoveAndUpdateClosure::copy_until_full()\n-{\n-  if (source() != copy_destination()) {\n-    DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)\n-    Copy::aligned_conjoint_words(source(), copy_destination(), words_remaining());\n-  }\n-  update_state(words_remaining());\n-  assert(is_full(), \"sanity\");\n-  return ParMarkBitMap::full;\n-}\n-\n-void MoveAndUpdateClosure::copy_partial_obj()\n-{\n-  size_t words = words_remaining();\n-\n-  HeapWord* const range_end = MIN2(source() + words, bitmap()->region_end());\n-  HeapWord* const end_addr = bitmap()->find_obj_end(source(), range_end);\n-  if (end_addr < range_end) {\n-    words = bitmap()->obj_size(source(), end_addr);\n-  }\n+  size_t words = MIN2(partial_obj_size, words_remaining());\n@@ -2686,2 +2628,1 @@\n-ParMarkBitMapClosure::IterationStatus\n-MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n+void MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {\n@@ -2689,8 +2630,0 @@\n-  assert(bitmap()->obj_size(addr) == words, \"bad size\");\n-\n-  assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==\n-         destination(), \"wrong destination\");\n-\n-  if (words > words_remaining()) {\n-    return ParMarkBitMap::would_overflow;\n-  }\n@@ -2704,0 +2637,4 @@\n+  \/\/ Avoid overflow\n+  words = MIN2(words, words_remaining());\n+  assert(words > 0, \"inv\");\n+\n@@ -2706,0 +2643,6 @@\n+    assert(source() != destination(), \"inv\");\n+    assert(cast_to_oop(source())->is_forwarded(), \"inv\");\n+    assert(cast_to_oop(source())->forwardee() == cast_to_oop(destination()), \"inv\");\n+    \/\/ Read the klass before the copying, since it might destroy the klass (i.e. overlapping copy)\n+    \/\/ and if partial copy, the destination klass may not be copied yet\n+    Klass* klass = cast_to_oop(source())->klass();\n@@ -2707,0 +2650,1 @@\n+    cast_to_oop(copy_destination())->set_mark(Klass::default_prototype_header(klass));\n@@ -2709,6 +2653,0 @@\n-  oop moved_oop = cast_to_oop(copy_destination());\n-  compaction_manager()->update_contents(moved_oop);\n-  assert(oopDesc::is_oop_or_null(moved_oop), \"Expected an oop or null at \" PTR_FORMAT, p2i(moved_oop));\n-\n-  assert(copy_destination() == cast_from_oop<HeapWord*>(moved_oop) + moved_oop->size(), \"sanity\");\n-  return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;\n@@ -2737,34 +2675,0 @@\n-UpdateOnlyClosure::UpdateOnlyClosure(ParMarkBitMap* mbm,\n-                                     ParCompactionManager* cm,\n-                                     PSParallelCompact::SpaceId space_id) :\n-  ParMarkBitMapClosure(mbm, cm),\n-  _start_array(PSParallelCompact::start_array(space_id))\n-{\n-}\n-\n-\/\/ Updates the references in the object to their new values.\n-ParMarkBitMapClosure::IterationStatus\n-UpdateOnlyClosure::do_addr(HeapWord* addr, size_t words) {\n-  do_addr(addr);\n-  return ParMarkBitMap::incomplete;\n-}\n-\n-FillClosure::FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id) :\n-  ParMarkBitMapClosure(PSParallelCompact::mark_bitmap(), cm),\n-  _start_array(PSParallelCompact::start_array(space_id))\n-{\n-  assert(space_id == PSParallelCompact::old_space_id,\n-         \"cannot use FillClosure in the young gen\");\n-}\n-\n-ParMarkBitMapClosure::IterationStatus\n-FillClosure::do_addr(HeapWord* addr, size_t size) {\n-  CollectedHeap::fill_with_objects(addr, size);\n-  HeapWord* const end = addr + size;\n-  do {\n-    size_t size = cast_to_oop(addr)->size();\n-    _start_array->update_for_block(addr, addr + size);\n-    addr += size;\n-  } while (addr < end);\n-  return ParMarkBitMap::incomplete;\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":446,"deletions":542,"binary":false,"changes":988,"status":"modified"},{"patch":"@@ -821,0 +821,19 @@\n+static const TypeFunc* clone_type() {\n+  \/\/ Create input type (domain)\n+  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n+  const Type** const domain_fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ src\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ dst\n+  domain_fields[argp++] = TypeX_X;               \/\/ size lower\n+  LP64_ONLY(domain_fields[argp++] = Type::HALF); \/\/ size upper\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + argcnt, domain_fields);\n+\n+  \/\/ Create result type (range)\n+  const Type** const range_fields = TypeTuple::fields(0);\n+  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n@@ -823,0 +842,31 @@\n+void BarrierSetC2::clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                                    address clone_addr, const char* clone_name) const {\n+  Node* const ctrl = ac->in(TypeFunc::Control);\n+  Node* const mem  = ac->in(TypeFunc::Memory);\n+  Node* const src  = ac->in(ArrayCopyNode::Src);\n+  Node* const dst  = ac->in(ArrayCopyNode::Dest);\n+  Node* const size = ac->in(ArrayCopyNode::Length);\n+\n+  assert(size->bottom_type()->base() == Type_X,\n+         \"Should be of object size type (int for 32 bits, long for 64 bits)\");\n+\n+  \/\/ The native clone we are calling here expects the object size in words.\n+  \/\/ Add header\/offset size to payload size to get object size.\n+  Node* const base_offset = phase->MakeConX(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n+  Node* const full_size = phase->transform_later(new AddXNode(size, base_offset));\n+  \/\/ HeapAccess<>::clone expects size in heap words.\n+  \/\/ For 64-bits platforms, this is a no-operation.\n+  \/\/ For 32-bits platforms, we need to multiply full_size by HeapWordsPerLong (2).\n+  Node* const full_size_in_heap_words = phase->transform_later(new LShiftXNode(full_size, phase->intcon(LogHeapWordsPerLong)));\n+\n+  Node* const call = phase->make_leaf_call(ctrl,\n+                                           mem,\n+                                           clone_type(),\n+                                           clone_addr,\n+                                           clone_name,\n+                                           TypeRawPtr::BOTTOM,\n+                                           src, dst, full_size_in_heap_words XTOP);\n+  phase->transform_later(call);\n+  phase->replace_node(ac, call);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -287,0 +287,2 @@\n+  void clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                        address call_addr, const char* call_name) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,1 +983,1 @@\n-    const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());\n+    const int gc_state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());\n@@ -991,1 +991,4 @@\n-      if (x == nullptr || x == compile->top()) continue;\n+      if (x == nullptr || x == compile->top()) {\n+        continue;\n+      }\n+\n@@ -1019,1 +1022,1 @@\n-                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == marking_offset) {\n+                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == gc_state_offset) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -410,17 +410,0 @@\n-\/\/ This TypeFunc assumes a 64bit system\n-static const TypeFunc* clone_type() {\n-  \/\/ Create input type (domain)\n-  const Type** const domain_fields = TypeTuple::fields(4);\n-  domain_fields[TypeFunc::Parms + 0] = TypeInstPtr::NOTNULL;  \/\/ src\n-  domain_fields[TypeFunc::Parms + 1] = TypeInstPtr::NOTNULL;  \/\/ dst\n-  domain_fields[TypeFunc::Parms + 2] = TypeLong::LONG;        \/\/ size lower\n-  domain_fields[TypeFunc::Parms + 3] = Type::HALF;            \/\/ size upper\n-  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + 4, domain_fields);\n-\n-  \/\/ Create result type (range)\n-  const Type** const range_fields = TypeTuple::fields(0);\n-  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n-\n-  return TypeFunc::make(domain, range);\n-}\n-\n@@ -482,25 +465,4 @@\n-  \/\/ Clone instance\n-  Node* const ctrl       = ac->in(TypeFunc::Control);\n-  Node* const mem        = ac->in(TypeFunc::Memory);\n-  Node* const dst        = ac->in(ArrayCopyNode::Dest);\n-  Node* const size       = ac->in(ArrayCopyNode::Length);\n-\n-  assert(size->bottom_type()->is_long(), \"Should be long\");\n-\n-  \/\/ The native clone we are calling here expects the instance size in words\n-  \/\/ Add header\/offset size to payload size to get instance size.\n-  Node* const base_offset = phase->longcon(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n-  Node* const full_size = phase->transform_later(new AddLNode(size, base_offset));\n-\n-  Node* const call = phase->make_leaf_call(ctrl,\n-                                           mem,\n-                                           clone_type(),\n-                                           ZBarrierSetRuntime::clone_addr(),\n-                                           \"ZBarrierSetRuntime::clone\",\n-                                           TypeRawPtr::BOTTOM,\n-                                           src,\n-                                           dst,\n-                                           full_size,\n-                                           phase->top());\n-  phase->transform_later(call);\n-  phase->replace_node(ac, call);\n+  \/\/ Clone instance or array where 'src' is only known to be an object (ary_ptr\n+  \/\/ is null). This can happen in bytecode generated dynamically to implement\n+  \/\/ reflective array clones.\n+  clone_in_runtime(phase, ac, ZBarrierSetRuntime::clone_addr(), \"ZBarrierSetRuntime::clone\");\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":4,"deletions":42,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -231,14 +231,0 @@\n-  \/\/ At this point the class may not be fully initialized\n-  \/\/ because of recursive initialization. If it is fully\n-  \/\/ initialized & has_finalized is not set, we rewrite\n-  \/\/ it into its fast version (Note: no locking is needed\n-  \/\/ here since this is an atomic byte write and can be\n-  \/\/ done more than once).\n-  \/\/\n-  \/\/ Note: In case of classes with has_finalized we don't\n-  \/\/       rewrite since that saves us an extra check in\n-  \/\/       the fast version which then would call the\n-  \/\/       slow version anyway (and do a call back into\n-  \/\/       Java).\n-  \/\/       If we have a breakpoint, then we don't rewrite\n-  \/\/       because the _breakpoint bytecode would be lost.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -844,1 +844,1 @@\n-  static_field(HeapRegion, LogOfHRGrainBytes, uint)\n+  static_field(G1HeapRegion, LogOfHRGrainBytes, uint)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3821,1 +3821,3 @@\n-  st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n+  if (default_methods() != nullptr) {\n+    st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -830,2 +830,0 @@\n-  bool has_vanilla_constructor() const  { return _misc_flags.has_vanilla_constructor(); }\n-  void set_has_vanilla_constructor()    { _misc_flags.set_has_vanilla_constructor(true); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,8 +56,7 @@\n-    flag(has_vanilla_constructor            , 1 << 13) \/* True if klass has a vanilla default constructor *\/ \\\n-    flag(has_final_method                   , 1 << 14) \/* True if klass has final method *\/ \\\n-    flag(has_inline_type_fields             , 1 << 15) \/* has inline fields and related embedded section is not empty *\/ \\\n-    flag(is_empty_inline_type               , 1 << 16) \/* empty inline type (*) *\/ \\\n-    flag(is_naturally_atomic                , 1 << 17) \/* loaded\/stored in one instruction *\/ \\\n-    flag(must_be_atomic                     , 1 << 18) \/* doesn't allow tearing *\/ \\\n-    flag(has_loosely_consistent_annotation  , 1 << 19) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n-    flag(is_implicitly_constructible        , 1 << 20) \/* the class has the ImplicitlyConstrutible annotation *\/\n+    flag(has_final_method                   , 1 << 13) \/* True if klass has final method *\/ \\\n+    flag(has_inline_type_fields             , 1 << 14) \/* has inline fields and related embedded section is not empty *\/ \\\n+    flag(is_empty_inline_type               , 1 << 15) \/* empty inline type (*) *\/ \\\n+    flag(is_naturally_atomic                , 1 << 16) \/* loaded\/stored in one instruction *\/ \\\n+    flag(must_be_atomic                     , 1 << 17) \/* doesn't allow tearing *\/ \\\n+    flag(has_loosely_consistent_annotation  , 1 << 18) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n+    flag(is_implicitly_constructible        , 1 << 19) \/* the class has the ImplicitlyConstrutible annotation *\/\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -690,44 +690,0 @@\n-bool Method::is_vanilla_constructor() const {\n-  \/\/ Returns true if this method is a vanilla constructor, i.e. an \"<init>\" \"()V\" method\n-  \/\/ which only calls the superclass vanilla constructor and possibly does stores of\n-  \/\/ zero constants to local fields:\n-  \/\/\n-  \/\/   aload_0, _fast_aload_0, or _nofast_aload_0\n-  \/\/   invokespecial\n-  \/\/   indexbyte1\n-  \/\/   indexbyte2\n-  \/\/\n-  \/\/ followed by an (optional) sequence of:\n-  \/\/\n-  \/\/   aload_0\n-  \/\/   aconst_null \/ iconst_0 \/ fconst_0 \/ dconst_0\n-  \/\/   putfield\n-  \/\/   indexbyte1\n-  \/\/   indexbyte2\n-  \/\/\n-  \/\/ followed by:\n-  \/\/\n-  \/\/   return\n-\n-  assert(name() == vmSymbols::object_initializer_name(),    \"Should only be called for default constructors\");\n-  assert(signature() == vmSymbols::void_method_signature(), \"Should only be called for default constructors\");\n-  int size = code_size();\n-  \/\/ Check if size match\n-  if (size == 0 || size % 5 != 0) return false;\n-  address cb = code_base();\n-  int last = size - 1;\n-  if ((cb[0] != Bytecodes::_aload_0 && cb[0] != Bytecodes::_fast_aload_0 && cb[0] != Bytecodes::_nofast_aload_0) ||\n-       cb[1] != Bytecodes::_invokespecial || cb[last] != Bytecodes::_return) {\n-    \/\/ Does not call superclass default constructor\n-    return false;\n-  }\n-  \/\/ Check optional sequence\n-  for (int i = 4; i < last; i += 5) {\n-    if (cb[i] != Bytecodes::_aload_0) return false;\n-    if (!Bytecodes::is_zero_const(Bytecodes::cast(cb[i+1]))) return false;\n-    if (cb[i+2] != Bytecodes::_putfield) return false;\n-  }\n-  return true;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -236,1 +236,7 @@\n-  res = widen_type(phase, res, T_INT);\n+  \/\/ But here we have to pay extra attention:\n+  \/\/ Do not narrow the type of range check dependent CastIINodes to\n+  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n+  \/\/ the corresponding range check is not removed.\n+  if (!_range_check_dependency) {\n+    res = widen_type(phase, res, T_INT);\n+  }\n@@ -256,1 +262,1 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n@@ -260,1 +266,1 @@\n-  if (!_type->is_int()->empty()) {\n+  if (!_range_check_dependency) {\n@@ -271,0 +277,7 @@\n+  if (_range_check_dependency) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      return this->in(1);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+macro(OpaqueInitializedAssertionPredicate)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3980,4 +3980,0 @@\n-  case Op_CastII: {\n-    remove_range_check_cast(n->as_CastII());\n-  }\n-  break;\n@@ -4135,0 +4131,10 @@\n+#ifdef ASSERT\n+  case Op_CastII:\n+    \/\/ Verify that all range check dependent CastII nodes were removed.\n+    if (n->isa_CastII()->has_range_check()) {\n+      n->dump(3);\n+      assert(false, \"Range check dependent CastII node was not removed\");\n+    }\n+    break;\n+#endif\n+\n@@ -4143,2 +4149,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4165,2 +4169,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4187,2 +4189,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4209,2 +4209,0 @@\n-          divmod->add_prec_from(n);\n-          divmod->add_prec_from(d);\n@@ -4419,28 +4417,0 @@\n-void Compile::remove_range_check_cast(CastIINode* cast) {\n-  if (cast->has_range_check()) {\n-    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n-    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n-    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n-    \/\/ range check or a null divisor check.\n-    assert(cast->in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n-    ResourceMark rm;\n-    Unique_Node_List wq;\n-    wq.push(cast);\n-    for (uint next = 0; next < wq.size(); ++next) {\n-      Node* m = wq.at(next);\n-      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n-        Node* use = m->fast_out(i);\n-        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n-          use->ensure_control_or_add_prec(cast->in(0));\n-        } else if (!use->is_CFG() && !use->is_Phi()) {\n-          wq.push(use);\n-        }\n-      }\n-    }\n-    cast->subsume_by(cast->in(1), this);\n-    if (cast->outcnt() == 0) {\n-      cast->disconnect_inputs(this);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":10,"deletions":40,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-class CastIINode;\n@@ -1346,2 +1345,0 @@\n-\n-  void remove_range_check_cast(CastIINode* cast);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6369,5 +6369,4 @@\n-  \/\/ Set the original stack and the reexecute bit for the interpreter to reexecute\n-  \/\/ the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens\n-  \/\/ on the return from z array allocation in runtime.\n-  { PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n+  Node* x_start = array_element_address(x, intcon(0), x_elem);\n+  Node* y_start = array_element_address(y, intcon(0), y_elem);\n+  \/\/ 'x_start' points to x array + scaled xlen\n+  \/\/ 'y_start' points to y array + scaled ylen\n@@ -6375,4 +6374,1 @@\n-    Node* x_start = array_element_address(x, intcon(0), x_elem);\n-    Node* y_start = array_element_address(y, intcon(0), y_elem);\n-    \/\/ 'x_start' points to x array + scaled xlen\n-    \/\/ 'y_start' points to y array + scaled ylen\n+  Node* z_start = array_element_address(z, intcon(0), T_INT);\n@@ -6380,54 +6376,4 @@\n-    \/\/ Allocate the result array\n-    Node* zlen = _gvn.transform(new AddINode(xlen, ylen));\n-    ciKlass* klass = ciTypeArrayKlass::make(T_INT);\n-    Node* klass_node = makecon(TypeKlassPtr::make(klass));\n-\n-    IdealKit ideal(this);\n-\n-#define __ ideal.\n-     Node* one = __ ConI(1);\n-     Node* zero = __ ConI(0);\n-     IdealVariable need_alloc(ideal), z_alloc(ideal);  __ declarations_done();\n-     __ set(need_alloc, zero);\n-     __ set(z_alloc, z);\n-     __ if_then(z, BoolTest::eq, null()); {\n-       __ increment (need_alloc, one);\n-     } __ else_(); {\n-       \/\/ Update graphKit memory and control from IdealKit.\n-       sync_kit(ideal);\n-       Node* cast = new CastPPNode(control(), z, TypePtr::NOTNULL);\n-       _gvn.set_type(cast, cast->bottom_type());\n-       C->record_for_igvn(cast);\n-\n-       Node* zlen_arg = load_array_length(cast);\n-       \/\/ Update IdealKit memory and control from graphKit.\n-       __ sync_kit(this);\n-       __ if_then(zlen_arg, BoolTest::lt, zlen); {\n-         __ increment (need_alloc, one);\n-       } __ end_if();\n-     } __ end_if();\n-\n-     __ if_then(__ value(need_alloc), BoolTest::ne, zero); {\n-       \/\/ Update graphKit memory and control from IdealKit.\n-       sync_kit(ideal);\n-       Node * narr = new_array(klass_node, zlen, 1);\n-       \/\/ Update IdealKit memory and control from graphKit.\n-       __ sync_kit(this);\n-       __ set(z_alloc, narr);\n-     } __ end_if();\n-\n-     sync_kit(ideal);\n-     z = __ value(z_alloc);\n-     \/\/ Can't use TypeAryPtr::INTS which uses Bottom offset.\n-     _gvn.set_type(z, TypeOopPtr::make_from_klass(klass));\n-     \/\/ Final sync IdealKit and GraphKit.\n-     final_sync(ideal);\n-#undef __\n-\n-    Node* z_start = array_element_address(z, intcon(0), T_INT);\n-\n-    Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                                   OptoRuntime::multiplyToLen_Type(),\n-                                   stubAddr, stubName, TypePtr::BOTTOM,\n-                                   x_start, xlen, y_start, ylen, z_start, zlen);\n-  } \/\/ original reexecute is set back here\n+  Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                 OptoRuntime::multiplyToLen_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 x_start, xlen, y_start, ylen, z_start);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":63,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1388,1 +1388,2 @@\n-                                                        Node* offset, Node* limit, jint stride_con, Node* value);\n+                                                        Node* offset, Node* limit, int stride_con, Node* value,\n+                                                        bool is_template);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -793,2 +793,6 @@\n-  if (bol->Opcode() == Op_Opaque4) {\n-    return nullptr; \/\/ Ignore loop predicate checks (the Opaque4 ensures they will go away)\n+  assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"Initialized Assertion Predicates cannot form a diamond with Halt\");\n+  if (bol->is_Opaque4()) {\n+    \/\/ Ignore Template Assertion Predicates with Opaque4 nodes.\n+    assert(assertion_predicate_has_loop_opaque_node(iff),\n+           \"must be Template Assertion Predicate, non-null-check with Opaque4 cannot form a diamond with Halt\");\n+    return nullptr;\n@@ -1838,1 +1842,2 @@\n-      n->Opcode() != Op_Opaque4 &&\n+      !n->is_Opaque4() &&\n+      !n->is_OpaqueInitializedAssertionPredicate() &&\n@@ -2151,1 +2156,1 @@\n-    Node *b = phi->in(i);\n+    Node* b = phi->in(i);\n@@ -2155,1 +2160,2 @@\n-      assert(b->is_Bool() || b->Opcode() == Op_Opaque4, \"\");\n+      assert(b->is_Bool() || b->is_Opaque4() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with Opaque4 node or Initialized Assertion Predicate with its Opaque node\");\n@@ -2158,1 +2164,0 @@\n-\n@@ -2162,1 +2167,1 @@\n-  if (n->Opcode() == Op_Opaque4) {\n+  if (n->is_Opaque4() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2343,1 +2348,1 @@\n-      if (use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque4 ||\n+      if (use->is_If() || use->is_CMove() || use->is_Opaque4() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1489,3 +1489,2 @@\n-    \/\/ might be a TRUE for finalizers or a fancy class check for\n-    \/\/ newInstance0.\n-    IfNode* toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n+    \/\/ might be a TRUE for finalizers.\n+    IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);\n@@ -2942,1 +2941,2 @@\n-               n->Opcode() == Op_Opaque4   ||\n+               n->is_Opaque4()             ||\n+               n->is_OpaqueInitializedAssertionPredicate() ||\n@@ -3020,1 +3020,1 @@\n-      } else if (n->Opcode() == Op_Opaque4) {\n+      } else if (n->is_Opaque4()) {\n@@ -3033,0 +3033,11 @@\n+      } else if (n->is_OpaqueInitializedAssertionPredicate()) {\n+          \/\/ Initialized Assertion Predicates must always evaluate to true. Therefore, we get rid of them in product\n+          \/\/ builds as they are useless. In debug builds we keep them as additional verification code. Even though\n+          \/\/ loop opts are already over, we want to keep Initialized Assertion Predicates alive as long as possible to\n+          \/\/ enable folding of dead control paths within which cast nodes become top after due to impossible types -\n+          \/\/ even after loop opts are over. Therefore, we delay the removal of these opaque nodes until now.\n+#ifdef ASSERT\n+        _igvn.replace_node(n, n->in(1));\n+#else\n+        _igvn.replace_node(n, _igvn.intcon(1));\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3570,1 +3570,4 @@\n-    result = mem;\n+    \/\/ Ensure vector type is the same\n+    if (!is_StoreVector() || as_StoreVector()->vect_type() == mem->as_LoadVector()->vect_type()) {\n+      result = mem;\n+    }\n@@ -3579,1 +3582,18 @@\n-    result = mem;\n+    if (!is_StoreVector()) {\n+      result = mem;\n+    } else {\n+      const StoreVectorNode* store_vector = as_StoreVector();\n+      const StoreVectorNode* mem_vector = mem->as_StoreVector();\n+      const Node* store_indices = store_vector->indices();\n+      const Node* mem_indices = mem_vector->indices();\n+      const Node* store_mask = store_vector->mask();\n+      const Node* mem_mask = mem_vector->mask();\n+      \/\/ Ensure types, indices, and masks match\n+      if (store_vector->vect_type() == mem_vector->vect_type() &&\n+          ((store_indices == nullptr) == (mem_indices == nullptr) &&\n+           (store_indices == nullptr || store_indices->eqv_uncast(mem_indices))) &&\n+          ((store_mask == nullptr) == (mem_mask == nullptr) &&\n+           (store_mask == nullptr || store_mask->eqv_uncast(mem_mask)))) {\n+        result = mem;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -617,1 +617,1 @@\n-  if (Opcode() == Op_Opaque4) {\n+  if (is_Opaque4()) {\n@@ -2888,9 +2888,0 @@\n-void Node::add_prec_from(Node* n) {\n-  for (uint i = n->req(); i < n->len(); i++) {\n-    Node* prec = n->in(i);\n-    if (prec != nullptr) {\n-      add_prec(prec);\n-    }\n-  }\n-}\n-\n@@ -2920,3 +2911,0 @@\n-bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n-                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+class OpaqueInitializedAssertionPredicateNode;\n@@ -187,0 +188,1 @@\n+class LoadVectorGatherMaskedNode;\n@@ -189,0 +191,1 @@\n+class StoreVectorScatterMaskedNode;\n@@ -807,3 +810,4 @@\n-    DEFINE_CLASS_ID(Move,     Node, 18)\n-    DEFINE_CLASS_ID(LShift,   Node, 19)\n-    DEFINE_CLASS_ID(Neg,      Node, 20)\n+    DEFINE_CLASS_ID(OpaqueInitializedAssertionPredicate,  Node, 18)\n+    DEFINE_CLASS_ID(Move,     Node, 19)\n+    DEFINE_CLASS_ID(LShift,   Node, 20)\n+    DEFINE_CLASS_ID(Neg,      Node, 21)\n@@ -982,0 +986,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueInitializedAssertionPredicate)\n@@ -1013,0 +1018,2 @@\n+  DEFINE_CLASS_QUERY(LoadVectorMasked)\n+  DEFINE_CLASS_QUERY(LoadVectorGatherMasked)\n@@ -1015,0 +1022,2 @@\n+  DEFINE_CLASS_QUERY(StoreVectorMasked)\n+  DEFINE_CLASS_QUERY(StoreVectorScatterMasked)\n@@ -1160,1 +1169,0 @@\n-  void add_prec_from(Node* n);\n@@ -1272,2 +1280,0 @@\n-  bool is_div_or_mod(BasicType bt) const;\n-\n@@ -2043,4 +2049,0 @@\n-Op_IL(Div)\n-Op_IL(Mod)\n-Op_IL(UDiv)\n-Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1159,1 +1159,1 @@\n-  int num_args      = 6;\n+  int num_args      = 5;\n@@ -1168,1 +1168,0 @@\n-  fields[argp++] = TypeInt::INT;        \/\/ zlen\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-            if (use->Opcode() == Op_Opaque4) {\n+            if (use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate()) {\n@@ -355,2 +355,2 @@\n-              \/\/ Uses are either IfNodes, CMoves or Opaque4\n-              if (u->Opcode() == Op_Opaque4) {\n+              \/\/ Uses are either IfNodes, CMoves, Opaque4, or OpaqueInitializedAssertionPredicates\n+              if (u->is_Opaque4() || u->is_OpaqueInitializedAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing(p);\n+    const G1HeapRegion* hr = g1h->heap_region_containing(p);\n@@ -484,1 +484,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing(result);\n+    const G1HeapRegion* hr = g1h->heap_region_containing(result);\n@@ -493,1 +493,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n+    const G1HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n@@ -502,1 +502,1 @@\n-    const HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n+    const G1HeapRegion* hr = g1h->heap_region_containing((void*) addr);\n@@ -545,1 +545,1 @@\n-    return (jint)HeapRegion::GrainBytes;\n+    return (jint)G1HeapRegion::GrainBytes;\n@@ -632,1 +632,1 @@\n-  bool do_heap_region(HeapRegion* r) {\n+  bool do_heap_region(G1HeapRegion* r) {\n@@ -636,1 +636,1 @@\n-      size_t reg_size = HeapRegion::GrainBytes;\n+      size_t reg_size = G1HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2354,0 +2354,9 @@\n+    } else if (match_option(option, \"--sun-misc-unsafe-memory-access=\", &tail)) {\n+      if (strcmp(tail, \"allow\") == 0 || strcmp(tail, \"warn\") == 0 || strcmp(tail, \"debug\") == 0 || strcmp(tail, \"deny\") == 0) {\n+        PropertyList_unique_add(&_system_properties, \"sun.misc.unsafe.memory.access\", tail,\n+                                AddProperty, WriteableProperty, InternalProperty);\n+      } else {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"Value specified to --sun-misc-unsafe-memory-access not recognized: '%s'\\n\", tail);\n+        return JNI_ERR;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1278,1 +1278,0 @@\n-#if COMPILER2_OR_JVMCI\n@@ -1284,3 +1283,0 @@\n-#else\n-        obj = ik->allocate_instance(THREAD);\n-#endif \/\/ COMPILER2_OR_JVMCI\n@@ -1667,1 +1663,0 @@\n-#if COMPILER2_OR_JVMCI\n@@ -1687,1 +1682,0 @@\n-#endif \/* !COMPILER2_OR_JVMCI *\/\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2234,2 +2234,2 @@\n-      log_trace(os, thread)(\"Pretouching thread stack from \" PTR_FORMAT \" to \" PTR_FORMAT \".\",\n-                            p2i(p2), p2i(end));\n+      log_trace(os, thread)(\"Pretouching thread stack for \" UINTX_FORMAT \": \" RANGEFMT \".\",\n+                            (uintx) osthread()->thread_id(), RANGEFMTARGS(p2, to_alloc));\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1187,1 +1187,2 @@\n-\/\/ Get count of Java threads that are waiting to enter or re-enter the specified monitor.\n+\/\/ Get Java threads that are waiting to enter or re-enter the specified monitor.\n+\/\/ Java threads that are executing mounted virtual threads are not included.\n@@ -1198,0 +1199,4 @@\n+    oop thread_oop = JvmtiEnvBase::get_vthread_or_thread_oop(p);\n+    if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+      continue;\n+    }\n@@ -1202,4 +1207,2 @@\n-    oop thread_oop = JvmtiEnvBase::get_vthread_or_thread_oop(p);\n-    bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n-    jint state = is_virtual ? JvmtiEnvBase::get_vthread_state(thread_oop, p)\n-                            : JvmtiEnvBase::get_thread_state(thread_oop, p);\n+    \/\/ do not include virtual threads to the list\n+    jint state = JvmtiEnvBase::get_thread_state(thread_oop, p);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,61 +27,3 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n-import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n-import java.lang.classfile.attribute.CharacterRangeInfo;\n-import java.lang.classfile.attribute.CharacterRangeTableAttribute;\n-import java.lang.classfile.attribute.CodeAttribute;\n-import java.lang.classfile.attribute.CompilationIDAttribute;\n-import java.lang.classfile.attribute.ConstantValueAttribute;\n-import java.lang.classfile.attribute.DeprecatedAttribute;\n-import java.lang.classfile.attribute.EnclosingMethodAttribute;\n-import java.lang.classfile.attribute.ExceptionsAttribute;\n-import java.lang.classfile.attribute.InnerClassInfo;\n-import java.lang.classfile.attribute.InnerClassesAttribute;\n-import java.lang.classfile.attribute.LineNumberInfo;\n-import java.lang.classfile.attribute.LineNumberTableAttribute;\n-import java.lang.classfile.attribute.LoadableDescriptorsAttribute;\n-import java.lang.classfile.attribute.LocalVariableInfo;\n-import java.lang.classfile.attribute.LocalVariableTableAttribute;\n-import java.lang.classfile.attribute.LocalVariableTypeInfo;\n-import java.lang.classfile.attribute.LocalVariableTypeTableAttribute;\n-import java.lang.classfile.attribute.MethodParameterInfo;\n-import java.lang.classfile.attribute.MethodParametersAttribute;\n-import java.lang.classfile.attribute.ModuleAttribute;\n-import java.lang.classfile.attribute.ModuleExportInfo;\n-import java.lang.classfile.attribute.ModuleHashInfo;\n-import java.lang.classfile.attribute.ModuleHashesAttribute;\n-import java.lang.classfile.attribute.ModuleMainClassAttribute;\n-import java.lang.classfile.attribute.ModuleOpenInfo;\n-import java.lang.classfile.attribute.ModulePackagesAttribute;\n-import java.lang.classfile.attribute.ModuleProvideInfo;\n-import java.lang.classfile.attribute.ModuleRequireInfo;\n-import java.lang.classfile.attribute.ModuleResolutionAttribute;\n-import java.lang.classfile.attribute.ModuleTargetAttribute;\n-import java.lang.classfile.attribute.NestHostAttribute;\n-import java.lang.classfile.attribute.NestMembersAttribute;\n-import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n-import java.lang.classfile.attribute.RecordAttribute;\n-import java.lang.classfile.attribute.RecordComponentInfo;\n-import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import java.lang.classfile.attribute.SignatureAttribute;\n-import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n-import java.lang.classfile.attribute.SourceFileAttribute;\n-import java.lang.classfile.attribute.SourceIDAttribute;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.attribute.SyntheticAttribute;\n-import java.lang.classfile.constantpool.Utf8Entry;\n-import jdk.internal.classfile.impl.AbstractAttributeMapper;\n-import jdk.internal.classfile.impl.BoundAttribute;\n-import jdk.internal.classfile.impl.CodeImpl;\n-import jdk.internal.classfile.impl.AbstractPoolEntry;\n-import jdk.internal.classfile.impl.StackMapDecoder;\n+import java.lang.classfile.AttributeMapper.AttributeStability;\n+import java.lang.classfile.attribute.*;\n+import jdk.internal.classfile.impl.AbstractAttributeMapper.*;\n@@ -92,0 +34,55 @@\n+ * <p>\n+ * Unless otherwise specified, mappers returned by each method\n+ * do not permit multiple attribute instances in a given location.\n+ * <p>\n+ * The most stable {@link AttributeStability#STATELESS STATELESS} mappers are:\n+ * <ul>\n+ * <li>{@link #deprecated()}\n+ * <li>{@link #moduleResolution()}\n+ * <li>{@link #sourceDebugExtension()}\n+ * <li>{@link #synthetic()}\n+ * <\/ul>\n+ *\n+ * The mappers with {@link AttributeStability#CP_REFS CP_REFS} stability are:\n+ * <ul>\n+ * <li>{@link #annotationDefault()}\n+ * <li>{@link #bootstrapMethods()}\n+ * <li>{@link #code()}\n+ * <li>{@link #compilationId()}\n+ * <li>{@link #constantValue()}\n+ * <li>{@link #enclosingMethod()}\n+ * <li>{@link #exceptions()}\n+ * <li>{@link #innerClasses()}\n+ * <li>{@link #loadableDescriptors()}\n+ * <li>{@link #methodParameters()}\n+ * <li>{@link #module()}\n+ * <li>{@link #moduleHashes()}\n+ * <li>{@link #moduleMainClass()}\n+ * <li>{@link #modulePackages()}\n+ * <li>{@link #moduleTarget()}\n+ * <li>{@link #nestHost()}\n+ * <li>{@link #nestMembers()}\n+ * <li>{@link #permittedSubclasses()}\n+ * <li>{@link #record()}\n+ * <li>{@link #runtimeInvisibleAnnotations()}\n+ * <li>{@link #runtimeInvisibleParameterAnnotations()}\n+ * <li>{@link #runtimeVisibleAnnotations()}\n+ * <li>{@link #runtimeVisibleParameterAnnotations()}\n+ * <li>{@link #signature()}\n+ * <li>{@link #sourceFile()}\n+ * <li>{@link #sourceId()}\n+ * <\/ul>\n+ *\n+ * The mappers with {@link AttributeStability#LABELS LABELS} stability are:\n+ * <ul>\n+ * <li>{@link #characterRangeTable()}\n+ * <li>{@link #lineNumberTable()}\n+ * <li>{@link #localVariableTable()}\n+ * <li>{@link #localVariableTypeTable()}\n+ * <\/ul>\n+ *\n+ * The {@link AttributeStability#UNSTABLE UNSTABLE} mappers are:\n+ * <ul>\n+ * <li>{@link #runtimeInvisibleTypeAnnotations()}\n+ * <li>{@link #runtimeVisibleTypeAnnotations()}\n+ * <\/ul>\n@@ -98,1 +95,1 @@\n-public class Attributes {\n+public final class Attributes {\n@@ -214,791 +211,284 @@\n-    \/** Attribute mapper for the {@code AnnotationDefault} attribute *\/\n-    public static final AttributeMapper<AnnotationDefaultAttribute>\n-            ANNOTATION_DEFAULT = new AbstractAttributeMapper<>(NAME_ANNOTATION_DEFAULT) {\n-                @Override\n-                public AnnotationDefaultAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundAnnotationDefaultAttr(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, AnnotationDefaultAttribute attr) {\n-                    attr.defaultValue().writeTo(buf);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code BootstrapMethods} attribute *\/\n-    public static final AttributeMapper<BootstrapMethodsAttribute>\n-            BOOTSTRAP_METHODS = new AbstractAttributeMapper<>(NAME_BOOTSTRAP_METHODS) {\n-                @Override\n-                public BootstrapMethodsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundBootstrapMethodsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, BootstrapMethodsAttribute attr) {\n-                    buf.writeList(attr.bootstrapMethods());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code CharacterRangeTable} attribute *\/\n-    public static final AttributeMapper<CharacterRangeTableAttribute>\n-            CHARACTER_RANGE_TABLE = new AbstractAttributeMapper<>(NAME_CHARACTER_RANGE_TABLE, true) {\n-                @Override\n-                public CharacterRangeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundCharacterRangeTableAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n-                    List<CharacterRangeInfo> ranges = attr.characterRangeTable();\n-                    buf.writeU2(ranges.size());\n-                    for (CharacterRangeInfo info : ranges) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.endPc());\n-                        buf.writeInt(info.characterRangeStart());\n-                        buf.writeInt(info.characterRangeEnd());\n-                        buf.writeU2(info.flags());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Code} attribute *\/\n-    public static final AttributeMapper<CodeAttribute>\n-            CODE = new AbstractAttributeMapper<>(NAME_CODE) {\n-                @Override\n-                public CodeAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new CodeImpl(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CodeAttribute attr) {\n-                    throw new UnsupportedOperationException(\"Code attribute does not support direct write\");\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-\n-    \/** Attribute mapper for the {@code CompilationID} attribute *\/\n-    public static final AttributeMapper<CompilationIDAttribute>\n-            COMPILATION_ID = new AbstractAttributeMapper<>(NAME_COMPILATION_ID, true) {\n-                @Override\n-                public CompilationIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundCompilationIDAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, CompilationIDAttribute attr) {\n-                    buf.writeIndex(attr.compilationId());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ConstantValue} attribute *\/\n-    public static final AttributeMapper<ConstantValueAttribute>\n-            CONSTANT_VALUE = new AbstractAttributeMapper<>(NAME_CONSTANT_VALUE) {\n-                @Override\n-                public ConstantValueAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundConstantValueAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ConstantValueAttribute attr) {\n-                    buf.writeIndex(attr.constant());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Deprecated} attribute *\/\n-    public static final AttributeMapper<DeprecatedAttribute>\n-            DEPRECATED = new AbstractAttributeMapper<>(NAME_DEPRECATED, true) {\n-                @Override\n-                public DeprecatedAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundDeprecatedAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, DeprecatedAttribute attr) {\n-                    \/\/ empty\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code EnclosingMethod} attribute *\/\n-    public static final AttributeMapper<EnclosingMethodAttribute>\n-            ENCLOSING_METHOD = new AbstractAttributeMapper<>(NAME_ENCLOSING_METHOD) {\n-                @Override\n-                public EnclosingMethodAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundEnclosingMethodAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n-                    buf.writeIndex(attr.enclosingClass());\n-                    buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Exceptions} attribute *\/\n-    public static final AttributeMapper<ExceptionsAttribute>\n-            EXCEPTIONS = new AbstractAttributeMapper<>(NAME_EXCEPTIONS) {\n-                @Override\n-                public ExceptionsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundExceptionsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ExceptionsAttribute attr) {\n-                    buf.writeListIndices(attr.exceptions());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code InnerClasses} attribute *\/\n-    public static final AttributeMapper<InnerClassesAttribute>\n-            INNER_CLASSES = new AbstractAttributeMapper<>(NAME_INNER_CLASSES) {\n-                @Override\n-                public InnerClassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundInnerClassesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n-                    List<InnerClassInfo> classes = attr.classes();\n-                    buf.writeU2(classes.size());\n-                    for (InnerClassInfo ic : classes) {\n-                        buf.writeIndex(ic.innerClass());\n-                        buf.writeIndexOrZero(ic.outerClass().orElse(null));\n-                        buf.writeIndexOrZero(ic.innerName().orElse(null));\n-                        buf.writeU2(ic.flagsMask());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LineNumberTable} attribute *\/\n-    public static final AttributeMapper<LineNumberTableAttribute>\n-            LINE_NUMBER_TABLE = new AbstractAttributeMapper<>(NAME_LINE_NUMBER_TABLE, true) {\n-                @Override\n-                public LineNumberTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLineNumberTableAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n-                    List<LineNumberInfo> lines = attr.lineNumbers();\n-                    buf.writeU2(lines.size());\n-                    for (LineNumberInfo line : lines) {\n-                        buf.writeU2(line.startPc());\n-                        buf.writeU2(line.lineNumber());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LocalVariableTable} attribute *\/\n-    public static final AttributeMapper<LocalVariableTableAttribute>\n-            LOCAL_VARIABLE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TABLE, true) {\n-                @Override\n-                public LocalVariableTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLocalVariableTableAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n-                    List<LocalVariableInfo> infos = attr.localVariables();\n-                    buf.writeU2(infos.size());\n-                    for (LocalVariableInfo info : infos) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.length());\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.type());\n-                        buf.writeU2(info.slot());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LocalVariableTypeTable} attribute *\/\n-    public static final AttributeMapper<LocalVariableTypeTableAttribute>\n-            LOCAL_VARIABLE_TYPE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TYPE_TABLE, true) {\n-                @Override\n-                public LocalVariableTypeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLocalVariableTypeTableAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n-                    List<LocalVariableTypeInfo> infos = attr.localVariableTypes();\n-                    buf.writeU2(infos.size());\n-                    for (LocalVariableTypeInfo info : infos) {\n-                        buf.writeU2(info.startPc());\n-                        buf.writeU2(info.length());\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.signature());\n-                        buf.writeU2(info.slot());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code MethodParameters} attribute *\/\n-    public static final AttributeMapper<MethodParametersAttribute>\n-            METHOD_PARAMETERS = new AbstractAttributeMapper<>(NAME_METHOD_PARAMETERS) {\n-                @Override\n-                public MethodParametersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundMethodParametersAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n-                    List<MethodParameterInfo> parameters = attr.parameters();\n-                    buf.writeU1(parameters.size());\n-                    for (MethodParameterInfo info : parameters) {\n-                        buf.writeIndexOrZero(info.name().orElse(null));\n-                        buf.writeU2(info.flagsMask());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Module} attribute *\/\n-    public static final AttributeMapper<ModuleAttribute>\n-            MODULE = new AbstractAttributeMapper<>(NAME_MODULE) {\n-                @Override\n-                public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n-                    buf.writeIndex(attr.moduleName());\n-                    buf.writeU2(attr.moduleFlagsMask());\n-                    buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n-                    buf.writeU2(attr.requires().size());\n-                    for (ModuleRequireInfo require : attr.requires()) {\n-                        buf.writeIndex(require.requires());\n-                        buf.writeU2(require.requiresFlagsMask());\n-                        buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n-                    }\n-                    buf.writeU2(attr.exports().size());\n-                    for (ModuleExportInfo export : attr.exports()) {\n-                        buf.writeIndex(export.exportedPackage());\n-                        buf.writeU2(export.exportsFlagsMask());\n-                        buf.writeListIndices(export.exportsTo());\n-                    }\n-                    buf.writeU2(attr.opens().size());\n-                    for (ModuleOpenInfo open : attr.opens()) {\n-                        buf.writeIndex(open.openedPackage());\n-                        buf.writeU2(open.opensFlagsMask());\n-                        buf.writeListIndices(open.opensTo());\n-                    }\n-                    buf.writeListIndices(attr.uses());\n-                    buf.writeU2(attr.provides().size());\n-                    for (ModuleProvideInfo provide : attr.provides()) {\n-                        buf.writeIndex(provide.provides());\n-                        buf.writeListIndices(provide.providesWith());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleHashes} attribute *\/\n-    public static final AttributeMapper<ModuleHashesAttribute>\n-            MODULE_HASHES = new AbstractAttributeMapper<>(NAME_MODULE_HASHES) {\n-                @Override\n-                public ModuleHashesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleHashesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n-                    buf.writeIndex(attr.algorithm());\n-                    List<ModuleHashInfo> hashes = attr.hashes();\n-                    buf.writeU2(hashes.size());\n-                    for (ModuleHashInfo hash : hashes) {\n-                        buf.writeIndex(hash.moduleName());\n-                        buf.writeU2(hash.hash().length);\n-                        buf.writeBytes(hash.hash());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleMainClass} attribute *\/\n-    public static final AttributeMapper<ModuleMainClassAttribute>\n-            MODULE_MAIN_CLASS = new AbstractAttributeMapper<>(NAME_MODULE_MAIN_CLASS) {\n-                @Override\n-                public ModuleMainClassAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleMainClassAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleMainClassAttribute attr) {\n-                    buf.writeIndex(attr.mainClass());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModulePackages} attribute *\/\n-    public static final AttributeMapper<ModulePackagesAttribute>\n-            MODULE_PACKAGES = new AbstractAttributeMapper<>(NAME_MODULE_PACKAGES) {\n-                @Override\n-                public ModulePackagesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModulePackagesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModulePackagesAttribute attr) {\n-                    buf.writeListIndices(attr.packages());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleResolution} attribute *\/\n-    public static final AttributeMapper<ModuleResolutionAttribute>\n-            MODULE_RESOLUTION = new AbstractAttributeMapper<>(NAME_MODULE_RESOLUTION) {\n-                @Override\n-                public ModuleResolutionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleResolutionAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleResolutionAttribute attr) {\n-                    buf.writeU2(attr.resolutionFlags());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code ModuleTarget} attribute *\/\n-    public static final AttributeMapper<ModuleTargetAttribute>\n-            MODULE_TARGET = new AbstractAttributeMapper<>(NAME_MODULE_TARGET) {\n-                @Override\n-                public ModuleTargetAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundModuleTargetAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, ModuleTargetAttribute attr) {\n-                    buf.writeIndex(attr.targetPlatform());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code NestHost} attribute *\/\n-    public static final AttributeMapper<NestHostAttribute>\n-            NEST_HOST = new AbstractAttributeMapper<>(NAME_NEST_HOST) {\n-                @Override\n-                public NestHostAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundNestHostAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, NestHostAttribute attr) {\n-                    buf.writeIndex(attr.nestHost());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code NestMembers} attribute *\/\n-    public static final AttributeMapper<NestMembersAttribute>\n-            NEST_MEMBERS = new AbstractAttributeMapper<>(NAME_NEST_MEMBERS) {\n-                @Override\n-                public NestMembersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundNestMembersAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, NestMembersAttribute attr) {\n-                    buf.writeListIndices(attr.nestMembers());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code PermittedSubclasses} attribute *\/\n-    public static final AttributeMapper<PermittedSubclassesAttribute>\n-            PERMITTED_SUBCLASSES = new AbstractAttributeMapper<>(NAME_PERMITTED_SUBCLASSES) {\n-                @Override\n-                public PermittedSubclassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundPermittedSubclassesAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, PermittedSubclassesAttribute attr) {\n-                    buf.writeListIndices(attr.permittedSubclasses());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code LoadableDescriptors} attribute *\/\n-    public static final AttributeMapper<LoadableDescriptorsAttribute>\n-            LOADABLE_DESCRIPTORS = new AbstractAttributeMapper<>(NAME_LOADABLE_DESCRIPTORS) {\n-                @Override\n-                public LoadableDescriptorsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundLoadableDescriptorsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, LoadableDescriptorsAttribute attr) {\n-                    buf.writeListIndices(attr.loadableDescriptors());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Record} attribute *\/\n-    public static final AttributeMapper<RecordAttribute>\n-            RECORD = new AbstractAttributeMapper<>(NAME_RECORD) {\n-                @Override\n-                public RecordAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRecordAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RecordAttribute attr) {\n-                    List<RecordComponentInfo> components = attr.components();\n-                    buf.writeU2(components.size());\n-                    for (RecordComponentInfo info : components) {\n-                        buf.writeIndex(info.name());\n-                        buf.writeIndex(info.descriptor());\n-                        buf.writeList(info.attributes());\n-                    }\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute(cf, pos);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleParameterAnnotationsAttribute attr) {\n-                    List<List<Annotation>> lists = attr.parameterAnnotations();\n-                    buf.writeU1(lists.size());\n-                    for (List<Annotation> list : lists)\n-                        buf.writeList(list);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute>\n-            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeInvisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeInvisibleTypeAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.UNSTABLE;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleAnnotationsAttribute>\n-            RUNTIME_VISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n-                    return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute>\n-            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleParameterAnnotationsAttribute attr) {\n-                    List<List<Annotation>> lists = attr.parameterAnnotations();\n-                    buf.writeU1(lists.size());\n-                    for (List<Annotation> list : lists)\n-                        buf.writeList(list);\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute *\/\n-    public static final AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute>\n-            RUNTIME_VISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS) {\n-                @Override\n-                public RuntimeVisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute(e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, RuntimeVisibleTypeAnnotationsAttribute attr) {\n-                    buf.writeList(attr.annotations());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.UNSTABLE;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code Signature} attribute *\/\n-    public static final AttributeMapper<SignatureAttribute>\n-            SIGNATURE = new AbstractAttributeMapper<>(NAME_SIGNATURE) {\n-                @Override\n-                public SignatureAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSignatureAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SignatureAttribute attr) {\n-                    buf.writeIndex(attr.signature());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceDebugExtension} attribute *\/\n-    public static final AttributeMapper<SourceDebugExtensionAttribute>\n-            SOURCE_DEBUG_EXTENSION = new AbstractAttributeMapper<>(NAME_SOURCE_DEBUG_EXTENSION) {\n-                @Override\n-                public SourceDebugExtensionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceDebugExtensionAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceDebugExtensionAttribute attr) {\n-                    buf.writeBytes(attr.contents());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceFile} attribute *\/\n-    public static final AttributeMapper<SourceFileAttribute>\n-            SOURCE_FILE = new AbstractAttributeMapper<>(NAME_SOURCE_FILE) {\n-                @Override\n-                public SourceFileAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceFileAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceFileAttribute attr) {\n-                    buf.writeIndex(attr.sourceFile());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code SourceID} attribute *\/\n-    public static final AttributeMapper<SourceIDAttribute>\n-            SOURCE_ID = new AbstractAttributeMapper<>(NAME_SOURCE_ID) {\n-                @Override\n-                public SourceIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSourceIDAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SourceIDAttribute attr) {\n-                    buf.writeIndex(attr.sourceId());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.CP_REFS;\n-                }\n-            };\n-\n-    \/** Attribute mapper for the {@code StackMapTable} attribute *\/\n-    public static final AttributeMapper<StackMapTableAttribute>\n-            STACK_MAP_TABLE = new AbstractAttributeMapper<>(NAME_STACK_MAP_TABLE) {\n-                @Override\n-                public StackMapTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundStackMapTableAttribute((CodeImpl)e, cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter b, StackMapTableAttribute attr) {\n-                    StackMapDecoder.writeFrames(b, attr.entries());\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.LABELS;\n-                }\n-            };\n-\n-\n-    \/** Attribute mapper for the {@code Synthetic} attribute *\/\n-    public static final AttributeMapper<SyntheticAttribute>\n-            SYNTHETIC = new AbstractAttributeMapper<>(NAME_SYNTHETIC, true) {\n-                @Override\n-                public SyntheticAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-                    return new BoundAttribute.BoundSyntheticAttribute(cf, this, p);\n-                }\n-\n-                @Override\n-                protected void writeBody(BufWriter buf, SyntheticAttribute attr) {\n-                    \/\/ empty\n-                }\n-\n-                @Override\n-                public AttributeMapper.AttributeStability stability() {\n-                    return AttributeStability.STATELESS;\n-                }\n-            };\n+    \/**\n+     * {@return Attribute mapper for the {@code AnnotationDefault} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<AnnotationDefaultAttribute> annotationDefault() {\n+        return AnnotationDefaultMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code BootstrapMethods} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<BootstrapMethodsAttribute> bootstrapMethods() {\n+        return BootstrapMethodsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code CharacterRangeTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CharacterRangeTableAttribute> characterRangeTable() {\n+        return CharacterRangeTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Code} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CodeAttribute> code() {\n+        return CodeMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code CompilationID} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<CompilationIDAttribute> compilationId() {\n+        return CompilationIDMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ConstantValue} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ConstantValueAttribute> constantValue() {\n+        return ConstantValueMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Deprecated} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<DeprecatedAttribute> deprecated() {\n+        return DeprecatedMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code EnclosingMethod} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<EnclosingMethodAttribute> enclosingMethod() {\n+        return EnclosingMethodMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Exceptions} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ExceptionsAttribute> exceptions() {\n+        return ExceptionsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code InnerClasses} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<InnerClassesAttribute> innerClasses() {\n+        return InnerClassesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LineNumberTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LineNumberTableAttribute> lineNumberTable() {\n+        return LineNumberTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LoadableDescriptors} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LoadableDescriptorsAttribute> loadableDescriptors() {\n+        return LoadableDescriptorsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LocalVariableTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LocalVariableTableAttribute> localVariableTable() {\n+        return LocalVariableTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code LocalVariableTypeTable} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<LocalVariableTypeTableAttribute> localVariableTypeTable() {\n+        return LocalVariableTypeTableMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code MethodParameters} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<MethodParametersAttribute> methodParameters() {\n+        return MethodParametersMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Module} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleAttribute> module() {\n+        return ModuleMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleHashes} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleHashesAttribute> moduleHashes() {\n+        return ModuleHashesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleMainClass} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleMainClassAttribute> moduleMainClass() {\n+        return ModuleMainClassMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModulePackages} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModulePackagesAttribute> modulePackages() {\n+        return ModulePackagesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleResolution} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleResolutionAttribute> moduleResolution() {\n+        return ModuleResolutionMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code ModuleTarget} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<ModuleTargetAttribute> moduleTarget() {\n+        return ModuleTargetMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code NestHost} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<NestHostAttribute> nestHost() {\n+        return NestHostMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code NestMembers} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<NestMembersAttribute> nestMembers() {\n+        return NestMembersMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code PermittedSubclasses} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<PermittedSubclassesAttribute> permittedSubclasses() {\n+        return PermittedSubclassesMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Record} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RecordAttribute> record() {\n+        return RecordMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleAnnotationsAttribute> runtimeInvisibleAnnotations() {\n+        return RuntimeInvisibleAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute> runtimeInvisibleParameterAnnotations() {\n+        return RuntimeInvisibleParameterAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute> runtimeInvisibleTypeAnnotations() {\n+        return RuntimeInvisibleTypeAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleAnnotationsAttribute> runtimeVisibleAnnotations() {\n+        return RuntimeVisibleAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute> runtimeVisibleParameterAnnotations() {\n+        return RuntimeVisibleParameterAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute> runtimeVisibleTypeAnnotations() {\n+        return RuntimeVisibleTypeAnnotationsMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code Signature} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SignatureAttribute> signature() {\n+        return SignatureMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceDebugExtension} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceDebugExtensionAttribute> sourceDebugExtension() {\n+        return SourceDebugExtensionMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceFile} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceFileAttribute> sourceFile() {\n+        return SourceFileMapper.INSTANCE;\n+    }\n+\n+    \/**\n+     * {@return Attribute mapper for the {@code SourceID} attribute}\n+     * @since 23\n+     *\/\n+    public static AttributeMapper<SourceIDAttribute> sourceId() {\n+        return SourceIDMapper.INSTANCE;\n+    }\n@@ -1007,3 +497,2 @@\n-     * {@return the attribute mapper for a standard attribute}\n-     *\n-     * @param name the name of the attribute to find\n+     * {@return Attribute mapper for the {@code StackMapTable} attribute}\n+     * @since 23\n@@ -1011,2 +500,2 @@\n-    public static AttributeMapper<?> standardAttribute(Utf8Entry name) {\n-        return _ATTR_MAP.get(name);\n+    public static AttributeMapper<StackMapTableAttribute> stackMapTable() {\n+        return StackMapTableMapper.INSTANCE;\n@@ -1016,1 +505,3 @@\n-     * All standard attribute mappers.\n+     * {@return Attribute mapper for the {@code Synthetic} attribute}\n+     * The mapper permits multiple instances in a given location.\n+     * @since 23\n@@ -1018,47 +509,2 @@\n-    public static final Set<AttributeMapper<?>> PREDEFINED_ATTRIBUTES = Set.of(\n-            ANNOTATION_DEFAULT,\n-            BOOTSTRAP_METHODS,\n-            CHARACTER_RANGE_TABLE,\n-            CODE,\n-            COMPILATION_ID,\n-            CONSTANT_VALUE,\n-            DEPRECATED,\n-            ENCLOSING_METHOD,\n-            EXCEPTIONS,\n-            INNER_CLASSES,\n-            LINE_NUMBER_TABLE,\n-            LOADABLE_DESCRIPTORS,\n-            LOCAL_VARIABLE_TABLE,\n-            LOCAL_VARIABLE_TYPE_TABLE,\n-            METHOD_PARAMETERS,\n-            MODULE,\n-            MODULE_HASHES,\n-            MODULE_MAIN_CLASS,\n-            MODULE_PACKAGES,\n-            MODULE_RESOLUTION,\n-            MODULE_TARGET,\n-            NEST_HOST,\n-            NEST_MEMBERS,\n-            PERMITTED_SUBCLASSES,\n-            RECORD,\n-            RUNTIME_INVISIBLE_ANNOTATIONS,\n-            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS,\n-            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS,\n-            RUNTIME_VISIBLE_ANNOTATIONS,\n-            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS,\n-            RUNTIME_VISIBLE_TYPE_ANNOTATIONS,\n-            SIGNATURE,\n-            SOURCE_DEBUG_EXTENSION,\n-            SOURCE_FILE,\n-            SOURCE_ID,\n-            STACK_MAP_TABLE,\n-            SYNTHETIC);\n-\n-    private static final Map<Utf8Entry, AttributeMapper<?>> _ATTR_MAP;\n-    \/\/no lambdas here as this is on critical JDK boostrap path\n-    static {\n-        var map = new HashMap<Utf8Entry, AttributeMapper<?>>(64);\n-        for (var am : PREDEFINED_ATTRIBUTES) {\n-            map.put(AbstractPoolEntry.rawUtf8EntryFromStandardAttributeName(am.name()), am);\n-        }\n-        _ATTR_MAP = Collections.unmodifiableMap(map);\n+    public static AttributeMapper<SyntheticAttribute> synthetic() {\n+        return SyntheticMapper.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attributes.java","additions":352,"deletions":906,"binary":false,"changes":1258,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -323,0 +323,3 @@\n+     * Note: the returned var handle does not perform any size or alignment check. It is up to clients\n+     * to adapt the returned var handle and insert the appropriate checks.\n+     *\n@@ -333,1 +336,0 @@\n-        long size = Utils.byteWidthOfPrimitive(carrier);\n@@ -338,1 +340,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsBytes(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n@@ -340,1 +342,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsChars(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsChars(be, alignmentMask, exact));\n@@ -342,1 +344,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsShorts(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsShorts(be, alignmentMask, exact));\n@@ -344,1 +346,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsInts(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsInts(be, alignmentMask, exact));\n@@ -346,1 +348,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsFloats(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsFloats(be, alignmentMask, exact));\n@@ -348,1 +350,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsLongs(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsLongs(be, alignmentMask, exact));\n@@ -350,1 +352,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsDoubles(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsDoubles(be, alignmentMask, exact));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -262,2 +262,6 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameter in addition to explicitly\n+     * declared ones.\n+     * Also note that compact constructors of a record class may have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters.\n@@ -268,0 +272,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -287,3 +292,7 @@\n-     * Also note that as a <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">modeling\n-     * artifact<\/a>, the number of returned parameters can differ\n+     * Compact constructors of a record class may also have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters,\n+     * but they are a special case and thus considered as if they had\n+     * been explicitly declared in the source.\n+     * Finally note that as a {@link java.lang.reflect##LanguageJvmModel\n+     * modeling artifact}, the number of returned parameters can differ\n@@ -291,3 +300,9 @@\n-     * generic information is present, only parameters explicitly\n-     * present in the source will be returned; if generic information\n-     * is not present, implicit and synthetic parameters may be\n+     * generic information is present, parameters explicitly\n+     * present in the source or parameters of compact constructors\n+     * of a record class will be returned.\n+     * Note that parameters of compact constructors of a record class are a special case,\n+     * as they are not explicitly present in the source, and its type will be returned\n+     * regardless of the parameters being\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} or not.\n+     * If generic information is not present, implicit and synthetic parameters may be\n@@ -298,1 +313,5 @@\n-     * the actual type arguments used in the source code.\n+     * the actual type arguments used in the source code. This assertion also\n+     * applies to the parameters of compact constructors of a record class,\n+     * independently of them being\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} or not.\n@@ -316,0 +335,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -342,9 +362,7 @@\n-                final Type[] out = new Type[nonGenericParamTypes.length];\n-                final Parameter[] params = getParameters();\n-                int fromidx = 0;\n-                for (int i = 0; i < out.length; i++) {\n-                    final Parameter param = params[i];\n-                    if (param.isSynthetic() || param.isImplicit()) {\n-                        \/\/ If we hit a synthetic or mandated parameter,\n-                        \/\/ use the non generic parameter info.\n-                        out[i] = nonGenericParamTypes[i];\n+                if (getDeclaringClass().isRecord() && this instanceof Constructor) {\n+                    \/* we could be seeing a compact constructor of a record class\n+                     * its parameters are mandated but we should be able to retrieve\n+                     * its generic information if present\n+                     *\/\n+                    if (genericParamTypes.length == nonGenericParamTypes.length) {\n+                        return genericParamTypes;\n@@ -352,3 +370,1 @@\n-                        \/\/ Otherwise, use the generic parameter info.\n-                        out[i] = genericParamTypes[fromidx];\n-                        fromidx++;\n+                        return nonGenericParamTypes.clone();\n@@ -356,0 +372,17 @@\n+                } else {\n+                    final Type[] out = new Type[nonGenericParamTypes.length];\n+                    final Parameter[] params = getParameters();\n+                    int fromidx = 0;\n+                    for (int i = 0; i < out.length; i++) {\n+                        final Parameter param = params[i];\n+                        if (param.isSynthetic() || param.isImplicit()) {\n+                            \/\/ If we hit a synthetic or mandated parameter,\n+                            \/\/ use the non generic parameter info.\n+                            out[i] = nonGenericParamTypes[i];\n+                        } else {\n+                            \/\/ Otherwise, use the generic parameter info.\n+                            out[i] = genericParamTypes[fromidx];\n+                            fromidx++;\n+                        }\n+                    }\n+                    return out;\n@@ -357,1 +390,0 @@\n-                return out;\n@@ -755,2 +787,6 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameter in addition to explicitly declared ones.\n+     * Also note that compact constructors of a record class may have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters.\n@@ -762,0 +798,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":61,"deletions":24,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassBuilder;\n@@ -51,0 +52,2 @@\n+\n+import jdk.internal.constant.ClassDescImpl;\n@@ -77,4 +80,6 @@\n-    private static final MethodHandle NULL_CHECK;\n-    private static final MethodHandle IS_ZERO;\n-    private static final MethodHandle CHECK_INDEX;\n-    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n+\n+    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class,\n+            BiPredicate.class,\n+            List.class);\n@@ -84,15 +89,23 @@\n-\n-    static {\n-        try {\n-            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n-                                           MethodType.methodType(boolean.class, Object.class));\n-            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n-                                           MethodType.methodType(boolean.class, int.class));\n-            CHECK_INDEX = LOOKUP.findStatic(Objects.class, \"checkIndex\",\n-                                           MethodType.methodType(int.class, int.class, int.class));\n-            MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n-                                                   MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n-                                                                         Class.class, EnumDesc[].class, EnumMap.class));\n-        }\n-        catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n+    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n+            MethodTypeDesc.ofDescriptor(\"(II)I\");\n+\n+    private static final ClassDesc CD_Objects = ClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+\n+    private static class StaticHolders {\n+        private static final MethodHandle NULL_CHECK;\n+        private static final MethodHandle IS_ZERO;\n+        private static final MethodHandle MAPPED_ENUM_LOOKUP;\n+\n+        static {\n+            try {\n+                NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n+                                               MethodType.methodType(boolean.class, Object.class));\n+                IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n+                                               MethodType.methodType(boolean.class, int.class));\n+                MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n+                                                       MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n+                                                                             Class.class, EnumDesc[].class, EnumMap.class));\n+            }\n+            catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n@@ -166,2 +179,3 @@\n-        requireNonNull(labels);\n-        Stream.of(labels).forEach(l -> verifyLabel(l, selectorType));\n+        for (Object l : labels) { \/\/ implicit null-check\n+            verifyLabel(l, selectorType);\n+        }\n@@ -172,2 +186,0 @@\n-        target = withIndexCheck(target, labels.length);\n-\n@@ -285,1 +297,1 @@\n-                    MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                    MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.NULL_CHECK, 0, int.class),\n@@ -287,1 +299,1 @@\n-                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(IS_ZERO, 1, Object.class),\n+                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.IS_ZERO, 1, Object.class),\n@@ -289,1 +301,1 @@\n-                                                                            MethodHandles.insertArguments(MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n+                                                                            MethodHandles.insertArguments(StaticHolders.MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n@@ -296,1 +308,0 @@\n-        target = withIndexCheck(target, labels.length);\n@@ -342,6 +353,0 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n-\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n-    }\n-\n@@ -410,0 +415,5 @@\n+            \/\/ Objects.checkIndex(RESTART_IDX, labelConstants + 1)\n+            cb.iload(RESTART_IDX);\n+            cb.loadConstant(labelConstants.length + 1);\n+            cb.invokestatic(CD_Objects, \"checkIndex\", CHECK_INDEX_DESCRIPTOR);\n+            cb.pop();\n@@ -624,1 +634,1 @@\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())),\n+        byte[] classBytes = ClassFile.of().build(ClassDescImpl.ofValidatedBinaryName(typeSwitchClassName(caller.lookupClass())),\n@@ -639,6 +649,2 @@\n-                                                        MethodType.methodType(int.class,\n-                                                                              Object.class,\n-                                                                              int.class,\n-                                                                              BiPredicate.class,\n-                                                                              List.class));\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                        TYPES_SWITCH_TYPE);\n+            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":46,"deletions":40,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.Annotation;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.AttributedElement;\n@@ -30,0 +32,3 @@\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.attribute.*;\n+import java.util.List;\n@@ -31,1 +36,3 @@\n-public abstract class AbstractAttributeMapper<T extends Attribute<T>>\n+import static java.lang.classfile.Attributes.*;\n+\n+public sealed abstract class AbstractAttributeMapper<T extends Attribute<T>>\n@@ -35,0 +42,1 @@\n+    private final AttributeMapper.AttributeStability stability;\n@@ -39,2 +47,2 @@\n-    public AbstractAttributeMapper(String name) {\n-        this(name, false);\n+    public AbstractAttributeMapper(String name, AttributeMapper.AttributeStability stability) {\n+        this(name, stability, false);\n@@ -44,0 +52,1 @@\n+                                   AttributeMapper.AttributeStability stability,\n@@ -46,0 +55,1 @@\n+        this.stability = stability;\n@@ -50,1 +60,1 @@\n-    public String name() {\n+    public final String name() {\n@@ -55,1 +65,1 @@\n-    public void writeAttribute(BufWriter buf, T attr) {\n+    public final void writeAttribute(BufWriter buf, T attr) {\n@@ -64,0 +74,5 @@\n+    @Override\n+    public AttributeMapper.AttributeStability stability() {\n+        return stability;\n+    }\n+\n@@ -74,0 +89,753 @@\n+\n+    public static final class AnnotationDefaultMapper extends AbstractAttributeMapper<AnnotationDefaultAttribute> {\n+        public static final AnnotationDefaultMapper INSTANCE = new AnnotationDefaultMapper();\n+\n+        private AnnotationDefaultMapper() {\n+            super(NAME_ANNOTATION_DEFAULT, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public AnnotationDefaultAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundAnnotationDefaultAttr(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, AnnotationDefaultAttribute attr) {\n+            attr.defaultValue().writeTo(buf);\n+        }\n+    }\n+\n+    public static final class BootstrapMethodsMapper extends AbstractAttributeMapper<BootstrapMethodsAttribute> {\n+        public static final BootstrapMethodsMapper INSTANCE = new BootstrapMethodsMapper();\n+\n+        private BootstrapMethodsMapper() {\n+            super(NAME_BOOTSTRAP_METHODS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public BootstrapMethodsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundBootstrapMethodsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, BootstrapMethodsAttribute attr) {\n+            buf.writeList(attr.bootstrapMethods());\n+        }\n+    }\n+\n+    public static final class CharacterRangeTableMapper extends AbstractAttributeMapper<CharacterRangeTableAttribute> {\n+        public static final CharacterRangeTableMapper INSTANCE = new CharacterRangeTableMapper();\n+\n+        private CharacterRangeTableMapper() {\n+            super(NAME_CHARACTER_RANGE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public CharacterRangeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundCharacterRangeTableAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n+            List<CharacterRangeInfo> ranges = attr.characterRangeTable();\n+            buf.writeU2(ranges.size());\n+            for (CharacterRangeInfo info : ranges) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.endPc());\n+                buf.writeInt(info.characterRangeStart());\n+                buf.writeInt(info.characterRangeEnd());\n+                buf.writeU2(info.flags());\n+            }\n+        }\n+    }\n+\n+    public static final class CodeMapper extends AbstractAttributeMapper<CodeAttribute> {\n+        public static final CodeMapper INSTANCE = new CodeMapper();\n+\n+        private CodeMapper() {\n+            super(NAME_CODE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public CodeAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new CodeImpl(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CodeAttribute attr) {\n+            throw new UnsupportedOperationException(\"Code attribute does not support direct write\");\n+        }\n+    }\n+\n+    public static final class CompilationIDMapper extends AbstractAttributeMapper<CompilationIDAttribute> {\n+        public static final CompilationIDMapper INSTANCE = new CompilationIDMapper();\n+\n+        private CompilationIDMapper() {\n+            super(NAME_COMPILATION_ID, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public CompilationIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundCompilationIDAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, CompilationIDAttribute attr) {\n+            buf.writeIndex(attr.compilationId());\n+        }\n+    }\n+\n+    public static final class ConstantValueMapper extends AbstractAttributeMapper<ConstantValueAttribute> {\n+        public static final ConstantValueMapper INSTANCE = new ConstantValueMapper();\n+\n+        private ConstantValueMapper() {\n+            super(NAME_CONSTANT_VALUE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ConstantValueAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundConstantValueAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ConstantValueAttribute attr) {\n+            buf.writeIndex(attr.constant());\n+        }\n+    }\n+\n+    public static final class DeprecatedMapper extends AbstractAttributeMapper<DeprecatedAttribute> {\n+        public static final DeprecatedMapper INSTANCE = new DeprecatedMapper();\n+\n+        private DeprecatedMapper() {\n+            super(NAME_DEPRECATED, AttributeStability.STATELESS, true);\n+        }\n+\n+        @Override\n+        public DeprecatedAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundDeprecatedAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, DeprecatedAttribute attr) {\n+            \/\/ empty\n+        }\n+    }\n+\n+    public static final class EnclosingMethodMapper extends AbstractAttributeMapper<EnclosingMethodAttribute> {\n+        public static final EnclosingMethodMapper INSTANCE = new EnclosingMethodMapper();\n+\n+        private EnclosingMethodMapper() {\n+            super(NAME_ENCLOSING_METHOD, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public EnclosingMethodAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundEnclosingMethodAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n+            buf.writeIndex(attr.enclosingClass());\n+            buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n+        }\n+    }\n+\n+    public static final class ExceptionsMapper extends AbstractAttributeMapper<ExceptionsAttribute> {\n+        public static final ExceptionsMapper INSTANCE = new ExceptionsMapper();\n+\n+        private ExceptionsMapper() {\n+            super(NAME_EXCEPTIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ExceptionsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundExceptionsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ExceptionsAttribute attr) {\n+            buf.writeListIndices(attr.exceptions());\n+        }\n+    }\n+\n+    public static final class InnerClassesMapper extends AbstractAttributeMapper<InnerClassesAttribute> {\n+        public static final InnerClassesMapper INSTANCE = new InnerClassesMapper();\n+\n+        private InnerClassesMapper() {\n+            super(NAME_INNER_CLASSES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public InnerClassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundInnerClassesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n+            List<InnerClassInfo> classes = attr.classes();\n+            buf.writeU2(classes.size());\n+            for (InnerClassInfo ic : classes) {\n+                buf.writeIndex(ic.innerClass());\n+                buf.writeIndexOrZero(ic.outerClass().orElse(null));\n+                buf.writeIndexOrZero(ic.innerName().orElse(null));\n+                buf.writeU2(ic.flagsMask());\n+            }\n+        }\n+    }\n+\n+    public static final class LineNumberTableMapper extends AbstractAttributeMapper<LineNumberTableAttribute> {\n+        public static final LineNumberTableMapper INSTANCE = new LineNumberTableMapper();\n+\n+        private LineNumberTableMapper() {\n+            super(NAME_LINE_NUMBER_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LineNumberTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLineNumberTableAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n+            List<LineNumberInfo> lines = attr.lineNumbers();\n+            buf.writeU2(lines.size());\n+            for (LineNumberInfo line : lines) {\n+                buf.writeU2(line.startPc());\n+                buf.writeU2(line.lineNumber());\n+            }\n+        }\n+    }\n+\n+    public static final class LoadableDescriptorsMapper extends AbstractAttributeMapper<LoadableDescriptorsAttribute> {\n+        public static final LoadableDescriptorsMapper INSTANCE = new LoadableDescriptorsMapper();\n+\n+        private LoadableDescriptorsMapper() {\n+            super(NAME_LOADABLE_DESCRIPTORS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public LoadableDescriptorsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLoadableDescriptorsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LoadableDescriptorsAttribute attr) {\n+            buf.writeListIndices(attr.loadableDescriptors());\n+        }\n+    }\n+\n+    public static final class LocalVariableTableMapper extends AbstractAttributeMapper<LocalVariableTableAttribute> {\n+        public static final LocalVariableTableMapper INSTANCE = new LocalVariableTableMapper();\n+\n+        private LocalVariableTableMapper() {\n+            super(NAME_LOCAL_VARIABLE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LocalVariableTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLocalVariableTableAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n+            List<LocalVariableInfo> infos = attr.localVariables();\n+            buf.writeU2(infos.size());\n+            for (LocalVariableInfo info : infos) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.length());\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.type());\n+                buf.writeU2(info.slot());\n+            }\n+        }\n+    }\n+\n+    public static final class LocalVariableTypeTableMapper extends AbstractAttributeMapper<LocalVariableTypeTableAttribute> {\n+        public static final LocalVariableTypeTableMapper INSTANCE = new LocalVariableTypeTableMapper();\n+\n+        private LocalVariableTypeTableMapper() {\n+            super(NAME_LOCAL_VARIABLE_TYPE_TABLE, AttributeStability.LABELS, true);\n+        }\n+\n+        @Override\n+        public LocalVariableTypeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundLocalVariableTypeTableAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n+            List<LocalVariableTypeInfo> infos = attr.localVariableTypes();\n+            buf.writeU2(infos.size());\n+            for (LocalVariableTypeInfo info : infos) {\n+                buf.writeU2(info.startPc());\n+                buf.writeU2(info.length());\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.signature());\n+                buf.writeU2(info.slot());\n+            }\n+        }\n+    }\n+\n+    public static final class MethodParametersMapper extends AbstractAttributeMapper<MethodParametersAttribute> {\n+        public static final MethodParametersMapper INSTANCE = new MethodParametersMapper();\n+\n+        private MethodParametersMapper() {\n+            super(NAME_METHOD_PARAMETERS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public MethodParametersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundMethodParametersAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n+            List<MethodParameterInfo> parameters = attr.parameters();\n+            buf.writeU1(parameters.size());\n+            for (MethodParameterInfo info : parameters) {\n+                buf.writeIndexOrZero(info.name().orElse(null));\n+                buf.writeU2(info.flagsMask());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleMapper extends AbstractAttributeMapper<ModuleAttribute> {\n+        public static final ModuleMapper INSTANCE = new ModuleMapper();\n+\n+        private ModuleMapper() {\n+            super(NAME_MODULE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n+            buf.writeIndex(attr.moduleName());\n+            buf.writeU2(attr.moduleFlagsMask());\n+            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+            buf.writeU2(attr.requires().size());\n+            for (ModuleRequireInfo require : attr.requires()) {\n+                buf.writeIndex(require.requires());\n+                buf.writeU2(require.requiresFlagsMask());\n+                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+            }\n+            buf.writeU2(attr.exports().size());\n+            for (ModuleExportInfo export : attr.exports()) {\n+                buf.writeIndex(export.exportedPackage());\n+                buf.writeU2(export.exportsFlagsMask());\n+                buf.writeListIndices(export.exportsTo());\n+            }\n+            buf.writeU2(attr.opens().size());\n+            for (ModuleOpenInfo open : attr.opens()) {\n+                buf.writeIndex(open.openedPackage());\n+                buf.writeU2(open.opensFlagsMask());\n+                buf.writeListIndices(open.opensTo());\n+            }\n+            buf.writeListIndices(attr.uses());\n+            buf.writeU2(attr.provides().size());\n+            for (ModuleProvideInfo provide : attr.provides()) {\n+                buf.writeIndex(provide.provides());\n+                buf.writeListIndices(provide.providesWith());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleHashesMapper extends AbstractAttributeMapper<ModuleHashesAttribute> {\n+        public static final ModuleHashesMapper INSTANCE = new ModuleHashesMapper();\n+\n+        private ModuleHashesMapper() {\n+            super(NAME_MODULE_HASHES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleHashesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleHashesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n+            buf.writeIndex(attr.algorithm());\n+            List<ModuleHashInfo> hashes = attr.hashes();\n+            buf.writeU2(hashes.size());\n+            for (ModuleHashInfo hash : hashes) {\n+                buf.writeIndex(hash.moduleName());\n+                buf.writeU2(hash.hash().length);\n+                buf.writeBytes(hash.hash());\n+            }\n+        }\n+    }\n+\n+    public static final class ModuleMainClassMapper extends AbstractAttributeMapper<ModuleMainClassAttribute> {\n+        public static final ModuleMainClassMapper INSTANCE = new ModuleMainClassMapper();\n+\n+        private ModuleMainClassMapper() {\n+            super(NAME_MODULE_MAIN_CLASS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleMainClassAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleMainClassAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleMainClassAttribute attr) {\n+            buf.writeIndex(attr.mainClass());\n+        }\n+    }\n+\n+    public static final class ModulePackagesMapper extends AbstractAttributeMapper<ModulePackagesAttribute> {\n+        public static final ModulePackagesMapper INSTANCE = new ModulePackagesMapper();\n+\n+        private ModulePackagesMapper() {\n+            super(NAME_MODULE_PACKAGES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModulePackagesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModulePackagesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModulePackagesAttribute attr) {\n+            buf.writeListIndices(attr.packages());\n+        }\n+    }\n+\n+    public static final class ModuleResolutionMapper extends AbstractAttributeMapper<ModuleResolutionAttribute> {\n+        public static final ModuleResolutionMapper INSTANCE = new ModuleResolutionMapper();\n+\n+        private ModuleResolutionMapper() {\n+            super(NAME_MODULE_RESOLUTION, AttributeStability.STATELESS);\n+        }\n+\n+        @Override\n+        public ModuleResolutionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleResolutionAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleResolutionAttribute attr) {\n+            buf.writeU2(attr.resolutionFlags());\n+        }\n+    }\n+\n+    public static final class ModuleTargetMapper extends AbstractAttributeMapper<ModuleTargetAttribute> {\n+        public static final ModuleTargetMapper INSTANCE = new ModuleTargetMapper();\n+\n+        private ModuleTargetMapper() {\n+            super(NAME_MODULE_TARGET, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public ModuleTargetAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleTargetAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleTargetAttribute attr) {\n+            buf.writeIndex(attr.targetPlatform());\n+        }\n+    }\n+\n+    public static final class NestHostMapper extends AbstractAttributeMapper<NestHostAttribute> {\n+        public static final NestHostMapper INSTANCE = new NestHostMapper();\n+\n+        private NestHostMapper() {\n+            super(NAME_NEST_HOST, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public NestHostAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundNestHostAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, NestHostAttribute attr) {\n+            buf.writeIndex(attr.nestHost());\n+        }\n+    }\n+\n+    public static final class NestMembersMapper extends AbstractAttributeMapper<NestMembersAttribute> {\n+        public static final NestMembersMapper INSTANCE = new NestMembersMapper();\n+\n+        private NestMembersMapper() {\n+            super(NAME_NEST_MEMBERS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public NestMembersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundNestMembersAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, NestMembersAttribute attr) {\n+            buf.writeListIndices(attr.nestMembers());\n+        }\n+    }\n+\n+    public static final class PermittedSubclassesMapper extends AbstractAttributeMapper<PermittedSubclassesAttribute> {\n+        public static final PermittedSubclassesMapper INSTANCE = new PermittedSubclassesMapper();\n+\n+        private PermittedSubclassesMapper() {\n+            super(NAME_PERMITTED_SUBCLASSES, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public PermittedSubclassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundPermittedSubclassesAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, PermittedSubclassesAttribute attr) {\n+            buf.writeListIndices(attr.permittedSubclasses());\n+        }\n+    }\n+\n+    public static final class RecordMapper extends AbstractAttributeMapper<RecordAttribute> {\n+        public static final RecordMapper INSTANCE = new RecordMapper();\n+\n+        private RecordMapper() {\n+            super(NAME_RECORD, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RecordAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRecordAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RecordAttribute attr) {\n+            List<RecordComponentInfo> components = attr.components();\n+            buf.writeU2(components.size());\n+            for (RecordComponentInfo info : components) {\n+                buf.writeIndex(info.name());\n+                buf.writeIndex(info.descriptor());\n+                buf.writeList(info.attributes());\n+            }\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleAnnotationsAttribute> {\n+        public static final RuntimeInvisibleAnnotationsMapper INSTANCE = new RuntimeInvisibleAnnotationsMapper();\n+\n+        private RuntimeInvisibleAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute(cf, pos);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleParameterAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute> {\n+        public static final RuntimeInvisibleParameterAnnotationsMapper INSTANCE = new RuntimeInvisibleParameterAnnotationsMapper();\n+\n+        private RuntimeInvisibleParameterAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleParameterAnnotationsAttribute attr) {\n+            List<List<Annotation>> lists = attr.parameterAnnotations();\n+            buf.writeU1(lists.size());\n+            for (List<Annotation> list : lists)\n+                buf.writeList(list);\n+        }\n+    }\n+\n+    public static final class RuntimeInvisibleTypeAnnotationsMapper extends AbstractAttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute> {\n+        public static final RuntimeInvisibleTypeAnnotationsMapper INSTANCE = new RuntimeInvisibleTypeAnnotationsMapper();\n+\n+        private RuntimeInvisibleTypeAnnotationsMapper() {\n+            super(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, AttributeStability.UNSTABLE);\n+        }\n+\n+        @Override\n+        public RuntimeInvisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeInvisibleTypeAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleAnnotationsAttribute> {\n+        public static final RuntimeVisibleAnnotationsMapper INSTANCE = new RuntimeVisibleAnnotationsMapper();\n+\n+        private RuntimeVisibleAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleParameterAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleParameterAnnotationsAttribute> {\n+        public static final RuntimeVisibleParameterAnnotationsMapper INSTANCE = new RuntimeVisibleParameterAnnotationsMapper();\n+\n+        private RuntimeVisibleParameterAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleParameterAnnotationsAttribute attr) {\n+            List<List<Annotation>> lists = attr.parameterAnnotations();\n+            buf.writeU1(lists.size());\n+            for (List<Annotation> list : lists)\n+                buf.writeList(list);\n+        }\n+    }\n+\n+    public static final class RuntimeVisibleTypeAnnotationsMapper extends AbstractAttributeMapper<RuntimeVisibleTypeAnnotationsAttribute> {\n+        public static final RuntimeVisibleTypeAnnotationsMapper INSTANCE = new RuntimeVisibleTypeAnnotationsMapper();\n+\n+        private RuntimeVisibleTypeAnnotationsMapper() {\n+            super(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS, AttributeStability.UNSTABLE);\n+        }\n+\n+        @Override\n+        public RuntimeVisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleTypeAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    }\n+\n+    public static final class SignatureMapper extends AbstractAttributeMapper<SignatureAttribute> {\n+        public static final SignatureMapper INSTANCE = new SignatureMapper();\n+\n+        private SignatureMapper() {\n+            super(NAME_SIGNATURE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SignatureAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSignatureAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SignatureAttribute attr) {\n+            buf.writeIndex(attr.signature());\n+        }\n+    }\n+\n+    public static final class SourceDebugExtensionMapper extends AbstractAttributeMapper<SourceDebugExtensionAttribute> {\n+        public static final SourceDebugExtensionMapper INSTANCE = new SourceDebugExtensionMapper();\n+\n+        private SourceDebugExtensionMapper() {\n+            super(NAME_SOURCE_DEBUG_EXTENSION, AttributeStability.STATELESS);\n+        }\n+\n+        @Override\n+        public SourceDebugExtensionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceDebugExtensionAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceDebugExtensionAttribute attr) {\n+            buf.writeBytes(attr.contents());\n+        }\n+    }\n+\n+    public static final class SourceFileMapper extends AbstractAttributeMapper<SourceFileAttribute> {\n+        public static final SourceFileMapper INSTANCE = new SourceFileMapper();\n+\n+        private SourceFileMapper() {\n+            super(NAME_SOURCE_FILE, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SourceFileAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceFileAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceFileAttribute attr) {\n+            buf.writeIndex(attr.sourceFile());\n+        }\n+    }\n+\n+    public static final class SourceIDMapper extends AbstractAttributeMapper<SourceIDAttribute> {\n+        public static final SourceIDMapper INSTANCE = new SourceIDMapper();\n+\n+        private SourceIDMapper() {\n+            super(NAME_SOURCE_ID, AttributeStability.CP_REFS);\n+        }\n+\n+        @Override\n+        public SourceIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSourceIDAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SourceIDAttribute attr) {\n+            buf.writeIndex(attr.sourceId());\n+        }\n+    }\n+\n+    public static final class StackMapTableMapper extends AbstractAttributeMapper<StackMapTableAttribute> {\n+        public static final StackMapTableMapper INSTANCE = new StackMapTableMapper();\n+\n+        private StackMapTableMapper() {\n+            super(NAME_STACK_MAP_TABLE, AttributeStability.LABELS);\n+        }\n+\n+        @Override\n+        public StackMapTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundStackMapTableAttribute((CodeImpl)e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter b, StackMapTableAttribute attr) {\n+            StackMapDecoder.writeFrames(b, attr.entries());\n+        }\n+    }\n+\n+    public static final class SyntheticMapper extends AbstractAttributeMapper<SyntheticAttribute> {\n+        public static final SyntheticMapper INSTANCE = new SyntheticMapper();\n+\n+        private SyntheticMapper() {\n+            super(NAME_SYNTHETIC, AttributeStability.STATELESS, true);\n+        }\n+\n+        @Override\n+        public SyntheticAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundSyntheticAttribute(cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, SyntheticAttribute attr) {\n+            \/\/ empty\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":773,"deletions":5,"binary":false,"changes":778,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static java.lang.classfile.Attributes.*;\n+\n@@ -143,1 +145,1 @@\n-            var mapper = Attributes.standardAttribute(name);\n+            var mapper = standardAttribute(name);\n@@ -892,1 +894,1 @@\n-            super(cf, Attributes.RUNTIME_INVISIBLE_ANNOTATIONS, payloadStart);\n+            super(cf, Attributes.runtimeInvisibleAnnotations(), payloadStart);\n@@ -910,1 +912,1 @@\n-            super(cf, Attributes.RUNTIME_VISIBLE_ANNOTATIONS, payloadStart);\n+            super(cf, Attributes.runtimeVisibleAnnotations(), payloadStart);\n@@ -1003,0 +1005,86 @@\n+\n+    \/**\n+     * {@return the attribute mapper for a standard attribute}\n+     *\n+     * @param name the name of the attribute to find\n+     *\/\n+    public static AttributeMapper<?> standardAttribute(Utf8Entry name) {\n+        \/\/ critical bootstrap path, so no lambdas nor method handles here\n+        return switch (name.hashCode()) {\n+            case 0x78147009 ->\n+                name.equalsString(NAME_ANNOTATION_DEFAULT) ? annotationDefault() : null;\n+            case 0x665e3a3a ->\n+                name.equalsString(NAME_BOOTSTRAP_METHODS) ? bootstrapMethods() : null;\n+            case 0xcb7e162 ->\n+                name.equalsString(NAME_CHARACTER_RANGE_TABLE) ? characterRangeTable() : null;\n+            case 0x21e41e7e ->\n+                name.equalsString(NAME_CODE) ? code() : null;\n+            case 0x5a306b41 ->\n+                name.equalsString(NAME_COMPILATION_ID) ? compilationId() : null;\n+            case 0x3e191c7c ->\n+                name.equalsString(NAME_CONSTANT_VALUE) ? constantValue() : null;\n+            case 0x5e88ed0c ->\n+                name.equalsString(NAME_DEPRECATED) ? deprecated() : null;\n+            case 0x7284695e ->\n+                name.equalsString(NAME_ENCLOSING_METHOD) ? enclosingMethod() : null;\n+            case 0x21df25db ->\n+                name.equalsString(NAME_EXCEPTIONS) ? exceptions() : null;\n+            case 0x11392da9 ->\n+                name.equalsString(NAME_INNER_CLASSES) ? innerClasses() : null;\n+            case 0x167536fc ->\n+                name.equalsString(NAME_LINE_NUMBER_TABLE) ? lineNumberTable() : null;\n+            case 0x4d56b212 ->\n+                name.equalsString(NAME_LOADABLE_DESCRIPTORS) ? loadableDescriptors() : null;\n+            case 0x46939abc ->\n+                name.equalsString(NAME_LOCAL_VARIABLE_TABLE) ? localVariableTable() : null;\n+            case 0x63ee67f4 ->\n+                name.equalsString(NAME_LOCAL_VARIABLE_TYPE_TABLE) ? localVariableTypeTable() : null;\n+            case 0x2b597e15 ->\n+                name.equalsString(NAME_METHOD_PARAMETERS) ? methodParameters() : null;\n+            case 0x19f20ade ->\n+                name.equalsString(NAME_MODULE) ? module() : null;\n+            case 0x47f6395e ->\n+                name.equalsString(NAME_MODULE_HASHES) ? moduleHashes() : null;\n+            case 0x54db809 ->\n+                name.equalsString(NAME_MODULE_MAIN_CLASS) ? moduleMainClass() : null;\n+            case 0x1abd1c2c ->\n+                name.equalsString(NAME_MODULE_PACKAGES) ? modulePackages() : null;\n+            case 0x6ba46dd ->\n+                name.equalsString(NAME_MODULE_RESOLUTION) ? moduleResolution() : null;\n+            case 0x46f7d91d ->\n+                name.equalsString(NAME_MODULE_TARGET) ? moduleTarget() : null;\n+            case 0x5137f53 ->\n+                name.equalsString(NAME_NEST_HOST) ? nestHost() : null;\n+            case 0x4a8fa3b6 ->\n+                name.equalsString(NAME_NEST_MEMBERS) ? nestMembers() : null;\n+            case 0x55c73cb6 ->\n+                name.equalsString(NAME_PERMITTED_SUBCLASSES) ? permittedSubclasses() : null;\n+            case 0x3fe76d4e ->\n+                name.equalsString(NAME_RECORD) ? record() : null;\n+            case 0x180d6925 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_ANNOTATIONS) ? runtimeInvisibleAnnotations() : null;\n+            case 0x7be22752 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS) ? runtimeInvisibleParameterAnnotations() : null;\n+            case 0x5299824 ->\n+                name.equalsString(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) ? runtimeInvisibleTypeAnnotations() : null;\n+            case 0x3534786e ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_ANNOTATIONS) ? runtimeVisibleAnnotations() : null;\n+            case 0xb4b4ac6 ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS) ? runtimeVisibleParameterAnnotations() : null;\n+            case 0x6926482 ->\n+                name.equalsString(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS) ? runtimeVisibleTypeAnnotations() : null;\n+            case 0x16a42b7c ->\n+                name.equalsString(NAME_SIGNATURE) ? signature() : null;\n+            case 0x400ab245 ->\n+                name.equalsString(NAME_SOURCE_DEBUG_EXTENSION) ? sourceDebugExtension() : null;\n+            case 0x2af490d4 ->\n+                name.equalsString(NAME_SOURCE_FILE) ? sourceFile() : null;\n+            case 0x303e0c58 ->\n+                name.equalsString(NAME_SOURCE_ID) ? sourceId() : null;\n+            case 0x19c7d0cd ->\n+                name.equalsString(NAME_STACK_MAP_TABLE) ? stackMapTable() : null;\n+            case 0x3dc79b7a ->\n+                name.equalsString(NAME_SYNTHETIC) ? synthetic() : null;\n+            default -> null;\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":91,"deletions":3,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-                            idi.bootstrapMethod(), idi.name().stringValue(),\n+                            mapDirectMethodHandle(idi.bootstrapMethod()), idi.name().stringValue(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-            super(Attributes.CONSTANT_VALUE);\n+            super(Attributes.constantValue());\n@@ -168,1 +168,1 @@\n-            super(Attributes.DEPRECATED);\n+            super(Attributes.deprecated());\n@@ -176,1 +176,1 @@\n-            super(Attributes.SYNTHETIC);\n+            super(Attributes.synthetic());\n@@ -186,1 +186,1 @@\n-            super(Attributes.SIGNATURE);\n+            super(Attributes.signature());\n@@ -202,1 +202,1 @@\n-            super(Attributes.EXCEPTIONS);\n+            super(Attributes.exceptions());\n@@ -218,1 +218,1 @@\n-            super(Attributes.ANNOTATION_DEFAULT);\n+            super(Attributes.annotationDefault());\n@@ -233,1 +233,1 @@\n-            super(Attributes.SOURCE_FILE);\n+            super(Attributes.sourceFile());\n@@ -249,1 +249,1 @@\n-            super(Attributes.STACK_MAP_TABLE);\n+            super(Attributes.stackMapTable());\n@@ -265,1 +265,1 @@\n-            super(Attributes.INNER_CLASSES);\n+            super(Attributes.innerClasses());\n@@ -281,1 +281,1 @@\n-            super(Attributes.RECORD);\n+            super(Attributes.record());\n@@ -298,1 +298,1 @@\n-            super(Attributes.ENCLOSING_METHOD);\n+            super(Attributes.enclosingMethod());\n@@ -320,1 +320,1 @@\n-            super(Attributes.METHOD_PARAMETERS);\n+            super(Attributes.methodParameters());\n@@ -336,1 +336,1 @@\n-            super(Attributes.MODULE_TARGET);\n+            super(Attributes.moduleTarget());\n@@ -352,1 +352,1 @@\n-            super(Attributes.MODULE_MAIN_CLASS);\n+            super(Attributes.moduleMainClass());\n@@ -369,1 +369,1 @@\n-            super(Attributes.MODULE_HASHES);\n+            super(Attributes.moduleHashes());\n@@ -391,1 +391,1 @@\n-            super(Attributes.MODULE_PACKAGES);\n+            super(Attributes.modulePackages());\n@@ -407,1 +407,1 @@\n-            super(Attributes.MODULE_RESOLUTION);\n+            super(Attributes.moduleResolution());\n@@ -423,1 +423,1 @@\n-            super(Attributes.PERMITTED_SUBCLASSES);\n+            super(Attributes.permittedSubclasses());\n@@ -439,1 +439,1 @@\n-            super(Attributes.LOADABLE_DESCRIPTORS);\n+            super(Attributes.loadableDescriptors());\n@@ -455,1 +455,1 @@\n-            super(Attributes.NEST_MEMBERS);\n+            super(Attributes.nestMembers());\n@@ -471,1 +471,1 @@\n-            super(Attributes.NEST_HOST);\n+            super(Attributes.nestHost());\n@@ -487,1 +487,1 @@\n-            super(Attributes.COMPILATION_ID);\n+            super(Attributes.compilationId());\n@@ -503,1 +503,1 @@\n-            super(Attributes.SOURCE_ID);\n+            super(Attributes.sourceId());\n@@ -519,1 +519,1 @@\n-            super(Attributes.SOURCE_DEBUG_EXTENSION);\n+            super(Attributes.sourceDebugExtension());\n@@ -535,1 +535,1 @@\n-            super(Attributes.CHARACTER_RANGE_TABLE);\n+            super(Attributes.characterRangeTable());\n@@ -551,1 +551,1 @@\n-            super(Attributes.LINE_NUMBER_TABLE);\n+            super(Attributes.lineNumberTable());\n@@ -567,1 +567,1 @@\n-            super(Attributes.LOCAL_VARIABLE_TABLE);\n+            super(Attributes.localVariableTable());\n@@ -583,1 +583,1 @@\n-            super(Attributes.LOCAL_VARIABLE_TYPE_TABLE);\n+            super(Attributes.localVariableTypeTable());\n@@ -599,1 +599,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleAnnotations());\n@@ -615,1 +615,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleAnnotations());\n@@ -631,1 +631,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleParameterAnnotations());\n@@ -647,1 +647,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleParameterAnnotations());\n@@ -663,1 +663,1 @@\n-            super(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+            super(Attributes.runtimeVisibleTypeAnnotations());\n@@ -679,1 +679,1 @@\n-            super(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+            super(Attributes.runtimeInvisibleTypeAnnotations());\n@@ -865,1 +865,1 @@\n-            super(Attributes.MODULE);\n+            super(Attributes.module());\n@@ -941,1 +941,1 @@\n-            super(Attributes.BOOTSTRAP_METHODS);\n+            super(Attributes.bootstrapMethods());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -72,0 +72,11 @@\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDesc ofValidatedBinaryName(String typeSwitchClassName) {\n+        return ofValidated(\"L\" + binaryToInternal(typeSwitchClassName) + \";\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassDescImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,3 +75,1 @@\n-        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\", status=\"Deprecated\")\n-        UNNAMED_CLASSES,\n-        @JEP(number=463, title=\"Implicitly Declared Classes and Instance Main Methods\", status=\"Preview\")\n+        @JEP(number=477, title=\"Implicitly Declared Classes and Instance Main Methods\", status=\"Third Preview\")\n@@ -81,1 +79,1 @@\n-        @JEP(number=462, title=\"Structured Concurrency\", status=\"Second Preview\")\n+        @JEP(number=480, title=\"Structured Concurrency\", status=\"Third Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-            case SUPER_INIT -> true;\n+            case FLEXIBLE_CONSTRUCTORS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-        SUPER_INIT(JDK22, Fragments.FeatureSuperInit, DiagKind.NORMAL),\n@@ -272,0 +271,1 @@\n+        FLEXIBLE_CONSTRUCTORS(JDK22, Fragments.FeatureFlexibleConstructors, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -231,0 +231,1 @@\n+    public final Type ioType;\n@@ -635,0 +636,1 @@\n+        ioType = enterClass(\"java.io.IO\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,3 @@\n-        } else if ((v.flags() & FINAL) != 0 &&\n+            return;\n+        }\n+        if ((v.flags() & FINAL) != 0 &&\n@@ -307,0 +309,17 @@\n+            return;\n+        }\n+\n+        \/\/ Check instance field assignments that appear in constructor prologues\n+        if (rs.isEarlyReference(env, base, v)) {\n+\n+            \/\/ Field may not be inherited from a superclass\n+            if (v.owner != env.enclClass.sym) {\n+                log.error(pos, Errors.CantRefBeforeCtorCalled(v));\n+                return;\n+            }\n+\n+            \/\/ Field may not have an initializer\n+            if ((v.flags() & HASINIT) != 0) {\n+                log.error(pos, Errors.CantAssignInitializedBeforeCtorCalled(v));\n+                return;\n+            }\n@@ -2811,0 +2830,1 @@\n+                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4161,1 +4161,1 @@\n-                    preview.checkSourceLevel(apply.pos(), Feature.SUPER_INIT);\n+                    preview.checkSourceLevel(apply.pos(), Feature.FLEXIBLE_CONSTRUCTORS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1516,1 +1516,1 @@\n-                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0) {\n+                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym)) {\n@@ -3777,0 +3777,1 @@\n+        Assert.check(name == names._this || name == names._super);\n@@ -3786,1 +3787,1 @@\n-                    else if (env1.info.ctorPrologue)\n+                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym))\n@@ -3839,0 +3840,64 @@\n+    \/**\n+     * Determine if an early instance field reference may appear in a constructor prologue.\n+     *\n+     * <p>\n+     * This is only allowed when:\n+     *  - The field is being assigned a value (i.e., written but not read)\n+     *  - The field is not inherited from a superclass\n+     *  - The assignment is not within a lambda, because that would require\n+     *    capturing 'this' which is not allowed prior to super().\n+     *\n+     * <p>\n+     * Note, this method doesn't catch all such scenarios, because this method\n+     * is invoked for symbol \"x\" only for \"x = 42\" but not for \"this.x = 42\".\n+     * We also don't verify that the field has no initializer, which is required.\n+     * To catch those cases, we rely on similar logic in Attr.checkAssignable().\n+     *\/\n+    private boolean isAllowedEarlyReference(Env<AttrContext> env, VarSymbol v) {\n+\n+        \/\/ Check assumptions\n+        Assert.check(env.info.ctorPrologue);\n+        Assert.check((v.flags_field & STATIC) == 0);\n+\n+        \/\/ The symbol must appear in the LHS of an assignment statement\n+        if (!(env.tree instanceof JCAssign assign))\n+            return false;\n+\n+        \/\/ The assignment statement must not be within a lambda\n+        if (env.info.isLambda)\n+            return false;\n+\n+        \/\/ Get the symbol's qualifier, if any\n+        JCExpression lhs = TreeInfo.skipParens(assign.lhs);\n+        JCExpression base = lhs instanceof JCFieldAccess select ? select.selected : null;\n+\n+        \/\/ If an early reference, the field must not be declared in a superclass\n+        if (isEarlyReference(env, base, v) && v.owner != env.enclClass.sym)\n+            return false;\n+\n+        \/\/ OK\n+        return true;\n+    }\n+\n+    \/**\n+     * Determine if the variable appearance constitutes an early reference to the current class.\n+     *\n+     * <p>\n+     * This means the variable is an instance field of the current class and it appears\n+     * in an early initialization context of it (i.e., one of its constructor prologues).\n+     *\n+     * <p>\n+     * Such a reference is only allowed for assignments to non-initialized fields that are\n+     * not inherited from a superclass, though that is not enforced by this method.\n+     *\n+     * @param env    The current environment\n+     * @param base   Variable qualifier, if any, otherwise null\n+     * @param v      The variable\n+     *\/\n+    public boolean isEarlyReference(Env<AttrContext> env, JCTree base, VarSymbol v) {\n+        return env.info.ctorPrologue &&\n+            (v.flags() & STATIC) == 0 &&\n+            v.owner.kind == TYP &&\n+            types.isSubtype(env.enclClass.type, v.owner.type) &&\n+            (base == null || TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-        private void importJavaLang(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter typeImportFilter) {\n+        private void implicitImports(JCCompilationUnit tree, Env<AttrContext> env) {\n@@ -336,0 +336,22 @@\n+\n+            List<JCTree> defs = tree.getTypeDecls();\n+            boolean isImplicitClass = !defs.isEmpty() &&\n+                    defs.head instanceof JCClassDecl cls &&\n+                    (cls.mods.flags & IMPLICIT_CLASS) != 0;\n+            if (isImplicitClass) {\n+                doModuleImport(make.ModuleImport(make.QualIdent(syms.java_base)));\n+                if (peekTypeExists(syms.ioType.tsym)) {\n+                    doImport(make.Import(make.Select(make.QualIdent(syms.ioType.tsym),\n+                            names.asterisk), true));\n+                }\n+            }\n+        }\n+\n+        private boolean peekTypeExists(TypeSymbol type) {\n+            try {\n+                type.complete();\n+                return !type.type.isErroneous();\n+            } catch (CompletionFailure cf) {\n+                \/\/does not exist\n+                return false;\n+            }\n@@ -360,1 +382,1 @@\n-                importJavaLang(tree, env, typeImportFilter);\n+                implicitImports(tree, env);\n@@ -480,1 +502,1 @@\n-                        if (export.modules != null && !export.modules.contains(env.toplevel.packge.modle)) {\n+                        if (export.modules != null && !export.modules.contains(env.toplevel.modle)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -175,2 +175,2 @@\n-    Set<JCMethodInvocation> invocationsWithPatternMatchingCatch = Set.of();\n-    ListBuffer<int[]> patternMatchingInvocationRanges;\n+    PatternMatchingCatchConfiguration patternMatchingCatchConfiguration =\n+            new PatternMatchingCatchConfiguration(Set.of(), null, null, null);\n@@ -1135,3 +1135,1 @@\n-        Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n-        ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n-        State startState = code.state.dup();\n+        PatternMatchingCatchConfiguration prevConfiguration = patternMatchingCatchConfiguration;\n@@ -1139,2 +1137,5 @@\n-            invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n-            patternMatchingInvocationRanges = new ListBuffer<>();\n+            patternMatchingCatchConfiguration =\n+                    new PatternMatchingCatchConfiguration(tree.patternMatchingCatch.calls2Handle(),\n+                                                         new ListBuffer<int[]>(),\n+                                                         tree.patternMatchingCatch.handler(),\n+                                                         code.state.dup());\n@@ -1143,0 +1144,8 @@\n+            generatePatternMatchingCatch(env);\n+            patternMatchingCatchConfiguration = prevConfiguration;\n+        }\n+    }\n+\n+    private void generatePatternMatchingCatch(Env<GenContext> env) {\n+        if (patternMatchingCatchConfiguration.handler != null &&\n+            !patternMatchingCatchConfiguration.ranges.isEmpty()) {\n@@ -1144,3 +1153,6 @@\n-            JCCatch handler = tree.patternMatchingCatch.handler();\n-            code.entryPoint(startState, handler.param.sym.type);\n-            genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+            JCCatch handler = patternMatchingCatchConfiguration.handler();\n+            code.entryPoint(patternMatchingCatchConfiguration.startState(),\n+                            handler.param.sym.type);\n+            genPatternMatchingCatch(handler,\n+                                    env,\n+                                    patternMatchingCatchConfiguration.ranges.toList());\n@@ -1148,2 +1160,0 @@\n-            invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n-            patternMatchingInvocationRanges = prevRanges;\n@@ -1974,1 +1984,1 @@\n-        if (invocationsWithPatternMatchingCatch.contains(tree)) {\n+        if (patternMatchingCatchConfiguration.invocations().contains(tree)) {\n@@ -1977,1 +1987,1 @@\n-            patternMatchingInvocationRanges.add(new int[] {start, code.curCP()});\n+            patternMatchingCatchConfiguration.ranges().add(new int[] {start, code.curCP()});\n@@ -1979,1 +1989,15 @@\n-            result = m.invoke();\n+            if (msym.isConstructor() && TreeInfo.isConstructorCall(tree)) {\n+                \/\/if this is a this(...) or super(...) call, there is a pending\n+                \/\/\"uninitialized this\" before this call. One catch handler cannot\n+                \/\/handle exceptions that may come from places with \"uninitialized this\"\n+                \/\/and (initialized) this, hence generate one set of handlers here\n+                \/\/for the \"uninitialized this\" case, and another set of handlers\n+                \/\/will be generated at the end of the method for the initialized this,\n+                \/\/if needed:\n+                generatePatternMatchingCatch(env);\n+                result = m.invoke();\n+                patternMatchingCatchConfiguration =\n+                        patternMatchingCatchConfiguration.restart(code.state.dup());\n+            } else {\n+                result = m.invoke();\n+            }\n@@ -2603,0 +2627,11 @@\n+    record PatternMatchingCatchConfiguration(Set<JCMethodInvocation> invocations,\n+                                            ListBuffer<int[]> ranges,\n+                                            JCCatch handler,\n+                                            State startState) {\n+        public PatternMatchingCatchConfiguration restart(State newState) {\n+            return new PatternMatchingCatchConfiguration(invocations(),\n+                                                        new ListBuffer<int[]>(),\n+                                                        handler(),\n+                                                        newState);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":50,"deletions":15,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -402,0 +402,4 @@\n+# 0: symbol or name\n+compiler.err.cant.assign.initialized.before.ctor.called=\\\n+    cannot assign initialized field ''{0}'' before supertype constructor has been called\n+\n@@ -3227,2 +3231,2 @@\n-compiler.misc.feature.super.init=\\\n-    statements before super()\n+compiler.misc.feature.flexible.constructors=\\\n+    flexible constructors\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-                    var sigAttr = componentInfo.findAttribute(Attributes.SIGNATURE);\n+                    var sigAttr = componentInfo.findAttribute(Attributes.signature());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-        cm.findAttribute(Attributes.SOURCE_FILE).ifPresent(sfa ->\n+        cm.findAttribute(Attributes.sourceFile()).ifPresent(sfa ->\n@@ -156,1 +156,1 @@\n-            var attr = classModel.findAttribute(Attributes.MODULE);\n+            var attr = classModel.findAttribute(Attributes.module());\n@@ -183,1 +183,1 @@\n-            var sigAttr = classModel.findAttribute(Attributes.SIGNATURE).orElse(null);\n+            var sigAttr = classModel.findAttribute(Attributes.signature()).orElse(null);\n@@ -404,1 +404,1 @@\n-                f.findAttribute(Attributes.SIGNATURE)\n+                f.findAttribute(Attributes.signature())\n@@ -410,1 +410,1 @@\n-            var a = f.findAttribute(Attributes.CONSTANT_VALUE);\n+            var a = f.findAttribute(Attributes.constantValue());\n@@ -485,1 +485,1 @@\n-            var sigAttr = m.findAttribute(Attributes.SIGNATURE);\n+            var sigAttr = m.findAttribute(Attributes.signature());\n@@ -512,1 +512,1 @@\n-            var e_attr = m.findAttribute(Attributes.EXCEPTIONS);\n+            var e_attr = m.findAttribute(Attributes.exceptions());\n@@ -564,1 +564,1 @@\n-                code.findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                code.findAttribute(Attributes.lineNumberTable())\n@@ -566,1 +566,1 @@\n-                code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE)\n+                code.findAttribute(Attributes.localVariableTable())\n@@ -594,1 +594,1 @@\n-        var attr = classModel.findAttribute(Attributes.MODULE);\n+        var attr = classModel.findAttribute(Attributes.module());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,14 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n+import java.security.PrivilegedAction;\n+import java.util.List;\n+import java.util.Set;\n+\n@@ -29,0 +43,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -33,4 +48,0 @@\n-import java.lang.reflect.Field;\n-import java.util.Set;\n-\n-\n@@ -51,0 +62,5 @@\n+ * @apiNote\n+ * This class pre-dates the introduction of {@link VarHandle}, low-level access to\n+ * memory with {@linkplain java.lang.foreign}, and other standard APIs. New code\n+ * should not use this API.\n+ *\n@@ -152,0 +168,3 @@\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfInt, long)} instead.\n+     *\n@@ -161,0 +180,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -163,0 +183,1 @@\n+        beforeMemoryAccess();\n@@ -177,0 +198,3 @@\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfInt, long, int)} instead.\n+     *\n@@ -186,0 +210,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -188,0 +213,1 @@\n+        beforeMemoryAccess();\n@@ -193,1 +219,2 @@\n-     * @see #getInt(Object, long)\n+     *\n+     * @deprecated Use {@link VarHandle#get(Object...)} instead.\n@@ -195,0 +222,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -197,0 +225,1 @@\n+        beforeMemoryAccess();\n@@ -208,1 +237,2 @@\n-     * @see #putInt(Object, long, int)\n+     *\n+     * @deprecated Use {@link VarHandle#set(Object...)} instead.\n@@ -210,0 +240,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -212,0 +243,1 @@\n+        beforeMemoryAccess();\n@@ -215,1 +247,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfBoolean, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -218,0 +256,1 @@\n+        beforeMemoryAccess();\n@@ -221,1 +260,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfBoolean, long, boolean)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -224,0 +269,1 @@\n+        beforeMemoryAccess();\n@@ -227,1 +273,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfByte, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -230,0 +282,1 @@\n+        beforeMemoryAccess();\n@@ -233,1 +286,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfByte, long, byte)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -236,0 +295,1 @@\n+        beforeMemoryAccess();\n@@ -239,1 +299,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfShort, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -242,0 +308,1 @@\n+        beforeMemoryAccess();\n@@ -245,1 +312,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfShort, long, short)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -248,0 +321,1 @@\n+        beforeMemoryAccess();\n@@ -251,1 +325,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfChar, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -254,0 +334,1 @@\n+        beforeMemoryAccess();\n@@ -257,1 +338,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfChar, long, char)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -260,0 +347,1 @@\n+        beforeMemoryAccess();\n@@ -263,1 +351,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfLong, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -266,0 +360,1 @@\n+        beforeMemoryAccess();\n@@ -269,1 +364,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfLong, long, long)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -272,0 +373,1 @@\n+        beforeMemoryAccess();\n@@ -275,1 +377,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfFloat, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -278,0 +386,1 @@\n+        beforeMemoryAccess();\n@@ -281,1 +390,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfFloat, long, float)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -284,0 +399,1 @@\n+        beforeMemoryAccess();\n@@ -287,1 +403,7 @@\n-    \/** @see #getInt(Object, long) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#get(Object...)} or\n+     * {@link MemorySegment#get(ValueLayout.OfDouble, long)} instead.\n+     *\n+     * @see #getInt(Object, long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -290,0 +412,1 @@\n+        beforeMemoryAccess();\n@@ -293,1 +416,7 @@\n-    \/** @see #putInt(Object, long, int) *\/\n+    \/**\n+     * @deprecated Use {@link VarHandle#set(Object...)} or\n+     * {@link MemorySegment#set(ValueLayout.OfDouble, long, double)} instead.\n+     *\n+     * @see #putInt(Object, long, int)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -296,0 +425,1 @@\n+        beforeMemoryAccess();\n@@ -306,0 +436,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -308,0 +440,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -310,0 +443,1 @@\n+        beforeMemoryAccess();\n@@ -318,0 +452,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -320,0 +456,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -322,0 +459,1 @@\n+        beforeMemoryAccess();\n@@ -325,1 +463,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -328,0 +471,1 @@\n+        beforeMemoryAccess();\n@@ -331,1 +475,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -334,0 +483,1 @@\n+        beforeMemoryAccess();\n@@ -337,1 +487,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -340,0 +495,1 @@\n+        beforeMemoryAccess();\n@@ -343,1 +499,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -346,0 +507,1 @@\n+        beforeMemoryAccess();\n@@ -349,1 +511,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -352,0 +519,1 @@\n+        beforeMemoryAccess();\n@@ -355,1 +523,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -358,0 +531,1 @@\n+        beforeMemoryAccess();\n@@ -361,1 +535,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -364,0 +543,1 @@\n+        beforeMemoryAccess();\n@@ -367,1 +547,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -370,0 +555,1 @@\n+        beforeMemoryAccess();\n@@ -373,1 +559,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -376,0 +567,1 @@\n+        beforeMemoryAccess();\n@@ -379,1 +571,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -382,0 +579,1 @@\n+        beforeMemoryAccess();\n@@ -385,1 +583,6 @@\n-    \/** @see #getByte(long) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #getByte(long)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -388,0 +591,1 @@\n+        beforeMemoryAccess();\n@@ -391,1 +595,6 @@\n-    \/** @see #putByte(long, byte) *\/\n+    \/**\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n+     * @see #putByte(long, byte)\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -394,0 +603,1 @@\n+        beforeMemoryAccess();\n@@ -410,0 +620,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -412,0 +624,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -414,0 +627,1 @@\n+        beforeMemoryAccess();\n@@ -425,0 +639,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to access off-heap memory.\n+     *\n@@ -427,0 +643,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -429,0 +646,1 @@\n+        beforeMemoryAccess();\n@@ -452,0 +670,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to allocate off-heap memory.\n+     *\n@@ -460,0 +680,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -462,0 +683,1 @@\n+        beforeMemoryAccess();\n@@ -484,0 +706,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to allocate off-heap memory.\n+     *\n@@ -491,0 +715,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -493,0 +718,1 @@\n+        beforeMemoryAccess();\n@@ -520,0 +746,3 @@\n+     * @deprecated {@link MemorySegment#fill(byte)} fills the contents of a memory\n+     * segment with a given value.\n+     *\n@@ -524,0 +753,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -526,0 +756,1 @@\n+        beforeMemoryAccess();\n@@ -535,0 +766,5 @@\n+     *\n+     * @deprecated {@link MemorySegment#fill(byte)} fills the contents of a memory\n+     * segment with a given value.\n+     *\n+     * Use {@link MemorySegment} and its bulk copy methods instead.\n@@ -536,0 +772,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -538,0 +775,1 @@\n+        beforeMemoryAccess();\n@@ -565,0 +803,2 @@\n+     * @deprecated Use {@link MemorySegment} and its bulk copy methods instead.\n+     *\n@@ -569,0 +809,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -573,0 +814,1 @@\n+        beforeMemoryAccess();\n@@ -582,0 +824,2 @@\n+     *\n+     * @deprecated Use {@link MemorySegment} and its bulk copy methods instead.\n@@ -583,0 +827,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -585,0 +830,1 @@\n+        beforeMemoryAccess();\n@@ -602,0 +848,2 @@\n+     * @deprecated Use {@link java.lang.foreign} to allocate and free off-heap memory.\n+     *\n@@ -606,0 +854,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -608,0 +857,1 @@\n+        beforeMemoryAccess();\n@@ -617,0 +867,1 @@\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n@@ -618,0 +869,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -640,1 +892,1 @@\n-     * in a future release. Use {@link java.lang.invoke.VarHandle} instead.\n+     * in a future release. Use {@link VarHandle} instead.\n@@ -644,1 +896,1 @@\n-    @Deprecated(since=\"18\")\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -661,0 +913,1 @@\n+        beforeMemoryAccess();\n@@ -683,1 +936,1 @@\n-     * in a future release. Use {@link java.lang.invoke.VarHandle} instead.\n+     * in a future release. Use {@link VarHandle} instead.\n@@ -687,1 +940,1 @@\n-    @Deprecated(since=\"18\")\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -704,0 +957,1 @@\n+        beforeMemoryAccess();\n@@ -720,1 +974,1 @@\n-     * in a future release. Use {@link java.lang.invoke.VarHandle} instead.\n+     * in a future release. Use {@link VarHandle} instead.\n@@ -722,1 +976,1 @@\n-    @Deprecated(since=\"18\")\n+    @Deprecated(since=\"18\", forRemoval=true)\n@@ -739,0 +993,1 @@\n+        beforeMemoryAccess();\n@@ -749,0 +1004,2 @@\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\n@@ -752,0 +1009,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -754,0 +1012,1 @@\n+        beforeMemoryAccess();\n@@ -757,1 +1016,5 @@\n-    \/** The value of {@code arrayBaseOffset(boolean[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(boolean[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -760,1 +1023,5 @@\n-    \/** The value of {@code arrayBaseOffset(byte[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(byte[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -763,1 +1030,5 @@\n-    \/** The value of {@code arrayBaseOffset(short[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(short[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -766,1 +1037,5 @@\n-    \/** The value of {@code arrayBaseOffset(char[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(char[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -769,1 +1044,5 @@\n-    \/** The value of {@code arrayBaseOffset(int[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(int[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -772,1 +1051,5 @@\n-    \/** The value of {@code arrayBaseOffset(long[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(long[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -775,1 +1058,5 @@\n-    \/** The value of {@code arrayBaseOffset(float[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(float[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -778,1 +1065,5 @@\n-    \/** The value of {@code arrayBaseOffset(double[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(double[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -781,1 +1072,5 @@\n-    \/** The value of {@code arrayBaseOffset(Object[].class)} *\/\n+    \/** The value of {@code arrayBaseOffset(Object[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -791,0 +1086,2 @@\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\n@@ -795,0 +1092,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -800,1 +1098,5 @@\n-    \/** The value of {@code arrayIndexScale(boolean[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(boolean[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -803,1 +1105,5 @@\n-    \/** The value of {@code arrayIndexScale(byte[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(byte[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -806,1 +1112,5 @@\n-    \/** The value of {@code arrayIndexScale(short[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(short[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -809,1 +1119,5 @@\n-    \/** The value of {@code arrayIndexScale(char[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(char[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -812,1 +1126,5 @@\n-    \/** The value of {@code arrayIndexScale(int[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(int[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -815,1 +1133,5 @@\n-    \/** The value of {@code arrayIndexScale(long[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(long[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -818,1 +1140,5 @@\n-    \/** The value of {@code arrayIndexScale(float[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(float[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -821,1 +1147,5 @@\n-    \/** The value of {@code arrayIndexScale(double[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(double[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -824,1 +1154,5 @@\n-    \/** The value of {@code arrayIndexScale(Object[].class)} *\/\n+    \/** The value of {@code arrayIndexScale(Object[].class)}.\n+     *\n+     * @deprecated Not needed when using {@link VarHandle} or {@link java.lang.foreign}.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -832,0 +1166,2 @@\n+     *\n+     * @deprecated Use {@link ValueLayout#ADDRESS}.{@link MemoryLayout#byteSize()} instead.\n@@ -833,0 +1169,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -838,1 +1175,5 @@\n-    \/** The value of {@code addressSize()} *\/\n+    \/** The value of {@code addressSize()}.\n+     *\n+     * @deprecated Use {@link ValueLayout#ADDRESS}.{@link MemoryLayout#byteSize()} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -877,0 +1218,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#compareAndExchange(Object...)} instead.\n@@ -878,0 +1221,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -882,0 +1226,1 @@\n+        beforeMemoryAccess();\n@@ -893,0 +1238,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#compareAndExchange(Object...)} instead.\n@@ -894,0 +1241,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -898,0 +1246,1 @@\n+        beforeMemoryAccess();\n@@ -909,0 +1258,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#compareAndExchange(Object...)} instead.\n@@ -910,0 +1261,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -914,0 +1266,1 @@\n+        beforeMemoryAccess();\n@@ -920,0 +1273,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n@@ -921,0 +1276,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -923,0 +1279,1 @@\n+        beforeMemoryAccess();\n@@ -929,0 +1286,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n@@ -930,0 +1289,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -932,0 +1292,1 @@\n+        beforeMemoryAccess();\n@@ -935,1 +1296,5 @@\n-    \/** Volatile version of {@link #getInt(Object, long)}  *\/\n+    \/** Volatile version of {@link #getInt(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -938,0 +1303,1 @@\n+        beforeMemoryAccess();\n@@ -941,1 +1307,5 @@\n-    \/** Volatile version of {@link #putInt(Object, long, int)}  *\/\n+    \/** Volatile version of {@link #putInt(Object, long, int)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -944,0 +1314,1 @@\n+        beforeMemoryAccess();\n@@ -947,1 +1318,5 @@\n-    \/** Volatile version of {@link #getBoolean(Object, long)}  *\/\n+    \/** Volatile version of {@link #getBoolean(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -950,0 +1325,1 @@\n+        beforeMemoryAccess();\n@@ -953,1 +1329,5 @@\n-    \/** Volatile version of {@link #putBoolean(Object, long, boolean)}  *\/\n+    \/** Volatile version of {@link #putBoolean(Object, long, boolean)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -956,0 +1336,1 @@\n+        beforeMemoryAccess();\n@@ -959,1 +1340,6 @@\n-    \/** Volatile version of {@link #getByte(Object, long)}  *\/\n+    \/** Volatile version of {@link #getByte(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)}\n+     * instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -962,0 +1348,1 @@\n+        beforeMemoryAccess();\n@@ -965,1 +1352,5 @@\n-    \/** Volatile version of {@link #putByte(Object, long, byte)}  *\/\n+    \/** Volatile version of {@link #putByte(Object, long, byte)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -968,0 +1359,1 @@\n+        beforeMemoryAccess();\n@@ -971,1 +1363,5 @@\n-    \/** Volatile version of {@link #getShort(Object, long)}  *\/\n+    \/** Volatile version of {@link #getShort(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -974,0 +1370,1 @@\n+        beforeMemoryAccess();\n@@ -977,1 +1374,5 @@\n-    \/** Volatile version of {@link #putShort(Object, long, short)}  *\/\n+    \/** Volatile version of {@link #putShort(Object, long, short)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -980,0 +1381,1 @@\n+        beforeMemoryAccess();\n@@ -983,1 +1385,5 @@\n-    \/** Volatile version of {@link #getChar(Object, long)}  *\/\n+    \/** Volatile version of {@link #getChar(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -986,0 +1392,1 @@\n+        beforeMemoryAccess();\n@@ -989,1 +1396,5 @@\n-    \/** Volatile version of {@link #putChar(Object, long, char)}  *\/\n+    \/** Volatile version of {@link #putChar(Object, long, char)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -992,0 +1403,1 @@\n+        beforeMemoryAccess();\n@@ -995,1 +1407,5 @@\n-    \/** Volatile version of {@link #getLong(Object, long)}  *\/\n+    \/** Volatile version of {@link #getLong(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -998,0 +1414,1 @@\n+        beforeMemoryAccess();\n@@ -1001,1 +1418,5 @@\n-    \/** Volatile version of {@link #putLong(Object, long, long)}  *\/\n+    \/** Volatile version of {@link #putLong(Object, long, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1004,0 +1425,1 @@\n+        beforeMemoryAccess();\n@@ -1007,1 +1429,5 @@\n-    \/** Volatile version of {@link #getFloat(Object, long)}  *\/\n+    \/** Volatile version of {@link #getFloat(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1010,0 +1436,1 @@\n+        beforeMemoryAccess();\n@@ -1013,1 +1440,5 @@\n-    \/** Volatile version of {@link #putFloat(Object, long, float)}  *\/\n+    \/** Volatile version of {@link #putFloat(Object, long, float)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1016,0 +1447,1 @@\n+        beforeMemoryAccess();\n@@ -1019,1 +1451,5 @@\n-    \/** Volatile version of {@link #getDouble(Object, long)}  *\/\n+    \/** Volatile version of {@link #getDouble(Object, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#getVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1022,0 +1458,1 @@\n+        beforeMemoryAccess();\n@@ -1025,1 +1462,5 @@\n-    \/** Volatile version of {@link #putDouble(Object, long, double)}  *\/\n+    \/** Volatile version of {@link #putDouble(Object, long, double)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setVolatile(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1028,0 +1469,1 @@\n+        beforeMemoryAccess();\n@@ -1039,0 +1481,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#setRelease(Object...)} instead.\n@@ -1040,0 +1484,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1042,0 +1487,1 @@\n+        beforeMemoryAccess();\n@@ -1045,1 +1491,5 @@\n-    \/** Ordered\/Lazy version of {@link #putIntVolatile(Object, long, int)}  *\/\n+    \/** Ordered\/Lazy version of {@link #putIntVolatile(Object, long, int)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setRelease(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1048,0 +1498,1 @@\n+        beforeMemoryAccess();\n@@ -1051,1 +1502,5 @@\n-    \/** Ordered\/Lazy version of {@link #putLongVolatile(Object, long, long)} *\/\n+    \/** Ordered\/Lazy version of {@link #putLongVolatile(Object, long, long)}.\n+     *\n+     * @deprecated Use {@link VarHandle#setRelease(Object...)} instead.\n+     *\/\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1054,0 +1509,1 @@\n+        beforeMemoryAccess();\n@@ -1112,1 +1568,1 @@\n-     * @deprecated Use {@link java.lang.management.OperatingSystemMXBean#getSystemLoadAverage()}\n+     * @deprecated Use {@link java.management\/java.lang.management.OperatingSystemMXBean#getSystemLoadAverage()}\n@@ -1115,0 +1571,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -1134,0 +1591,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1135,0 +1594,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1137,0 +1597,1 @@\n+        beforeMemoryAccess();\n@@ -1150,0 +1611,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1151,0 +1614,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1153,0 +1617,1 @@\n+        beforeMemoryAccess();\n@@ -1166,0 +1631,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1167,0 +1634,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1169,0 +1637,1 @@\n+        beforeMemoryAccess();\n@@ -1182,0 +1651,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1183,0 +1654,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1185,0 +1657,1 @@\n+        beforeMemoryAccess();\n@@ -1198,0 +1671,2 @@\n+     *\n+     * @deprecated Use {@link VarHandle#getAndAdd(Object...)} instead.\n@@ -1199,0 +1674,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1201,0 +1677,1 @@\n+        beforeMemoryAccess();\n@@ -1215,1 +1692,1 @@\n-     * @deprecated Use {@link java.lang.invoke.VarHandle#acquireFence()} instead.\n+     * @deprecated Use {@link VarHandle#acquireFence()} instead.\n@@ -1235,1 +1712,1 @@\n-     * @deprecated Use {@link java.lang.invoke.VarHandle#releaseFence()} instead.\n+     * @deprecated Use {@link VarHandle#releaseFence()} instead.\n@@ -1252,1 +1729,1 @@\n-     * @deprecated Use {@link java.lang.invoke.VarHandle#fullFence()} instead.\n+     * @deprecated Use {@link VarHandle#fullFence()} instead.\n@@ -1269,0 +1746,6 @@\n+     *\n+     * @deprecated Use a {@link MemorySegment} allocated in an {@link Arena} with the\n+     * appropriate temporal bounds. The {@link MemorySegment#asByteBuffer()} method\n+     * wraps a memory segment as a {@code ByteBuffer} to allow interop with existing\n+     * code.\n+     *\n@@ -1271,0 +1754,1 @@\n+    @Deprecated(since=\"23\", forRemoval=true)\n@@ -1273,2 +1757,2 @@\n-            throw new IllegalArgumentException(\"buffer is non-direct\");\n-\n+            throw new IllegalArgumentException(\"Not a direct buffer\");\n+        beforeMemoryAccess();\n@@ -1277,0 +1761,188 @@\n+\n+    \/\/ Infrastructure for --sun-misc-unsafe-memory-access=<value> command line option.\n+\n+    private static final Object MEMORY_ACCESS_WARNED_BASE;\n+    private static final long MEMORY_ACCESS_WARNED_OFFSET;\n+    static {\n+        try {\n+            Field field = Unsafe.class.getDeclaredField(\"memoryAccessWarned\");\n+            MEMORY_ACCESS_WARNED_BASE = theInternalUnsafe.staticFieldBase(field);\n+            MEMORY_ACCESS_WARNED_OFFSET = theInternalUnsafe.staticFieldOffset(field);\n+        } catch (Exception e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+    \/\/ set to true by first usage of memory-access method\n+    private static @Stable boolean memoryAccessWarned;\n+\n+    private static boolean isMemoryAccessWarned() {\n+        return theInternalUnsafe.getBooleanVolatile(MEMORY_ACCESS_WARNED_BASE, MEMORY_ACCESS_WARNED_OFFSET);\n+    }\n+\n+    private static boolean trySetMemoryAccessWarned() {\n+        return theInternalUnsafe.compareAndSetBoolean(MEMORY_ACCESS_WARNED_BASE, MEMORY_ACCESS_WARNED_OFFSET, false, true);\n+    }\n+\n+    private static final MemoryAccessOption MEMORY_ACCESS_OPTION = MemoryAccessOption.value();\n+\n+    \/**\n+     * Invoked by all memory-access methods.\n+     *\/\n+    @ForceInline\n+    private static void beforeMemoryAccess() {\n+        if (MEMORY_ACCESS_OPTION == MemoryAccessOption.ALLOW) {\n+            return;\n+        }\n+\n+        if (MEMORY_ACCESS_OPTION == MemoryAccessOption.WARN && isMemoryAccessWarned()) {\n+            \/\/ nothing to do if this is not the first usage\n+            return;\n+        }\n+\n+        \/\/ warn && first usage, debug, or deny\n+        beforeMemoryAccessSlow();\n+    }\n+\n+    private static void beforeMemoryAccessSlow() {\n+        assert MEMORY_ACCESS_OPTION != MemoryAccessOption.ALLOW;\n+\n+        \/\/ stack trace without the frames for the beforeMemoryAccess methods\n+        List<StackWalker.StackFrame> stack = StackWalkerHolder.INSTANCE.walk(s ->\n+                s.dropWhile(f -> (f.getDeclaringClass() == Unsafe.class)\n+                                && f.getMethodName().startsWith(\"beforeMemoryAccess\"))\n+                    .limit(32)\n+                    .toList()\n+        );\n+\n+        \/\/ callerClass -> Unsafe.methodName\n+        String methodName = stack.get(0).getMethodName();\n+        Class<?> callerClass = stack.get(1).getDeclaringClass();\n+\n+        switch (MEMORY_ACCESS_OPTION) {\n+            case WARN -> {\n+                if (trySetMemoryAccessWarned()) {\n+                    log(multiLineWarning(callerClass, methodName));\n+                }\n+            }\n+            case DEBUG -> {\n+                String warning = singleLineWarning(callerClass, methodName);\n+                StringBuilder sb = new StringBuilder(warning);\n+                stack.stream()\n+                        .skip(1)\n+                        .forEach(f ->\n+                                sb.append(System.lineSeparator()).append(\"\\tat \" + f)\n+                        );\n+                log(sb.toString());\n+            }\n+            case DENY -> {\n+                throw new UnsupportedOperationException(methodName);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Represents the options for the depreacted method-access methods.\n+     *\/\n+    private enum MemoryAccessOption {\n+        \/**\n+         * Allow use of the memory-access methods with no warnings.\n+         *\/\n+        ALLOW,\n+        \/**\n+         * Warning on the first use of a memory-access method.\n+         *\/\n+        WARN,\n+        \/**\n+         * One-line warning and a stack trace on every use of a memory-access method.\n+         *\/\n+        DEBUG,\n+        \/**\n+         * Deny use of the memory-access methods.\n+         *\/\n+        DENY;\n+\n+        private static MemoryAccessOption defaultValue() {\n+            return ALLOW;\n+        }\n+\n+        \/**\n+         * Return the value.\n+         *\/\n+        static MemoryAccessOption value() {\n+            String value = VM.getSavedProperty(\"sun.misc.unsafe.memory.access\");\n+            if (value != null) {\n+                return switch (value) {\n+                    case \"allow\" -> MemoryAccessOption.ALLOW;\n+                    case \"warn\"  -> MemoryAccessOption.WARN;\n+                    case \"debug\" -> MemoryAccessOption.DEBUG;\n+                    case \"deny\"  -> MemoryAccessOption.DENY;\n+                    default -> {\n+                        \/\/ should not happen\n+                        log(\"sun.misc.unsafe.memory.access ignored, value '\" + value +\n+                                \"' is not a recognized value\");\n+                        yield defaultValue();\n+                    }\n+                };\n+            } else {\n+                return defaultValue();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Holder for StackWalker that retains class references.\n+     *\/\n+    private static class StackWalkerHolder {\n+        static final StackWalker INSTANCE;\n+        static {\n+            PrivilegedAction<StackWalker> pa = () ->\n+                    StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            @SuppressWarnings(\"removal\")\n+            StackWalker walker = AccessController.doPrivileged(pa);\n+            INSTANCE = walker;\n+        }\n+    }\n+\n+    \/**\n+     * Return the multi-line warning message for when the given class invokes the\n+     * given the Unsafe method.\n+     *\/\n+    private static String multiLineWarning(Class<?> callerClass, String methodName) {\n+        return String.format(\n+                \"\"\"\n+                WARNING: A terminally deprecated method in sun.misc.Unsafe has been called\n+                WARNING: sun.misc.Unsafe::%s has been called by %s\n+                WARNING: Please consider reporting this to the maintainers of %s\n+                WARNING: sun.misc.Unsafe::%s will be removed in a future release\"\"\",\n+                methodName, callerAndLocation(callerClass), callerClass, methodName);\n+    }\n+\n+    \/**\n+     * Return the single-line warning message for when the given class invokes the\n+     * given the Unsafe method.\n+     *\/\n+    private static String singleLineWarning(Class<?> callerClass, String methodName) {\n+        return String.format(\"WARNING: sun.misc.Unsafe::%s called by %s\",\n+                methodName, callerAndLocation(callerClass));\n+    }\n+\n+    \/**\n+     * Returns a string with the caller class and the location URL from the CodeSource.\n+     *\/\n+    private static String callerAndLocation(Class<?> callerClass) {\n+        PrivilegedAction<ProtectionDomain> pa = callerClass::getProtectionDomain;\n+        @SuppressWarnings(\"removal\")\n+        CodeSource cs = AccessController.doPrivileged(pa).getCodeSource();\n+        String who = callerClass.getName();\n+        if (cs != null && cs.getLocation() != null) {\n+            who += \" (\" + cs.getLocation() + \")\";\n+        }\n+        return who;\n+    }\n+\n+    \/**\n+     * Prints the given message to the standard error.\n+     *\/\n+    private static void log(String message) {\n+        VM.initialErr().println(message);\n+    }\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":753,"deletions":81,"binary":false,"changes":834,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+compiler\/codecache\/CodeCacheFullCountTest.java 8332954 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -763,0 +763,5 @@\n+    public static final String LOAD_VECTOR_MASKED = PREFIX + \"LOAD_VECTOR_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_VECTOR_MASKED, \"LoadVectorMasked\");\n+    }\n+\n@@ -1487,0 +1492,5 @@\n+    public static final String STORE_VECTOR_MASKED = PREFIX + \"STORE_VECTOR_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR_MASKED, \"StoreVectorMasked\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8235369 8235550 8247444 8326879\n+ * @bug 8235369 8235550 8247444 8326879 8320575\n@@ -28,0 +28,1 @@\n+ * @build R10\n@@ -61,0 +62,21 @@\n+    record R9(List<String> ls) {\n+        R9 {} \/\/ compact constructor, will contain a mandated parameter\n+    }\n+\n+    \/* record R10 is defined in an accompaning jcod file, defined as:\n+    record R10(List<String> ls) { \/\/ in this case there wasn't be any compact constructor and thus no mandated param\n+    }\n+    *\/\n+\n+    record R11(int i, List<String> ls) {\n+        R11 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R12(List<String> ls, int i) {\n+        R12 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R13(List<String> ls1, int i, List<String> ls2) {\n+        R13 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n@@ -70,2 +92,7 @@\n-                       R8.class)\n-                   .stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n+                       R8.class,\n+                       R9.class,\n+                       R10.class,\n+                       R11.class,\n+                       R12.class,\n+                       R13.class\n+        ).stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n@@ -128,0 +155,28 @@\n+            new Object[] { new R9(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            \/* R10 has exactly the same definition as R9 but the parameter of the compact constructor doesn't have\n+             * the mandated flag, nevertheless we should be able to load the same generic information\n+             *\/\n+            new Object[] { new R10(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R11(1, List.of(\"1\")),\n+                        2,\n+                        new Object[]{ 1, List.of(\"1\") },\n+                        new String[]{ \"i\", \"ls\" },\n+                        new String[]{ \"int\", \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R12(List.of(\"1\"), 1),\n+                        2,\n+                        new Object[]{ List.of(\"1\"), 1 },\n+                        new String[]{ \"ls\", \"i\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\"} },\n+            new Object[] { new R13(List.of(\"1\"), 1, List.of(\"2\")),\n+                        3,\n+                        new Object[]{ List.of(\"1\"), 1, List.of(\"2\") },\n+                        new String[]{ \"ls1\", \"i\", \"ls2\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\", \"java.util.List<java.lang.String>\"} },\n@@ -153,0 +208,17 @@\n+        \/\/ now let's check constructors\n+        var constructor = recordClass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for (var p: constructor.getParameters()) {\n+            assertEquals(p.getParameterizedType().toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), signatures[i]));\n+            i++;\n+        }\n+        \/\/ similar as above but testing another API\n+        i = 0;\n+        for (var p : constructor.getGenericParameterTypes()) {\n+            assertEquals(p.toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.toString(), signatures[i]));\n+            i++;\n+        }\n@@ -205,1 +277,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":76,"deletions":5,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                                                com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(cob4::with);\n+                                                com.findAttribute(Attributes.stackMapTable()).ifPresent(cob4::with);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+    private static final String GC_PREFIX = \"-XX:+Use\";\n+    private static final String GC_SUFFIX = \"GC\";\n+\n@@ -351,2 +354,0 @@\n-        String GC_PREFIX  = \"-XX:+Use\";\n-        String GC_SUFFIX  = \"GC\";\n@@ -466,1 +467,25 @@\n-        return \"\" + (\"true\".equals(vmCDS()) && WB.canWriteJavaHeapArchive());\n+        return \"\" + (\"true\".equals(vmCDS()) && WB.canWriteJavaHeapArchive()\n+                     && isCDSRuntimeOptionsCompatible());\n+    }\n+\n+    \/**\n+     * @return true if the VM options specified via the \"test.cds.runtime.options\"\n+     * property is compatible with writing Java heap objects into the CDS archive\n+     *\/\n+    protected boolean isCDSRuntimeOptionsCompatible() {\n+        String jtropts = System.getProperty(\"test.cds.runtime.options\");\n+        if (jtropts == null) {\n+            return true;\n+        }\n+        String CCP_DISABLED = \"-XX:-UseCompressedClassPointers\";\n+        String G1GC_ENABLED = \"-XX:+UseG1GC\";\n+        for (String opt : jtropts.split(\",\")) {\n+            if (opt.equals(CCP_DISABLED)) {\n+                return false;\n+            }\n+            if (opt.startsWith(GC_PREFIX) && opt.endsWith(GC_SUFFIX) &&\n+                !opt.equals(G1GC_ENABLED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-        InnerClassesAttribute inners = classFile.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+        InnerClassesAttribute inners = classFile.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousClassFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n- * @bug 8324873\n- * @summary [lworld] implementation of value classes construction\n+ * @bug 8324873 8325805\n+ * @summary Permit non-superclass instance field assignments before this\/super in constructors\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DA_DUConstructors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14,3 +14,7 @@\n-SuperInitFails.java:154:9: compiler.err.cant.ref.before.ctor.called: this\n-SuperInitFails.java:165:31: compiler.err.cant.ref.before.ctor.called: x\n-SuperInitFails.java:169:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:155:31: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:159:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:168:13: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:172:17: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:176:24: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:180:18: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:186:28: compiler.err.cant.ref.before.ctor.called: this\n@@ -25,1 +29,1 @@\n-SuperInitFails.java:160:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:150:18: compiler.err.ctor.calls.not.allowed.here\n@@ -28,1 +32,1 @@\n-25 errors\n+30 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -411,0 +411,48 @@\n+    \/\/ we allow 'this' reference prior to super() for field assignments only\n+    public static class Test20 {\n+        private int x;\n+        public Test20(short x) {\n+            x = x;\n+            super();\n+        }\n+        public Test20(int x) {\n+            this.x = x;\n+            super();\n+        }\n+        public Test20(char x) {\n+            Test20.this.x = x;\n+            super();\n+        }\n+        public Test20(byte y) {\n+            x = y;\n+            this((int)y);\n+            this.x++;\n+        }\n+    }\n+\n+    \/\/ allow creating and using local and anonymous classes before super()\n+    \/\/ they will not have enclosing instances though\n+    public static class Test21 {\n+        public Test21(int x) {\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    this.hashCode();\n+                }\n+            };\n+            r.run();\n+            super();\n+            r.run();\n+        }\n+        public Test21(float x) {\n+            class Foo {\n+                public void bar() {\n+                    this.hashCode();\n+                }\n+            };\n+            new Foo().bar();\n+            super();\n+            new Foo().bar();\n+        }\n+    }\n+\n+\n@@ -452,0 +500,3 @@\n+        new Test20(123);\n+        new Test21((int)123);\n+        new Test21((float)123);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-            CodeAttribute code = test_method.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute code = test_method.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/T7093325.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                EnclosingMethodAttribute encl = cf.findAttribute(Attributes.ENCLOSING_METHOD).orElse(null);\n+                EnclosingMethodAttribute encl = cf.findAttribute(Attributes.enclosingMethod()).orElse(null);\n@@ -62,1 +62,1 @@\n-            InnerClassesAttribute attr = cf.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+            InnerClassesAttribute attr = cf.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/InnerClasses\/SyntheticClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-            InnerClassesAttribute innerClasses = cm.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+            InnerClassesAttribute innerClasses = cm.findAttribute(Attributes.innerClasses()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-compiler.warn.is.preview                                # difficult to produce reliably despite future changes to java.base\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n@@ -246,1 +246,1 @@\n-            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            BootstrapMethodsAttribute bsm_attr = cf.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n@@ -248,1 +248,1 @@\n-            BootstrapMethodsAttribute bsm_attr = cm.findAttribute(Attributes.BOOTSTRAP_METHODS).orElseThrow();\n+            BootstrapMethodsAttribute bsm_attr = cm.findAttribute(Attributes.bootstrapMethods()).orElseThrow();\n","filename":"test\/langtools\/tools\/javac\/lambda\/bytecode\/TestLambdaBytecodeTargetRelease14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -747,2 +747,2 @@\n-            byte[] newBytes = ClassFile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof Attributes)\n-                    .andThen(ClassTransform.endHandler(classBuilder -> classBuilder.with(newAttr))));\n+            byte[] newBytes = ClassFile.of().transform(cf,\n+                    ClassTransform.endHandler(classBuilder -> classBuilder.with(newAttr)));\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,4 @@\n+            \/\/ Temporarily ignore java.io.IO:\n+            if (f.getName().equals(\"ioType\"))\n+                continue;\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/TestSymtabItems.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-            CodeAttribute ea = testMethod.findAttribute(Attributes.CODE).orElse(null);\n+            CodeAttribute ea = testMethod.findAttribute(Attributes.code()).orElse(null);\n","filename":"test\/langtools\/tools\/javac\/varargs\/7042566\/T7042566.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}