{"files":[{"patch":"@@ -55,5 +55,1 @@\n-    \/\/ The following flags are designed to be additive (hence \"has-resources\"\n-    \/\/ rather than \"is-empty\", even though \"isEmpty()\" is whats in the API).\n-    \/\/ API methods like \"isEmpty()\" and \"hasPreviewVersion()\" are designed to\n-    \/\/ match the semantics of ImageLocation flags to avoid having business\n-    \/\/ logic need to reason about two different flag regimes.\n+    \/\/ The following flags are designed to be additive.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ModuleReference.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-     * {@code \"java.base\"} entry will be marked as non-empty.\n+     * {@code \"java.base\"} entry will be marked as having content.\n@@ -133,3 +133,2 @@\n-     * <p>For preview mode however, a package that's empty in non-preview mode\n-     * can be non-empty in preview mode. Furthermore, packages which only exist\n-     * in preview mode (empty or not) need to be ignored in non-preview mode.\n+     * <p>When processing module references in non-preview mode, entries marked\n+     * as {@link ModuleReference#isPreviewOnly() preview-only} must be ignored.\n@@ -137,23 +136,3 @@\n-     * <p>To account for this, the following flags are used for each module\n-     * reference in a package node:\n-     * <ul>\n-     *     <li>{@code HAS_NORMAL_CONTENT}: Packages with resources in normal\n-     *     mode. At most one entry will have this flag set.\n-     *     <li>{@code HAS_PREVIEW_CONTENT}: Packages with resources in preview\n-     *     mode. At most one entry will have this flag set.\n-     *     <li>{@code IS_PREVIEW_ONLY}: This is set for packages, empty\n-     *     or not, which exist only in preview mode.\n-     * <\/ul>\n-     *\n-     * <p>While there are 8 combinations of these 3 flags, some will never\n-     * occur (e.g. {@code HAS_NORMAL_CONTENT + IS_PREVIEW_ONLY}).\n-     *\n-     * <p>Package node entries are sorted by name, with the exception that (if\n-     * it exists) the unique entry marked as having content will be listed first.\n-     *\n-     * <p>When processing entries in normal (non preview) mode, entries marked\n-     * with {@code IS_PREVIEW_ONLY} must be ignored. If, after filtering, there\n-     * are no entries left, then the entire package must be ignored.\n-     *\n-     * <p>After this, in either mode, the content flag(s) of the first entry\n-     * determine if that module contains resources for the package.\n+     * <p>If all entries in a package are preview-only, then the package's flags\n+     * have {@link ImageLocation#FLAGS_IS_PREVIEW_ONLY FLAGS_IS_PREVIEW_ONLY}\n+     * set, and the entire package must be ignored.\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageResourcesTree.java","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit\/othervm jdk.jlink\/jdk.tools.jlink.internal.ImageResourcesTreeTest\n+ * @run junit\/othervm -ea -esa jdk.jlink\/jdk.tools.jlink.internal.ImageResourcesTreeTest\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/ImageResourcesTreeTestDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.internal.jimage.ModuleReference;\n@@ -28,1 +29,0 @@\n-import jdk.tools.jlink.internal.ImageResourcesTree.PackageNode.PackageReference;\n@@ -49,5 +49,0 @@\n-    \/\/ Package entry flags copied from ImageResourcesTree.\n-    private static final int PKG_FLAG_HAS_NORMAL_CONTENT = 0x1;\n-    private static final int PKG_FLAG_HAS_PREVIEW_CONTENT = 0x2;\n-    private static final int PKG_FLAG_IS_PREVIEW_ONLY = 0x4;\n-\n@@ -142,2 +137,2 @@\n-        assertEquals(2, pkgUtil.moduleCount());\n-        List<PackageReference> modRefs = pkgUtil.modules().toList();\n+        List<ModuleReference> modRefs = pkgUtil.getModuleReferences();\n+        assertEquals(2, modRefs.size());\n@@ -145,1 +140,1 @@\n-        List<String> modNames = modRefs.stream().map(PackageReference::name).toList();\n+        List<String> modNames = modRefs.stream().map(ModuleReference::name).toList();\n@@ -148,7 +143,3 @@\n-        PackageReference baseRef = modRefs.get(0);\n-        assertNonEmptyRef(baseRef, \"java.base\");\n-        assertEquals(PKG_FLAG_HAS_NORMAL_CONTENT, baseRef.flags());\n-\n-        PackageReference loggingRef = modRefs.get(1);\n-        assertEmptyRef(loggingRef, \"java.logging\");\n-        assertEquals(0, loggingRef.flags());\n+        \/\/ Ordered by name.\n+        assertNonEmptyRef(modRefs.get(0), \"java.base\");\n+        assertEmptyRef(modRefs.get(1), \"java.logging\");\n@@ -168,1 +159,1 @@\n-        List<PackageReference> modRefs = pkgUtil.modules().toList();\n+        List<ModuleReference> modRefs = pkgUtil.getModuleReferences();\n@@ -170,1 +161,1 @@\n-        PackageReference baseRef = modRefs.get(0);\n+        ModuleReference baseRef = modRefs.get(0);\n@@ -172,1 +163,1 @@\n-        assertEquals(PKG_FLAG_HAS_NORMAL_CONTENT | PKG_FLAG_HAS_PREVIEW_CONTENT, baseRef.flags());\n+        assertTrue(baseRef.hasPreviewVersion());\n@@ -186,1 +177,1 @@\n-        PackageReference nonEmptyRef = nonEmptyPkg.modules().findFirst().orElseThrow();\n+        ModuleReference nonEmptyRef = nonEmptyPkg.getModuleReferences().getFirst();\n@@ -188,1 +179,0 @@\n-        assertEquals(PKG_FLAG_IS_PREVIEW_ONLY | PKG_FLAG_HAS_PREVIEW_CONTENT, nonEmptyRef.flags());\n@@ -192,1 +182,1 @@\n-        PackageReference emptyRef = emptyPkg.modules().findFirst().orElseThrow();\n+        ModuleReference emptyRef = emptyPkg.getModuleReferences().getFirst();\n@@ -194,1 +184,0 @@\n-        assertEquals(PKG_FLAG_IS_PREVIEW_ONLY, emptyRef.flags());\n@@ -198,3 +187,3 @@\n-    public void expectedPackageEntries_sharedPackage() {\n-        \/\/ Resource in many modules define the same package (java.shared).\n-        \/\/ However, the package \"java.shared\" only has content in one module.\n+    public void expectedPackageOrder_sharedPackage() {\n+        \/\/ Resource in many modules define the same package (java.shared), but\n+        \/\/ this only has content in one module (java.content).\n@@ -202,3 +191,3 @@\n-        \/\/ \"java.preview\" would sort before after \"java.resource\" if it were\n-        \/\/ only sorted by name, but the preview flag has precedence.\n-        \/\/ Expect: content -> resource{1..6} -> preview{7..8}\n+        \/\/ \"java.moduleN\" would sort before after \"java.previewN\" if it were\n+        \/\/ only sorted by name, but preview entries come first.\n+        \/\/ Expect: preview{1..3) -> content -> module{1..3}\n@@ -206,6 +195,1 @@\n-                \"\/java.resource1\/java\/shared\/one\/SomeClass.class\",\n-                \"\/java.preview7\/META-INF\/preview\/java\/shared\/foo\/SomeClass.class\",\n-                \"\/java.resource3\/java\/shared\/three\/SomeClass.class\",\n-                \"\/java.resource6\/java\/shared\/six\/SomeClass.class\",\n-                \"\/java.preview8\/META-INF\/preview\/java\/shared\/bar\/SomeClass.class\",\n-                \"\/java.resource5\/java\/shared\/five\/SomeClass.class\",\n+                \/\/ Module with content in \"java.shared\".\n@@ -213,2 +197,8 @@\n-                \"\/java.resource2\/java\/shared\/two\/SomeClass.class\",\n-                \"\/java.resource4\/java\/shared\/four\/SomeClass.class\");\n+                \/\/ Other resources (in other modules) which implicitly define \"java.shared\".\n+                \"\/java.module3\/java\/shared\/three\/SomeClass.class\",\n+                \"\/java.module2\/java\/shared\/two\/SomeClass.class\",\n+                \"\/java.module1\/java\/shared\/one\/SomeClass.class\",\n+                \/\/ Preview resources in other modules which implicitly define \"java.shared\".\n+                \"\/java.preview3\/META-INF\/preview\/java\/shared\/baz\/SomeClass.class\",\n+                \"\/java.preview2\/META-INF\/preview\/java\/shared\/bar\/SomeClass.class\",\n+                \"\/java.preview1\/META-INF\/preview\/java\/shared\/foo\/SomeClass.class\");\n@@ -219,1 +209,0 @@\n-        \/\/ Preview only package (with content).\n@@ -221,5 +210,1 @@\n-        assertEquals(9, sharedPkg.moduleCount());\n-\n-        List<PackageReference> refs = sharedPkg.modules().toList();\n-        assertNonEmptyRef(refs.getFirst(), \"java.content\");\n-        assertEquals(PKG_FLAG_HAS_NORMAL_CONTENT, refs.getFirst().flags());\n+        List<ModuleReference> refs = sharedPkg.getModuleReferences();\n@@ -227,5 +212,4 @@\n-        \/\/ Empty non-preview refs after non-empty ref.\n-        int idx = 1;\n-        for (PackageReference emptyRef : refs.subList(1, 7)) {\n-            assertEmptyRef(emptyRef, \"java.resource\" + idx++);\n-            assertEquals(0, emptyRef.flags());\n+        \/\/ Preview packages first, by name.\n+        int n = 1;\n+        for (ModuleReference ref : refs.subList(0, 3)) {\n+            assertEmptyPreviewOnlyRef(ref, \"java.preview\" + (n++));\n@@ -233,4 +217,6 @@\n-        \/\/ Empty preview-only refs last.\n-        for (PackageReference emptyRef : refs.subList(7, 9)) {\n-            assertEmptyPreviewOnlyRef(emptyRef, \"java.preview\" + idx++);\n-            assertEquals(PKG_FLAG_IS_PREVIEW_ONLY, emptyRef.flags());\n+        \/\/ The content package (simply due to its name).\n+        assertNonEmptyRef(refs.get(3), \"java.content\");\n+        \/\/ And the non-preview empty packages after.\n+        n = 1;\n+        for (ModuleReference ref : refs.subList(4, 7)) {\n+            assertEmptyRef(ref, \"java.module\" + (n++));\n@@ -252,1 +238,1 @@\n-    static void assertNonEmptyRef(PackageReference ref, String modName) {\n+    static void assertNonEmptyRef(ModuleReference ref, String modName) {\n@@ -254,1 +240,1 @@\n-        assertFalse(ref.isEmpty(), \"Expected non-empty reference: \" + ref);\n+        assertTrue(ref.hasContent(), \"Expected non-empty reference: \" + ref);\n@@ -258,1 +244,1 @@\n-    static void assertEmptyRef(PackageReference ref, String modName) {\n+    static void assertEmptyRef(ModuleReference ref, String modName) {\n@@ -260,1 +246,1 @@\n-        assertTrue(ref.isEmpty(), \"Expected empty reference: \" + ref);\n+        assertFalse(ref.hasContent(), \"Expected empty reference: \" + ref);\n@@ -264,1 +250,1 @@\n-    static void assertNonEmptyPreviewOnlyRef(PackageReference ref, String modName) {\n+    static void assertNonEmptyPreviewOnlyRef(ModuleReference ref, String modName) {\n@@ -266,1 +252,1 @@\n-        assertFalse(ref.isEmpty(), \"Expected empty reference: \" + ref);\n+        assertTrue(ref.hasContent(), \"Expected empty reference: \" + ref);\n@@ -270,1 +256,1 @@\n-    static void assertEmptyPreviewOnlyRef(PackageReference ref, String modName) {\n+    static void assertEmptyPreviewOnlyRef(ModuleReference ref, String modName) {\n@@ -272,1 +258,1 @@\n-        assertTrue(ref.isEmpty(), \"Expected empty reference: \" + ref);\n+        assertFalse(ref.hasContent(), \"Expected empty reference: \" + ref);\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/jdk.jlink\/jdk\/tools\/jlink\/internal\/ImageResourcesTreeTest.java","additions":46,"deletions":60,"binary":false,"changes":106,"status":"modified"}]}