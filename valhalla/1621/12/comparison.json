{"files":[{"patch":"@@ -32,2 +32,2 @@\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=88b090fa80c6c1d084ec9a755233967458788e2c0777ae2e172230c5c692d7ef\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=59cdcaf255add4721de38eb411d4ecfe779356b61fb671aee63c7dec78054c2b\n@@ -36,2 +36,2 @@\n-ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin24-binaries\/releases\/download\/jdk-24%2B36\/OpenJDK24U-jdk_x64_alpine-linux_hotspot_24_36.tar.gz\n-ALPINE_LINUX_X64_BOOT_JDK_SHA256=a642608f0da78344ee6812fb1490b8bc1d7ad5a18064c70994d6f330568c51cb\n+ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin25-binaries\/releases\/download\/jdk-25%2B36\/OpenJDK25U-jdk_x64_alpine-linux_hotspot_25_36.tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_SHA256=637e47474d411ed86134f413af7d5fef4180ddb0bf556347b7e74a88cf8904c8\n@@ -40,2 +40,2 @@\n-MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_macos-aarch64_bin.tar.gz\n-MACOS_AARCH64_BOOT_JDK_SHA256=f7133238a12714a62c5ad2bd4da6741130be1a82512065da9ca23dee26b2d3d3\n+MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_macos-aarch64_bin.tar.gz\n+MACOS_AARCH64_BOOT_JDK_SHA256=2006337bf326fdfdf6117081751ba38c1c8706d63419ecac7ff102ff7c776876\n@@ -44,2 +44,2 @@\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=6bbfb1d01741cbe55ab90299cb91464b695de9a3ace85c15131aa2f50292f321\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=47482ad9888991ecac9b2bcc131e2b53ff78aff275104cef85f66252308e8a09\n@@ -48,2 +48,2 @@\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=11d1d9f6ac272d5361c8a0bef01894364081c7fb1a6914c2ad2fc312ae83d63b\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=85bcc178461e2cb3c549ab9ca9dfa73afd54c09a175d6510d0884071867137d3\n","filename":"make\/conf\/github-actions.conf","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -390,2 +390,2 @@\n-    common.boot_jdk_version = \"24\";\n-    common.boot_jdk_build_number = \"36\";\n+    common.boot_jdk_version = \"25\";\n+    common.boot_jdk_build_number = \"37\";\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"24 25 26\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"25 26\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1269,2 +1269,2 @@\n-    _ANY_REG32_mask = _ALL_REG32_mask;\n-    _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp->as_VMReg()));\n+    _ANY_REG32_mask.assignFrom(_ALL_REG32_mask);\n+    _ANY_REG32_mask.remove(OptoReg::as_OptoReg(r31_sp->as_VMReg()));\n@@ -1272,1 +1272,1 @@\n-    _ANY_REG_mask = _ALL_REG_mask;\n+    _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n@@ -1274,1 +1274,1 @@\n-    _PTR_REG_mask = _ALL_REG_mask;\n+    _PTR_REG_mask.assignFrom(_ALL_REG_mask);\n@@ -1276,2 +1276,2 @@\n-    _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;\n-    _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);\n+    _NO_SPECIAL_REG32_mask.assignFrom(_ALL_REG32_mask);\n+    _NO_SPECIAL_REG32_mask.subtract(_NON_ALLOCATABLE_REG32_mask);\n@@ -1279,2 +1279,2 @@\n-    _NO_SPECIAL_REG_mask = _ALL_REG_mask;\n-    _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n+    _NO_SPECIAL_REG_mask.assignFrom(_ALL_REG_mask);\n+    _NO_SPECIAL_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n@@ -1282,2 +1282,2 @@\n-    _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;\n-    _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n+    _NO_SPECIAL_PTR_REG_mask.assignFrom(_ALL_REG_mask);\n+    _NO_SPECIAL_PTR_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n@@ -1288,3 +1288,3 @@\n-      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n-      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n-      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n@@ -1295,3 +1295,3 @@\n-      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n-      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n-      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -1300,2 +1300,2 @@\n-    _NO_SPECIAL_NO_RFP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n-    _NO_SPECIAL_NO_RFP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask.assignFrom(_NO_SPECIAL_PTR_REG_mask);\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -1740,1 +1740,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n@@ -2514,1 +2514,1 @@\n-  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ (_NO_SPECIAL_REG32_mask.size() minus 1) forces CallNode to become\n@@ -2517,1 +2517,1 @@\n-  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.size() - 1;\n@@ -2532,1 +2532,1 @@\n-  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.size() : FLOATPRESSURE;\n@@ -2539,1 +2539,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -2541,1 +2541,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2545,1 +2545,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -2547,1 +2547,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2551,1 +2551,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -2553,1 +2553,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2557,1 +2557,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n@@ -2559,1 +2559,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -7084,1 +7084,1 @@\n-                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n@@ -7086,1 +7086,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n@@ -7088,1 +7088,1 @@\n-  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n@@ -7090,0 +7090,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -7091,3 +7092,2 @@\n-                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n-                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n@@ -7098,2 +7098,1 @@\n-instruct vcompressS(vReg dst, vReg src, pReg pg,\n-                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+instruct vcompressS(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n@@ -7105,0 +7104,2 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_dup($tmp1$$FloatRegister, __ H, 0);\n@@ -7106,1 +7107,2 @@\n-                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister, $pgtmp$$PRegister,\n+                          length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -5072,1 +5072,1 @@\n-                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n+                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n@@ -5074,1 +5074,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n@@ -5076,1 +5076,1 @@\n-  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n@@ -5078,0 +5078,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -5079,3 +5080,2 @@\n-                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n-                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister);\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n@@ -5086,2 +5086,1 @@\n-instruct vcompressS(vReg dst, vReg src, pReg pg,\n-                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+instruct vcompressS(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n@@ -5093,0 +5092,2 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ sve_dup($tmp1$$FloatRegister, __ H, 0);\n@@ -5094,1 +5095,2 @@\n-                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n+                          $tmp1$$FloatRegister, $tmp2$$FloatRegister, $pgtmp$$PRegister,\n+                          length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3489,0 +3489,1 @@\n+  INSN(sve_splice,0b00000101, 0b101100100); \/\/ splice two vectors under predicate control, destructive\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2227,1 +2227,1 @@\n-\/\/ Preserves: src, mask\n+\/\/ Preserves: mask, vzr\n@@ -2229,2 +2229,2 @@\n-                                           FloatRegister vtmp1, FloatRegister vtmp2,\n-                                           PRegister pgtmp) {\n+                                           FloatRegister vzr, FloatRegister vtmp,\n+                                           PRegister pgtmp, unsigned vector_length_in_bytes) {\n@@ -2232,1 +2232,3 @@\n-  assert_different_registers(dst, src, vtmp1, vtmp2);\n+  \/\/ When called by sve_compress_byte, src and vtmp may be the same register.\n+  assert_different_registers(dst, src, vzr);\n+  assert_different_registers(dst, vtmp, vzr);\n@@ -2234,5 +2236,4 @@\n-\n-  \/\/ Example input:   src   = 8888 7777 6666 5555 4444 3333 2222 1111\n-  \/\/                  mask  = 0001 0000 0000 0001 0001 0000 0001 0001\n-  \/\/ Expected result: dst   = 0000 0000 0000 8888 5555 4444 2222 1111\n-  sve_dup(vtmp2, H, 0);\n+  \/\/ high <-- low\n+  \/\/ Example input:   src   = hh gg ff ee dd cc bb aa, one character is 8 bits.\n+  \/\/                  mask  = 01 00 00 01 01 00 01 01, one character is 1 bit.\n+  \/\/ Expected result: dst   = 00 00 00 hh ee dd bb aa\n@@ -2241,1 +2242,1 @@\n-  \/\/ dst = 00004444 00003333 00002222 00001111\n+  \/\/ dst   =  00dd  00cc  00bb  00aa\n@@ -2243,1 +2244,1 @@\n-  \/\/ pgtmp = 00000001 00000000 00000001 00000001\n+  \/\/ pgtmp =  0001  0000  0001  0001\n@@ -2247,1 +2248,1 @@\n-  \/\/ dst = 00000000 00004444 00002222 00001111\n+  \/\/ dst   =  0000  00dd  00bb  00aa\n@@ -2250,2 +2251,9 @@\n-  \/\/ dst = 0000 0000 0000 0000 0000 4444 2222 1111\n-  sve_uzp1(dst, H, dst, vtmp2);\n+  \/\/ dst   = 00 00 00 00 00 dd bb aa\n+  sve_uzp1(dst, H, dst, vzr);\n+\n+  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n+  \/\/ highest half is invalid.\n+  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n+    return;\n+  }\n+\n@@ -2257,1 +2265,1 @@\n-  \/\/ pgtmp = 00000001 00000000 00000000 00000001\n+  \/\/ pgtmp =  0001  0000  0000  0001\n@@ -2259,20 +2267,14 @@\n-  \/\/ vtmp1 = 00008888 00007777 00006666 00005555\n-  sve_uunpkhi(vtmp1, S, src);\n-  \/\/ vtmp1 = 00000000 00000000 00008888 00005555\n-  sve_compact(vtmp1, S, vtmp1, pgtmp);\n-  \/\/ vtmp1 = 0000 0000 0000 0000 0000 0000 8888 5555\n-  sve_uzp1(vtmp1, H, vtmp1, vtmp2);\n-\n-  \/\/ Compressed low:   dst   = 0000 0000 0000 0000 0000 4444 2222 1111\n-  \/\/ Compressed high:  vtmp1 = 0000 0000 0000 0000 0000 0000 8888  5555\n-  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n-  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n-  neg(rscratch1, rscratch1);\n-  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n-  sve_index(vtmp2, H, rscratch1, 1);\n-  \/\/ vtmp1 = 0000 0000 0000 8888 5555 0000 0000 0000\n-  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n-\n-  \/\/ Combine the compressed high(after shifted) with the compressed low.\n-  \/\/ dst = 0000 0000 0000 8888 5555 4444 2222 1111\n-  sve_orr(dst, dst, vtmp1);\n+  \/\/ vtmp  =  00hh  00gg  00ff  00ee\n+  sve_uunpkhi(vtmp, S, src);\n+  \/\/ vtmp  =  0000  0000  00hh  00ee\n+  sve_compact(vtmp, S, vtmp, pgtmp);\n+  \/\/ vtmp  = 00 00 00 00 00 00 hh ee\n+  sve_uzp1(vtmp, H, vtmp, vzr);\n+\n+  \/\/ pgtmp = 00 00 00 00 00 01 01 01\n+  sve_whilelt(pgtmp, H, zr, rscratch1);\n+  \/\/ Compressed low:  dst  = 00 00 00 00 00 dd bb aa\n+  \/\/ Compressed high: vtmp = 00 00 00 00 00 00 hh ee\n+  \/\/ Combine the compressed low with the compressed high:\n+  \/\/                  dst  = 00 00 00 hh ee dd bb aa\n+  sve_splice(dst, H, pgtmp, vtmp);\n@@ -2284,3 +2286,2 @@\n-                                          FloatRegister vtmp1, FloatRegister vtmp2,\n-                                          FloatRegister vtmp3, FloatRegister vtmp4,\n-                                          PRegister ptmp, PRegister pgtmp) {\n+                                          FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+                                          PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes) {\n@@ -2288,1 +2289,1 @@\n-  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3, vtmp4);\n+  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3);\n@@ -2290,3 +2291,6 @@\n-  \/\/ Example input:   src   = 88 77 66 55 44 33 22 11\n-  \/\/                  mask  = 01 00 00 01 01 00 01 01\n-  \/\/ Expected result: dst   = 00 00 00 88 55 44 22 11\n+  \/\/ high <-- low\n+  \/\/ Example input:   src   = q p n m l k j i h g f e d c b a, one character is 8 bits.\n+  \/\/                  mask  = 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 1, one character is 1 bit.\n+  \/\/ Expected result: dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n+  FloatRegister vzr = vtmp3;\n+  sve_dup(vzr, B, 0);\n@@ -2294,1 +2298,0 @@\n-  sve_dup(vtmp4, B, 0);\n@@ -2296,1 +2299,1 @@\n-  \/\/ vtmp1 = 0044 0033 0022 0011\n+  \/\/ vtmp1 =  0h  0g  0f  0e  0d  0c  0b  0a\n@@ -2298,1 +2301,1 @@\n-  \/\/ ptmp = 0001 0000 0001 0001\n+  \/\/ ptmp  =  00  01  00  00  00  01  00  01\n@@ -2300,3 +2303,0 @@\n-  \/\/ Count the active elements of lowest half.\n-  \/\/ rscratch2 = 3\n-  sve_cntp(rscratch2, H, ptrue, ptmp);\n@@ -2305,2 +2305,3 @@\n-  \/\/ dst = 0000 0044 0022 0011\n-  sve_compress_short(dst, vtmp1, ptmp, vtmp2, vtmp3, pgtmp);\n+  \/\/ dst   =  00  00  00  00  00  0g  0c  0a\n+  unsigned extended_size = vector_length_in_bytes << 1;\n+  sve_compress_short(dst, vtmp1, ptmp, vzr, vtmp2, pgtmp, extended_size > MaxVectorSize ? MaxVectorSize : extended_size);\n@@ -2308,2 +2309,11 @@\n-  \/\/ dst = 00 00 00 00 00 44 22 11\n-  sve_uzp1(dst, B, dst, vtmp4);\n+  \/\/ dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n+  sve_uzp1(dst, B, dst, vzr);\n+\n+  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n+  \/\/ highest half is invalid.\n+  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n+    return;\n+  }\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch2 = 3\n+  sve_cntp(rscratch2, H, ptrue, ptmp);\n@@ -2312,1 +2322,1 @@\n-  \/\/ ptmp = 0001 0000 0000 0001\n+  \/\/ ptmp  =  00  01  00  00  00  00  00  01\n@@ -2314,1 +2324,1 @@\n-  \/\/ vtmp1 = 0088 0077 0066 0055\n+  \/\/ vtmp2 =  0q  0p  0n  0m  0l  0k  0j  0i\n@@ -2316,19 +2326,12 @@\n-  \/\/ vtmp1 = 0000 0000 0088 0055\n-  sve_compress_short(vtmp1, vtmp2, ptmp, vtmp3, vtmp4, pgtmp);\n-\n-  sve_dup(vtmp4, B, 0);\n-  \/\/ vtmp1 = 00 00 00 00 00 00 88 55\n-  sve_uzp1(vtmp1, B, vtmp1, vtmp4);\n-\n-  \/\/ Compressed low:   dst   = 00 00 00 00 00 44 22 11\n-  \/\/ Compressed high:  vtmp1 = 00 00 00 00 00 00 88 55\n-  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n-  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n-  neg(rscratch2, rscratch2);\n-  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n-  sve_index(vtmp2, B, rscratch2, 1);\n-  \/\/ vtmp1 = 00 00 00 88 55 00 00 00\n-  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n-  \/\/ Combine the compressed high(after shifted) with the compressed low.\n-  \/\/ dst = 00 00 00 88 55 44 22 11\n-  sve_orr(dst, dst, vtmp1);\n+  \/\/ vtmp1 =  00  00  00  00  00  00  0p  0i\n+  sve_compress_short(vtmp1, vtmp2, ptmp, vzr, vtmp2, pgtmp, extended_size - MaxVectorSize);\n+  \/\/ vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n+  sve_uzp1(vtmp1, B, vtmp1, vzr);\n+\n+  \/\/ ptmp  = 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1\n+  sve_whilelt(ptmp, B, zr, rscratch2);\n+  \/\/ Compressed low:  dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n+  \/\/ Compressed high: vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n+  \/\/ Combine the compressed low with the compressed high:\n+  \/\/                  dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n+  sve_splice(dst, B, ptmp, vtmp1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":76,"deletions":73,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -178,3 +178,2 @@\n-                         FloatRegister vtmp1, FloatRegister vtmp2,\n-                         FloatRegister vtmp3, FloatRegister vtmp4,\n-                         PRegister ptmp, PRegister pgtmp);\n+                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+                         PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes);\n@@ -183,2 +182,2 @@\n-                          FloatRegister vtmp1, FloatRegister vtmp2,\n-                          PRegister pgtmp);\n+                          FloatRegister vzr, FloatRegister vtmp,\n+                          PRegister pgtmp, unsigned vector_length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1957,0 +1957,11 @@\n+\n+#ifdef ASSERT\n+void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n+  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n+  Label L;\n+  subs(zr, reg, oopDesc::base_offset_in_bytes());\n+  br(Assembler::GE, L);\n+  stop(\"bad field offset\");\n+  bind(L);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -352,0 +352,2 @@\n+\n+  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,3 +156,0 @@\n-class RelocActions {\n-protected:\n-  typedef int (*reloc_insn)(address insn_addr, address &target);\n@@ -160,3 +157,3 @@\n-  virtual reloc_insn adrpMem() = 0;\n-  virtual reloc_insn adrpAdd() = 0;\n-  virtual reloc_insn adrpMovk() = 0;\n+static uint32_t insn_at(address insn_addr, int n) {\n+  return ((uint32_t*)insn_addr)[n];\n+}\n@@ -164,9 +161,2 @@\n-  const address _insn_addr;\n-  const uint32_t _insn;\n-\n-  static uint32_t insn_at(address insn_addr, int n) {\n-    return ((uint32_t*)insn_addr)[n];\n-  }\n-  uint32_t insn_at(int n) const {\n-    return insn_at(_insn_addr, n);\n-  }\n+template<typename T>\n+class RelocActions : public AllStatic {\n@@ -176,14 +166,1 @@\n-  RelocActions(address insn_addr) : _insn_addr(insn_addr), _insn(insn_at(insn_addr, 0)) {}\n-  RelocActions(address insn_addr, uint32_t insn)\n-    :  _insn_addr(insn_addr), _insn(insn) {}\n-\n-  virtual int unconditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int conditionalBranch(address insn_addr, address &target) = 0;\n-  virtual int testAndBranch(address insn_addr, address &target) = 0;\n-  virtual int loadStore(address insn_addr, address &target) = 0;\n-  virtual int adr(address insn_addr, address &target) = 0;\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) = 0;\n-  virtual int immediate(address insn_addr, address &target) = 0;\n-  virtual void verify(address insn_addr, address &target) = 0;\n-\n-  int ALWAYSINLINE run(address insn_addr, address &target) {\n+  static int ALWAYSINLINE run(address insn_addr, address &target) {\n@@ -191,0 +168,1 @@\n+    uint32_t insn = insn_at(insn_addr, 0);\n@@ -192,1 +170,1 @@\n-    uint32_t dispatch = Instruction_aarch64::extract(_insn, 30, 25);\n+    uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n@@ -196,1 +174,1 @@\n-        instructions = unconditionalBranch(insn_addr, target);\n+        instructions = T::unconditionalBranch(insn_addr, target);\n@@ -201,2 +179,2 @@\n-        instructions = conditionalBranch(insn_addr, target);\n-          break;\n+        instructions = T::conditionalBranch(insn_addr, target);\n+        break;\n@@ -205,1 +183,1 @@\n-        instructions = testAndBranch(insn_addr, target);\n+        instructions = T::testAndBranch(insn_addr, target);\n@@ -217,1 +195,1 @@\n-        if ((Instruction_aarch64::extract(_insn, 29, 24) & 0b111011) == 0b011000) {\n+        if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n@@ -219,1 +197,1 @@\n-          instructions = loadStore(insn_addr, target);\n+          instructions = T::loadStore(insn_addr, target);\n@@ -232,2 +210,2 @@\n-        assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n-        int shift = Instruction_aarch64::extract(_insn, 31, 31);\n+        assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+        int shift = Instruction_aarch64::extract(insn, 31, 31);\n@@ -235,1 +213,1 @@\n-          uint32_t insn2 = insn_at(1);\n+          uint32_t insn2 = insn_at(insn_addr, 1);\n@@ -237,1 +215,1 @@\n-              Instruction_aarch64::extract(_insn, 4, 0) ==\n+              Instruction_aarch64::extract(insn, 4, 0) ==\n@@ -239,1 +217,1 @@\n-            instructions = adrp(insn_addr, target, adrpMem());\n+            instructions = T::adrp(insn_addr, target, T::adrpMem);\n@@ -241,1 +219,1 @@\n-                     Instruction_aarch64::extract(_insn, 4, 0) ==\n+                     Instruction_aarch64::extract(insn, 4, 0) ==\n@@ -243,1 +221,1 @@\n-            instructions = adrp(insn_addr, target, adrpAdd());\n+            instructions = T::adrp(insn_addr, target, T::adrpAdd);\n@@ -245,1 +223,1 @@\n-                     Instruction_aarch64::extract(_insn, 4, 0) ==\n+                     Instruction_aarch64::extract(insn, 4, 0) ==\n@@ -247,1 +225,1 @@\n-            instructions = adrp(insn_addr, target, adrpMovk());\n+            instructions = T::adrp(insn_addr, target, T::adrpMovk);\n@@ -252,1 +230,1 @@\n-          instructions = adr(insn_addr, target);\n+          instructions = T::adr(insn_addr, target);\n@@ -260,1 +238,1 @@\n-        instructions = immediate(insn_addr, target);\n+        instructions = T::immediate(insn_addr, target);\n@@ -268,1 +246,1 @@\n-    verify(insn_addr, target);\n+    T::verify(insn_addr, target);\n@@ -273,5 +251,1 @@\n-class Patcher : public RelocActions {\n-  virtual reloc_insn adrpMem() { return &Patcher::adrpMem_impl; }\n-  virtual reloc_insn adrpAdd() { return &Patcher::adrpAdd_impl; }\n-  virtual reloc_insn adrpMovk() { return &Patcher::adrpMovk_impl; }\n-\n+class Patcher : public AllStatic {\n@@ -279,3 +253,1 @@\n-  Patcher(address insn_addr) : RelocActions(insn_addr) {}\n-\n-  virtual int unconditionalBranch(address insn_addr, address &target) {\n+  static int unconditionalBranch(address insn_addr, address &target) {\n@@ -286,1 +258,1 @@\n-  virtual int conditionalBranch(address insn_addr, address &target) {\n+  static int conditionalBranch(address insn_addr, address &target) {\n@@ -291,1 +263,1 @@\n-  virtual int testAndBranch(address insn_addr, address &target) {\n+  static int testAndBranch(address insn_addr, address &target) {\n@@ -296,1 +268,1 @@\n-  virtual int loadStore(address insn_addr, address &target) {\n+  static int loadStore(address insn_addr, address &target) {\n@@ -301,1 +273,1 @@\n-  virtual int adr(address insn_addr, address &target) {\n+  static int adr(address insn_addr, address &target) {\n@@ -303,1 +275,1 @@\n-    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n+    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 28, 24) == 0b10000, \"must be\");\n@@ -313,1 +285,2 @@\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n+  template<typename U>\n+  static int adrp(address insn_addr, address &target, U inner) {\n@@ -316,1 +289,1 @@\n-    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n+    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 28, 24) == 0b10000, \"must be\");\n@@ -323,1 +296,1 @@\n-    instructions = (*inner)(insn_addr, adjusted_target);\n+    instructions = inner(insn_addr, adjusted_target);\n@@ -333,1 +306,1 @@\n-  static int adrpMem_impl(address insn_addr, address &target) {\n+  static int adrpMem(address insn_addr, address &target) {\n@@ -342,1 +315,1 @@\n-  static int adrpAdd_impl(address insn_addr, address &target) {\n+  static int adrpAdd(address insn_addr, address &target) {\n@@ -348,1 +321,1 @@\n-  static int adrpMovk_impl(address insn_addr, address &target) {\n+  static int adrpMovk(address insn_addr, address &target) {\n@@ -355,2 +328,2 @@\n-  virtual int immediate(address insn_addr, address &target) {\n-    assert(Instruction_aarch64::extract(_insn, 31, 21) == 0b11010010100, \"must be\");\n+  static int immediate(address insn_addr, address &target) {\n+    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 31, 21) == 0b11010010100, \"must be\");\n@@ -366,1 +339,1 @@\n-  virtual void verify(address insn_addr, address &target) {\n+  static void verify(address insn_addr, address &target) {\n@@ -400,5 +373,1 @@\n-class AArch64Decoder : public RelocActions {\n-  virtual reloc_insn adrpMem() { return &AArch64Decoder::adrpMem_impl; }\n-  virtual reloc_insn adrpAdd() { return &AArch64Decoder::adrpAdd_impl; }\n-  virtual reloc_insn adrpMovk() { return &AArch64Decoder::adrpMovk_impl; }\n-\n+class AArch64Decoder : public AllStatic {\n@@ -406,1 +375,0 @@\n-  AArch64Decoder(address insn_addr, uint32_t insn) : RelocActions(insn_addr, insn) {}\n@@ -408,2 +376,2 @@\n-  virtual int loadStore(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 23, 5);\n+  static int loadStore(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 23, 5);\n@@ -413,2 +381,2 @@\n-  virtual int unconditionalBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 25, 0);\n+  static int unconditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 25, 0);\n@@ -418,2 +386,2 @@\n-  virtual int conditionalBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 23, 5);\n+  static int conditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 23, 5);\n@@ -423,2 +391,2 @@\n-  virtual int testAndBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(_insn, 18, 5);\n+  static int testAndBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 18, 5);\n@@ -428,1 +396,1 @@\n-  virtual int adr(address insn_addr, address &target) {\n+  static int adr(address insn_addr, address &target) {\n@@ -430,2 +398,3 @@\n-    intptr_t offset = Instruction_aarch64::extract(_insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(_insn, 23, 5) << 2;\n+    uint32_t insn = insn_at(insn_addr, 0);\n+    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n@@ -435,4 +404,6 @@\n-  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n-    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n-    intptr_t offset = Instruction_aarch64::extract(_insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(_insn, 23, 5) << 2;\n+  template<typename U>\n+  static int adrp(address insn_addr, address &target, U inner) {\n+    uint32_t insn = insn_at(insn_addr, 0);\n+    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n+    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n@@ -443,1 +414,1 @@\n-    uint32_t insn2 = insn_at(1);\n+    uint32_t insn2 = insn_at(insn_addr, 1);\n@@ -446,1 +417,1 @@\n-    (*inner)(insn_addr, target);\n+    inner(insn_addr, target);\n@@ -449,1 +420,1 @@\n-  static int adrpMem_impl(address insn_addr, address &target) {\n+  static int adrpMem(address insn_addr, address &target) {\n@@ -458,1 +429,1 @@\n-  static int adrpAdd_impl(address insn_addr, address &target) {\n+  static int adrpAdd(address insn_addr, address &target) {\n@@ -465,1 +436,1 @@\n-  static int adrpMovk_impl(address insn_addr, address &target) {\n+  static int adrpMovk(address insn_addr, address &target) {\n@@ -484,1 +455,1 @@\n-  virtual int immediate(address insn_addr, address &target) {\n+  static int immediate(address insn_addr, address &target) {\n@@ -486,1 +457,1 @@\n-    assert(Instruction_aarch64::extract(_insn, 31, 21) == 0b11010010100, \"must be\");\n+    assert(Instruction_aarch64::extract(insns[0], 31, 21) == 0b11010010100, \"must be\");\n@@ -490,3 +461,3 @@\n-    target = address(uint64_t(Instruction_aarch64::extract(_insn, 20, 5))\n-                 + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n-                 + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n+    target = address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n+                  + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n+                  + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n@@ -497,1 +468,1 @@\n-  virtual void verify(address insn_addr, address &target) {\n+  static void verify(address insn_addr, address &target) {\n@@ -501,2 +472,1 @@\n-address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n-  AArch64Decoder decoder(insn_addr, insn);\n+address MacroAssembler::target_addr_for_insn(address insn_addr) {\n@@ -504,1 +474,1 @@\n-  decoder.run(insn_addr, target);\n+  RelocActions<AArch64Decoder>::run(insn_addr, target);\n@@ -511,2 +481,1 @@\n-  Patcher patcher(insn_addr);\n-  return patcher.run(insn_addr, target);\n+  return RelocActions<Patcher>::run(insn_addr, target);\n@@ -554,2 +523,2 @@\n-address MacroAssembler::target_addr_for_insn_or_null(address insn_addr, unsigned insn) {\n-  if (NativeInstruction::is_ldrw_to_zr(address(&insn))) {\n+address MacroAssembler::target_addr_for_insn_or_null(address insn_addr) {\n+  if (NativeInstruction::is_ldrw_to_zr(insn_addr)) {\n@@ -558,1 +527,1 @@\n-  return MacroAssembler::target_addr_for_insn(insn_addr, insn);\n+  return MacroAssembler::target_addr_for_insn(insn_addr);\n@@ -7907,4 +7876,3 @@\n-  if (EnableValhalla) {\n-    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n-    andr(mark, mark, ~((int) markWord::inline_type_bit_in_place));\n-  }\n+  \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+  andr(mark, mark, ~((int) markWord::inline_type_bit_in_place));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":82,"deletions":114,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -706,10 +706,2 @@\n-  static address target_addr_for_insn(address insn_addr, unsigned insn);\n-  static address target_addr_for_insn_or_null(address insn_addr, unsigned insn);\n-  static address target_addr_for_insn(address insn_addr) {\n-    unsigned insn = *(unsigned*)insn_addr;\n-    return target_addr_for_insn(insn_addr, insn);\n-  }\n-  static address target_addr_for_insn_or_null(address insn_addr) {\n-    unsigned insn = *(unsigned*)insn_addr;\n-    return target_addr_for_insn_or_null(insn_addr, insn);\n-  }\n+  static address target_addr_for_insn(address insn_addr);\n+  static address target_addr_for_insn_or_null(address insn_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  assert_different_registers(bc_reg, temp_reg);\n@@ -235,3 +236,6 @@\n-\n-  \/\/ patch bytecode\n-  __ strb(bc_reg, at_bcp(0));\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n+  __ lea(temp_reg, at_bcp(0));\n+  __ stlrb(bc_reg, temp_reg);\n@@ -3278,0 +3282,1 @@\n+  __ verify_field_offset(r1);\n@@ -3383,0 +3388,2 @@\n+  __ verify_field_offset(r1);\n+\n@@ -3458,0 +3465,1 @@\n+\n@@ -3459,0 +3467,1 @@\n+  __ verify_field_offset(r1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1134,1 +1134,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -1136,1 +1136,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -1140,1 +1140,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -1142,1 +1142,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -1146,1 +1146,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -1148,1 +1148,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -1152,1 +1152,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n@@ -1154,1 +1154,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,2 +136,7 @@\n-  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n-  void load_method_entry(Register cache, Register index, int bcp_offset = 1);\n+  void load_field_or_method_entry(bool is_method, Register cache, Register index, int bcp_offset, bool for_fast_bytecode);\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1, bool for_fast_bytecode = false) {\n+    load_field_or_method_entry(false, cache, index, bcp_offset, for_fast_bytecode);\n+  }\n+  void load_method_entry(Register cache, Register index, int bcp_offset = 1, bool for_fast_bytecode = false) {\n+    load_field_or_method_entry(true, cache, index, bcp_offset, for_fast_bytecode);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -471,1 +471,5 @@\n-void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+void InterpreterMacroAssembler::load_field_or_method_entry(bool is_method, Register cache, Register index, int bcp_offset, bool for_fast_bytecode) {\n+  const int entry_size     = is_method ? sizeof(ResolvedMethodEntry) : sizeof(ResolvedFieldEntry),\n+            base_offset    = is_method ? Array<ResolvedMethodEntry>::base_offset_in_bytes() : Array<ResolvedFieldEntry>::base_offset_in_bytes(),\n+            entries_offset = is_method ? in_bytes(ConstantPoolCache::method_entries_offset()) : in_bytes(ConstantPoolCache::field_entries_offset());\n+\n@@ -475,1 +479,1 @@\n-  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+  if (is_power_of_2(entry_size)) {\n@@ -477,1 +481,1 @@\n-    sldi(index, index, log2i_exact(sizeof(ResolvedFieldEntry)));\n+    sldi(index, index, log2i_exact(entry_size));\n@@ -480,1 +484,1 @@\n-    mulli(index, index, sizeof(ResolvedFieldEntry));\n+    mulli(index, index, entry_size);\n@@ -483,2 +487,2 @@\n-  ld_ptr(cache, in_bytes(ConstantPoolCache::field_entries_offset()), R27_constPoolCache);\n-  addi(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+  ld_ptr(cache, entries_offset, R27_constPoolCache);\n+  addi(cache, cache, base_offset);\n@@ -486,1 +490,0 @@\n-}\n@@ -488,10 +491,7 @@\n-void InterpreterMacroAssembler::load_method_entry(Register cache, Register index, int bcp_offset) {\n-  \/\/ Get index out of bytecode pointer\n-  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedMethodEntry)\n-  mulli(index, index, sizeof(ResolvedMethodEntry));\n-\n-  \/\/ Get address of field entries array\n-  ld_ptr(cache, ConstantPoolCache::method_entries_offset(), R27_constPoolCache);\n-  addi(cache, cache, Array<ResolvedMethodEntry>::base_offset_in_bytes());\n-  add(cache, cache, index); \/\/ method_entries + base_offset + scaled index\n+  if (for_fast_bytecode) {\n+    \/\/ Prevent speculative loading from ResolvedFieldEntry\/ResolvedMethodEntry as it can miss the info written by another thread.\n+    \/\/ TemplateTable::patch_bytecode uses release-store.\n+    \/\/ We reached here via control dependency (Bytecode dispatch has used the rewritten Bytecode).\n+    \/\/ So, we can use control-isync based ordering.\n+    isync();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2453,1 +2453,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -2455,1 +2455,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2459,1 +2459,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -2461,1 +2461,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2465,1 +2465,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -2467,1 +2467,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2471,1 +2471,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n@@ -2473,1 +2473,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -151,1 +151,3 @@\n-  \/\/ Patch bytecode.\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry\n+  \/\/ and ResolvedMethodEntry loads in fast bytecode codelets.\n+  __ release();\n@@ -315,0 +317,1 @@\n+  \/\/ Only rewritten during link time. So, no need for memory barriers for accessing resolved info.\n@@ -3117,1 +3120,1 @@\n-  __ load_field_entry(Rcache, Rscratch);\n+  __ load_field_entry(Rcache, Rscratch, 1, \/* for_fast_bytecode *\/ true);\n@@ -3198,1 +3201,1 @@\n-  __ load_field_entry(Rcache, Rscratch);\n+  __ load_field_entry(Rcache, Rscratch, 1, \/* for_fast_bytecode *\/ true);\n@@ -3337,1 +3340,1 @@\n-  __ load_field_entry(Rcache, Rscratch, 2);\n+  __ load_field_entry(Rcache, Rscratch, 2, \/* for_fast_bytecode *\/ true);\n@@ -3498,1 +3501,1 @@\n-  __ load_method_entry(Rcache, R11_scratch1);\n+  __ load_method_entry(Rcache, R11_scratch1, 1, \/* for_fast_bytecode *\/ true);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -102,0 +102,4 @@\n+  if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n+    FLAG_SET_ERGO(UsePopCountInstruction, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1844,0 +1844,9 @@\n+void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n+  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n+  Label L;\n+  mv(t0, oopDesc::base_offset_in_bytes());\n+  bge(reg, t0, L);\n+  stop(\"bad field offset\");\n+  bind(L);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-#ifdef ASSERT\n+  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n@@ -305,3 +305,2 @@\n-                           const char* msg, bool stop_by_hit = true);\n-  void verify_frame_setup();\n-#endif\n+                           const char* msg, bool stop_by_hit = true) NOT_DEBUG_RETURN;\n+  void verify_frame_setup() NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1095,2 +1095,2 @@\n-  _ANY_REG32_mask = _ALL_REG32_mask;\n-  _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(x0->as_VMReg()));\n+  _ANY_REG32_mask.assignFrom(_ALL_REG32_mask);\n+  _ANY_REG32_mask.remove(OptoReg::as_OptoReg(x0->as_VMReg()));\n@@ -1098,2 +1098,2 @@\n-  _ANY_REG_mask = _ALL_REG_mask;\n-  _ANY_REG_mask.SUBTRACT(_ZR_REG_mask);\n+  _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n+  _ANY_REG_mask.subtract(_ZR_REG_mask);\n@@ -1101,2 +1101,2 @@\n-  _PTR_REG_mask = _ALL_REG_mask;\n-  _PTR_REG_mask.SUBTRACT(_ZR_REG_mask);\n+  _PTR_REG_mask.assignFrom(_ALL_REG_mask);\n+  _PTR_REG_mask.subtract(_ZR_REG_mask);\n@@ -1104,2 +1104,2 @@\n-  _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;\n-  _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);\n+  _NO_SPECIAL_REG32_mask.assignFrom(_ALL_REG32_mask);\n+  _NO_SPECIAL_REG32_mask.subtract(_NON_ALLOCATABLE_REG32_mask);\n@@ -1107,2 +1107,2 @@\n-  _NO_SPECIAL_REG_mask = _ALL_REG_mask;\n-  _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n+  _NO_SPECIAL_REG_mask.assignFrom(_ALL_REG_mask);\n+  _NO_SPECIAL_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n@@ -1110,2 +1110,2 @@\n-  _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;\n-  _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n+  _NO_SPECIAL_PTR_REG_mask.assignFrom(_ALL_REG_mask);\n+  _NO_SPECIAL_PTR_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n@@ -1115,3 +1115,3 @@\n-    _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n-    _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n-    _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n+    _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n+    _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n+    _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n@@ -1122,3 +1122,3 @@\n-    _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n-    _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n-    _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+    _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+    _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+    _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n@@ -1127,2 +1127,2 @@\n-  _NO_SPECIAL_NO_FP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n-  _NO_SPECIAL_NO_FP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+  _NO_SPECIAL_NO_FP_PTR_REG_mask.assignFrom(_NO_SPECIAL_PTR_REG_mask);\n+  _NO_SPECIAL_NO_FP_PTR_REG_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n@@ -1329,1 +1329,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n@@ -2107,1 +2107,1 @@\n-  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ (_NO_SPECIAL_REG32_mask.size() minus 1) forces CallNode to become\n@@ -2110,1 +2110,1 @@\n-  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.size() - 1;\n@@ -2125,1 +2125,1 @@\n-  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.size() : FLOATPRESSURE;\n@@ -2132,1 +2132,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -2134,1 +2134,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2138,1 +2138,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -2140,1 +2140,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2144,1 +2144,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -2146,1 +2146,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n@@ -2150,1 +2150,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n@@ -2152,1 +2152,1 @@\n-  return RegMask();\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1076,1 +1076,0 @@\n-#ifdef ASSERT\n@@ -1078,1 +1077,0 @@\n-#endif\n@@ -1550,1 +1548,0 @@\n-#ifdef ASSERT\n@@ -1552,1 +1549,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  assert_different_registers(bc_reg, temp_reg);\n@@ -199,1 +200,5 @@\n-  \/\/ patch bytecode\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n+  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n@@ -3032,0 +3037,1 @@\n+  __ verify_field_offset(x11);\n@@ -3119,0 +3125,2 @@\n+  __ verify_field_offset(x11);\n+\n@@ -3174,0 +3182,1 @@\n+\n@@ -3175,0 +3184,1 @@\n+  __ verify_field_offset(x11);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,11 +106,0 @@\n-  \/\/ Enable vendor specific features\n-\n-  if (mvendorid.enabled()) {\n-    \/\/ Rivos\n-    if (mvendorid.value() == RIVOS) {\n-      if (FLAG_IS_DEFAULT(UseConservativeFence)) {\n-        FLAG_SET_DEFAULT(UseConservativeFence, false);\n-      }\n-    }\n-  }\n-\n@@ -202,1 +191,1 @@\n-  if (UseZicboz && zicboz_block_size.enabled() && zicboz_block_size.value() > 0) {\n+  if (UseZicboz && zicboz_block_size.value() > 0) {\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    int64_t           _value;\n+\n@@ -58,8 +58,1 @@\n-      _pretty(pretty), _feature_string(fstring), _linux_feature_bit(nth_bit(linux_bit_num)),\n-      _value(-1) {\n-    }\n-    virtual void enable_feature(int64_t value = 0) {\n-      _value = value;\n-    }\n-    virtual void disable_feature() {\n-      _value = -1;\n+      _pretty(pretty), _feature_string(fstring), _linux_feature_bit(nth_bit(linux_bit_num)) {\n@@ -67,0 +60,2 @@\n+    virtual void enable_feature(int64_t value = 0) = 0;\n+    virtual void disable_feature() = 0;\n@@ -70,1 +65,0 @@\n-    int64_t value()              { return _value; }\n@@ -73,29 +67,1 @@\n-\n-   protected:\n-    bool deps_all_enabled(RVFeatureValue* dep0, ...) {\n-      assert(dep0 != nullptr, \"must not\");\n-\n-      va_list va;\n-      va_start(va, dep0);\n-      RVFeatureValue* next = dep0;\n-      bool enabled = true;\n-      while (next != nullptr && enabled) {\n-        enabled = next->enabled();\n-        next = va_arg(va, RVFeatureValue*);\n-      }\n-      va_end(va);\n-      return enabled;\n-    }\n-\n-    void deps_string(stringStream& ss, RVFeatureValue* dep0, ...) {\n-      assert(dep0 != nullptr, \"must not\");\n-      ss.print(\"%s (%s)\", dep0->pretty(), dep0->enabled() ? \"enabled\" : \"disabled\");\n-\n-      va_list va;\n-      va_start(va, dep0);\n-      RVFeatureValue* next = nullptr;\n-      while ((next = va_arg(va, RVFeatureValue*)) != nullptr) {\n-        ss.print(\", %s (%s)\", next->pretty(), next->enabled() ? \"enabled\" : \"disabled\");\n-      }\n-      va_end(va);\n-    }\n+    virtual void log_enabled() = 0;\n@@ -120,0 +86,1 @@\n+      DEBUG_ONLY(verify_deps(dep0, ##__VA_ARGS__));                                                         \\\n@@ -121,1 +88,1 @@\n-        if (this->deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                  \\\n+        if (deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                        \\\n@@ -152,0 +119,1 @@\n+\n@@ -157,0 +125,4 @@\n+    int cpu_feature_index() {\n+      \/\/ Can be used to check, for example, v is declared before Zvfh in RV_EXT_FEATURE_FLAGS.\n+      return _cpu_feature_index;\n+    }\n@@ -161,1 +133,0 @@\n-      RVFeatureValue::enable_feature(value);\n@@ -165,1 +136,0 @@\n-      RVFeatureValue::disable_feature();\n@@ -168,0 +138,52 @@\n+    void log_enabled();\n+\n+   protected:\n+    bool deps_all_enabled(RVExtFeatureValue* dep0, ...) {\n+      assert(dep0 != nullptr, \"must not\");\n+\n+      va_list va;\n+      va_start(va, dep0);\n+      RVExtFeatureValue* next = dep0;\n+      bool enabled = true;\n+      while (next != nullptr && enabled) {\n+        enabled = next->enabled();\n+        next = va_arg(va, RVExtFeatureValue*);\n+      }\n+      va_end(va);\n+      return enabled;\n+    }\n+\n+    void deps_string(stringStream& ss, RVExtFeatureValue* dep0, ...) {\n+      assert(dep0 != nullptr, \"must not\");\n+      ss.print(\"%s (%s)\", dep0->pretty(), dep0->enabled() ? \"enabled\" : \"disabled\");\n+\n+      va_list va;\n+      va_start(va, dep0);\n+      RVExtFeatureValue* next = nullptr;\n+      while ((next = va_arg(va, RVExtFeatureValue*)) != nullptr) {\n+        ss.print(\", %s (%s)\", next->pretty(), next->enabled() ? \"enabled\" : \"disabled\");\n+      }\n+      va_end(va);\n+    }\n+\n+#ifdef ASSERT\n+    void verify_deps(RVExtFeatureValue* dep0, ...) {\n+      assert(dep0 != nullptr, \"must not\");\n+      assert(cpu_feature_index() >= 0, \"must\");\n+\n+      va_list va;\n+      va_start(va, dep0);\n+      RVExtFeatureValue* next = dep0;\n+      while (next != nullptr) {\n+        assert(next->cpu_feature_index() >= 0, \"must\");\n+        \/\/ We only need to check depenency relationship for extension flags.\n+        \/\/ The dependant ones must be declared before this, for example, v must be declared\n+        \/\/ before Zvfh in RV_EXT_FEATURE_FLAGS. The reason is in setup_cpu_available_features\n+        \/\/ we need to make sure v is `update_flag`ed before Zvfh, so Zvfh is `update_flag`ed\n+        \/\/ based on v.\n+        assert(cpu_feature_index() > next->cpu_feature_index(), \"Invalid\");\n+        next = va_arg(va, RVExtFeatureValue*);\n+      }\n+      va_end(va);\n+    }\n+#endif \/\/ ASSERT\n@@ -171,1 +193,3 @@\n-    bool _enabled;\n+    static const int64_t DEFAULT_VALUE = -1;\n+    int64_t _value;\n+\n@@ -175,1 +199,1 @@\n-      _enabled(false) {\n+      _value(DEFAULT_VALUE) {\n@@ -177,8 +201,4 @@\n-    bool enabled()               { return _enabled; }\n-    void enable_feature(int64_t value = 0) {\n-      RVFeatureValue::enable_feature(value);\n-      _enabled = true;\n-    }\n-    void disable_feature() {\n-      RVFeatureValue::disable_feature();\n-      _enabled = false;\n+    bool enabled() { return _value != DEFAULT_VALUE; }\n+    void enable_feature(int64_t value) {\n+      assert(value != DEFAULT_VALUE, \"Sanity\");\n+      _value = value;\n@@ -186,0 +206,3 @@\n+    void disable_feature() { _value = DEFAULT_VALUE; }\n+    int64_t value() { return _value; }\n+    void log_enabled();\n@@ -285,0 +308,2 @@\n+  \/* Manufactory JEDEC id encoded, ISA vol 2 3.1.2.. *\/                                        \\\n+  decl(mvendorid         ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)                        \\\n@@ -291,2 +316,0 @@\n-  \/* Manufactory JEDEC id encoded, ISA vol 2 3.1.2.. *\/                                        \\\n-  decl(mvendorid         ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)                        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":77,"deletions":54,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-    __ z_csg($oldval$$Register, $newval$$Register, 0, $mem_ptr$$reg);\n+    __ z_csg($res$$Register, $newval$$Register, 0, $mem_ptr$$reg);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1_s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1964,1 +1964,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -1969,1 +1969,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -1974,1 +1974,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -1979,1 +1979,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -489,9 +489,9 @@\n-  caller_saved.Insert(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rsi->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(rdi->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r8->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r9->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r10->as_VMReg()));\n-  caller_saved.Insert(OptoReg::as_OptoReg(r11->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rsi->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(rdi->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r8->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r9->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r10->as_VMReg()));\n+  caller_saved.insert(OptoReg::as_OptoReg(r11->as_VMReg()));\n@@ -500,16 +500,16 @@\n-    caller_saved.Insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n-    caller_saved.Insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n+    caller_saved.insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n@@ -529,1 +529,1 @@\n-      if (caller_saved.Member(opto_reg)) {\n+      if (caller_saved.member(opto_reg)) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -10442,4 +10442,3 @@\n-  if (EnableValhalla) {\n-    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n-    andptr(reg_rax, ~((int) markWord::inline_type_bit_in_place));\n-  }\n+  \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+  andptr(reg_rax, ~((int) markWord::inline_type_bit_in_place));\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-  _ANY_REG_mask = _ALL_REG_mask;\n+  _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n@@ -503,2 +503,2 @@\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n@@ -507,2 +507,2 @@\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n-    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n@@ -511,5 +511,5 @@\n-  _PTR_REG_mask = _ANY_REG_mask;\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n-  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n+  _PTR_REG_mask.assignFrom(_ANY_REG_mask);\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n@@ -518,2 +518,2 @@\n-      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n-      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n+      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n@@ -523,2 +523,2 @@\n-  _STACK_OR_PTR_REG_mask = _PTR_REG_mask;\n-  _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+  _STACK_OR_PTR_REG_mask.assignFrom(_PTR_REG_mask);\n+  _STACK_OR_PTR_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n@@ -526,3 +526,3 @@\n-  _PTR_REG_NO_RBP_mask = _PTR_REG_mask;\n-  _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _PTR_REG_NO_RBP_mask.assignFrom(_PTR_REG_mask);\n+  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n@@ -530,3 +530,3 @@\n-  _PTR_NO_RAX_REG_mask = _PTR_REG_mask;\n-  _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+  _PTR_NO_RAX_REG_mask.assignFrom(_PTR_REG_mask);\n+  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n@@ -534,3 +534,3 @@\n-  _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;\n-  _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n-  _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n+  _PTR_NO_RAX_RBX_REG_mask.assignFrom(_PTR_NO_RAX_REG_mask);\n+  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n+  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n@@ -539,3 +539,3 @@\n-  _LONG_REG_mask = _PTR_REG_mask;\n-  _STACK_OR_LONG_REG_mask = _LONG_REG_mask;\n-  _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+  _LONG_REG_mask.assignFrom(_PTR_REG_mask);\n+  _STACK_OR_LONG_REG_mask.assignFrom(_LONG_REG_mask);\n+  _STACK_OR_LONG_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n@@ -543,5 +543,5 @@\n-  _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n+  _LONG_NO_RAX_RDX_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n@@ -549,3 +549,3 @@\n-  _LONG_NO_RCX_REG_mask = _LONG_REG_mask;\n-  _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-  _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n+  _LONG_NO_RCX_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n@@ -553,5 +553,5 @@\n-  _LONG_NO_RBP_R13_REG_mask = _LONG_REG_mask;\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n@@ -559,1 +559,1 @@\n-  _INT_REG_mask = _ALL_INT_REG_mask;\n+  _INT_REG_mask.assignFrom(_ALL_INT_REG_mask);\n@@ -562,1 +562,1 @@\n-      _INT_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _INT_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n@@ -567,1 +567,1 @@\n-    _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+    _INT_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n@@ -570,1 +570,1 @@\n-    _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+    _INT_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n@@ -573,2 +573,2 @@\n-  _STACK_OR_INT_REG_mask = _INT_REG_mask;\n-  _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n+  _STACK_OR_INT_REG_mask.assignFrom(_INT_REG_mask);\n+  _STACK_OR_INT_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n@@ -576,3 +576,3 @@\n-  _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;\n-  _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  _INT_NO_RAX_RDX_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n@@ -580,2 +580,2 @@\n-  _INT_NO_RCX_REG_mask = _INT_REG_mask;\n-  _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  _INT_NO_RCX_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n@@ -583,3 +583,3 @@\n-  _INT_NO_RBP_R13_REG_mask = _INT_REG_mask;\n-  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n@@ -589,1 +589,1 @@\n-  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n+  _FLOAT_REG_mask.assignFrom(VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask);\n@@ -764,1 +764,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n@@ -1670,1 +1670,1 @@\n-  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.size() : INTPRESSURE;\n@@ -1678,1 +1678,1 @@\n-  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.size() - dec_count;\n@@ -1690,1 +1690,1 @@\n-RegMask Matcher::divI_proj_mask() {\n+const RegMask& Matcher::divI_proj_mask() {\n@@ -1695,1 +1695,1 @@\n-RegMask Matcher::modI_proj_mask() {\n+const RegMask& Matcher::modI_proj_mask() {\n@@ -1700,1 +1700,1 @@\n-RegMask Matcher::divL_proj_mask() {\n+const RegMask& Matcher::divL_proj_mask() {\n@@ -1705,1 +1705,1 @@\n-RegMask Matcher::modL_proj_mask() {\n+const RegMask& Matcher::modL_proj_mask() {\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+\n+int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n+  ShouldNotCallThis();\n+}\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zNUMA_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+static uint* z_numa_id_to_node = nullptr;\n+static uint32_t* z_node_to_numa_id = nullptr;\n+\n@@ -38,0 +41,20 @@\n+  size_t configured_nodes = 0;\n+\n+  if (UseNUMA) {\n+    const size_t max_nodes = os::Linux::numa_num_configured_nodes();\n+    z_numa_id_to_node = NEW_C_HEAP_ARRAY(uint, max_nodes, mtGC);\n+    configured_nodes = os::numa_get_leaf_groups(z_numa_id_to_node, 0);\n+\n+    z_node_to_numa_id = NEW_C_HEAP_ARRAY(uint32_t, max_nodes, mtGC);\n+\n+    \/\/ Fill the array with invalid NUMA ids\n+    for (uint32_t i = 0; i < max_nodes; i++) {\n+      z_node_to_numa_id[i] = (uint32_t)-1;\n+    }\n+\n+    \/\/ Fill the reverse mappings\n+    for (uint32_t i = 0; i < configured_nodes; i++) {\n+      z_node_to_numa_id[z_numa_id_to_node[i]] = i;\n+    }\n+  }\n+\n@@ -40,1 +63,1 @@\n-      ? os::Linux::numa_max_node() + 1\n+      ? configured_nodes\n@@ -57,1 +80,1 @@\n-  return os::Linux::get_node_by_cpu(ZCPU::id());\n+  return z_node_to_numa_id[os::Linux::get_node_by_cpu(ZCPU::id())];\n@@ -66,1 +89,1 @@\n-  uint32_t id = (uint32_t)-1;\n+  int node = -1;\n@@ -68,1 +91,1 @@\n-  if (ZSyscall::get_mempolicy((int*)&id, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n+  if (ZSyscall::get_mempolicy(&node, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n@@ -73,1 +96,8 @@\n-  assert(id < _count, \"Invalid NUMA id\");\n+  DEBUG_ONLY(const int max_nodes = os::Linux::numa_num_configured_nodes();)\n+  assert(node < max_nodes, \"NUMA node is out of bounds node=%d, max=%d\", node, max_nodes);\n+\n+  return z_node_to_numa_id[node];\n+}\n+\n+int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n+  assert(numa_id < _count, \"NUMA id out of range 0 <= %ud <= %ud\", numa_id, _count);\n@@ -75,1 +105,1 @@\n-  return id;\n+  return (int)z_numa_id_to_node[numa_id];\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zNUMA_linux.cpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-  os::Linux::numa_set_preferred((int)numa_id);\n+  os::Linux::numa_set_preferred(ZNUMA::numa_id_to_node(numa_id));\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -74,3 +75,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not commit PerfData memory\\n\");\n-    }\n+    log_debug(perf)(\"could not commit PerfData memory\");\n@@ -300,1 +299,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n+    if (log_is_enabled(Debug, perf)) {\n+      LogStreamHandle(Debug, perf) log;\n@@ -302,1 +302,1 @@\n-        warning(\"directory %s is a symlink and is not secure\\n\", dirname);\n+        log.print_cr(\"directory %s is a symlink and is not secure\", dirname);\n@@ -304,1 +304,1 @@\n-        warning(\"could not open directory %s: %s\\n\", dirname, os::strerror(errno));\n+        log.print_cr(\"could not open directory %s: %s\", dirname, os::strerror(errno));\n@@ -374,3 +374,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not change to directory %s\", dirname);\n-    }\n+    log_debug(perf)(\"could not change to directory %s\", dirname);\n@@ -414,3 +412,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"fstat failed on %s: %s\\n\", filename, os::strerror(errno));\n-    }\n+    log_debug(perf)(\"fstat failed on %s: %s\", filename, os::strerror(errno));\n@@ -421,3 +417,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"file %s has multiple links\\n\", filename);\n-    }\n+    log_debug(perf)(\"file %s has multiple links\", filename);\n@@ -450,1 +444,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n+    if (log_is_enabled(Debug, perf)) {\n+      LogStreamHandle(Debug, perf) log;\n@@ -452,2 +447,1 @@\n-        warning(\"Could not retrieve passwd entry: %s\\n\",\n-                os::strerror(result));\n+        log.print_cr(\"Could not retrieve passwd entry: %s\", os::strerror(result));\n@@ -466,2 +460,1 @@\n-        warning(\"Could not retrieve passwd entry: %s\\n\",\n-                os::strerror(errno));\n+        log.print_cr(\"Could not retrieve passwd entry: %s\", os::strerror(errno));\n@@ -470,3 +463,2 @@\n-        warning(\"Could not determine user name: %s\\n\",\n-                p->pw_name == nullptr ? \"pw_name = null\" :\n-                                     \"pw_name zero length\");\n+        log.print_cr(\"Could not determine user name: %s\",\n+                     p->pw_name == nullptr ? \"pw_name = null\" : \"pw_name zero length\");\n@@ -683,1 +675,1 @@\n-  if (PrintMiscellaneous && Verbose && result == OS_ERR) {\n+  if (log_is_enabled(Debug, perf) && result == OS_ERR) {\n@@ -685,2 +677,2 @@\n-      warning(\"Could not unlink shared memory backing\"\n-              \" store file %s : %s\\n\", path, os::strerror(errno));\n+      log_debug(perf)(\"could not unlink shared memory backing store file %s : %s\",\n+                      path, os::strerror(errno));\n@@ -822,1 +814,0 @@\n-      \/\/\n@@ -825,3 +816,1 @@\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"%s directory is insecure\\n\", dirname);\n-        }\n+        log_debug(perf)(\"%s directory is insecure\", dirname);\n@@ -834,5 +823,1 @@\n-      \/\/\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"could not create directory %s: %s\\n\",\n-                dirname, os::strerror(errno));\n-      }\n+      log_debug(perf)(\"could not create directory %s: %s\", dirname, os::strerror(errno));\n@@ -875,1 +860,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n+    if (log_is_enabled(Debug, perf)) {\n+      LogStreamHandle(Debug, perf) log;\n@@ -877,1 +863,1 @@\n-        warning(\"file %s is a symlink and is not secure\\n\", filename);\n+        log.print_cr(\"file %s is a symlink and is not secure\", filename);\n@@ -879,1 +865,1 @@\n-        warning(\"could not create file %s: %s\\n\", filename, os::strerror(errno));\n+        log.print_cr(\"could not create file %s: %s\", filename, os::strerror(errno));\n@@ -927,3 +913,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not truncate shared memory file: %s\\n\", os::strerror(errno));\n-    }\n+    log_debug(perf)(\"could not truncate shared memory file: %s\", os::strerror(errno));\n@@ -936,3 +920,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not set shared memory file size: %s\\n\", os::strerror(errno));\n-    }\n+    log_debug(perf)(\"could not set shared memory file size: %s\", os::strerror(errno));\n@@ -1060,3 +1042,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"mmap failed -  %s\\n\", os::strerror(errno));\n-    }\n+    log_debug(perf)(\"mmap failed - %s\", os::strerror(errno));\n@@ -1138,3 +1118,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"fstat failed: %s\\n\", os::strerror(errno));\n-    }\n+    log_debug(perf)(\"fstat failed: %s\", os::strerror(errno));\n@@ -1215,3 +1193,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"mmap failed: %s\\n\", os::strerror(errno));\n-    }\n+    log_debug(perf)(\"mmap failed: %s\", os::strerror(errno));\n@@ -1247,1 +1223,0 @@\n-\n@@ -1250,4 +1225,1 @@\n-      \/\/\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"Reverting to non-shared PerfMemory region.\\n\");\n-      }\n+      log_debug(perf)(\"Reverting to non-shared PerfMemory region.\");\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":30,"deletions":58,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/deferredStatic.hpp\"\n@@ -170,1 +171,1 @@\n-  static OSXSemaphore sr_semaphore;\n+static DeferredStatic<OSXSemaphore> sr_semaphore;\n@@ -172,1 +173,1 @@\n-  static PosixSemaphore sr_semaphore;\n+static DeferredStatic<PosixSemaphore> sr_semaphore;\n@@ -180,1 +181,1 @@\n-static Semaphore* sig_semaphore = nullptr;\n+static DeferredStatic<Semaphore> sig_semaphore;\n@@ -354,1 +355,2 @@\n-  sig_semaphore = new Semaphore();\n+  int sem_count = 0;\n+  sig_semaphore.initialize(sem_count);\n@@ -358,1 +360,3 @@\n-  if (sig_semaphore != nullptr) {\n+  \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n+  \/\/ initialization isn't called.\n+  if (!ReduceSignalUsage) {\n@@ -361,4 +365,0 @@\n-  } else {\n-    \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n-    \/\/ initialization isn't called.\n-    assert(ReduceSignalUsage, \"signal semaphore should be created\");\n@@ -1699,1 +1699,1 @@\n-      sr_semaphore.signal();\n+      sr_semaphore->signal();\n@@ -1708,1 +1708,1 @@\n-          sr_semaphore.signal();\n+          sr_semaphore->signal();\n@@ -1734,0 +1734,3 @@\n+  int sem_count = 0;\n+  sr_semaphore.initialize(sem_count);\n+\n@@ -1781,1 +1784,1 @@\n-  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n+  assert(!sr_semaphore->trywait(), \"semaphore has invalid state\");\n@@ -1796,1 +1799,1 @@\n-    if (sr_semaphore.timedwait(2)) {\n+    if (sr_semaphore->timedwait(2)) {\n@@ -1805,1 +1808,1 @@\n-        sr_semaphore.wait();\n+        sr_semaphore->wait();\n@@ -1820,1 +1823,1 @@\n-  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n+  assert(!sr_semaphore->trywait(), \"invalid semaphore state\");\n@@ -1830,1 +1833,1 @@\n-      if (sr_semaphore.timedwait(2)) {\n+      if (sr_semaphore->timedwait(2)) {\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+\n+int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n+  ShouldNotCallThis();\n+}\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zNUMA_windows.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6262,0 +6262,103 @@\n+\n+\/*\n+ * Windows\/x64 does not use stack frames the way expected by Java:\n+ * [1] in most cases, there is no frame pointer. All locals are addressed via RSP\n+ * [2] in rare cases, when alloca() is used, a frame pointer is used, but this may\n+ *     not be RBP.\n+ * See http:\/\/msdn.microsoft.com\/en-us\/library\/ew5tede7.aspx\n+ *\n+ * So it's not possible to print the native stack using the\n+ *     while (...) {...  fr = os::get_sender_for_C_frame(&fr); }\n+ * loop in vmError.cpp. We need to roll our own loop.\n+ * This approach works for Windows AArch64 as well.\n+ *\/\n+bool os::win32::platform_print_native_stack(outputStream* st, const void* context,\n+                                            char* buf, int buf_size, address& lastpc)\n+{\n+  CONTEXT ctx;\n+  if (context != nullptr) {\n+    memcpy(&ctx, context, sizeof(ctx));\n+  } else {\n+    RtlCaptureContext(&ctx);\n+  }\n+\n+  st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n+\n+  DWORD machine_type;\n+  STACKFRAME stk;\n+  memset(&stk, 0, sizeof(stk));\n+  stk.AddrStack.Mode      = AddrModeFlat;\n+  stk.AddrFrame.Mode      = AddrModeFlat;\n+  stk.AddrPC.Mode         = AddrModeFlat;\n+\n+#if defined(_M_AMD64)\n+  stk.AddrStack.Offset    = ctx.Rsp;\n+  stk.AddrFrame.Offset    = ctx.Rbp;\n+  stk.AddrPC.Offset       = ctx.Rip;\n+  machine_type            = IMAGE_FILE_MACHINE_AMD64;\n+#elif defined(_M_ARM64)\n+  stk.AddrStack.Offset    = ctx.Sp;\n+  stk.AddrFrame.Offset    = ctx.Fp;\n+  stk.AddrPC.Offset       = ctx.Pc;\n+  machine_type            = IMAGE_FILE_MACHINE_ARM64;\n+#else\n+  #error unknown architecture\n+#endif\n+\n+  \/\/ Ensure we consider dynamically loaded DLLs\n+  SymbolEngine::refreshModuleList();\n+\n+  int count = 0;\n+  address lastpc_internal = 0;\n+  while (count++ < StackPrintLimit) {\n+    intptr_t* sp = (intptr_t*)stk.AddrStack.Offset;\n+    intptr_t* fp = (intptr_t*)stk.AddrFrame.Offset; \/\/ NOT necessarily the same as ctx.Rbp!\n+    address pc = (address)stk.AddrPC.Offset;\n+\n+    if (pc != nullptr) {\n+      if (count == 2 && lastpc_internal == pc) {\n+        \/\/ Skip it -- StackWalk64() may return the same PC\n+        \/\/ (but different SP) on the first try.\n+      } else {\n+        \/\/ Don't try to create a frame(sp, fp, pc) -- on WinX64, stk.AddrFrame\n+        \/\/ may not contain what Java expects, and may cause the frame() constructor\n+        \/\/ to crash. Let's just print out the symbolic address.\n+        frame::print_C_frame(st, buf, buf_size, pc);\n+        \/\/ print source file and line, if available\n+        char buf[128];\n+        int line_no;\n+        if (SymbolEngine::get_source_info(pc, buf, sizeof(buf), &line_no)) {\n+          st->print(\"  (%s:%d)\", buf, line_no);\n+        } else {\n+          st->print(\"  (no source info available)\");\n+        }\n+        st->cr();\n+      }\n+      lastpc_internal = pc;\n+    }\n+\n+    PVOID p = WindowsDbgHelp::symFunctionTableAccess64(GetCurrentProcess(), stk.AddrPC.Offset);\n+    if (p == nullptr) {\n+      \/\/ StackWalk64() can't handle this PC. Calling StackWalk64 again may cause crash.\n+      lastpc = lastpc_internal;\n+      break;\n+    }\n+\n+    BOOL result = WindowsDbgHelp::stackWalk64(\n+        machine_type,              \/\/ __in      DWORD MachineType,\n+        GetCurrentProcess(),       \/\/ __in      HANDLE hProcess,\n+        GetCurrentThread(),        \/\/ __in      HANDLE hThread,\n+        &stk,                      \/\/ __inout   LP STACKFRAME64 StackFrame,\n+        &ctx);                     \/\/ __inout   PVOID ContextRecord,\n+\n+    if (!result) {\n+      break;\n+    }\n+  }\n+  if (count > StackPrintLimit) {\n+    st->print_cr(\"...<more frames>...\");\n+  }\n+  st->cr();\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -65,3 +66,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not commit PerfData memory\\n\");\n-    }\n+    log_debug(perf)(\"could not commit PerfData memory\");\n@@ -93,1 +92,1 @@\n-  assert(destfile[0] != '\\0', \"invalid Perfdata file path\");\n+  assert(destfile[0] != '\\0', \"invalid PerfData file path\");\n@@ -99,4 +98,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not create Perfdata save file: %s: %s\\n\",\n-              destfile, os::strerror(errno));\n-    }\n+    log_debug(perf)(\"could not create PerfData save file: %s: %s\",\n+                    destfile, os::strerror(errno));\n@@ -108,4 +105,2 @@\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"Could not write Perfdata save file: %s: %s\\n\",\n-                  destfile, os::strerror(errno));\n-        }\n+        log_debug(perf)(\"could not write PerfData save file: %s: %s\",\n+                        destfile, os::strerror(errno));\n@@ -120,4 +115,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      if (result == OS_ERR) {\n-        warning(\"Could not close %s: %s\\n\", destfile, os::strerror(errno));\n-      }\n+    if (result == OS_ERR) {\n+      log_debug(perf)(\"could not close %s: %s\", destfile, os::strerror(errno));\n@@ -223,4 +216,2 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"could not get attributes for file %s: \"\n-                \" lasterror = %d\\n\", path, lasterror);\n-      }\n+      log_debug(perf)(\"could not get attributes for file %s: lasterror = %d\",\n+                      path, lasterror);\n@@ -237,3 +228,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"%s is a reparse point\\n\", path);\n-    }\n+    log_debug(perf)(\"%s is a reparse point\", path);\n@@ -256,4 +245,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"%s is not a directory, file attributes = \"\n-              INTPTR_FORMAT \"\\n\", path, fa);\n-    }\n+    log_debug(perf)(\"%s is not a directory, file attributes : \"\n+                    INTPTR_FORMAT, path, fa);\n@@ -495,5 +482,3 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      if (errno != ENOENT) {\n-        warning(\"Could not unlink shared memory backing\"\n-                \" store file %s : %s\\n\", path, os::strerror(errno));\n-      }\n+    if (errno != ENOENT) {\n+      log_debug(perf)(\"could not unlink shared memory backing store file %s : %s\",\n+                      path, os::strerror(errno));\n@@ -518,5 +503,3 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      DWORD lastError = GetLastError();\n-      if (lastError != ERROR_INVALID_PARAMETER) {\n-        warning(\"OpenProcess failed: %d\\n\", GetLastError());\n-      }\n+    DWORD lastError = GetLastError();\n+    if (lastError != ERROR_INVALID_PARAMETER) {\n+      log_debug(perf)(\"OpenProcess failed: %d\", lastError);\n@@ -529,3 +512,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"GetExitCodeProcess failed: %d\\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"GetExitCodeProcess failed: %d\", GetLastError());\n@@ -548,3 +529,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"bypassing file system criteria checks for %s\\n\", path);\n-    }\n+    log_debug(perf)(\"bypassing file system criteria checks for %s\", path);\n@@ -556,3 +535,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"expected device specifier in path: %s\\n\", path);\n-    }\n+    log_debug(perf)(\"expected device specifier in path: %s\", path);\n@@ -579,5 +556,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not get device information for %s: \"\n-              \" path = %s: lasterror = %d\\n\",\n-              root_path, path, GetLastError());\n-    }\n+    log_debug(perf)(\"could not get device information for %s: path = %s: lasterror = %d\",\n+                    root_path, path, GetLastError());\n@@ -589,4 +563,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"file system type %s on device %s does not support\"\n-              \" ACLs\\n\", fs_type, root_path);\n-    }\n+    log_debug(perf)(\"file system type %s on device %s does not support ACLs\",\n+                    fs_type, root_path);\n@@ -598,4 +570,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"file system type %s on device %s is compressed\\n\",\n-              fs_type, root_path);\n-    }\n+    log_debug(perf)(\"file system type %s on device %s is compressed\",\n+                    fs_type, root_path);\n@@ -707,3 +677,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"CreateFileMapping failed, lasterror = %d\\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"CreateFileMapping failed, lasterror = %d\", GetLastError());\n@@ -720,3 +688,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"file mapping already exists, lasterror = %d\\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"file mapping already exists, lasterror = %d\", GetLastError());\n@@ -786,3 +752,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"OpenProcessToken failure: lasterror = %d \\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"OpenProcessToken failure: lasterror = %d\", GetLastError());\n@@ -798,4 +762,2 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"GetTokenInformation failure: lasterror = %d,\"\n-                \" rsize = %d\\n\", lasterror, rsize);\n-      }\n+      log_debug(perf)(\"GetTokenInformation failure: lasterror = %d, rsize = %d\",\n+                      lasterror, rsize);\n@@ -811,4 +773,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"GetTokenInformation failure: lasterror = %d,\"\n-              \" rsize = %d\\n\", GetLastError(), rsize);\n-    }\n+    log_debug(perf)(\"GetTokenInformation failure: lasterror = %d, rsize = %d\",\n+                    GetLastError(), rsize);\n@@ -824,4 +784,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"GetTokenInformation failure: lasterror = %d,\"\n-              \" rsize = %d\\n\", GetLastError(), rsize);\n-    }\n+    log_debug(perf)(\"GetTokenInformation failure: lasterror = %d, rsize = %d\",\n+                    GetLastError(), rsize);\n@@ -869,4 +827,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"GetSecurityDescriptor failure: lasterror = %d \\n\",\n-              GetLastError());\n-    }\n+    log_debug(perf)(\"GetSecurityDescriptor failure: lasterror = %d\",\n+                    GetLastError());\n@@ -889,4 +845,2 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"GetAclInformation failure: lasterror = %d \\n\", GetLastError());\n-        return false;\n-      }\n+      log_debug(perf)(\"GetAclInformation failure: lasterror = %d\", GetLastError());\n+      return false;\n@@ -917,3 +871,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"InitializeAcl failure: lasterror = %d \\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"InitializeAcl failure: lasterror = %d\", GetLastError());\n@@ -930,3 +882,1 @@\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"InitializeAcl failure: lasterror = %d \\n\", GetLastError());\n-        }\n+        log_debug(perf)(\"InitializeAcl failure: lasterror = %d\", GetLastError());\n@@ -957,3 +907,1 @@\n-          if (PrintMiscellaneous && Verbose) {\n-            warning(\"AddAce failure: lasterror = %d \\n\", GetLastError());\n-          }\n+          log_debug(perf)(\"AddAce failure: lasterror = %d\", GetLastError());\n@@ -972,4 +920,2 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"AddAccessAllowedAce failure: lasterror = %d \\n\",\n-                GetLastError());\n-      }\n+      log_debug(perf)(\"AddAccessAllowedAce failure: lasterror = %d\",\n+                      GetLastError());\n@@ -988,3 +934,1 @@\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"InitializeAcl failure: lasterror = %d \\n\", GetLastError());\n-        }\n+        log_debug(perf)(\"InitializeAcl failure: lasterror = %d\", GetLastError());\n@@ -996,3 +940,1 @@\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"AddAce failure: lasterror = %d \\n\", GetLastError());\n-        }\n+        log_debug(perf)(\"AddAce failure: lasterror = %d\", GetLastError());\n@@ -1008,4 +950,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"SetSecurityDescriptorDacl failure:\"\n-              \" lasterror = %d \\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"SetSecurityDescriptorDacl failure: lasterror = %d\", GetLastError());\n@@ -1028,4 +967,1 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"SetSecurityDescriptorControl failure:\"\n-                \" lasterror = %d \\n\", GetLastError());\n-      }\n+      log_debug(perf)(\"SetSecurityDescriptorControl failure: lasterror = %d\", GetLastError());\n@@ -1060,4 +996,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"InitializeSecurityDescriptor failure: \"\n-              \"lasterror = %d \\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"InitializeSecurityDescriptor failure: lasterror = %d\", GetLastError());\n@@ -1116,5 +1049,1 @@\n-\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"AllocateAndInitializeSid failure: \"\n-              \"lasterror = %d \\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"AllocateAndInitializeSid failure: lasterror = %d\", GetLastError());\n@@ -1134,5 +1063,1 @@\n-\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"AllocateAndInitializeSid failure: \"\n-              \"lasterror = %d \\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"AllocateAndInitializeSid failure: lasterror = %d\", GetLastError());\n@@ -1239,3 +1164,1 @@\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"%s directory is insecure\\n\", dirname);\n-        }\n+        log_debug(perf)(\"%s directory is insecure\", dirname);\n@@ -1252,5 +1175,2 @@\n-        if (PrintMiscellaneous && Verbose) {\n-          lasterror = GetLastError();\n-          warning(\"SetFileSecurity failed for %s directory.  lasterror %d \\n\",\n-                                                        dirname, lasterror);\n-        }\n+        lasterror = GetLastError();\n+        log_debug(perf)(\"SetFileSecurity failed for %s directory. lasterror = %d\", dirname, lasterror);\n@@ -1259,3 +1179,1 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"CreateDirectory failed: %d\\n\", GetLastError());\n-      }\n+      log_debug(perf)(\"CreateDirectory failed: %d\", GetLastError());\n@@ -1328,3 +1246,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"could not create file %s: %d\\n\", filename, lasterror);\n-    }\n+    log_debug(perf)(\"could not create file %s: %d\", filename, lasterror);\n@@ -1356,4 +1272,2 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"Could not get status information from file %s: %s\\n\",\n-            filename, os::strerror(errno));\n-      }\n+      log_debug(perf)(\"could not get status information from file %s: %s\",\n+                      filename, os::strerror(errno));\n@@ -1372,3 +1286,1 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"could not flush file %s: %d\\n\", filename, lasterror);\n-      }\n+      log_debug(perf)(\"could not flush file %s: %d\", filename, lasterror);\n@@ -1405,4 +1317,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"OpenFileMapping failed for shared memory object %s:\"\n-              \" lasterror = %d\\n\", objectname, lasterror);\n-    }\n+    log_debug(perf)(\"OpenFileMapping failed for shared memory object %s:\"\n+                    \" lasterror = %d\", objectname, lasterror);\n@@ -1488,3 +1398,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"MapViewOfFile failed, lasterror = %d\\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"MapViewOfFile failed, lasterror = %d\", GetLastError());\n@@ -1554,3 +1462,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"stat %s failed: %s\\n\", filename, os::strerror(errno));\n-    }\n+    log_debug(perf)(\"stat %s failed: %s\", filename, os::strerror(errno));\n@@ -1562,6 +1468,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"unexpected file size: size = %zu\\n\",\n-              statbuf.st_size);\n-    }\n-    THROW_MSG_0(vmSymbols::java_io_IOException(),\n-                \"Invalid PerfMemory size\");\n+    log_debug(perf)(\"unexpected file size: size = %zu\", statbuf.st_size);\n+    THROW_MSG_0(vmSymbols::java_io_IOException(), \"Invalid PerfMemory size\");\n@@ -1640,3 +1542,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"MapViewOfFile failed, lasterror = %d\\n\", GetLastError());\n-    }\n+    log_debug(perf)(\"MapViewOfFile failed, lasterror = %d\", GetLastError());\n@@ -1711,3 +1611,1 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"Reverting to non-shared PerfMemory region.\\n\");\n-      }\n+      log_debug(perf)(\"Reverting to non-shared PerfMemory region.\");\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":70,"deletions":172,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -170,9 +170,2 @@\n-  if (is_valid(RISCV_HWPROBE_KEY_MVENDORID)) {\n-    VM_Version::mvendorid.enable_feature(query[RISCV_HWPROBE_KEY_MVENDORID].value);\n-  }\n-  if (is_valid(RISCV_HWPROBE_KEY_MARCHID)) {\n-    VM_Version::marchid.enable_feature(query[RISCV_HWPROBE_KEY_MARCHID].value);\n-  }\n-  if (is_valid(RISCV_HWPROBE_KEY_MIMPID)) {\n-    VM_Version::mimpid.enable_feature(query[RISCV_HWPROBE_KEY_MIMPID].value);\n-  }\n+  \/\/ ====== extensions ======\n+  \/\/\n@@ -180,0 +173,1 @@\n+    VM_Version::ext_a.enable_feature();\n@@ -182,5 +176,0 @@\n-    VM_Version::ext_a.enable_feature();\n-  }\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_IMA_FD)) {\n-    VM_Version::ext_f.enable_feature();\n-    VM_Version::ext_d.enable_feature();\n@@ -191,0 +180,4 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_IMA_FD)) {\n+    VM_Version::ext_d.enable_feature();\n+    VM_Version::ext_f.enable_feature();\n+  }\n@@ -205,0 +198,6 @@\n+\n+#ifndef PRODUCT\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZACAS)) {\n+    VM_Version::ext_Zacas.enable_feature();\n+  }\n+#endif\n@@ -211,0 +210,5 @@\n+#ifndef PRODUCT\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZBKB)) {\n+    VM_Version::ext_Zbkb.enable_feature();\n+  }\n+#endif\n@@ -215,5 +219,2 @@\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICBOZ)) {\n-    VM_Version::ext_Zicboz.enable_feature();\n-  }\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZBKB)) {\n-    VM_Version::ext_Zbkb.enable_feature();\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZFA)) {\n+    VM_Version::ext_Zfa.enable_feature();\n@@ -229,0 +230,12 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICBOZ)) {\n+    VM_Version::ext_Zicboz.enable_feature();\n+  }\n+  \/\/ Currently tests shows that cmove using Zicond instructions will bring\n+  \/\/ performance regression, but to get a test coverage all the time, will\n+  \/\/ still prefer to enabling it in debug version.\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICOND)) {\n+    VM_Version::ext_Zicond.enable_feature();\n+  }\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZTSO)) {\n+    VM_Version::ext_Ztso.enable_feature();\n+  }\n@@ -232,2 +245,0 @@\n-#endif\n-#ifndef PRODUCT\n@@ -238,0 +249,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZVFH)) {\n+    VM_Version::ext_Zvfh.enable_feature();\n+  }\n@@ -246,11 +260,5 @@\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZVFH)) {\n-    VM_Version::ext_Zvfh.enable_feature();\n-  }\n-#ifndef PRODUCT\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZFA)) {\n-    VM_Version::ext_Zfa.enable_feature();\n-  }\n-#endif\n-#ifndef PRODUCT\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZTSO)) {\n-    VM_Version::ext_Ztso.enable_feature();\n+\n+  \/\/ ====== non-extensions ======\n+  \/\/\n+  if (is_valid(RISCV_HWPROBE_KEY_MARCHID)) {\n+    VM_Version::marchid.enable_feature(query[RISCV_HWPROBE_KEY_MARCHID].value);\n@@ -258,4 +266,2 @@\n-#endif\n-#ifndef PRODUCT\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZACAS)) {\n-    VM_Version::ext_Zacas.enable_feature();\n+  if (is_valid(RISCV_HWPROBE_KEY_MIMPID)) {\n+    VM_Version::mimpid.enable_feature(query[RISCV_HWPROBE_KEY_MIMPID].value);\n@@ -263,5 +269,2 @@\n-  \/\/ Currently tests shows that cmove using Zicond instructions will bring\n-  \/\/ performance regression, but to get a test coverage all the time, will\n-  \/\/ still prefer to enabling it in debug version.\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICOND)) {\n-    VM_Version::ext_Zicond.enable_feature();\n+  if (is_valid(RISCV_HWPROBE_KEY_MVENDORID)) {\n+    VM_Version::mvendorid.enable_feature(query[RISCV_HWPROBE_KEY_MVENDORID].value);\n@@ -269,1 +272,0 @@\n-#endif\n@@ -280,1 +282,0 @@\n-\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -106,0 +106,8 @@\n+void VM_Version::RVExtFeatureValue::log_enabled() {\n+  log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\"\", pretty());\n+}\n+\n+void VM_Version::RVNonExtFeatureValue::log_enabled() {\n+  log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\" (%ld)\", pretty(), value());\n+}\n+\n@@ -147,3 +155,2 @@\n-      log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\" (%ld)\",\n-             _feature_list[i]->pretty(),\n-             _feature_list[i]->value());\n+      _feature_list[i]->log_enabled();\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"os_windows.hpp\"\n@@ -35,0 +36,6 @@\n+#define HAVE_PLATFORM_PRINT_NATIVE_STACK 1\n+inline bool os::platform_print_native_stack(outputStream* st, const void* context,\n+                                            char *buf, int buf_size, address& lastpc) {\n+  return os::win32::platform_print_native_stack(st, context, buf, buf_size, lastpc);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -200,92 +200,0 @@\n-#ifdef HAVE_PLATFORM_PRINT_NATIVE_STACK\n-\/*\n- * Windows\/x64 does not use stack frames the way expected by Java:\n- * [1] in most cases, there is no frame pointer. All locals are addressed via RSP\n- * [2] in rare cases, when alloca() is used, a frame pointer is used, but this may\n- *     not be RBP.\n- * See http:\/\/msdn.microsoft.com\/en-us\/library\/ew5tede7.aspx\n- *\n- * So it's not possible to print the native stack using the\n- *     while (...) {...  fr = os::get_sender_for_C_frame(&fr); }\n- * loop in vmError.cpp. We need to roll our own loop.\n- *\/\n-bool os::win32::platform_print_native_stack(outputStream* st, const void* context,\n-                                            char *buf, int buf_size, address& lastpc)\n-{\n-  CONTEXT ctx;\n-  if (context != nullptr) {\n-    memcpy(&ctx, context, sizeof(ctx));\n-  } else {\n-    RtlCaptureContext(&ctx);\n-  }\n-\n-  st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n-\n-  STACKFRAME stk;\n-  memset(&stk, 0, sizeof(stk));\n-  stk.AddrStack.Offset    = ctx.Rsp;\n-  stk.AddrStack.Mode      = AddrModeFlat;\n-  stk.AddrFrame.Offset    = ctx.Rbp;\n-  stk.AddrFrame.Mode      = AddrModeFlat;\n-  stk.AddrPC.Offset       = ctx.Rip;\n-  stk.AddrPC.Mode         = AddrModeFlat;\n-\n-  \/\/ Ensure we consider dynamically loaded dll's\n-  SymbolEngine::refreshModuleList();\n-\n-  int count = 0;\n-  address lastpc_internal = 0;\n-  while (count++ < StackPrintLimit) {\n-    intptr_t* sp = (intptr_t*)stk.AddrStack.Offset;\n-    intptr_t* fp = (intptr_t*)stk.AddrFrame.Offset; \/\/ NOT necessarily the same as ctx.Rbp!\n-    address pc = (address)stk.AddrPC.Offset;\n-\n-    if (pc != nullptr) {\n-      if (count == 2 && lastpc_internal == pc) {\n-        \/\/ Skip it -- StackWalk64() may return the same PC\n-        \/\/ (but different SP) on the first try.\n-      } else {\n-        \/\/ Don't try to create a frame(sp, fp, pc) -- on WinX64, stk.AddrFrame\n-        \/\/ may not contain what Java expects, and may cause the frame() constructor\n-        \/\/ to crash. Let's just print out the symbolic address.\n-        frame::print_C_frame(st, buf, buf_size, pc);\n-        \/\/ print source file and line, if available\n-        char buf[128];\n-        int line_no;\n-        if (SymbolEngine::get_source_info(pc, buf, sizeof(buf), &line_no)) {\n-          st->print(\"  (%s:%d)\", buf, line_no);\n-        } else {\n-          st->print(\"  (no source info available)\");\n-        }\n-        st->cr();\n-      }\n-      lastpc_internal = pc;\n-    }\n-\n-    PVOID p = WindowsDbgHelp::symFunctionTableAccess64(GetCurrentProcess(), stk.AddrPC.Offset);\n-    if (!p) {\n-      \/\/ StackWalk64() can't handle this PC. Calling StackWalk64 again may cause crash.\n-      lastpc = lastpc_internal;\n-      break;\n-    }\n-\n-    BOOL result = WindowsDbgHelp::stackWalk64(\n-        IMAGE_FILE_MACHINE_AMD64,  \/\/ __in      DWORD MachineType,\n-        GetCurrentProcess(),       \/\/ __in      HANDLE hProcess,\n-        GetCurrentThread(),        \/\/ __in      HANDLE hThread,\n-        &stk,                      \/\/ __inout   LP STACKFRAME64 StackFrame,\n-        &ctx);                     \/\/ __inout   PVOID ContextRecord,\n-\n-    if (!result) {\n-      break;\n-    }\n-  }\n-  if (count > StackPrintLimit) {\n-    st->print_cr(\"...<more frames>...\");\n-  }\n-  st->cr();\n-\n-  return true;\n-}\n-#endif \/\/ HAVE_PLATFORM_PRINT_NATIVE_STACK\n-\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":0,"deletions":92,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -902,1 +902,3 @@\n-  if( reg_class_name == nullptr ) return \"RegMask::Empty\";\n+  if (reg_class_name == nullptr) {\n+    return \"RegMask::EMPTY\";\n+  }\n@@ -905,1 +907,1 @@\n-    return \"RegMask::Empty\";\n+    return \"RegMask::EMPTY\";\n@@ -923,1 +925,1 @@\n-  const char *reg_mask = \"RegMask::Empty\";\n+  const char* reg_mask = \"RegMask::EMPTY\";\n@@ -942,1 +944,1 @@\n-  const char *regMask      = \"RegMask::Empty\";\n+  const char* regMask = \"RegMask::EMPTY\";\n@@ -971,1 +973,1 @@\n-  \/\/ Instructions producing 'Universe' use RegMask::Empty\n+  \/\/ Instructions producing 'Universe' use RegMask::EMPTY\n@@ -973,1 +975,1 @@\n-    return \"RegMask::Empty\";\n+    return \"RegMask::EMPTY\";\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2427,1 +2427,1 @@\n-  const char *reg_class = nullptr; \/\/ \"RegMask::Empty\";\n+  const char* reg_class = nullptr; \/\/ \"RegMask::EMPTY\";\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2840,1 +2840,1 @@\n-        fprintf(fp,\"  return &RegMask::Empty;\\n\");\n+        fprintf(fp, \"  return &RegMask::EMPTY;\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,0 +228,18 @@\n+      \/\/ no-fast bytecode\n+      case Bytecodes::_nofast_getfield:\n+      \/\/ fast bytecodes\n+      case Bytecodes::_fast_agetfield:\n+      case Bytecodes::_fast_bgetfield:\n+      case Bytecodes::_fast_cgetfield:\n+      case Bytecodes::_fast_dgetfield:\n+      case Bytecodes::_fast_fgetfield:\n+      case Bytecodes::_fast_igetfield:\n+      case Bytecodes::_fast_lgetfield:\n+      case Bytecodes::_fast_sgetfield:\n+        raw_bc = Bytecodes::_getfield;\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n+\n@@ -229,0 +247,13 @@\n+      \/\/ no-fast bytecode\n+      case Bytecodes::_nofast_putfield:\n+      \/\/ fast bytecodes\n+      case Bytecodes::_fast_aputfield:\n+      case Bytecodes::_fast_bputfield:\n+      case Bytecodes::_fast_zputfield:\n+      case Bytecodes::_fast_cputfield:\n+      case Bytecodes::_fast_dputfield:\n+      case Bytecodes::_fast_fputfield:\n+      case Bytecodes::_fast_iputfield:\n+      case Bytecodes::_fast_lputfield:\n+      case Bytecodes::_fast_sputfield:\n+        raw_bc = Bytecodes::_putfield;\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+#include \"runtime\/serviceThread.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -56,0 +58,2 @@\n+\/\/\n+\/\/ Note: we can't link the classes yet because SharedRuntime is not yet ready to generate adapters.\n@@ -115,0 +119,38 @@\n+\/\/ Some cached heap objects may hold references to methods in aot-linked\n+\/\/ classes (via MemberName). We need to make sure all classes are\n+\/\/ linked before executing any bytecode.\n+void AOTLinkedClassBulkLoader::link_classes(JavaThread* current) {\n+  link_classes_impl(current);\n+  if (current->has_pending_exception()) {\n+    exit_on_exception(current);\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::link_classes_impl(TRAPS) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+\n+  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n+\n+  link_classes_in_table(table->boot1(), CHECK);\n+  link_classes_in_table(table->boot2(), CHECK);\n+  link_classes_in_table(table->platform(), CHECK);\n+  link_classes_in_table(table->app(), CHECK);\n+}\n+\n+void AOTLinkedClassBulkLoader::link_classes_in_table(Array<InstanceKlass*>* classes, TRAPS) {\n+  if (classes != nullptr) {\n+    for (int i = 0; i < classes->length(); i++) {\n+      \/\/ NOTE: CDSConfig::is_preserving_verification_constraints() is required\n+      \/\/ when storing ik in the AOT cache. This means we don't have to verify\n+      \/\/ ik at all.\n+      \/\/\n+      \/\/ Without is_preserving_verification_constraints(), ik->link_class() may cause\n+      \/\/ class loading, which may result in invocation of ClassLoader::loadClass() calls,\n+      \/\/ which CANNOT happen because we are not ready to execute any Java byecodes yet\n+      \/\/ at this point.\n+      InstanceKlass* ik = classes->at(i);\n+      ik->link_class(CHECK);\n+    }\n+  }\n+}\n+\n@@ -176,4 +218,2 @@\n-\/\/ Link all java.base classes in the AOTLinkedClassTable. Of those classes,\n-\/\/ move the ones that have been AOT-initialized to the \"initialized\" state.\n-void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n-  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n+void AOTLinkedClassBulkLoader::init_javabase_classes(JavaThread* current) {\n+  init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n@@ -185,4 +225,2 @@\n-\/\/ Do the same thing as link_or_init_javabase_classes(), but for the classes that are not\n-\/\/ in the java.base module.\n-void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(JavaThread* current) {\n-  link_or_init_non_javabase_classes_impl(current);\n+void AOTLinkedClassBulkLoader::init_non_javabase_classes(JavaThread* current) {\n+  init_non_javabase_classes_impl(current);\n@@ -194,1 +232,1 @@\n-void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes_impl(TRAPS) {\n+void AOTLinkedClassBulkLoader::init_non_javabase_classes_impl(TRAPS) {\n@@ -211,3 +249,3 @@\n-  link_or_init_classes_for_loader(Handle(), table->boot2(), CHECK);\n-  link_or_init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n-  link_or_init_classes_for_loader(h_system_loader, table->app(), CHECK);\n+  init_classes_for_loader(Handle(), table->boot2(), CHECK);\n+  init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n+  init_classes_for_loader(h_system_loader, table->app(), CHECK);\n@@ -245,0 +283,1 @@\n+    oop message = java_lang_Throwable::message(current->pending_exception());\n@@ -246,1 +285,1 @@\n-                   java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n+                   message == nullptr ? \"(no message)\" : java_lang_String::as_utf8_string(message));\n@@ -292,1 +331,1 @@\n-void AOTLinkedClassBulkLoader::link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n+void AOTLinkedClassBulkLoader::init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n@@ -296,6 +335,1 @@\n-      if (ik->class_loader_data() == nullptr) {\n-        \/\/ This class is not yet loaded. We will initialize it in a later phase.\n-        \/\/ For example, we have loaded only AOTLinkedClassCategory::BOOT1 classes\n-        \/\/ but k is part of AOTLinkedClassCategory::BOOT2.\n-        continue;\n-      }\n+      assert(ik->class_loader_data() != nullptr, \"must be\");\n@@ -304,5 +338,0 @@\n-      } else {\n-        \/\/ Some cached heap objects may hold references to methods in aot-linked\n-        \/\/ classes (via MemberName). We need to make sure all classes are\n-        \/\/ linked to allow such MemberNames to be invoked.\n-        ik->link_class(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":54,"deletions":25,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -55,4 +55,5 @@\n-  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader,\n-                               Array<InstanceKlass*>* classes);\n-  static void link_or_init_non_javabase_classes_impl(TRAPS);\n-  static void link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n+  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader, Array<InstanceKlass*>* classes);\n+  static void link_classes_impl(TRAPS);\n+  static void link_classes_in_table(Array<InstanceKlass*>* classes, TRAPS);\n+  static void init_non_javabase_classes_impl(TRAPS);\n+  static void init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n@@ -70,3 +71,4 @@\n-  static void preload_classes(JavaThread* current);\n-  static void link_or_init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void link_or_init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void preload_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void link_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -138,6 +138,8 @@\n-    info._src_addr = ref->obj();\n-    info._buffered_addr = ref->obj();\n-    info._requested_addr = ref->obj();\n-    info._bytes = ref->size() * BytesPerWord;\n-    info._type = ref->msotype();\n-    _objs.append(info);\n+    if (AOTMetaspace::in_aot_cache(ref->obj())) {\n+      info._src_addr = ref->obj();\n+      info._buffered_addr = ref->obj();\n+      info._requested_addr = ref->obj();\n+      info._bytes = ref->size() * BytesPerWord;\n+      info._type = ref->msotype();\n+      _objs.append(info);\n+    }\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -967,0 +967,2 @@\n+  } else if (is_dumping_classic_static_archive()) {\n+    return is_dumping_aot_linked_classes();\n@@ -968,1 +970,0 @@\n-    \/\/ For simplicity, we don't support this optimization with the old CDS workflow.\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,0 +130,8 @@\n+      LogStreamHandle(Trace, aot, resolve) log;\n+      if (log.is_enabled()) {\n+        log.print(\"ConstantPool entries for %s to be pre-resolved:\", k->external_name());\n+        for (int i = 0; i < cp_indices.length(); i++) {\n+          log.print(\" %d\", cp_indices.at(i));\n+        }\n+        log.print(\"\\n\");\n+      }\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  if (CDSConfig::is_preserving_verification_constraints() && CDSConfig::is_dumping_final_static_archive()) {\n+  if (CDSConfig::is_preserving_verification_constraints()) {\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-    StackMapFrame* frame, int32_t target, TRAPS) const {\n+    StackMapFrame* frame, int bci, int offset, TRAPS) const {\n@@ -138,0 +138,8 @@\n+  \/\/ Jump targets must be within the method and the method size is limited. See JVMS 4.11\n+  int min_offset = -1 * max_method_code_size;\n+  if (offset < min_offset || offset > max_method_code_size) {\n+    frame->verifier()->verify_error(ErrorContext::bad_stackmap(bci, frame),\n+        \"Illegal target of jump or branch (bci %d + offset %d)\", bci, offset);\n+    return;\n+  }\n+  int target = bci + offset;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  void check_jump_target(StackMapFrame* frame, int32_t target, TRAPS) const;\n+  void check_jump_target(StackMapFrame* frame, int bci, int offset, TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,0 @@\n-      bool Bug8370217_FIXED = false;\n@@ -216,1 +215,1 @@\n-      if (EnableValhalla && Bug8370217_FIXED) {\n+      if (Arguments::enable_preview() && EnableValhalla) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -858,0 +858,22 @@\n+void SystemDictionaryShared::link_all_exclusion_check_candidates(InstanceKlass* ik) {\n+  bool need_to_link = false;\n+  {\n+    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+    ExclusionCheckCandidates candidates(ik);\n+\n+    candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+      if (!k->is_linked()) {\n+        need_to_link = true;\n+      }\n+    });\n+  }\n+  if (need_to_link) {\n+    JavaThread* THREAD = JavaThread::current();\n+    if (log_is_enabled(Info, aot, link)) {\n+      ResourceMark rm(THREAD);\n+      log_info(aot, link)(\"Link all loaded classes for %s\", ik->external_name());\n+    }\n+    AOTMetaspace::link_all_loaded_classes(THREAD);\n+  }\n+}\n+\n@@ -881,9 +903,6 @@\n-      if (!ik->is_linked()) {\n-        \/\/ should_be_excluded_impl() below doesn't link unlinked classes. We come\n-        \/\/ here only when we are trying to aot-link constant pool entries, so\n-        \/\/ we'd better link the class.\n-        JavaThread* THREAD = JavaThread::current();\n-        ik->link_class(THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION;\n-          return true; \/\/ linking failed -- let's exclude it\n+      {\n+        \/\/ fast path\n+        MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+        DumpTimeClassInfo* p = get_info_locked(ik);\n+        if (p->has_checked_exclusion()) {\n+          return p->is_excluded();\n@@ -891,4 +910,0 @@\n-\n-        \/\/ Also link any classes that were loaded for the verification of ik or its supertypes.\n-        \/\/ Otherwise we might miss the verification constraints of those classes.\n-        AOTMetaspace::link_all_loaded_classes(THREAD);\n@@ -897,0 +912,2 @@\n+      link_all_exclusion_check_candidates(ik);\n+\n@@ -899,3 +916,0 @@\n-      if (p->is_excluded()) {\n-        return true;\n-      }\n@@ -915,1 +929,1 @@\n-      \/\/ Can't take the lock as we are in safepoint.\n+      \/\/ Don't take DumpTimeTable_lock as we are in safepoint.\n@@ -1423,0 +1437,4 @@\n+\n+  get_archive(is_static_archive)->_unregistered_dictionary.iterate([&] (const RunTimeClassInfo* record) {\n+      classes->append(record->klass());\n+    });\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+  static void link_all_exclusion_check_candidates(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -819,1 +819,0 @@\n-      int target;\n@@ -1644,1 +1643,0 @@\n-          target = bcs.dest();\n@@ -1646,1 +1644,1 @@\n-            &current_frame, target, CHECK_VERIFY(this));\n+            &current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n@@ -1657,1 +1655,0 @@\n-          target = bcs.dest();\n@@ -1659,1 +1656,1 @@\n-            (&current_frame, target, CHECK_VERIFY(this));\n+            (&current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n@@ -1662,1 +1659,0 @@\n-          target = bcs.dest();\n@@ -1664,1 +1660,1 @@\n-            &current_frame, target, CHECK_VERIFY(this));\n+            &current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n@@ -1667,1 +1663,0 @@\n-          target = bcs.dest_w();\n@@ -1669,1 +1664,1 @@\n-            &current_frame, target, CHECK_VERIFY(this));\n+            &current_frame, bcs.bci(), bcs.get_offset_s4(), CHECK_VERIFY(this));\n@@ -2315,2 +2310,1 @@\n-  int target = bci + default_offset;\n-  stackmap_table->check_jump_target(current_frame, target, CHECK_VERIFY(this));\n+  stackmap_table->check_jump_target(current_frame, bci, default_offset, CHECK_VERIFY(this));\n@@ -2321,1 +2315,1 @@\n-    target = bci + (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n+    int offset = (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n@@ -2323,1 +2317,1 @@\n-      current_frame, target, CHECK_VERIFY(this));\n+      current_frame, bci, offset, CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1161,1 +1162,1 @@\n-    + align_up(ImmutableDataReferencesCounterSize, oopSize);\n+    + ImmutableDataReferencesCounterSize;\n@@ -1340,0 +1341,1 @@\n+    _immutable_data_reference_counter_offset = 0;\n@@ -1438,9 +1440,0 @@\n-  \/\/ Increment number of references to immutable data to share it between nmethods\n-  _immutable_data_size          = nm._immutable_data_size;\n-  if (_immutable_data_size > 0) {\n-    _immutable_data             = nm._immutable_data;\n-    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n-  } else {\n-    _immutable_data             = blob_end();\n-  }\n-\n@@ -1462,0 +1455,1 @@\n+  _immutable_data_size          = nm._immutable_data_size;\n@@ -1480,0 +1474,9 @@\n+  _immutable_data_reference_counter_offset = nm._immutable_data_reference_counter_offset;\n+\n+  \/\/ Increment number of references to immutable data to share it between nmethods\n+  if (_immutable_data_size > 0) {\n+    _immutable_data             = nm._immutable_data;\n+    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n+  } else {\n+    _immutable_data             = blob_end();\n+  }\n@@ -1773,1 +1776,2 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n+    _immutable_data_reference_counter_offset = _speculations_offset + align_up(speculations_len, oopSize);\n+    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n@@ -1775,1 +1779,2 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n+    _immutable_data_reference_counter_offset =  _scopes_data_offset + align_up(debug_info->data_size(), oopSize);\n+    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n@@ -2522,0 +2527,27 @@\n+#if INCLUDE_CDS\n+static GrowableArrayCHeap<nmethod*, mtClassShared>* _delayed_compiled_method_load_events = nullptr;\n+\n+void nmethod::add_delayed_compiled_method_load_event(nmethod* nm) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+  precond(!ServiceThread::has_started());\n+\n+  \/\/ We are still in single threaded stage of VM bootstrap. No need to lock.\n+  if (_delayed_compiled_method_load_events == nullptr) {\n+    _delayed_compiled_method_load_events = new GrowableArrayCHeap<nmethod*, mtClassShared>();\n+  }\n+  _delayed_compiled_method_load_events->append(nm);\n+}\n+\n+void nmethod::post_delayed_compiled_method_load_events() {\n+  precond(ServiceThread::has_started());\n+  if (_delayed_compiled_method_load_events != nullptr) {\n+    for (int i = 0; i < _delayed_compiled_method_load_events->length(); i++) {\n+      nmethod* nm = _delayed_compiled_method_load_events->at(i);\n+      nm->post_compiled_method_load_event();\n+    }\n+    delete _delayed_compiled_method_load_events;\n+    _delayed_compiled_method_load_events = nullptr;\n+  }\n+}\n+#endif\n+\n@@ -2527,0 +2559,10 @@\n+#if INCLUDE_CDS\n+  if (!ServiceThread::has_started()) {\n+    \/\/ With AOT-linked classes, we could compile wrappers for native methods before the\n+    \/\/ ServiceThread has been started, so we must delay the events to be posted later.\n+    assert(state == nullptr, \"must be\");\n+    add_delayed_compiled_method_load_event(this);\n+    return;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+  int      _immutable_data_reference_counter_offset;\n@@ -654,1 +655,1 @@\n-  address speculations_end      () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+  address speculations_end      () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n@@ -656,1 +657,1 @@\n-  address scopes_data_end       () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+  address scopes_data_end       () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n@@ -658,2 +659,1 @@\n-\n-  address immutable_data_references_counter_begin () const { return immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+  address immutable_data_references_counter_begin () const { return _immutable_data + _immutable_data_reference_counter_offset ; }\n@@ -986,0 +986,2 @@\n+  static void add_delayed_compiled_method_load_event(nmethod* nm) NOT_CDS_RETURN;\n+\n@@ -1020,0 +1022,3 @@\n+  \/\/ AOT cache support\n+  static void post_delayed_compiled_method_load_events() NOT_CDS_RETURN;\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -620,2 +620,8 @@\n-    tty->print_cr(\"Method patterns has the format:\");\n-  tty->print_cr(\"  package\/Class.method()\");\n+  tty->print_cr(\"The <method pattern> has the format '<class>.<method><descriptor>'.\");\n+  tty->cr();\n+  tty->print_cr(\"For example, the <method pattern>\");\n+  tty->cr();\n+  tty->print_cr(\"  package\/Class.method(Lpackage\/Parameter;)Lpackage\/Return;\");\n+  tty->cr();\n+  tty->print_cr(\"matches the <method> 'method' in <class> 'package\/Class' with <descriptor>\");\n+  tty->print_cr(\"'(Lpackage\/Parameter;)Lpackage\/Return;'\");\n@@ -624,1 +630,0 @@\n-  tty->print_cr(\"  package.Class::method()\");\n@@ -626,2 +631,25 @@\n-  tty->print_cr(\"The signature can be separated by an optional whitespace or comma:\");\n-  tty->print_cr(\"  package\/Class.method ()\");\n+  tty->print_cr(\"  package.Class::method(Lpackage.Parameter;)Lpackage.Return;\");\n+  tty->cr();\n+  tty->print_cr(\"A whitespace or comma can optionally separate the <descriptor> from the\");\n+  tty->print_cr(\"<method>:\");\n+  tty->cr();\n+  tty->print_cr(\"  package\/Class.method (Lpackage\/Parameter;)Lpackage\/Return;\");\n+  tty->print_cr(\"  package\/Class.method,(Lpackage\/Parameter;)Lpackage\/Return;\");\n+  tty->cr();\n+  tty->print_cr(\"The <class> and <method> accept leading and trailing '*' wildcards\");\n+  tty->print_cr(\"matching:\");\n+  tty->cr();\n+  tty->print_cr(\"  *ackage\/Clas*.*etho*(Lpackage\/Parameter;)Lpackage\/Return;\");\n+  tty->cr();\n+  tty->print_cr(\"The <descriptor> does not support explicit wildcards and\");\n+  tty->print_cr(\"always has an implicit trailing wildcard. Therefore,\");\n+  tty->cr();\n+  tty->print_cr(\"  package\/Class.method(Lpackage\/Parameter;)Lpackage\/Return;\");\n+  tty->cr();\n+  tty->print_cr(\"matches a subset of\");\n+  tty->cr();\n+  tty->print_cr(\"  package\/Class.method(Lpackage\/Parameter;)\");\n+  tty->cr();\n+  tty->print_cr(\"which matches a subset of\");\n+  tty->cr();\n+  tty->print_cr(\"  package\/Class.method\");\n@@ -629,3 +657,1 @@\n-  tty->print_cr(\"The class and method identifier can be used together with leading or\");\n-  tty->print_cr(\"trailing *'s for wildcard matching:\");\n-  tty->print_cr(\"  *ackage\/Clas*.*etho*()\");\n+  tty->print_cr(\"which matches all possible descriptors.\");\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":34,"deletions":8,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  _space->initialize(committed_region, \/* clear_space = *\/ true, \/* mangle_space = *\/ true);\n+  _space->initialize(committed_region, \/* clear_space = *\/ true);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-void G1BarrierSet::write_region(JavaThread* thread, MemRegion mr) {\n+void G1BarrierSet::write_region(MemRegion mr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,4 +87,0 @@\n-  virtual bool card_mark_must_follow_store() const {\n-    return true;\n-  }\n-\n@@ -106,2 +102,1 @@\n-  inline void write_region(MemRegion mr);\n-  void write_region(JavaThread* thread, MemRegion mr);\n+  virtual void write_region(MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,4 +71,0 @@\n-inline void G1BarrierSet::write_region(MemRegion mr) {\n-  write_region(JavaThread::current(), mr);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1394,1 +1394,0 @@\n-  bs->initialize();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-MutableNUMASpace::MutableNUMASpace(size_t alignment) : MutableSpace(alignment), _must_use_large_pages(false) {\n+MutableNUMASpace::MutableNUMASpace(size_t page_size) : MutableSpace(page_size) {\n@@ -42,1 +42,0 @@\n-  _page_size = os::vm_page_size();\n@@ -46,9 +45,0 @@\n-#ifdef LINUX\n-  \/\/ Changing the page size can lead to freeing of memory. When using large pages\n-  \/\/ and the memory has been both reserved and committed, Linux does not support\n-  \/\/ freeing parts of it.\n-    if (UseLargePages && !os::can_commit_large_page_memory()) {\n-      _must_use_large_pages = true;\n-    }\n-#endif \/\/ LINUX\n-\n@@ -63,1 +53,1 @@\n-    lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], alignment));\n+    lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], page_size));\n@@ -131,1 +121,4 @@\n-  assert(lgrp_spaces_index != -1, \"must have created spaces for all lgrp_ids\");\n+  if (lgrp_spaces_index == -1) {\n+    \/\/ Running on a CPU with no memory; pick another CPU based on %.\n+    lgrp_spaces_index = lgrp_id % lgrp_spaces()->length();\n+  }\n@@ -149,15 +142,5 @@\n-  HeapWord *start = align_up(mr.start(), page_size());\n-  HeapWord *end = align_down(mr.end(), page_size());\n-  if (end > start) {\n-    MemRegion aligned_region(start, end);\n-    assert((intptr_t)aligned_region.start()     % page_size() == 0 &&\n-           (intptr_t)aligned_region.byte_size() % page_size() == 0, \"Bad alignment\");\n-    assert(region().contains(aligned_region), \"Sanity\");\n-    \/\/ First we tell the OS which page size we want in the given range. The underlying\n-    \/\/ large page can be broken down if we require small pages.\n-    const size_t os_align = UseLargePages ? page_size() : os::vm_page_size();\n-    os::realign_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n-    \/\/ Then we uncommit the pages in the range.\n-    os::disclaim_memory((char*)aligned_region.start(), aligned_region.byte_size());\n-    \/\/ And make them local\/first-touch biased.\n-    os::numa_make_local((char*)aligned_region.start(), aligned_region.byte_size(), checked_cast<int>(lgrp_id));\n+  assert(is_aligned(mr.start(), page_size()), \"precondition\");\n+  assert(is_aligned(mr.end(), page_size()), \"precondition\");\n+\n+  if (mr.is_empty()) {\n+    return;\n@@ -165,0 +148,7 @@\n+  \/\/ First we tell the OS which page size we want in the given range. The underlying\n+  \/\/ large page can be broken down if we require small pages.\n+  os::realign_memory((char*) mr.start(), mr.byte_size(), page_size());\n+  \/\/ Then we uncommit the pages in the range.\n+  os::disclaim_memory((char*) mr.start(), mr.byte_size());\n+  \/\/ And make them local\/first-touch biased.\n+  os::numa_make_local((char*)mr.start(), mr.byte_size(), checked_cast<int>(lgrp_id));\n@@ -213,1 +203,2 @@\n-  return base_space_size() \/ lgrp_spaces()->length() * page_size();\n+  \/\/ The number of pages may not be evenly divided.\n+  return align_down(capacity_in_bytes() \/ lgrp_spaces()->length(), page_size());\n@@ -220,1 +211,1 @@\n-  size_t pages_available = base_space_size();\n+  size_t pages_available = capacity_in_bytes() \/ page_size();\n@@ -266,0 +257,5 @@\n+  assert(is_aligned(new_region.start(), page_size()), \"precondition\");\n+  assert(is_aligned(new_region.end(), page_size()), \"precondition\");\n+  assert(is_aligned(intersection.start(), page_size()), \"precondition\");\n+  assert(is_aligned(intersection.end(), page_size()), \"precondition\");\n+\n@@ -268,12 +264,0 @@\n-    \/\/ Try to coalesce small pages into a large one.\n-    if (UseLargePages && page_size() >= alignment()) {\n-      HeapWord* p = align_up(intersection.start(), alignment());\n-      if (new_region.contains(p)\n-          && pointer_delta(p, new_region.start(), sizeof(char)) >= alignment()) {\n-        if (intersection.contains(p)) {\n-          intersection = MemRegion(p, intersection.end());\n-        } else {\n-          intersection = MemRegion(p, p);\n-        }\n-      }\n-    }\n@@ -287,12 +271,0 @@\n-    \/\/ Try to coalesce small pages into a large one.\n-    if (UseLargePages && page_size() >= alignment()) {\n-      HeapWord* p = align_down(intersection.end(), alignment());\n-      if (new_region.contains(p)\n-          && pointer_delta(new_region.end(), p, sizeof(char)) >= alignment()) {\n-        if (intersection.contains(p)) {\n-          intersection = MemRegion(intersection.start(), p);\n-        } else {\n-          intersection = MemRegion(p, p);\n-        }\n-      }\n-    }\n@@ -312,0 +284,2 @@\n+  assert(is_aligned(mr.start(), page_size()), \"precondition\");\n+  assert(is_aligned(mr.end(), page_size()), \"precondition\");\n@@ -319,18 +293,8 @@\n-  \/\/ Compute chunk sizes\n-  size_t prev_page_size = page_size();\n-  set_page_size(alignment());\n-  HeapWord* rounded_bottom = align_up(bottom(), page_size());\n-  HeapWord* rounded_end = align_down(end(), page_size());\n-  size_t base_space_size_pages = pointer_delta(rounded_end, rounded_bottom, sizeof(char)) \/ page_size();\n-\n-  \/\/ Try small pages if the chunk size is too small\n-  if (base_space_size_pages \/ lgrp_spaces()->length() == 0\n-      && page_size() > os::vm_page_size()) {\n-    \/\/ Changing the page size below can lead to freeing of memory. So we fail initialization.\n-    if (_must_use_large_pages) {\n-      vm_exit_during_initialization(\"Failed initializing NUMA with large pages. Too small heap size\");\n-    }\n-    set_page_size(os::vm_page_size());\n-    rounded_bottom = align_up(bottom(), page_size());\n-    rounded_end = align_down(end(), page_size());\n-    base_space_size_pages = pointer_delta(rounded_end, rounded_bottom, sizeof(char)) \/ page_size();\n+  size_t num_pages = mr.byte_size() \/ page_size();\n+\n+  if (num_pages < (size_t)lgrp_spaces()->length()) {\n+    log_warning(gc)(\"Degraded NUMA config: #os-pages (%zu) < #CPU (%d); space-size: %zu, page-size: %zu\",\n+      num_pages, lgrp_spaces()->length(), mr.byte_size(), page_size());\n+\n+    \/\/ Keep only the first few CPUs.\n+    lgrp_spaces()->trunc_to((int)num_pages);\n@@ -338,2 +302,0 @@\n-  guarantee(base_space_size_pages \/ lgrp_spaces()->length() > 0, \"Space too small\");\n-  set_base_space_size(base_space_size_pages);\n@@ -344,1 +306,1 @@\n-    new_region = MemRegion(rounded_bottom, rounded_end);\n+    new_region = mr;\n@@ -346,4 +308,1 @@\n-    if (intersection.start() == nullptr ||\n-        intersection.end() == nullptr   ||\n-        prev_page_size > page_size()) { \/\/ If the page size got smaller we have to change\n-                                        \/\/ the page size preference for the whole space.\n+    if (intersection.is_empty()) {\n@@ -396,1 +355,1 @@\n-        new_region = MemRegion(bottom(), rounded_bottom + (chunk_byte_size >> LogHeapWordSize));\n+        new_region = MemRegion(bottom(), chunk_byte_size >> LogHeapWordSize);\n@@ -400,9 +359,8 @@\n-    } else\n-      if (i < lgrp_spaces()->length() - 1) { \/\/ Middle chunks\n-        MutableSpace *ps = lgrp_spaces()->at(i - 1)->space();\n-        new_region = MemRegion(ps->end(),\n-                               ps->end() + (chunk_byte_size >> LogHeapWordSize));\n-      } else { \/\/ Top chunk\n-        MutableSpace *ps = lgrp_spaces()->at(i - 1)->space();\n-        new_region = MemRegion(ps->end(), end());\n-      }\n+    } else if (i < lgrp_spaces()->length() - 1) { \/\/ Middle chunks\n+      MutableSpace* ps = lgrp_spaces()->at(i - 1)->space();\n+      new_region = MemRegion(ps->end(),\n+                             chunk_byte_size >> LogHeapWordSize);\n+    } else { \/\/ Top chunk\n+      MutableSpace* ps = lgrp_spaces()->at(i - 1)->space();\n+      new_region = MemRegion(ps->end(), end());\n+    }\n@@ -435,2 +393,0 @@\n-\n-    set_adaptation_cycles(samples_count());\n@@ -438,0 +394,1 @@\n+  set_adaptation_cycles(samples_count());\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":48,"deletions":91,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-    LGRPSpace(uint l, size_t alignment) : _lgrp_id(l), _allocation_failed(false) {\n-      _space = new MutableSpace(alignment);\n+    LGRPSpace(uint l, size_t page_size) : _lgrp_id(l), _allocation_failed(false) {\n+      _space = new MutableSpace(page_size);\n@@ -120,1 +120,0 @@\n-  size_t _page_size;\n@@ -123,5 +122,0 @@\n-  bool _must_use_large_pages;\n-\n-  void set_page_size(size_t psz)                     { _page_size = psz;          }\n-  size_t page_size() const                           { return _page_size;         }\n-\n@@ -134,4 +128,0 @@\n-  size_t _base_space_size;\n-  void set_base_space_size(size_t v)                 { _base_space_size = v;      }\n-  size_t base_space_size() const                     { return _base_space_size;   }\n-\n@@ -157,1 +147,1 @@\n-  MutableNUMASpace(size_t alignment);\n+  MutableNUMASpace(size_t page_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-MutableSpace::MutableSpace(size_t alignment) :\n+MutableSpace::MutableSpace(size_t page_size) :\n@@ -39,1 +39,1 @@\n-  _alignment(alignment),\n+  _page_size(page_size),\n@@ -42,5 +42,1 @@\n-  _end(nullptr)\n-{\n-  assert(MutableSpace::alignment() % os::vm_page_size() == 0,\n-         \"Space should be aligned\");\n-}\n+  _end(nullptr) {}\n@@ -48,12 +44,6 @@\n-void MutableSpace::numa_setup_pages(MemRegion mr, size_t page_size, bool clear_space) {\n-  if (!mr.is_empty()) {\n-    HeapWord *start = align_up(mr.start(), page_size);\n-    HeapWord *end =   align_down(mr.end(), page_size);\n-    if (end > start) {\n-      size_t size = pointer_delta(end, start, sizeof(char));\n-      if (clear_space) {\n-        \/\/ Prefer page reallocation to migration.\n-        os::disclaim_memory((char*)start, size);\n-      }\n-      os::numa_make_global((char*)start, size);\n-    }\n+void MutableSpace::numa_setup_pages(MemRegion mr, bool clear_space) {\n+  assert(is_aligned(mr.start(), page_size()), \"precondition\");\n+  assert(is_aligned(mr.end(), page_size()), \"precondition\");\n+\n+  if (mr.is_empty()) {\n+    return;\n@@ -61,0 +51,6 @@\n+\n+  if (clear_space) {\n+    \/\/ Prefer page reallocation to migration.\n+    os::disclaim_memory((char*) mr.start(), mr.byte_size());\n+  }\n+  os::numa_make_global((char*) mr.start(), mr.byte_size());\n@@ -108,2 +104,0 @@\n-    size_t page_size = alignment();\n-\n@@ -111,2 +105,2 @@\n-      numa_setup_pages(head, page_size, clear_space);\n-      numa_setup_pages(tail, page_size, clear_space);\n+      numa_setup_pages(head, clear_space);\n+      numa_setup_pages(tail, clear_space);\n@@ -116,1 +110,0 @@\n-      size_t pretouch_page_size = UseLargePages ? page_size : os::vm_page_size();\n@@ -118,1 +111,1 @@\n-                             pretouch_page_size, pretouch_workers);\n+                             page_size(), pretouch_workers);\n@@ -121,1 +114,1 @@\n-                             pretouch_page_size, pretouch_workers);\n+                             page_size(), pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  size_t _alignment;\n+  size_t _page_size;\n@@ -59,1 +59,1 @@\n-  void numa_setup_pages(MemRegion mr, size_t page_size, bool clear_space);\n+  void numa_setup_pages(MemRegion mr, bool clear_space);\n@@ -64,1 +64,4 @@\n- public:\n+protected:\n+  size_t page_size() const                 { return _page_size;         }\n+\n+public:\n@@ -80,2 +83,0 @@\n-  size_t alignment()                       { return _alignment; }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,1 +50,4 @@\n-  ReservedSpace backing_store = MemoryReserver::reserve(bytes_to_reserve, mtGC);\n+  ReservedSpace backing_store = MemoryReserver::reserve(bytes_to_reserve,\n+                                                        os::vm_allocation_granularity(),\n+                                                        os::vm_page_size(),\n+                                                        mtGC);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -106,5 +106,0 @@\n-\/\/ The alignment used for spaces in young gen and old gen\n-static size_t default_space_alignment() {\n-  return 64 * K * HeapWordSize;\n-}\n-\n@@ -114,1 +109,1 @@\n-  SpaceAlignment = default_space_alignment();\n+  SpaceAlignment = ParallelScavengeHeap::default_space_alignment();\n@@ -126,0 +121,6 @@\n+  if (!UseLargePages) {\n+    ParallelScavengeHeap::set_desired_page_size(os::vm_page_size());\n+    return;\n+  }\n+\n+  \/\/ If using large-page, need to update SpaceAlignment so that spaces are page-size aligned.\n@@ -128,0 +129,6 @@\n+  ParallelScavengeHeap::set_desired_page_size(page_sz);\n+\n+  if (page_sz == os::vm_page_size()) {\n+    log_warning(gc, heap)(\"MinHeapSize (%zu) must be large enough for 4 * page-size; Disabling UseLargePages for heap\", MinHeapSize);\n+    return;\n+  }\n@@ -129,3 +136,2 @@\n-  \/\/ Can a page size be something else than a power of two?\n-  assert(is_power_of_2((intptr_t)page_sz), \"must be a power of 2\");\n-  size_t new_alignment = align_up(page_sz, SpaceAlignment);\n+  \/\/ Space is largepage-aligned.\n+  size_t new_alignment = page_sz;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+size_t ParallelScavengeHeap::_desired_page_size = 0;\n@@ -68,1 +69,7 @@\n-  ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment);\n+  assert(_desired_page_size != 0, \"Should be initialized\");\n+  ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment, _desired_page_size);\n+  \/\/ Adjust SpaceAlignment based on actually used large page size.\n+  if (UseLargePages) {\n+    SpaceAlignment = MAX2(heap_rs.page_size(), default_space_alignment());\n+  }\n+  assert(is_aligned(SpaceAlignment, heap_rs.page_size()), \"inv\");\n@@ -82,1 +89,0 @@\n-  barrier_set->initialize();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+  \/\/ At startup, calculate the desired OS page-size based on heap size and large-page flags.\n+  static size_t _desired_page_size;\n+\n@@ -131,0 +134,12 @@\n+  \/\/ The alignment used for spaces in young gen and old gen\n+  constexpr static size_t default_space_alignment() {\n+    constexpr size_t alignment = 64 * K * HeapWordSize;\n+    static_assert(is_power_of_2(alignment), \"inv\");\n+    return alignment;\n+  }\n+\n+  static void set_desired_page_size(size_t page_size) {\n+    assert(is_power_of_2(page_size), \"precondition\");\n+    _desired_page_size = page_size;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-  inline void push(PartialArrayState* stat);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,4 +63,0 @@\n-inline void ParCompactionManager::push(PartialArrayState* stat) {\n-  marking_stack()->push(ScannerTask(stat));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  _object_space = new MutableSpace(virtual_space()->alignment());\n+  _object_space = new MutableSpace(virtual_space()->page_size());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-  _alignment(alignment)\n-{\n+  _alignment(alignment),\n+  _page_size(rs.page_size()) {\n@@ -91,1 +91,2 @@\n-  assert(is_aligned(_alignment, os::vm_page_size()), \"bad alignment\");\n+  assert(is_aligned(_page_size, os::vm_page_size()), \"bad alignment\");\n+  assert(is_aligned(_alignment, _page_size), \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+  \/\/ OS page size used. If using Transparent Huge Pages, it's the desired large page-size.\n+  const size_t _page_size;\n+\n@@ -71,0 +74,1 @@\n+  size_t page_size()          const { return _page_size; }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    _eden_space = new MutableNUMASpace(virtual_space()->alignment());\n+    _eden_space = new MutableNUMASpace(virtual_space()->page_size());\n@@ -88,1 +88,1 @@\n-    _eden_space = new MutableSpace(virtual_space()->alignment());\n+    _eden_space = new MutableSpace(virtual_space()->page_size());\n@@ -90,2 +90,2 @@\n-  _from_space = new MutableSpace(virtual_space()->alignment());\n-  _to_space   = new MutableSpace(virtual_space()->alignment());\n+  _from_space = new MutableSpace(virtual_space()->page_size());\n+  _to_space   = new MutableSpace(virtual_space()->page_size());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  nonstatic_field(PSVirtualSpace,              _page_size,                                    const size_t)                          \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/vmStructs_parallelgc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -228,6 +228,0 @@\n-  MemRegion cmr((HeapWord*)_virtual_space.low(),\n-                (HeapWord*)_virtual_space.high());\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  gch->rem_set()->resize_covered_region(cmr);\n-\n@@ -238,0 +232,2 @@\n+  init_spaces();\n+\n@@ -259,1 +255,0 @@\n-  compute_space_boundaries(0, SpaceDecorator::Clear, SpaceDecorator::Mangle);\n@@ -271,9 +266,4 @@\n-void DefNewGeneration::compute_space_boundaries(uintx minimum_eden_size,\n-                                                bool clear_space,\n-                                                bool mangle_space) {\n-  \/\/ If the spaces are being cleared (only done at heap initialization\n-  \/\/ currently), the survivor spaces need not be empty.\n-  \/\/ Otherwise, no care is taken for used areas in the survivor spaces\n-  \/\/ so check.\n-  assert(clear_space || (to()->is_empty() && from()->is_empty()),\n-    \"Initialization of the survivor spaces assumes these are empty\");\n+void DefNewGeneration::init_spaces() {\n+  \/\/ Using layout: from, to, eden, so only from can be non-empty.\n+  assert(eden()->is_empty(), \"precondition\");\n+  assert(to()->is_empty(), \"precondition\");\n@@ -281,11 +271,2 @@\n-  \/\/ Compute sizes\n-  uintx size = _virtual_space.committed_size();\n-  uintx survivor_size = compute_survivor_size(size, SpaceAlignment);\n-  uintx eden_size = size - (2*survivor_size);\n-  if (eden_size > max_eden_size()) {\n-    \/\/ Need to reduce eden_size to satisfy the max constraint. The delta needs\n-    \/\/ to be 2*SpaceAlignment aligned so that both survivors are properly\n-    \/\/ aligned.\n-    uintx eden_delta = align_up(eden_size - max_eden_size(), 2*SpaceAlignment);\n-    eden_size     -= eden_delta;\n-    survivor_size += eden_delta\/2;\n+  if (!from()->is_empty()) {\n+    assert((char*) from()->bottom() == _virtual_space.low(), \"inv\");\n@@ -293,1 +274,0 @@\n-  assert(eden_size > 0 && survivor_size <= eden_size, \"just checking\");\n@@ -295,11 +275,7 @@\n-  if (eden_size < minimum_eden_size) {\n-    \/\/ May happen due to 64Kb rounding, if so adjust eden size back up\n-    minimum_eden_size = align_up(minimum_eden_size, SpaceAlignment);\n-    uintx maximum_survivor_size = (size - minimum_eden_size) \/ 2;\n-    uintx unaligned_survivor_size =\n-      align_down(maximum_survivor_size, SpaceAlignment);\n-    survivor_size = MAX2(unaligned_survivor_size, SpaceAlignment);\n-    eden_size = size - (2*survivor_size);\n-    assert(eden_size > 0 && survivor_size <= eden_size, \"just checking\");\n-    assert(eden_size >= minimum_eden_size, \"just checking\");\n-  }\n+  \/\/ Compute sizes\n+  size_t size = _virtual_space.committed_size();\n+  size_t survivor_size = compute_survivor_size(size, SpaceAlignment);\n+  assert(survivor_size >= from()->used(), \"inv\");\n+  assert(size > 2 * survivor_size, \"inv\");\n+  size_t eden_size = size - (2 * survivor_size);\n+  assert(eden_size > 0 && survivor_size <= eden_size, \"just checking\");\n@@ -307,4 +283,5 @@\n-  char *eden_start = _virtual_space.low();\n-  char *from_start = eden_start + eden_size;\n-  char *to_start   = from_start + survivor_size;\n-  char *to_end     = to_start   + survivor_size;\n+  \/\/ layout: from, to, eden\n+  char* from_start = _virtual_space.low();\n+  char* to_start = from_start + survivor_size;\n+  char* eden_start = to_start + survivor_size;\n+  char* eden_end = eden_start + eden_size;\n@@ -312,2 +289,1 @@\n-  assert(to_end == _virtual_space.high(), \"just checking\");\n-  assert(is_aligned(eden_start, SpaceAlignment), \"checking alignment\");\n+  assert(eden_end == _virtual_space.high(), \"just checking\");\n@@ -316,0 +292,2 @@\n+  assert(is_aligned(eden_start, SpaceAlignment), \"checking alignment\");\n+  assert(is_aligned(eden_end, SpaceAlignment), \"checking alignment\");\n@@ -317,1 +295,0 @@\n-  MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)from_start);\n@@ -319,6 +296,2 @@\n-  MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)to_end);\n-\n-  \/\/ A minimum eden size implies that there is a part of eden that\n-  \/\/ is being used and that affects the initialization of any\n-  \/\/ newly formed eden.\n-  bool live_in_eden = minimum_eden_size > 0;\n+  MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)eden_start);\n+  MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);\n@@ -327,12 +300,11 @@\n-  eden()->initialize(edenMR,\n-                     clear_space && !live_in_eden,\n-                     SpaceDecorator::Mangle);\n-  \/\/ If clear_space and live_in_eden, we will not have cleared any\n-  \/\/ portion of eden above its top. This can cause newly\n-  \/\/ expanded space not to be mangled if using ZapUnusedHeapArea.\n-  \/\/ We explicitly do such mangling here.\n-  if (ZapUnusedHeapArea && clear_space && live_in_eden && mangle_space) {\n-    eden()->mangle_unused_area();\n-  }\n-  from()->initialize(fromMR, clear_space, mangle_space);\n-  to()->initialize(toMR, clear_space, mangle_space);\n+  from()->initialize(fromMR, from()->is_empty());\n+  to()->initialize(toMR, true);\n+  eden()->initialize(edenMR, true);\n+\n+  post_resize();\n+}\n+\n+void DefNewGeneration::post_resize() {\n+  MemRegion cmr((HeapWord*)_virtual_space.low(),\n+                (HeapWord*)_virtual_space.high());\n+  SerialHeap::heap()->rem_set()->resize_covered_region(cmr);\n@@ -354,1 +326,3 @@\n-  HeapWord* prev_high = (HeapWord*) _virtual_space.high();\n+  assert(bytes != 0, \"precondition\");\n+  assert(is_aligned(bytes, SpaceAlignment), \"precondition\");\n+\n@@ -356,7 +330,2 @@\n-  if (success && ZapUnusedHeapArea) {\n-    \/\/ Mangle newly committed space immediately because it\n-    \/\/ can be done here more simply that after the new\n-    \/\/ spaces have been computed.\n-    HeapWord* new_high = (HeapWord*) _virtual_space.high();\n-    MemRegion mangle_region(prev_high, new_high);\n-    SpaceMangler::mangle_region(mangle_region);\n+  if (!success) {\n+    log_info(gc)(\"Failed to expand young-gen by %zu bytes\", bytes);\n@@ -368,0 +337,11 @@\n+void DefNewGeneration::expand_eden_by(size_t delta_bytes) {\n+  if (!expand(delta_bytes)) {\n+    return;\n+  }\n+\n+  MemRegion eden_mr{eden()->bottom(), (HeapWord*)_virtual_space.high()};\n+  eden()->initialize(eden_mr, eden()->is_empty());\n+\n+  post_resize();\n+}\n+\n@@ -400,12 +380,2 @@\n-void DefNewGeneration::compute_new_size() {\n-  \/\/ This is called after a GC that includes the old generation, so from-space\n-  \/\/ will normally be empty.\n-  \/\/ Note that we check both spaces, since if scavenge failed they revert roles.\n-  \/\/ If not we bail out (otherwise we would have to relocate the objects).\n-  if (!from()->is_empty() || !to()->is_empty()) {\n-    return;\n-  }\n-\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  size_t old_size = gch->old_gen()->capacity();\n+size_t DefNewGeneration::calculate_desired_young_gen_bytes() const {\n+  size_t old_size = SerialHeap::heap()->old_gen()->capacity();\n@@ -432,8 +402,32 @@\n-  assert(desired_new_size <= max_new_size, \"just checking\");\n-\n-  bool changed = false;\n-  if (desired_new_size > new_size_before) {\n-    size_t change = desired_new_size - new_size_before;\n-    assert(change % alignment == 0, \"just checking\");\n-    if (expand(change)) {\n-       changed = true;\n+  if (!from()->is_empty()) {\n+    \/\/ Mininum constraint to hold all live objs inside from-space.\n+    size_t min_survivor_size = align_up(from()->used(), alignment);\n+\n+    \/\/ SurvivorRatio := eden_size \/ survivor_size\n+    \/\/ young-gen-size = eden_size                     + 2 * survivor_size\n+    \/\/                = SurvivorRatio * survivor_size + 2 * survivor_size\n+    \/\/                = (SurvivorRatio + 2) * survivor_size\n+    size_t min_young_gen_size = min_survivor_size * (SurvivorRatio + 2);\n+\n+    desired_new_size = MAX2(min_young_gen_size, desired_new_size);\n+  }\n+  assert(is_aligned(desired_new_size, alignment), \"postcondition\");\n+\n+  return desired_new_size;\n+}\n+\n+void DefNewGeneration::resize_inner() {\n+  assert(eden()->is_empty(), \"precondition\");\n+  assert(to()->is_empty(), \"precondition\");\n+\n+  size_t current_young_gen_size_bytes = _virtual_space.committed_size();\n+  size_t desired_young_gen_size_bytes = calculate_desired_young_gen_bytes();\n+  if (current_young_gen_size_bytes == desired_young_gen_size_bytes) {\n+    return;\n+  }\n+\n+  \/\/ Commit\/uncommit\n+  if (desired_young_gen_size_bytes > current_young_gen_size_bytes) {\n+    size_t delta_bytes = desired_young_gen_size_bytes - current_young_gen_size_bytes;\n+    if (!expand(delta_bytes)) {\n+      return;\n@@ -441,31 +435,43 @@\n-    \/\/ If the heap failed to expand to the desired size,\n-    \/\/ \"changed\" will be false.  If the expansion failed\n-    \/\/ (and at this point it was expected to succeed),\n-    \/\/ ignore the failure (leaving \"changed\" as false).\n-  }\n-  if (desired_new_size < new_size_before && eden()->is_empty()) {\n-    \/\/ bail out of shrinking if objects in eden\n-    size_t change = new_size_before - desired_new_size;\n-    assert(change % alignment == 0, \"just checking\");\n-    _virtual_space.shrink_by(change);\n-    changed = true;\n-  }\n-  if (changed) {\n-    \/\/ The spaces have already been mangled at this point but\n-    \/\/ may not have been cleared (set top = bottom) and should be.\n-    \/\/ Mangling was done when the heap was being expanded.\n-    compute_space_boundaries(eden()->used(),\n-                             SpaceDecorator::Clear,\n-                             SpaceDecorator::DontMangle);\n-    MemRegion cmr((HeapWord*)_virtual_space.low(),\n-                  (HeapWord*)_virtual_space.high());\n-    gch->rem_set()->resize_covered_region(cmr);\n-\n-    log_debug(gc, ergo, heap)(\n-        \"New generation size %zuK->%zuK [eden=%zuK,survivor=%zuK]\",\n-        new_size_before\/K, _virtual_space.committed_size()\/K,\n-        eden()->capacity()\/K, from()->capacity()\/K);\n-    log_trace(gc, ergo, heap)(\n-        \"  [allowed %zuK extra for %d threads]\",\n-          thread_increase_size\/K, threads_count);\n-      }\n+  } else {\n+    size_t delta_bytes = current_young_gen_size_bytes - desired_young_gen_size_bytes;\n+    _virtual_space.shrink_by(delta_bytes);\n+  }\n+\n+  assert(desired_young_gen_size_bytes == _virtual_space.committed_size(), \"inv\");\n+\n+  init_spaces();\n+\n+  log_debug(gc, ergo, heap)(\"New generation size %zuK->%zuK [eden=%zuK,survivor=%zuK]\",\n+    current_young_gen_size_bytes\/K, _virtual_space.committed_size()\/K,\n+    eden()->capacity()\/K, from()->capacity()\/K);\n+}\n+\n+void DefNewGeneration::resize_after_young_gc() {\n+  \/\/ Called only after successful young-gc.\n+  assert(eden()->is_empty(), \"precondition\");\n+  assert(to()->is_empty(), \"precondition\");\n+\n+  if ((char*)to()->bottom() == _virtual_space.low()) {\n+    \/\/ layout: to, from, eden; can't resize.\n+    return;\n+  }\n+\n+  assert((char*)from()->bottom() == _virtual_space.low(), \"inv\");\n+  resize_inner();\n+}\n+\n+void DefNewGeneration::resize_after_full_gc() {\n+  if (eden()->is_empty() && from()->is_empty() && to()->is_empty()) {\n+    resize_inner();\n+    return;\n+  }\n+\n+  \/\/ Usually the young-gen is empty after full-gc.\n+  \/\/ This is the extreme case; expand young-gen to its max size.\n+  if (_virtual_space.uncommitted_size() == 0) {\n+    \/\/ Already at its max size.\n+    return;\n+  }\n+\n+  \/\/ Keep from\/to and expand eden.\n+  expand_eden_by(_virtual_space.uncommitted_size());\n@@ -486,1 +492,0 @@\n-\n@@ -492,1 +497,0 @@\n-\n@@ -500,1 +504,2 @@\n-  return reserved_bytes - compute_survivor_size(reserved_bytes, SpaceAlignment);\n+  const size_t min_survivor_bytes = SpaceAlignment;\n+  return reserved_bytes - min_survivor_bytes;\n@@ -592,1 +597,0 @@\n-  to()->clear(SpaceDecorator::Mangle);\n@@ -842,7 +846,12 @@\n-HeapWord* DefNewGeneration::allocate(size_t word_size) {\n-  \/\/ This is the slow-path allocation for the DefNewGeneration.\n-  \/\/ Most allocations are fast-path in compiled code.\n-  \/\/ We try to allocate from the eden.  If that works, we are happy.\n-  \/\/ Note that since DefNewGeneration supports lock-free allocation, we\n-  \/\/ have to use it here, as well.\n-  HeapWord* result = eden()->par_allocate(word_size);\n+HeapWord* DefNewGeneration::expand_and_allocate(size_t word_size) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+  assert(Thread::current()->is_VM_thread(), \"precondition\");\n+\n+  size_t eden_free_bytes = eden()->free();\n+  size_t requested_bytes = word_size * HeapWordSize;\n+  if (eden_free_bytes < requested_bytes) {\n+    size_t expand_bytes = requested_bytes - eden_free_bytes;\n+    expand_eden_by(align_up(expand_bytes, SpaceAlignment));\n+  }\n+\n+  HeapWord* result = eden()->allocate(word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":143,"deletions":134,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -134,0 +134,7 @@\n+  size_t calculate_desired_young_gen_bytes() const;\n+\n+  void expand_eden_by(size_t delta_bytes);\n+\n+  void resize_inner();\n+  void post_resize();\n+\n@@ -186,2 +193,0 @@\n-  \/\/ Allocate requested size or return null; single-threaded and lock-free versions.\n-  HeapWord* allocate(size_t word_size);\n@@ -189,0 +194,1 @@\n+  HeapWord* expand_and_allocate(size_t word_size);\n@@ -199,2 +205,2 @@\n-  \/\/ GC support\n-  void compute_new_size();\n+  void resize_after_young_gc();\n+  void resize_after_full_gc();\n@@ -223,7 +229,3 @@\n- protected:\n-  \/\/ If clear_space is true, clear the survivor spaces.  Eden is\n-  \/\/ cleared if the minimum size of eden is 0.  If mangle_space\n-  \/\/ is true, also mangle the space in debug mode.\n-  void compute_space_boundaries(uintx minimum_eden_size,\n-                                bool clear_space,\n-                                bool mangle_space);\n+ private:\n+  \/\/ Initialize eden\/from\/to spaces.\n+  void init_spaces();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-  bs->initialize();\n@@ -272,1 +271,1 @@\n-  HeapWord* result = _young_gen->allocate(size);\n+  HeapWord* result = _young_gen->expand_and_allocate(size);\n@@ -274,1 +273,1 @@\n-  if (result == nullptr) {\n+  if (result == nullptr && !is_tlab) {\n@@ -391,0 +390,1 @@\n+    _young_gen->resize_after_young_gc();\n@@ -397,2 +397,0 @@\n-  _young_gen->compute_new_size();\n-\n@@ -584,1 +582,1 @@\n-  _young_gen->compute_new_size();\n+  _young_gen->resize_after_full_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,4 +58,4 @@\n-\/\/ +-----------------+--------+--------+--------+---------------+-------------------+\n-\/\/ |       eden      |  from  |   to   |        |      old      |                   |\n-\/\/ |                 |  (to)  | (from) |        |               |                   |\n-\/\/ +-----------------+--------+--------+--------+---------------+-------------------+\n+\/\/ +--------+--------+-----------------+--------+---------------+-------------------+\n+\/\/ |  from  |   to   |       eden      |        |      old      |                   |\n+\/\/ |  (to)  | (from) |                 |        |               |                   |\n+\/\/ +--------+--------+-----------------+--------+---------------+-------------------+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  _the_space->initialize(MemRegion(bottom, end), SpaceDecorator::Clear, SpaceDecorator::Mangle);\n+  _the_space->initialize(MemRegion(bottom, end), SpaceDecorator::Clear);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  _preserve.Insert(OptoReg::as_OptoReg(vm_reg));\n+  _preserve.insert(OptoReg::as_OptoReg(vm_reg));\n@@ -131,1 +131,1 @@\n-    _preserve.Remove(OptoReg::as_OptoReg(vm_reg));\n+    _preserve.remove(OptoReg::as_OptoReg(vm_reg));\n@@ -1178,1 +1178,1 @@\n-      new_live.OR(live[succ_id]);\n+      new_live.or_with(live[succ_id]);\n@@ -1189,1 +1189,1 @@\n-          regs->OR(new_live);\n+          regs->or_with(new_live);\n@@ -1197,1 +1197,1 @@\n-        new_live.Remove(first);\n+        new_live.remove(first);\n@@ -1200,1 +1200,1 @@\n-        new_live.Remove(second);\n+        new_live.remove(second);\n@@ -1209,1 +1209,1 @@\n-          new_live.Insert(first);\n+          new_live.insert(first);\n@@ -1212,1 +1212,1 @@\n-          new_live.Insert(second);\n+          new_live.insert(second);\n@@ -1220,1 +1220,1 @@\n-          regs->OR(new_live);\n+          regs->or_with(new_live);\n@@ -1226,2 +1226,2 @@\n-    new_live.SUBTRACT(old_live);\n-    if (!new_live.is_Empty()) {\n+    new_live.subtract(old_live);\n+    if (!new_live.is_empty()) {\n@@ -1229,1 +1229,1 @@\n-      old_live.OR(new_live);\n+      old_live.or_with(new_live);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  _defer_initial_card_mark(false),\n@@ -69,1 +68,0 @@\n-  _defer_initial_card_mark(false),\n@@ -73,4 +71,0 @@\n-void CardTableBarrierSet::initialize() {\n-  initialize_deferred_card_mark_barriers();\n-}\n-\n@@ -111,3 +105,1 @@\n-\/\/     that this barrier need only be applied to a non-young write,\n-\/\/     but, because of the presence of concurrent refinement,\n-\/\/     must strictly follow the oop-store.\n+\/\/     that this barrier need only be applied to a non-young write.\n@@ -123,2 +115,0 @@\n-  \/\/ If a previous card-mark was deferred, flush it now.\n-  flush_deferred_card_mark_barrier(thread);\n@@ -127,3 +117,0 @@\n-    \/\/ The deferred_card_mark region should be empty\n-    \/\/ following the flush above.\n-    assert(thread->deferred_card_mark().is_empty(), \"Error\");\n@@ -133,7 +120,2 @@\n-    if (_defer_initial_card_mark) {\n-      \/\/ Defer the card mark\n-      thread->set_deferred_card_mark(mr);\n-    } else {\n-      \/\/ Do the card mark\n-      write_region(mr);\n-    }\n+    \/\/ Do the card mark\n+    write_region(mr);\n@@ -143,49 +125,0 @@\n-\n-void CardTableBarrierSet::initialize_deferred_card_mark_barriers() {\n-  \/\/ Used for ReduceInitialCardMarks (when COMPILER2 or JVMCI is used);\n-  \/\/ otherwise remains unused.\n-#if COMPILER2_OR_JVMCI\n-  _defer_initial_card_mark = CompilerConfig::is_c2_or_jvmci_compiler_enabled() && ReduceInitialCardMarks\n-                             && (DeferInitialCardMark || card_mark_must_follow_store());\n-#else\n-  assert(_defer_initial_card_mark == false, \"Who would set it?\");\n-#endif\n-}\n-\n-void CardTableBarrierSet::flush_deferred_card_mark_barrier(JavaThread* thread) {\n-#if COMPILER2_OR_JVMCI\n-  MemRegion deferred = thread->deferred_card_mark();\n-  if (!deferred.is_empty()) {\n-    assert(_defer_initial_card_mark, \"Otherwise should be empty\");\n-    {\n-      \/\/ Verify that the storage points to a parsable object in heap\n-      DEBUG_ONLY(oop old_obj = cast_to_oop(deferred.start());)\n-      assert(!_card_table->is_in_young(old_obj),\n-             \"Else should have been filtered in on_slowpath_allocation_exit()\");\n-      assert(oopDesc::is_oop(old_obj), \"Not an oop\");\n-      assert(deferred.word_size() == old_obj->size(),\n-             \"Mismatch: multiple objects?\");\n-    }\n-    write_region(thread, deferred);\n-    \/\/ \"Clear\" the deferred_card_mark field\n-    thread->set_deferred_card_mark(MemRegion());\n-  }\n-  assert(thread->deferred_card_mark().is_empty(), \"invariant\");\n-#else\n-  assert(!_defer_initial_card_mark, \"Should be false\");\n-  assert(thread->deferred_card_mark().is_empty(), \"Should be empty\");\n-#endif\n-}\n-\n-void CardTableBarrierSet::on_thread_detach(Thread* thread) {\n-  \/\/ The deferred store barriers must all have been flushed to the\n-  \/\/ card-table (or other remembered set structure) before GC starts\n-  \/\/ processing the card-table (or other remembered set).\n-  if (thread->is_Java_thread()) { \/\/ Only relevant for Java threads.\n-    flush_deferred_card_mark_barrier(JavaThread::cast(thread));\n-  }\n-}\n-\n-bool CardTableBarrierSet::card_mark_must_follow_store() const {\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-  \/\/ Used in support of ReduceInitialCardMarks; only consulted if COMPILER2\n-  \/\/ or INCLUDE_JVMCI is being used\n-  bool       _defer_initial_card_mark;\n@@ -67,7 +64,0 @@\n-  void initialize();\n-\n-  void write_region(JavaThread* thread, MemRegion mr) {\n-    write_region(mr);\n-  }\n-\n- public:\n@@ -83,19 +73,0 @@\n-  \/\/ ReduceInitialCardMarks\n-  void initialize_deferred_card_mark_barriers();\n-\n-  \/\/ If the CollectedHeap was asked to defer a store barrier above,\n-  \/\/ this informs it to flush such a deferred store barrier to the\n-  \/\/ remembered set.\n-  void flush_deferred_card_mark_barrier(JavaThread* thread);\n-\n-  \/\/ If a compiler is eliding store barriers for TLAB-allocated objects,\n-  \/\/ we will be informed of a slow-path allocation by a call\n-  \/\/ to on_slowpath_allocation_exit() below. Such a call precedes the\n-  \/\/ initialization of the object itself, and no post-store-barriers will\n-  \/\/ be issued. Some heap types require that the barrier strictly follows\n-  \/\/ the initializing stores. (This is currently implemented by deferring the\n-  \/\/ barrier until the next slow-path allocation or gc-related safepoint.)\n-  \/\/ This interface answers whether a particular barrier type needs the card\n-  \/\/ mark to be thus strictly sequenced after the stores.\n-  virtual bool card_mark_must_follow_store() const;\n-\n@@ -103,3 +74,0 @@\n-  virtual void on_thread_detach(Thread* thread);\n-\n-  virtual void make_parsable(JavaThread* thread) { flush_deferred_card_mark_barrier(thread); }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -421,4 +421,0 @@\n-  product(bool, DeferInitialCardMark, false, DIAGNOSTIC,                    \\\n-          \"When +ReduceInitialCardMarks, explicitly defer any that \"        \\\n-          \"may arise from new_pre_store_barrier\")                           \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-  \/\/ Causes all refs in \"mr\" to be assumed to be modified by the given JavaThread.\n-  virtual void write_region(JavaThread* thread, MemRegion mr) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,2 +47,1 @@\n-                                 bool clear_space,\n-                                 bool mangle_space) {\n+                                 bool clear_space) {\n@@ -56,1 +55,4 @@\n-    clear(mangle_space);\n+    clear(SpaceDecorator::DontMangle);\n+  }\n+  if (ZapUnusedHeapArea) {\n+    mangle_unused_area();\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n+  void initialize(MemRegion mr, bool clear_space);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-  nonstatic_field(CardTableBarrierSet,         _defer_initial_card_mark,                      bool)                                  \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+\/**\n+ * ShenanoahAllocationRate maintains a truncated history of recently sampled allocation rates for the purpose of providing\n+ * informed estimates of current and future allocation rates based on weighted averages and standard deviations of the\n+ * truncated history.  More recently sampled allocations are weighted more heavily than older samples when computing\n+ * averages and standard deviations.\n+ *\/\n@@ -38,0 +44,2 @@\n+\n+  \/\/ Reset the _last_sample_value to zero, _last_sample_time to current time.\n@@ -40,0 +48,7 @@\n+  \/\/ Force an allocation rate sample to be taken, even if the time since last sample is not greater than\n+  \/\/ 1s\/ShenandoahAdaptiveSampleFrequencyHz, except when current_time - _last_sample_time < MinSampleTime (2 ms).\n+  \/\/ The sampled allocation rate is computed from (allocated - _last_sample_value) \/ (current_time - _last_sample_time).\n+  \/\/ Return the newly computed rate if the sample is taken, zero if it is not an appropriate time to add a sample.\n+  \/\/ In the case that a new sample is not taken, overwrite unaccounted_bytes_allocated with bytes allocated since\n+  \/\/ the previous sample was taken (allocated - _last_sample_value).  Otherwise, overwrite unaccounted_bytes_allocated\n+  \/\/ with 0.\n@@ -41,0 +56,4 @@\n+\n+  \/\/ Add an allocation rate sample if the time since last sample is greater than 1s\/ShenandoahAdaptiveSampleFrequencyHz.\n+  \/\/ The sampled allocation rate is computed from (allocated - _last_sample_value) \/ (current_time - _last_sample_time).\n+  \/\/ Return the newly computed rate if the sample is taken, zero if it is not an appropriate time to add a sample.\n@@ -43,0 +62,3 @@\n+  \/\/ Return an estimate of the upper bound on allocation rate, with the upper bound computed as the weighted average\n+  \/\/ of recently sampled instantaneous allocation rates added to sds times the standard deviation computed for the\n+  \/\/ sequence of recently sampled average allocation rates.\n@@ -44,0 +66,3 @@\n+\n+  \/\/ Test whether rate significantly diverges from the computed average allocation rate.  If so, return true.\n+  \/\/ Otherwise, return false.  Significant divergence is recognized if (rate - _rate.avg()) \/ _rate.sd() > threshold.\n@@ -48,0 +73,2 @@\n+  \/\/ Return the instantaneous rate calculated from (allocated - _last_sample_value) \/ (time - _last_sample_time).\n+  \/\/ Return Sentinel value 0.0 if (time - _last_sample_time) == 0 or if (allocated <= _last_sample_value).\n@@ -50,0 +77,1 @@\n+  \/\/ Time at which previous allocation rate sample was collected.\n@@ -51,0 +79,2 @@\n+\n+  \/\/ Bytes allocated as of the time at which previous allocation rate sample was collected.\n@@ -52,0 +82,2 @@\n+\n+  \/\/ The desired interval of time between consecutive samples of the allocation rate.\n@@ -53,0 +85,2 @@\n+\n+  \/\/ Holds a sequence of the most recently sampled instantaneous allocation rates\n@@ -54,0 +88,3 @@\n+\n+  \/\/ Holds a sequence of the most recently computed weighted average of allocation rates, with each weighted average\n+  \/\/ computed immediately after an instantaneous rate was sampled\n@@ -157,0 +194,2 @@\n+  \/\/ Sample the allocation rate at GC trigger time if possible.  Return the number of allocated bytes that were\n+  \/\/ not accounted for in the sample.  This must be called before resetting bytes allocated since gc start.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -92,2 +92,13 @@\n-  assert(!ReduceInitialCardMarks || !ShenandoahCardBarrier || ShenandoahGenerationalHeap::heap()->is_in_young(new_obj),\n-         \"Allocating new object outside of young generation: \" INTPTR_FORMAT, p2i(new_obj));\n+  if (ReduceInitialCardMarks && ShenandoahCardBarrier && !ShenandoahHeap::heap()->is_in_young(new_obj)) {\n+    log_debug(gc)(\"Newly allocated object (\" PTR_FORMAT \") is not in the young generation\", p2i(new_obj));\n+    \/\/ This can happen when an object is newly allocated, but we come to a safepoint before returning\n+    \/\/ the object. If the safepoint runs a degenerated cycle that is upgraded to a full GC, this object\n+    \/\/ will have survived two GC cycles. If the tenuring age is very low (1), this object may be promoted.\n+    \/\/ In this case, we have an allocated object, but it has received no stores yet. If card marking barriers\n+    \/\/ have been elided, we could end up with an object in old holding pointers to young that won't be in\n+    \/\/ the remembered set. The solution here is conservative, but this problem should be rare, and it will\n+    \/\/ correct itself on subsequent cycles when the remembered set is updated.\n+    ShenandoahGenerationalHeap::heap()->old_generation()->card_scan()->mark_range_as_dirty(\n+      cast_from_oop<HeapWord*>(new_obj), new_obj->size()\n+    );\n+  }\n@@ -95,1 +106,0 @@\n-  assert(thread->deferred_card_mark().is_empty(), \"We don't use this\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -145,0 +145,5 @@\n+\n+  \/\/ Reset the bytes allocated within this generation since the start of GC.  The argument initial_bytes_allocated\n+  \/\/ is normally zero.  In the case that some memory was allocated following the last allocation rate sample that\n+  \/\/ precedes the start of GC, the number of bytes allocated is supplied as the initial value of bytes_allocated_since_gc_start.\n+  \/\/ We will behave as if these bytes were allocated after the start of GC.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1579,2 +1579,2 @@\n-  \/\/ concurrent cycle in the prologue of the heap inspect\/dump operation. This is how\n-  \/\/ other concurrent collectors in the JVM handle this scenario as well.\n+  \/\/ concurrent cycle in the prologue of the heap inspect\/dump operation (see VM_HeapDumper::doit_prologue).\n+  \/\/ This is how other concurrent collectors in the JVM handle this scenario as well.\n@@ -1590,1 +1590,4 @@\n-  \/\/assert(false, \"Shouldn't need to do full collections\");\n+  \/\/ This method is only called by `CollectedHeap::collect_as_vm_thread`, which we have\n+  \/\/ overridden to do nothing. See the comment there for an explanation of how heap inspections\n+  \/\/ work for Shenandoah.\n+  ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  log_debug(gc)(\"SMC:initialize_top_at_mark_start for Region %zu, TAMS: \" PTR_FORMAT \", TopOfBitMap: \" PTR_FORMAT,\n-                r->index(), p2i(bottom), p2i(r->end()));\n+  log_debug(gc, mark)(\"SMC:initialize_top_at_mark_start for Region %zu, TAMS: \" PTR_FORMAT \", TopOfBitMap: \" PTR_FORMAT,\n+                      r->index(), p2i(bottom), p2i(r->end()));\n@@ -89,2 +89,2 @@\n-  log_debug(gc)(\"SMC:clear_bitmap for %s Region %zu, top_bitmap: \" PTR_FORMAT,\n-                r->affiliation_name(), r->index(), p2i(top_bitmap));\n+  log_debug(gc, mark)(\"SMC:clear_bitmap for %s Region %zu, top_bitmap: \" PTR_FORMAT,\n+                      r->affiliation_name(), r->index(), p2i(top_bitmap));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-  log_debug(gc)(\"Capturing TAMS for %s Region %zu, was: \" PTR_FORMAT \", now: \" PTR_FORMAT,\n-                r->affiliation_name(), idx, p2i(old_tams), p2i(new_tams));\n+  log_debug(gc, mark)(\"Capturing TAMS for %s Region %zu, was: \" PTR_FORMAT \", now: \" PTR_FORMAT,\n+                      r->affiliation_name(), idx, p2i(old_tams), p2i(new_tams));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+    SuspendibleThreadSetJoiner joiner;\n@@ -98,0 +99,1 @@\n+    SuspendibleThreadSetJoiner joiner;\n@@ -125,0 +127,1 @@\n+  SuspendibleThreadSetLeaver leaver;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-  _phase(phase), _is_par(is_par) {\n-  Threads::change_thread_claim_token();\n-}\n+  _phase(phase),\n+  _is_par(is_par),\n+  _threads_claim_token_scope() {}\n@@ -77,4 +77,0 @@\n-ShenandoahThreadRoots::~ShenandoahThreadRoots() {\n-  Threads::assert_all_threads_claimed();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -90,1 +91,2 @@\n-  const bool _is_par;\n+  const bool                    _is_par;\n+  ThreadsClaimTokenScope        _threads_claim_token_scope;\n@@ -93,1 +95,0 @@\n-  ~ShenandoahThreadRoots();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -686,3 +686,3 @@\n-    log_debug(gc)(\"ShenandoahScanRememberedTask::do_work(%u), processing slice of region \"\n-                  \"%zu at offset %zu, size: %zu\",\n-                  worker_id, region->index(), assignment._chunk_offset, assignment._chunk_size);\n+    log_debug(gc, remset)(\"ShenandoahScanRememberedTask::do_work(%u), processing slice of region \"\n+                          \"%zu at offset %zu, size: %zu\",\n+                          worker_id, region->index(), assignment._chunk_offset, assignment._chunk_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -346,3 +346,3 @@\n-  log_debug(gc)(\"Remembered set scan processing Region %zu, from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n-                region->index(), p2i(start_of_range), p2i(end_of_range),\n-                use_write_table? \"read\/write (updating)\": \"read (marking)\");\n+  log_debug(gc, remset)(\"Remembered set scan processing Region %zu, from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n+                        region->index(), p2i(start_of_range), p2i(end_of_range),\n+                        use_write_table? \"read\/write (updating)\": \"read (marking)\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+\n+  static int numa_id_to_node(uint32_t numa_id);\n","filename":"src\/hotspot\/share\/gc\/z\/zNUMA.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  if (!commit(vmem, (uint32_t)-1) || !uncommit(vmem)) {\n+  if (!commit(vmem, 0) || !uncommit(vmem)) {\n@@ -296,1 +296,1 @@\n-    os::numa_make_local((char*)addr, size, (int)numa_id);\n+    os::numa_make_local((char*)addr, size, ZNUMA::numa_id_to_node(numa_id));\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -267,1 +267,2 @@\n-        return cpool->resolved_indy_entry_at(method_index)->is_resolved();\n+        bool is_resolved = cpool->resolved_indy_entry_at(method_index)->is_resolved();\n+        return !is_resolved;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,2 +103,17 @@\n-  int             dest() const                   { return bci() + bytecode().get_offset_s2(raw_code()); }\n-  int             dest_w() const                 { return bci() + bytecode().get_offset_s4(raw_code()); }\n+  int get_offset_s2() const { return bytecode().get_offset_s2(raw_code()); }\n+  int get_offset_s4() const { return bytecode().get_offset_s4(raw_code()); }\n+\n+  \/\/ These methods are not safe to use before or during verification as they may\n+  \/\/ have large offsets and cause overflows\n+  int dest() const {\n+    int min_offset = -1 * max_method_code_size;\n+    int offset = bytecode().get_offset_s2(raw_code());\n+    guarantee(offset >= min_offset && offset <= max_method_code_size, \"must be\");\n+    return bci() + offset;\n+  }\n+  int dest_w() const {\n+    int min_offset = -1 * max_method_code_size;\n+    int offset = bytecode().get_offset_s4(raw_code());\n+    guarantee(offset >= min_offset && offset <= max_method_code_size, \"must be\");\n+    return bci() + offset;\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeStream.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -461,0 +461,1 @@\n+  assert(!thread->is_Java_thread() || JavaThread::cast(thread)->thread_state() == _thread_in_vm, \"invariant\");\n@@ -522,1 +523,1 @@\n-  JavaThread* const _jt;\n+  JavaThread* _jt;\n@@ -526,1 +527,1 @@\n-  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? JavaThread::cast(t) : nullptr),\n+  JavaThreadInVMAndNative(Thread* t) : _jt(nullptr),\n@@ -528,1 +529,2 @@\n-    if (_jt != nullptr) {\n+    if (t != nullptr && t->is_Java_thread()) {\n+      _jt = JavaThread::cast(t);\n@@ -538,0 +540,1 @@\n+      assert(_jt != nullptr, \"invariant\");\n@@ -577,0 +580,1 @@\n+      JavaThreadInVMAndNative jtivm(thread);\n@@ -578,1 +582,0 @@\n-        JavaThreadInVMAndNative jtivm(thread);\n@@ -582,0 +585,2 @@\n+      \/\/ Transition to a safe safepoint state for the infinite sleep. A nop for non-java threads.\n+      jtivm.transition_to_native();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {\n+ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size) {\n@@ -972,3 +972,7 @@\n-  size_t page_size = os::vm_page_size();\n-  if (UseLargePages && is_aligned(alignment, os::large_page_size())) {\n-    page_size = os::large_page_size();\n+  size_t page_size;\n+  if (desired_page_size == 0) {\n+    if (UseLargePages) {\n+      page_size = os::large_page_size();\n+    } else {\n+      page_size = os::vm_page_size();\n+    }\n@@ -978,1 +982,3 @@\n-    assert(!UseLargePages || UseParallelGC , \"Wrong alignment to use large pages\");\n+    assert(UseParallelGC , \"only Parallel\");\n+    \/\/ Use caller provided value.\n+    page_size = desired_page_size;\n@@ -980,1 +986,1 @@\n-\n+  assert(is_aligned(heap_size, page_size), \"inv\");\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment);\n+  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size = 0);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -39,1 +40,1 @@\n-void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address, address block_address) const {\n@@ -51,0 +52,12 @@\n+  if (MemTracker::tracking_level() == NMT_TrackingLevel::NMT_detail) {\n+    MallocHeader* mh = (MallocHeader*)block_address;\n+    NativeCallStack stack;\n+    if (MallocSiteTable::access_stack(stack, *mh)) {\n+      st->print_cr(\"allocated from:\");\n+      stack.print_on(st);\n+    } else {\n+      st->print_cr(\"allocation-site cannot be shown since the marker is also corrupted.\");\n+    }\n+    st->print_cr(\"\");\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  void print_block_on_error(outputStream* st, address bad_address) const;\n+  void print_block_on_error(outputStream* st, address bad_address, address block_address) const;\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer);\n+    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer, (address)header_pointer);\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,3 @@\n-  assert(bucket_idx < table_size, \"Invalid bucket index\");\n+  if (bucket_idx >= table_size) {\n+    return nullptr;\n+  }\n@@ -172,1 +174,3 @@\n-  assert(head != nullptr, \"Invalid position index\");\n+  if (head == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -544,1 +544,0 @@\n-  Klass* k = resolved_klass_at(cp_index);\n@@ -546,0 +545,1 @@\n+  Klass* k = nullptr;\n@@ -547,5 +547,1 @@\n-  if (k == nullptr) {\n-    \/\/ We'd come here if the referenced class has been excluded via\n-    \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n-    \/\/ has cleared the resolved_klasses()->at(...) pointer to null. Thus, we\n-    \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n@@ -554,2 +550,11 @@\n-    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n-    can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n+    k = resolved_klass_at(cp_index);\n+    if (k == nullptr) {\n+      \/\/ We'd come here if the referenced class has been excluded via\n+      \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n+      \/\/ has cleared the resolved_klasses()->at(...) pointer to null. Thus, we\n+      \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n+      can_archive = false;\n+    } else {\n+      ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+      can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n+    }\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -434,1 +434,2 @@\n-    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n+        && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -440,14 +441,12 @@\n-    if (resolved) {\n-      LogStreamHandle(Trace, aot, resolve) log;\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n-        Symbol* name = cp->uncached_name_ref_at(cp_index);\n-        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n-        log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n-                  (archived ? \"archived\" : \"reverted\"),\n-                  cp_index,\n-                  cp->pool_holder()->name()->as_C_string(),\n-                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n-      }\n+    LogStreamHandle(Trace, aot, resolve) log;\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+      Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+      Symbol* name = cp->uncached_name_ref_at(cp_index);\n+      Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+      log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n+                (archived ? \"archived\" : \"reverted\"),\n+                cp_index,\n+                cp->pool_holder()->name()->as_C_string(),\n+                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n@@ -474,1 +473,2 @@\n-    if (resolved && can_archive_resolved_method(src_cp, rme)) {\n+    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n+        && can_archive_resolved_method(src_cp, rme)) {\n@@ -480,20 +480,18 @@\n-    if (resolved) {\n-      LogStreamHandle(Trace, aot, resolve) log;\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n-        Symbol* name = cp->uncached_name_ref_at(cp_index);\n-        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n-        log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n-                  (archived ? \"archived\" : \"reverted\"),\n-                  (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n-                  cp_index,\n-                  cp->pool_holder()->name()->as_C_string(),\n-                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n-        if (archived) {\n-          Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n-          log.print(\" => %s%s\",\n-                    resolved_klass->name()->as_C_string(),\n-                    (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n-        }\n+    LogStreamHandle(Trace, aot, resolve) log;\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+      Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+      Symbol* name = cp->uncached_name_ref_at(cp_index);\n+      Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+      log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n+                (archived ? \"archived\" : \"reverted\"),\n+                (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n+                cp_index,\n+                cp->pool_holder()->name()->as_C_string(),\n+                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+      if (archived) {\n+        Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n+        log.print(\" => %s%s\",\n+                  resolved_klass->name()->as_C_string(),\n+                  (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n@@ -514,1 +512,2 @@\n-    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n+        && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -520,16 +519,13 @@\n-    if (resolved) {\n-      LogStreamHandle(Trace, aot, resolve) log;\n-      if (log.is_enabled()) {\n-        ResourceMark rm;\n-        int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n-        int bsm_ref = cp->method_handle_index_at(bsm);\n-        Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n-        Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n-        Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n-        log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n-                  (archived ? \"archived\" : \"reverted\"),\n-                  cp_index, cp->pool_holder()->name()->as_C_string(), i);\n-        log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n-                  bsm_name->as_C_string(), bsm_signature->as_C_string());\n-      }\n-      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n+    LogStreamHandle(Trace, aot, resolve) log;\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+      int bsm_ref = cp->method_handle_index_at(bsm);\n+      Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+      Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+      Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+      log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n+                (archived ? \"archived\" : \"reverted\"),\n+                cp_index, cp->pool_holder()->name()->as_C_string(), i);\n+      log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n+                bsm_name->as_C_string(), bsm_signature->as_C_string());\n@@ -537,0 +533,1 @@\n+    ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":50,"deletions":53,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -88,1 +88,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this,proj->_con,RegMask::EMPTY,MachProjNode::unmatched_proj);\n@@ -809,1 +809,1 @@\n-                rm.Insert(r);\n+                rm.insert(r);\n@@ -816,1 +816,1 @@\n-          rm.Insert(regs.second());\n+          rm.insert(regs.second());\n@@ -822,1 +822,1 @@\n-        return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);\n+        return new MachProjNode(this,con, RegMask::EMPTY, (uint)OptoReg::Bad);\n@@ -831,1 +831,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this,proj->_con,RegMask::EMPTY,MachProjNode::unmatched_proj);\n@@ -1696,1 +1696,3 @@\n-  if( idx < TypeFunc::Parms ) return RegMask::Empty;\n+  if (idx < TypeFunc::Parms) {\n+    return RegMask::EMPTY;\n+  }\n@@ -1701,1 +1703,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -1812,1 +1814,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -1863,1 +1865,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1020,1 +1020,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3075,1 +3075,1 @@\n-  return i ? out_RegMask() : RegMask::Empty;\n+  return i ? out_RegMask() : RegMask::EMPTY;\n@@ -3081,1 +3081,3 @@\n-  if( ideal_reg == 0 ) return RegMask::Empty;\n+  if (ideal_reg == 0) {\n+    return RegMask::EMPTY;\n+  }\n@@ -3108,1 +3110,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3113,1 +3115,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3118,1 +3120,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -3123,1 +3125,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-    return RegMask::All;\n+    return RegMask::ALL;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-    else tty->print(\", #!!!_%d_vs_%d \",_mask_size,_mask.Size());\n+    else {\n+      tty->print(\", #!!!_%d_vs_%d \", _mask_size, _mask.size());\n+    }\n@@ -54,1 +56,1 @@\n-    tty->print(\", #?(%d) \",_mask.Size());\n+    tty->print(\", #?(%d) \", _mask.size());\n@@ -744,1 +746,1 @@\n-          lrg.Remove(hi);       \/\/ Yank from mask\n+          lrg.remove(hi);               \/\/ Yank from mask\n@@ -776,1 +778,1 @@\n-      _lrg_map.map(n->_idx, !rm.is_Empty() ? lr_counter++ : 0);\n+      _lrg_map.map(n->_idx, !rm.is_empty() ? lr_counter++ : 0);\n@@ -797,1 +799,1 @@\n-      _lrg_map.map(n->_idx, !rm.is_Empty() ? n->_idx : 0);\n+      _lrg_map.map(n->_idx, !rm.is_empty() ? n->_idx : 0);\n@@ -882,1 +884,1 @@\n-        lrg.AND( rm );\n+        lrg.and_with(rm);\n@@ -938,1 +940,1 @@\n-          lrg.set_num_regs(rm.Size());\n+          lrg.set_num_regs(rm.size());\n@@ -1129,1 +1131,1 @@\n-          lrg.AND( rm );\n+          lrg.and_with(rm);\n@@ -1167,1 +1169,1 @@\n-          lrg.Clear();\n+          lrg.clear();\n@@ -1408,1 +1410,1 @@\n-  if (lrg.mask().can_represent(reg) && lrg.mask().Member(reg)) {\n+  if (lrg.mask().can_represent(reg) && lrg.mask().member(reg)) {\n@@ -1462,1 +1464,1 @@\n-          mask.Remove(assigned - num_regs + 1); \/\/ Unmask the lowest reg\n+          mask.remove(assigned - num_regs + 1);      \/\/ Unmask the lowest reg\n@@ -1513,1 +1515,1 @@\n-      tempmask.AND(lrgs(copy_lrg).mask());\n+      tempmask.and_with(lrgs(copy_lrg).mask());\n@@ -1536,1 +1538,1 @@\n-    lrg.Remove(reg);\n+    lrg.remove(reg);\n@@ -1538,1 +1540,1 @@\n-    lrg.Insert(reg);\n+    lrg.insert(reg);\n@@ -1548,2 +1550,2 @@\n-  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n-  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n@@ -1625,1 +1627,1 @@\n-          uint size = lrg->mask().Size();\n+          uint size = lrg->mask().size();\n@@ -1629,1 +1631,1 @@\n-          lrg->SUBTRACT_inner(nlrg.mask());\n+          lrg->subtract_inner(nlrg.mask());\n@@ -1631,1 +1633,1 @@\n-          if (trace_spilling() && lrg->mask().Size() != size) {\n+          if (trace_spilling() && lrg->mask().size() != size) {\n@@ -1638,1 +1640,1 @@\n-            trace_mask.SUBTRACT(lrg->mask());\n+            trace_mask.subtract(lrg->mask());\n@@ -1704,2 +1706,2 @@\n-        lrg->Clear();           \/\/ Clear the mask\n-        lrg->Insert(reg);       \/\/ Set regmask to match selected reg\n+        lrg->clear();     \/\/ Clear the mask\n+        lrg->insert(reg); \/\/ Set regmask to match selected reg\n@@ -1712,1 +1714,1 @@\n-          lrg->Insert(OptoReg::add(reg,-i));\n+          lrg->insert(OptoReg::add(reg, -i));\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  uint _mask_size;              \/\/ cache of _mask.Size();\n+  uint _mask_size;              \/\/ cache of _mask.size();\n@@ -108,1 +108,1 @@\n-  int compute_mask_size() const { return _mask.is_infinite_stack() ? INFINITE_STACK_SIZE : _mask.Size(); }\n+  int compute_mask_size() const { return _mask.is_infinite_stack() ? INFINITE_STACK_SIZE : _mask.size(); }\n@@ -110,1 +110,1 @@\n-    assert((size == (int)INFINITE_STACK_SIZE) || (size == (int)_mask.Size()), \"\");\n+    assert((size == (int)INFINITE_STACK_SIZE) || (size == (int)_mask.size()), \"\");\n@@ -131,1 +131,1 @@\n-  void set_mask( const RegMask &rm ) { _mask = rm; DEBUG_ONLY(_msize_valid=0;)}\n+  void set_mask(const RegMask& rm) { _mask.assignFrom(rm); DEBUG_ONLY(_msize_valid = 0;) }\n@@ -133,5 +133,5 @@\n-  void AND( const RegMask &rm ) { _mask.AND(rm); DEBUG_ONLY(_msize_valid=0;)}\n-  void SUBTRACT( const RegMask &rm ) { _mask.SUBTRACT(rm); DEBUG_ONLY(_msize_valid=0;)}\n-  void SUBTRACT_inner(const RegMask& rm) { _mask.SUBTRACT_inner(rm); DEBUG_ONLY(_msize_valid = 0;) }\n-  void Clear()   { _mask.Clear()  ; DEBUG_ONLY(_msize_valid=1); _mask_size = 0; }\n-  void Set_All() { _mask.Set_All(); DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); }\n+  void and_with( const RegMask &rm ) { _mask.and_with(rm); DEBUG_ONLY(_msize_valid=0;)}\n+  void subtract( const RegMask &rm ) { _mask.subtract(rm); DEBUG_ONLY(_msize_valid=0;)}\n+  void subtract_inner(const RegMask& rm) { _mask.subtract_inner(rm); DEBUG_ONLY(_msize_valid = 0;) }\n+  void clear()   { _mask.clear()  ; DEBUG_ONLY(_msize_valid=1); _mask_size = 0; }\n+  void set_all() { _mask.set_all(); DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); }\n@@ -140,2 +140,2 @@\n-  void Insert( OptoReg::Name reg ) { _mask.Insert(reg);  DEBUG_ONLY(_msize_valid=0;) }\n-  void Remove( OptoReg::Name reg ) { _mask.Remove(reg);  DEBUG_ONLY(_msize_valid=0;) }\n+  void insert( OptoReg::Name reg ) { _mask.insert(reg);  DEBUG_ONLY(_msize_valid=0;) }\n+  void remove( OptoReg::Name reg ) { _mask.remove(reg);  DEBUG_ONLY(_msize_valid=0;) }\n@@ -627,1 +627,1 @@\n-        uint new_pressure = current_pressure() + fatproj_mask.Size();\n+        uint new_pressure = current_pressure() + fatproj_mask.size();\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-      lrg1->AND(lrg2->mask());\n+      lrg1->and_with(lrg2->mask());\n@@ -506,2 +506,2 @@\n-  lrgs(lr2).Clear();        \/\/ Force empty mask for LRG 2\n-  \/\/lrgs(lr2)._size = 0;      \/\/ Live-range 2 goes dead\n+  lrgs(lr2).clear();           \/\/ Force empty mask for LRG 2\n+  \/\/ lrgs(lr2)._size = 0;      \/\/ Live-range 2 goes dead\n@@ -573,1 +573,1 @@\n-        rm.SUBTRACT( lrgs(lidx).mask() );\n+        rm.subtract(lrgs(lidx).mask());\n@@ -575,1 +575,1 @@\n-        rm_size = rm.Size();\n+        rm_size = rm.size();\n@@ -698,1 +698,1 @@\n-  mask.AND(lrgs(lr2).mask());\n+  mask.and_with(lrgs(lr2).mask());\n@@ -700,1 +700,1 @@\n-  uint rm_size = mask.Size();\n+  uint rm_size = mask.size();\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-  virtual const RegMask &out_RegMask() const { return RegMask::Empty; }\n-  virtual const RegMask &in_RegMask(uint) const { return RegMask::Empty; }\n+  virtual const RegMask& out_RegMask() const { return RegMask::EMPTY; }\n+  virtual const RegMask& in_RegMask(uint) const { return RegMask::EMPTY; }\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1671,1 +1671,1 @@\n-    rm = match->divI_proj_mask();\n+    rm.assignFrom(match->divI_proj_mask());\n@@ -1674,1 +1674,1 @@\n-    rm = match->modI_proj_mask();\n+    rm.assignFrom(match->modI_proj_mask());\n@@ -1686,1 +1686,1 @@\n-    rm = match->divL_proj_mask();\n+    rm.assignFrom(match->divL_proj_mask());\n@@ -1689,1 +1689,1 @@\n-    rm = match->modL_proj_mask();\n+    rm.assignFrom(match->modL_proj_mask());\n@@ -1724,1 +1724,1 @@\n-    rm = match->divI_proj_mask();\n+    rm.assignFrom(match->divI_proj_mask());\n@@ -1727,1 +1727,1 @@\n-    rm = match->modI_proj_mask();\n+    rm.assignFrom(match->modI_proj_mask());\n@@ -1739,1 +1739,1 @@\n-    rm = match->divL_proj_mask();\n+    rm.assignFrom(match->divL_proj_mask());\n@@ -1742,1 +1742,1 @@\n-    rm = match->modL_proj_mask();\n+    rm.assignFrom(match->modL_proj_mask());\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1337,2 +1337,0 @@\n-    } else if (use->is_SafePoint()) {\n-      \/\/ processed later\n@@ -1340,0 +1338,1 @@\n+      \/\/ Safepoints to be processed later; other users aren't expected here\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_Empty())\n+  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_empty()) {\n@@ -1454,0 +1454,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    _lrgs[i].Set_All();\n+    _lrgs[i].set_all();\n@@ -658,1 +658,1 @@\n-  mask_tmp.AND(*Matcher::idealreg2regmask[op_regtype]);\n+  mask_tmp.and_with(*Matcher::idealreg2regmask[op_regtype]);\n@@ -732,1 +732,1 @@\n-    old = interfering_lrg.mask();\n+    old.assignFrom(interfering_lrg.mask());\n@@ -741,1 +741,1 @@\n-      r2mask = mask;\n+      r2mask.assignFrom(mask);\n@@ -745,1 +745,1 @@\n-      interfering_lrg.SUBTRACT(r2mask);\n+      interfering_lrg.subtract(r2mask);\n@@ -749,1 +749,1 @@\n-      interfering_lrg.SUBTRACT(mask);\n+      interfering_lrg.subtract(mask);\n@@ -754,2 +754,2 @@\n-      if (interfering_lrg.mask().Member(r_reg)) {\n-        interfering_lrg.Remove(r_reg);\n+      if (interfering_lrg.mask().member(r_reg)) {\n+        interfering_lrg.remove(r_reg);\n@@ -936,1 +936,1 @@\n-        if (lrg.is_bound() && !n->rematerialize() && !lrg.mask().is_Empty()) {\n+        if (lrg.is_bound() && !n->rematerialize() && !lrg.mask().is_empty()) {\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -885,1 +885,1 @@\n-    if( !regs.Member(r) ) {     \/\/ Not already defined by the call\n+    if (!regs.member(r)) { \/\/ Not already defined by the call\n@@ -890,1 +890,1 @@\n-        proj->_rout.Insert(r);\n+        proj->_rout.insert(r);\n@@ -914,1 +914,1 @@\n-    regs.OR(n->out_RegMask());\n+    regs.or_with(n->out_RegMask());\n@@ -937,1 +937,1 @@\n-  regs.Insert(_matcher.c_frame_pointer());\n+  regs.insert(_matcher.c_frame_pointer());\n@@ -942,1 +942,1 @@\n-  MachProjNode *proj = new MachProjNode( mcall, r_cnt+1, RegMask::Empty, MachProjNode::fat_proj );\n+  MachProjNode* proj = new MachProjNode(mcall, r_cnt + 1, RegMask::EMPTY, MachProjNode::fat_proj);\n@@ -1194,2 +1194,2 @@\n-      regs.Insert(_matcher.c_frame_pointer());\n-      regs.OR(n->out_RegMask());\n+      regs.insert(_matcher.c_frame_pointer());\n+      regs.or_with(n->out_RegMask());\n@@ -1197,1 +1197,1 @@\n-      MachProjNode *proj = new MachProjNode( n, 1, RegMask::Empty, MachProjNode::fat_proj );\n+      MachProjNode* proj = new MachProjNode(n, 1, RegMask::EMPTY, MachProjNode::fat_proj);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -706,1 +706,3 @@\n-  _igvn.replace_node(multiversion_slow_proj, region);\n+  \/\/ The lazy_replace ensures that any get_ctrl that used to have multiversion_slow_proj\n+  \/\/ as their control are forwarded to the new region node as their control.\n+  lazy_replace(multiversion_slow_proj, region);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -549,1 +549,1 @@\n-    if (!rm.is_Empty() && rm.is_bound(ideal_reg())) {\n+    if (!rm.is_empty() && rm.is_bound(ideal_reg())) {\n@@ -643,2 +643,5 @@\n-  if( idx == 0 ) return RegMask::Empty;\n-  else return in(1)->as_Mach()->out_RegMask();\n+  if (idx == 0) {\n+    return RegMask::EMPTY;\n+  } else {\n+    return in(1)->as_Mach()->out_RegMask();\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -776,1 +776,1 @@\n-  virtual const RegMask &out_RegMask() const { return RegMask::Empty; }\n+  virtual const RegMask& out_RegMask() const { return RegMask::EMPTY; }\n@@ -808,1 +808,1 @@\n-  virtual const RegMask &in_RegMask(uint) const { return RegMask::Empty; }\n+  virtual const RegMask& in_RegMask(uint) const { return RegMask::EMPTY; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-    mask[--cnt].Clear();\n-    mask[cnt].Insert(OptoReg::stack2reg(slot));\n+    mask[--cnt].clear();\n+    mask[cnt].insert(OptoReg::stack2reg(slot));\n@@ -198,1 +198,1 @@\n-    mask[i].Clear();\n+    mask[i].clear();\n@@ -202,1 +202,1 @@\n-      mask[i].Insert(reg1);\n+      mask[i].insert(reg1);\n@@ -206,1 +206,1 @@\n-      mask[i].Insert(reg2);\n+      mask[i].insert(reg2);\n@@ -224,1 +224,1 @@\n-  assert(_return_addr_mask.is_Empty(),\n+  assert(_return_addr_mask.is_empty(),\n@@ -226,1 +226,1 @@\n-  _return_addr_mask.Insert(return_addr());\n+  _return_addr_mask.insert(return_addr());\n@@ -229,1 +229,1 @@\n-  _return_addr_mask.Insert(OptoReg::add(return_addr(),1));\n+  _return_addr_mask.insert(OptoReg::add(return_addr(), 1));\n@@ -297,1 +297,1 @@\n-    _calling_convention_mask[i].Clear();\n+    _calling_convention_mask[i].clear();\n@@ -309,1 +309,1 @@\n-      _calling_convention_mask[i].Insert(reg1);\n+      _calling_convention_mask[i].insert(reg1);\n@@ -313,1 +313,1 @@\n-      _calling_convention_mask[i].Insert(reg2);\n+      _calling_convention_mask[i].insert(reg2);\n@@ -458,5 +458,5 @@\n-  rms[TypeFunc::Control  ] = RegMask::Empty;\n-  rms[TypeFunc::I_O      ] = RegMask::Empty;\n-  rms[TypeFunc::Memory   ] = RegMask::Empty;\n-  rms[TypeFunc::ReturnAdr] = ret_adr;\n-  rms[TypeFunc::FramePtr ] = fp;\n+  rms[TypeFunc::Control  ].assignFrom(RegMask::EMPTY);\n+  rms[TypeFunc::I_O      ].assignFrom(RegMask::EMPTY);\n+  rms[TypeFunc::Memory   ].assignFrom(RegMask::EMPTY);\n+  rms[TypeFunc::ReturnAdr].assignFrom(ret_adr);\n+  rms[TypeFunc::FramePtr ].assignFrom(fp);\n@@ -507,1 +507,1 @@\n-  C->FIRST_STACK_mask().Clear();\n+  C->FIRST_STACK_mask().clear();\n@@ -512,1 +512,1 @@\n-    C->FIRST_STACK_mask().Insert(i);\n+    C->FIRST_STACK_mask().insert(i);\n@@ -516,1 +516,1 @@\n-  C->FIRST_STACK_mask().Set_All_From(_out_arg_limit);\n+  C->FIRST_STACK_mask().set_all_from(_out_arg_limit);\n@@ -525,1 +525,1 @@\n-  *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];\n+  idealreg2spillmask[Op_RegP]->assignFrom(*idealreg2regmask[Op_RegP]);\n@@ -527,3 +527,3 @@\n-  *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];\n-   idealreg2spillmask[Op_RegN]->OR(C->FIRST_STACK_mask());\n-   idealreg2spillmask[Op_RegP]->OR(aligned_stack_mask);\n+  idealreg2spillmask[Op_RegN]->assignFrom(*idealreg2regmask[Op_RegN]);\n+  idealreg2spillmask[Op_RegN]->or_with(C->FIRST_STACK_mask());\n+  idealreg2spillmask[Op_RegP]->or_with(aligned_stack_mask);\n@@ -531,1 +531,1 @@\n-   idealreg2spillmask[Op_RegP]->OR(C->FIRST_STACK_mask());\n+   idealreg2spillmask[Op_RegP]->or_with(C->FIRST_STACK_mask());\n@@ -533,8 +533,8 @@\n-  *idealreg2spillmask[Op_RegI] = *idealreg2regmask[Op_RegI];\n-   idealreg2spillmask[Op_RegI]->OR(C->FIRST_STACK_mask());\n-  *idealreg2spillmask[Op_RegL] = *idealreg2regmask[Op_RegL];\n-   idealreg2spillmask[Op_RegL]->OR(aligned_stack_mask);\n-  *idealreg2spillmask[Op_RegF] = *idealreg2regmask[Op_RegF];\n-   idealreg2spillmask[Op_RegF]->OR(C->FIRST_STACK_mask());\n-  *idealreg2spillmask[Op_RegD] = *idealreg2regmask[Op_RegD];\n-   idealreg2spillmask[Op_RegD]->OR(aligned_stack_mask);\n+  idealreg2spillmask[Op_RegI]->assignFrom(*idealreg2regmask[Op_RegI]);\n+  idealreg2spillmask[Op_RegI]->or_with(C->FIRST_STACK_mask());\n+  idealreg2spillmask[Op_RegL]->assignFrom(*idealreg2regmask[Op_RegL]);\n+  idealreg2spillmask[Op_RegL]->or_with(aligned_stack_mask);\n+  idealreg2spillmask[Op_RegF]->assignFrom(*idealreg2regmask[Op_RegF]);\n+  idealreg2spillmask[Op_RegF]->or_with(C->FIRST_STACK_mask());\n+  idealreg2spillmask[Op_RegD]->assignFrom(*idealreg2regmask[Op_RegD]);\n+  idealreg2spillmask[Op_RegD]->or_with(aligned_stack_mask);\n@@ -543,2 +543,2 @@\n-    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-     idealreg2spillmask[Op_RegVectMask]->OR(aligned_stack_mask);\n+    idealreg2spillmask[Op_RegVectMask]->assignFrom(*idealreg2regmask[Op_RegVectMask]);\n+    idealreg2spillmask[Op_RegVectMask]->or_with(aligned_stack_mask);\n@@ -546,1 +546,1 @@\n-    *idealreg2spillmask[Op_RegVectMask] = RegMask::Empty;\n+    idealreg2spillmask[Op_RegVectMask]->assignFrom(RegMask::EMPTY);\n@@ -550,2 +550,2 @@\n-    *idealreg2spillmask[Op_VecS] = *idealreg2regmask[Op_VecS];\n-     idealreg2spillmask[Op_VecS]->OR(C->FIRST_STACK_mask());\n+    idealreg2spillmask[Op_VecS]->assignFrom(*idealreg2regmask[Op_VecS]);\n+    idealreg2spillmask[Op_VecS]->or_with(C->FIRST_STACK_mask());\n@@ -553,1 +553,1 @@\n-    *idealreg2spillmask[Op_VecS] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecS]->assignFrom(RegMask::EMPTY);\n@@ -559,2 +559,2 @@\n-    *idealreg2spillmask[Op_VecD] = *idealreg2regmask[Op_VecD];\n-     idealreg2spillmask[Op_VecD]->OR(aligned_stack_mask);\n+    idealreg2spillmask[Op_VecD]->assignFrom(*idealreg2regmask[Op_VecD]);\n+    idealreg2spillmask[Op_VecD]->or_with(aligned_stack_mask);\n@@ -562,1 +562,1 @@\n-    *idealreg2spillmask[Op_VecD] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecD]->assignFrom(RegMask::EMPTY);\n@@ -575,1 +575,1 @@\n-      aligned_stack_mask.Remove(in);\n+      aligned_stack_mask.remove(in);\n@@ -578,4 +578,4 @@\n-     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);\n-     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecX] = *idealreg2regmask[Op_VecX];\n-     idealreg2spillmask[Op_VecX]->OR(aligned_stack_mask);\n+    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);\n+    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecX]->assignFrom(*idealreg2regmask[Op_VecX]);\n+    idealreg2spillmask[Op_VecX]->or_with(aligned_stack_mask);\n@@ -583,1 +583,1 @@\n-    *idealreg2spillmask[Op_VecX] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecX]->assignFrom(RegMask::EMPTY);\n@@ -590,1 +590,1 @@\n-      aligned_stack_mask.Remove(in);\n+      aligned_stack_mask.remove(in);\n@@ -593,4 +593,4 @@\n-     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);\n-     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecY] = *idealreg2regmask[Op_VecY];\n-     idealreg2spillmask[Op_VecY]->OR(aligned_stack_mask);\n+    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);\n+    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecY]->assignFrom(*idealreg2regmask[Op_VecY]);\n+    idealreg2spillmask[Op_VecY]->or_with(aligned_stack_mask);\n@@ -598,1 +598,1 @@\n-    *idealreg2spillmask[Op_VecY] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecY]->assignFrom(RegMask::EMPTY);\n@@ -605,1 +605,1 @@\n-      aligned_stack_mask.Remove(in);\n+      aligned_stack_mask.remove(in);\n@@ -608,4 +608,4 @@\n-     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);\n-     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecZ] = *idealreg2regmask[Op_VecZ];\n-     idealreg2spillmask[Op_VecZ]->OR(aligned_stack_mask);\n+    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);\n+    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecZ]->assignFrom(*idealreg2regmask[Op_VecZ]);\n+    idealreg2spillmask[Op_VecZ]->or_with(aligned_stack_mask);\n@@ -613,1 +613,1 @@\n-    *idealreg2spillmask[Op_VecZ] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecZ]->assignFrom(RegMask::EMPTY);\n@@ -623,1 +623,1 @@\n-        scalable_stack_mask.Remove(in);\n+        scalable_stack_mask.remove(in);\n@@ -630,2 +630,2 @@\n-      *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-      idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+      idealreg2spillmask[Op_RegVectMask]->assignFrom(*idealreg2regmask[Op_RegVectMask]);\n+      idealreg2spillmask[Op_RegVectMask]->or_with(scalable_stack_mask);\n@@ -637,1 +637,1 @@\n-      scalable_stack_mask.Remove(in);\n+      scalable_stack_mask.remove(in);\n@@ -642,4 +642,4 @@\n-     scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n-     assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_VecA] = *idealreg2regmask[Op_VecA];\n-     idealreg2spillmask[Op_VecA]->OR(scalable_stack_mask);\n+    scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n+    assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    idealreg2spillmask[Op_VecA]->assignFrom(*idealreg2regmask[Op_VecA]);\n+    idealreg2spillmask[Op_VecA]->or_with(scalable_stack_mask);\n@@ -647,1 +647,1 @@\n-    *idealreg2spillmask[Op_VecA] = RegMask::Empty;\n+    idealreg2spillmask[Op_VecA]->assignFrom(RegMask::EMPTY);\n@@ -655,2 +655,2 @@\n-    idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n-    idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n+    idealreg2spillmask[Op_RegI]->or_with(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegF]->or_with(*idealreg2regmask[Op_RegI]);\n@@ -658,4 +658,4 @@\n-    idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n-    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n-    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegN]->or_with(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegL]->or_with(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->or_with(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegP]->or_with(*idealreg2regmask[Op_RegD]);\n@@ -663,1 +663,1 @@\n-    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegP]->or_with(*idealreg2regmask[Op_RegF]);\n@@ -667,2 +667,2 @@\n-    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegL]->or_with(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->or_with(*idealreg2regmask[Op_RegL]);\n@@ -676,14 +676,14 @@\n-  *idealreg2debugmask  [Op_RegN] = *idealreg2spillmask[Op_RegN];\n-  *idealreg2debugmask  [Op_RegI] = *idealreg2spillmask[Op_RegI];\n-  *idealreg2debugmask  [Op_RegL] = *idealreg2spillmask[Op_RegL];\n-  *idealreg2debugmask  [Op_RegF] = *idealreg2spillmask[Op_RegF];\n-  *idealreg2debugmask  [Op_RegD] = *idealreg2spillmask[Op_RegD];\n-  *idealreg2debugmask  [Op_RegP] = *idealreg2spillmask[Op_RegP];\n-  *idealreg2debugmask  [Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n-\n-  *idealreg2debugmask  [Op_VecA] = *idealreg2spillmask[Op_VecA];\n-  *idealreg2debugmask  [Op_VecS] = *idealreg2spillmask[Op_VecS];\n-  *idealreg2debugmask  [Op_VecD] = *idealreg2spillmask[Op_VecD];\n-  *idealreg2debugmask  [Op_VecX] = *idealreg2spillmask[Op_VecX];\n-  *idealreg2debugmask  [Op_VecY] = *idealreg2spillmask[Op_VecY];\n-  *idealreg2debugmask  [Op_VecZ] = *idealreg2spillmask[Op_VecZ];\n+  idealreg2debugmask[Op_RegN]->assignFrom(*idealreg2spillmask[Op_RegN]);\n+  idealreg2debugmask[Op_RegI]->assignFrom(*idealreg2spillmask[Op_RegI]);\n+  idealreg2debugmask[Op_RegL]->assignFrom(*idealreg2spillmask[Op_RegL]);\n+  idealreg2debugmask[Op_RegF]->assignFrom(*idealreg2spillmask[Op_RegF]);\n+  idealreg2debugmask[Op_RegD]->assignFrom(*idealreg2spillmask[Op_RegD]);\n+  idealreg2debugmask[Op_RegP]->assignFrom(*idealreg2spillmask[Op_RegP]);\n+  idealreg2debugmask[Op_RegVectMask]->assignFrom(*idealreg2spillmask[Op_RegVectMask]);\n+\n+  idealreg2debugmask[Op_VecA]->assignFrom(*idealreg2spillmask[Op_VecA]);\n+  idealreg2debugmask[Op_VecS]->assignFrom(*idealreg2spillmask[Op_VecS]);\n+  idealreg2debugmask[Op_VecD]->assignFrom(*idealreg2spillmask[Op_VecD]);\n+  idealreg2debugmask[Op_VecX]->assignFrom(*idealreg2spillmask[Op_VecX]);\n+  idealreg2debugmask[Op_VecY]->assignFrom(*idealreg2spillmask[Op_VecY]);\n+  idealreg2debugmask[Op_VecZ]->assignFrom(*idealreg2spillmask[Op_VecZ]);\n@@ -696,14 +696,14 @@\n-  idealreg2debugmask[Op_RegN]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegI]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegL]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegF]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegD]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegP]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_RegVectMask]->SUBTRACT(*caller_save_mask);\n-\n-  idealreg2debugmask[Op_VecA]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecS]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecD]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecX]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecY]->SUBTRACT(*caller_save_mask);\n-  idealreg2debugmask[Op_VecZ]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegN]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegI]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegL]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegF]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegD]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegP]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegVectMask]->subtract(*caller_save_mask);\n+\n+  idealreg2debugmask[Op_VecA]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecS]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecD]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecX]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecY]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_VecZ]->subtract(*caller_save_mask);\n@@ -738,1 +738,1 @@\n-    ret_rms[i] = _return_values_mask[i-TypeFunc::Parms];\n+    ret_rms[i].assignFrom(_return_values_mask[i-TypeFunc::Parms]);\n@@ -751,1 +751,1 @@\n-    reth_rms[TypeFunc::Parms] = mreg2regmask[reg];\n+    reth_rms[TypeFunc::Parms].assignFrom(mreg2regmask[reg]);\n@@ -754,1 +754,1 @@\n-    reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));\n+    reth_rms[TypeFunc::Parms].insert(OptoReg::add(OptoReg::Name(reg), 1));\n@@ -773,2 +773,2 @@\n-      tail_call_rms[TypeFunc::Parms+0] = m->MachNode::in_RegMask(TypeFunc::Parms+0);\n-      tail_call_rms[TypeFunc::Parms+1] = m->MachNode::in_RegMask(TypeFunc::Parms+1);\n+      tail_call_rms[TypeFunc::Parms + 0].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 0));\n+      tail_call_rms[TypeFunc::Parms + 1].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 1));\n@@ -786,2 +786,2 @@\n-      tail_jump_rms[TypeFunc::Parms+0] = m->MachNode::in_RegMask(TypeFunc::Parms+0);\n-      tail_jump_rms[TypeFunc::Parms+1] = m->MachNode::in_RegMask(TypeFunc::Parms+1);\n+      tail_jump_rms[TypeFunc::Parms + 0].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 0));\n+      tail_jump_rms[TypeFunc::Parms + 1].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 1));\n@@ -820,5 +820,5 @@\n-      ret_rms      [      ret_edge_cnt] = mreg2regmask[i];\n-      reth_rms     [     reth_edge_cnt] = mreg2regmask[i];\n-      tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];\n-      tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];\n-      forw_exc_rms [ forw_exc_edge_cnt] = mreg2regmask[i];\n+      ret_rms      [      ret_edge_cnt].assignFrom(mreg2regmask[i]);\n+      reth_rms     [     reth_edge_cnt].assignFrom(mreg2regmask[i]);\n+      tail_call_rms[tail_call_edge_cnt].assignFrom(mreg2regmask[i]);\n+      tail_jump_rms[tail_jump_edge_cnt].assignFrom(mreg2regmask[i]);\n+      forw_exc_rms [ forw_exc_edge_cnt].assignFrom(mreg2regmask[i]);\n@@ -827,1 +827,1 @@\n-      halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];\n+      halt_rms     [     halt_edge_cnt].assignFrom(*idealreg2spillmask[_register_save_type[i]]);\n@@ -838,6 +838,6 @@\n-        ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));\n-        reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));\n-        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n-        halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));\n+        ret_rms      [      ret_edge_cnt].insert(OptoReg::Name(i+1));\n+        reth_rms     [     reth_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_call_rms[tail_call_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_jump_rms[tail_jump_edge_cnt].insert(OptoReg::Name(i+1));\n+        forw_exc_rms [ forw_exc_edge_cnt].insert(OptoReg::Name(i+1));\n+        halt_rms     [     halt_edge_cnt].insert(OptoReg::Name(i+1));\n@@ -851,6 +851,6 @@\n-        ret_rms      [      ret_edge_cnt] = RegMask::Empty;\n-        reth_rms     [     reth_edge_cnt] = RegMask::Empty;\n-        tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;\n-        tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;\n-        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n-        halt_rms     [     halt_edge_cnt] = RegMask::Empty;\n+        ret_rms      [      ret_edge_cnt].assignFrom(RegMask::EMPTY);\n+        reth_rms     [     reth_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_call_rms[tail_call_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_jump_rms[tail_jump_edge_cnt].assignFrom(RegMask::EMPTY);\n+        forw_exc_rms [ forw_exc_edge_cnt].assignFrom(RegMask::EMPTY);\n+        halt_rms     [     halt_edge_cnt].assignFrom(RegMask::EMPTY);\n@@ -866,6 +866,6 @@\n-        ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));\n-        reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));\n-        tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));\n-        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n-        halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));\n+        ret_rms      [      ret_edge_cnt].insert(OptoReg::Name(i+1));\n+        reth_rms     [     reth_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_call_rms[tail_call_edge_cnt].insert(OptoReg::Name(i+1));\n+        tail_jump_rms[tail_jump_edge_cnt].insert(OptoReg::Name(i+1));\n+        forw_exc_rms [ forw_exc_edge_cnt].insert(OptoReg::Name(i+1));\n+        halt_rms     [     halt_edge_cnt].insert(OptoReg::Name(i+1));\n@@ -879,6 +879,6 @@\n-        ret_rms      [      ret_edge_cnt] = RegMask::Empty;\n-        reth_rms     [     reth_edge_cnt] = RegMask::Empty;\n-        tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;\n-        tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;\n-        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n-        halt_rms     [     halt_edge_cnt] = RegMask::Empty;\n+        ret_rms      [      ret_edge_cnt].assignFrom(RegMask::EMPTY);\n+        reth_rms     [     reth_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_call_rms[tail_call_edge_cnt].assignFrom(RegMask::EMPTY);\n+        tail_jump_rms[tail_jump_edge_cnt].assignFrom(RegMask::EMPTY);\n+        forw_exc_rms [ forw_exc_edge_cnt].assignFrom(RegMask::EMPTY);\n+        halt_rms     [     halt_edge_cnt].assignFrom(RegMask::EMPTY);\n@@ -911,1 +911,1 @@\n-  c_frame_ptr_mask = RegMask(c_frame_pointer());\n+  c_frame_ptr_mask.assignFrom(RegMask(c_frame_pointer()));\n@@ -914,1 +914,1 @@\n-  c_frame_ptr_mask.Insert(OptoReg::add(c_frame_pointer(),1));\n+  c_frame_ptr_mask.insert(OptoReg::add(c_frame_pointer(), 1));\n@@ -918,1 +918,1 @@\n-  STACK_ONLY_mask.Clear();\n+  STACK_ONLY_mask.clear();\n@@ -920,1 +920,1 @@\n-  STACK_ONLY_mask.Set_All_From(OptoReg::stack2reg(0));\n+  STACK_ONLY_mask.set_all_from(OptoReg::stack2reg(0));\n@@ -927,1 +927,1 @@\n-    mreg2regmask[i].Insert(i);\n+    mreg2regmask[i].insert(i);\n@@ -932,1 +932,1 @@\n-      caller_save_regmask.Insert(i);\n+      caller_save_regmask.insert(i);\n@@ -938,1 +938,1 @@\n-      caller_save_regmask_exclude_soe.Insert(i);\n+      caller_save_regmask_exclude_soe.insert(i);\n@@ -1280,2 +1280,2 @@\n-  msfpt->_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;\n-  msfpt->_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;\n+  msfpt->_in_rms[TypeFunc::ReturnAdr].assignFrom(_return_addr_mask);\n+  msfpt->_in_rms[TypeFunc::FramePtr ].assignFrom(c_frame_ptr_mask);\n@@ -1358,1 +1358,1 @@\n-          rm->Insert(r);\n+          rm->insert(r);\n@@ -1364,1 +1364,1 @@\n-        rm->Insert( reg1 );\n+        rm->insert( reg1 );\n@@ -1369,1 +1369,1 @@\n-        rm->Insert( reg2 );\n+        rm->insert( reg2 );\n@@ -1387,1 +1387,1 @@\n-    MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );\n+    MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::EMPTY, MachProjNode::fat_proj );\n@@ -1389,1 +1389,1 @@\n-      proj->_rout.Insert(OptoReg::Name(i));\n+      proj->_rout.insert(OptoReg::Name(i));\n@@ -1391,1 +1391,1 @@\n-    if (!proj->_rout.is_Empty()) {\n+    if (!proj->_rout.is_empty()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":157,"deletions":157,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-  static RegMask divI_proj_mask();\n+  static const RegMask& divI_proj_mask();\n@@ -415,1 +415,1 @@\n-  static RegMask modI_proj_mask();\n+  static const RegMask& modI_proj_mask();\n@@ -418,1 +418,1 @@\n-  static RegMask divL_proj_mask();\n+  static const RegMask& divL_proj_mask();\n@@ -420,1 +420,1 @@\n-  static RegMask modL_proj_mask();\n+  static const RegMask& modL_proj_mask();\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4552,1 +4552,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this, proj->_con, RegMask::EMPTY, MachProjNode::unmatched_proj);\n@@ -4799,1 +4799,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -6023,1 +6023,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    if (!scaleI.is_zero() && !scaleL.is_NaN()) {\n+    if (!scaleI.is_zero() && !scaleL.is_zero()) {\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -188,1 +188,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2813,1 +2813,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n@@ -2818,1 +2818,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  bool can_use = use_mask.Member(def_reg);\n+  bool can_use = use_mask.member(def_reg);\n@@ -681,1 +681,1 @@\n-              bool is_adjacent = lrgs(useidx).mask().Member(ureg_lo);\n+              bool is_adjacent = lrgs(useidx).mask().member(ureg_lo);\n@@ -765,1 +765,1 @@\n-        bool is_adjacent = lrgs(lidx).mask().Member(nreg_lo);\n+        bool is_adjacent = lrgs(lidx).mask().member(nreg_lo);\n@@ -770,2 +770,2 @@\n-          RegMask tmp = lrgs(lidx).mask();\n-          tmp.Remove(nreg);\n+          RegMask tmp(lrgs(lidx).mask());\n+          tmp.remove(nreg);\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-    if (!n->out_RegMask().is_Empty()) {\n+    if (!n->out_RegMask().is_empty()) {\n@@ -1041,1 +1041,1 @@\n-                (int)umask.Size() <= lrgs(useidx).num_regs() &&\n+                (int)umask.size() <= lrgs(useidx).num_regs() &&\n@@ -1131,1 +1131,1 @@\n-                  tmp_rm.SUBTRACT(Matcher::STACK_ONLY_mask);\n+                  tmp_rm.subtract(Matcher::STACK_ONLY_mask);\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-const RegMask RegMask::Empty;\n+const RegMask RegMask::EMPTY;\n@@ -52,1 +52,1 @@\n-const RegMask RegMask::All(\n+const RegMask RegMask::ALL(\n@@ -129,1 +129,1 @@\n-  return Size() == 2 && !is_aligned_pairs();\n+  return size() == 2 && !is_aligned_pairs();\n@@ -230,1 +230,1 @@\n-    if (!Member(reg - i)) {\n+    if (!member(reg - i)) {\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -302,33 +302,0 @@\n-  \/\/ Make us a copy of src\n-  void copy(const RegMask& src) {\n-    assert(_offset == src._offset, \"offset mismatch\");\n-    _hwm = src._hwm;\n-    _lwm = src._lwm;\n-\n-    \/\/ Copy base mask\n-    memcpy(_rm_word, src._rm_word, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n-    _infinite_stack = src._infinite_stack;\n-\n-    \/\/ Copy extension\n-    if (src._rm_word_ext != nullptr) {\n-      assert(src._rm_size_in_words > RM_SIZE_IN_WORDS, \"sanity\");\n-      assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n-      grow(src._rm_size_in_words, false);\n-      memcpy(_rm_word_ext, src._rm_word_ext,\n-             sizeof(uintptr_t) * (src._rm_size_in_words - RM_SIZE_IN_WORDS));\n-    }\n-\n-    \/\/ If the source is smaller than us, we need to set the gap according to\n-    \/\/ the sources infinite_stack flag.\n-    if (src._rm_size_in_words < _rm_size_in_words) {\n-      int value = 0;\n-      if (src.is_infinite_stack()) {\n-        value = 0xFF;\n-        _hwm = rm_word_max_index();\n-      }\n-      set_range(src._rm_size_in_words, value, _rm_size_in_words - src._rm_size_in_words);\n-    }\n-\n-    assert(valid_watermarks(), \"post-condition\");\n-  }\n-\n@@ -452,1 +419,1 @@\n-    Insert(reg);\n+    insert(reg);\n@@ -456,3 +423,18 @@\n-  \/\/ ----------------------------------------\n-  \/\/ Deep copying constructors and assignment\n-  \/\/ ----------------------------------------\n+  \/\/ Make us represent the same set of registers as src.\n+  void assignFrom(const RegMask& src) {\n+    assert(_offset == src._offset, \"offset mismatch\");\n+    _hwm = src._hwm;\n+    _lwm = src._lwm;\n+\n+    \/\/ Copy base mask\n+    memcpy(_rm_word, src._rm_word, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n+    _infinite_stack = src._infinite_stack;\n+\n+    \/\/ Copy extension\n+    if (src._rm_word_ext != nullptr) {\n+      assert(src._rm_size_in_words > RM_SIZE_IN_WORDS, \"sanity\");\n+      assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n+      grow(src._rm_size_in_words, false);\n+      memcpy(_rm_word_ext, src._rm_word_ext,\n+             sizeof(uintptr_t) * (src._rm_size_in_words - RM_SIZE_IN_WORDS));\n+    }\n@@ -460,0 +442,17 @@\n+    \/\/ If the source is smaller than us, we need to set the gap according to\n+    \/\/ the sources infinite_stack flag.\n+    if (src._rm_size_in_words < _rm_size_in_words) {\n+      int value = 0;\n+      if (src.is_infinite_stack()) {\n+        value = 0xFF;\n+        _hwm = rm_word_max_index();\n+      }\n+      set_range(src._rm_size_in_words, value, _rm_size_in_words - src._rm_size_in_words);\n+    }\n+\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n+  \/\/ Construct from other register mask (deep copy) and register an arena\n+  \/\/ for potential register mask extension. Passing nullptr as arena disables\n+  \/\/ extension.\n@@ -462,1 +461,1 @@\n-    copy(rm);\n+    assignFrom(rm);\n@@ -465,1 +464,2 @@\n-  RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n+  \/\/ Copy constructor (deep copy). By default does not allow extension.\n+  explicit RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n@@ -467,4 +467,2 @@\n-  RegMask& operator=(const RegMask& rm) {\n-    copy(rm);\n-    return *this;\n-  }\n+  \/\/ Disallow copy assignment (use assignFrom instead)\n+  RegMask& operator=(const RegMask&) = delete;\n@@ -476,1 +474,1 @@\n-  bool Member(OptoReg::Name reg) const {\n+  bool member(OptoReg::Name reg) const {\n@@ -489,1 +487,1 @@\n-  bool is_Empty() const {\n+  bool is_empty() const {\n@@ -645,1 +643,1 @@\n-  void Clear() {\n+  void clear() {\n@@ -654,1 +652,1 @@\n-  void Set_All() {\n+  void set_all() {\n@@ -656,1 +654,1 @@\n-    Set_All_From_Offset();\n+    set_all_from_offset();\n@@ -660,1 +658,1 @@\n-  void Set_All_From_Offset() {\n+  void set_all_from_offset() {\n@@ -669,1 +667,1 @@\n-  void Set_All_From(OptoReg::Name reg) {\n+  void set_all_from(OptoReg::Name reg) {\n@@ -692,1 +690,1 @@\n-  void Insert(OptoReg::Name reg) {\n+  void insert(OptoReg::Name reg) {\n@@ -709,1 +707,1 @@\n-  void Remove(OptoReg::Name reg) {\n+  void remove(OptoReg::Name reg) {\n@@ -717,2 +715,2 @@\n-  \/\/ OR 'rm' into 'this'\n-  void OR(const RegMask &rm) {\n+  \/\/ Or 'rm' into 'this'\n+  void or_with(const RegMask& rm) {\n@@ -739,2 +737,2 @@\n-  \/\/ AND 'rm' into 'this'\n-  void AND(const RegMask &rm) {\n+  \/\/ And 'rm' into 'this'\n+  void and_with(const RegMask& rm) {\n@@ -771,1 +769,1 @@\n-  void SUBTRACT(const RegMask &rm) {\n+  void subtract(const RegMask& rm) {\n@@ -794,1 +792,1 @@\n-  void SUBTRACT_inner(const RegMask& rm) {\n+  void subtract_inner(const RegMask& rm) {\n@@ -824,1 +822,1 @@\n-    Set_All_From_Offset();\n+    set_all_from_offset();\n@@ -829,1 +827,1 @@\n-  uint Size() const {\n+  uint size() const {\n@@ -898,2 +896,2 @@\n-  static const RegMask Empty;   \/\/ Common empty mask\n-  static const RegMask All;     \/\/ Common all mask\n+  static const RegMask EMPTY; \/\/ Common empty mask\n+  static const RegMask ALL;   \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":60,"deletions":62,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  return RegMask::Empty;\n+  return RegMask::EMPTY;\n","filename":"src\/hotspot\/share\/opto\/rootnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,0 +199,5 @@\n+  if (JvmtiEnvBase::get_phase() != JVMTI_PHASE_LIVE) {\n+    st->print_cr(\"Dynamic agent loading is only permitted in the live phase\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -882,1 +882,0 @@\n-  bool                 _has_been_modified;\n@@ -899,1 +898,0 @@\n-    _has_been_modified = false;\n@@ -938,2 +936,0 @@\n-  bool has_been_modified() { return _has_been_modified; }\n-\n@@ -986,1 +982,0 @@\n-      _has_been_modified = true;\n@@ -1061,1 +1056,1 @@\n-bool JvmtiExport::post_class_file_load_hook(Symbol* h_name,\n+void JvmtiExport::post_class_file_load_hook(Symbol* h_name,\n@@ -1068,1 +1063,1 @@\n-    return false;\n+    return;\n@@ -1072,1 +1067,1 @@\n-    return false;\n+    return;\n@@ -1080,1 +1075,0 @@\n-  return poster.has_been_modified();\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -380,2 +380,1 @@\n-  \/\/ Return true if the class was modified by the hook.\n-  static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,\n+  static void post_class_file_load_hook(Symbol* h_name, Handle class_loader,\n@@ -384,1 +383,1 @@\n-                                        JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);\n+                                        JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -564,0 +564,1 @@\n+  { \"ShenandoahPacing\",             JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1936,2 +1936,1 @@\n-#if INCLUDE_JVMCI\n-address Deoptimization::deoptimize_for_missing_exception_handler(nmethod* nm) {\n+address Deoptimization::deoptimize_for_missing_exception_handler(nmethod* nm, bool make_not_entrant) {\n@@ -1939,1 +1938,3 @@\n-  nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n+  if (make_not_entrant) {\n+    nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n+  }\n@@ -1953,0 +1954,9 @@\n+\n+  Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);\n+\n+  if (!nm->is_compiled_by_jvmci()) {\n+    return SharedRuntime::deopt_blob()->unpack_with_exception_in_tls();\n+  }\n+\n+#if INCLUDE_JVMCI\n+  \/\/ JVMCI support\n@@ -1968,1 +1978,0 @@\n-  Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);\n@@ -1974,0 +1983,1 @@\n+#endif\n@@ -1977,1 +1987,0 @@\n-#endif\n@@ -2880,0 +2889,1 @@\n+  \"not_compiled_exception_handler\",\n@@ -2883,1 +2893,0 @@\n-  \"not_compiled_exception_handler\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,1 @@\n+    Reason_not_compiled_exception_handler, \/\/ missing compiled exception handler\n@@ -124,1 +125,0 @@\n-    Reason_not_compiled_exception_handler,\n@@ -187,0 +187,1 @@\n+  static address deoptimize_for_missing_exception_handler(nmethod* nm, bool make_not_entrant);\n@@ -188,1 +189,0 @@\n-  static address deoptimize_for_missing_exception_handler(nmethod* nm);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -539,1 +539,0 @@\n-  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n@@ -1363,3 +1362,0 @@\n-  \/\/ Verify that the deferred card marks have been flushed.\n-  assert(deferred_card_mark().is_empty(), \"Should be empty during GC\");\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,5 +153,0 @@\n-  \/\/ See ReduceInitialCardMarks: this holds the precise space interval of\n-  \/\/ the most recent slow path allocation for which compiled code has\n-  \/\/ elided card-marks for performance along the fast-path.\n-  MemRegion     _deferred_card_mark;\n-\n@@ -783,3 +778,0 @@\n-  MemRegion deferred_card_mark() const           { return _deferred_card_mark; }\n-  void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,3 +117,1 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not create PerfData Memory region, reverting to malloc\");\n-    }\n+    log_debug(perf)(\"could not create PerfData Memory region, reverting to malloc\");\n@@ -253,4 +251,1 @@\n-      if (PrintMiscellaneous && Verbose) {\n-        warning(\"Invalid performance data file path name specified, \"\\\n-                \"fall back to a default name\");\n-      }\n+      log_debug(perf)(\"invalid performance data file path name specified, fall back to a default name\");\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-DEBUG_ONLY(JavaThread* ServiceThread::_instance = nullptr;)\n+JavaThread* ServiceThread::_instance = nullptr;\n@@ -65,1 +65,1 @@\n-  DEBUG_ONLY(_instance = thread;)\n+  _instance = thread;\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  DEBUG_ONLY(static JavaThread* _instance;)\n+  static JavaThread* _instance;\n@@ -47,0 +47,1 @@\n+  static bool has_started() { return  _instance != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -800,1 +800,2 @@\n-      return Deoptimization::deoptimize_for_missing_exception_handler(nm);\n+      bool make_not_entrant = true;\n+      return Deoptimization::deoptimize_for_missing_exception_handler(nm, make_not_entrant);\n@@ -856,0 +857,9 @@\n+\n+  \/\/ If the compiler did not anticipate a recursive exception, resulting in an exception\n+  \/\/ thrown from the catch bci, then the compiled exception handler might be missing.\n+  \/\/ This is rare.  Just deoptimize and let the interpreter handle it.\n+  if (t == nullptr && recursive_exception_occurred) {\n+    bool make_not_entrant = false;\n+    return Deoptimization::deoptimize_for_missing_exception_handler(nm, make_not_entrant);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -392,4 +392,0 @@\n-  static bool handle_ic_miss_helper_internal(Handle receiver, nmethod* caller_nm, const frame& caller_frame,\n-                                             methodHandle callee_method, Bytecodes::Code bc, CallInfo& call_info,\n-                                             bool& needs_ic_stub_refill, bool& is_optimized, bool caller_is_c1, TRAPS);\n-\n@@ -569,1 +565,0 @@\n-  static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+  if ((obj)->mark().is_inline_type()) {  \\\n@@ -325,1 +325,1 @@\n-  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+  if ((obj)->mark().is_inline_type()) {  \\\n@@ -357,1 +357,1 @@\n-  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n+  assert(!obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -449,1 +449,1 @@\n-  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"JITed code should never have locked an instance of a value class\");\n+  assert(!obj->klass()->is_inline_klass(), \"JITed code should never have locked an instance of a value class\");\n@@ -466,1 +466,1 @@\n-  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+  if (obj->klass()->is_inline_klass()) {\n@@ -684,4 +684,3 @@\n-  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n-    \/\/ VM should be calling bootstrap method\n-    ShouldNotReachHere();\n-  }\n+  \/\/ VM should be calling bootstrap method.\n+  assert(!obj->klass()->is_inline_klass(), \"FastHashCode should not be called for inline classes\");\n+\n@@ -789,1 +788,1 @@\n-  if (EnableValhalla && h_obj->mark().is_inline_type()) {\n+  if (h_obj->mark().is_inline_type()) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -346,0 +346,5 @@\n+  \/\/ This is before the execution of the very first Java bytecode.\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::link_classes(THREAD);\n+  }\n+\n@@ -746,0 +751,4 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    nmethod::post_delayed_compiled_method_load_events();\n+  }\n+\n@@ -778,1 +787,1 @@\n-    AOTLinkedClassBulkLoader::link_or_init_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::init_javabase_classes(THREAD);\n@@ -797,1 +806,1 @@\n-    AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::init_non_javabase_classes(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -801,1 +802,2 @@\n-  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)\n+  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)                               \\\n+  static_field(ContinuationEntry,              _return_pc,                                    address)\n@@ -1278,0 +1280,1 @@\n+  declare_toplevel_type(ContinuationEntry)                                \\\n@@ -1586,0 +1589,1 @@\n+  declare_constant(Deoptimization::Reason_not_compiled_exception_handler) \\\n@@ -1587,1 +1591,0 @@\n-  NOT_ZERO(JVMCI_ONLY(declare_constant(Deoptimization::Reason_not_compiled_exception_handler))) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -379,1 +379,3 @@\n-    return \"Print all threads with stacktraces.\";\n+    return \"Print all platform threads, and mounted virtual threads, \"\n+           \"with stack traces. The Thread.dump_to_file command will \"\n+           \"print all threads to a file.\";\n@@ -791,1 +793,2 @@\n-    return \"Dump threads, with stack traces, to a file in plain text or JSON format.\";\n+    return \"Dump all threads, with stack traces, \"\n+           \"to a file in plain text or JSON format.\";\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1451,2 +1451,2 @@\n-        byte[] newValue = (s instanceof String str)\n-            ? putStringAt(currValue, coder, count, dstOffset, str, start, end)\n+        byte[] newValue = (s instanceof String str && str.length() == len)\n+            ? putStringAt(currValue, coder, count, dstOffset, str)\n@@ -1931,1 +1931,1 @@\n-     private static byte[] putStringAt(byte[] value, byte coder, int count, int index, String str, int off, int end) {\n+     private static byte[] putStringAt(byte[] value, byte coder, int count, int index, String str) {\n@@ -1934,1 +1934,1 @@\n-        str.getBytes(newValue, off, index, coder, end - off);\n+        str.getBytes(newValue, 0, index, coder, str.length());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n- * @author  Nakul Saraiya\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,3 +364,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Joseph D. Darcy\n@@ -708,1 +705,0 @@\n-     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,3 +82,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Joseph D. Darcy\n@@ -424,1 +421,0 @@\n-     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Josh Bloch\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,4 +82,0 @@\n- * @author  Lee Boynton\n- * @author  Arthur van Hoff\n- * @author  Josh Bloch\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2532,1 +2532,0 @@\n-     * @author Joseph D. Darcy\n@@ -2579,1 +2578,0 @@\n-     * @author Joseph D. Darcy\n@@ -2620,1 +2618,0 @@\n-     * @author Joseph D. Darcy\n@@ -2642,1 +2639,0 @@\n-     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n- * @author  Nakul Saraiya\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n- * @author  Joseph D. Darcy\n@@ -496,1 +495,0 @@\n-     * @author Joseph D. Darcy\n@@ -2017,1 +2015,0 @@\n-     * @author Joseph D. Darcy\n@@ -2044,1 +2041,0 @@\n-     * @author Joseph D. Darcy\n@@ -2065,1 +2061,0 @@\n-     * @author Joseph D. Darcy\n@@ -2086,1 +2081,0 @@\n-     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.Opcode;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +39,1 @@\n+import java.lang.reflect.Modifier;\n@@ -40,0 +46,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -61,3 +69,3 @@\n-    private static final MethodHandle OBJECTS_EQUALS;\n-    private static final MethodHandle OBJECTS_HASHCODE;\n-    private static final MethodHandle OBJECTS_TOSTRING;\n+    private static final MethodHandle IS_NULL;\n+    private static final MethodHandle IS_ARG0_NULL;\n+    private static final MethodHandle IS_ARG1_NULL;\n@@ -66,0 +74,4 @@\n+    private static final MethodType MT_OBJECT_BOOLEAN = MethodType.methodType(boolean.class, Object.class);\n+    private static final MethodType MT_INT = MethodType.methodType(int.class);\n+    private static final MethodTypeDesc MTD_OBJECT_BOOLEAN = MethodTypeDesc.of(CD_boolean, CD_Object);\n+    private static final MethodTypeDesc MTD_INT = MethodTypeDesc.of(CD_int);\n@@ -71,1 +83,0 @@\n-    private static final HashMap<Class<?>, MethodHandle> primitiveToString = new HashMap<>();\n@@ -81,6 +92,6 @@\n-            OBJECTS_EQUALS = publicLookup.findStatic(Objects.class, \"equals\",\n-                                                     MethodType.methodType(boolean.class, Object.class, Object.class));\n-            OBJECTS_HASHCODE = publicLookup.findStatic(Objects.class, \"hashCode\",\n-                                                       MethodType.methodType(int.class, Object.class));\n-            OBJECTS_TOSTRING = publicLookup.findStatic(Objects.class, \"toString\",\n-                                                       MethodType.methodType(String.class, Object.class));\n+\n+            var objectsIsNull = publicLookup.findStatic(Objects.class, \"isNull\",\n+                                                        MethodType.methodType(boolean.class, Object.class));\n+            IS_NULL = objectsIsNull;\n+            IS_ARG0_NULL = MethodHandles.dropArguments(objectsIsNull, 1, Object.class);\n+            IS_ARG1_NULL = MethodHandles.dropArguments(objectsIsNull, 0, Object.class);\n@@ -126,17 +137,0 @@\n-\n-            primitiveToString.put(byte.class, lookup.findStatic(Byte.class, \"toString\",\n-                                                                MethodType.methodType(String.class, byte.class)));\n-            primitiveToString.put(short.class, lookup.findStatic(Short.class, \"toString\",\n-                                                                 MethodType.methodType(String.class, short.class)));\n-            primitiveToString.put(char.class, lookup.findStatic(Character.class, \"toString\",\n-                                                                MethodType.methodType(String.class, char.class)));\n-            primitiveToString.put(int.class, lookup.findStatic(Integer.class, \"toString\",\n-                                                               MethodType.methodType(String.class, int.class)));\n-            primitiveToString.put(long.class, lookup.findStatic(Long.class, \"toString\",\n-                                                                MethodType.methodType(String.class, long.class)));\n-            primitiveToString.put(float.class, lookup.findStatic(Float.class, \"toString\",\n-                                                                 MethodType.methodType(String.class, float.class)));\n-            primitiveToString.put(double.class, lookup.findStatic(Double.class, \"toString\",\n-                                                                  MethodType.methodType(String.class, double.class)));\n-            primitiveToString.put(boolean.class, lookup.findStatic(Boolean.class, \"toString\",\n-                                                                   MethodType.methodType(String.class, boolean.class)));\n@@ -164,4 +158,7 @@\n-    private static MethodHandle equalator(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveEquals.get(clazz)\n-                : OBJECTS_EQUALS.asType(MethodType.methodType(boolean.class, clazz, clazz)));\n+    private static MethodHandle equalator(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n+        if (clazz.isPrimitive())\n+            return primitiveEquals.get(clazz);\n+        MethodType mt = MethodType.methodType(boolean.class, clazz, clazz);\n+        return MethodHandles.guardWithTest(IS_ARG0_NULL.asType(mt),\n+                                           IS_ARG1_NULL.asType(mt),\n+                                           lookup.findVirtual(clazz, \"equals\", MT_OBJECT_BOOLEAN).asType(mt));\n@@ -171,4 +168,7 @@\n-    private static MethodHandle hasher(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveHashers.get(clazz)\n-                : OBJECTS_HASHCODE.asType(MethodType.methodType(int.class, clazz)));\n+    private static MethodHandle hasher(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n+        if (clazz.isPrimitive())\n+            return primitiveHashers.get(clazz);\n+        MethodType mt = MethodType.methodType(int.class, clazz);\n+        return MethodHandles.guardWithTest(IS_NULL.asType(MethodType.methodType(boolean.class, clazz)),\n+                                           MethodHandles.dropArguments(MethodHandles.zero(int.class), 0, clazz),\n+                                           lookup.findVirtual(clazz, \"hashCode\", MT_INT).asType(mt));\n@@ -177,5 +177,16 @@\n-    \/** Get the stringifier for a value of a given type *\/\n-    private static MethodHandle stringifier(Class<?> clazz) {\n-        return (clazz.isPrimitive()\n-                ? primitiveToString.get(clazz)\n-                : OBJECTS_TOSTRING.asType(MethodType.methodType(String.class, clazz)));\n+    \/\/ If this type must be a monomorphic receiver, that is, one that has no\n+    \/\/ subtypes in the JVM.  For example, Object-typed fields may have a more\n+    \/\/ specific one type at runtime and thus need optimizations.\n+    private static boolean isMonomorphic(Class<?> type) {\n+        \/\/ Includes primitives and final classes, but not arrays.\n+        \/\/ All array classes are reported to be final, but Object[] can have subtypes like String[]\n+        return Modifier.isFinal(type.getModifiers()) && !type.isArray();\n+    }\n+\n+    private static String specializerClassName(Class<?> targetClass, String kind) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$\" + kind + \"Specializer\";\n@@ -190,2 +201,2 @@\n-    private static MethodHandle makeEquals(Class<?> receiverClass,\n-                                          List<MethodHandle> getters) {\n+    private static MethodHandle makeEquals(MethodHandles.Lookup lookup, Class<?> receiverClass,\n+                                           List<MethodHandle> getters) throws Throwable {\n@@ -200,2 +211,64 @@\n-        for (MethodHandle getter : getters) {\n-            MethodHandle equalator = equalator(getter.type().returnType()); \/\/ (TT)Z\n+        int size = getters.size();\n+        MethodHandle[] equalators = new MethodHandle[size];\n+        boolean hasPolymorphism = false;\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            var type = getter.type().returnType();\n+            if (isMonomorphic(type)) {\n+                equalators[i] = equalator(lookup, type);\n+            } else {\n+                hasPolymorphism = true;\n+            }\n+        }\n+\n+        \/\/ Currently, hotspot does not support polymorphic inlining.\n+        \/\/ As a result, if we have a MethodHandle to Object.equals,\n+        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n+        \/\/ and we must spin bytecode to accomplish separate profiling.\n+        if (hasPolymorphism) {\n+            String[] names = new String[size];\n+\n+            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n+            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Equalator\")), clb -> {\n+                for (int i = 0; i < size; i++) {\n+                    if (equalators[i] == null) {\n+                        var name = \"equalator\".concat(Integer.toString(i));\n+                        names[i] = name;\n+                        var type = getters.get(i).type().returnType();\n+                        boolean isInterface = type.isInterface();\n+                        var typeDesc = type.describeConstable().orElseThrow();\n+                        clb.withMethodBody(name, MethodTypeDesc.of(CD_boolean, typeDesc, typeDesc), ACC_STATIC, cob -> {\n+                            var nonNullPath = cob.newLabel();\n+                            var fail = cob.newLabel();\n+                            cob.aload(0)\n+                               .ifnonnull(nonNullPath)\n+                               .aload(1)\n+                               .ifnonnull(fail)\n+                               .iconst_1() \/\/ arg0 null, arg1 null\n+                               .ireturn()\n+                               .labelBinding(fail)\n+                               .iconst_0() \/\/ arg0 null, arg1 non-null\n+                               .ireturn()\n+                               .labelBinding(nonNullPath)\n+                               .aload(0) \/\/ arg0.equals(arg1) - bytecode subject to customized profiling\n+                               .aload(1)\n+                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"equals\", MTD_OBJECT_BOOLEAN, isInterface)\n+                               .ireturn();\n+                        });\n+                    }\n+                }\n+            });\n+\n+            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n+\n+            for (int i = 0; i < size; i++) {\n+                if (equalators[i] == null) {\n+                    var type = getters.get(i).type().returnType();\n+                    equalators[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(boolean.class, type, type));\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            MethodHandle equalator = equalators[i]; \/\/ (TT)Z\n@@ -217,2 +290,2 @@\n-    private static MethodHandle makeHashCode(Class<?> receiverClass,\n-                                            List<MethodHandle> getters) {\n+    private static MethodHandle makeHashCode(MethodHandles.Lookup lookup, Class<?> receiverClass,\n+                                             List<MethodHandle> getters) throws Throwable {\n@@ -221,0 +294,54 @@\n+        int size = getters.size();\n+        MethodHandle[] hashers = new MethodHandle[size];\n+        boolean hasPolymorphism = false;\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            var type = getter.type().returnType();\n+            if (isMonomorphic(type)) {\n+                hashers[i] = hasher(lookup, type);\n+            } else {\n+                hasPolymorphism = true;\n+            }\n+        }\n+\n+        \/\/ Currently, hotspot does not support polymorphic inlining.\n+        \/\/ As a result, if we have a MethodHandle to Object.hashCode,\n+        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n+        \/\/ and we must spin bytecode to accomplish separate profiling.\n+        if (hasPolymorphism) {\n+            String[] names = new String[size];\n+\n+            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n+            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Hasher\")), clb -> {\n+                for (int i = 0; i < size; i++) {\n+                    if (hashers[i] == null) {\n+                        var name = \"hasher\".concat(Integer.toString(i));\n+                        names[i] = name;\n+                        var type = getters.get(i).type().returnType();\n+                        boolean isInterface = type.isInterface();\n+                        var typeDesc = type.describeConstable().orElseThrow();\n+                        clb.withMethodBody(name, MethodTypeDesc.of(CD_int, typeDesc), ACC_STATIC, cob -> {\n+                            var nonNullPath = cob.newLabel();\n+                            cob.aload(0)\n+                               .ifnonnull(nonNullPath)\n+                               .iconst_0() \/\/ null hash is 0\n+                               .ireturn()\n+                               .labelBinding(nonNullPath)\n+                               .aload(0) \/\/ arg0.hashCode() - bytecode subject to customized profiling\n+                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"hashCode\", MTD_INT, isInterface)\n+                               .ireturn();\n+                        });\n+                    }\n+                }\n+            });\n+\n+            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n+\n+            for (int i = 0; i < size; i++) {\n+                if (hashers[i] == null) {\n+                    var type = getters.get(i).type().returnType();\n+                    hashers[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(int.class, type));\n+                }\n+            }\n+        }\n+\n@@ -222,2 +349,3 @@\n-        for (MethodHandle getter : getters) {\n-            MethodHandle hasher = hasher(getter.type().returnType()); \/\/ (T)I\n+        for (int i = 0; i < size; i++) {\n+            var getter = getters.get(i);\n+            MethodHandle hasher = hashers[i]; \/\/ (T)I\n@@ -416,1 +544,1 @@\n-                yield makeEquals(recordClass, getterList);\n+                yield makeEquals(lookup, recordClass, getterList);\n@@ -421,1 +549,1 @@\n-                yield makeHashCode(recordClass, getterList);\n+                yield makeHashCode(lookup, recordClass, getterList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":178,"deletions":50,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -330,4 +330,0 @@\n- * @author  Josh Bloch\n- * @author  Mike Cowlishaw\n- * @author  Joseph D. Darcy\n- * @author  Sergey V. Kuksenko\n@@ -1782,1 +1778,0 @@\n-     * @author Joseph D. Darcy\n@@ -1951,1 +1946,0 @@\n-     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n- * @author  Mike Cowlishaw\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/math\/MathContext.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,3 +118,0 @@\n- * @author  Josh Bloch\n- * @author  Mike Cowlishaw\n- * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/math\/RoundingMode.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,15 +38,1 @@\n-public final class ByteOrder {\n-\n-    private final String name;\n-\n-    private ByteOrder(String name) {\n-        this.name = name;\n-    }\n-\n-    \/**\n-     * Constant denoting big-endian byte order.  In this order, the bytes of a\n-     * multibyte value are ordered from most significant to least significant.\n-     *\/\n-    public static final ByteOrder BIG_ENDIAN\n-        = new ByteOrder(\"BIG_ENDIAN\");\n-\n+public enum ByteOrder  {\n@@ -58,2 +44,7 @@\n-    public static final ByteOrder LITTLE_ENDIAN\n-        = new ByteOrder(\"LITTLE_ENDIAN\");\n+    LITTLE_ENDIAN,\n+    \/**\n+     * Constant denoting big-endian byte order.  In this order, the bytes of a\n+     * multibyte value are ordered from most significant to least significant.\n+     *\/\n+    BIG_ENDIAN;\n+\n@@ -81,14 +72,0 @@\n-\n-    \/**\n-     * Constructs a string describing this object.\n-     *\n-     * <p> This method returns the string\n-     * {@code \"BIG_ENDIAN\"} for {@link #BIG_ENDIAN} and\n-     * {@code \"LITTLE_ENDIAN\"} for {@link #LITTLE_ENDIAN}.\n-     *\n-     * @return  The specified string\n-     *\/\n-    public String toString() {\n-        return name;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteOrder.java","additions":9,"deletions":32,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-     * <p> Unless otherwise specified, a write operation will return only after\n+     * <p> For many types of channels, a write operation will return only after\n@@ -82,2 +82,5 @@\n-     * none at all.  A socket channel in non-blocking mode, for example, cannot\n-     * write any more bytes than are free in the socket's output buffer.\n+     * none at all.  A socket channel in {@linkplain\n+     * SelectableChannel#isBlocking non-blocking mode}, for example, cannot\n+     * write any more bytes than are free in the socket's output buffer.  The\n+     * write method may need to be invoked more than once to ensure that all\n+     * {@linkplain ByteBuffer#hasRemaining remaining} bytes are written.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/GatheringByteChannel.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-     * <p> Unless otherwise specified, a write operation will return only after\n+     * <p> For many types of channels, a write operation will return only after\n@@ -71,2 +71,5 @@\n-     * none at all.  A socket channel in non-blocking mode, for example, cannot\n-     * write any more bytes than are free in the socket's output buffer.\n+     * none at all.  A socket channel in {@linkplain\n+     * SelectableChannel#isBlocking non-blocking mode}, for example, cannot\n+     * write any more bytes than are free in the socket's output buffer.  The\n+     * write method may need to be invoked more than once to ensure that all\n+     * {@linkplain ByteBuffer#hasRemaining remaining} bytes are written.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/WritableByteChannel.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -149,0 +149,31 @@\n+    \/**\n+     * The minimum supported {@code Duration}, which is {@link Long#MIN_VALUE}\n+     * seconds.\n+     *\n+     * @apiNote This constant represents the smallest possible instance of\n+     * {@code Duration}. Since {@code Duration} is directed, the smallest\n+     * possible duration is negative.\n+     *\n+     * The constant is intended to be used as a sentinel value or in tests.\n+     * Care should be taken when performing arithmetic on {@code MIN} as there\n+     * is a high risk that {@link ArithmeticException} or {@link DateTimeException}\n+     * will be thrown.\n+     *\n+     * @since 26\n+     *\/\n+    public static final Duration MIN = new Duration(Long.MIN_VALUE, 0);\n+    \/**\n+     * The maximum supported {@code Duration}, which is {@link Long#MAX_VALUE}\n+     * seconds and {@code 999,999,999} nanoseconds.\n+     *\n+     * @apiNote This constant represents the largest possible instance of\n+     * {@code Duration}.\n+     *\n+     * The constant is intended to be used as a sentinel value or in tests.\n+     * Care should be taken when performing arithmetic on {@code MAX} as there\n+     * is a high risk that {@link ArithmeticException} or {@link DateTimeException}\n+     * will be thrown.\n+     *\n+     * @since 26\n+     *\/\n+    public static final Duration MAX = new Duration(Long.MAX_VALUE, 999_999_999);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,2 +187,1 @@\n-     * The estimated duration of this unit is artificially defined as the largest duration\n-     * supported by {@link Duration}.\n+     * The estimated duration of this unit is artificially defined as {@link Duration#MAX}.\n@@ -190,1 +189,1 @@\n-    FOREVER(\"Forever\", Duration.ofSeconds(Long.MAX_VALUE, 999_999_999));\n+    FOREVER(\"Forever\", Duration.MAX);\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/ChronoUnit.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,17 @@\n+ * Defines the header and version information for jimage files.\n+ *\n+ * <p>Version number changes must be synced in a single change across all code\n+ * which reads\/writes jimage files, and code which tries to open a jimage file\n+ * with an unexpected version should fail.\n+ *\n+ * <p>Known jimage file code which needs updating on version change:\n+ * <ul>\n+ *     <li>src\/java.base\/share\/native\/libjimage\/imageFile.hpp\n+ * <\/ul>\n+ *\n+ * <p>Version history:\n+ * <ul>\n+ *     <li>{@code 1.0}: Original version.\n+ *     <li>{@code 1.1}: Support preview mode with new flags.\n+ * <\/ul>\n+ *\n@@ -42,1 +59,1 @@\n-    public static final int MINOR_VERSION = 0;\n+    public static final int MINOR_VERSION = 1;\n@@ -55,1 +72,1 @@\n-            int locationsSize, int stringsSize) {\n+                       int locationsSize, int stringsSize) {\n@@ -61,3 +78,2 @@\n-                int flags, int resourceCount,\n-                int tableLength, int locationsSize, int stringsSize)\n-    {\n+                       int flags, int resourceCount,\n+                       int tableLength, int locationsSize, int stringsSize) {\n@@ -75,1 +91,1 @@\n-       return HEADER_SLOTS * 4;\n+        return HEADER_SLOTS * 4;\n@@ -83,1 +99,1 @@\n-                \"jimage header not the correct size: \" + buffer.capacity());\n+                    \"jimage header not the correct size: \" + buffer.capacity());\n@@ -97,1 +113,1 @@\n-            resourceCount, tableLength, locationsSize, stringsSize);\n+                resourceCount, tableLength, locationsSize, stringsSize);\n@@ -159,4 +175,4 @@\n-               getRedirectSize() +\n-               getOffsetsSize() +\n-               getLocationsSize() +\n-               getStringsSize();\n+                getRedirectSize() +\n+                getOffsetsSize() +\n+                getLocationsSize() +\n+                getStringsSize();\n@@ -171,1 +187,1 @@\n-               getRedirectSize();\n+                getRedirectSize();\n@@ -176,1 +192,1 @@\n-               getOffsetsSize();\n+                getOffsetsSize();\n@@ -181,1 +197,1 @@\n-               getLocationsSize();\n+                getLocationsSize();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageHeader.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.List;\n@@ -30,0 +31,1 @@\n+import java.util.function.Predicate;\n@@ -39,0 +41,3 @@\n+    \/\/ Also defined in src\/java.base\/share\/native\/libjimage\/imageFile.hpp\n+\n+    \/** End of attribute stream marker. *\/\n@@ -40,0 +45,1 @@\n+    \/** String table offset of module name. *\/\n@@ -41,0 +47,1 @@\n+    \/** String table offset of resource path parent. *\/\n@@ -42,0 +49,1 @@\n+    \/** String table offset of resource path base. *\/\n@@ -43,0 +51,1 @@\n+    \/** String table offset of resource path extension. *\/\n@@ -44,0 +53,1 @@\n+    \/** Container byte offset of resource. *\/\n@@ -45,0 +55,1 @@\n+    \/** In-image byte size of the compressed resource. *\/\n@@ -46,0 +57,1 @@\n+    \/** In-memory byte size of the uncompressed resource. *\/\n@@ -47,1 +59,145 @@\n-    public static final int ATTRIBUTE_COUNT = 8;\n+    \/** Flags relating to preview mode resources. *\/\n+    public static final int ATTRIBUTE_PREVIEW_FLAGS = 8;\n+    \/** Number of attribute kinds. *\/\n+    public static final int ATTRIBUTE_COUNT = 9;\n+\n+    \/\/ Flag masks for the ATTRIBUTE_PREVIEW_FLAGS attribute. Defined so\n+    \/\/ that zero is the overwhelmingly common case for normal resources.\n+\n+    \/**\n+     * Indicates that a non-preview location is associated with preview\n+     * resources.\n+     *\n+     * <p>This can apply to both resources and directories in the\n+     * {@code \/modules\/xxx\/...} namespace, as well as {@code \/packages\/xxx}\n+     * directories.\n+     *\n+     * <p>For {@code \/packages\/xxx} directories, it indicates that the package\n+     * has preview resources in one of the modules in which it exists.\n+     *\/\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n+    \/**\n+     * Set on all locations in the {@code \/modules\/xxx\/META-INF\/preview\/...}\n+     * namespace.\n+     *\n+     * <p>This flag is mutually exclusive with {@link #FLAGS_HAS_PREVIEW_VERSION}.\n+     *\/\n+    private static final int FLAGS_IS_PREVIEW_VERSION = 0x2;\n+    \/**\n+     * Indicates that a location only exists due to preview resources.\n+     *\n+     * <p>This can apply to both resources and directories in the\n+     * {@code \/modules\/xxx\/...} namespace, as well as {@code \/packages\/xxx}\n+     * directories.\n+     *\n+     * <p>For {@code \/packages\/xxx} directories it indicates that, for every\n+     * module in which the package exists, it is preview only.\n+     *\n+     * <p>This flag is mutually exclusive with {@link #FLAGS_HAS_PREVIEW_VERSION}\n+     * and need not imply that {@link #FLAGS_IS_PREVIEW_VERSION} is set (i.e.\n+     * for {@code \/packages\/xxx} directories).\n+     *\/\n+    private static final int FLAGS_IS_PREVIEW_ONLY = 0x4;\n+\n+    \/\/ Also used in ImageReader.\n+    static final String MODULES_PREFIX = \"\/modules\";\n+    static final String PACKAGES_PREFIX = \"\/packages\";\n+    static final String PREVIEW_INFIX = \"\/META-INF\/preview\";\n+\n+    \/**\n+     * Helper function to calculate preview flags (ATTRIBUTE_PREVIEW_FLAGS).\n+     *\n+     * <p>Since preview flags are calculated separately for resource nodes and\n+     * directory nodes (in two quite different places) it's useful to have a\n+     * common helper.\n+     *\n+     * <p>Based on the entry name, the flags are:\n+     * <ul>\n+     *     <li>{@code \"[\/modules]\/<module>\/<path>\"} normal resource or directory:<br>\n+     *     Zero, or {@code FLAGS_HAS_PREVIEW_VERSION} if a preview entry exists.\n+     *     <li>{@code \"[\/modules]\/<module>\/META-INF\/preview\/<path>\"} preview\n+     *     resource or directory:<br>\n+     *     {@code FLAGS_IS_PREVIEW_VERSION}, and additionally {@code\n+     *     FLAGS_IS_PREVIEW_ONLY} if no normal version of the resource exists.\n+     *     <li>In all other cases, returned flags are zero (note that {@code\n+     *     \"\/packages\/xxx\"} entries may have flags, but these are calculated\n+     *     elsewhere).\n+     * <\/ul>\n+     *\n+     * @param name the jimage name of the resource or directory.\n+     * @param hasEntry a predicate for jimage names returning whether an entry\n+     *     is present.\n+     * @return flags for the ATTRIBUTE_PREVIEW_FLAGS attribute.\n+     *\/\n+    public static int getFlags(String name, Predicate<String> hasEntry) {\n+        if (name.startsWith(PACKAGES_PREFIX + \"\/\")) {\n+            throw new IllegalArgumentException(\n+                    \"Package sub-directory flags handled separately: \" + name);\n+        }\n+        \/\/ Find suffix for either '\/modules\/xxx\/suffix' or '\/xxx\/suffix' paths.\n+        int idx = name.startsWith(MODULES_PREFIX + \"\/\") ? MODULES_PREFIX.length() + 1 : 1;\n+        int suffixStart = name.indexOf('\/', idx);\n+        if (suffixStart == -1) {\n+            \/\/ No flags for '[\/modules]\/xxx' paths (esp. '\/modules', '\/packages').\n+            \/\/ '\/packages\/xxx' entries have flags, but not calculated here.\n+            return 0;\n+        }\n+        \/\/ Prefix is either '\/modules\/xxx' or '\/xxx', and suffix starts with '\/'.\n+        String prefix = name.substring(0, suffixStart);\n+        String suffix = name.substring(suffixStart);\n+        if (suffix.startsWith(PREVIEW_INFIX + \"\/\")) {\n+            \/\/ Preview resources\/directories.\n+            String nonPreviewName = prefix + suffix.substring(PREVIEW_INFIX.length());\n+            return FLAGS_IS_PREVIEW_VERSION\n+                    | (hasEntry.test(nonPreviewName) ? 0 : FLAGS_IS_PREVIEW_ONLY);\n+        } else if (!suffix.startsWith(\"\/META-INF\/\")) {\n+            \/\/ Non-preview resources\/directories.\n+            String previewName = prefix + PREVIEW_INFIX + suffix;\n+            return hasEntry.test(previewName) ? FLAGS_HAS_PREVIEW_VERSION : 0;\n+        } else {\n+            \/\/ Suffix is '\/META-INF\/xxx' and no preview version is even possible.\n+            return 0;\n+        }\n+    }\n+\n+    \/**\n+     * Helper function to calculate package flags for {@code \"\/packages\/xxx\"}\n+     * directory entries.\n+     *\n+     * <p>Based on the module references, the flags are:\n+     * <ul>\n+     *     <li>{@code FLAGS_HAS_PREVIEW_VERSION} if <em>any<\/em> referenced\n+     *     package has a preview version.\n+     *     <li>{@code FLAGS_IS_PREVIEW_ONLY} if <em>all<\/em> referenced packages\n+     *     are preview only.\n+     * <\/ul>\n+     *\n+     * @return package flags for {@code \"\/packages\/xxx\"} directory entries.\n+     *\/\n+    public static int getPackageFlags(List<ModuleReference> moduleReferences) {\n+        boolean hasPreviewVersion =\n+                moduleReferences.stream().anyMatch(ModuleReference::hasPreviewVersion);\n+        boolean isPreviewOnly =\n+                moduleReferences.stream().allMatch(ModuleReference::isPreviewOnly);\n+        return (hasPreviewVersion ? ImageLocation.FLAGS_HAS_PREVIEW_VERSION : 0)\n+                | (isPreviewOnly ? ImageLocation.FLAGS_IS_PREVIEW_ONLY : 0);\n+    }\n+\n+    \/**\n+     * Tests a non-preview image location's flags to see if it has preview\n+     * content associated with it.\n+     *\/\n+    public static boolean hasPreviewVersion(int flags) {\n+        return (flags & FLAGS_HAS_PREVIEW_VERSION) != 0;\n+    }\n+\n+    \/**\n+     * Tests an image location's flags to see if it only exists in preview mode.\n+     *\/\n+    public static boolean isPreviewOnly(int flags) {\n+        return (flags & FLAGS_IS_PREVIEW_ONLY) != 0;\n+    }\n+\n+    public enum LocationType {\n+        RESOURCE, MODULES_ROOT, MODULES_DIR, PACKAGES_ROOT, PACKAGES_DIR;\n+    }\n@@ -75,1 +231,1 @@\n-                    \"Invalid jimage attribute kind: \" + kind);\n+                        \"Invalid jimage attribute kind: \" + kind);\n@@ -97,1 +253,1 @@\n-                    stream.put((int)(value >> (i << 3)));\n+                    stream.put((int) (value >> (i << 3)));\n@@ -105,1 +261,1 @@\n-     }\n+    }\n@@ -120,1 +276,1 @@\n-        int moduleOffset = (int)attributes[ATTRIBUTE_MODULE];\n+        int moduleOffset = (int) attributes[ATTRIBUTE_MODULE];\n@@ -191,1 +347,1 @@\n-            ImageStrings strings) {\n+                          ImageStrings strings) {\n@@ -203,1 +359,1 @@\n-            int moduleOffset, int parentOffset, int baseOffset, int extOffset, ImageStrings strings) {\n+                                      int moduleOffset, int parentOffset, int baseOffset, int extOffset, ImageStrings strings) {\n@@ -243,1 +399,1 @@\n-                \"Invalid jimage attribute kind: \" + kind);\n+                    \"Invalid jimage attribute kind: \" + kind);\n@@ -251,1 +407,1 @@\n-                \"Invalid jimage attribute kind: \" + kind);\n+                    \"Invalid jimage attribute kind: \" + kind);\n@@ -253,1 +409,1 @@\n-        return getStrings().get((int)attributes[kind]);\n+        return getStrings().get((int) attributes[kind]);\n@@ -261,1 +417,1 @@\n-        return (int)getAttribute(ATTRIBUTE_MODULE);\n+        return (int) getAttribute(ATTRIBUTE_MODULE);\n@@ -269,1 +425,1 @@\n-        return (int)getAttribute(ATTRIBUTE_BASE);\n+        return (int) getAttribute(ATTRIBUTE_BASE);\n@@ -277,1 +433,1 @@\n-        return (int)getAttribute(ATTRIBUTE_PARENT);\n+        return (int) getAttribute(ATTRIBUTE_PARENT);\n@@ -285,1 +441,5 @@\n-        return (int)getAttribute(ATTRIBUTE_EXTENSION);\n+        return (int) getAttribute(ATTRIBUTE_EXTENSION);\n+    }\n+\n+    public int getFlags() {\n+        return (int) getAttribute(ATTRIBUTE_PREVIEW_FLAGS);\n@@ -297,1 +457,1 @@\n-                builder.append(\"\/modules\");\n+                builder.append(MODULES_PREFIX);\n@@ -320,30 +480,0 @@\n-    String buildName(boolean includeModule, boolean includeParent,\n-            boolean includeName) {\n-        StringBuilder builder = new StringBuilder();\n-\n-        if (includeModule && getModuleOffset() != 0) {\n-            builder.append(\"\/modules\/\");\n-            builder.append(getModule());\n-         }\n-\n-        if (includeParent && getParentOffset() != 0) {\n-            builder.append('\/');\n-            builder.append(getParent());\n-        }\n-\n-        if (includeName) {\n-            if (includeModule || includeParent) {\n-                builder.append('\/');\n-            }\n-\n-            builder.append(getBase());\n-\n-            if (getExtensionOffset() != 0) {\n-                builder.append('.');\n-                builder.append(getExtension());\n-            }\n-        }\n-\n-        return builder.toString();\n-   }\n-\n@@ -362,0 +492,36 @@\n+    \/\/ Fast (zero allocation) type determination for locations.\n+    public LocationType getType() {\n+        switch (getModuleOffset()) {\n+            case ImageStrings.MODULES_STRING_OFFSET:\n+                \/\/ Locations in \/modules\/... namespace are directory entries.\n+                return LocationType.MODULES_DIR;\n+            case ImageStrings.PACKAGES_STRING_OFFSET:\n+                \/\/ Locations in \/packages\/... namespace are always 2-level\n+                \/\/ \"\/packages\/xxx\" directories.\n+                return LocationType.PACKAGES_DIR;\n+            case ImageStrings.EMPTY_STRING_OFFSET:\n+                \/\/ Only 2 choices, either the \"\/modules\" or \"\/packages\" root.\n+                assert isRootDir() : \"Invalid root directory: \" + getFullName();\n+                return getBase().charAt(1) == 'p'\n+                        ? LocationType.PACKAGES_ROOT\n+                        : LocationType.MODULES_ROOT;\n+            default:\n+                \/\/ Anything else is \/<module>\/<path> and references a resource.\n+                return LocationType.RESOURCE;\n+        }\n+    }\n+\n+    private boolean isRootDir() {\n+        if (getModuleOffset() == 0 && getParentOffset() == 0) {\n+            String name = getFullName();\n+            return name.equals(MODULES_PREFIX) || name.equals(PACKAGES_PREFIX);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Cannot use String.format() (too early in startup for locale code).\n+        return \"ImageLocation[name='\" + getFullName() + \"', type=\" + getType() + \", flags=\" + getFlags() + \"]\";\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageLocation.java","additions":212,"deletions":46,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.ImageLocation.LocationType;\n+\n@@ -37,0 +39,1 @@\n+import java.util.Comparator;\n@@ -43,0 +46,1 @@\n+import java.util.TreeMap;\n@@ -47,0 +51,8 @@\n+import static jdk.internal.jimage.ImageLocation.LocationType.MODULES_DIR;\n+import static jdk.internal.jimage.ImageLocation.LocationType.MODULES_ROOT;\n+import static jdk.internal.jimage.ImageLocation.LocationType.PACKAGES_DIR;\n+import static jdk.internal.jimage.ImageLocation.LocationType.RESOURCE;\n+import static jdk.internal.jimage.ImageLocation.MODULES_PREFIX;\n+import static jdk.internal.jimage.ImageLocation.PACKAGES_PREFIX;\n+import static jdk.internal.jimage.ImageLocation.PREVIEW_INFIX;\n+\n@@ -89,2 +101,4 @@\n-     * Opens an image reader for a jimage file at the specified path, using the\n-     * given byte order.\n+     * Opens an image reader for a jimage file at the specified path.\n+     *\n+     * @param imagePath file system path of the jimage file.\n+     * @param mode whether to return preview resources.\n@@ -92,5 +106,2 @@\n-    public static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n-        Objects.requireNonNull(imagePath);\n-        Objects.requireNonNull(byteOrder);\n-\n-        return SharedImageReader.open(imagePath, byteOrder);\n+    public static ImageReader open(Path imagePath, PreviewMode mode) throws IOException {\n+        return open(imagePath, ByteOrder.nativeOrder(), mode);\n@@ -100,2 +111,5 @@\n-     * Opens an image reader for a jimage file at the specified path, using the\n-     * platform native byte order.\n+     * Opens an image reader for a jimage file at the specified path.\n+     *\n+     * @param imagePath file system path of the jimage file.\n+     * @param byteOrder the byte-order to be used when reading the jimage file.\n+     * @param mode controls whether preview resources are visible.\n@@ -103,2 +117,5 @@\n-    public static ImageReader open(Path imagePath) throws IOException {\n-        return open(imagePath, ByteOrder.nativeOrder());\n+    public static ImageReader open(Path imagePath, ByteOrder byteOrder, PreviewMode mode)\n+            throws IOException {\n+        Objects.requireNonNull(imagePath);\n+        Objects.requireNonNull(byteOrder);\n+        return SharedImageReader.open(imagePath, byteOrder, mode.isPreviewModeEnabled());\n@@ -217,3 +234,0 @@\n-        private static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n-        private static final String MODULES_ROOT = \"\/modules\";\n-        private static final String PACKAGES_ROOT = \"\/packages\";\n@@ -225,0 +239,27 @@\n+        static final class ReaderKey {\n+            private final Path imagePath;\n+            private final boolean previewMode;\n+\n+            public ReaderKey(Path imagePath, boolean previewMode) {\n+                this.imagePath = imagePath;\n+                this.previewMode = previewMode;\n+            }\n+\n+            @Override\n+            public boolean equals(Object obj) {\n+                \/\/ No pattern variables here (Java 8 compatible source).\n+                if (obj instanceof ReaderKey) {\n+                    ReaderKey other = (ReaderKey) obj;\n+                    return this.imagePath.equals(other.imagePath) && this.previewMode == other.previewMode;\n+                }\n+                return false;\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return imagePath.hashCode() ^ Boolean.hashCode(previewMode);\n+            }\n+        }\n+\n+        private static final Map<ReaderKey, SharedImageReader> OPEN_FILES = new HashMap<>();\n+\n@@ -235,3 +276,0 @@\n-        \/\/ Used to classify ImageLocation instances without string comparison.\n-        private final int modulesStringOffset;\n-        private final int packagesStringOffset;\n@@ -239,1 +277,8 @@\n-        private SharedImageReader(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        \/\/ Preview mode support.\n+        private final boolean previewMode;\n+        \/\/ A relativized mapping from non-preview name to directories containing\n+        \/\/ preview-only nodes. This is used to add preview-only content to\n+        \/\/ directories as they are completed.\n+        private final HashMap<String, Directory> previewDirectoriesToMerge;\n+\n+        private SharedImageReader(Path imagePath, ByteOrder byteOrder, boolean previewMode) throws IOException {\n@@ -243,4 +288,1 @@\n-            \/\/ Pick stable jimage names from which to extract string offsets (we cannot\n-            \/\/ use \"\/modules\" or \"\/packages\", since those have a module offset of zero).\n-            this.modulesStringOffset = getModuleOffset(\"\/modules\/java.base\");\n-            this.packagesStringOffset = getModuleOffset(\"\/packages\/java.lang\");\n+            this.previewMode = previewMode;\n@@ -250,4 +292,2 @@\n-            Directory packages = newDirectory(PACKAGES_ROOT);\n-            nodes.put(packages.getName(), packages);\n-            Directory modules = newDirectory(MODULES_ROOT);\n-            nodes.put(modules.getName(), modules);\n+            Directory packages = ensureCached(newDirectory(PACKAGES_PREFIX));\n+            Directory modules = ensureCached(newDirectory(MODULES_PREFIX));\n@@ -257,1 +297,8 @@\n-            nodes.put(root.getName(), root);\n+            ensureCached(root);\n+\n+            \/\/ By scanning the \/packages directory information early we can determine\n+            \/\/ which module\/package pairs have preview resources, and build the (small)\n+            \/\/ set of preview nodes early. This also ensures that preview-only entries\n+            \/\/ in the \/packages directory are not present in non-preview mode.\n+            this.previewDirectoriesToMerge = previewMode ? new HashMap<>() : null;\n+            packages.setChildren(processPackagesDirectory(previewMode));\n@@ -261,3 +308,8 @@\n-         * Returns the offset of the string denoting the leading \"module\" segment in\n-         * the given path (e.g. {@code <module>\/<path>}). We can't just pass in the\n-         * {@code \/<module>} string here because that has a module offset of zero.\n+         * Process {@code \"\/packages\/xxx\"} entries to build the child nodes for the\n+         * root {@code \"\/packages\"} node. Preview-only entries will be skipped if\n+         * {@code previewMode == false}.\n+         *\n+         * <p>If {@code previewMode == true}, this method also populates the {@link\n+         * #previewDirectoriesToMerge} map with any preview-only nodes, to be merged\n+         * into directories as they are completed. It also caches preview resources\n+         * and preview-only directories for direct lookup.\n@@ -265,6 +317,71 @@\n-        private int getModuleOffset(String path) {\n-            ImageLocation location = findLocation(path);\n-            assert location != null : \"Cannot find expected jimage location: \" + path;\n-            int offset = location.getModuleOffset();\n-            assert offset != 0 : \"Invalid module offset for jimage location: \" + path;\n-            return offset;\n+        private ArrayList<Node> processPackagesDirectory(boolean previewMode) {\n+            ImageLocation pkgRoot = findLocation(PACKAGES_PREFIX);\n+            assert pkgRoot != null : \"Invalid jimage file\";\n+            IntBuffer offsets = getOffsetBuffer(pkgRoot);\n+            ArrayList<Node> pkgDirs = new ArrayList<>(offsets.capacity());\n+            \/\/ Package path to module map, sorted in reverse order so that\n+            \/\/ longer child paths get processed first.\n+            Map<String, List<String>> previewPackagesToModules =\n+                    new TreeMap<>(Comparator.reverseOrder());\n+            for (int i = 0; i < offsets.capacity(); i++) {\n+                ImageLocation pkgDir = getLocation(offsets.get(i));\n+                int flags = pkgDir.getFlags();\n+                \/\/ A package subdirectory is \"preview only\" if all the modules\n+                \/\/ it references have that package marked as preview only.\n+                \/\/ Skipping these entries avoids empty package subdirectories.\n+                if (previewMode || !ImageLocation.isPreviewOnly(flags)) {\n+                    pkgDirs.add(ensureCached(newDirectory(pkgDir.getFullName())));\n+                }\n+                if (previewMode && ImageLocation.hasPreviewVersion(flags)) {\n+                    \/\/ Only do this in preview mode for the small set of packages with\n+                    \/\/ preview versions (the number of preview entries should be small).\n+                    List<String> moduleNames = new ArrayList<>();\n+                    ModuleReference.readNameOffsets(getOffsetBuffer(pkgDir), \/*normal*\/ false, \/*preview*\/ true)\n+                            .forEachRemaining(n -> moduleNames.add(getString(n)));\n+                    previewPackagesToModules.put(pkgDir.getBase().replace('.', '\/'), moduleNames);\n+                }\n+            }\n+            \/\/ Reverse sorted map means child directories are processed first.\n+            previewPackagesToModules.forEach((pkgPath, modules) ->\n+                    modules.forEach(modName -> processPreviewDir(MODULES_PREFIX + \"\/\" + modName, pkgPath)));\n+            \/\/ We might have skipped some preview-only package entries.\n+            pkgDirs.trimToSize();\n+            return pkgDirs;\n+        }\n+\n+        void processPreviewDir(String namePrefix, String pkgPath) {\n+            String previewDirName = namePrefix + PREVIEW_INFIX + \"\/\" + pkgPath;\n+            ImageLocation previewLoc = findLocation(previewDirName);\n+            assert previewLoc != null : \"Missing preview directory location: \" + previewDirName;\n+            String nonPreviewDirName = namePrefix + \"\/\" + pkgPath;\n+            List<Node> previewOnlyChildren = createChildNodes(previewLoc, 0, childLoc -> {\n+                String baseName = getBaseName(childLoc);\n+                String nonPreviewChildName = nonPreviewDirName + \"\/\" + baseName;\n+                boolean isPreviewOnly = ImageLocation.isPreviewOnly(childLoc.getFlags());\n+                LocationType type = childLoc.getType();\n+                if (type == RESOURCE) {\n+                    \/\/ Preview resources are cached to override non-preview versions.\n+                    Node childNode = ensureCached(newResource(nonPreviewChildName, childLoc));\n+                    return isPreviewOnly ? childNode : null;\n+                } else {\n+                    \/\/ Child directories are not cached here (they are either cached\n+                    \/\/ already or have been added to previewDirectoriesToMerge).\n+                    assert type == MODULES_DIR : \"Invalid location type: \" + childLoc;\n+                    Node childNode = nodes.get(nonPreviewChildName);\n+                    assert isPreviewOnly == (childNode != null) :\n+                            \"Inconsistent child node: \" + nonPreviewChildName;\n+                    return childNode;\n+                }\n+            });\n+            Directory previewDir = newDirectory(nonPreviewDirName);\n+            previewDir.setChildren(previewOnlyChildren);\n+            if (ImageLocation.isPreviewOnly(previewLoc.getFlags())) {\n+                \/\/ If we are preview-only, our children are also preview-only, so\n+                \/\/ this directory is a complete hierarchy and should be cached.\n+                assert !previewOnlyChildren.isEmpty() : \"Invalid empty preview-only directory: \" + nonPreviewDirName;\n+                ensureCached(previewDir);\n+            } else if (!previewOnlyChildren.isEmpty()) {\n+                \/\/ A partial directory containing extra preview-only nodes\n+                \/\/ to be merged when the non-preview directory is completed.\n+                previewDirectoriesToMerge.put(nonPreviewDirName, previewDir);\n+            }\n@@ -273,1 +390,8 @@\n-        private static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        \/\/ Adds a node to the cache, ensuring that no matching entry already existed.\n+        private <T extends Node> T ensureCached(T node) {\n+            Node existingNode = nodes.put(node.getName(), node);\n+            assert existingNode == null : \"Unexpected node already cached for: \" + node;\n+            return node;\n+        }\n+\n+        private static ImageReader open(Path imagePath, ByteOrder byteOrder, boolean previewMode) throws IOException {\n@@ -278,1 +402,2 @@\n-                SharedImageReader reader = OPEN_FILES.get(imagePath);\n+                ReaderKey key = new ReaderKey(imagePath, previewMode);\n+                SharedImageReader reader = OPEN_FILES.get(key);\n@@ -282,2 +407,2 @@\n-                    reader =  new SharedImageReader(imagePath, byteOrder);\n-                    OPEN_FILES.put(imagePath, reader);\n+                    reader = new SharedImageReader(imagePath, byteOrder, previewMode);\n+                    OPEN_FILES.put(key, reader);\n@@ -307,1 +432,1 @@\n-                    if (!OPEN_FILES.remove(this.getImagePath(), this)) {\n+                    if (!OPEN_FILES.remove(new ReaderKey(getImagePath(), previewMode), this)) {\n@@ -325,0 +450,2 @@\n+            \/\/ Root directories \"\/\", \"\/modules\" and \"\/packages\", as well\n+            \/\/ as all \"\/packages\/xxx\" subdirectories are already cached.\n@@ -327,12 +454,4 @@\n-                \/\/ We cannot get the root paths (\"\/modules\" or \"\/packages\") here\n-                \/\/ because those nodes are already in the nodes cache.\n-                if (name.startsWith(MODULES_ROOT + \"\/\")) {\n-                    \/\/ This may perform two lookups, one for a directory (in\n-                    \/\/ \"\/modules\/...\") and one for a non-prefixed resource\n-                    \/\/ (with \"\/modules\" removed).\n-                    node = buildModulesNode(name);\n-                } else if (name.startsWith(PACKAGES_ROOT + \"\/\")) {\n-                    node = buildPackagesNode(name);\n-                }\n-                if (node != null) {\n-                    nodes.put(node.getName(), node);\n+                if (name.startsWith(MODULES_PREFIX + \"\/\")) {\n+                    node = buildAndCacheModulesNode(name);\n+                } else if (name.startsWith(PACKAGES_PREFIX + \"\/\")) {\n+                    node = buildAndCacheLinkNode(name);\n@@ -362,1 +481,1 @@\n-            String nodeName = MODULES_ROOT + \"\/\" + moduleName + \"\/\" + resourcePath;\n+            String nodeName = MODULES_PREFIX + \"\/\" + moduleName + \"\/\" + resourcePath;\n@@ -368,1 +487,1 @@\n-                    if (loc != null && isResource(loc)) {\n+                    if (loc != null && loc.getType() == RESOURCE) {\n@@ -384,3 +503,4 @@\n-         * search). As such, it skips checking the nodes cache and only checks\n-         * for an entry in the jimage file, as this is faster if the resource\n-         * is not present. This also means it doesn't need synchronization.\n+         * search). As such, it skips checking the nodes cache if possible, and\n+         * only checks for an entry in the jimage file, as this is faster if the\n+         * resource is not present. This also means it doesn't need\n+         * synchronization most of the time.\n@@ -392,2 +512,12 @@\n-            \/\/ If the given module name is 'modules', then 'isResource()'\n-            \/\/ returns false to prevent false positives.\n+            \/\/ In preview mode, preview-only resources are eagerly added to the\n+            \/\/ cache, so we must check that first.\n+            if (previewMode) {\n+                String nodeName = MODULES_PREFIX + \"\/\" + moduleName + \"\/\" + resourcePath;\n+                \/\/ Synchronize as tightly as possible to reduce locking contention.\n+                synchronized (this) {\n+                    Node node = nodes.get(nodeName);\n+                    if (node != null) {\n+                        return node.isResource();\n+                    }\n+                }\n+            }\n@@ -395,1 +525,1 @@\n-            return loc != null && isResource(loc);\n+            return loc != null && loc.getType() == RESOURCE;\n@@ -404,2 +534,5 @@\n-        private Node buildModulesNode(String name) {\n-            assert name.startsWith(MODULES_ROOT + \"\/\") : \"Invalid module node name: \" + name;\n+        private Node buildAndCacheModulesNode(String name) {\n+            assert name.startsWith(MODULES_PREFIX + \"\/\") : \"Invalid module node name: \" + name;\n+            if (isPreviewName(name)) {\n+                return null;\n+            }\n@@ -411,2 +544,2 @@\n-                assert isModulesSubdirectory(loc) : \"Invalid modules directory: \" + name;\n-                return completeModuleDirectory(newDirectory(name), loc);\n+                assert loc.getType() == MODULES_DIR : \"Invalid modules directory: \" + name;\n+                return ensureCached(completeModuleDirectory(newDirectory(name), loc));\n@@ -417,2 +550,4 @@\n-            loc = findLocation(name.substring(MODULES_ROOT.length()));\n-            return loc != null && isResource(loc) ? newResource(name, loc) : null;\n+            loc = findLocation(name.substring(MODULES_PREFIX.length()));\n+            return loc != null && loc.getType() == RESOURCE\n+                    ? ensureCached(newResource(name, loc))\n+                    : null;\n@@ -422,1 +557,31 @@\n-         * Builds a node in the \"\/packages\/...\" namespace.\n+         * Returns whether a directory name in the \"\/modules\/\" directory could be referencing\n+         * the \"META-INF\" directory\".\n+         *\/\n+        private boolean isMetaInf(Directory dir) {\n+            String name = dir.getName();\n+            int pathStart = name.indexOf('\/', MODULES_PREFIX.length() + 1);\n+            return name.length() == pathStart + \"\/META-INF\".length()\n+                    && name.endsWith(\"\/META-INF\");\n+        }\n+\n+        \/**\n+         * Returns whether a node name in the \"\/modules\/\" directory could be referencing\n+         * a preview resource or directory under \"META-INF\/preview\".\n+         *\/\n+        private boolean isPreviewName(String name) {\n+            int pathStart = name.indexOf('\/', MODULES_PREFIX.length() + 1);\n+            int previewEnd = pathStart + PREVIEW_INFIX.length();\n+            return pathStart > 0\n+                    && name.regionMatches(pathStart, PREVIEW_INFIX, 0, PREVIEW_INFIX.length())\n+                    && (name.length() == previewEnd || name.charAt(previewEnd) == '\/');\n+        }\n+\n+        private String getBaseName(ImageLocation loc) {\n+            \/\/ Matches logic in ImageLocation#getFullName() regarding extensions.\n+            String trailingParts = loc.getBase()\n+                    + ((loc.getExtensionOffset() != 0) ? \".\" + loc.getExtension() : \"\");\n+            return trailingParts.substring(trailingParts.lastIndexOf('\/') + 1);\n+        }\n+\n+        \/**\n+         * Builds a link node of the form \"\/packages\/xxx\/yyy\".\n@@ -424,2 +589,2 @@\n-         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...} node\n-         * is not present in the cache.\n+         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...}\n+         * node is not present in the cache (the name is not trusted).\n@@ -427,7 +592,5 @@\n-        private Node buildPackagesNode(String name) {\n-            \/\/ There are only locations for the root \"\/packages\" or \"\/packages\/xxx\"\n-            \/\/ directories, but not the symbolic links below them (the links can be\n-            \/\/ entirely derived from the name information in the parent directory).\n-            \/\/ However, unlike resources this means that we do not have a constant\n-            \/\/ time lookup for link nodes when creating them.\n-            int packageStart = PACKAGES_ROOT.length() + 1;\n+        private Node buildAndCacheLinkNode(String name) {\n+            \/\/ There are only locations for \"\/packages\" or \"\/packages\/xxx\"\n+            \/\/ directories, but not the symbolic links below them (links are\n+            \/\/ derived from the name information in the parent directory).\n+            int packageStart = PACKAGES_PREFIX.length() + 1;\n@@ -435,8 +598,3 @@\n-            if (packageEnd == -1) {\n-                ImageLocation loc = findLocation(name);\n-                return loc != null ? completePackageDirectory(newDirectory(name), loc) : null;\n-            } else {\n-                \/\/ We cannot assume that the parent directory exists for a link node, since\n-                \/\/ the given name is untrusted and could reference a non-existent link.\n-                \/\/ However, if the parent directory is present, we can conclude that the\n-                \/\/ given name was not a valid link (or else it would already be cached).\n+            \/\/ We already built the 2-level \"\/packages\/xxx\" directories,\n+            \/\/ so if this is a 2-level name, it cannot reference a node.\n+            if (packageEnd >= 0) {\n@@ -444,8 +602,6 @@\n-                if (!nodes.containsKey(dirName)) {\n-                    ImageLocation loc = findLocation(dirName);\n-                    \/\/ If the parent location doesn't exist, the link node cannot exist.\n-                    if (loc != null) {\n-                        nodes.put(dirName, completePackageDirectory(newDirectory(dirName), loc));\n-                        \/\/ When the parent is created its child nodes are created and cached,\n-                        \/\/ but this can still return null if given name wasn't a valid link.\n-                        return nodes.get(name);\n+                \/\/ If no parent exists here, the name cannot be valid.\n+                Directory parent = (Directory) nodes.get(dirName);\n+                if (parent != null) {\n+                    if (!parent.isCompleted()) {\n+                        \/\/ This caches all child links of the parent directory.\n+                        completePackageSubdirectory(parent, findLocation(dirName));\n@@ -453,0 +609,1 @@\n+                    return nodes.get(name);\n@@ -464,1 +621,1 @@\n-            assert name.startsWith(MODULES_ROOT) || name.startsWith(PACKAGES_ROOT);\n+            assert name.startsWith(MODULES_PREFIX) || name.startsWith(PACKAGES_PREFIX);\n@@ -467,4 +624,2 @@\n-            \/\/ We cannot use 'isXxxSubdirectory()' methods here since we could\n-            \/\/ be given a top-level directory (for which that test doesn't work).\n-            \/\/ The string MUST start \"\/modules\" or \"\/packages\" here.\n-            if (name.charAt(1) == 'm') {\n+            LocationType type = loc.getType();\n+            if (type == MODULES_DIR || type == MODULES_ROOT) {\n@@ -473,1 +628,2 @@\n-                completePackageDirectory(dir, loc);\n+                assert type == PACKAGES_DIR : \"Invalid location type: \" + loc;\n+                completePackageSubdirectory(dir, loc);\n@@ -478,6 +634,1 @@\n-        \/**\n-         * Completes a modules directory by setting the list of child nodes.\n-         *\n-         * <p>The given directory can be the top level {@code \/modules} directory,\n-         * so it is NOT safe to use {@code isModulesSubdirectory(loc)} here.\n-         *\/\n+        \/** Completes a modules directory by setting the list of child nodes. *\/\n@@ -486,3 +637,11 @@\n-            List<Node> children = createChildNodes(loc, childLoc -> {\n-                if (isModulesSubdirectory(childLoc)) {\n-                    return nodes.computeIfAbsent(childLoc.getFullName(), this::newDirectory);\n+            List<Node> previewOnlyNodes = getPreviewNodesToMerge(dir);\n+            \/\/ We hide preview names from direct lookup, but must also prevent\n+            \/\/ the preview directory from appearing in any META-INF directories.\n+            boolean parentIsMetaInfDir = isMetaInf(dir);\n+            List<Node> children = createChildNodes(loc, previewOnlyNodes.size(), childLoc -> {\n+                LocationType type = childLoc.getType();\n+                if (type == MODULES_DIR) {\n+                    String name = childLoc.getFullName();\n+                    return parentIsMetaInfDir && name.endsWith(\"\/preview\")\n+                            ? null\n+                            : nodes.computeIfAbsent(name, this::newDirectory);\n@@ -490,0 +649,1 @@\n+                    assert type == RESOURCE : \"Invalid location type: \" + loc;\n@@ -495,0 +655,1 @@\n+            children.addAll(previewOnlyNodes);\n@@ -499,0 +660,21 @@\n+        \/** Completes a package directory by setting the list of child nodes. *\/\n+        private void completePackageSubdirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            assert !dir.isCompleted() : \"Directory already completed: \" + dir;\n+            assert loc.getType() == PACKAGES_DIR : \"Invalid location type: \" + loc.getType();\n+\n+            \/\/ In non-preview mode we might skip a very small number of preview-only\n+            \/\/ entries, but it's not worth \"right-sizing\" the array for that.\n+            IntBuffer offsets = getOffsetBuffer(loc);\n+            List<Node> children = new ArrayList<>(offsets.capacity() \/ 2);\n+            ModuleReference.readNameOffsets(offsets, \/*normal*\/ true, previewMode)\n+                    .forEachRemaining(n -> {\n+                        String modName = getString(n);\n+                        Node link = newLinkNode(dir.getName() + \"\/\" + modName, MODULES_PREFIX + \"\/\" + modName);\n+                        children.add(ensureCached(link));\n+                    });\n+            \/\/ If the parent directory exists, there must be at least one child node.\n+            assert !children.isEmpty() : \"Invalid empty package directory: \" + dir;\n+            dir.setChildren(children);\n+        }\n+\n@@ -500,1 +682,1 @@\n-         * Completes a package directory by setting the list of child nodes.\n+         * Returns the list of child preview nodes to be merged into the given directory.\n@@ -502,2 +684,4 @@\n-         * <p>The given directory can be the top level {@code \/packages} directory,\n-         * so it is NOT safe to use {@code isPackagesSubdirectory(loc)} here.\n+         * <p>Because this is only called once per-directory (since the result is cached\n+         * indefinitely) we can remove any entries we find from the cache. If ever the\n+         * node cache allowed entries to expire, this would have to be changed so that\n+         * directories could be completed more than once.\n@@ -505,22 +689,5 @@\n-        private Directory completePackageDirectory(Directory dir, ImageLocation loc) {\n-            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n-            \/\/ The only directories in the \"\/packages\" namespace are \"\/packages\" or\n-            \/\/ \"\/packages\/<package>\". However, unlike \"\/modules\" directories, the\n-            \/\/ location offsets mean different things.\n-            List<Node> children;\n-            if (dir.getName().equals(PACKAGES_ROOT)) {\n-                \/\/ Top-level directory just contains a list of subdirectories.\n-                children = createChildNodes(loc, c -> nodes.computeIfAbsent(c.getFullName(), this::newDirectory));\n-            } else {\n-                \/\/ A package directory's content is array of offset PAIRS in the\n-                \/\/ Strings table, but we only need the 2nd value of each pair.\n-                IntBuffer intBuffer = getOffsetBuffer(loc);\n-                int offsetCount = intBuffer.capacity();\n-                assert (offsetCount & 0x1) == 0 : \"Offset count must be even: \" + offsetCount;\n-                children = new ArrayList<>(offsetCount \/ 2);\n-                \/\/ Iterate the 2nd offset in each pair (odd indices).\n-                for (int i = 1; i < offsetCount; i += 2) {\n-                    String moduleName = getString(intBuffer.get(i));\n-                    children.add(nodes.computeIfAbsent(\n-                            dir.getName() + \"\/\" + moduleName,\n-                            n -> newLinkNode(n, MODULES_ROOT + \"\/\" + moduleName)));\n+        List<Node> getPreviewNodesToMerge(Directory dir) {\n+            if (previewDirectoriesToMerge != null) {\n+                Directory mergeDir = previewDirectoriesToMerge.remove(dir.getName());\n+                if (mergeDir != null) {\n+                    return mergeDir.children;\n@@ -529,3 +696,1 @@\n-            \/\/ This only happens once and \"completes\" the directory.\n-            dir.setChildren(children);\n-            return dir;\n+            return Collections.emptyList();\n@@ -535,1 +700,7 @@\n-         * Creates the list of child nodes for a {@code Directory} based on a given\n+         * Creates the list of child nodes for a modules {@code Directory} from\n+         * its parent location.\n+         *\n+         * <p>The {@code getChildFn} may return existing cached nodes rather\n+         * than creating them, and if newly created nodes are to be cached,\n+         * it is the job of {@code getChildFn}, or the caller of this method,\n+         * to do that.\n@@ -537,2 +708,7 @@\n-         * <p>Note: This cannot be used for package subdirectories as they have\n-         * child offsets stored differently to other directories.\n+         * @param loc a location relating to a \"\/modules\" directory.\n+         * @param extraNodesCount a known number of preview-only child nodes\n+         *     which will be merged onto the end of the returned list later.\n+         * @param getChildFn a function to return a node for each child location\n+         *     (or null to skip putting anything in the list).\n+         * @return the list of the non-null child nodes, returned by\n+         *     {@code getChildFn}, in the order of the locations entries.\n@@ -540,1 +716,3 @@\n-        private List<Node> createChildNodes(ImageLocation loc, Function<ImageLocation, Node> newChildFn) {\n+        private List<Node> createChildNodes(ImageLocation loc, int extraNodesCount, Function<ImageLocation, Node> getChildFn) {\n+            LocationType type = loc.getType();\n+            assert type == MODULES_DIR || type == MODULES_ROOT : \"Invalid location type: \" + loc;\n@@ -543,1 +721,1 @@\n-            List<Node> children = new ArrayList<>(childCount);\n+            List<Node> children = new ArrayList<>(childCount + extraNodesCount);\n@@ -545,1 +723,4 @@\n-                children.add(newChildFn.apply(getLocation(offsets.get(i))));\n+                Node childNode = getChildFn.apply(getLocation(offsets.get(i)));\n+                if (childNode != null) {\n+                    children.add(childNode);\n+                }\n@@ -552,1 +733,1 @@\n-            assert !isResource(dir) : \"Not a directory: \" + dir.getFullName();\n+            assert dir.getType() != RESOURCE : \"Not a directory: \" + dir.getFullName();\n@@ -559,26 +740,0 @@\n-        \/**\n-         * Efficiently determines if an image location is a resource.\n-         *\n-         * <p>A resource must have a valid module associated with it, so its\n-         * module offset must be non-zero, and not equal to the offsets for\n-         * \"\/modules\/...\" or \"\/packages\/...\" entries.\n-         *\/\n-        private boolean isResource(ImageLocation loc) {\n-            int moduleOffset = loc.getModuleOffset();\n-            return moduleOffset != 0\n-                    && moduleOffset != modulesStringOffset\n-                    && moduleOffset != packagesStringOffset;\n-        }\n-\n-        \/**\n-         * Determines if an image location is a directory in the {@code \/modules}\n-         * namespace (if so, the location name is the node name).\n-         *\n-         * <p>In jimage, every {@code ImageLocation} under {@code \/modules\/} is a\n-         * directory and has the same value for {@code getModule()}, and {@code\n-         * getModuleOffset()}.\n-         *\/\n-        private boolean isModulesSubdirectory(ImageLocation loc) {\n-            return loc.getModuleOffset() == modulesStringOffset;\n-        }\n-\n@@ -600,1 +755,0 @@\n-            assert name.equals(loc.getFullName(true)) : \"Mismatched location for resource: \" + name;\n@@ -832,1 +986,1 @@\n-        private void setChildren(List<Node> children) {\n+        private void setChildren(List<? extends Node> children) {\n@@ -837,0 +991,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":326,"deletions":171,"binary":false,"changes":497,"status":"modified"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jimage;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Function;\n-\n-\/**\n- * Factory to get ImageReader\n- *\n- * @implNote This class needs to maintain JDK 8 source compatibility.\n- *\n- * It is used internally in the JDK to implement jimage\/jrtfs access,\n- * but also compiled and delivered as part of the jrtfs.jar to support access\n- * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n- *\/\n-public class ImageReaderFactory {\n-    private ImageReaderFactory() {}\n-\n-    private static final String JAVA_HOME = System.getProperty(\"java.home\");\n-    private static final Path BOOT_MODULES_JIMAGE;\n-\n-    static {\n-        FileSystem fs;\n-        if (ImageReaderFactory.class.getClassLoader() == null) {\n-            try {\n-                fs = (FileSystem) Class.forName(\"sun.nio.fs.DefaultFileSystemProvider\")\n-                        .getMethod(\"theFileSystem\")\n-                        .invoke(null);\n-            } catch (Exception e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        } else {\n-            fs = FileSystems.getDefault();\n-        }\n-        BOOT_MODULES_JIMAGE = fs.getPath(JAVA_HOME, \"lib\", \"modules\");\n-    }\n-\n-    private static final Map<Path, ImageReader> readers = new ConcurrentHashMap<>();\n-\n-    \/**\n-     * Returns an {@code ImageReader} to read from the given image file\n-     *\/\n-    public static ImageReader get(Path jimage) throws IOException {\n-        Objects.requireNonNull(jimage);\n-        try {\n-            return readers.computeIfAbsent(jimage, OPENER);\n-        } catch (UncheckedIOException io) {\n-            throw io.getCause();\n-        }\n-    }\n-\n-    private static Function<Path, ImageReader> OPENER = new Function<Path, ImageReader>() {\n-        public ImageReader apply(Path path) {\n-            try {\n-                return ImageReader.open(path);\n-            } catch (IOException io) {\n-                throw new UncheckedIOException(io);\n-            }\n-        }\n-    };\n-\n-    \/**\n-     * Returns the {@code ImageReader} to read the image file in this\n-     * run-time image.\n-     *\n-     * @throws UncheckedIOException if an I\/O error occurs\n-     *\/\n-    public static ImageReader getImageReader() {\n-        try {\n-            return get(BOOT_MODULES_JIMAGE);\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(ioe);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReaderFactory.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,17 @@\n+    \/\/ String offset constants are useful for efficient classification\n+    \/\/ of location entries without string comparison.\n+    \/\/ They are validated during initialization of ImageStringsWriter.\n+    \/\/\n+    \/\/ Adding new strings (with larger offsets) is possible without changing\n+    \/\/ the jimage version number, but any change to existing strings must be\n+    \/\/ accompanied by a jimage version number change.\n+\n+    \/** Fixed offset for the empty string in the strings table. *\/\n+    int EMPTY_STRING_OFFSET = 0;\n+    \/** Fixed offset for the string \"class\" in the strings table. *\/\n+    int CLASS_STRING_OFFSET = 1;\n+    \/** Fixed offset for the string \"modules\" in the strings table. *\/\n+    int MODULES_STRING_OFFSET = 7;\n+    \/** Fixed offset for the string \"packages\" in the strings table. *\/\n+    int PACKAGES_STRING_OFFSET = 15;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageStrings.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jimage;\n+\n+import java.nio.IntBuffer;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the module entries stored in the buffer of {@code \"\/packages\/xxx\"}\n+ * image locations (package subdirectories). These entries use flags which are\n+ * similar to, but distinct from, the {@link ImageLocation} flags, so\n+ * encapsulating them here helps avoid confusion.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ *\/\n+public final class ModuleReference implements Comparable<ModuleReference> {\n+    \/\/ These flags are additive (hence \"has-content\" rather than \"is-empty\").\n+\n+    \/** If set, this package exists in preview mode. *\/\n+    private static final int FLAGS_PKG_HAS_PREVIEW_VERSION = 0x1;\n+    \/** If set, this package exists in non-preview mode. *\/\n+    private static final int FLAGS_PKG_HAS_NORMAL_VERSION = 0x2;\n+    \/** If set, the associated module has resources (in normal or preview mode). *\/\n+    private static final int FLAGS_PKG_HAS_RESOURCES = 0x4;\n+\n+    \/**\n+     * References are ordered with preview versions first which permits early\n+     * exit when processing preview entries (it's reversed because the default\n+     * order for a boolean is {@code false < true}).\n+     *\/\n+    private static final Comparator<ModuleReference> PREVIEW_FIRST =\n+            Comparator.comparing(ModuleReference::hasPreviewVersion).reversed()\n+                    .thenComparing(ModuleReference::name);\n+\n+    \/**\n+     * Returns a reference for non-empty packages (those with resources) in a\n+     * given module.\n+     *\n+     * <p>The same reference can be used for multiple packages in the same module.\n+     *\/\n+    public static ModuleReference forPackageIn(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, FLAGS_PKG_HAS_RESOURCES | previewFlag(isPreview));\n+    }\n+\n+    \/**\n+     * Returns a reference for empty packages in a given module.\n+     *\n+     * <p>The same reference can be used for multiple packages in the same module.\n+     *\/\n+    public static ModuleReference forEmptyPackageIn(String moduleName, boolean isPreview) {\n+        return new ModuleReference(moduleName, previewFlag(isPreview));\n+    }\n+\n+    private static int previewFlag(boolean isPreview) {\n+        return isPreview ? FLAGS_PKG_HAS_PREVIEW_VERSION : FLAGS_PKG_HAS_NORMAL_VERSION;\n+    }\n+\n+    \/** Merges two references for the same module (combining their flags). *\/\n+    public ModuleReference merge(ModuleReference other) {\n+        if (!name.equals(other.name)) {\n+            throw new IllegalArgumentException(\"Cannot merge \" + other + \" with \" + this);\n+        }\n+        \/\/ Because flags are additive, we can just OR them here.\n+        return new ModuleReference(name, flags | other.flags);\n+    }\n+\n+    private final String name;\n+    private final int flags;\n+\n+    private ModuleReference(String moduleName, int flags) {\n+        this.name = Objects.requireNonNull(moduleName);\n+        this.flags = flags;\n+    }\n+\n+    \/** Returns the module name of this reference. *\/\n+    public String name() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns whether the package associated with this reference contains\n+     * resources in this reference's module.\n+     *\n+     * <p>An invariant of the module system is that while a package may exist\n+     * under many modules, it only has resources in one.\n+     *\/\n+    public boolean hasResources() {\n+        return (flags & FLAGS_PKG_HAS_RESOURCES) != 0;\n+    }\n+\n+    \/**\n+     * Returns whether the package associated with this reference has a preview\n+     * version (empty or otherwise) in this reference's module.\n+     *\/\n+    public boolean hasPreviewVersion() {\n+        return (flags & FLAGS_PKG_HAS_PREVIEW_VERSION) != 0;\n+    }\n+\n+    \/** Returns whether this reference exists only in preview mode. *\/\n+    public boolean isPreviewOnly() {\n+        return (flags & FLAGS_PKG_HAS_NORMAL_VERSION) == 0;\n+    }\n+\n+    @Override\n+    public int compareTo(ModuleReference rhs) {\n+        return PREVIEW_FIRST.compare(this, rhs);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ModuleReference{ module=\" + name + \", flags=\" + flags + \" }\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof ModuleReference)) {\n+            return false;\n+        }\n+        ModuleReference other = (ModuleReference) obj;\n+        return name.equals(other.name) && flags == other.flags;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, flags);\n+    }\n+\n+    \/**\n+     * Reads the content buffer of a package subdirectory to return a sequence\n+     * of module name offsets in the jimage.\n+     *\n+     * @param buffer the content buffer of an {@link ImageLocation} with type\n+     *     {@link ImageLocation.LocationType#PACKAGES_DIR PACKAGES_DIR}.\n+     * @param includeNormal whether to include name offsets for modules present\n+     *     in normal (non-preview) mode.\n+     * @param includePreview whether to include name offsets for modules present\n+     *     in preview mode.\n+     * @return an iterator of module name offsets.\n+     *\/\n+    public static Iterator<Integer> readNameOffsets(\n+            IntBuffer buffer, boolean includeNormal, boolean includePreview) {\n+        int bufferSize = buffer.capacity();\n+        if (bufferSize == 0 || (bufferSize & 0x1) != 0) {\n+            throw new IllegalArgumentException(\"Invalid buffer size\");\n+        }\n+        int includeMask = (includeNormal ? FLAGS_PKG_HAS_NORMAL_VERSION : 0)\n+                + (includePreview ? FLAGS_PKG_HAS_PREVIEW_VERSION : 0);\n+        if (includeMask == 0) {\n+            throw new IllegalArgumentException(\"Invalid flags\");\n+        }\n+\n+        return new Iterator<Integer>() {\n+            private int idx = nextIdx(0);\n+\n+            int nextIdx(int idx) {\n+                for (; idx < bufferSize; idx += 2) {\n+                    \/\/ If any of the test flags are set, include this entry.\n+                    if ((buffer.get(idx) & includeMask) != 0) {\n+                        return idx;\n+                    } else if (!includeNormal) {\n+                        \/\/ Preview entries are first in the offset buffer, so we\n+                        \/\/ can exit early (by returning the end index) if we are\n+                        \/\/ only iterating preview entries, and have run out.\n+                        break;\n+                    }\n+                }\n+                return bufferSize;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return idx < bufferSize;\n+            }\n+\n+            @Override\n+            public Integer next() {\n+                if (idx < bufferSize) {\n+                    int nameOffset = buffer.get(idx + 1);\n+                    idx = nextIdx(idx + 2);\n+                    return nameOffset;\n+                }\n+                throw new NoSuchElementException();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Writes a list of module references to a given buffer. The given references\n+     * list is checked carefully to ensure the written buffer will be valid.\n+     *\n+     * <p>Entries are written in order, taking two integer slots per entry as\n+     * {@code [<flags>, <encoded-name>]}.\n+     *\n+     * @param refs the references to write, correctly ordered.\n+     * @param buffer destination buffer.\n+     * @param nameEncoder encoder for module names.\n+     * @throws IllegalArgumentException in the references are invalid in any way.\n+     *\/\n+    public static void write(\n+            List<ModuleReference> refs, IntBuffer buffer, Function<String, Integer> nameEncoder) {\n+        if (refs.isEmpty()) {\n+            throw new IllegalArgumentException(\"References list must be non-empty\");\n+        }\n+        int expectedCapacity = 2 * refs.size();\n+        if (buffer.capacity() != expectedCapacity) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid buffer capacity: expected \" + expectedCapacity + \", got \" + buffer.capacity());\n+        }\n+        \/\/ This catches exact duplicates in the list.\n+        refs.stream().reduce((lhs, rhs) -> {\n+            if (lhs.compareTo(rhs) >= 0) {\n+                throw new IllegalArgumentException(\"References must be strictly ordered: \" + refs);\n+            }\n+            return rhs;\n+        });\n+        \/\/ Distinct references can have the same name (but we don't allow this).\n+        if (refs.stream().map(ModuleReference::name).distinct().count() != refs.size()) {\n+            throw new IllegalArgumentException(\"Reference names must be unique: \" + refs);\n+        }\n+        if (refs.stream().filter(ModuleReference::hasResources).count() > 1) {\n+            throw new IllegalArgumentException(\"At most one reference can have resources: \" + refs);\n+        }\n+        for (ModuleReference modRef : refs) {\n+            buffer.put(modRef.flags);\n+            buffer.put(nameEncoder.apply(modRef.name));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ModuleReference.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jimage;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+\/**\n+ * Specifies the preview mode used to open a jimage file via {@link ImageReader}.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ * *\/\n+public enum PreviewMode {\n+    \/**\n+     * Preview mode is disabled. No preview classes or resources will be available\n+     * in this mode.\n+     *\/\n+    DISABLED,\n+    \/**\n+     * Preview mode is enabled. If preview classes or resources exist in the jimage file,\n+     * they will be made available.\n+     *\/\n+    ENABLED,\n+    \/**\n+     * The preview mode of the current run-time, typically determined by the\n+     * {@code --enable-preview} flag.\n+     *\/\n+    FOR_RUNTIME;\n+\n+    \/**\n+     * Resolves whether preview mode should be enabled for an {@link ImageReader}.\n+     *\/\n+    public boolean isPreviewModeEnabled() {\n+        if (!ENABLE_PREVIEW_MODE) {\n+            return false;\n+        }\n+        \/\/ A switch, instead of an abstract method, saves 3 subclasses.\n+        switch (this) {\n+            case DISABLED:\n+                return false;\n+            case ENABLED:\n+                return true;\n+            case FOR_RUNTIME:\n+                \/\/ We want to call jdk.internal.misc.PreviewFeatures.isEnabled(), but\n+                \/\/ is not available in older JREs, so we must look to it reflectively.\n+                Class<?> clazz;\n+                try {\n+                    clazz = Class.forName(\"jdk.internal.misc.PreviewFeatures\");\n+                } catch (ClassNotFoundException e) {\n+                    \/\/ It is valid and expected that the class might not exist (JDK-8).\n+                    return false;\n+                }\n+                try {\n+                    return (Boolean) clazz.getDeclaredMethod(\"isEnabled\").invoke(null);\n+                } catch (NoSuchMethodException | IllegalAccessException |\n+                         InvocationTargetException e) {\n+                    \/\/ But if the class exists, the method must exist and be callable.\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            default:\n+                throw new IllegalStateException(\"Invalid mode: \" + this);\n+        }\n+    }\n+    ;\n+\n+    \/\/ Temporary system property to disable preview patching and enable the new preview mode\n+    \/\/ feature for testing\/development. Once the preview mode feature is finished, the value\n+    \/\/ will be always 'true' and this code, and all related dead-code can be removed.\n+    private static final boolean DISABLE_PREVIEW_PATCHING_DEFAULT = false;\n+    private static final boolean ENABLE_PREVIEW_MODE = Boolean.parseBoolean(\n+            System.getProperty(\n+                    \"DISABLE_PREVIEW_PATCHING\",\n+                    Boolean.toString(DISABLE_PREVIEW_PATCHING_DEFAULT)));\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/PreviewMode.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jimage;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+\n+\/**\n+ * Static holder class for singleton {@link ImageReader} instance.\n+ *\n+ * @implNote This class needs to maintain JDK 8 source compatibility.\n+ *\n+ * It is used internally in the JDK to implement jimage\/jrtfs access,\n+ * but also compiled and delivered as part of the jrtfs.jar to support access\n+ * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n+ *\/\n+public class SystemImageReader {\n+    private static final ImageReader SYSTEM_IMAGE_READER;\n+\n+    static {\n+        String javaHome = System.getProperty(\"java.home\");\n+        FileSystem fs;\n+        if (SystemImageReader.class.getClassLoader() == null) {\n+            try {\n+                fs = (FileSystem) Class.forName(\"sun.nio.fs.DefaultFileSystemProvider\")\n+                        .getMethod(\"theFileSystem\")\n+                        .invoke(null);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        } else {\n+            fs = FileSystems.getDefault();\n+        }\n+        try {\n+            SYSTEM_IMAGE_READER = ImageReader.open(fs.getPath(javaHome, \"lib\", \"modules\"), PreviewMode.FOR_RUNTIME);\n+        } catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the singleton {@code ImageReader} to read the image file in this\n+     * run-time image. The returned instance must not be closed.\n+     *\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     *\/\n+    public static ImageReader get() {\n+        return SYSTEM_IMAGE_READER;\n+    }\n+\n+    private SystemImageReader() {}\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/SystemImageReader.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -61,1 +61,0 @@\n-import java.util.Map;\n@@ -65,0 +64,1 @@\n+\n@@ -66,0 +66,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -84,3 +85,24 @@\n-    JrtFileSystem(JrtFileSystemProvider provider, Map<String, ?> env)\n-            throws IOException\n-    {\n+    \/**\n+     * Special constructor for the singleton system jrt file system. This creates\n+     * a non-closable instance, and should only be called once by {@link\n+     * JrtFileSystemProvider}.\n+     *\n+     * @param provider the provider opening the file system.\n+     *\/\n+    JrtFileSystem(JrtFileSystemProvider provider)\n+            throws IOException {\n+        this.provider = provider;\n+        this.image = SystemImage.open(PreviewMode.FOR_RUNTIME);  \/\/ open image file\n+        this.isOpen = true;\n+        \/\/ Only the system singleton jrt file system is \"unclosable\".\n+        this.isClosable = false;\n+    }\n+\n+    \/**\n+     * Creates a new, non-system, instance of the jrt file system.\n+     *\n+     * @param provider the provider opening the file system.\n+     * @param mode controls whether preview resources are visible.\n+     *\/\n+    JrtFileSystem(JrtFileSystemProvider provider, PreviewMode mode)\n+            throws IOException {\n@@ -88,1 +110,1 @@\n-        this.image = SystemImage.open();  \/\/ open image file\n+        this.image = SystemImage.open(mode);  \/\/ open image file\n@@ -90,1 +112,1 @@\n-        this.isClosable = env != null;\n+        this.isClosable = true;\n@@ -156,1 +178,1 @@\n-                    new HashSet<String>(Arrays.asList(\"basic\", \"jrt\")));\n+            new HashSet<String>(Arrays.asList(\"basic\", \"jrt\")));\n@@ -187,2 +209,2 @@\n-                throw new UnsupportedOperationException(\"Syntax '\" + syntax\n-                        + \"' not recognized\");\n+            throw new UnsupportedOperationException(\"Syntax '\" + syntax\n+                    + \"' not recognized\");\n@@ -280,1 +302,1 @@\n-                    \"option class: \" + option.getClass());\n+                        \"option class: \" + option.getClass());\n@@ -284,1 +306,1 @@\n-            options.contains(StandardOpenOption.APPEND)) {\n+                options.contains(StandardOpenOption.APPEND)) {\n@@ -325,2 +347,2 @@\n-            Set<? extends OpenOption> options,\n-            FileAttribute<?>... attrs)\n+                                     Set<? extends OpenOption> options,\n+                                     FileAttribute<?>... attrs)\n@@ -336,2 +358,2 @@\n-            Set<? extends OpenOption> options,\n-            FileAttribute<?>... attrs)\n+                                             Set<? extends OpenOption> options,\n+                                             FileAttribute<?>... attrs)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.PreviewMode;\n+\n@@ -47,1 +49,1 @@\n- * .jimage file or exploded modules directory of underlying JDK.\n+ * a jimage file, or exploded modules directory of underlying JDK.\n@@ -72,1 +74,1 @@\n-        @SuppressWarnings({ \"removal\", \"suppression\" })\n+        @SuppressWarnings({\"removal\", \"suppression\"})\n@@ -108,1 +110,1 @@\n-            return newFileSystem((String)env.get(\"java.home\"), uri, env);\n+            return newFileSystem((String) env.get(\"java.home\"), uri, env);\n@@ -110,1 +112,11 @@\n-            return new JrtFileSystem(this, env);\n+            return new JrtFileSystem(this, parsePreviewMode(env.get(\"previewMode\")));\n+        }\n+    }\n+\n+    \/\/ Currently this does not support specifying \"for runtime\", because it is\n+    \/\/ expected that callers creating non-standard image readers will not be\n+    \/\/ using them to read resources for the current runtime (they would just\n+    \/\/ use \"jrt:\" URLs if they were doing that).\n+    private static PreviewMode parsePreviewMode(Object envValue) {\n+        if (envValue instanceof String && Boolean.parseBoolean((String) envValue)) {\n+            return PreviewMode.ENABLED;\n@@ -112,0 +124,2 @@\n+        \/\/ Default (unspecified\/null or bad parameter) is to not use preview mode.\n+        return PreviewMode.DISABLED;\n@@ -122,1 +136,1 @@\n-        Map<String,?> newEnv = new HashMap<>(env);\n+        Map<String, ?> newEnv = new HashMap<>(env);\n@@ -127,1 +141,1 @@\n-            @SuppressWarnings({ \"deprecation\", \"suppression\" })\n+            @SuppressWarnings({\"deprecation\", \"suppression\"})\n@@ -129,1 +143,1 @@\n-            return ((FileSystemProvider)tmp).newFileSystem(uri, newEnv);\n+            return ((FileSystemProvider) tmp).newFileSystem(uri, newEnv);\n@@ -143,2 +157,1 @@\n-                throws ClassNotFoundException\n-        {\n+                throws ClassNotFoundException {\n@@ -160,1 +173,1 @@\n-    @SuppressWarnings({ \"removal\", \"suppression\" })\n+    @SuppressWarnings({\"removal\", \"suppression\"})\n@@ -169,1 +182,1 @@\n-        final URL[] urls = new URL[] { url };\n+        final URL[] urls = new URL[]{url};\n@@ -211,1 +224,2 @@\n-                        this.theFileSystem = fs = new JrtFileSystem(this, null);\n+                        \/\/ Special constructor call for singleton instance.\n+                        this.theFileSystem = fs = new JrtFileSystem(this);\n@@ -229,1 +243,1 @@\n-    static final JrtPath toJrtPath(Path path) {\n+    static JrtPath toJrtPath(Path path) {\n@@ -260,1 +274,1 @@\n-    public final void delete(Path path) throws IOException {\n+    public void delete(Path path) throws IOException {\n@@ -266,1 +280,1 @@\n-            getFileAttributeView(Path path, Class<V> type, LinkOption... options) {\n+    getFileAttributeView(Path path, Class<V> type, LinkOption... options) {\n@@ -293,3 +307,3 @@\n-            Set<? extends OpenOption> options,\n-            ExecutorService exec,\n-            FileAttribute<?>... attrs)\n+                                                              Set<? extends OpenOption> options,\n+                                                              ExecutorService exec,\n+                                                              FileAttribute<?>... attrs)\n@@ -302,2 +316,2 @@\n-            Set<? extends OpenOption> options,\n-            FileAttribute<?>... attrs)\n+                                              Set<? extends OpenOption> options,\n+                                              FileAttribute<?>... attrs)\n@@ -316,2 +330,2 @@\n-            Set<? extends OpenOption> options,\n-            FileAttribute<?>... attrs)\n+                                      Set<? extends OpenOption> options,\n+                                      FileAttribute<?>... attrs)\n@@ -337,1 +351,1 @@\n-            readAttributes(Path path, Class<A> type, LinkOption... options)\n+    readAttributes(Path path, Class<A> type, LinkOption... options)\n@@ -347,1 +361,1 @@\n-            readAttributes(Path path, String attribute, LinkOption... options)\n+    readAttributes(Path path, String attribute, LinkOption... options)\n@@ -354,1 +368,1 @@\n-            Object value, LinkOption... options)\n+                             Object value, LinkOption... options)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystemProvider.java","additions":39,"deletions":25,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -50,1 +51,1 @@\n-@SuppressWarnings({ \"removal\", \"suppression\"} )\n+@SuppressWarnings({\"removal\", \"suppression\"})\n@@ -57,1 +58,1 @@\n-    static SystemImage open() throws IOException {\n+    static SystemImage open(PreviewMode mode) throws IOException {\n@@ -60,1 +61,1 @@\n-            final ImageReader image = ImageReader.open(moduleImageFile);\n+            final ImageReader image = ImageReader.open(moduleImageFile, mode);\n@@ -76,0 +77,1 @@\n+\n@@ -78,0 +80,4 @@\n+        \/\/ TODO: Support preview mode in ExplodedImage and remove this check.\n+        if (mode.isPreviewModeEnabled())\n+            throw new UnsupportedOperationException(\n+                    \"Preview mode not yet supported for exploded images\");\n@@ -98,6 +104,6 @@\n-            new PrivilegedAction<Boolean>() {\n-                @Override\n-                public Boolean run() {\n-                    return Files.isRegularFile(moduleImageFile);\n-                }\n-            });\n+                new PrivilegedAction<Boolean>() {\n+                    @Override\n+                    public Boolean run() {\n+                        return Files.isRegularFile(moduleImageFile);\n+                    }\n+                });\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n- *\n- * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleConsts.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n- *\n- * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatConsts.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-import jdk.internal.jimage.ImageReaderFactory;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -89,1 +89,1 @@\n-    private SystemModuleFinders() { }\n+    private SystemModuleFinders() {}\n@@ -151,1 +151,1 @@\n-            = (Map.Entry<String, ModuleReference>[])new Map.Entry[moduleCount];\n+                = (Map.Entry<String, ModuleReference>[]) new Map.Entry[moduleCount];\n@@ -159,4 +159,4 @@\n-                                                     targets[i],\n-                                                     recordedHashes[i],\n-                                                     hashSupplier,\n-                                                     moduleResolutions[i]);\n+                    targets[i],\n+                    recordedHashes[i],\n+                    hashSupplier,\n+                    moduleResolutions[i]);\n@@ -239,4 +239,4 @@\n-                                                     attrs.target(),\n-                                                     attrs.recordedHashes(),\n-                                                     hashSupplier,\n-                                                     attrs.moduleResolution());\n+                    attrs.target(),\n+                    attrs.recordedHashes(),\n+                    hashSupplier,\n+                    attrs.moduleResolution());\n@@ -334,7 +334,7 @@\n-                                                       uri,\n-                                                       readerSupplier,\n-                                                       null,\n-                                                       target,\n-                                                       recordedHashes,\n-                                                       hasher,\n-                                                       mres);\n+                uri,\n+                readerSupplier,\n+                null,\n+                target,\n+                recordedHashes,\n+                hasher,\n+                mres);\n@@ -395,1 +395,1 @@\n-        static final ImageReader READER = ImageReaderFactory.getImageReader();\n+        static final ImageReader READER = SystemImageReader.get();\n@@ -518,1 +518,1 @@\n-            for (;;) {\n+            for (; ; ) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.internal.jimage.ImageReaderFactory;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -51,1 +51,1 @@\n-    private static final ImageReader READER = ImageReaderFactory.getImageReader();\n+    private static final ImageReader READER = SystemImageReader.get();\n@@ -112,0 +112,2 @@\n+        \/\/ Note: UncheckedIOException is thrown by the Node subclass in\n+        \/\/ ExplodedImage (this not obvious, so worth calling out).\n@@ -114,1 +116,1 @@\n-        } catch (IOException ioe) {\n+        } catch (IOException | UncheckedIOException ioe) {\n@@ -122,1 +124,1 @@\n-        return len > Integer.MAX_VALUE ? -1 : (int)len;\n+        return len > Integer.MAX_VALUE ? -1 : (int) len;\n@@ -127,0 +129,4 @@\n+        if (path.indexOf('%') == -1) {\n+            \/\/ Nothing to decode (overwhelmingly common case).\n+            return path;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jrt\/JavaRuntimeURLConnection.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -862,0 +862,16 @@\n+    \/**\n+     * Checks that the BMPString does not contain any surrogate characters,\n+     * which are outside the Basic Multilingual Plane.\n+     *\n+     * @throws IOException if illegal characters are detected\n+     *\/\n+    public void validateBMPString() throws IOException {\n+        String bmpString = getBMPString();\n+        for (int i = 0; i < bmpString.length(); i++) {\n+            if (Character.isSurrogate(bmpString.charAt(i))) {\n+                throw new IOException(\n+                    \"Illegal character in BMPString, index: \" + i);\n+            }\n+         }\n+     }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.charset.Charset;\n@@ -34,0 +35,1 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n@@ -35,0 +37,1 @@\n+import static java.nio.charset.StandardCharsets.UTF_16BE;\n@@ -592,0 +595,4 @@\n+\n+        if (value.tag == DerValue.tag_BMPString) {\n+            value.validateBMPString();\n+        }\n@@ -716,1 +723,2 @@\n-            String valStr = new String(value.getDataBytes(), UTF_8);\n+            String valStr =\n+                new String(value.getDataBytes(), getCharset(value, false));\n@@ -835,1 +843,2 @@\n-            String valStr = new String(value.getDataBytes(), UTF_8);\n+            String valStr =\n+                new String(value.getDataBytes(), getCharset(value, true));\n@@ -930,0 +939,33 @@\n+    \/*\n+     * Returns the charset that should be used to decode each DN string type.\n+     *\n+     * This method ensures that multi-byte (UTF8String and BMPString) types\n+     * are decoded using the correct charset and the String forms represent\n+     * the correct characters. For 8-bit ASCII-based types (PrintableString\n+     * and IA5String), we return ISO_8859_1 rather than ASCII, so that the\n+     * complete range of characters can be represented, as many certificates\n+     * do not comply with the Internationalized Domain Name ACE format.\n+     *\n+     * NOTE: this method only supports DirectoryStrings of the types returned\n+     * by isDerString().\n+     *\/\n+    private static Charset getCharset(DerValue value, boolean canonical) {\n+        if (canonical) {\n+            return switch (value.tag) {\n+                case DerValue.tag_PrintableString -> ISO_8859_1;\n+                case DerValue.tag_UTF8String -> UTF_8;\n+                default -> throw new Error(\"unexpected tag: \" + value.tag);\n+            };\n+        }\n+\n+        return switch (value.tag) {\n+            case DerValue.tag_PrintableString,\n+                 DerValue.tag_T61String,\n+                 DerValue.tag_IA5String,\n+                 DerValue.tag_GeneralString -> ISO_8859_1;\n+            case DerValue.tag_BMPString -> UTF_16BE;\n+            case DerValue.tag_UTF8String -> UTF_8;\n+            default -> throw new Error(\"unexpected tag: \" + value.tag);\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AVA.java","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,3 +130,24 @@\n-        if (params != null) {\n-            encodedParams = params.toByteArray();\n-            decodeParams();\n+\n+        if (params == null) {\n+            this.encodedParams = null;\n+            this.algParams = null;\n+            return;\n+        }\n+\n+        \/*\n+         * If the parameters field explicitly contains an ASN.1 NULL, treat it as\n+         * \"no parameters\" rather than storing a literal NULL encoding.\n+         *\n+         * This canonicalization ensures consistent encoding\/decoding behavior:\n+         *  - Algorithms that omit parameters and those that encode explicit NULL\n+         *   are treated equivalently (encodedParams == null).\n+         *\/\n+        if (params.tag == DerValue.tag_Null) {\n+            if (params.length() != 0) {\n+                throw new IOException(\"Invalid ASN.1 NULL in AlgorithmId parameters: \" +\n+                        \"non-zero length\");\n+            }\n+            \/\/ Canonicalize to \"no parameters\" representation for consistency\n+            this.encodedParams = null;\n+            this.algParams = null;\n+            return;\n@@ -134,0 +155,4 @@\n+\n+        \/\/ Normal case: non-NULL params -> store and decode\n+        this.encodedParams = params.toByteArray();\n+        decodeParams();\n@@ -166,31 +191,1 @@\n-            \/\/ MessageDigest algorithms usually have a NULL parameters even\n-            \/\/ if most RFCs suggested absent.\n-            \/\/ RSA key and signature algorithms requires the NULL parameters\n-            \/\/ to be present, see A.1 and A.2.4 of RFC 8017.\n-            if (algid.equals(RSAEncryption_oid)\n-                    || algid.equals(MD2_oid)\n-                    || algid.equals(MD5_oid)\n-                    || algid.equals(SHA_oid)\n-                    || algid.equals(SHA224_oid)\n-                    || algid.equals(SHA256_oid)\n-                    || algid.equals(SHA384_oid)\n-                    || algid.equals(SHA512_oid)\n-                    || algid.equals(SHA512_224_oid)\n-                    || algid.equals(SHA512_256_oid)\n-                    || algid.equals(SHA3_224_oid)\n-                    || algid.equals(SHA3_256_oid)\n-                    || algid.equals(SHA3_384_oid)\n-                    || algid.equals(SHA3_512_oid)\n-                    || algid.equals(SHA1withRSA_oid)\n-                    || algid.equals(SHA224withRSA_oid)\n-                    || algid.equals(SHA256withRSA_oid)\n-                    || algid.equals(SHA384withRSA_oid)\n-                    || algid.equals(SHA512withRSA_oid)\n-                    || algid.equals(SHA512$224withRSA_oid)\n-                    || algid.equals(SHA512$256withRSA_oid)\n-                    || algid.equals(MD2withRSA_oid)\n-                    || algid.equals(MD5withRSA_oid)\n-                    || algid.equals(SHA3_224withRSA_oid)\n-                    || algid.equals(SHA3_256withRSA_oid)\n-                    || algid.equals(SHA3_384withRSA_oid)\n-                    || algid.equals(SHA3_512withRSA_oid)) {\n+            if (OIDS_REQUIRING_NULL.contains(algid.toString())) {\n@@ -198,0 +193,2 @@\n+            } else {\n+                \/\/ Parameters omitted\n@@ -649,26 +646,50 @@\n-    public static final ObjectIdentifier SHA1withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA1withRSA);\n-    public static final ObjectIdentifier SHA224withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA224withRSA);\n-    public static final ObjectIdentifier SHA256withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA256withRSA);\n-    public static final ObjectIdentifier SHA384withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA384withRSA);\n-    public static final ObjectIdentifier SHA512withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA512withRSA);\n-    public static final ObjectIdentifier SHA512$224withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA512$224withRSA);\n-    public static final ObjectIdentifier SHA512$256withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA512$256withRSA);\n-    public static final ObjectIdentifier MD2withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.MD2withRSA);\n-    public static final ObjectIdentifier MD5withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.MD5withRSA);\n-    public static final ObjectIdentifier SHA3_224withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA3_224withRSA);\n-    public static final ObjectIdentifier SHA3_256withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA3_256withRSA);\n-    public static final ObjectIdentifier SHA3_384withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA3_384withRSA);\n-    public static final ObjectIdentifier SHA3_512withRSA_oid =\n-            ObjectIdentifier.of(KnownOIDs.SHA3_512withRSA);\n+    \/* Set of OIDs that must explicitly encode a NULL parameter in AlgorithmIdentifier.\n+     * References:\n+         - RFC 8017 (PKCS #1) A.1, A.2.4: RSA key and signature algorithms\n+         - RFC 9879 (HMAC) 4: HMAC algorithm identifiers\n+         - RFC 9688 (HMAC with SHA-3) 4.3: HMAC-SHA3 algorithms MUST omit parameters\n+     *\/\n+    private static final Set<String> OIDS_REQUIRING_NULL = Set.of(\n+            \/\/ MessageDigest algorithms usually have a NULL parameters even\n+            \/\/ if most RFCs suggested absent.\n+            KnownOIDs.MD2.value(),\n+            KnownOIDs.MD5.value(),\n+            KnownOIDs.SHA_1.value(),\n+            KnownOIDs.SHA_224.value(),\n+            KnownOIDs.SHA_256.value(),\n+            KnownOIDs.SHA_384.value(),\n+            KnownOIDs.SHA_512.value(),\n+            KnownOIDs.SHA_512$224.value(),\n+            KnownOIDs.SHA_512$256.value(),\n+            KnownOIDs.SHA3_224.value(),\n+            KnownOIDs.SHA3_256.value(),\n+            KnownOIDs.SHA3_384.value(),\n+            KnownOIDs.SHA3_512.value(),\n+\n+            \/\/--- RSA key and signature algorithms (RFC 8017 A.1, A.2.4)\n+            KnownOIDs.RSA.value(),\n+            KnownOIDs.SHA1withRSA.value(),\n+            KnownOIDs.SHA224withRSA.value(),\n+            KnownOIDs.SHA256withRSA.value(),\n+            KnownOIDs.SHA384withRSA.value(),\n+            KnownOIDs.SHA512withRSA.value(),\n+            KnownOIDs.SHA512$224withRSA.value(),\n+            KnownOIDs.SHA512$256withRSA.value(),\n+            KnownOIDs.MD2withRSA.value(),\n+            KnownOIDs.MD5withRSA.value(),\n+            KnownOIDs.SHA3_224withRSA.value(),\n+            KnownOIDs.SHA3_256withRSA.value(),\n+            KnownOIDs.SHA3_384withRSA.value(),\n+            KnownOIDs.SHA3_512withRSA.value(),\n+\n+            \/\/ HMACs per RFC 9879 (Section 4): these require explicit NULL parameters\n+            \/\/ Note: HMAC-SHA3 algorithms (RFC 9688 4.3) MUST omit parameters,\n+            \/\/ so they are intentionally excluded from this list.\n+            KnownOIDs.HmacSHA1.value(),\n+            KnownOIDs.HmacSHA224.value(),\n+            KnownOIDs.HmacSHA256.value(),\n+            KnownOIDs.HmacSHA384.value(),\n+            KnownOIDs.HmacSHA512.value(),\n+            KnownOIDs.HmacSHA512$224.value(),\n+            KnownOIDs.HmacSHA512$256.value()\n+    );\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":82,"deletions":61,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -322,6 +322,1 @@\n-        \/\/ Temporarily, we allow either version (1.1 or 1.0) of the file to\n-        \/\/ be read so this code can be committed before image writing changes\n-        \/\/ for preview mode. Preview mode changes do not modify any structure,\n-        \/\/ so a 1.0 file will look like a jimage without any preview resources.\n-        \/\/ TODO: Restore equality check for MINOR_VERSION.\n-        _header.minor_version(_endian) > MINOR_VERSION) {\n+        _header.minor_version(_endian) != MINOR_VERSION) {\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -398,1 +398,2 @@\n-static jboolean isLegalTarget(context_type *, int offset);\n+static jboolean isLegalOffset(context_type *, int bci, int offset);\n+static jboolean isLegalTarget(context_type *, int target);\n@@ -1157,2 +1158,1 @@\n-        int target = offset + jump;\n-        if (!isLegalTarget(context, target))\n+        if (!isLegalOffset(context, offset, jump))\n@@ -1160,0 +1160,1 @@\n+        int target = offset + jump;\n@@ -1173,2 +1174,1 @@\n-        int target = offset + jump;\n-        if (!isLegalTarget(context, target))\n+        if (!isLegalOffset(context, offset, jump))\n@@ -1176,0 +1176,1 @@\n+        int target = offset + jump;\n@@ -1214,1 +1215,2 @@\n-        if (!isLegalTarget(context, offset + _ck_ntohl(lpc[0])))\n+        int jump = _ck_ntohl(lpc[0]);\n+        if (!isLegalOffset(context, offset, jump))\n@@ -1216,1 +1218,2 @@\n-        saved_operand[keys + 1] = code_data[offset + _ck_ntohl(lpc[0])];\n+        int target = offset + jump;\n+        saved_operand[keys + 1] = code_data[target];\n@@ -1218,2 +1221,2 @@\n-            int target = offset + _ck_ntohl(lptr[0]);\n-            if (!isLegalTarget(context, target))\n+            jump = _ck_ntohl(lptr[0]);\n+            if (!isLegalOffset(context, offset, jump))\n@@ -1221,0 +1224,1 @@\n+            target = offset + jump;\n@@ -1749,1 +1753,10 @@\n-isLegalTarget(context_type *context, int offset)\n+isLegalTarget(context_type *context, int target)\n+{\n+    int code_length = context->code_length;\n+    int *code_data = context->code_data;\n+    return (target >= 0 && target < code_length && code_data[target] >= 0);\n+}\n+\n+\/* Given a bci and offset, make sure the offset is valid and the target is legal *\/\n+static jboolean\n+isLegalOffset(context_type *context, int bci, int offset)\n@@ -1753,1 +1766,5 @@\n-    return (offset >= 0 && offset < code_length && code_data[offset] >= 0);\n+    int max_offset = 65535; \/\/ JVMS 4.11\n+    int min_offset = -65535;\n+    if (offset < min_offset || offset > max_offset) return JNI_FALSE;\n+    int target = bci + offset;\n+    return (target >= 0 && target < code_length && code_data[target] >= 0);\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -349,0 +349,13 @@\n+        private static int toRangeHash(Set<Range> ranges) {\n+            int m = 0;\n+            for (Range range : ranges) {\n+                int index = range.ordinal();\n+                if (index < NUM_KEYS) {\n+                    m |= 1 << index;\n+                } else {\n+                    m |=  (1 << NUM_KEYS) + index;\n+                }\n+            }\n+            return m;\n+        }\n+\n@@ -579,1 +592,1 @@\n-    private static int ctCacheLimit = contexts.length - 2;\n+    private static final int ctCacheLimit = contexts.length - 2;\n@@ -1513,0 +1526,3 @@\n+        if (((this.mask & ARABIC) != 0) && ((this.mask & EASTERN_ARABIC) != 0)) {\n+            this.mask &= ~ARABIC;\n+        }\n@@ -1798,9 +1814,1 @@\n-        int hash = mask;\n-        if (rangeSet != null) {\n-            \/\/ Use the CONTEXTUAL_MASK bit only for the enum-based\n-            \/\/ NumericShaper. A deserialized NumericShaper might have\n-            \/\/ bit masks.\n-            hash &= CONTEXTUAL_MASK;\n-            hash ^= rangeSet.hashCode();\n-        }\n-        return hash;\n+        return (rangeSet != null) ? Range.toRangeHash(rangeSet) : (mask & ~CONTEXTUAL_MASK);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/NumericShaper.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,3 @@\n-    private int perpendiculardfddf(final double[] pts, final int off) {\n+    private int perpendiculardfddf(final double[] pts, final int off,\n+                                   final double A, final double B)\n+    {\n@@ -158,1 +160,1 @@\n-        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0.0d, 1.0d);\n+        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, A, B);\n@@ -174,1 +176,3 @@\n-    int rootsOfROCMinusW(final double[] roots, final int off, final double w2, final double err) {\n+    int rootsOfROCMinusW(final double[] roots, final int off, final double w2,\n+                         final double A, final double B)\n+    {\n@@ -179,1 +183,2 @@\n-        final int end = off + perpendiculardfddf(roots, off);\n+        final int end = off + perpendiculardfddf(roots, off, A, B);\n+        Helpers.isort(roots, off, end);\n@@ -182,1 +187,3 @@\n-        double t0 = 0.0d, ft0 = ROCsq(t0) - w2;\n+        double t0 = 0.0d;\n+        double ft0 = eliminateInf(ROCsq(t0) - w2);\n+        double t1, ft1;\n@@ -185,1 +192,2 @@\n-            double t1 = roots[i], ft1 = ROCsq(t1) - w2;\n+            t1 = roots[i];\n+            ft1 = eliminateInf(ROCsq(t1) - w2);\n@@ -191,1 +199,1 @@\n-                roots[ret++] = falsePositionROCsqMinusX(t0, t1, w2, err);\n+                roots[ret++] = falsePositionROCsqMinusX(t0, t1, ft0, ft1, w2, A); \/\/ A = err\n@@ -196,1 +204,0 @@\n-\n@@ -200,3 +207,6 @@\n-    private static double eliminateInf(final double x) {\n-        return (x == Double.POSITIVE_INFINITY ? Double.MAX_VALUE :\n-               (x == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : x));\n+    private final static double MAX_ROC_SQ = 1e20;\n+\n+    private static double eliminateInf(final double x2) {\n+        \/\/ limit the value of x to avoid numerical problems (smaller step):\n+        \/\/ must handle NaN and +Infinity:\n+        return (x2 <= MAX_ROC_SQ) ? x2 : MAX_ROC_SQ;\n@@ -213,0 +223,1 @@\n+                                            final double ft0, final double ft1,\n@@ -217,2 +228,2 @@\n-        double t = t1, ft = eliminateInf(ROCsq(t) - w2);\n-        double s = t0, fs = eliminateInf(ROCsq(s) - w2);\n+        double s = t0, fs = eliminateInf(ft0);\n+        double t = t1, ft = eliminateInf(ft1);\n@@ -221,1 +232,1 @@\n-        for (int i = 0; i < iterLimit && Math.abs(t - s) > err * Math.abs(t + s); i++) {\n+        for (int i = 0; i < iterLimit && Math.abs(t - s) > err; i++) {\n@@ -223,1 +234,1 @@\n-            fr = ROCsq(r) - w2;\n+            fr = eliminateInf(ROCsq(r) - w2);\n@@ -244,1 +255,1 @@\n-        return r;\n+        return (Math.abs(ft) <= Math.abs(fs)) ? t : s;\n@@ -259,4 +270,4 @@\n-        final double dx2dy2 = dx * dx + dy * dy;\n-        final double ddx2ddy2 = ddx * ddx + ddy * ddy;\n-        final double ddxdxddydy = ddx * dx + ddy * dy;\n-        return dx2dy2 * ((dx2dy2 * dx2dy2) \/ (dx2dy2 * ddx2ddy2 - ddxdxddydy * ddxdxddydy));\n+        final double dx2dy2 = dx * dx + dy * dy; \/\/ positive\n+        final double dxddyddxdy = dx * ddy - dy * ddx;\n+        \/\/ may return +Infinity if dxddyddxdy = 0 or NaN if 0\/0:\n+        return (dx2dy2 * dx2dy2 * dx2dy2) \/ (dxddyddxdy * dxddyddxdy); \/\/ both positive\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Curve.java","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-        return Math.abs(num) < 2.0d * Math.ulp(num);\n+        return Math.abs(num) < 2.0d * Helpers.ulp(num);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DMarlinRenderingEngine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+    private final static double T_ERR = 1e-4;\n+    private final static double T_A = T_ERR;\n+    private final static double T_B = 1.0 - T_ERR;\n+\n@@ -40,0 +44,3 @@\n+    \/** use lower precision like former Pisces and Marlin (float-precision) *\/\n+    static double ulp(final double value) { return Math.ulp((float)value); }\n+\n@@ -325,1 +332,1 @@\n-        ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001d);\n+        ret += c.rootsOfROCMinusW(ts, ret, w2, T_A, T_B);\n@@ -327,2 +334,2 @@\n-        ret = filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);\n-        isort(ts, ret);\n+        ret = filterOutNotInAB(ts, 0, ret, T_A, T_B);\n+        isort(ts, 0, ret);\n@@ -357,1 +364,1 @@\n-        isort(ts, ret);\n+        isort(ts, 0, ret);\n@@ -377,2 +384,2 @@\n-    static void isort(final double[] a, final int len) {\n-        for (int i = 1, j; i < len; i++) {\n+    static void isort(final double[] a, final int off, final int len) {\n+        for (int i = off + 1, j; i < len; i++) {\n@@ -381,1 +388,1 @@\n-            for (; j >= 0 && a[j] > ai; j--) {\n+            for (; j >= off && a[j] > ai; j--) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Helpers.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -889,2 +889,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Math.ulp(y2));\n-        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Math.ulp(y4));\n+        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Helpers.ulp(y2));\n+        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Helpers.ulp(y4));\n@@ -908,1 +908,1 @@\n-        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Helpers.ulp(dotsq))) {\n@@ -1081,2 +1081,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Math.ulp(y2));\n-        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Math.ulp(y3));\n+        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Helpers.ulp(y2));\n+        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Helpers.ulp(y3));\n@@ -1094,1 +1094,1 @@\n-        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Helpers.ulp(dotsq))) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-itcavantgarde=avantgarde_book\n","filename":"src\/java.desktop\/share\/conf\/psfontj2d.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,3 +79,1 @@\n-    \/**\n-     * Paint MenuItem.\n-     *\/\n+    @Override\n@@ -87,5 +85,8 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n-                    arrowIcon, background, foreground,\n-                    disabledForeground, acceleratorSelectionForeground,\n-                    acceleratorForeground, defaultTextIconGap,\n-                    menuItem, getPropertyPrefix());\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n+                                            checkIcon, arrowIcon,\n+                                            background, foreground,\n+                                            disabledForeground,\n+                                            acceleratorSelectionForeground,\n+                                            acceleratorForeground,\n+                                            defaultTextIconGap,\n+                                            menuItem, getPropertyPrefix());\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsCheckBoxMenuItemUI.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.awt.Insets;\n@@ -36,1 +35,0 @@\n-import java.util.Enumeration;\n@@ -38,2 +36,0 @@\n-import javax.swing.AbstractButton;\n-import javax.swing.ButtonGroup;\n@@ -41,1 +37,0 @@\n-import javax.swing.DefaultButtonModel;\n@@ -135,21 +130,0 @@\n-    protected void installDefaults() {\n-        super.installDefaults();\n-        String prefix = getPropertyPrefix();\n-\n-        if (acceleratorSelectionForeground == null ||\n-                acceleratorSelectionForeground instanceof UIResource) {\n-            acceleratorSelectionForeground =\n-                    UIManager.getColor(prefix + \".acceleratorSelectionForeground\");\n-        }\n-        if (acceleratorForeground == null ||\n-                acceleratorForeground instanceof UIResource) {\n-            acceleratorForeground =\n-                    UIManager.getColor(prefix + \".acceleratorForeground\");\n-        }\n-        if (disabledForeground == null ||\n-                disabledForeground instanceof UIResource) {\n-            disabledForeground =\n-                    UIManager.getColor(prefix + \".disabledForeground\");\n-        }\n-    }\n-\n@@ -168,0 +142,1 @@\n+    @Override\n@@ -173,4 +148,7 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n-                                            arrowIcon, background, foreground,\n-                                            disabledForeground, acceleratorSelectionForeground,\n-                                            acceleratorForeground, defaultTextIconGap, menuItem,\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n+                                            checkIcon, arrowIcon,\n+                                            background, foreground,\n+                                            disabledForeground,\n+                                            acceleratorSelectionForeground,\n+                                            acceleratorForeground,\n+                                            defaultTextIconGap, menuItem,\n@@ -185,1 +163,2 @@\n-                              JComponent c, Icon checkIcon, Icon arrowIcon,\n+                              JComponent c,\n+                              Icon checkIcon, Icon arrowIcon,\n@@ -190,1 +169,4 @@\n-                              int defaultTextIconGap, JMenuItem menuItem, String prefix) {\n+                              int defaultTextIconGap, JMenuItem menuItem,\n+                              String prefix) {\n+        assert c == menuItem : \"menuItem passed as 'c' must be the same\";\n+\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -134,3 +134,1 @@\n-    \/**\n-     * Paint MenuItem.\n-     *\/\n+    @Override\n@@ -138,3 +136,4 @@\n-                              Icon checkIcon, Icon arrowIcon,\n-                              Color background, Color foreground,\n-                              int defaultTextIconGap) {\n+                                 Icon checkIcon, Icon arrowIcon,\n+                                 Color background, Color foreground,\n+                                 int defaultTextIconGap) {\n+        assert c == menuItem : \"menuItem passed as 'c' must be the same\";\n@@ -142,1 +141,2 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon, arrowIcon,\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n+                                            checkIcon, arrowIcon,\n@@ -144,2 +144,4 @@\n-                                            disabledForeground, acceleratorSelectionForeground,\n-                                            acceleratorForeground, defaultTextIconGap, menuItem,\n+                                            disabledForeground,\n+                                            acceleratorSelectionForeground,\n+                                            acceleratorForeground,\n+                                            defaultTextIconGap, menuItem,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuUI.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -79,3 +79,1 @@\n-    \/**\n-     * Paint MenuItem.\n-     *\/\n+    @Override\n@@ -87,5 +85,8 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n-                    arrowIcon, background, foreground,\n-                    disabledForeground, acceleratorSelectionForeground,\n-                    acceleratorForeground, defaultTextIconGap,\n-                    menuItem, getPropertyPrefix());\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n+                                            checkIcon, arrowIcon,\n+                                            background, foreground,\n+                                            disabledForeground,\n+                                            acceleratorSelectionForeground,\n+                                            acceleratorForeground,\n+                                            defaultTextIconGap,\n+                                            menuItem, getPropertyPrefix());\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRadioButtonMenuItemUI.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -293,1 +293,2 @@\n-        sb.append(request.method())\n+        String method = request.method();\n+        sb.append(method)\n@@ -303,1 +304,0 @@\n-        \/\/ GET, HEAD and DELETE with no request body should not set the Content-Length header\n@@ -307,1 +307,6 @@\n-                systemHeadersBuilder.setHeader(\"Content-Length\", \"0\");\n+                \/\/ PUT and POST with no request body should set the Content-Length header\n+                \/\/ even when the content is empty.\n+                \/\/ Other methods defined in RFC 9110 should not send the header in that case.\n+                if (\"POST\".equals(method) || \"PUT\".equals(method)) {\n+                    systemHeadersBuilder.setHeader(\"Content-Length\", \"0\");\n+                }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -177,3 +177,2 @@\n-     * Allocated buffer size. Must never be higher than 16K. But can be lower\n-     * if smaller allocation units preferred. HTTP\/2 mandates that all\n-     * implementations support frame payloads of at least 16K.\n+     * The capacity of ephemeral {@link ByteBuffer}s allocated to pass data to and from the client.\n+     * It is ensured to have a value between 1 and 2^14 (16,384).\n@@ -181,2 +180,0 @@\n-    private static final int DEFAULT_BUFSIZE = 16 * 1024;\n-\n@@ -184,2 +181,10 @@\n-            \"jdk.httpclient.bufsize\", DEFAULT_BUFSIZE\n-    );\n+            \"jdk.httpclient.bufsize\", 1,\n+            \/\/ We cap at 2^14 (16,384) for two main reasons:\n+            \/\/ - The initial frame size is 2^14 (RFC 9113)\n+            \/\/ - SSL record layer fragments data in chunks of 2^14 bytes or less (RFC 5246)\n+            1 << 14,\n+            \/\/ We choose 2^14 (16,384) as the default, because:\n+            \/\/ 1. It maximizes throughput within the limits described above\n+            \/\/ 2. It is small enough to not create a GC bottleneck when it is partially filled\n+            1 << 14,\n+            true);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,1 +51,3 @@\n- * The size to use for internal allocated buffers in bytes.\n+ * The capacity of internal ephemeral buffers allocated to pass data to and from the\n+ * client, in bytes. Valid values are in the range [1, 2^14 (16384)].\n+ * If an invalid value is provided, the default value is used.\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @LastModified: May 2025\n+ * @LastModified: June 2025\n@@ -62,0 +62,3 @@\n+    \/**\n+     * Creates a new {@code DocumentBuilderFactory} instance.\n+     *\/\n@@ -63,0 +66,10 @@\n+        this(null, null);\n+    }\n+\n+    \/**\n+     * Creates a new {@code DocumentBuilderFactory} instance with a {@code XMLSecurityManager}\n+     * and {@code XMLSecurityPropertyManager}.\n+     * @param xsm the {@code XMLSecurityManager}\n+     * @param xspm the {@code XMLSecurityPropertyManager}\n+     *\/\n+    public DocumentBuilderFactoryImpl(XMLSecurityManager xsm, XMLSecurityPropertyManager xspm) {\n@@ -65,2 +78,2 @@\n-        fSecurityManager = config.getXMLSecurityManager(true);\n-        fSecurityPropertyMgr = config.getXMLSecurityPropertyManager(true);\n+        fSecurityManager = (xsm == null) ? config.getXMLSecurityManager(true) : xsm;\n+        fSecurityPropertyMgr = (xspm == null) ? config.getXMLSecurityPropertyManager(true) : xspm;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/DocumentBuilderFactoryImpl.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @LastModified: May 2025\n+ * @LastModified: June 2025\n@@ -75,0 +75,1 @@\n+        private XMLSecurityPropertyManager _xmlSecPropMgr;\n@@ -83,0 +84,1 @@\n+            _xmlSecPropMgr = config.getXMLSecurityPropertyManager(true);\n@@ -132,1 +134,1 @@\n-                    !_isNotSecureProcessing, _featureManager, _xmlSecMgr);\n+                    !_isNotSecureProcessing, _featureManager, _xmlSecMgr, _xmlSecPropMgr);\n@@ -186,0 +188,1 @@\n+                    _xmlSecMgr.setSecureProcessing(value);\n@@ -341,2 +344,1 @@\n-        if (_xmlSecMgr != null &&\n-                _xmlSecMgr.setLimit(name, JdkProperty.State.APIPROPERTY, value)) {\n+        if (JdkXmlUtils.setProperty(_xmlSecMgr, _xmlSecPropMgr, name, value)) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathFactoryImpl.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.xml.internal.XMLSecurityPropertyManager;\n@@ -53,1 +54,1 @@\n- * @LastModified: May 2025\n+ * @LastModified: June 2025\n@@ -65,1 +66,2 @@\n-                JdkXmlConfig.getInstance(false).getXMLSecurityManager(false));\n+                JdkXmlConfig.getInstance(false).getXMLSecurityManager(false),\n+                JdkXmlConfig.getInstance(false).getXMLSecurityPropertyManager(false));\n@@ -70,1 +72,1 @@\n-            XMLSecurityManager xmlSecMgr) {\n+            XMLSecurityManager xmlSecMgr, XMLSecurityPropertyManager xmlSecPropMgr) {\n@@ -78,0 +80,1 @@\n+        this.xmlSecPropMgr = xmlSecPropMgr;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathImpl.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import javax.xml.XMLConstants;\n@@ -47,0 +48,1 @@\n+import jdk.xml.internal.XMLSecurityPropertyManager;\n@@ -57,1 +59,1 @@\n- * @LastModified: Apr 2025\n+ * @LastModified: June 2025\n@@ -70,0 +72,1 @@\n+    XMLSecurityPropertyManager xmlSecPropMgr;\n@@ -131,1 +134,6 @@\n-            DocumentBuilderFactory dbf = JdkXmlUtils.getDOMFactory(overrideDefaultParser);\n+            DocumentBuilderFactory dbf = JdkXmlUtils.getDOMFactory(\n+                    overrideDefaultParser, xmlSecMgr, xmlSecPropMgr);\n+            if (xmlSecMgr != null && xmlSecMgr.isSecureProcessingSet()) {\n+                dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING,\n+                        xmlSecMgr.isSecureProcessing());\n+            }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathImplUtil.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -448,0 +448,14 @@\n+        return getDOMFactory(overrideDefaultParser, null, null);\n+    }\n+\n+    \/**\n+     * {@return a DocumentBuilderFactory instance}\n+     *\n+     * @param overrideDefaultParser a flag indicating whether the system-default\n+     * implementation may be overridden. If the system property of the\n+     * DOM factory ID is set, override is always allowed.\n+     * @param xsm XMLSecurityManager\n+     * @param xspm XMLSecurityPropertyManager\n+     *\/\n+    public static DocumentBuilderFactory getDOMFactory(boolean overrideDefaultParser,\n+            XMLSecurityManager xsm, XMLSecurityPropertyManager xspm) {\n@@ -456,1 +470,1 @@\n-                        ? new DocumentBuilderFactoryImpl()\n+                        ? new DocumentBuilderFactoryImpl(xsm, xspm)\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkXmlUtils.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -247,0 +247,6 @@\n+    \/**\n+     * Flag indicating the secure processing is set explicitly through factories'\n+     * setFeature method and then the setSecureProcessing method\n+     *\/\n+    boolean secureProcessingSet;\n+\n@@ -343,0 +349,1 @@\n+        secureProcessingSet = true;\n@@ -361,0 +368,9 @@\n+    \/**\n+     * Returns the state indicating whether the Secure Processing is set explicitly,\n+     * via factories' setFeature and then this class' setSecureProcessing method.\n+     * @return the state indicating whether the Secure Processing is set explicitly\n+     *\/\n+    public boolean isSecureProcessingSet() {\n+        return secureProcessingSet;\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/XMLSecurityManager.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,604 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+import com.sun.tools.javac.code.*;\n+import com.sun.tools.javac.tree.*;\n+import com.sun.tools.javac.util.*;\n+\n+import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.tree.JCTree.*;\n+\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+\/** A class to compute exhaustiveness of set of switch cases.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class ExhaustivenessComputer {\n+    protected static final Context.Key<ExhaustivenessComputer> exhaustivenessKey = new Context.Key<>();\n+\n+    private final Symtab syms;\n+    private final Types types;\n+    private final Check chk;\n+    private final Infer infer;\n+\n+    public static ExhaustivenessComputer instance(Context context) {\n+        ExhaustivenessComputer instance = context.get(exhaustivenessKey);\n+        if (instance == null)\n+            instance = new ExhaustivenessComputer(context);\n+        return instance;\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ExhaustivenessComputer(Context context) {\n+        context.put(exhaustivenessKey, this);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        chk = Check.instance(context);\n+        infer = Infer.instance(context);\n+    }\n+\n+    public boolean exhausts(JCExpression selector, List<JCCase> cases) {\n+        Set<PatternDescription> patternSet = new HashSet<>();\n+        Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n+        Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n+        for (JCCase c : cases) {\n+            if (!TreeInfo.unguardedCase(c))\n+                continue;\n+\n+            for (var l : c.labels) {\n+                if (l instanceof JCPatternCaseLabel patternLabel) {\n+                    for (Type component : components(selector.type)) {\n+                        patternSet.add(makePatternDescription(component, patternLabel.pat));\n+                    }\n+                } else if (l instanceof JCConstantCaseLabel constantLabel) {\n+                    if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n+                        Object value = ((JCLiteral) constantLabel.expr).value;\n+                        booleanLiterals.remove(value);\n+                    } else {\n+                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                        if (s != null && s.isEnum()) {\n+                            enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                Set<Symbol> result = new HashSet<>();\n+                                s.owner.members()\n+                                        .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                        .forEach(result::add);\n+                                return result;\n+                            }).remove(s);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n+            return true;\n+        }\n+\n+        for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n+            if (e.getValue().isEmpty()) {\n+                patternSet.add(new BindingPattern(e.getKey().type));\n+            }\n+        }\n+        Set<PatternDescription> patterns = patternSet;\n+        boolean useHashes = true;\n+        try {\n+            boolean repeat = true;\n+            while (repeat) {\n+                Set<PatternDescription> updatedPatterns;\n+                updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n+                updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n+                updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                repeat = !updatedPatterns.equals(patterns);\n+                if (checkCovered(selector.type, patterns)) {\n+                    return true;\n+                }\n+                if (!repeat) {\n+                    \/\/there may be situation like:\n+                    \/\/class B permits S1, S2\n+                    \/\/patterns: R(S1, B), R(S2, S2)\n+                    \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n+                    \/\/but hashing in reduceNestedPatterns will not allow that\n+                    \/\/disable the use of hashing, and use subtyping in\n+                    \/\/reduceNestedPatterns to handle situations like this:\n+                    repeat = useHashes;\n+                    useHashes = false;\n+                } else {\n+                    \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                    \/\/is enabled, as the hashing speeds up the process significantly:\n+                    useHashes = true;\n+                }\n+                patterns = updatedPatterns;\n+            }\n+            return checkCovered(selector.type, patterns);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(selector.pos(), cf);\n+            return true; \/\/error recovery\n+        }\n+    }\n+\n+    private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n+        for (Type seltypeComponent : components(seltype)) {\n+            for (PatternDescription pd : patterns) {\n+                if(isBpCovered(seltypeComponent, pd)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private List<Type> components(Type seltype) {\n+        return switch (seltype.getTag()) {\n+            case CLASS -> {\n+                if (seltype.isCompound()) {\n+                    if (seltype.isIntersection()) {\n+                        yield ((Type.IntersectionClassType) seltype).getComponents()\n+                                                                    .stream()\n+                                                                    .flatMap(t -> components(t).stream())\n+                                                                    .collect(List.collector());\n+                    }\n+                    yield List.nil();\n+                }\n+                yield List.of(types.erasure(seltype));\n+            }\n+            case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n+            default -> List.of(types.erasure(seltype));\n+        };\n+    }\n+\n+    \/* In a set of patterns, search for a sub-set of binding patterns that\n+     * in combination exhaust their sealed supertype. If such a sub-set\n+     * is found, it is removed, and replaced with a binding pattern\n+     * for the sealed supertype.\n+     *\/\n+    private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n+        Set<Symbol> existingBindings = patterns.stream()\n+                                               .filter(pd -> pd instanceof BindingPattern)\n+                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                               .collect(Collectors.toSet());\n+\n+        for (PatternDescription pdOne : patterns) {\n+            if (pdOne instanceof BindingPattern bpOne) {\n+                Set<PatternDescription> toAdd = new HashSet<>();\n+\n+                for (Type sup : types.directSupertypes(bpOne.type)) {\n+                    ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n+\n+                    clazz.complete();\n+\n+                    if (clazz.isSealed() && clazz.isAbstract() &&\n+                        \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n+                        !existingBindings.contains(clazz)) {\n+                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n+                        \/\/do not reduce to types unrelated to the selector type:\n+                        Type clazzErasure = types.erasure(clazz.type);\n+                        if (components(selectorType).stream()\n+                                                    .map(types::erasure)\n+                                                    .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                            continue;\n+                        }\n+\n+                        Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n+                            Type instantiated;\n+                            if (csym.type.allparams().isEmpty()) {\n+                                instantiated = csym.type;\n+                            } else {\n+                                instantiated = infer.instantiatePatternType(selectorType, csym);\n+                            }\n+\n+                            return instantiated != null && types.isCastable(selectorType, instantiated);\n+                        });\n+\n+                        for (PatternDescription pdOther : patterns) {\n+                            if (pdOther instanceof BindingPattern bpOther) {\n+                                Set<Symbol> currentPermittedSubTypes =\n+                                        allPermittedSubTypes(bpOther.type.tsym, s -> true);\n+\n+                                PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n+                                    Symbol perm = it.next();\n+\n+                                    for (Symbol currentPermitted : currentPermittedSubTypes) {\n+                                        if (types.isSubtype(types.erasure(currentPermitted.type),\n+                                                            types.erasure(perm.type))) {\n+                                            it.remove();\n+                                            continue PERMITTED;\n+                                        }\n+                                    }\n+                                    if (types.isSubtype(types.erasure(perm.type),\n+                                                        types.erasure(bpOther.type))) {\n+                                        it.remove();\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        if (permitted.isEmpty()) {\n+                            toAdd.add(new BindingPattern(clazz.type));\n+                        }\n+                    }\n+                }\n+\n+                if (!toAdd.isEmpty()) {\n+                    Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n+                    newPatterns.addAll(toAdd);\n+                    return newPatterns;\n+                }\n+            }\n+        }\n+        return patterns;\n+    }\n+\n+    private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n+        Set<Symbol> permitted = new HashSet<>();\n+        List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n+\n+        while (permittedSubtypesClosure.nonEmpty()) {\n+            ClassSymbol current = permittedSubtypesClosure.head;\n+\n+            permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+            current.complete();\n+\n+            if (current.isSealed() && current.isAbstract()) {\n+                for (Type t : current.getPermittedSubclasses()) {\n+                    ClassSymbol csym = (ClassSymbol) t.tsym;\n+\n+                    if (accept.test(csym)) {\n+                        permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                        permitted.add(csym);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return permitted;\n+    }\n+\n+    private List<ClassSymbol> baseClasses(TypeSymbol root) {\n+        if (root instanceof ClassSymbol clazz) {\n+            return List.of(clazz);\n+        } else if (root instanceof TypeVariableSymbol tvar) {\n+            ListBuffer<ClassSymbol> result = new ListBuffer<>();\n+            for (Type bound : tvar.getBounds()) {\n+                result.appendList(baseClasses(bound.tsym));\n+            }\n+            return result.toList();\n+        } else {\n+            return List.nil();\n+        }\n+    }\n+\n+    \/* Among the set of patterns, find sub-set of patterns such:\n+     * $record($prefix$, $nested, $suffix$)\n+     * Where $record, $prefix$ and $suffix$ is the same for each pattern\n+     * in the set, and the patterns only differ in one \"column\" in\n+     * the $nested pattern.\n+     * Then, the set of $nested patterns is taken, and passed recursively\n+     * to reduceNestedPatterns and to reduceBindingPatterns, to\n+     * simplify the pattern. If that succeeds, the original found sub-set\n+     * of patterns is replaced with a new set of patterns of the form:\n+     * $record($prefix$, $resultOfReduction, $suffix$)\n+     *\n+     * useHashes: when true, patterns will be subject to exact equivalence;\n+     *            when false, two binding patterns will be considered equivalent\n+     *            if one of them is more generic than the other one;\n+     *            when false, the processing will be significantly slower,\n+     *            as pattern hashes cannot be used to speed up the matching process\n+     *\/\n+    private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n+                                                         boolean useHashes) {\n+        \/* implementation note:\n+         * finding a sub-set of patterns that only differ in a single\n+         * column is time-consuming task, so this method speeds it up by:\n+         * - group the patterns by their record class\n+         * - for each column (nested pattern) do:\n+         * -- group patterns by their hash\n+         * -- in each such by-hash group, find sub-sets that only differ in\n+         *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n+         *    on patterns in the chosen column, as described above\n+         *\/\n+        var groupByRecordClass =\n+                patterns.stream()\n+                        .filter(pd -> pd instanceof RecordPattern)\n+                        .map(pd -> (RecordPattern) pd)\n+                        .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n+\n+        for (var e : groupByRecordClass.entrySet()) {\n+            int nestedPatternsCount = e.getKey().getRecordComponents().size();\n+            Set<RecordPattern> current = new HashSet<>(e.getValue());\n+\n+            for (int mismatchingCandidate = 0;\n+                 mismatchingCandidate < nestedPatternsCount;\n+                 mismatchingCandidate++) {\n+                int mismatchingCandidateFin = mismatchingCandidate;\n+                var groupEquivalenceCandidates =\n+                        current\n+                         .stream()\n+                         \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                         .filter(pd -> pd.nested.length == nestedPatternsCount)\n+                         .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n+                for (var candidates : groupEquivalenceCandidates.values()) {\n+                    var candidatesArr = candidates.toArray(RecordPattern[]::new);\n+\n+                    for (int firstCandidate = 0;\n+                         firstCandidate < candidatesArr.length;\n+                         firstCandidate++) {\n+                        RecordPattern rpOne = candidatesArr[firstCandidate];\n+                        ListBuffer<RecordPattern> join = new ListBuffer<>();\n+\n+                        join.append(rpOne);\n+\n+                        NEXT_PATTERN: for (int nextCandidate = 0;\n+                                           nextCandidate < candidatesArr.length;\n+                                           nextCandidate++) {\n+                            if (firstCandidate == nextCandidate) {\n+                                continue;\n+                            }\n+\n+                            RecordPattern rpOther = candidatesArr[nextCandidate];\n+                            if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n+                                for (int i = 0; i < rpOne.nested.length; i++) {\n+                                    if (i != mismatchingCandidate) {\n+                                        if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                            if (useHashes ||\n+                                                \/\/when not using hashes,\n+                                                \/\/check if rpOne.nested[i] is\n+                                                \/\/a subtype of rpOther.nested[i]:\n+                                                !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n+                                                !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n+                                                !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                continue NEXT_PATTERN;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                join.append(rpOther);\n+                            }\n+                        }\n+\n+                        var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n+                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n+\n+                        updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                        updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                        updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n+\n+                        if (!nestedPatterns.equals(updatedPatterns)) {\n+                            if (useHashes) {\n+                                current.removeAll(join);\n+                            }\n+\n+                            for (PatternDescription nested : updatedPatterns) {\n+                                PatternDescription[] newNested =\n+                                        Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                                newNested[mismatchingCandidateFin] = nested;\n+                                current.add(new RecordPattern(rpOne.recordType(),\n+                                                                rpOne.fullComponentTypes(),\n+                                                                newNested));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (!current.equals(new HashSet<>(e.getValue()))) {\n+                Set<PatternDescription> result = new HashSet<>(patterns);\n+                result.removeAll(e.getValue());\n+                result.addAll(current);\n+                return result;\n+            }\n+        }\n+        return patterns;\n+    }\n+\n+    \/* In the set of patterns, find those for which, given:\n+     * $record($nested1, $nested2, ...)\n+     * all the $nestedX pattern cover the given record component,\n+     * and replace those with a simple binding pattern over $record.\n+     *\/\n+    private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+        var newPatterns = new HashSet<PatternDescription>();\n+        boolean modified = false;\n+        for (PatternDescription pd : patterns) {\n+            if (pd instanceof RecordPattern rpOne) {\n+                PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                if (reducedPattern != rpOne) {\n+                    newPatterns.add(reducedPattern);\n+                    modified = true;\n+                    continue;\n+                }\n+            }\n+            newPatterns.add(pd);\n+        }\n+        return modified ? newPatterns : patterns;\n+    }\n+\n+    private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n+        if (pattern instanceof RecordPattern rpOne) {\n+            Type[] componentType = rpOne.fullComponentTypes();\n+            \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+            if (componentType.length != rpOne.nested.length) {\n+                return pattern;\n+            }\n+            PatternDescription[] reducedNestedPatterns = null;\n+            boolean covered = true;\n+            for (int i = 0; i < componentType.length; i++) {\n+                PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n+                if (newNested != rpOne.nested[i]) {\n+                    if (reducedNestedPatterns == null) {\n+                        reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                    }\n+                    reducedNestedPatterns[i] = newNested;\n+                }\n+\n+                covered &= checkCovered(componentType[i], List.of(newNested));\n+            }\n+            if (covered) {\n+                return new BindingPattern(rpOne.recordType);\n+            } else if (reducedNestedPatterns != null) {\n+                return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+            }\n+        }\n+        return pattern;\n+    }\n+\n+    private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n+        Set<Symbol> existingBindings = patterns.stream()\n+                                               .filter(pd -> pd instanceof BindingPattern)\n+                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                               .collect(Collectors.toSet());\n+        Set<PatternDescription> result = new HashSet<>(patterns);\n+\n+        for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n+            PatternDescription pd = it.next();\n+            if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n+                it.remove();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n+        if (newNested instanceof BindingPattern bp) {\n+            Type seltype = types.erasure(componentType);\n+            Type pattype = types.erasure(bp.type);\n+\n+            return seltype.isPrimitive() ?\n+                    types.isUnconditionallyExact(seltype, pattype) :\n+                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n+        }\n+        return false;\n+    }\n+\n+    sealed interface PatternDescription { }\n+    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n+        if (pattern instanceof JCBindingPattern binding) {\n+            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n+                    ? selectorType : binding.type;\n+            return new BindingPattern(type);\n+        } else if (pattern instanceof JCRecordPattern record) {\n+            Type[] componentTypes;\n+\n+            if (!record.type.isErroneous()) {\n+                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                        .map(r -> types.memberType(record.type, r))\n+                        .toArray(s -> new Type[s]);\n+            }\n+            else {\n+                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n+            }\n+\n+            PatternDescription[] nestedDescriptions =\n+                    new PatternDescription[record.nested.size()];\n+            int i = 0;\n+            for (List<JCPattern> it = record.nested;\n+                 it.nonEmpty();\n+                 it = it.tail, i++) {\n+                Type componentType = i < componentTypes.length ? componentTypes[i]\n+                                                               : syms.errType;\n+                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n+            }\n+            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+        } else if (pattern instanceof JCAnyPattern) {\n+            return new BindingPattern(selectorType);\n+        } else {\n+            throw Assert.error();\n+        }\n+    }\n+    record BindingPattern(Type type) implements PatternDescription {\n+        @Override\n+        public int hashCode() {\n+            return type.tsym.hashCode();\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof BindingPattern other &&\n+                    type.tsym == other.type.tsym;\n+        }\n+        @Override\n+        public String toString() {\n+            return type.tsym + \" _\";\n+        }\n+    }\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return _hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof RecordPattern other &&\n+                    recordType.tsym == other.recordType.tsym &&\n+                    Arrays.equals(nested, other.nested);\n+        }\n+\n+        public int hashCode(int excludeComponent) {\n+            return hashCode(excludeComponent, recordType, nested);\n+        }\n+\n+        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+            int hash = 5;\n+            hash =  41 * hash + recordType.tsym.hashCode();\n+            for (int  i = 0; i < nested.length; i++) {\n+                if (i != excludeComponent) {\n+                    hash = 41 * hash + nested[i].hashCode();\n+                }\n+            }\n+            return hash;\n+        }\n+        @Override\n+        public String toString() {\n+            return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                    .map(pd -> pd.toString())\n+                    .collect(Collectors.joining(\", \")) + \")\";\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":604,"deletions":0,"binary":false,"changes":604,"status":"added"},{"patch":"@@ -30,3 +30,0 @@\n-import java.util.LinkedHashSet;\n-import java.util.Map;\n-import java.util.Map.Entry;\n@@ -34,1 +31,1 @@\n-import java.util.HashSet;\n+import java.util.LinkedHashSet;\n@@ -55,1 +52,0 @@\n-import com.sun.tools.javac.code.Kinds.Kind;\n@@ -57,1 +53,0 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -63,6 +58,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import static java.util.stream.Collectors.groupingBy;\n@@ -217,0 +206,1 @@\n+    private final ExhaustivenessComputer exhaustiveness;\n@@ -218,1 +208,0 @@\n-    private final Infer infer;\n@@ -342,1 +331,0 @@\n-        infer = Infer.instance(context);\n@@ -350,0 +338,1 @@\n+        exhaustiveness = ExhaustivenessComputer.instance(context);\n@@ -739,1 +728,1 @@\n-                tree.isExhaustive |= exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive |= exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -778,1 +767,1 @@\n-                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive = exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -788,423 +777,0 @@\n-        private boolean exhausts(JCExpression selector, List<JCCase> cases) {\n-            Set<PatternDescription> patternSet = new HashSet<>();\n-            Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n-            Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n-            for (JCCase c : cases) {\n-                if (!TreeInfo.unguardedCase(c))\n-                    continue;\n-\n-                for (var l : c.labels) {\n-                    if (l instanceof JCPatternCaseLabel patternLabel) {\n-                        for (Type component : components(selector.type)) {\n-                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n-                        }\n-                    } else if (l instanceof JCConstantCaseLabel constantLabel) {\n-                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n-                            Object value = ((JCLiteral) constantLabel.expr).value;\n-                            booleanLiterals.remove(value);\n-                        } else {\n-                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                            if (s != null && s.isEnum()) {\n-                                enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                    Set<Symbol> result = new HashSet<>();\n-                                    s.owner.members()\n-                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                            .forEach(result::add);\n-                                    return result;\n-                                }).remove(s);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n-                return true;\n-            }\n-\n-            for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n-                if (e.getValue().isEmpty()) {\n-                    patternSet.add(new BindingPattern(e.getKey().type));\n-                }\n-            }\n-            Set<PatternDescription> patterns = patternSet;\n-            boolean useHashes = true;\n-            try {\n-                boolean repeat = true;\n-                while (repeat) {\n-                    Set<PatternDescription> updatedPatterns;\n-                    updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                    repeat = !updatedPatterns.equals(patterns);\n-                    if (checkCovered(selector.type, patterns)) {\n-                        return true;\n-                    }\n-                    if (!repeat) {\n-                        \/\/there may be situation like:\n-                        \/\/class B permits S1, S2\n-                        \/\/patterns: R(S1, B), R(S2, S2)\n-                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n-                        \/\/but hashing in reduceNestedPatterns will not allow that\n-                        \/\/disable the use of hashing, and use subtyping in\n-                        \/\/reduceNestedPatterns to handle situations like this:\n-                        repeat = useHashes;\n-                        useHashes = false;\n-                    } else {\n-                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n-                        \/\/is enabled, as the hashing speeds up the process significantly:\n-                        useHashes = true;\n-                    }\n-                    patterns = updatedPatterns;\n-                }\n-                return checkCovered(selector.type, patterns);\n-            } catch (CompletionFailure cf) {\n-                chk.completionError(selector.pos(), cf);\n-                return true; \/\/error recovery\n-            }\n-        }\n-\n-        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n-            for (Type seltypeComponent : components(seltype)) {\n-                for (PatternDescription pd : patterns) {\n-                    if(isBpCovered(seltypeComponent, pd)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        private List<Type> components(Type seltype) {\n-            return switch (seltype.getTag()) {\n-                case CLASS -> {\n-                    if (seltype.isCompound()) {\n-                        if (seltype.isIntersection()) {\n-                            yield ((Type.IntersectionClassType) seltype).getComponents()\n-                                                                        .stream()\n-                                                                        .flatMap(t -> components(t).stream())\n-                                                                        .collect(List.collector());\n-                        }\n-                        yield List.nil();\n-                    }\n-                    yield List.of(types.erasure(seltype));\n-                }\n-                case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n-                default -> List.of(types.erasure(seltype));\n-            };\n-        }\n-\n-        \/* In a set of patterns, search for a sub-set of binding patterns that\n-         * in combination exhaust their sealed supertype. If such a sub-set\n-         * is found, it is removed, and replaced with a binding pattern\n-         * for the sealed supertype.\n-         *\/\n-        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-\n-            for (PatternDescription pdOne : patterns) {\n-                if (pdOne instanceof BindingPattern bpOne) {\n-                    Set<PatternDescription> toAdd = new HashSet<>();\n-\n-                    for (Type sup : types.directSupertypes(bpOne.type)) {\n-                        ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n-\n-                        clazz.complete();\n-\n-                        if (clazz.isSealed() && clazz.isAbstract() &&\n-                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n-                            !existingBindings.contains(clazz)) {\n-                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n-                            \/\/do not reduce to types unrelated to the selector type:\n-                            Type clazzErasure = types.erasure(clazz.type);\n-                            if (components(selectorType).stream()\n-                                                        .map(types::erasure)\n-                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n-                                continue;\n-                            }\n-\n-                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n-                                Type instantiated;\n-                                if (csym.type.allparams().isEmpty()) {\n-                                    instantiated = csym.type;\n-                                } else {\n-                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n-                                }\n-\n-                                return instantiated != null && types.isCastable(selectorType, instantiated);\n-                            });\n-\n-                            for (PatternDescription pdOther : patterns) {\n-                                if (pdOther instanceof BindingPattern bpOther) {\n-                                    Set<Symbol> currentPermittedSubTypes =\n-                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n-\n-                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n-                                        Symbol perm = it.next();\n-\n-                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n-                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                                types.erasure(perm.type))) {\n-                                                it.remove();\n-                                                continue PERMITTED;\n-                                            }\n-                                        }\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n-                                            it.remove();\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            if (permitted.isEmpty()) {\n-                                toAdd.add(new BindingPattern(clazz.type));\n-                            }\n-                        }\n-                    }\n-\n-                    if (!toAdd.isEmpty()) {\n-                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n-                        newPatterns.addAll(toAdd);\n-                        return newPatterns;\n-                    }\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n-            Set<Symbol> permitted = new HashSet<>();\n-            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n-\n-            while (permittedSubtypesClosure.nonEmpty()) {\n-                ClassSymbol current = permittedSubtypesClosure.head;\n-\n-                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n-\n-                current.complete();\n-\n-                if (current.isSealed() && current.isAbstract()) {\n-                    for (Type t : current.getPermittedSubclasses()) {\n-                        ClassSymbol csym = (ClassSymbol) t.tsym;\n-\n-                        if (accept.test(csym)) {\n-                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n-                            permitted.add(csym);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            return permitted;\n-        }\n-\n-        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n-            if (root instanceof ClassSymbol clazz) {\n-                return List.of(clazz);\n-            } else if (root instanceof TypeVariableSymbol tvar) {\n-                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n-                for (Type bound : tvar.getBounds()) {\n-                    result.appendList(baseClasses(bound.tsym));\n-                }\n-                return result.toList();\n-            } else {\n-                return List.nil();\n-            }\n-        }\n-\n-        \/* Among the set of patterns, find sub-set of patterns such:\n-         * $record($prefix$, $nested, $suffix$)\n-         * Where $record, $prefix$ and $suffix$ is the same for each pattern\n-         * in the set, and the patterns only differ in one \"column\" in\n-         * the $nested pattern.\n-         * Then, the set of $nested patterns is taken, and passed recursively\n-         * to reduceNestedPatterns and to reduceBindingPatterns, to\n-         * simplify the pattern. If that succeeds, the original found sub-set\n-         * of patterns is replaced with a new set of patterns of the form:\n-         * $record($prefix$, $resultOfReduction, $suffix$)\n-         *\n-         * useHashes: when true, patterns will be subject to exact equivalence;\n-         *            when false, two binding patterns will be considered equivalent\n-         *            if one of them is more generic than the other one;\n-         *            when false, the processing will be significantly slower,\n-         *            as pattern hashes cannot be used to speed up the matching process\n-         *\/\n-        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n-                                                             boolean useHashes) {\n-            \/* implementation note:\n-             * finding a sub-set of patterns that only differ in a single\n-             * column is time-consuming task, so this method speeds it up by:\n-             * - group the patterns by their record class\n-             * - for each column (nested pattern) do:\n-             * -- group patterns by their hash\n-             * -- in each such by-hash group, find sub-sets that only differ in\n-             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n-             *    on patterns in the chosen column, as described above\n-             *\/\n-            var groupByRecordClass =\n-                    patterns.stream()\n-                            .filter(pd -> pd instanceof RecordPattern)\n-                            .map(pd -> (RecordPattern) pd)\n-                            .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n-\n-            for (var e : groupByRecordClass.entrySet()) {\n-                int nestedPatternsCount = e.getKey().getRecordComponents().size();\n-                Set<RecordPattern> current = new HashSet<>(e.getValue());\n-\n-                for (int mismatchingCandidate = 0;\n-                     mismatchingCandidate < nestedPatternsCount;\n-                     mismatchingCandidate++) {\n-                    int mismatchingCandidateFin = mismatchingCandidate;\n-                    var groupEquivalenceCandidates =\n-                            current\n-                             .stream()\n-                             \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                             .filter(pd -> pd.nested.length == nestedPatternsCount)\n-                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n-                    for (var candidates : groupEquivalenceCandidates.values()) {\n-                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n-\n-                        for (int firstCandidate = 0;\n-                             firstCandidate < candidatesArr.length;\n-                             firstCandidate++) {\n-                            RecordPattern rpOne = candidatesArr[firstCandidate];\n-                            ListBuffer<RecordPattern> join = new ListBuffer<>();\n-\n-                            join.append(rpOne);\n-\n-                            NEXT_PATTERN: for (int nextCandidate = 0;\n-                                               nextCandidate < candidatesArr.length;\n-                                               nextCandidate++) {\n-                                if (firstCandidate == nextCandidate) {\n-                                    continue;\n-                                }\n-\n-                                RecordPattern rpOther = candidatesArr[nextCandidate];\n-                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                    for (int i = 0; i < rpOne.nested.length; i++) {\n-                                        if (i != mismatchingCandidate) {\n-                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                                if (useHashes ||\n-                                                    \/\/when not using hashes,\n-                                                    \/\/check if rpOne.nested[i] is\n-                                                    \/\/a subtype of rpOther.nested[i]:\n-                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                    join.append(rpOther);\n-                                }\n-                            }\n-\n-                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n-\n-                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                            updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n-\n-                            if (!nestedPatterns.equals(updatedPatterns)) {\n-                                if (useHashes) {\n-                                    current.removeAll(join);\n-                                }\n-\n-                                for (PatternDescription nested : updatedPatterns) {\n-                                    PatternDescription[] newNested =\n-                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    newNested[mismatchingCandidateFin] = nested;\n-                                    current.add(new RecordPattern(rpOne.recordType(),\n-                                                                    rpOne.fullComponentTypes(),\n-                                                                    newNested));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (!current.equals(new HashSet<>(e.getValue()))) {\n-                    Set<PatternDescription> result = new HashSet<>(patterns);\n-                    result.removeAll(e.getValue());\n-                    result.addAll(current);\n-                    return result;\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        \/* In the set of patterns, find those for which, given:\n-         * $record($nested1, $nested2, ...)\n-         * all the $nestedX pattern cover the given record component,\n-         * and replace those with a simple binding pattern over $record.\n-         *\/\n-        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n-            var newPatterns = new HashSet<PatternDescription>();\n-            boolean modified = false;\n-            for (PatternDescription pd : patterns) {\n-                if (pd instanceof RecordPattern rpOne) {\n-                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n-                    if (reducedPattern != rpOne) {\n-                        newPatterns.add(reducedPattern);\n-                        modified = true;\n-                        continue;\n-                    }\n-                }\n-                newPatterns.add(pd);\n-            }\n-            return modified ? newPatterns : patterns;\n-        }\n-\n-        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n-            if (pattern instanceof RecordPattern rpOne) {\n-                Type[] componentType = rpOne.fullComponentTypes();\n-                \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                if (componentType.length != rpOne.nested.length) {\n-                    return pattern;\n-                }\n-                PatternDescription[] reducedNestedPatterns = null;\n-                boolean covered = true;\n-                for (int i = 0; i < componentType.length; i++) {\n-                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n-                    if (newNested != rpOne.nested[i]) {\n-                        if (reducedNestedPatterns == null) {\n-                            reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                        }\n-                        reducedNestedPatterns[i] = newNested;\n-                    }\n-\n-                    covered &= checkCovered(componentType[i], List.of(newNested));\n-                }\n-                if (covered) {\n-                    return new BindingPattern(rpOne.recordType);\n-                } else if (reducedNestedPatterns != null) {\n-                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n-                }\n-            }\n-            return pattern;\n-        }\n-\n-        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-            Set<PatternDescription> result = new HashSet<>(patterns);\n-\n-            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n-                PatternDescription pd = it.next();\n-                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n-                    it.remove();\n-                }\n-            }\n-\n-            return result;\n-        }\n-\n@@ -1356,12 +922,0 @@\n-    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n-        if (newNested instanceof BindingPattern bp) {\n-            Type seltype = types.erasure(componentType);\n-            Type pattype = types.erasure(bp.type);\n-\n-            return seltype.isPrimitive() ?\n-                    types.isUnconditionallyExact(seltype, pattype) :\n-                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n-        }\n-        return false;\n-    }\n-\n@@ -3551,89 +3105,0 @@\n-    sealed interface PatternDescription { }\n-    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n-        if (pattern instanceof JCBindingPattern binding) {\n-            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n-                    ? selectorType : binding.type;\n-            return new BindingPattern(type);\n-        } else if (pattern instanceof JCRecordPattern record) {\n-            Type[] componentTypes;\n-\n-            if (!record.type.isErroneous()) {\n-                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                        .map(r -> types.memberType(record.type, r))\n-                        .toArray(s -> new Type[s]);\n-            }\n-            else {\n-                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n-            }\n-\n-            PatternDescription[] nestedDescriptions =\n-                    new PatternDescription[record.nested.size()];\n-            int i = 0;\n-            for (List<JCPattern> it = record.nested;\n-                 it.nonEmpty();\n-                 it = it.tail, i++) {\n-                Type componentType = i < componentTypes.length ? componentTypes[i]\n-                                                               : syms.errType;\n-                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n-            }\n-            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n-        } else if (pattern instanceof JCAnyPattern) {\n-            return new BindingPattern(selectorType);\n-        } else {\n-            throw Assert.error();\n-        }\n-    }\n-    record BindingPattern(Type type) implements PatternDescription {\n-        @Override\n-        public int hashCode() {\n-            return type.tsym.hashCode();\n-        }\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof BindingPattern other &&\n-                    type.tsym == other.type.tsym;\n-        }\n-        @Override\n-        public String toString() {\n-            return type.tsym + \" _\";\n-        }\n-    }\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n-\n-        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return _hashCode;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof RecordPattern other &&\n-                    recordType.tsym == other.recordType.tsym &&\n-                    Arrays.equals(nested, other.nested);\n-        }\n-\n-        public int hashCode(int excludeComponent) {\n-            return hashCode(excludeComponent, recordType, nested);\n-        }\n-\n-        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n-            int hash = 5;\n-            hash =  41 * hash + recordType.tsym.hashCode();\n-            for (int  i = 0; i < nested.length; i++) {\n-                if (i != excludeComponent) {\n-                    hash = 41 * hash + nested[i].hashCode();\n-                }\n-            }\n-            return hash;\n-        }\n-        @Override\n-        public String toString() {\n-            return recordType.tsym + \"(\" + Arrays.stream(nested)\n-                    .map(pd -> pd.toString())\n-                    .collect(Collectors.joining(\", \")) + \")\";\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":5,"deletions":540,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-    cannot reference {0} before constructor has been called\n+    reference to {0} may only appear after an explicit constructor invocation\n@@ -404,1 +404,1 @@\n-    cannot assign initialized field ''{0}'' before constructor has been called\n+    assignment to initialized field ''{0}'' may only appear after an explicit constructor invocation\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -183,0 +183,2 @@\n+  public boolean isContinuationStub()   { return getName().equals(\"StubRoutines (continuation stubs)\"); }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+\n+\n+public class ContinuationEntry extends VMObject {\n+    private static long size;\n+    private static Address returnPC;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+        Type type = db.lookupType(\"ContinuationEntry\");\n+        size = type.getSize();\n+        returnPC = type.getAddressField(\"_return_pc\").getValue();\n+    }\n+\n+    public ContinuationEntry(Address addr) {\n+        super(addr);\n+    }\n+\n+    public Address getEntryPC() {\n+        return returnPC;\n+    }\n+\n+    public Address getEntrySP(){\n+        return this.getAddress();\n+    }\n+\n+    public Address getEntryFP(){\n+        return this.getAddress().addOffsetTo(size);\n+    }\n+\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ContinuationEntry.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -50,0 +50,1 @@\n+  private static AddressField  contEntryField;\n@@ -98,0 +99,1 @@\n+    contEntryField    = type.getAddressField(\"_cont_entry\");\n@@ -343,0 +345,4 @@\n+  public ContinuationEntry getContEntry() {\n+      return VMObjectFactory.newObject(ContinuationEntry.class, contEntryField.getValue(addr));\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -273,1 +273,7 @@\n-      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n@@ -359,0 +365,10 @@\n+  private Frame senderForContinuationStub(AARCH64RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address senderSP = contEntry.getEntrySP();\n+    Address senderPC = contEntry.getEntryPC();\n+    Address senderFP = contEntry.getEntryFP();\n+\n+    return new AARCH64Frame(senderSP, senderFP, senderPC);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -261,1 +261,7 @@\n-      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n@@ -334,0 +340,9 @@\n+  private Frame senderForContinuationStub(PPC64RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address sp = contEntry.getEntrySP();\n+    Address pc = contEntry.getEntryPC();\n+    Address fp = contEntry.getEntryFP();\n+\n+    return new PPC64Frame(sp, fp, pc);\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -265,1 +265,7 @@\n-      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n@@ -351,0 +357,10 @@\n+  private Frame senderForContinuationStub(RISCV64RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address senderSP = contEntry.getEntrySP();\n+    Address senderPC = contEntry.getEntryPC();\n+    Address senderFP = contEntry.getEntryFP();\n+\n+    return new RISCV64Frame(senderSP, senderFP, senderPC);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -273,1 +273,7 @@\n-      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n@@ -359,0 +365,10 @@\n+  private Frame senderForContinuationStub(X86RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address senderSP = contEntry.getEntrySP();\n+    Address senderPC = contEntry.getEntryPC();\n+    Address senderFP = contEntry.getEntryFP();\n+\n+    return new X86Frame(senderSP, senderFP, senderPC);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -334,0 +334,1 @@\n+        copyResource(DocPaths.SORT_A_Z_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.SORT_A_Z_SVG), true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    static final HtmlId TOC_ORDER_TOGGLE = HtmlId.of(\"toc-lexical-order-toggle\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,0 +115,10 @@\n+\n+            header.add(Entity.NO_BREAK_SPACE)\n+                    .add(HtmlTree.BUTTON(HtmlStyles.tocSortToggle)\n+                            .setId(HtmlIds.TOC_ORDER_TOGGLE)\n+                            .add(HtmlTree.IMG(writer.pathToRoot.resolve(DocPaths.RESOURCE_FILES)\n+                                            .resolve(DocPaths.SORT_A_Z_SVG),\n+                                    writer.resources.getText(\"doclet.sort_table_of_contents\")\n+                            ))\n+                    );\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TableOfContents.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -167,0 +167,10 @@\n+    \/**\n+     * The class used for lexical order toggle in the table of contents.\n+     *\/\n+    tocSortToggle,\n+\n+     \/**\n+     * The class used to indicate the state of the lexical sort toggle.\n+     *\/\n+    tocSortIsActive,\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyles.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,8 @@\n+const sortLexicalLabel = \"##REPLACE:doclet.Sort_lexicographically##\";\n+const sortSourceLabel  = \"##REPLACE:doclet.Sort_by_source_order##\";\n+const TOC_ALPHA  = \"alpha\";\n+const TOC_SOURCE = \"source\";\n+var origOlOrder = new Map();\n+var origContainerOrder = new Map();\n+var snapshotted = false;\n+\n@@ -412,0 +420,3 @@\n+\n+    snapshotAllOnce();\n+\n@@ -643,0 +654,162 @@\n+\n+    function allTocNavs() {\n+        return Array.from(document.querySelectorAll(\"nav.toc\"));\n+    }\n+\n+    function nestedTocLists(scope) {\n+        const listsToSort = [];\n+        const sectionLinks = scope.querySelectorAll(\"ol.toc-list > li > a\");\n+\n+        sectionLinks.forEach(function(link) {\n+            const href = link.getAttribute(\"href\");\n+            if (href === \"#constructor-detail\" || href === \"#method-detail\"\n+                || href === \"#field-detail\" || href === \"#annotation-interface-element-detail\"\n+                || href === \"#enum-constant-detail\" || href === \"#property-detail\") {\n+                const memberList = link.nextElementSibling;\n+                if (memberList && memberList.tagName === 'OL') {\n+                    listsToSort.push(memberList);\n+                }\n+            }\n+        });\n+\n+        return listsToSort;\n+    }\n+\n+    function textForLi(li) {\n+        return li.querySelector(\":scope > a\").textContent.trim();\n+    }\n+\n+    function alphaCompare(a, b) {\n+        return textForLi(a).localeCompare(textForLi(b), undefined, {\n+            numeric: true,\n+            sensitivity: \"base\"\n+        });\n+    }\n+\n+    function snapshotTocOnce(nav){\n+        nestedTocLists(nav).forEach(function(ol){\n+            if (!origOlOrder.has(ol)) origOlOrder.set(ol, Array.from(ol.children));\n+        });\n+    }\n+    function restoreToc(nav){\n+        nestedTocLists(nav).forEach(function(ol){\n+            var orig = origOlOrder.get(ol);\n+            if (orig) orig.forEach(function(li){ ol.appendChild(li); });\n+        });\n+    }\n+    function sortTocAlpha(nav){\n+        nestedTocLists(nav).forEach(function(ol){\n+            var lis = Array.from(ol.children);\n+            if (lis.length < 2) return;\n+            lis.slice().sort(alphaCompare).forEach(function(li){ ol.appendChild(li); });\n+        });\n+    }\n+\n+    function snapshotAllOnce() {\n+        if (snapshotted) return;\n+        allTocNavs().forEach(snapshotTocOnce);\n+        snapshotted = true;\n+    }\n+\n+    function restoreAllMemberContainers(){\n+        origContainerOrder.forEach(function(kids, container){\n+            kids.forEach(function(ch){ container.appendChild(ch); });\n+        });\n+    }\n+\n+    function reorderMemberDetailsAlpha() {\n+        var sidebarNav = document.querySelector(\".main-grid nav.toc\");\n+        var mainRoot = document.querySelector(\".main-grid main\");\n+        if (!sidebarNav || !mainRoot) return;\n+\n+        var containers = Array.from(\n+            mainRoot.querySelectorAll(\"ul.member-list\")\n+        );\n+\n+        containers.forEach(function(container) {\n+            var links = Array.from(sidebarNav.querySelectorAll(\"a[href^='#']\")).filter(function(a) {\n+                var id = a.getAttribute(\"href\").slice(1);\n+                if (!id) return false;\n+                var target = document.getElementById(decodeURI(id));\n+                return target && container.contains(target);\n+            });\n+            if (links.length < 2) return;\n+\n+            var items = links.map(function(a) {\n+                var id = a.getAttribute(\"href\").slice(1);\n+                var target = document.getElementById(decodeURI(id));\n+                if (!target) return null;\n+                var block = target.closest(\"section.detail, div.detail\") || target;\n+                var li = block.closest(\"li\");\n+                if (li.parentElement !== container) return null;\n+                return {\n+                    node: li,\n+                    text: (a.textContent || \"\").trim()\n+                };\n+            }).filter(Boolean);\n+\n+            if (items.length < 2) return;\n+\n+            if (!origContainerOrder.has(container)) {\n+                origContainerOrder.set(container, Array.from(container.children));\n+            }\n+\n+            items.slice()\n+                .sort(function(x, y) {\n+                    return x.text.localeCompare(y.text, undefined, {\n+                        numeric: true,\n+                        sensitivity: \"base\"\n+                    });\n+                })\n+                .forEach(function(it) {\n+                    container.appendChild(it.node);\n+                });\n+        });\n+    }\n+\n+    function updateToggleButtons(order){\n+        const next = (order === TOC_ALPHA) ? sortSourceLabel : sortLexicalLabel;\n+        document.querySelectorAll(\".toc-sort-toggle\").forEach(function(btn){\n+            btn.setAttribute(\"aria-label\", next);\n+            btn.setAttribute(\"title\", next);\n+            btn.setAttribute(\"aria-pressed\", order === TOC_ALPHA);\n+\n+            if (order === TOC_ALPHA) {\n+                btn.classList.add(\"toc-sort-is-active\");\n+            } else {\n+                btn.classList.remove(\"toc-sort-is-active\");\n+            }\n+\n+            var img = btn.querySelector(\"img\");\n+            if (img) img.alt = next;\n+        });\n+    }\n+\n+    var tocOrder = TOC_SOURCE;\n+    updateToggleButtons(tocOrder);\n+\n+    function applyAlpha(){\n+        snapshotAllOnce();\n+        reorderMemberDetailsAlpha();\n+        allTocNavs().forEach(sortTocAlpha);\n+        initSectionData(); handleScroll();\n+        updateToggleButtons(TOC_ALPHA);\n+        tocOrder = TOC_ALPHA;\n+    }\n+\n+    function applySource(){\n+        snapshotAllOnce();\n+        restoreAllMemberContainers();\n+        allTocNavs().forEach(restoreToc);\n+        initSectionData(); handleScroll();\n+        updateToggleButtons(TOC_SOURCE);\n+        tocOrder = TOC_SOURCE;\n+    }\n+\n+    document.querySelectorAll(\".toc-sort-toggle\").forEach(function(btn) {\n+      btn.addEventListener(\"click\", function() {\n+          if (tocOrder === TOC_SOURCE) applyAlpha(); else applySource();\n+          if (typeof btn.blur === \"function\") btn.blur();\n+      });\n+    });\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":173,"deletions":0,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 32 32\">\n+<line fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" x1=\"23\" y1=\"26.1\" x2=\"23\" y2=\"5\"\/>\n+    <polyline fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" points=\"18.7,21.8 23,26.1 27.3,21.8 \"\/>\n+    <polyline fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" points=\"12,15 12,14 9.1,6 8.9,6 6,14 6,15 \"\/>\n+    <line fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" x1=\"6\" y1=\"12\" x2=\"12\" y2=\"12\"\/>\n+    <polyline fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" points=\"5,18 12,18 12,19 6,25 6,26 13,26 \"\/>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/sort-a-z.svg","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -696,1 +696,0 @@\n-    border: none;\n@@ -700,0 +699,1 @@\n+    border: 1px solid transparent;\n@@ -1904,0 +1904,5 @@\n+    .top-nav nav.toc .toc-sort-toggle {\n+        background: transparent;\n+        border: 0;\n+        margin-left: 4px;\n+    }\n@@ -1960,0 +1965,27 @@\n+\n+nav.toc div.toc-header input.filter-input {\n+    flex: 1 1 auto;\n+    min-width: 0;\n+}\n+\n+nav.toc div.toc-header .toc-sort-toggle {\n+    flex: 0 0 auto;\n+    position: static;\n+    display: inline-flex;\n+    align-items: center;\n+    padding: .5em;\n+    cursor: pointer;\n+}\n+\n+nav.toc div.toc-header .toc-sort-toggle > img {\n+    width: 22px;\n+    height: 22px;\n+    vertical-align: middle;\n+    filter: var(--icon-filter);\n+}\n+\n+nav.toc div.toc-header .toc-sort-toggle.toc-sort-is-active {\n+    background-color: var(--toc-highlight-color);\n+    border-radius: 4px;\n+}\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+doclet.Sort_lexicographically=Sort member details lexicographically\n+doclet.Sort_by_source_order=Sort member details by source order\n@@ -259,0 +261,1 @@\n+doclet.sort_table_of_contents=Sort member details in lexicographical order\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,0 +118,3 @@\n+    \/** The name of the table of contents toggle icon file. *\/\n+    public static final DocPath SORT_A_Z_SVG = DocPath.create(\"sort-a-z.svg\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -707,1 +707,1 @@\n-:   Dump threads, with stack traces, to a file in plain text or JSON format.\n+:   Dump all threads, with stack traces, to a file in plain text or JSON format.\n@@ -726,1 +726,2 @@\n-:   Prints all threads with stacktraces.\n+:   Print all platform threads, and mounted virtual threads, with stack traces.\n+    The Thread.dump_to_file command will print all threads to a file.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.md","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.net.URI;\n@@ -136,1 +137,18 @@\n-        setParameters(new JMXServiceURL(url), userName, password);\n+        JMXServiceURL jmxServiceURL = new JMXServiceURL(url);\n+        setParameters(jmxServiceURL, userName, password);\n+        if (\"rmi\".equals(jmxServiceURL.getProtocol())) {\n+            String path = jmxServiceURL.getURLPath();\n+            if (path.startsWith(\"\/jndi\/\")) {\n+                int end = path.indexOf(';');\n+                if (end < 0) end = path.length();\n+                String registryURIStr = path.substring(6, end);\n+                URI registryURI = URI.create(registryURIStr);\n+                if (\"rmi\".equals(registryURI.getScheme())\n+                        && \"\/jmxrmi\".equals(registryURI.getPath())) {\n+                    this.registryHostName = registryURI.getHost();\n+                    this.registryPort = registryURI.getPort();\n+                    this.vmConnector = true;\n+                    checkSslConfig();\n+                }\n+            }\n+        }\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/ProxyClient.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -893,2 +893,0 @@\n- \"debugflags=flags             debug flags (bitmask)           none\\n\"\n- \"                               USE_ITERATE_THROUGH_HEAP 0x01\\n\"\n@@ -1195,7 +1193,0 @@\n-        } else if (strcmp(buf, \"debugflags\") == 0) {\n-            \/*LINTED*\/\n-            if (!get_tok(&str, current, (int)(end - current), ',')) {\n-                goto syntax_error;\n-            }\n-            \/*LINTED*\/\n-            gdata->debugflags = (unsigned)strtol(current, NULL, 0);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2732,4 +2732,0 @@\n-\/* Two different cbObjectCounter's, one for FollowReferences, one for\n- *    IterateThroughHeap. Pick a card, any card.\n- *\/\n-\n@@ -2797,32 +2793,0 @@\n-\/* Callback for instance count heap traversal (heap_iteration_callback) *\/\n-static jint JNICALL\n-cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,\n-                        void* user_data)\n-{\n-    ClassCountData  *data;\n-    int              index;\n-\n-    \/* Check data structure *\/\n-    data = (ClassCountData*)user_data;\n-    if (data == NULL) {\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Classes with no tag should be filtered out. *\/\n-    if ( class_tag == (jlong)0 ) {\n-        data->error = AGENT_ERROR_INTERNAL;\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Class tag is actually an index into data arrays *\/\n-    index = CLASSTAG2INDEX(class_tag);\n-    if (index < 0 || index >= data->classCount) {\n-        data->error = AGENT_ERROR_ILLEGAL_ARGUMENT;\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Bump instance count on this class *\/\n-    data->counts[index]++;\n-    return JVMTI_VISIT_OBJECTS;\n-}\n-\n@@ -2881,39 +2845,13 @@\n-        \/* Check debug flags to see how to do this. *\/\n-        if ( (gdata->debugflags & USE_ITERATE_THROUGH_HEAP) == 0 ) {\n-\n-            \/* Using FollowReferences only gives us live objects, but we\n-             *   need to tag the objects to avoid counting them twice since\n-             *   the callback is per reference.\n-             *   The jclass objects have been tagged with their index in the\n-             *   supplied list, and that tag may flip to negative if it\n-             *   is also an object of interest.\n-             *   All other objects being counted that weren't in the\n-             *   supplied classes list will have a negative classCount\n-             *   tag value. So all objects counted will have negative tags.\n-             *   If the absolute tag value is an index in the supplied\n-             *   list, then it's one of the supplied classes.\n-             *\/\n-            data.negObjTag = -INDEX2CLASSTAG(classCount);\n-\n-            \/* Setup callbacks, only using object reference callback *\/\n-            heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n-\n-            \/* Follow references, no initiating object, tagged classes only *\/\n-            error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n-                          (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n-                           NULL, NULL, &heap_callbacks, &data);\n-\n-        } else {\n-\n-            \/* Using IterateThroughHeap means that we will visit each object\n-             *   once, so no special tag tricks here. Just simple counting.\n-             *   However in this case the object might not be live, so we do\n-             *   a GC beforehand to make sure we minimize this.\n-             *\/\n-\n-            \/* FIXUP: Need some kind of trigger here to avoid excessive GC's? *\/\n-            error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);\n-            if ( error != JVMTI_ERROR_NONE ) {\n-\n-                \/* Setup callbacks, just need object callback *\/\n-                heap_callbacks.heap_iteration_callback = &cbObjectCounter;\n+        \/* Using FollowReferences only gives us live objects, but we\n+         *   need to tag the objects to avoid counting them twice since\n+         *   the callback is per reference.\n+         *   The jclass objects have been tagged with their index in the\n+         *   supplied list, and that tag may flip to negative if it\n+         *   is also an object of interest.\n+         *   All other objects being counted that weren't in the\n+         *   supplied classes list will have a negative classCount\n+         *   tag value. So all objects counted will have negative tags.\n+         *   If the absolute tag value is an index in the supplied\n+         *   list, then it's one of the supplied classes.\n+         *\/\n+        data.negObjTag = -INDEX2CLASSTAG(classCount);\n@@ -2921,4 +2859,2 @@\n-                \/* Iterate through entire heap, tagged classes only *\/\n-                error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)\n-                              (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n-                               NULL, &heap_callbacks, &data);\n+        \/* Setup callbacks, only using object reference callback *\/\n+        heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n@@ -2926,2 +2862,4 @@\n-            }\n-        }\n+        \/* Follow references, no initiating object, tagged classes only *\/\n+        error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n+                      (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n+                       NULL, NULL, &heap_callbacks, &data);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":20,"deletions":82,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,6 +95,0 @@\n-    \/* Debug flags (bit mask) *\/\n-    int      debugflags;\n-\n-    \/* Possible debug flags *\/\n-    #define USE_ITERATE_THROUGH_HEAP 0X001\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -260,0 +260,5 @@\n+            sortedCache[i] = null;\n+        }\n+        \/\/ Shrink array\n+        if (index > 100_000 && 4 * index < sortedCache.length) {\n+            sortedCache = new RecordedEvent[2 * index];\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -130,0 +130,4 @@\n+            if (index > 100_000 && 4 * index < cacheSorted.length) {\n+                cacheSorted = new RecordedEvent[2 * index];\n+            }\n+            onFlush();\n@@ -139,0 +143,1 @@\n+            cacheSorted[i] = null;\n@@ -140,1 +145,0 @@\n-        onFlush();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-    private ByteOrder byteOrder;\n-    private ImageStringsWriter strings;\n+    private final ByteOrder byteOrder;\n+    private final ImageStringsWriter strings;\n@@ -44,10 +44,6 @@\n-    private List<ImageLocationWriter> input;\n-    private ImageStream headerStream;\n-    private ImageStream redirectStream;\n-    private ImageStream locationOffsetStream;\n-    private ImageStream locationStream;\n-    private ImageStream allIndexStream;\n-\n-    public BasicImageWriter() {\n-        this(ByteOrder.nativeOrder());\n-    }\n+    private final List<ImageLocationWriter> input;\n+    private final ImageStream headerStream;\n+    private final ImageStream redirectStream;\n+    private final ImageStream locationOffsetStream;\n+    private final ImageStream locationStream;\n+    private final ImageStream allIndexStream;\n@@ -78,2 +74,6 @@\n-    public void addLocation(String fullname, long contentOffset,\n-            long compressedSize, long uncompressedSize) {\n+    public void addLocation(\n+            String fullname,\n+            long contentOffset,\n+            long compressedSize,\n+            long uncompressedSize,\n+            int previewFlags) {\n@@ -82,1 +82,1 @@\n-                        contentOffset, compressedSize, uncompressedSize);\n+                        contentOffset, compressedSize, uncompressedSize, previewFlags);\n@@ -91,4 +91,0 @@\n-    int getLocationsCount() {\n-        return input.size();\n-    }\n-\n@@ -177,12 +173,0 @@\n-\n-    ImageLocationWriter find(String key) {\n-        int index = redirect[ImageStringsReader.hashCode(key) % length];\n-\n-        if (index < 0) {\n-            index = -index - 1;\n-        } else {\n-            index = ImageStringsReader.hashCode(key, index) % length;\n-        }\n-\n-        return locations[index];\n-    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/BasicImageWriter.java","additions":16,"deletions":32,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import jdk.internal.jimage.ImageLocation;\n@@ -230,25 +231,2 @@\n-        ResourcePool resultResources;\n-        try {\n-            resultResources = pluginSupport.visitResources(allContent);\n-            if (generateRuntimeImage) {\n-                \/\/ Keep track of non-modules resources for linking from a run-time image\n-                resultResources = addNonClassResourcesTrackFiles(resultResources,\n-                                                                 writer);\n-                \/\/ Generate the diff between the input resources from packaged\n-                \/\/ modules in 'allContent' to the plugin- or otherwise\n-                \/\/ generated-content in 'resultResources'\n-                resultResources = addResourceDiffFiles(allContent.resourcePool(),\n-                                                       resultResources,\n-                                                       writer);\n-            }\n-        } catch (PluginException pe) {\n-            if (JlinkTask.DEBUG) {\n-                pe.printStackTrace();\n-            }\n-            throw pe;\n-        } catch (Exception ex) {\n-            if (JlinkTask.DEBUG) {\n-                ex.printStackTrace();\n-            }\n-            throw new IOException(ex);\n-        }\n+        ResourcePool resultResources =\n+                getResourcePool(allContent, writer, pluginSupport, generateRuntimeImage);\n@@ -285,0 +263,2 @@\n+                int locFlags = ImageLocation.getFlags(\n+                        res.path(), p -> resultResources.findEntry(p).isPresent());\n@@ -286,1 +266,1 @@\n-                writer.addLocation(path, offset[0], compressedSize, uncompressedSize);\n+                writer.addLocation(path, offset[0], compressedSize, uncompressedSize, locFlags);\n@@ -310,0 +290,34 @@\n+    private static ResourcePool getResourcePool(\n+            ResourcePoolManager allContent,\n+            BasicImageWriter writer,\n+            ImagePluginStack pluginSupport,\n+            boolean generateRuntimeImage)\n+            throws IOException {\n+        ResourcePool resultResources;\n+        try {\n+            resultResources = pluginSupport.visitResources(allContent);\n+            if (generateRuntimeImage) {\n+                \/\/ Keep track of non-modules resources for linking from a run-time image\n+                resultResources = addNonClassResourcesTrackFiles(resultResources,\n+                        writer);\n+                \/\/ Generate the diff between the input resources from packaged\n+                \/\/ modules in 'allContent' to the plugin- or otherwise\n+                \/\/ generated-content in 'resultResources'\n+                resultResources = addResourceDiffFiles(allContent.resourcePool(),\n+                        resultResources,\n+                        writer);\n+            }\n+        } catch (PluginException pe) {\n+            if (JlinkTask.DEBUG) {\n+                pe.printStackTrace();\n+            }\n+            throw pe;\n+        } catch (Exception ex) {\n+            if (JlinkTask.DEBUG) {\n+                ex.printStackTrace();\n+            }\n+            throw new IOException(ex);\n+        }\n+        return resultResources;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":41,"deletions":27,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,2 @@\n-    static ImageLocationWriter newLocation(String fullName,\n+    static ImageLocationWriter newLocation(\n+            String fullName,\n@@ -58,1 +59,4 @@\n-            long contentOffset, long compressedSize, long uncompressedSize) {\n+            long contentOffset,\n+            long compressedSize,\n+            long uncompressedSize,\n+            int previewFlags) {\n@@ -93,7 +97,8 @@\n-               .addAttribute(ATTRIBUTE_MODULE, moduleName)\n-               .addAttribute(ATTRIBUTE_PARENT, parentName)\n-               .addAttribute(ATTRIBUTE_BASE, baseName)\n-               .addAttribute(ATTRIBUTE_EXTENSION, extensionName)\n-               .addAttribute(ATTRIBUTE_OFFSET, contentOffset)\n-               .addAttribute(ATTRIBUTE_COMPRESSED, compressedSize)\n-               .addAttribute(ATTRIBUTE_UNCOMPRESSED, uncompressedSize);\n+                .addAttribute(ATTRIBUTE_MODULE, moduleName)\n+                .addAttribute(ATTRIBUTE_PARENT, parentName)\n+                .addAttribute(ATTRIBUTE_BASE, baseName)\n+                .addAttribute(ATTRIBUTE_EXTENSION, extensionName)\n+                .addAttribute(ATTRIBUTE_OFFSET, contentOffset)\n+                .addAttribute(ATTRIBUTE_COMPRESSED, compressedSize)\n+                .addAttribute(ATTRIBUTE_UNCOMPRESSED, uncompressedSize)\n+                .addAttribute(ATTRIBUTE_PREVIEW_FLAGS, previewFlags);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageLocationWriter.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.internal.jimage.ImageLocation;\n+import jdk.internal.jimage.ModuleReference;\n+\n@@ -32,0 +35,1 @@\n+import java.util.Comparator;\n@@ -33,0 +37,1 @@\n+import java.util.HashSet;\n@@ -38,1 +43,1 @@\n-import java.util.TreeSet;\n+import java.util.stream.Collectors;\n@@ -42,1 +47,0 @@\n- *\n@@ -47,1 +51,1 @@\n-        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+        return path.startsWith(\"\/packages\/\") || path.startsWith(\"\/modules\/\");\n@@ -53,1 +57,2 @@\n-    private static class Node {\n+    \/\/ Visible for testing only.\n+    static class Node {\n@@ -69,0 +74,8 @@\n+        private void setLocation(ImageLocationWriter loc) {\n+            \/\/ This *can* be called more than once, but only with the same instance.\n+            if (this.loc != null && loc != this.loc) {\n+                throw new IllegalStateException(\"Cannot add different locations: \" + name);\n+            }\n+            this.loc = Objects.requireNonNull(loc);\n+        }\n+\n@@ -98,1 +111,2 @@\n-    private static final class ResourceNode extends Node {\n+    \/\/ Visible for testing only.\n+    static final class ResourceNode extends Node {\n@@ -105,9 +119,22 @@\n-    private static class PackageNode extends Node {\n-        \/**\n-         * A reference to a package. Empty packages can be located inside one or\n-         * more modules. A package with classes exist in only one module.\n-         *\/\n-        static final class PackageReference {\n-\n-            private final String name;\n-            private final boolean isEmpty;\n+    \/**\n+     * A 2nd level package directory, {@code \"\/packages\/<package-name>\"}.\n+     *\n+     * <p>While package paths can exist within many modules, for each package\n+     * there is at most one module in which that package has resources.\n+     *\n+     * <p>For example, the package path {@code java\/util} exists in both the\n+     * {@code java.base} and {@code java.logging} modules. This means both\n+     * {@code \"\/packages\/java.util\/java.base\"} and\n+     * {@code \"\/packages\/java.util\/java.logging\"} will exist, but only\n+     * {@code \"java.base\"} entry will be marked as having content.\n+     *\n+     * <p>When processing module references in non-preview mode, entries marked\n+     * as {@link ModuleReference#isPreviewOnly() preview-only} must be ignored.\n+     *\n+     * <p>If all entries in a package are preview-only, then the package's flags\n+     * have {@link ImageLocation#FLAGS_IS_PREVIEW_ONLY FLAGS_IS_PREVIEW_ONLY}\n+     * set, and the entire package must be ignored.\n+     *\/\n+    \/\/ Visible for testing only.\n+    static final class PackageNode extends Node {\n+        private final List<ModuleReference> moduleReferences;\n@@ -115,3 +142,4 @@\n-            PackageReference(String name, boolean isEmpty) {\n-                this.name = Objects.requireNonNull(name);\n-                this.isEmpty = isEmpty;\n+        PackageNode(String name, List<ModuleReference> moduleReferences, Node parent) {\n+            super(name, parent);\n+            if (moduleReferences.isEmpty()) {\n+                throw new IllegalStateException(\"Package must be associated with modules: \" + name);\n@@ -119,4 +147,2 @@\n-\n-            @Override\n-            public String toString() {\n-                return name + \"[empty:\" + isEmpty + \"]\";\n+            if (moduleReferences.stream().filter(ModuleReference::hasResources).count() > 1) {\n+                throw new IllegalStateException(\"Multiple modules contain non-empty package: \" + name);\n@@ -124,0 +150,1 @@\n+            this.moduleReferences = Collections.unmodifiableList(moduleReferences);\n@@ -126,11 +153,2 @@\n-        private final Map<String, PackageReference> references = new TreeMap<>();\n-\n-        PackageNode(String name, Node parent) {\n-            super(name, parent);\n-        }\n-\n-        private void addReference(String name, boolean isEmpty) {\n-            PackageReference ref = references.get(name);\n-            if (ref == null || ref.isEmpty) {\n-                references.put(name, new PackageReference(name, isEmpty));\n-            }\n+        List<ModuleReference> getModuleReferences() {\n+            return moduleReferences;\n@@ -138,0 +156,1 @@\n+    }\n@@ -139,12 +158,5 @@\n-        private void validate() {\n-            boolean exists = false;\n-            for (PackageReference ref : references.values()) {\n-                if (!ref.isEmpty) {\n-                    if (exists) {\n-                        throw new RuntimeException(\"Multiple modules to contain package \"\n-                                + getName());\n-                    } else {\n-                        exists = true;\n-                    }\n-                }\n-            }\n+    \/\/ Not serialized, and never stored in any field of any class that is.\n+    @SuppressWarnings(\"serial\")\n+    private static final class InvalidTreeException extends Exception {\n+        public InvalidTreeException(Node badNode) {\n+            super(\"Resources tree, invalid data structure, skipping: \" + badNode.getPath());\n@@ -152,0 +164,3 @@\n+        \/\/ Exception only used for program flow, not debugging.\n+        @Override\n+        public Throwable fillInStackTrace() {return this;}\n@@ -157,1 +172,3 @@\n-    private static final class Tree {\n+    \/\/ Visible for testing only.\n+    static final class Tree {\n+        private static final String PREVIEW_PREFIX = \"META-INF\/preview\/\";\n@@ -162,2 +179,1 @@\n-        private Node modules;\n-        private Node packages;\n+        private Node packagesRoot;\n@@ -165,2 +181,4 @@\n-        private Tree(List<String> paths) {\n-            this.paths = paths;\n+        \/\/ Visible for testing only.\n+        Tree(List<String> paths) {\n+            this.paths = paths.stream().sorted(Comparator.reverseOrder()).toList();\n+            \/\/ Root node is not added to the directAccess map.\n@@ -172,21 +190,15 @@\n-            modules = new Node(\"modules\", root);\n-            directAccess.put(modules.getPath(), modules);\n-\n-            Map<String, Set<String>> moduleToPackage = new TreeMap<>();\n-            Map<String, Set<String>> packageToModule = new TreeMap<>();\n-\n-            for (String p : paths) {\n-                if (!p.startsWith(\"\/\")) {\n-                    continue;\n-                }\n-                String[] split = p.split(\"\/\");\n-                \/\/ minimum length is 3 items: \/<mod>\/<pkg>\n-                if (split.length < 3) {\n-                    System.err.println(\"Resources tree, invalid data structure, \"\n-                            + \"skipping \" + p);\n-                    continue;\n-                }\n-                Node current = modules;\n-                String module = null;\n-                for (int i = 0; i < split.length; i++) {\n-                    \/\/ When a non terminal node is marked as being a resource, something is wrong.\n+            Node modulesRoot = new Node(\"modules\", root);\n+            directAccess.put(modulesRoot.getPath(), modulesRoot);\n+            packagesRoot = new Node(\"packages\", root);\n+            directAccess.put(packagesRoot.getPath(), packagesRoot);\n+\n+            \/\/ Map of dot-separated package names to module references (those\n+            \/\/ in which the package appear). References are merged after to\n+            \/\/ ensure each module name appears only once, but temporarily a\n+            \/\/ module may have several entries per package (e.g. with-content,\n+            \/\/ without-content, normal, preview-only etc..).\n+            Map<String, Set<ModuleReference>> packageToModules = new TreeMap<>();\n+            for (String fullPath : paths) {\n+                try {\n+                    processPath(fullPath, modulesRoot, packageToModules);\n+                } catch (InvalidTreeException err) {\n@@ -194,54 +206,2 @@\n-                    \/\/ invalid directory entry marled as not directory (see 8131762)\n-                    if (current instanceof ResourceNode) {\n-                        System.err.println(\"Resources tree, invalid data structure, \"\n-                                + \"skipping \" + p);\n-                        continue;\n-                    }\n-                    String s = split[i];\n-                    if (!s.isEmpty()) {\n-                        \/\/ First item, this is the module, simply add a new node to the\n-                        \/\/ tree.\n-                        if (module == null) {\n-                            module = s;\n-                        }\n-                        Node n = current.children.get(s);\n-                        if (n == null) {\n-                            if (i == split.length - 1) { \/\/ Leaf\n-                                n = new ResourceNode(s, current);\n-                                String pkg = toPackageName(n.parent);\n-                                \/\/System.err.println(\"Adding a resource node. pkg \" + pkg + \", name \" + s);\n-                                if (pkg != null && !pkg.startsWith(\"META-INF\")) {\n-                                    Set<String> pkgs = moduleToPackage.get(module);\n-                                    if (pkgs == null) {\n-                                        pkgs = new TreeSet<>();\n-                                        moduleToPackage.put(module, pkgs);\n-                                    }\n-                                    pkgs.add(pkg);\n-                                }\n-                            } else { \/\/ put only sub trees, no leaf\n-                                n = new Node(s, current);\n-                                directAccess.put(n.getPath(), n);\n-                                String pkg = toPackageName(n);\n-                                if (pkg != null && !pkg.startsWith(\"META-INF\")) {\n-                                    Set<String> mods = packageToModule.get(pkg);\n-                                    if (mods == null) {\n-                                        mods = new TreeSet<>();\n-                                        packageToModule.put(pkg, mods);\n-                                    }\n-                                    mods.add(module);\n-                                }\n-                            }\n-                        }\n-                        current = n;\n-                    }\n-                }\n-            }\n-            packages = new Node(\"packages\", root);\n-            directAccess.put(packages.getPath(), packages);\n-            \/\/ The subset of package nodes that have some content.\n-            \/\/ These packages exist only in a single module.\n-            for (Map.Entry<String, Set<String>> entry : moduleToPackage.entrySet()) {\n-                for (String pkg : entry.getValue()) {\n-                    PackageNode pkgNode = new PackageNode(pkg, packages);\n-                    pkgNode.addReference(entry.getKey(), false);\n-                    directAccess.put(pkgNode.getPath(), pkgNode);\n+                    \/\/ invalid directory entry marked as not directory (see 8131762).\n+                    System.err.println(err.getMessage());\n@@ -251,10 +211,13 @@\n-            \/\/ All packages\n-            for (Map.Entry<String, Set<String>> entry : packageToModule.entrySet()) {\n-                \/\/ Do we already have a package node?\n-                PackageNode pkgNode = (PackageNode) packages.getChildren(entry.getKey());\n-                if (pkgNode == null) {\n-                    pkgNode = new PackageNode(entry.getKey(), packages);\n-                }\n-                for (String module : entry.getValue()) {\n-                    pkgNode.addReference(module, true);\n-                }\n+            \/\/ We've collected information for all \"packages\", including the root\n+            \/\/ (empty) package and anything under \"META-INF\". However, these should\n+            \/\/ not have entries in the \"\/packages\" directory.\n+            packageToModules.keySet().removeIf(p -> p.isEmpty() || p.equals(\"META-INF\") || p.startsWith(\"META-INF.\"));\n+            packageToModules.forEach((pkgName, modRefs) -> {\n+                \/\/ Merge multiple refs for the same module.\n+                List<ModuleReference> pkgModules = modRefs.stream()\n+                        .collect(Collectors.groupingBy(ModuleReference::name))\n+                        .values().stream()\n+                        .map(refs -> refs.stream().reduce(ModuleReference::merge).orElseThrow())\n+                        .sorted()\n+                        .toList();\n+                PackageNode pkgNode = new PackageNode(pkgName, pkgModules, packagesRoot);\n@@ -262,0 +225,16 @@\n+            });\n+        }\n+\n+        private void processPath(\n+                String fullPath,\n+                Node modulesRoot,\n+                Map<String, Set<ModuleReference>> packageToModules)\n+                throws InvalidTreeException {\n+            \/\/ Paths are untrusted, so be careful about checking expected format.\n+            if (!fullPath.startsWith(\"\/\") || fullPath.endsWith(\"\/\") || fullPath.contains(\"\/\/\")) {\n+                return;\n+            }\n+            int modEnd = fullPath.indexOf('\/', 1);\n+            \/\/ Ensure non-empty module name with non-empty suffix.\n+            if (modEnd <= 1) {\n+                return;\n@@ -263,3 +242,11 @@\n-            \/\/ Validate that the packages are well formed.\n-            for (Node n : packages.children.values()) {\n-                ((PackageNode)n).validate();\n+            String modName = fullPath.substring(1, modEnd);\n+            String pkgPath = fullPath.substring(modEnd + 1);\n+\n+            Node parentNode = getDirectoryNode(modName, modulesRoot);\n+            boolean isPreviewPath = false;\n+            if (pkgPath.startsWith(PREVIEW_PREFIX)) {\n+                \/\/ For preview paths, process nodes relative to the preview directory.\n+                pkgPath = pkgPath.substring(PREVIEW_PREFIX.length());\n+                Node metaInf = getDirectoryNode(\"META-INF\", parentNode);\n+                parentNode = getDirectoryNode(\"preview\", metaInf);\n+                isPreviewPath = true;\n@@ -268,0 +255,26 @@\n+            int pathEnd = pkgPath.lastIndexOf('\/');\n+            \/\/ From invariants tested above, this must now be well-formed.\n+            String fullPkgName = (pathEnd == -1) ? \"\" : pkgPath.substring(0, pathEnd).replace('\/', '.');\n+            String resourceName = pkgPath.substring(pathEnd + 1);\n+            \/\/ Intermediate packages are marked \"empty\" (no resources). This might\n+            \/\/ later be merged with a non-empty reference for the same package.\n+            ModuleReference emptyRef = ModuleReference.forEmptyPackageIn(modName, isPreviewPath);\n+\n+            \/\/ Work down through empty packages to final resource.\n+            for (int i = pkgEndIndex(fullPkgName, 0); i != -1; i = pkgEndIndex(fullPkgName, i)) {\n+                \/\/ Due to invariants already checked, pkgName is non-empty.\n+                String pkgName = fullPkgName.substring(0, i);\n+                packageToModules.computeIfAbsent(pkgName, p -> new HashSet<>()).add(emptyRef);\n+                String childNodeName = pkgName.substring(pkgName.lastIndexOf('.') + 1);\n+                parentNode = getDirectoryNode(childNodeName, parentNode);\n+            }\n+            \/\/ Reached non-empty (leaf) package (could still be a duplicate).\n+            Node resourceNode = parentNode.getChildren(resourceName);\n+            if (resourceNode == null) {\n+                ModuleReference resourceRef = ModuleReference.forPackageIn(modName, isPreviewPath);\n+                packageToModules.computeIfAbsent(fullPkgName, p -> new HashSet<>()).add(resourceRef);\n+                \/\/ Init adds new node to parent (don't add resources to directAccess).\n+                new ResourceNode(resourceName, parentNode);\n+            } else if (!(resourceNode instanceof ResourceNode)) {\n+                throw new InvalidTreeException(resourceNode);\n+            }\n@@ -270,3 +283,8 @@\n-        public String toResourceName(Node node) {\n-            if (!node.children.isEmpty()) {\n-                throw new RuntimeException(\"Node is not a resource\");\n+        private Node getDirectoryNode(String name, Node parent) throws InvalidTreeException {\n+            Node child = parent.getChildren(name);\n+            if (child == null) {\n+                \/\/ Adds child to parent during init.\n+                child = new Node(name, parent);\n+                directAccess.put(child.getPath(), child);\n+            } else if (child instanceof ResourceNode) {\n+                throw new InvalidTreeException(child);\n@@ -274,1 +292,1 @@\n-            return removeRadical(node);\n+            return child;\n@@ -277,13 +295,5 @@\n-        public String getModule(Node node) {\n-            if (node.parent == null || node.getName().equals(\"modules\")\n-                    || node.getName().startsWith(\"packages\")) {\n-                return null;\n-            }\n-            String path = removeRadical(node);\n-            \/\/ \"\/xxx\/...\";\n-            path = path.substring(1);\n-            int i = path.indexOf(\"\/\");\n-            if (i == -1) {\n-                return path;\n-            } else {\n-                return path.substring(0, i);\n+        \/\/ Helper to iterate package names up to, and including, the complete name.\n+        private int pkgEndIndex(String s, int i) {\n+            if (i >= 0 && i < s.length()) {\n+                i = s.indexOf('.', i + 1);\n+                return i != -1 ? i : s.length();\n@@ -291,0 +301,1 @@\n+            return -1;\n@@ -293,8 +304,3 @@\n-        public String toPackageName(Node node) {\n-            if (node.parent == null) {\n-                return null;\n-            }\n-            String path = removeRadical(node.getPath(), \"\/modules\/\");\n-            String module = getModule(node);\n-            if (path.equals(module)) {\n-                return null;\n+        private String toResourceName(Node node) {\n+            if (!node.children.isEmpty()) {\n+                throw new RuntimeException(\"Node is not a resource\");\n@@ -302,2 +308,1 @@\n-            String pkg = removeRadical(path, module + \"\/\");\n-            return pkg.replace('\/', '.');\n+            return removeRadical(node);\n@@ -306,1 +311,1 @@\n-        public String removeRadical(Node node) {\n+        private String removeRadical(Node node) {\n@@ -342,3 +347,4 @@\n-                PackageNode pkgNode = (PackageNode) current;\n-                int size = pkgNode.references.size() * 8;\n-                writer.addLocation(current.getPath(), offset, 0, size);\n+                List<ModuleReference> refs = ((PackageNode) current).getModuleReferences();\n+                \/\/ \"\/packages\/<pkg name>\" entries have 8-byte entries (flags+offset).\n+                int size = refs.size() * 8;\n+                writer.addLocation(current.getPath(), offset, 0, size, ImageLocation.getPackageFlags(refs));\n@@ -354,0 +360,2 @@\n+                    int locFlags = ImageLocation.getFlags(current.getPath(), tree.directAccess::containsKey);\n+                    \/\/ Normal directory entries have 4-byte entries (offset only).\n@@ -355,1 +363,1 @@\n-                    writer.addLocation(current.getPath(), offset, 0, size);\n+                    writer.addLocation(current.getPath(), offset, 0, size, locFlags);\n@@ -372,1 +380,1 @@\n-                    item.loc = entry.getValue();\n+                    item.setLocation(entry.getValue());\n@@ -381,12 +389,7 @@\n-                \/\/ \/packages\/<pkg name>\n-                PackageNode pkgNode = (PackageNode) current;\n-                int size = pkgNode.references.size() * 8;\n-                ByteBuffer buff = ByteBuffer.allocate(size);\n-                buff.order(writer.getByteOrder());\n-                for (PackageNode.PackageReference mod : pkgNode.references.values()) {\n-                    buff.putInt(mod.isEmpty ? 1 : 0);\n-                    buff.putInt(writer.addString(mod.name));\n-                }\n-                byte[] arr = buff.array();\n-                content.add(arr);\n-                current.loc = outLocations.get(current.getPath());\n+                \/\/ \"\/packages\/<pkg name>\" entries have 8-byte entries (flags+offset).\n+                List<ModuleReference> refs = ((PackageNode) current).getModuleReferences();\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(8 * refs.size());\n+                byteBuffer.order(writer.getByteOrder());\n+                ModuleReference.write(refs, byteBuffer.asIntBuffer(), writer::addString);\n+                content.add(byteBuffer.array());\n+                current.setLocation(outLocations.get(current.getPath()));\n@@ -413,1 +416,1 @@\n-                        current.loc = outLocations.get(s);\n+                        current.setLocation(outLocations.get(s));\n@@ -416,1 +419,1 @@\n-                        current.loc = outLocations.get(current.getPath());\n+                        current.setLocation(outLocations.get(current.getPath()));\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageResourcesTree.java","additions":187,"deletions":184,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+\n@@ -36,1 +37,0 @@\n-    static final int EMPTY_OFFSET = 0;\n@@ -45,5 +45,9 @@\n-        \/\/ Reserve 0 offset for empty string.\n-        int offset = addString(\"\");\n-        if (offset != 0) {\n-            throw new InternalError(\"Empty string not offset zero\");\n-        }\n+        \/\/ Frequently used\/special strings for which the offset is useful.\n+        \/\/ New strings can be reserved after existing strings without having to\n+        \/\/ change the jimage file version, but any change to existing entries\n+        \/\/ requires the jimage file version to be increased at the same time.\n+        reserveString(\"\", ImageStrings.EMPTY_STRING_OFFSET);\n+        reserveString(\"class\", ImageStrings.CLASS_STRING_OFFSET);\n+        reserveString(\"modules\", ImageStrings.MODULES_STRING_OFFSET);\n+        reserveString(\"packages\", ImageStrings.PACKAGES_STRING_OFFSET);\n+    }\n@@ -51,4 +55,4 @@\n-        \/\/ Reserve 1 offset for frequently used \".class\".\n-        offset = addString(\"class\");\n-        if (offset != 1) {\n-            throw new InternalError(\"'class' string not offset one\");\n+    private void reserveString(String value, int expectedOffset) {\n+        int offset = addString(value);\n+        if (offset != expectedOffset) {\n+            throw new InternalError(\"Reserved string \\\"\" + value + \"\\\" not at expected offset \" + expectedOffset + \"[was \" + offset + \"]\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageStringsWriter.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,2 +282,0 @@\n-  jdk.crypto.ec provides java.security.Provider used by java.base\n-  jdk.crypto.mscapi provides java.security.Provider used by java.base\n","filename":"src\/jdk.jlink\/share\/man\/jlink.md","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        app = normalizeAppImageLayout(app);\n+        app = copyWithUnresolvedAppImageLayout(app);\n@@ -246,1 +246,1 @@\n-    private static MacApplication normalizeAppImageLayout(MacApplication app) {\n+    private static MacApplication copyWithUnresolvedAppImageLayout(MacApplication app) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n@@ -32,3 +30,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n@@ -36,1 +31,0 @@\n-import java.util.Optional;\n@@ -47,20 +41,1 @@\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) != null) {\n-            Path applicationImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-            if (new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params)).signed()) {\n-                var appLayout = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT.resolveAt(applicationImage);\n-                if (!Files.exists(\n-                        PackageFile.getPathInAppImage(appLayout))) {\n-                    Log.info(MessageFormat.format(I18N.getString(\n-                            \"warning.per.user.app.image.signed\"),\n-                            PackageFile.getPathInAppImage(appLayout)));\n-                }\n-            } else {\n-                if (Optional.ofNullable(\n-                        SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n-                    \/\/ if signing bundle with app-image, warn user if app-image\n-                    \/\/ is not already signed.\n-                    Log.info(MessageFormat.format(I18N.getString(\n-                            \"warning.unsigned.app.image\"), getID()));\n-                }\n-            }\n-        } else {\n+        if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass());\n+            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(superAppBuilder.mainLauncherClassName().orElseThrow());\n@@ -125,1 +125,1 @@\n-            final var appImageFileExtras = new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params));\n+            final var appImageFileExtras = new MacAppImageFileExtras(superAppBuilder.externalApplication().orElseThrow());\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n@@ -29,0 +30,1 @@\n+import java.nio.file.Files;\n@@ -60,1 +62,15 @@\n-        return MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n+\n+        var macPkg = MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n+        validatePredefinedAppImage(macPkg);\n+        return macPkg;\n+    }\n+\n+    private static void validatePredefinedAppImage(MacPackage pkg) {\n+        if (pkg.predefinedAppImageSigned().orElse(false)) {\n+            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n+                var thePackageFile = PackageFile.getPathInAppImage(APPLICATION_LAYOUT);\n+                if (!Files.exists(predefinedAppImage.resolve(thePackageFile))) {\n+                    Log.info(I18N.format(\"warning.per.user.app.image.signed\", thePackageFile));\n+                }\n+            });\n+        }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-        return MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n+        var pkg = MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n+        validatePredefinedAppImage(pkg);\n+        return pkg;\n@@ -59,0 +61,8 @@\n+    private static void validatePredefinedAppImage(MacPkgPackage pkg) {\n+        if (!pkg.predefinedAppImageSigned().orElse(false) && pkg.sign()) {\n+            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n+                Log.info(I18N.format(\"warning.unsigned.app.image\", \"pkg\"));\n+            });\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackageBuilder.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,0 +89,3 @@\n+\n+        externalApp = Objects.requireNonNull(app);\n+\n@@ -115,0 +118,13 @@\n+    Optional<ExternalApplication> externalApplication() {\n+        return Optional.ofNullable(externalApp);\n+    }\n+\n+    Optional<String> mainLauncherClassName() {\n+        return launchers()\n+                .map(ApplicationLaunchers::mainLauncher)\n+                .flatMap(Launcher::startupInfo)\n+                .map(LauncherStartupInfo::qualifiedClassName).or(() -> {\n+                    return externalApplication().map(ExternalApplication::getMainClass);\n+                });\n+    }\n+\n@@ -211,0 +227,1 @@\n+    private ExternalApplication externalApp;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -151,1 +152,2 @@\n-        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes, LinkOption.NOFOLLOW_LINKS);\n+        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes,\n+                LinkOption.NOFOLLOW_LINKS, StandardCopyOption.REPLACE_EXISTING);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-        Log.verbose (\"\\njpackage argument list: \\n\" + argList + \"\\n\");\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                MODULE_PATH.copyInto(params, runtimeBuilderBuilder::modulePath);\n+                runtimeBuilderBuilder.modulePath(MODULE_PATH.fetchFrom(params));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n@@ -48,1 +46,1 @@\n-        Files.createDirectories(getParent(destFile));\n+        Files.createDirectories(destFile.getParent());\n@@ -55,20 +53,0 @@\n-    public static boolean exists(Path path) {\n-        if (path == null) {\n-            return false;\n-        }\n-\n-        return Files.exists(path);\n-    }\n-\n-    \/\/ run \"launcher paramfile\" in the directory where paramfile is kept\n-    public static void run(String launcher, Path paramFile)\n-            throws IOException {\n-        if (IOUtils.exists(paramFile)) {\n-            ProcessBuilder pb =\n-                    new ProcessBuilder(launcher,\n-                        getFileName(paramFile).toString());\n-            pb = pb.directory(getParent(paramFile).toFile());\n-            exec(pb);\n-        }\n-    }\n-\n@@ -86,15 +64,0 @@\n-    \/\/ See JDK-8236282\n-    \/\/ Reading output from some processes (currently known \"hdiutil attach\")\n-    \/\/ might hang even if process already exited. Only possible workaround found\n-    \/\/ in \"hdiutil attach\" case is to redirect the output to a temp file and then\n-    \/\/ read this file back.\n-    public static void exec(ProcessBuilder pb, boolean writeOutputToFile)\n-            throws IOException {\n-        exec(pb, false, null, writeOutputToFile, Executor.INFINITE_TIMEOUT);\n-    }\n-\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n-            PrintStream consumer) throws IOException {\n-        exec(pb, testForPresenceOnly, consumer, false, Executor.INFINITE_TIMEOUT);\n-    }\n-\n@@ -130,45 +93,0 @@\n-    public static int getProcessOutput(List<String> result, String... args)\n-            throws IOException, InterruptedException {\n-\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-\n-        final Process p = pb.start();\n-\n-        List<String> list = new ArrayList<>();\n-\n-        final BufferedReader in =\n-                new BufferedReader(new InputStreamReader(p.getInputStream()));\n-        final BufferedReader err =\n-                new BufferedReader(new InputStreamReader(p.getErrorStream()));\n-\n-        Thread t = new Thread(() -> {\n-            try {\n-                String line;\n-                while ((line = in.readLine()) != null) {\n-                    list.add(line);\n-                }\n-            } catch (IOException ioe) {\n-                Log.verbose(ioe);\n-            }\n-\n-            try {\n-                String line;\n-                while ((line = err.readLine()) != null) {\n-                    Log.error(line);\n-                }\n-            } catch (IOException ioe) {\n-                  Log.verbose(ioe);\n-            }\n-        });\n-        t.setDaemon(true);\n-        t.start();\n-\n-        int ret = p.waitFor();\n-        Log.verbose(pb.command(), list, ret, IOUtils.getPID(p));\n-\n-        result.clear();\n-        result.addAll(list);\n-\n-        return ret;\n-    }\n-\n@@ -191,22 +109,0 @@\n-    public static Path getParent(Path p) {\n-        Path parent = p.getParent();\n-        if (parent == null) {\n-            IllegalArgumentException iae =\n-                    new IllegalArgumentException(p.toString());\n-            Log.verbose(iae);\n-            throw iae;\n-        }\n-        return parent;\n-    }\n-\n-    public static Path getFileName(Path p) {\n-        Path filename = p.getFileName();\n-        if (filename == null) {\n-            IllegalArgumentException iae =\n-                    new IllegalArgumentException(p.toString());\n-            Log.verbose(iae);\n-            throw iae;\n-        }\n-        return filename;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":1,"deletions":105,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -28,0 +29,1 @@\n+import java.io.IOException;\n@@ -35,0 +37,1 @@\n+import java.nio.file.Files;\n@@ -96,0 +99,46 @@\n+    \/**\n+     * Returns a list of paths that includes the location where the \"java.base\"\n+     * module can be found.\n+     * <p>\n+     * Returns the specified path list if \"java.base\" module can be found in one of\n+     * the paths from the specified path list.\n+     * <p>\n+     * Returns a new path list created from the specified path list with the path of\n+     * \"java.base\" module in the current runtime appended otherwise.\n+     *\n+     * @param modulePath the path list where to look up for \"java.base\" module\n+     * @return the path list that includes location of \"java.base\" module\n+     *\/\n+    static List<Path> ensureBaseModuleInModulePath(List<Path> modulePath) {\n+        if (modulePath.stream().anyMatch(path -> {\n+            return Files.isRegularFile(path.resolve(\"java.base.jmod\"));\n+        })) {\n+            return modulePath;\n+        } else {\n+            \/\/ There is no \"java.base.jmod\" file in the `modulePath` path list.\n+            \/\/ Pick items from the default module path list that are not yet\n+            \/\/ in the `modulePath` path list and append them to it.\n+\n+            var missingDefaultModulePath = getDefaultModulePath();\n+\n+            if (!modulePath.isEmpty()) {\n+                missingDefaultModulePath.stream().filter(defaultPath -> {\n+                    return modulePath.stream().anyMatch(path -> {\n+                        try {\n+                            return Files.isSameFile(path, defaultPath);\n+                        } catch (IOException ex) {\n+                            \/\/ Assume `defaultPath` path doesn't exist in `modulePath` list.\n+                            return false;\n+                        }\n+                    });\n+                }).toList();\n+            }\n+\n+            if (missingDefaultModulePath.isEmpty()) {\n+                return modulePath;\n+            } else {\n+                return Stream.of(modulePath, missingDefaultModulePath).flatMap(Collection::stream).toList();\n+            }\n+        }\n+    }\n+\n@@ -218,1 +267,1 @@\n-        return strings.stream().collect(Collectors.joining(\",\"));\n+        return strings.stream().sorted().collect(Collectors.joining(\",\"));\n@@ -233,1 +282,1 @@\n-    };\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.UncheckedIOException;\n@@ -183,0 +184,9 @@\n+    Source probe() {\n+        try {\n+            return saveToStream(null);\n+        } catch (IOException ex) {\n+            \/\/ Should never happen.\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OverridableResource.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -59,1 +58,0 @@\n-    private static final String JAVABASEJMOD = \"java.base.jmod\";\n@@ -418,1 +416,1 @@\n-                    p -> getDefaultModulePath(),\n+                    p -> JLinkRuntimeBuilder.ensureBaseModuleInModulePath(List.of()),\n@@ -423,20 +421,1 @@\n-                        Path javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n-\n-                        \/\/ Add the default JDK module path to the module path.\n-                        if (javaBasePath == null) {\n-                            List<Path> jdkModulePath = getDefaultModulePath();\n-\n-                            if (jdkModulePath != null) {\n-                                modulePath = Stream.concat(modulePath.stream(),\n-                                        jdkModulePath.stream()).toList();\n-                                javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n-                            }\n-                        }\n-\n-                        if (javaBasePath == null ||\n-                                !Files.exists(javaBasePath)) {\n-                            Log.error(String.format(I18N.getString(\n-                                    \"warning.no.jdk.modules.found\")));\n-                        }\n-\n-                        return modulePath;\n+                        return JLinkRuntimeBuilder.ensureBaseModuleInModulePath(modulePath);\n@@ -445,14 +424,0 @@\n-    \/\/ Returns the path to the JDK modules in the user defined module path.\n-    private static Path findPathOfModule( List<Path> modulePath, String moduleName) {\n-\n-        for (Path path : modulePath) {\n-            Path moduleNamePath = path.resolve(moduleName);\n-\n-            if (Files.exists(moduleNamePath)) {\n-                return path;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":2,"deletions":37,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public static Optional<ApplicationLaunchers> fromList(List<Launcher> launchers) {\n+    public static Optional<ApplicationLaunchers> fromList(List<? extends Launcher> launchers) {\n@@ -65,1 +65,1 @@\n-                    launchers.subList(1, launchers.size())));\n+                    List.copyOf(launchers.subList(1, launchers.size()))));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLaunchers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.module.ModuleFinder;\n@@ -49,1 +50,7 @@\n-     * Gets the default set of paths where to find Java modules.\n+     * Gets the default set of paths where jlink should look up for system Java\n+     * modules.\n+     *\n+     * <p>\n+     * These paths are for {@code jlink} command. Using them with\n+     * {@link ModuleFinder#of(Path...)} may not work as expected: attempt to find\n+     * \"java.base\" module in these paths will fail.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-warning.no.jdk.modules.found=Warning: No JDK Modules found\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Object wrapper implementing {@link Object#equals(Object)} such that it\n+ * returns {@code true} only when the argument is another instance of this class\n+ * wrapping the same object.\n+ * <p>\n+ * The class guarantees that {@link Object#equals(Object)} and\n+ * {@link Object#hashCode()} methods of the wrapped object will never be called\n+ * inside of the class methods.\n+ *\n+ * @param <T> the type of the wrapped value\n+ *\/\n+public final class IdentityWrapper<T> {\n+\n+    public IdentityWrapper(T value) {\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    public T value() {\n+        return value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if ((obj == null) || (getClass() != obj.getClass())) {\n+            return false;\n+        }\n+        var other = (IdentityWrapper<?>) obj;\n+        return value == other.value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Identity[%s]\", value);\n+    }\n+\n+    private final T value;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/IdentityWrapper.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -7,1 +7,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Result.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static java.util.stream.Collectors.toMap;\n+\n@@ -33,0 +35,1 @@\n+import java.util.TreeMap;\n@@ -34,2 +37,0 @@\n-import java.util.function.UnaryOperator;\n-import java.util.stream.Collectors;\n@@ -49,5 +50,5 @@\n-        scripts = EnumSet.allOf(scriptIdsType).stream().collect(\n-                Collectors.toMap(UnaryOperator.identity(), scriptId -> {\n-                    return new ShellScriptResource(scriptId.name()).setResource(\n-                            scriptId.get());\n-                }));\n+        scripts = EnumSet.allOf(scriptIdsType).stream().collect(toMap(x -> x, scriptId -> {\n+            return new ShellScriptResource(scriptId.name()).setResource(scriptId.get());\n+        }, (a, b) -> {\n+            throw new UnsupportedOperationException();\n+        }, TreeMap::new));\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/PackageScripts.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        return msiBundler.validate(params);\n+        return msiBundler.validate(params, WinFromParams.EXE_PACKAGE);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.jpackage.internal.model.Package;\n@@ -83,1 +84,5 @@\n-    public boolean validate(Map<String, ? super Object> params)\n+    public boolean validate(Map<String, ? super Object> params) throws ConfigException {\n+        return validate(params, WinFromParams.MSI_PACKAGE);\n+    }\n+\n+    boolean validate(Map<String, ? super Object> params, BundlerParamInfo<? extends Package> pkgParam)\n@@ -87,1 +92,1 @@\n-            WinFromParams.APPLICATION.fetchFrom(params);\n+            pkgParam.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-                return IOUtils.getFileName(path).toString();\n+                return path.getFileName().toString();\n@@ -528,1 +528,1 @@\n-                IOUtils.getFileName(launcherPath), \"\").toString();\n+                launcherPath.getFileName(), \"\").toString();\n@@ -715,1 +715,1 @@\n-            xml.writeAttribute(\"Name\", IOUtils.getFileName(dir).toString());\n+            xml.writeAttribute(\"Name\", dir.getFileName().toString());\n@@ -821,1 +821,1 @@\n-                if (IOUtils.getFileName(src).toString().endsWith(\".ico\")) {\n+                if (src.getFileName().toString().endsWith(\".ico\")) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        Files.createDirectories(IOUtils.getParent(msi));\n+        Files.createDirectories(msi.getParent());\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.TreeMap;\n@@ -147,1 +148,1 @@\n-            Files.createDirectories(IOUtils.getParent(resourceSaveAsFile));\n+            Files.createDirectories(resourceSaveAsFile.getParent());\n@@ -196,1 +197,1 @@\n-        private final Map<Path, OverridableResource> resources = new HashMap<>();\n+        private final Map<Path, OverridableResource> resources = new TreeMap<>();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixSourceConverter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+\n+jdk\/javadoc\/doccheck\/checks\/jdkCheckLinks.java 8370249 generic-all\n","filename":"test\/docs\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2146,0 +2146,4 @@\n+                        [\"splice\",   \"__ sve_splice(z0, __ B, p0, z1);\",                   \"splice\\tz0.b, p0, z0.b, z1.b\"],\n+                        [\"splice\",   \"__ sve_splice(z0, __ H, p0, z1);\",                   \"splice\\tz0.h, p0, z0.h, z1.h\"],\n+                        [\"splice\",   \"__ sve_splice(z0, __ S, p0, z1);\",                   \"splice\\tz0.s, p0, z0.s, z1.s\"],\n+                        [\"splice\",   \"__ sve_splice(z0, __ D, p0, z1);\",                   \"splice\\tz0.d, p0, z0.d, z1.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1159,0 +1159,4 @@\n+    __ sve_splice(z0, __ B, p0, z1);                   \/\/       splice  z0.b, p0, z0.b, z1.b\n+    __ sve_splice(z0, __ H, p0, z1);                   \/\/       splice  z0.h, p0, z0.h, z1.h\n+    __ sve_splice(z0, __ S, p0, z1);                   \/\/       splice  z0.s, p0, z0.s, z1.s\n+    __ sve_splice(z0, __ D, p0, z1);                   \/\/       splice  z0.d, p0, z0.d, z1.d\n@@ -1448,7 +1452,7 @@\n-    0x14000000,     0x17ffffd7,     0x140004b7,     0x94000000,\n-    0x97ffffd4,     0x940004b4,     0x3400000a,     0x34fffa2a,\n-    0x3400962a,     0x35000008,     0x35fff9c8,     0x350095c8,\n-    0xb400000b,     0xb4fff96b,     0xb400956b,     0xb500001d,\n-    0xb5fff91d,     0xb500951d,     0x10000013,     0x10fff8b3,\n-    0x100094b3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36309436,     0x3758000c,     0x375ff7cc,     0x375893cc,\n+    0x14000000,     0x17ffffd7,     0x140004bb,     0x94000000,\n+    0x97ffffd4,     0x940004b8,     0x3400000a,     0x34fffa2a,\n+    0x340096aa,     0x35000008,     0x35fff9c8,     0x35009648,\n+    0xb400000b,     0xb4fff96b,     0xb40095eb,     0xb500001d,\n+    0xb5fff91d,     0xb500959d,     0x10000013,     0x10fff8b3,\n+    0x10009533,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363094b6,     0x3758000c,     0x375ff7cc,     0x3758944c,\n@@ -1459,13 +1463,13 @@\n-    0x540091a0,     0x54000001,     0x54fff541,     0x54009141,\n-    0x54000002,     0x54fff4e2,     0x540090e2,     0x54000002,\n-    0x54fff482,     0x54009082,     0x54000003,     0x54fff423,\n-    0x54009023,     0x54000003,     0x54fff3c3,     0x54008fc3,\n-    0x54000004,     0x54fff364,     0x54008f64,     0x54000005,\n-    0x54fff305,     0x54008f05,     0x54000006,     0x54fff2a6,\n-    0x54008ea6,     0x54000007,     0x54fff247,     0x54008e47,\n-    0x54000008,     0x54fff1e8,     0x54008de8,     0x54000009,\n-    0x54fff189,     0x54008d89,     0x5400000a,     0x54fff12a,\n-    0x54008d2a,     0x5400000b,     0x54fff0cb,     0x54008ccb,\n-    0x5400000c,     0x54fff06c,     0x54008c6c,     0x5400000d,\n-    0x54fff00d,     0x54008c0d,     0x5400000e,     0x54ffefae,\n-    0x54008bae,     0x5400000f,     0x54ffef4f,     0x54008b4f,\n+    0x54009220,     0x54000001,     0x54fff541,     0x540091c1,\n+    0x54000002,     0x54fff4e2,     0x54009162,     0x54000002,\n+    0x54fff482,     0x54009102,     0x54000003,     0x54fff423,\n+    0x540090a3,     0x54000003,     0x54fff3c3,     0x54009043,\n+    0x54000004,     0x54fff364,     0x54008fe4,     0x54000005,\n+    0x54fff305,     0x54008f85,     0x54000006,     0x54fff2a6,\n+    0x54008f26,     0x54000007,     0x54fff247,     0x54008ec7,\n+    0x54000008,     0x54fff1e8,     0x54008e68,     0x54000009,\n+    0x54fff189,     0x54008e09,     0x5400000a,     0x54fff12a,\n+    0x54008daa,     0x5400000b,     0x54fff0cb,     0x54008d4b,\n+    0x5400000c,     0x54fff06c,     0x54008cec,     0x5400000d,\n+    0x54fff00d,     0x54008c8d,     0x5400000e,     0x54ffefae,\n+    0x54008c2e,     0x5400000f,     0x54ffef4f,     0x54008bcf,\n@@ -1692,1 +1696,2 @@\n-    0x6585c891,     0x65c5c891,     0x45b0c210,     0x45f1c231,\n+    0x6585c891,     0x65c5c891,     0x052c8020,     0x056c8020,\n+    0x05ac8020,     0x05ec8020,     0x45b0c210,     0x45f1c231,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -167,0 +167,10 @@\n+TEST_VM_FATAL_ERROR_MSG(NMT, memory_corruption_call_stack, \".*header canary.*\") {\n+  if (MemTracker::tracking_level() != NMT_detail) {\n+    guarantee(false, \"fake message ignore this - header canary\");\n+  }\n+  const size_t SIZE = 1024;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  *(p - 1) = 0;\n+  os::free(p);\n+}\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  ASSERT_TRUE(rm.Size() == expected);\n+  ASSERT_TRUE(rm.size() == expected);\n@@ -38,1 +38,1 @@\n-    ASSERT_TRUE(!rm.is_Empty());\n+    ASSERT_TRUE(!rm.is_empty());\n@@ -40,1 +40,1 @@\n-    ASSERT_TRUE(rm.is_Empty());\n+    ASSERT_TRUE(rm.is_empty());\n@@ -63,8 +63,8 @@\n-  rm.Insert(30);\n-  rm.Insert(31);\n-  rm.Insert(32);\n-  rm.Insert(33);\n-  rm.Insert(62);\n-  rm.Insert(63);\n-  rm.Insert(64);\n-  rm.Insert(65);\n+  rm.insert(30);\n+  rm.insert(31);\n+  rm.insert(32);\n+  rm.insert(33);\n+  rm.insert(62);\n+  rm.insert(63);\n+  rm.insert(64);\n+  rm.insert(65);\n@@ -85,1 +85,1 @@\n-  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits()\n+  \/\/ Check that set_all doesn't add bits outside of rm.rm_size_bits()\n@@ -87,4 +87,4 @@\n-  rm.Set_All();\n-  ASSERT_TRUE(rm.Size() == rm.rm_size_in_bits());\n-  ASSERT_TRUE(!rm.is_Empty());\n-  \/\/ Set_All sets infinite_stack\n+  rm.set_all();\n+  ASSERT_TRUE(rm.size() == rm.rm_size_in_bits());\n+  ASSERT_TRUE(!rm.is_empty());\n+  \/\/ set_all sets infinite_stack\n@@ -98,2 +98,2 @@\n-  rm.Set_All();\n-  rm.Clear();\n+  rm.set_all();\n+  rm.clear();\n@@ -103,1 +103,1 @@\n-TEST_VM(RegMask, AND) {\n+TEST_VM(RegMask, and_with) {\n@@ -105,1 +105,1 @@\n-  rm1.Insert(OptoReg::Name(1));\n+  rm1.insert(OptoReg::Name(1));\n@@ -107,1 +107,1 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(1)));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(1)));\n@@ -109,1 +109,1 @@\n-  rm1.AND(rm1);\n+  rm1.and_with(rm1);\n@@ -113,1 +113,1 @@\n-  rm1.AND(rm2);\n+  rm1.and_with(rm2);\n@@ -118,1 +118,1 @@\n-TEST_VM(RegMask, OR) {\n+TEST_VM(RegMask, or_with) {\n@@ -120,1 +120,1 @@\n-  rm1.Insert(OptoReg::Name(1));\n+  rm1.insert(OptoReg::Name(1));\n@@ -122,1 +122,1 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(1)));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(1)));\n@@ -124,1 +124,1 @@\n-  rm1.OR(rm1);\n+  rm1.or_with(rm1);\n@@ -128,1 +128,1 @@\n-  rm1.OR(rm2);\n+  rm1.or_with(rm2);\n@@ -133,1 +133,1 @@\n-TEST_VM(RegMask, SUBTRACT) {\n+TEST_VM(RegMask, subtract) {\n@@ -137,1 +137,1 @@\n-  rm2.Set_All();\n+  rm2.set_all();\n@@ -139,1 +139,1 @@\n-    rm1.Insert(i);\n+    rm1.insert(i);\n@@ -143,1 +143,1 @@\n-  rm2.SUBTRACT(rm1);\n+  rm2.subtract(rm1);\n@@ -148,1 +148,1 @@\n-TEST_VM(RegMask, SUBTRACT_inner) {\n+TEST_VM(RegMask, subtract_inner) {\n@@ -151,1 +151,1 @@\n-  rm2.Set_All();\n+  rm2.set_all();\n@@ -153,1 +153,1 @@\n-    rm1.Insert(i);\n+    rm1.insert(i);\n@@ -155,1 +155,1 @@\n-  rm2.SUBTRACT_inner(rm1);\n+  rm2.subtract_inner(rm1);\n@@ -164,1 +164,1 @@\n-    rm.Insert(i);\n+    rm.insert(i);\n@@ -168,1 +168,1 @@\n-    rm.Remove(i);\n+    rm.remove(i);\n@@ -179,2 +179,2 @@\n-    rm.Insert(i);\n-    rm.Insert(i + 1);\n+    rm.insert(i);\n+    rm.insert(i + 1);\n@@ -185,1 +185,1 @@\n-    rm.Clear();\n+    rm.clear();\n@@ -188,3 +188,3 @@\n-  rm.Clear();\n-  rm.Insert(rm.rm_size_in_bits() - 2);\n-  rm.Insert(rm.rm_size_in_bits() - 1);\n+  rm.clear();\n+  rm.insert(rm.rm_size_in_bits() - 2);\n+  rm.insert(rm.rm_size_in_bits() - 1);\n@@ -201,1 +201,1 @@\n-        rm.Insert(j);\n+        rm.insert(j);\n@@ -205,1 +205,1 @@\n-      rm.Clear();\n+      rm.clear();\n@@ -209,1 +209,1 @@\n-      rm.Insert(j);\n+      rm.insert(j);\n@@ -213,1 +213,1 @@\n-    rm.Clear();\n+    rm.clear();\n@@ -220,1 +220,1 @@\n-  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_FALSE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -222,1 +222,1 @@\n-  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_TRUE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -227,3 +227,3 @@\n-  rm.Insert(OptoReg::Name(44));\n-  rm.Insert(OptoReg::Name(30));\n-  rm.Insert(OptoReg::Name(54));\n+  rm.insert(OptoReg::Name(44));\n+  rm.insert(OptoReg::Name(30));\n+  rm.insert(OptoReg::Name(54));\n@@ -234,1 +234,1 @@\n-  rm.Clear();\n+  rm.clear();\n@@ -245,8 +245,8 @@\n-  rm.Insert(OptoReg::Name(24));\n-  rm.Insert(OptoReg::Name(25));\n-  rm.Insert(OptoReg::Name(26));\n-  rm.Insert(OptoReg::Name(27));\n-  rm.Insert(OptoReg::Name(16));\n-  rm.Insert(OptoReg::Name(17));\n-  rm.Insert(OptoReg::Name(18));\n-  rm.Insert(OptoReg::Name(19));\n+  rm.insert(OptoReg::Name(24));\n+  rm.insert(OptoReg::Name(25));\n+  rm.insert(OptoReg::Name(26));\n+  rm.insert(OptoReg::Name(27));\n+  rm.insert(OptoReg::Name(16));\n+  rm.insert(OptoReg::Name(17));\n+  rm.insert(OptoReg::Name(18));\n+  rm.insert(OptoReg::Name(19));\n@@ -258,2 +258,2 @@\n-  rm.Insert(OptoReg::Name(30));\n-  rm.Insert(OptoReg::Name(31));\n+  rm.insert(OptoReg::Name(30));\n+  rm.insert(OptoReg::Name(31));\n@@ -261,6 +261,6 @@\n-  rm.Insert(OptoReg::Name(32));\n-  rm.Insert(OptoReg::Name(37));\n-  rm.Insert(OptoReg::Name(62));\n-  rm.Insert(OptoReg::Name(71));\n-  rm.Insert(OptoReg::Name(74));\n-  rm.Insert(OptoReg::Name(75));\n+  rm.insert(OptoReg::Name(32));\n+  rm.insert(OptoReg::Name(37));\n+  rm.insert(OptoReg::Name(62));\n+  rm.insert(OptoReg::Name(71));\n+  rm.insert(OptoReg::Name(74));\n+  rm.insert(OptoReg::Name(75));\n@@ -272,4 +272,4 @@\n-  ASSERT_TRUE(rm.Member(OptoReg::Name(30)));\n-  ASSERT_TRUE(rm.Member(OptoReg::Name(31)));\n-  ASSERT_TRUE(rm.Member(OptoReg::Name(74)));\n-  ASSERT_TRUE(rm.Member(OptoReg::Name(75)));\n+  ASSERT_TRUE(rm.member(OptoReg::Name(30)));\n+  ASSERT_TRUE(rm.member(OptoReg::Name(31)));\n+  ASSERT_TRUE(rm.member(OptoReg::Name(74)));\n+  ASSERT_TRUE(rm.member(OptoReg::Name(75)));\n@@ -277,2 +277,2 @@\n-  rm.Remove(OptoReg::Name(30));\n-  rm.Remove(OptoReg::Name(74));\n+  rm.remove(OptoReg::Name(30));\n+  rm.remove(OptoReg::Name(74));\n@@ -284,13 +284,13 @@\n-  rm.Insert(OptoReg::Name(3));\n-  rm.Insert(OptoReg::Name(20));\n-  rm.Insert(OptoReg::Name(21));\n-  rm.Insert(OptoReg::Name(22));\n-  rm.Insert(OptoReg::Name(23));\n-  rm.Insert(OptoReg::Name(25));\n-  rm.Insert(OptoReg::Name(26));\n-  rm.Insert(OptoReg::Name(27));\n-  rm.Insert(OptoReg::Name(40));\n-  rm.Insert(OptoReg::Name(42));\n-  rm.Insert(OptoReg::Name(43));\n-  rm.Insert(OptoReg::Name(44));\n-  rm.Insert(OptoReg::Name(45));\n+  rm.insert(OptoReg::Name(3));\n+  rm.insert(OptoReg::Name(20));\n+  rm.insert(OptoReg::Name(21));\n+  rm.insert(OptoReg::Name(22));\n+  rm.insert(OptoReg::Name(23));\n+  rm.insert(OptoReg::Name(25));\n+  rm.insert(OptoReg::Name(26));\n+  rm.insert(OptoReg::Name(27));\n+  rm.insert(OptoReg::Name(40));\n+  rm.insert(OptoReg::Name(42));\n+  rm.insert(OptoReg::Name(43));\n+  rm.insert(OptoReg::Name(44));\n+  rm.insert(OptoReg::Name(45));\n@@ -310,1 +310,1 @@\n-  rm.Insert(OptoReg::Name(3));\n+  rm.insert(OptoReg::Name(3));\n@@ -330,5 +330,5 @@\n-  rm1.Insert(OptoReg::Name(23));\n-  rm1.Insert(OptoReg::Name(2));\n-  rm1.Insert(OptoReg::Name(12));\n-  rm2.Insert(OptoReg::Name(1));\n-  rm2.Insert(OptoReg::Name(4));\n+  rm1.insert(OptoReg::Name(23));\n+  rm1.insert(OptoReg::Name(2));\n+  rm1.insert(OptoReg::Name(12));\n+  rm2.insert(OptoReg::Name(1));\n+  rm2.insert(OptoReg::Name(4));\n@@ -337,1 +337,1 @@\n-  rm1.Insert(OptoReg::Name(4));\n+  rm1.insert(OptoReg::Name(4));\n@@ -345,4 +345,4 @@\n-  rm.Insert(OptoReg::Name(3));\n-  rm.Insert(OptoReg::Name(5));\n-  rm.Insert(OptoReg::Name(6));\n-  rm.Insert(OptoReg::Name(7));\n+  rm.insert(OptoReg::Name(3));\n+  rm.insert(OptoReg::Name(5));\n+  rm.insert(OptoReg::Name(6));\n+  rm.insert(OptoReg::Name(7));\n@@ -358,1 +358,1 @@\n-  ASSERT_TRUE(rm.Member(reg1));\n+  ASSERT_TRUE(rm.member(reg1));\n@@ -360,5 +360,5 @@\n-  rm.Clear();\n-  rm.Insert(reg1);\n-  ASSERT_TRUE(rm.Member(reg1));\n-  rm.Remove(reg1);\n-  ASSERT_FALSE(rm.Member(reg1));\n+  rm.clear();\n+  rm.insert(reg1);\n+  ASSERT_TRUE(rm.member(reg1));\n+  rm.remove(reg1);\n+  ASSERT_FALSE(rm.member(reg1));\n@@ -367,4 +367,4 @@\n-  rm.Clear();\n-  rm.Insert(reg2);\n-  ASSERT_FALSE(rm.Member(reg1));\n-  ASSERT_TRUE(rm.Member(reg2));\n+  rm.clear();\n+  rm.insert(reg2);\n+  ASSERT_FALSE(rm.member(reg1));\n+  ASSERT_TRUE(rm.member(reg2));\n@@ -379,1 +379,1 @@\n-  rm.Clear();\n+  rm.clear();\n@@ -382,2 +382,2 @@\n-  rm.Insert(reg1);\n-  rm.Insert(reg2);\n+  rm.insert(reg1);\n+  rm.insert(reg2);\n@@ -403,1 +403,1 @@\n-  rm.Clear();\n+  rm.clear();\n@@ -405,8 +405,8 @@\n-  rm.Insert(reg1);\n-  rm.Insert(reg2);\n-  rm.Insert(reg3);\n-  rm.Insert(reg4);\n-  rm.Insert(reg5);\n-  rm.Insert(reg6);\n-  rm.Insert(reg7);\n-  rm.Insert(reg8);\n+  rm.insert(reg1);\n+  rm.insert(reg2);\n+  rm.insert(reg3);\n+  rm.insert(reg4);\n+  rm.insert(reg5);\n+  rm.insert(reg6);\n+  rm.insert(reg7);\n+  rm.insert(reg8);\n@@ -416,1 +416,1 @@\n-TEST_VM(RegMask, rollover_and_Set_All_From) {\n+TEST_VM(RegMask, rollover_and_set_all_from) {\n@@ -421,2 +421,2 @@\n-  rm.Clear();\n-  rm.Set_All_From(reg1);\n+  rm.clear();\n+  rm.set_all_from(reg1);\n@@ -426,1 +426,1 @@\n-TEST_VM(RegMask, rollover_and_Set_All_From_Offset) {\n+TEST_VM(RegMask, rollover_and_set_all_from_offset) {\n@@ -430,2 +430,2 @@\n-  rm.Clear();\n-  rm.Set_All_From_Offset();\n+  rm.clear();\n+  rm.set_all_from_offset();\n@@ -443,5 +443,5 @@\n-  rm.Clear();\n-  rm.Insert(reg1);\n-  rm.Insert(reg2);\n-  rm.Insert(reg3);\n-  rm.Insert(reg4);\n+  rm.clear();\n+  rm.insert(reg1);\n+  rm.insert(reg2);\n+  rm.insert(reg3);\n+  rm.insert(reg4);\n@@ -456,1 +456,1 @@\n-TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint) {\n+TEST_VM(RegMask, rollover_and_subtract_inner_disjoint) {\n@@ -462,2 +462,2 @@\n-  rm1.Clear();\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.clear();\n+  rm1.subtract_inner(rm2);\n@@ -465,1 +465,1 @@\n-  rm2.SUBTRACT_inner(rm1);\n+  rm2.subtract_inner(rm1);\n@@ -467,3 +467,3 @@\n-  rm1.Insert(reg1);\n-  rm2.Insert(42);\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.insert(reg1);\n+  rm2.insert(42);\n+  rm1.subtract_inner(rm2);\n@@ -471,1 +471,1 @@\n-  rm2.SUBTRACT_inner(rm1);\n+  rm2.subtract_inner(rm1);\n@@ -475,1 +475,1 @@\n-TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap) {\n+TEST_VM(RegMask, rollover_and_subtract_inner_overlap) {\n@@ -481,1 +481,1 @@\n-  rm1.Clear();\n+  rm1.clear();\n@@ -484,2 +484,2 @@\n-  rm2.Clear();\n-  rm1.SUBTRACT_inner(rm2);\n+  rm2.clear();\n+  rm1.subtract_inner(rm2);\n@@ -487,1 +487,1 @@\n-  rm2.SUBTRACT_inner(rm1);\n+  rm2.subtract_inner(rm1);\n@@ -489,3 +489,3 @@\n-  rm1.Insert(reg1);\n-  rm2.Insert(reg1);\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.insert(reg1);\n+  rm2.insert(reg1);\n+  rm1.subtract_inner(rm2);\n@@ -493,2 +493,2 @@\n-  rm1.Insert(reg1);\n-  rm2.SUBTRACT_inner(rm1);\n+  rm1.insert(reg1);\n+  rm2.subtract_inner(rm1);\n@@ -505,1 +505,1 @@\n-  rm2.Member(0); \/\/ Safeguard in RegMask must catch this.\n+  rm2.member(0); \/\/ Safeguard in RegMask must catch this.\n@@ -511,1 +511,1 @@\n-  rm.Insert(std::numeric_limits<OptoReg::Name>::max());\n+  rm.insert(std::numeric_limits<OptoReg::Name>::max());\n@@ -518,1 +518,1 @@\n-  rm.Insert(rm.rm_size_in_bits());\n+  rm.insert(rm.rm_size_in_bits());\n@@ -526,2 +526,2 @@\n-  \/\/ Cannot copy with different offsets\n-  rm2 = rm1;\n+  \/\/ Cannot assign with different offsets\n+  rm2.assignFrom(rm1);\n@@ -552,2 +552,2 @@\n-  rm.Insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n-  rm.Clear();\n+  rm.insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n+  rm.clear();\n@@ -565,8 +565,8 @@\n-  rm.Insert(30);\n-  rm.Insert(31);\n-  rm.Insert(33);\n-  rm.Insert(62);\n-  rm.Insert(first_extended());\n-  rm.Insert(first_extended() + 42);\n-  rm.Insert(first_extended() + 55);\n-  rm.Insert(first_extended() + 456);\n+  rm.insert(30);\n+  rm.insert(31);\n+  rm.insert(33);\n+  rm.insert(62);\n+  rm.insert(first_extended());\n+  rm.insert(first_extended() + 42);\n+  rm.insert(first_extended() + 55);\n+  rm.insert(first_extended() + 456);\n@@ -586,2 +586,2 @@\n-TEST_VM(RegMask, Set_ALL_extended) {\n-  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits() on\n+TEST_VM(RegMask, set_all_extended) {\n+  \/\/ Check that set_all doesn't add bits outside of rm.rm_size_bits() on\n@@ -591,4 +591,4 @@\n-  rm.Set_All();\n-  ASSERT_EQ(rm.Size(), rm.rm_size_in_bits());\n-  ASSERT_TRUE(!rm.is_Empty());\n-  \/\/ Set_All sets infinite_stack bit\n+  rm.set_all();\n+  ASSERT_EQ(rm.size(), rm.rm_size_in_bits());\n+  ASSERT_TRUE(!rm.is_empty());\n+  \/\/ set_all sets infinite_stack bit\n@@ -599,1 +599,1 @@\n-TEST_VM(RegMask, Set_ALL_From_extended) {\n+TEST_VM(RegMask, set_all_from_extended) {\n@@ -602,1 +602,1 @@\n-  rm.Set_All_From(OptoReg::Name(42));\n+  rm.set_all_from(OptoReg::Name(42));\n@@ -606,1 +606,1 @@\n-TEST_VM(RegMask, Set_ALL_From_extended_grow) {\n+TEST_VM(RegMask, set_all_from_extended_grow) {\n@@ -608,1 +608,1 @@\n-  rm.Set_All_From(first_extended() + OptoReg::Name(42));\n+  rm.set_all_from(first_extended() + OptoReg::Name(42));\n@@ -613,2 +613,2 @@\n-TEST_VM(RegMask, Clear_extended) {\n-  \/\/ Check that Clear doesn't leave any stray bits on extended RegMasks.\n+TEST_VM(RegMask, clear_extended) {\n+  \/\/ Check that clear doesn't leave any stray bits on extended RegMasks.\n@@ -616,1 +616,1 @@\n-  rm.Insert(first_extended());\n+  rm.insert(first_extended());\n@@ -618,2 +618,2 @@\n-  rm.Set_All();\n-  rm.Clear();\n+  rm.set_all();\n+  rm.clear();\n@@ -623,1 +623,1 @@\n-TEST_VM(RegMask, AND_extended_basic) {\n+TEST_VM(RegMask, and_with_extended_basic) {\n@@ -625,1 +625,1 @@\n-  rm1.Insert(OptoReg::Name(first_extended()));\n+  rm1.insert(OptoReg::Name(first_extended()));\n@@ -628,1 +628,1 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n@@ -630,1 +630,1 @@\n-  rm1.AND(rm1);\n+  rm1.and_with(rm1);\n@@ -635,1 +635,1 @@\n-  rm1.AND(rm2);\n+  rm1.and_with(rm2);\n@@ -640,1 +640,1 @@\n-TEST_VM(RegMask, AND_extended_extended) {\n+TEST_VM(RegMask, and_with_extended_extended) {\n@@ -642,1 +642,1 @@\n-  rm1.Insert(OptoReg::Name(first_extended()));\n+  rm1.insert(OptoReg::Name(first_extended()));\n@@ -645,1 +645,1 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n@@ -647,1 +647,1 @@\n-  rm1.AND(rm1);\n+  rm1.and_with(rm1);\n@@ -652,1 +652,1 @@\n-  rm1.AND(rm2);\n+  rm1.and_with(rm2);\n@@ -657,1 +657,1 @@\n-TEST_VM(RegMask, OR_extended_basic) {\n+TEST_VM(RegMask, or_with_extended_basic) {\n@@ -659,1 +659,1 @@\n-  rm1.Insert(OptoReg::Name(first_extended()));\n+  rm1.insert(OptoReg::Name(first_extended()));\n@@ -662,1 +662,1 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n@@ -664,1 +664,1 @@\n-  rm1.OR(rm1);\n+  rm1.or_with(rm1);\n@@ -669,1 +669,1 @@\n-  rm1.OR(rm2);\n+  rm1.or_with(rm2);\n@@ -674,1 +674,1 @@\n-TEST_VM(RegMask, OR_extended_extended) {\n+TEST_VM(RegMask, or_with_extended_extended) {\n@@ -676,1 +676,1 @@\n-  rm1.Insert(OptoReg::Name(first_extended()));\n+  rm1.insert(OptoReg::Name(first_extended()));\n@@ -679,1 +679,1 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n@@ -681,1 +681,1 @@\n-  rm1.OR(rm1);\n+  rm1.or_with(rm1);\n@@ -686,1 +686,1 @@\n-  rm1.OR(rm2);\n+  rm1.or_with(rm2);\n@@ -691,1 +691,1 @@\n-TEST_VM(RegMask, SUBTRACT_extended) {\n+TEST_VM(RegMask, subtract_extended) {\n@@ -697,1 +697,1 @@\n-  rm2.Set_All();\n+  rm2.set_all();\n@@ -700,1 +700,1 @@\n-    rm1.Insert(i);\n+    rm1.insert(i);\n@@ -704,1 +704,1 @@\n-  rm2.SUBTRACT(rm1);\n+  rm2.subtract(rm1);\n@@ -713,1 +713,1 @@\n-  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_FALSE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -715,1 +715,1 @@\n-  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_TRUE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -725,5 +725,5 @@\n-  rm1.Insert(OptoReg::Name(23));\n-  rm1.Insert(OptoReg::Name(2));\n-  rm1.Insert(OptoReg::Name(first_extended() + 12));\n-  rm2.Insert(OptoReg::Name(1));\n-  rm2.Insert(OptoReg::Name(first_extended() + 4));\n+  rm1.insert(OptoReg::Name(23));\n+  rm1.insert(OptoReg::Name(2));\n+  rm1.insert(OptoReg::Name(first_extended() + 12));\n+  rm2.insert(OptoReg::Name(1));\n+  rm2.insert(OptoReg::Name(first_extended() + 4));\n@@ -732,1 +732,1 @@\n-  rm1.Insert(OptoReg::Name(first_extended() + 4));\n+  rm1.insert(OptoReg::Name(first_extended() + 4));\n@@ -741,1 +741,1 @@\n-  rm.Insert(OptoReg::Name(1));\n+  rm.insert(OptoReg::Name(1));\n@@ -743,1 +743,1 @@\n-  rm.Insert(OptoReg::Name(first_extended()));\n+  rm.insert(OptoReg::Name(first_extended()));\n@@ -745,1 +745,1 @@\n-  rm.Clear();\n+  rm.clear();\n@@ -750,1 +750,1 @@\n-TEST_VM(RegMask, SUBTRACT_inner_basic_extended) {\n+TEST_VM(RegMask, subtract_inner_basic_extended) {\n@@ -753,2 +753,2 @@\n-  rm1.Insert(OptoReg::Name(1));\n-  rm1.Insert(OptoReg::Name(42));\n+  rm1.insert(OptoReg::Name(1));\n+  rm1.insert(OptoReg::Name(42));\n@@ -756,2 +756,2 @@\n-  rm2.Insert(OptoReg::Name(1));\n-  rm2.Insert(OptoReg::Name(first_extended() + 20));\n+  rm2.insert(OptoReg::Name(1));\n+  rm2.insert(OptoReg::Name(first_extended() + 20));\n@@ -759,1 +759,1 @@\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.subtract_inner(rm2);\n@@ -762,1 +762,1 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(42)));\n@@ -765,1 +765,1 @@\n-TEST_VM(RegMask, SUBTRACT_inner_extended_basic) {\n+TEST_VM(RegMask, subtract_inner_extended_basic) {\n@@ -768,3 +768,3 @@\n-  rm1.Insert(OptoReg::Name(1));\n-  rm1.Insert(OptoReg::Name(42));\n-  rm1.Insert(OptoReg::Name(first_extended() + 20));\n+  rm1.insert(OptoReg::Name(1));\n+  rm1.insert(OptoReg::Name(42));\n+  rm1.insert(OptoReg::Name(first_extended() + 20));\n@@ -772,1 +772,1 @@\n-  rm2.Insert(OptoReg::Name(1));\n+  rm2.insert(OptoReg::Name(1));\n@@ -774,1 +774,1 @@\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.subtract_inner(rm2);\n@@ -776,2 +776,2 @@\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n-  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended() + 20)));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended() + 20)));\n@@ -787,2 +787,2 @@\n-  rm.Insert(reg1);\n-  ASSERT_TRUE(rm.Member(reg1));\n+  rm.insert(reg1);\n+  ASSERT_TRUE(rm.member(reg1));\n@@ -791,1 +791,1 @@\n-TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint_extended) {\n+TEST_VM(RegMask, rollover_and_subtract_inner_disjoint_extended) {\n@@ -798,2 +798,2 @@\n-  rm1.Clear();\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.clear();\n+  rm1.subtract_inner(rm2);\n@@ -801,1 +801,1 @@\n-  rm2.SUBTRACT_inner(rm1);\n+  rm2.subtract_inner(rm1);\n@@ -803,3 +803,3 @@\n-  rm1.Insert(reg1);\n-  rm2.Insert(42);\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.insert(reg1);\n+  rm2.insert(42);\n+  rm1.subtract_inner(rm2);\n@@ -807,1 +807,1 @@\n-  rm2.SUBTRACT_inner(rm1);\n+  rm2.subtract_inner(rm1);\n@@ -811,1 +811,1 @@\n-TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap_extended) {\n+TEST_VM(RegMask, rollover_and_subtract_inner_overlap_extended) {\n@@ -818,2 +818,2 @@\n-  rm2.Clear();\n-  rm1.SUBTRACT_inner(rm2);\n+  rm2.clear();\n+  rm1.subtract_inner(rm2);\n@@ -821,1 +821,1 @@\n-  rm2.SUBTRACT_inner(rm1);\n+  rm2.subtract_inner(rm1);\n@@ -823,3 +823,3 @@\n-  rm1.Insert(reg1);\n-  rm2.Insert(reg1);\n-  rm1.SUBTRACT_inner(rm2);\n+  rm1.insert(reg1);\n+  rm2.insert(reg1);\n+  rm1.subtract_inner(rm2);\n@@ -827,2 +827,2 @@\n-  rm1.Insert(reg1);\n-  rm2.SUBTRACT_inner(rm1);\n+  rm1.insert(reg1);\n+  rm2.subtract_inner(rm1);\n@@ -858,1 +858,1 @@\n-  ASSERT_EQ(mask_ref.count_one_bits(), mask.Size());\n+  ASSERT_EQ(mask_ref.count_one_bits(), mask.size());\n@@ -873,1 +873,1 @@\n-  mask_aux.Clear();\n+  mask_aux.clear();\n@@ -939,1 +939,1 @@\n-    mask_aux.Insert(reg);\n+    mask_aux.insert(reg);\n@@ -997,1 +997,1 @@\n-      mask.Insert(reg);\n+      mask.insert(reg);\n@@ -1013,1 +1013,1 @@\n-      mask.Remove(reg);\n+      mask.remove(reg);\n@@ -1020,1 +1020,1 @@\n-      mask.Clear();\n+      mask.clear();\n@@ -1026,1 +1026,1 @@\n-        \/\/ Set_All expects a zero-offset.\n+        \/\/ set_all expects a zero-offset.\n@@ -1030,1 +1030,1 @@\n-        tty->print_cr(\"action: Set_All\");\n+        tty->print_cr(\"action: set_all\");\n@@ -1032,1 +1032,1 @@\n-      mask.Set_All();\n+      mask.set_all();\n@@ -1038,1 +1038,1 @@\n-        tty->print_cr(\"action: AND\");\n+        tty->print_cr(\"action: and_with\");\n@@ -1042,1 +1042,1 @@\n-      mask.AND(mask_aux);\n+      mask.and_with(mask_aux);\n@@ -1051,1 +1051,1 @@\n-        tty->print_cr(\"action: OR\");\n+        tty->print_cr(\"action: or_with\");\n@@ -1055,1 +1055,1 @@\n-      mask.OR(mask_aux);\n+      mask.or_with(mask_aux);\n@@ -1064,1 +1064,1 @@\n-        tty->print_cr(\"action: SUBTRACT\");\n+        tty->print_cr(\"action: subtract\");\n@@ -1068,1 +1068,1 @@\n-      mask.SUBTRACT(mask_aux);\n+      mask.subtract(mask_aux);\n@@ -1079,1 +1079,1 @@\n-        tty->print_cr(\"action: SUBTRACT_inner\");\n+        tty->print_cr(\"action: subtract_inner\");\n@@ -1083,1 +1083,1 @@\n-      \/\/ SUBTRACT_inner expects an argument register mask with infinite_stack =\n+      \/\/ subtract_inner expects an argument register mask with infinite_stack =\n@@ -1086,2 +1086,2 @@\n-      mask.SUBTRACT_inner(mask_aux);\n-      \/\/ SUBTRACT_inner does not have \"stack-extension semantics\".\n+      mask.subtract_inner(mask_aux);\n+      \/\/ subtract_inner does not have \"stack-extension semantics\".\n@@ -1109,1 +1109,1 @@\n-      mask.Clear();\n+      mask.clear();\n@@ -1123,1 +1123,1 @@\n-      mask.Clear();\n+      mask.clear();\n@@ -1130,1 +1130,1 @@\n-        tty->print_cr(\"action: Set_All_From_Offset\");\n+        tty->print_cr(\"action: set_all_from_offset\");\n@@ -1132,1 +1132,1 @@\n-      mask.Set_All_From_Offset();\n+      mask.set_all_from_offset();\n@@ -1139,1 +1139,1 @@\n-        tty->print_cr(\"action: Set_All_From\");\n+        tty->print_cr(\"action: set_all_from\");\n@@ -1144,1 +1144,1 @@\n-      mask.Set_All_From(reg);\n+      mask.set_all_from(reg);\n@@ -1157,1 +1157,1 @@\n-  rm.Clear();\n+  rm.clear();\n@@ -1162,1 +1162,1 @@\n-    rm.Insert(reg);\n+    rm.insert(reg);\n@@ -1178,1 +1178,1 @@\n-    rm.Insert(reg);\n+    rm.insert(reg);\n@@ -1181,1 +1181,1 @@\n-      rm.Remove(reg);\n+      rm.remove(reg);\n@@ -1244,2 +1244,2 @@\n-    \/\/ Copy source to destination\n-    dst = src;\n+    \/\/ Set destination to source\n+    dst.assignFrom(src);\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":281,"deletions":281,"binary":false,"changes":562,"status":"modified"},{"patch":"@@ -36,5 +36,0 @@\n-####\n-## Tests for functionality which currently is not supported for virtual threads\n-\n-vmTestbase\/nsk\/jvmti\/GetCurrentThreadCpuTime\/curthrcputime001\/TestDescription.java 8348844 generic-all\n-vmTestbase\/nsk\/jvmti\/GetThreadCpuTime\/thrcputime001\/TestDescription.java 8348844 generic-all\n@@ -85,11 +80,0 @@\n-##########\n-## Tests incompatible with  with virtual test thread factory.\n-## There is no goal to run all test with virtual test thread factory.\n-## So any test migth be added as incompatible, the bug is not required.\n-\n-gc\/arguments\/TestNewSizeThreadIncrease.java 0000000 generic-all\n-gc\/g1\/TestSkipRebuildRemsetPhase.java 0000000 generic-all\n-runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java 0000000 generic-all\n-runtime\/Thread\/AsyncExceptionOnMonitorEnter.java 0000000 generic-all\n-runtime\/Thread\/StopAtExit.java 0000000 generic-all\n-runtime\/handshake\/HandshakeWalkStackTest.java 0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+compiler\/valhalla\/inlinetypes\/TestNullableArrays.java 8367553 generic-aarch64\n@@ -158,0 +159,1 @@\n+runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java                                    8369043 generic-aarch64\n@@ -165,1 +167,1 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8270326,8344261 generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8270326 generic-all\n@@ -185,3 +187,0 @@\n-serviceability\/sa\/JhsdbThreadInfoTest.java              8344261 generic-all\n-serviceability\/sa\/TestJhsdbJstackLock.java              8344261 generic-all\n-serviceability\/attach\/RemovingUnixDomainSocketTest.java 8344261 generic-all\n@@ -229,0 +228,1 @@\n+serviceability\/sa\/TestJhsdbJstackWithVirtualThread.java 8365722 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -593,0 +593,1 @@\n+ -runtime\/cds\/appcds\/VerifyObjArrayCloneTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"amd64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n+ * @requires os.arch == \"aarch64\" | os.arch == \"amd64\" | os.arch == \"x86_64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestBit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n+ * @requires os.arch == \"amd64\" | os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RotateLeftNodeIntIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n+ * @requires os.arch == \"amd64\" | os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RotateLeftNodeLongIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,9 +26,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Handle;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n-import java.io.FileInputStream;\n@@ -36,0 +27,11 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -42,1 +44,0 @@\n-import java.nio.file.Paths;\n@@ -45,0 +46,2 @@\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -50,1 +53,1 @@\n-public class InvokeDynamicPatcher extends ClassVisitor {\n+public final class InvokeDynamicPatcher {\n@@ -52,2 +55,1 @@\n-    private static final String CLASS = InvokeDynamic.class.getName()\n-            .replace('.', '\/');\n+    private static final ClassDesc CLASS = InvokeDynamic.class.describeConstable().orElseThrow();\n@@ -59,6 +61,6 @@\n-    private static final String CALL_NATIVE_FIELD_DESC = \"Z\";\n-    private static final String CALLEE_METHOD_DESC\n-            = \"(L\" + CLASS + \";IJFDLjava\/lang\/String;)Z\";\n-    private static final String ASSERTTRUE_METHOD_DESC\n-            = \"(ZLjava\/lang\/String;)V\";\n-    private static final String ASSERTS_CLASS = \"jdk\/test\/lib\/Asserts\";\n+    private static final ClassDesc CALL_NATIVE_FIELD_DESC = CD_boolean;\n+    private static final MethodTypeDesc CALLEE_METHOD_DESC = MethodTypeDesc.of(\n+            CD_boolean, CLASS, CD_int, CD_long, CD_float, CD_double, CD_String);\n+    private static final MethodTypeDesc ASSERTTRUE_METHOD_DESC = MethodTypeDesc.of(\n+            CD_void, CD_boolean, CD_String);\n+    private static final ClassDesc ASSERTS_CLASS = ClassDesc.ofInternalName(\"jdk\/test\/lib\/Asserts\");\n@@ -67,28 +69,9 @@\n-    public static void main(String args[]) {\n-        ClassReader cr;\n-        Path filePath;\n-        try {\n-            filePath = Paths.get(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n-                    .getLocation().toURI()).resolve(CLASS + \".class\");\n-        } catch (URISyntaxException ex) {\n-            throw new Error(\"TESTBUG: Can't get code source\" + ex, ex);\n-        }\n-        try (FileInputStream fis = new FileInputStream(filePath.toFile())) {\n-            cr = new ClassReader(fis);\n-        } catch (IOException e) {\n-            throw new Error(\"Error reading file\", e);\n-        }\n-        ClassWriter cw = new ClassWriter(cr,\n-                ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n-        cr.accept(new InvokeDynamicPatcher(Opcodes.ASM5, cw), 0);\n-        try {\n-            Files.write(filePath, cw.toByteArray(),\n-                    StandardOpenOption.WRITE);\n-        } catch (IOException e) {\n-            throw new Error(e);\n-        }\n-    }\n-\n-    public InvokeDynamicPatcher(int api, ClassWriter cw) {\n-        super(api, cw);\n-    }\n+    public static void main(String args[]) throws IOException, URISyntaxException {\n+        Path filePath = Path.of(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n+                    .getLocation().toURI()).resolve(InvokeDynamic.class.getName().replace('.', '\/') +\".class\");\n+        var bytes = ClassFile.of().transformClass(ClassFile.of().parse(filePath),\n+                ClassTransform.transformingMethodBodies(m -> m.methodName().equalsString(CALLER_METHOD_NAME), new CodeTransform() {\n+                    @Override\n+                    public void accept(CodeBuilder builder, CodeElement element) {\n+                        \/\/ discard\n+                    }\n@@ -96,75 +79,63 @@\n-    @Override\n-    public MethodVisitor visitMethod(final int access, final String name,\n-            final String desc, final String signature,\n-            final String[] exceptions) {\n-        \/* a code generate looks like\n-         *  0: aload_0\n-         *  1: ldc           #125  \/\/ int 1\n-         *  3: ldc2_w        #126  \/\/ long 2l\n-         *  6: ldc           #128  \/\/ float 3.0f\n-         *  8: ldc2_w        #129  \/\/ double 4.0d\n-         * 11: ldc           #132  \/\/ String 5\n-         * 13: aload_0\n-         * 14: getfield      #135  \/\/ Field nativeCallee:Z\n-         * 17: ifeq          28\n-         * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-         * 25: goto          33\n-         * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-         * 33: ldc           #185                \/\/ String Call insuccessfull\n-         * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n-         * 38: return\n-         *\n-         * or, using java-like pseudo-code\n-         * if (this.nativeCallee == false) {\n-         *     invokedynamic-call-return-value = invokedynamic-of-callee\n-         * } else {\n-         *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n-         * }\n-         * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n-         * return;\n-         *\/\n-        if (name.equals(CALLER_METHOD_NAME)) {\n-            MethodVisitor mv = cv.visitMethod(access, name, desc,\n-                    signature, exceptions);\n-            Label nonNativeLabel = new Label();\n-            Label checkLabel = new Label();\n-            MethodType mtype = MethodType.methodType(CallSite.class,\n-                    MethodHandles.Lookup.class, String.class, MethodType.class);\n-            Handle bootstrap = new Handle(Opcodes.H_INVOKESTATIC, CLASS,\n-                    BOOTSTRAP_METHOD_NAME, mtype.toMethodDescriptorString());\n-            mv.visitCode();\n-            \/\/ push callee parameters onto stack\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\/\/push \"this\"\n-            mv.visitLdcInsn(1);\n-            mv.visitLdcInsn(2L);\n-            mv.visitLdcInsn(3.0f);\n-            mv.visitLdcInsn(4.0d);\n-            mv.visitLdcInsn(\"5\");\n-            \/\/ params loaded. let's decide what method to call\n-            mv.visitVarInsn(Opcodes.ALOAD, 0); \/\/ push \"this\"\n-            \/\/ get nativeCallee field\n-            mv.visitFieldInsn(Opcodes.GETFIELD, CLASS, CALL_NATIVE_FIELD,\n-                    CALL_NATIVE_FIELD_DESC);\n-            \/\/ if nativeCallee == false goto nonNativeLabel\n-            mv.visitJumpInsn(Opcodes.IFEQ, nonNativeLabel);\n-            \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n-            mv.visitInvokeDynamicInsn(NATIVE_CALLEE_METHOD_NAME,\n-                    CALLEE_METHOD_DESC, bootstrap);\n-            \/\/ goto checkLabel\n-            mv.visitJumpInsn(Opcodes.GOTO, checkLabel);\n-            \/\/ label: nonNativeLabel\n-            mv.visitLabel(nonNativeLabel);\n-            \/\/ invokedynamic calleeMethod using bootstrap method\n-            mv.visitInvokeDynamicInsn(CALLEE_METHOD_NAME, CALLEE_METHOD_DESC,\n-                    bootstrap);\n-            mv.visitLabel(checkLabel);\n-            mv.visitLdcInsn(CallsBase.CALL_ERR_MSG);\n-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, ASSERTS_CLASS,\n-                    ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC, false);\n-            \/\/ label: return\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-            return null;\n-        }\n-        return super.visitMethod(access, name, desc, signature, exceptions);\n+                    \/* the code generated looks like\n+                     *  0: aload_0\n+                     *  1: ldc           #125  \/\/ int 1\n+                     *  3: ldc2_w        #126  \/\/ long 2l\n+                     *  6: ldc           #128  \/\/ float 3.0f\n+                     *  8: ldc2_w        #129  \/\/ double 4.0d\n+                     * 11: ldc           #132  \/\/ String 5\n+                     * 13: aload_0\n+                     * 14: getfield      #135  \/\/ Field nativeCallee:Z\n+                     * 17: ifeq          28\n+                     * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+                     * 25: goto          33\n+                     * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+                     * 33: ldc           #185                \/\/ String Call insuccessfull\n+                     * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n+                     * 38: return\n+                     *\n+                     * or, using java-like pseudo-code\n+                     * if (this.nativeCallee == false) {\n+                     *     invokedynamic-call-return-value = invokedynamic-of-callee\n+                     * } else {\n+                     *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n+                     * }\n+                     * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n+                     * return;\n+                     *\/\n+                    @Override\n+                    public void atEnd(CodeBuilder builder) {\n+                        Label nonNativeLabel = builder.newLabel();\n+                        Label checkLabel = builder.newLabel();\n+                        MethodType mtype = MethodType.methodType(CallSite.class,\n+                                MethodHandles.Lookup.class, String.class, MethodType.class);\n+                        DirectMethodHandleDesc dmh = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.STATIC,\n+                                CLASS, BOOTSTRAP_METHOD_NAME, mtype.descriptorString());\n+                        \/\/ push callee parameters onto stack\n+                        builder.aload(builder.receiverSlot())\n+                               .ldc(1)\n+                               .ldc(2L)\n+                               .ldc(3.0f)\n+                               .ldc(4.0d)\n+                               .ldc(\"5\")\n+                               \/\/ params loaded. let's decide what method to call\n+                               .aload(builder.receiverSlot())\n+                               \/\/ get nativeCallee field\n+                               .getfield(CLASS, CALL_NATIVE_FIELD, CALL_NATIVE_FIELD_DESC)\n+                               \/\/ if nativeCallee == false goto nonNativeLabel\n+                               .ifeq(nonNativeLabel)\n+                               \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n+                               .invokedynamic(DynamicCallSiteDesc.of(dmh, NATIVE_CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n+                               \/\/ goto checkLabel\n+                               .goto_(checkLabel)\n+                               \/\/ label: nonNativeLabel\n+                               .labelBinding(nonNativeLabel)\n+                               \/\/ invokedynamic calleeMethod using bootstrap method\n+                               .invokedynamic(DynamicCallSiteDesc.of(dmh, CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n+                               .labelBinding(checkLabel)\n+                               .ldc(CallsBase.CALL_ERR_MSG)\n+                               .invokestatic(ASSERTS_CLASS, ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC)\n+                               \/\/ label: return\n+                               .return_();\n+                    }\n+                }));\n+        Files.write(filePath, bytes, StandardOpenOption.WRITE);\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/common\/InvokeDynamicPatcher.java","additions":93,"deletions":122,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n@@ -32,0 +31,1 @@\n+ * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super class IllegalAccessInCatch\n+    version 52:0\n+{\n+    \/*\n+      static int test() {\n+        try {\n+          return 1 \/ 0;\n+        } catch (jdk.internal.agent.AgentConfigurationError e1) {\n+          try {\n+            return 0;\n+          } catch (IllegalAccessError e2) {\n+            return 1;\n+          }\n+        }\n+      }\n+    *\/\n+    static Method test:\"()I\"\n+    stack 2 locals 1\n+  {\n+    iconst_1;\n+    iconst_0;\n+    try t0;\n+    idiv;\n+    endtry t0;\n+    ireturn;\n+    catch t0 jdk\/internal\/agent\/AgentConfigurationError; \/\/ loadable but not accessible from unnamed module\n+    stack_frame_type full;\n+    stack_map class java\/lang\/Throwable;\n+    try t1;\n+    iconst_0;\n+    ireturn;\n+    endtry t1;\n+    catch t1 java\/lang\/IllegalAccessError;\n+    stack_frame_type full;\n+    stack_map class java\/lang\/Throwable;\n+    iconst_1;\n+    ireturn;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/IllegalAccessInCatch.jasm","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8367002\n+ * @summary Compilers might not generate handlers for recursive exceptions\n+ *\n+ * @compile IllegalAccessInCatch.jasm\n+ * @run main\/othervm -Xbatch\n+ *   -XX:CompileCommand=compileonly,IllegalAccessInCatch*::test\n+ *   -XX:-TieredCompilation\n+ *   TestAccessErrorInCatch\n+ * @run main\/othervm -Xbatch\n+ *   -XX:CompileCommand=compileonly,IllegalAccessInCatch*::test\n+ *   -XX:TieredStopAtLevel=3\n+ *   TestAccessErrorInCatch\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import java.nio.file.Files;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class TestAccessErrorInCatch {\n+\n+    public static void main(String[] args) throws Throwable {\n+        Path TEST_CLASSES_DIR = FileSystems.getDefault().getPath(System.getProperty(\"test.classes\"));\n+        byte[] bytes = Files.readAllBytes(TEST_CLASSES_DIR.resolve(\"IllegalAccessInCatch.class\"));\n+\n+        var l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        Class<?> anonClass = l.lookupClass();\n+        MethodHandle mh = l.findStatic(anonClass, \"test\", MethodType.methodType(int.class));\n+        for (int i = 0; i < 16_000; i++) {\n+            invoke(mh);\n+        }\n+        System.out.println(invoke(mh));\n+    }\n+\n+    private static int invoke(MethodHandle mh) throws Throwable {\n+        return (int) mh.invokeExact();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestAccessErrorInCatch.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -884,0 +884,10 @@\n+        {\n+            Outer o = new Outer();\n+            Object oldVal = new Object();\n+            o.f = oldVal;\n+            Object cmpVal = new Object();\n+            Object newVal = new Object();\n+            Object oldVal2 = testCompareAndExchange(o, cmpVal, newVal);\n+            Asserts.assertEquals(oldVal2, oldVal);\n+            Asserts.assertEquals(o.f, oldVal);\n+        }\n@@ -893,0 +903,10 @@\n+        {\n+            Outer o = new Outer();\n+            Object oldVal = new Object();\n+            o.f = oldVal;\n+            Object cmpVal = new Object();\n+            Object newVal = new Object();\n+            boolean b = testCompareAndSwap(o, cmpVal, newVal);\n+            Asserts.assertFalse(b);\n+            Asserts.assertEquals(o.f, oldVal);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestG1BarrierGeneration.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -29,1 +29,0 @@\n- * @library \/testlibrary\/asm\n@@ -40,6 +39,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n@@ -49,0 +42,4 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -162,16 +159,7 @@\n-                ClassReader cr = new ClassReader(classfileBuffer);\n-                ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);\n-                ClassVisitor adapter = new ClassVisitor(Opcodes.ASM5, cw) {\n-                    @Override\n-                    public MethodVisitor visitMethod(int access, String base, String desc, String signature, String[] exceptions) {\n-                        MethodVisitor mv = cv.visitMethod(access, base, desc, signature, exceptions);\n-                        if (mv != null) {\n-                            mv = new MethodVisitor(Opcodes.ASM5, mv) {\n-                                @Override\n-                                public void visitLdcInsn(Object cst) {\n-                                    System.out.println(\"replacing \\\"\" + cst + \"\\\" with \\\"bar\\\"\");\n-                                    mv.visitLdcInsn(\"bar\");\n-                                }\n-                            };\n-                        }\n-                        return mv;\n+                var context = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofResourceParsing(cl)));\n+                return context.transformClass(context.parse(classfileBuffer), ClassTransform.transformingMethodBodies((codeBuilder, codeElement) -> {\n+                    if (codeElement instanceof ConstantInstruction.LoadConstantInstruction ldc) {\n+                        System.out.println(\"replacing \\\"\" + ldc.constantEntry().constantValue() + \"\\\" with \\\"bar\\\"\");\n+                        codeBuilder.ldc(\"bar\");\n+                    } else {\n+                        codeBuilder.with(codeElement);\n@@ -179,5 +167,1 @@\n-                };\n-\n-                cr.accept(adapter, ClassReader.SKIP_FRAMES);\n-                cw.visitEnd();\n-                return cw.toByteArray();\n+                }));\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/RedefineMethodUsedByMultipleMethodHandles.java","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,8 +26,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.tree.ClassNode;\n-import jdk.test.lib.Utils;\n@@ -37,1 +29,0 @@\n-import jdk.vm.ci.hotspot.HotSpotNmethod;\n@@ -41,0 +32,8 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodType;\n@@ -43,1 +42,0 @@\n-import java.lang.reflect.Field;\n@@ -46,2 +44,2 @@\n-import java.lang.reflect.Parameter;\n-import java.util.HashMap;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -74,13 +72,4 @@\n-        Map<Integer, Integer> lineNumbers = new TreeMap<>();\n-        Class<?> aClass = method.getDeclaringClass();\n-        ClassReader cr;\n-        try {\n-            Module aModule = aClass.getModule();\n-            String name = aClass.getName();\n-            cr = new ClassReader(aModule.getResourceAsStream(\n-                    name.replace('.', '\/') + \".class\"));\n-        } catch (IOException e) {\n-                        throw new Error(\"TEST BUG: can read \" + aClass.getName() + \" : \" + e, e);\n-        }\n-        ClassNode cn = new ClassNode();\n-        cr.accept(cn, ClassReader.EXPAND_FRAMES);\n+        ClassModel classModel = findClassBytes(method.getDeclaringClass());\n+        MethodModel methodModel = findMethod(classModel, method);\n+        if (methodModel == null)\n+            return Map.of();\n@@ -88,10 +77,10 @@\n-        Map<Label, Integer> labels = new HashMap<>();\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        ClassVisitor cv = new ClassVisitorForLabels(cw, labels, method);\n-        cr.accept(cv, ClassReader.EXPAND_FRAMES);\n-        labels.forEach((k, v) -> lineNumbers.put(k.getOffset(), v));\n-        boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n-                || Modifier.isNative(method.getModifiers());\n-        if (lineNumbers.isEmpty() && !isEmptyMethod) {\n-            throw new Error(method + \" doesn't contains the line numbers table \"\n-                    +\"(the method marked neither abstract nor native)\");\n+        var foundLineNumberTable = methodModel.code().flatMap(code ->\n+                code.findAttribute(Attributes.lineNumberTable()));\n+        if (foundLineNumberTable.isEmpty()) {\n+            boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n+                    || Modifier.isNative(method.getModifiers());\n+            if (!isEmptyMethod) {\n+                throw new Error(method + \" doesn't contains the line numbers table \"\n+                        + \"(the method marked neither abstract nor native)\");\n+            }\n+            return Map.of();\n@@ -99,0 +88,4 @@\n+\n+        Map<Integer, Integer> lineNumbers = new TreeMap<>();\n+        foundLineNumberTable.get().lineNumbers().forEach(ln ->\n+                lineNumbers.put(ln.startPc(), ln.lineNumber()));\n@@ -102,24 +95,9 @@\n-    private static class ClassVisitorForLabels extends ClassVisitor {\n-        private final Map<Label, Integer> lineNumbers;\n-        private final String targetName;\n-        private final String targetDesc;\n-\n-        public ClassVisitorForLabels(ClassWriter cw, Map<Label, Integer> lines,\n-                                     Executable target) {\n-            super(Opcodes.ASM7, cw);\n-            this.lineNumbers = lines;\n-\n-            StringBuilder builder = new StringBuilder(\"(\");\n-            for (Parameter parameter : target.getParameters()) {\n-                builder.append(Utils.toJVMTypeSignature(parameter.getType()));\n-            }\n-            builder.append(\")\");\n-            if (target instanceof Constructor) {\n-                targetName = \"<init>\";\n-                builder.append(\"V\");\n-            } else {\n-                targetName = target.getName();\n-                builder.append(Utils.toJVMTypeSignature(\n-                        ((Method) target).getReturnType()));\n-            }\n-            targetDesc = builder.toString();\n+    \/\/ Finds the ClassFile API model of a given class, or fail with an Error.\n+    public static ClassModel findClassBytes(Class<?> clazz) {\n+        String binaryName = clazz.getName();\n+        byte[] fileBytes;\n+        try (var inputStream = clazz.getModule().getResourceAsStream(\n+                binaryName.replace('.', '\/') + \".class\")) {\n+            fileBytes = inputStream.readAllBytes();\n+        } catch (IOException e) {\n+            throw new Error(\"TEST BUG: cannot read \" + binaryName, e);\n@@ -127,0 +105,9 @@\n+        return ClassFile.of().parse(fileBytes);\n+    }\n+\n+    \/\/ Finds a matching method in a class model, or null if none match.\n+    public static MethodModel findMethod(ClassModel classModel, Executable method) {\n+        MethodTypeDesc methodType = MethodType.methodType(\n+                method instanceof Method m ? m.getReturnType() : void.class,\n+                method.getParameterTypes()).describeConstable().orElseThrow();\n+        String methodName = method instanceof Method m ? m.getName() : ConstantDescs.INIT_NAME;\n@@ -128,14 +115,4 @@\n-        @Override\n-        public final MethodVisitor visitMethod(int access, String name,\n-                                               String desc, String signature,\n-                                               String[] exceptions) {\n-            MethodVisitor mv = cv.visitMethod(access, name, desc, signature,\n-                    exceptions);\n-            if (targetDesc.equals(desc) && targetName.equals(name)) {\n-                return new MethodVisitor(Opcodes.ASM7, mv) {\n-                    @Override\n-                    public void visitLineNumber(int i, Label label) {\n-                        super.visitLineNumber(i, label);\n-                        lineNumbers.put(label, i);\n-                    }\n-                };\n+        for (var methodModel : classModel.methods()) {\n+            if (methodModel.methodName().equalsString(methodName)\n+                    && methodModel.methodType().isMethodType(methodType)) {\n+                return methodModel;\n@@ -143,1 +120,0 @@\n-            return  mv;\n@@ -145,0 +121,1 @@\n+        return null;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CTVMUtilities.java","additions":51,"deletions":74,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+        if (Double.compare(lo, hi) >= 0) {\n+            throw new EmptyGeneratorException();\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformDoubleGenerator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+        if (Float.compare(lo, hi) >= 0) {\n+            throw new EmptyGeneratorException();\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformFloatGenerator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2900,0 +2900,30 @@\n+    public static final String COMPRESS_VB = VECTOR_PREFIX + \"COMPRESS_VB\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VB, \"CompressV\", TYPE_BYTE);\n+    }\n+\n+    public static final String COMPRESS_VS = VECTOR_PREFIX + \"COMPRESS_VS\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VS, \"CompressV\", TYPE_SHORT);\n+    }\n+\n+    public static final String COMPRESS_VI = VECTOR_PREFIX + \"COMPRESS_VI\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VI, \"CompressV\", TYPE_INT);\n+    }\n+\n+    public static final String COMPRESS_VL = VECTOR_PREFIX + \"COMPRESS_VL\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VL, \"CompressV\", TYPE_LONG);\n+    }\n+\n+    public static final String COMPRESS_VF = VECTOR_PREFIX + \"COMPRESS_VF\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VF, \"CompressV\", TYPE_FLOAT);\n+    }\n+\n+    public static final String COMPRESS_VD = VECTOR_PREFIX + \"COMPRESS_VD\" + POSTFIX;\n+    static {\n+        vectorNode(COMPRESS_VD, \"CompressV\", TYPE_DOUBLE);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -330,2 +330,4 @@\n-            TestFormat.checkNoThrow(scenarioIndices.add(scenarioIndex),\n-                             \"Cannot define two scenarios with the same index \" + scenarioIndex);\n+            if (!scenarioIndices.add(scenarioIndex)) {\n+                TestFormat.failNoThrow(\"Cannot define two scenarios with the same index \" + scenarioIndex);\n+                continue;\n+            }\n@@ -339,1 +341,1 @@\n-     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when when constructing\n+     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when constructing\n@@ -341,1 +343,4 @@\n-     * flags that have to be specified togeher. Further, an empty string in a set stands in for \"no flag\".\n+     * flags that have to be specified together. Further, an empty string in a set stands in for \"no flag\".\n+     * <p>\n+     * Passing a single set will create a scenario for each of the provided flags in the set (i.e. the same as\n+     * passing an additional set with an empty string only).\n@@ -358,1 +363,1 @@\n-     * @param sets sets of flags to generate the cross product for.\n+     * @param flagSets sets of flags to generate the cross product for.\n@@ -379,1 +384,1 @@\n-                Stream.of(Collections.<String>emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n+                Stream.of(Collections.emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n@@ -387,2 +392,2 @@\n-                    ), \/\/ ...that get flattend into one big List<List<String>>.\n-                (a, b) -> Stream.concat(a, b)); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n+                    ), \/\/ ...that get flattened into one big List<List<String>>.\n+                Stream::concat); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n@@ -394,1 +399,1 @@\n-                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split muliple flags in the same string into separate strings.\n+                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split multiple flags in the same string into separate strings.\n@@ -397,1 +402,1 @@\n-                     .collect(Collectors.toList())\n+                     .toList()\n@@ -399,1 +404,1 @@\n-            .collect(Collectors.toList()).toArray(new Scenario[0]);\n+            .toList().toArray(new Scenario[0]);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        \"avx512_vbmi2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,1 +115,4 @@\n- *\n+ * - Generate cases that would catch bugs like JDK-8369902:\n+ *   - Large long constants, or scales. Probably only possible for MemorySegment.\n+ *   - Large number of invar, and reuse of invar so that they could cancle\n+ *     to zero, and need to be filtered out.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8369902\n+ * @summary Bug in MemPointerParser::canonicalize_raw_summands let to wrong result, because a\n+ *          NaN summand was filtered out, instead of making the MemPointer \/ VPointer invalid.\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestDoNotFilterNaNSummands::test\n+ *      -Xbatch\n+ *      compiler.loopopts.superword.TestDoNotFilterNaNSummands\n+ * @run main compiler.loopopts.superword.TestDoNotFilterNaNSummands\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+\/\/ This was the test found by the fuzzer. If you are looking for a simpler example with the same issue,\n+\/\/ please look at TestMemorySegmentFilterSummands::test2.\n+public class TestDoNotFilterNaNSummands {\n+    static final int N = 100;\n+    static int zero = 0;\n+\n+    static int[] test() {\n+        int x = -4;\n+        int aI[] = new int[N];\n+        for (int k = 0; k < N; k++) {\n+            \/\/ Note that x is always \"-4\", and N is a compile time constant. The modulo \"%\"\n+            \/\/ gets optimized with magic numbers and shift\/mul\/sub trick, in the long domain,\n+            \/\/ which somehow creates some large long constant that cannot be represented\n+            \/\/ as an int.\n+            int idx = (x >>> 1) % N;\n+            \/\/ This is the CountedLoop that we may try to auto vectorize.\n+            \/\/ We have a linear access (i) and a constant index access (idx), which eventually\n+            \/\/ cross, so there is aliasing. If there is vectorization with an aliasing runtime\n+            \/\/ check, this check must fail.\n+            for (int i = 1; i < 63; i++) {\n+                aI[i] = 2;\n+                \/\/ The MemPointer \/ VPointer for the accesses below contain a large constant\n+                \/\/ long constant offset that cannot be represented as an int, so the scaleL\n+                \/\/ NoOverflowInt becomes NaN. In MemPointerParser::canonicalize_raw_summands\n+                \/\/ we are supposed to filter out zero summands, but since we WRONGLY filtered\n+                \/\/ out NaNs instead, this summand got filtered out, and later we did not detect\n+                \/\/ that the MemPointer contains a NaN. Instead, we just get a \"valid\" looking\n+                \/\/ VPointer, and generate runtime checks that are missing the long constant\n+                \/\/ offset, leading to wrong decisions, and hence vectorization even though\n+                \/\/ we have aliasing. This means that the accesses from above and below get\n+                \/\/ reordered in an illegal way, leading to wrong results.\n+                aI[idx] += 1;\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                \/\/ It is a no-op, but the compiler can't know statically that zero=0.\n+                \/\/ Seems to be required in the graph, no idea why.\n+                x >>= zero;\n+            }\n+        }\n+        return aI;\n+    }\n+\n+    \/\/ Use the sum as an easy way to compare the results.\n+    public static int sum(int[] aI) {\n+        int sum = 0;\n+        for (int i = 0; i < aI.length; i++) { sum += aI[i]; }\n+        return sum;\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Run once, hopefully before compilation, so get interpreter results.\n+        int[] aIG = test();\n+        int gold = sum(aIG);\n+\n+        \/\/ Repeat execution, until eventually compilation happens, compare\n+        \/\/ compiler results to interpreter results.\n+        for (int k = 0; k < 1000; k++) {\n+            int[] aI = test();\n+            int val = sum(aI);\n+            if (gold != val) {\n+                System.out.println(\"Detected wrong result, printing values of arrays:\");\n+                for (int i = 0; i < aI.length; i++) {\n+                    System.out.println(\"at \" + i + \": \" + aIG[i] + \" vs \" + aI[i]);\n+                }\n+                throw new RuntimeException(\"wrong result: \" + gold + \" \" + val);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDoNotFilterNaNSummands.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.*;\n+import java.util.Set;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+\n+\/*\n+ * @test\n+ * @bug 8369902\n+ * @summary Bug in MemPointerParser::canonicalize_raw_summands let to wrong results or assert.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentFilterSummands\n+ *\/\n+\n+public class TestMemorySegmentFilterSummands {\n+\n+    static long init  = 1000;\n+    static long limit = 9000;\n+\n+    static long invar0 = 0;\n+    static long invar1 = 0;\n+    static long invar2 = 0;\n+    static long invar3 = 0;\n+    static long invar4 = 0;\n+    static long invarX = 0;\n+\n+    public static final long BIG = 0x200000000L;\n+    public static long big = -BIG;\n+\n+    static MemorySegment a1 = Arena.ofAuto().allocate(10_000);\n+    static MemorySegment b1 = Arena.ofAuto().allocate(10_000);\n+    static {\n+        for (long i = init; i < limit; i++) {\n+            a1.set(ValueLayout.JAVA_BYTE, i, (byte)((i & 0xf) + 1));\n+        }\n+    }\n+\n+    static MemorySegment a2 = MemorySegment.ofArray(new byte[40_000]);\n+    static MemorySegment b2 = a2;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addCrossProductScenarios(Set.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\"),\n+                                   Set.of(\"-XX:-ShortRunningLongLoop\", \"-XX:+ShortRunningLoop\"));\n+        f.start();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR,   \"> 0\",\n+                  IRNode.LOAD_VECTOR_B,  \"> 0\",\n+                  \".*multiversion.*\",    \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test1() {\n+        long invar = 0;\n+        invar += invarX; \/\/ cancles out with above\n+        invar += invar0;\n+        invar += invar1;\n+        invar += invar2;\n+        invar += invar3;\n+        invar += invar4;\n+        invar -= invarX; \/\/ cancles out with above\n+        \/\/ invar contains a raw summand for invarX, which has a scaleL=0. It needs to be filtered out.\n+        \/\/ The two occurances of invarX are conveniently put in a long chain, so that IGVN cannot see\n+        \/\/ that they cancle out, so that they are not optimized out before loop-opts.\n+        for (long i = init; i < limit; i++) {\n+            byte v = a1.get(ValueLayout.JAVA_BYTE, i + invar);\n+            b1.set(ValueLayout.JAVA_BYTE, i + invar, v);\n+        }\n+    }\n+\n+    @Check(test = \"test1\")\n+    static void check1() {\n+        Verify.checkEQ(a1, b1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ This test could in principle show vectorization, but it would probably need to do some special\n+    \/\/ tricks to only vectorize around the overlap. Still, it could happen that at some point we end\n+    \/\/ up multiversioning, and having a vectorized loop that is never entered.\n+    \/\/\n+    \/\/ For now, the long constant BIG leads to an invalid VPointer, which means we do not vectorize.\n+    static void test2() {\n+        \/\/ At runtime, \"BIG + big\" is zero. But BIG is a long constant that cannot be represented as\n+        \/\/ an int, and so the scaleL NoOverflowInt is a NaN. We should not filter it out from the summands,\n+        \/\/ but instead make the MemPointer \/ VPointer invalid, which prevents vectorization.\n+        long adr = 4L * 5000 + BIG + big;\n+\n+        for (long i = init; i < limit; i++) {\n+            \/\/ The reference to a2 iterates linearly, while the reference to \"b2\" stays at the same adr.\n+            \/\/ But the two alias: in the middle of the \"a2\" range it crosses over \"b2\" adr, so the\n+            \/\/ aliasing runtime check (if we generate one) should fail. But if \"BIG\" is just filtered\n+            \/\/ out from the summands, we instead just create a runtime check without it, which leads\n+            \/\/ to a wrong answer, and the check does not fail, and we get wrong results.\n+            a2.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * i, 0);\n+            int v = b2.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            b2.set(ValueLayout.JAVA_INT_UNALIGNED, adr, v + 1);\n+        }\n+    }\n+\n+    @Check(test = \"test2\")\n+    static void check2() {\n+        int s = 0;\n+        for (long i = init; i < limit; i++) {\n+            s += a2.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i);\n+        }\n+        if (s != 4000) {\n+            throw new RuntimeException(\"wrong value\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentFilterSummands.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8369898\n+ * @summary Bug in PhaseIdealLoop::create_new_if_for_multiversion, that messed up the\n+ *          _loop_or_ctrl data structure while doing SuperWord for a first loop, and\n+ *          then get_ctrl asserted for a second loop that was also SuperWord-ed in the\n+ *          same loop-opts-phase.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,*TestMultiversionSlowProjReplacementAndGetCtrl::test\n+ *      -XX:CompileCommand=exclude,*TestMultiversionSlowProjReplacementAndGetCtrl::dontinline\n+ *      -XX:-TieredCompilation\n+ *      -Xbatch\n+ *      compiler.loopopts.superword.TestMultiversionSlowProjReplacementAndGetCtrl\n+ * @run main compiler.loopopts.superword.TestMultiversionSlowProjReplacementAndGetCtrl\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestMultiversionSlowProjReplacementAndGetCtrl {\n+    static final int N = 400;\n+\n+    static void dontinline() {}\n+\n+    static long test() {\n+        int x = 0;\n+        int arrayI[] = new int[N];\n+        byte[] arrayB = new byte[N];\n+        dontinline();\n+        \/\/ CallStaticJava for dontinline\n+        \/\/ -> memory Proj\n+        \/\/ -> it is used in both the k-indexed and j-indexed loops by their loads\/stores.\n+        for (int k = 8; k < 92; ++k) {\n+            \/\/ Loop here is multiversioned, and eventually we insert an aliasing runtime check.\n+            \/\/ This means that a StoreN (with mem input Proj from above) has its ctrl changed\n+            \/\/ from the old multiversion_if_proj to a new region. We have to be careful to update\n+            \/\/ the _loop_or_ctrl side-table so that get_ctrl for StoreN is sane.\n+            \/\/\n+            \/\/ Below is some nested loop material I could not reduce further. Maybe because\n+            \/\/ of loop-opts phase timing. Because we have to SuperWord the k-indexed loop\n+            \/\/ above in the same loop-opts-phase as the j-indexed loop below, so that they\n+            \/\/ have a shared _loop_or_ctrl data structure.\n+            int y = 6;\n+            while (--y > 0) {}\n+            for (long i = 1; i < 6; i++) {\n+                \/\/ I suspect that it is the two array references below that are SuperWord-ed,\n+                \/\/ and since we do not manage to statically prove they cannot overlap, we add\n+                \/\/ a speculative runtime check, i.e. multiversioning in this case.\n+                arrayI[0] += 1;\n+                arrayI[k] = 0;\n+                try {\n+                    x = 2 \/ k % y;\n+                } catch (ArithmeticException a_e) {\n+                }\n+            }\n+        }\n+        long sum = 0;\n+        for (int j = 0; j < arrayB.length; j++) {\n+            \/\/ Load below has mem input from Proj below dontinline\n+            \/\/ We look up to the mem input (Proj), and down to uses\n+            \/\/ that are Stores, checking in_bb on them, which calls\n+            \/\/ get_ctrl on that StoreN from the other loop above.\n+            sum += arrayB[j];\n+        }\n+        return sum;\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 1_000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMultiversionSlowProjReplacementAndGetCtrl.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 0\n@@ -33,0 +33,71 @@\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 6\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 7\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding 8\n+ *\/\n@@ -44,5 +115,10 @@\n-        InlineTypes.getFramework()\n-                .addScenarios(InlineTypes.DEFAULT_SCENARIOS)\n-                .addScenarios(new Scenario(7, \"--enable-preview\", \"-XX:-UseCompressedOops\"))\n-                .addScenarios(new Scenario(8, \"--enable-preview\", \"-XX:+UseCompressedOops\"))\n-                .start();\n+        TestFramework framework = InlineTypes.getFramework();\n+        int index = Integer.parseInt(args[0]);\n+        if (index < 7) {\n+            framework.addScenarios(InlineTypes.DEFAULT_SCENARIOS[index]);\n+        } else if (index == 7) {\n+            framework.addScenarios(new Scenario(7, \"--enable-preview\", \"-XX:-UseCompressedOops\"));\n+        } else {\n+            framework.addScenarios(new Scenario(8, \"--enable-preview\", \"-XX:+UseCompressedOops\"));\n+        }\n+        framework.start();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":83,"deletions":7,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -70,1 +70,79 @@\n- * @run main\/timeout=300 compiler.valhalla.inlinetypes.TestArrays\n+ * @run main compiler.valhalla.inlinetypes.TestArrays 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestArrays 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestArrays 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestArrays 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestArrays 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestArrays 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestArrays 6\n@@ -84,1 +162,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -57,1 +57,79 @@\n- * @run main\/timeout=300 compiler.valhalla.inlinetypes.TestBasicFunctionality\n+ * @run main compiler.valhalla.inlinetypes.TestBasicFunctionality 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8327695\n+ * @summary Test the basic value class implementation in C2.\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestBasicFunctionality 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8327695\n+ * @summary Test the basic value class implementation in C2.\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestBasicFunctionality 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8327695\n+ * @summary Test the basic value class implementation in C2.\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestBasicFunctionality 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8327695\n+ * @summary Test the basic value class implementation in C2.\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestBasicFunctionality 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8327695\n+ * @summary Test the basic value class implementation in C2.\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestBasicFunctionality 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @bug 8327695\n+ * @summary Test the basic value class implementation in C2.\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestBasicFunctionality 6\n@@ -65,1 +143,1 @@\n-                   .addScenarios(InlineTypes.DEFAULT_SCENARIOS)\n+                   .addScenarios(InlineTypes.DEFAULT_SCENARIOS[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -60,1 +60,85 @@\n- * @run main\/othervm\/timeout=450 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class calling convention optimizations.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class calling convention optimizations.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class calling convention optimizations.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class calling convention optimizations.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class calling convention optimizations.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test value class calling convention optimizations.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestCallingConvention 6\n@@ -103,1 +187,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":86,"deletions":2,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n@@ -59,1 +60,91 @@\n- * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test intrinsic support for value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.valhalla.inlinetypes.TestIntrinsics 6\n@@ -77,1 +168,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -41,1 +41,73 @@\n- * @run main\/timeout=300 compiler.valhalla.inlinetypes.TestJNICalls\n+ * @run main compiler.valhalla.inlinetypes.TestJNICalls 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test calling native methods with value class arguments from compiled code.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestJNICalls 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test calling native methods with value class arguments from compiled code.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestJNICalls 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test calling native methods with value class arguments from compiled code.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestJNICalls 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test calling native methods with value class arguments from compiled code.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestJNICalls 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test calling native methods with value class arguments from compiled code.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestJNICalls 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test calling native methods with value class arguments from compiled code.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestJNICalls 6\n@@ -51,1 +123,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestJNICalls.java","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -73,1 +73,79 @@\n- * @run main\/timeout=600 compiler.valhalla.inlinetypes.TestLWorld\n+ * @run main compiler.valhalla.inlinetypes.TestLWorld 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestLWorld 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestLWorld 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestLWorld 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestLWorld 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestLWorld 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestLWorld 6\n@@ -91,1 +169,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -56,1 +56,79 @@\n- * @run main\/timeout=450 compiler.valhalla.inlinetypes.TestMethodHandles\n+ * @run main compiler.valhalla.inlinetypes.TestMethodHandles 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @requires vm.opt.AbortVMOnCompilationFailure != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestMethodHandles 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @requires vm.opt.AbortVMOnCompilationFailure != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestMethodHandles 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @requires vm.opt.AbortVMOnCompilationFailure != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestMethodHandles 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @requires vm.opt.AbortVMOnCompilationFailure != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestMethodHandles 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @requires vm.opt.AbortVMOnCompilationFailure != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestMethodHandles 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test method handle support for inline types\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @requires vm.opt.AbortVMOnCompilationFailure != true\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestMethodHandles 6\n@@ -150,1 +228,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -58,1 +58,73 @@\n- * @run main\/timeout=600 compiler.valhalla.inlinetypes.TestNullableArrays\n+ * @run main compiler.valhalla.inlinetypes.TestNullableArrays 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable value class arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestNullableArrays 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable value class arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestNullableArrays 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable value class arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestNullableArrays 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable value class arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestNullableArrays 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable value class arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestNullableArrays 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable value class arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestNullableArrays 6\n@@ -73,1 +145,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -63,1 +63,79 @@\n- * @run main\/timeout=1000 compiler.valhalla.inlinetypes.TestNullableInlineTypes\n+ * @run main compiler.valhalla.inlinetypes.TestNullableInlineTypes 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestNullableInlineTypes 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestNullableInlineTypes 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestNullableInlineTypes 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestNullableInlineTypes 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestNullableInlineTypes 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main compiler.valhalla.inlinetypes.TestNullableInlineTypes 6\n@@ -76,1 +154,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -49,1 +49,73 @@\n- * @run main\/timeout=600 compiler.valhalla.inlinetypes.TestOnStackReplacement\n+ * @run main compiler.valhalla.inlinetypes.TestOnStackReplacement 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestOnStackReplacement 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestOnStackReplacement 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestOnStackReplacement 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestOnStackReplacement 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestOnStackReplacement 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestOnStackReplacement 6\n@@ -59,1 +131,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -50,1 +50,73 @@\n- * @run main\/timeout=300 compiler.valhalla.inlinetypes.TestValueClasses\n+ * @run main compiler.valhalla.inlinetypes.TestValueClasses 0\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestValueClasses 1\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestValueClasses 2\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestValueClasses 3\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestValueClasses 4\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestValueClasses 5\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main compiler.valhalla.inlinetypes.TestValueClasses 6\n@@ -65,1 +137,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(scenarios[Integer.parseInt(args[0])])\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8366333\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary IR test for VectorAPI compress\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorCompressTest\n+ *\/\n+\n+public class VectorCompressTest {\n+    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+    static final int LENGTH = 512;\n+    static final Generators RD = Generators.G;\n+    static byte[] ba, bb;\n+    static short[] sa, sb;\n+    static int[] ia, ib;\n+    static long[] la, lb;\n+    static float[] fa, fb;\n+    static double[] da, db;\n+    static boolean[] ma;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        fa = new float[LENGTH];\n+        fb = new float[LENGTH];\n+        da = new double[LENGTH];\n+        db = new double[LENGTH];\n+        ma = new boolean[LENGTH];\n+\n+        Generator<Integer> iGen = RD.ints();\n+        Generator<Long> lGen = RD.longs();\n+        Generator<Float> fGen = RD.floats();\n+        Generator<Double> dGen = RD.doubles();\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = iGen.next().byteValue();\n+            sa[i] = iGen.next().shortValue();\n+            ma[i] = iGen.next() % 2 == 0;\n+        }\n+        RD.fill(iGen, ia);\n+        RD.fill(lGen, la);\n+        RD.fill(fGen, fa);\n+        RD.fill(dGen, da);\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressByte(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(ba[i], bb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals((byte)0, bb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressShort(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(sa[i], sb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals((short)0, sb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressInteger(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(ia[i], ib[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0, ib[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressLong(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(la[i], lb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0L, lb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressFloat(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(fa[i], fb[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0.0f, fb[i]);\n+        }\n+    }\n+\n+    @DontInline\n+    static void verifyVectorCompressDouble(int vlen) {\n+        int index = 0;\n+        for (int i = 0; i < vlen; i++) {\n+            if (ma[i]) {\n+                Asserts.assertEquals(da[i], db[index++]);\n+            }\n+        }\n+        for (int i = index; i < vlen; i++) {\n+            Asserts.assertEquals(0.0, db[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VB, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VB, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512_vbmi2\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressByte() {\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        VectorMask<Byte> m = VectorMask.fromArray(B_SPECIES, ma, 0);\n+        av.compress(m).intoArray(bb, 0);\n+        verifyVectorCompressByte(B_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VS, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VS, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512_vbmi2\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressShort() {\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        VectorMask<Short> m = VectorMask.fromArray(S_SPECIES, ma, 0);\n+        av.compress(m).intoArray(sb, 0);\n+        verifyVectorCompressShort(S_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VI, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VI, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressInt() {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        VectorMask<Integer> m = VectorMask.fromArray(I_SPECIES, ma, 0);\n+        av.compress(m).intoArray(ib, 0);\n+        verifyVectorCompressInteger(I_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VL, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VL, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressLong() {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        VectorMask<Long> m = VectorMask.fromArray(L_SPECIES, ma, 0);\n+        av.compress(m).intoArray(lb, 0);\n+        verifyVectorCompressLong(L_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VF, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VF, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressFloat() {\n+        FloatVector av = FloatVector.fromArray(F_SPECIES, fa, 0);\n+        VectorMask<Float> m = VectorMask.fromArray(F_SPECIES, ma, 0);\n+        av.compress(m).intoArray(fb, 0);\n+        verifyVectorCompressFloat(F_SPECIES.length());\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COMPRESS_VD, \"= 1\" },\n+        applyIfCPUFeature = { \"sve\", \"true\" })\n+    @IR(counts = { IRNode.COMPRESS_VD, \"= 1\" },\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n+    public static void testVectorCompressDouble() {\n+        DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, 0);\n+        VectorMask<Double> m = VectorMask.fromArray(D_SPECIES, ma, 0);\n+        av.compress(m).intoArray(db, 0);\n+        verifyVectorCompressDouble(D_SPECIES.length());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompressTest.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.arch != \"riscv64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"))\n+ * @requires vm.opt.final.MaxVectorSize == \"null\" | vm.opt.final.MaxVectorSize >= 16\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestNewSizeThreadIncrease.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSkipRebuildRemsetPhase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,5 @@\n-import org.objectweb.asm.*;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n@@ -27,21 +31,14 @@\n-    static byte[] fixup(byte[] buf) throws java.io.IOException {\n-        ClassReader cr = new ClassReader(buf);\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {\n-            public MethodVisitor visitMethod(\n-                final int access,\n-                final String name,\n-                final String desc,\n-                final String signature,\n-                final String[] exceptions)\n-            {\n-                MethodVisitor mv = super.visitMethod(access,\n-                        name,\n-                        desc,\n-                        signature,\n-                        exceptions);\n-                if (mv == null)  return null;\n-                if (name.equals(\"callme\")) {\n-                    \/\/ make receiver go dead!\n-                    mv.visitInsn(Opcodes.ACONST_NULL);\n-                    mv.visitVarInsn(Opcodes.ASTORE, 0);\n+    static byte[] fixup(byte[] buf) {\n+        return ClassFile.of().transformClass(ClassFile.of().parse(buf), ClassTransform.transformingMethodBodies(\n+                m -> m.methodName().equalsString(\"callme\"),\n+                new CodeTransform() {\n+                    @Override\n+                    public void atStart(CodeBuilder builder) {\n+                        \/\/ make receiver go dead!\n+                        builder.aconst_null().astore(0);\n+                    }\n+\n+                    @Override\n+                    public void accept(CodeBuilder builder, CodeElement element) {\n+                        builder.with(element); \/\/ pass through\n+                    }\n@@ -49,5 +46,1 @@\n-                return mv;\n-            }\n-        };\n-        cr.accept(cv, 0);\n-        return cw.toByteArray();\n+        ));\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Asmator.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Test8003720.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check the allocation-site stack trace of a corrupted memory at free() time\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail NMTPrintMallocSiteOfCorruptedMemory\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class NMTPrintMallocSiteOfCorruptedMemory {\n+    private static final String HEADER_ARG = \"header\";\n+    private static final String FOOTER_ARG = \"footer\";\n+    private static final String HEADER_AND_SITE_ARG = \"header-and-site\";\n+    private static final String FOOTER_AND_SITE_ARG = \"footer-and-site\";\n+    private static final int MALLOC_SIZE = 10;\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    static {\n+        System.loadLibrary(\"MallocHeaderModifier\");\n+    }\n+\n+    public static native byte modifyHeaderCanary(long malloc_memory);\n+    public static native byte modifyFooterCanary(long malloc_memory, long size);\n+    public static native byte modifyHeaderCanaryAndSiteMarker(long malloc_memory);\n+    public static native byte modifyFooterCanaryAndSiteMarker(long malloc_memory, long size);\n+\n+    private static void runThisTestWith(String arg) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(new String[] {\"-Xbootclasspath\/a:.\",\n+                                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                                    \"-XX:NativeMemoryTracking=detail\",\n+                                                                                    \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                                                                    \"NMTPrintMallocSiteOfCorruptedMemory\",\n+                                                                                    arg});\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldMatch(\"NMT Block at .*, corruption at: \");\n+        switch(arg) {\n+            case HEADER_AND_SITE_ARG, FOOTER_AND_SITE_ARG -> output.shouldContain(\"allocation-site cannot be shown since the marker is also corrupted.\");\n+            case HEADER_ARG, FOOTER_ARG -> {\n+                output.shouldContain(\"allocated from:\");\n+                output.shouldMatch(\"\\\\[.*\\\\]WB_NMTMalloc\\\\+0x.*\");\n+            }\n+        }\n+    }\n+\n+    private static void testModifyHeaderCanary() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyHeaderCanary(addr);\n+        wb.NMTFree(addr);\n+    }\n+\n+    private static void testModifyFooterCanary() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyFooterCanary(addr, MALLOC_SIZE);\n+        wb.NMTFree(addr);\n+    }\n+\n+    private static void testModifyHeaderCanaryAndSiteMarker() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyHeaderCanaryAndSiteMarker(addr);\n+        wb.NMTFree(addr);\n+    }\n+\n+    private static void testModifyFooterCanaryAndSiteMarker() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyFooterCanaryAndSiteMarker(addr, MALLOC_SIZE);\n+        wb.NMTFree(addr);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        if (args != null && args.length == 1) {\n+            switch (args[0]) {\n+                case HEADER_ARG -> testModifyHeaderCanary();\n+                case FOOTER_ARG -> testModifyFooterCanary();\n+                case HEADER_AND_SITE_ARG -> testModifyHeaderCanaryAndSiteMarker();\n+                case FOOTER_AND_SITE_ARG -> testModifyFooterCanaryAndSiteMarker();\n+                default -> throw new RuntimeException(\"Invalid argument for NMTPrintMallocSiteOfCorruptedMemory (\" + args[0] + \")\");\n+            }\n+        } else {\n+            runThisTestWith(HEADER_ARG);\n+            runThisTestWith(FOOTER_ARG);\n+            runThisTestWith(HEADER_AND_SITE_ARG);\n+            runThisTestWith(FOOTER_AND_SITE_ARG);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTPrintMallocSiteOfCorruptedMemory.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include <stdint.h>\n+#include <string.h>\n+\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyHeaderCanary(JNIEnv *env, jclass cls, jlong addr) {\n+  *((jint*)(uintptr_t)addr - 1) = 0;\n+  return 0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyFooterCanary(JNIEnv *env, jclass cls, jlong addr, jint size) {\n+  *((jbyte*)(uintptr_t)addr + size + 1) = 0;\n+  return 0;\n+}\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyHeaderCanaryAndSiteMarker(JNIEnv *env, jclass cls, jlong addr) {\n+  jbyte* p = (jbyte*)(uintptr_t)addr - 16;\n+  memset(p, 0xFF , 16);\n+  return 0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyFooterCanaryAndSiteMarker(JNIEnv *env, jclass cls, jlong addr, jint size) {\n+  jbyte* p = (jbyte*)(uintptr_t)addr - 16;\n+  memset(p, 0xFF , 16);\n+  *((jbyte*)(uintptr_t)addr + size + 1) = 0;\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/libMallocHeaderModifier.c","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+\n+This is a simple parser for parsing the output of\n+\n+   java -Xshare:dump -Xlog:aot+map=debug,aot+map+oops=trace:file=aot.map:none:filesize=0\n+\n+The map file contains patterns like this for the heap objects:\n+\n+======================================================================\n+0x00000000ffe00000: @@ Object (0xffe00000) java.lang.String \"\"\n+ - klass: 'java\/lang\/String' 0x0000000800010220\n+ - fields (3 words):\n+ - private 'hash' 'I' @12  0 (0x00000000)\n+ - private final 'coder' 'B' @16  0 (0x00)\n+ - private 'hashIsZero' 'Z' @17  true (0x01)\n+ - injected 'flags' 'B' @18  1 (0x01)\n+ - private final 'value' '[B' @20 0x00000000ffe00018 (0xffe00018) [B length: 0\n+0x00000000ffe00018: @@ Object (0xffe00018) [B length: 0\n+ - klass: {type array byte} 0x00000008000024d8\n+======================================================================\n+\n+Currently this parser just check the output related to JDK-8308903.\n+I.e., each oop field must point to a valid HeapObject. For example, the 'value' field\n+in the String must point to a valid byte array.\n+\n+This parser can be extended to check for the other parts of the map file, or perform\n+more analysis on the HeapObjects.\n+\n+*\/\n+\n+public class AOTMapReader {\n+    public static class MapFile {\n+        HashSet<String> classes = new HashSet<>();\n+        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n+        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n+        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n+        public int stringCount = 0;\n+\n+        void add(HeapObject heapObject) {\n+            heapObjects.add(heapObject);\n+            oopToObject.put(heapObject.address.oop, heapObject);\n+            if (heapObject.address.narrowOop != 0) {\n+                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n+            }\n+            if (heapObject.className.equals(\"java.lang.String\")) {\n+                stringCount ++;\n+            }\n+        }\n+\n+        public int heapObjectCount() {\n+            return heapObjects.size();\n+        }\n+\n+        void addClass(String className) {\n+            classes.add(className);\n+        }\n+\n+        public boolean hasClass(String className) {\n+            return classes.contains(className);\n+        }\n+\n+        public void shouldHaveClass(String className) {\n+            if (!hasClass(className)) {\n+                throw new RuntimeException(\"AOT map file is missing class \" + className);\n+            }\n+        }\n+    }\n+\n+    public static class HeapAddress {\n+        long oop;\n+        long narrowOop;\n+\n+        HeapAddress(String oopStr, String narrowOopStr) {\n+            oop = Long.parseUnsignedLong(oopStr, 16);\n+            if (narrowOopStr != null) {\n+                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n+            }\n+        }\n+    }\n+\n+    public static class Klass {\n+        long address;\n+        String name;\n+\n+        static Klass getKlass(String name, String addr) {\n+            \/\/ TODO: look up from a table of known Klasses\n+            Klass k = new Klass();\n+            k.name = name;\n+            k.address =  Long.parseUnsignedLong(addr, 16);\n+            return k;\n+        }\n+    }\n+\n+    public static class HeapObject {\n+        HeapAddress address;\n+        ArrayList<Field> fields;\n+        String className;\n+        Klass klass;\n+\n+        HeapObject(String className, String oop, String narrowOop) {\n+            this.className = className;\n+            address = new HeapAddress(oop, narrowOop);\n+        }\n+\n+        void setKlass(String klassName, String address) {\n+            klass = Klass.getKlass(klassName, address);\n+        }\n+\n+        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n+            if (fields == null) {\n+                fields = new ArrayList<Field>();\n+            }\n+            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n+        }\n+    }\n+\n+    public static class Field {\n+        String name;\n+        int offset;\n+        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n+        int lineCount;\n+\n+        Field(String name, String offset, String oopStr, String narrowOopStr) {\n+            this.name = name;\n+            this.offset = Integer.parseInt(offset);\n+            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n+            this.lineCount = AOTMapReader.lineCount;\n+        }\n+    }\n+\n+    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n+    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n+\n+    \/\/ -------------------------------------------------------------------------------\n+    \/\/ Patterns for heap objects\n+    \/\/ -------------------------------------------------------------------------------\n+\n+    \/\/ (one address)\n+    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n+    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object ([^ ]*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n+    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] ([^ ]*)\");\n+\n+    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n+    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: {type array byte} 0x00000008000024c8\n+    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n+    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n+\n+    \/\/  - fields (3 words):\n+    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n+\n+    \/\/ (one address)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n+    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n+    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    \/\/ (injected module_entry)\n+    \/\/  - injected 'module_entry' 'J' @16 0 (0x0000000000000000)\n+    static Pattern moduleEntryPattern = Pattern.compile(\"- injected 'module_entry' 'J' @[0-9]+[ ]+([0-9]+)\");\n+\n+    \/\/ -------------------------------------------------------------------------------\n+    \/\/ Patterns for metaspace objects\n+    \/\/ -------------------------------------------------------------------------------\n+\n+    \/\/ 0x00000008000d1698: @@ Class             512 [Ljdk.internal.vm.FillerElement;\n+    \/\/ 0x00000008000d18a0: @@ Class             520 java.lang.Cloneable\n+    static Pattern classPattern = Pattern.compile(\"^0x([0-9a-f]+): @@ Class [ ]*([0-9]+) (.*)\");\n+\n+\n+    private static Matcher match(String line, Pattern pattern) {\n+        Matcher m = pattern.matcher(line);\n+        if (m.find()) {\n+            return m;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n+        mapFile.add(heapObject);\n+    }\n+\n+    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n+        Matcher m;\n+\n+        nextLine();\n+        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n+            nextLine();\n+        }\n+\n+        if (line == null || !line.startsWith(\" - \")) {\n+            return heapObject;\n+        }\n+\n+        if ((m = match(line, instanceObjKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            nextLine();\n+            if ((m = match(line, fieldsWordsPattern)) == null) {\n+                throw new RuntimeException(\"Expected field size info\");\n+            }\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+                if (!line.contains(\"marked metadata pointer\")) {\n+                    if ((m = match(line, oopFieldPattern2)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n+                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n+                    } else if ((m = match(line, moduleEntryPattern)) != null) {\n+                        String value = m.group(1);\n+                        if (!value.equals(\"0\")) {\n+                            throw new RuntimeException(\"module_entry should be 0 but found: \" + line);\n+                        }\n+                    }\n+                }\n+            }\n+        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(3));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else {\n+            throw new RuntimeException(\"Expected klass info\");\n+        }\n+    }\n+\n+    private static void parseClassObject(String className, String addr, String size) throws IOException {\n+        mapFile.addClass(className);\n+        nextLine();\n+    }\n+\n+    static MapFile mapFile;\n+    static BufferedReader reader;\n+    static String line = null; \/\/ current line being parsed\n+    static int lineCount = 0;\n+    static String nextLine()  throws IOException {\n+        line = reader.readLine();\n+        ++ lineCount;\n+        return line;\n+    }\n+\n+    public static MapFile read(String fileName) {\n+        mapFile = new MapFile();\n+        lineCount = 0;\n+\n+        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n+            reader = r;\n+            nextLine();\n+\n+            Matcher m;\n+            while (line != null) {\n+                if ((m = match(line, objPattern2)) != null) {\n+                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n+                } else if ((m = match(line, objPattern1)) != null) {\n+                    parseHeapObject(m.group(2), m.group(1), null);\n+                } else if ((m = match(line, classPattern)) != null) {\n+                    parseClassObject(m.group(3), m.group(1), m.group(2)); \/\/ name, addr, size\n+                } else {\n+                    nextLine();\n+                }\n+            }\n+            return mapFile;\n+        } catch (Throwable t) {\n+            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n+            throw new RuntimeException(t);\n+        } finally {\n+            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n+            System.out.println(\"Found \" + mapFile.heapObjectCount() + \" heap objects (\"\n+                               + mapFile.stringCount + \" strings)\");\n+            mapFile = null;\n+            reader = null;\n+            line = null;\n+            lineCount = 0;\n+        }\n+    }\n+\n+    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n+        if (allObjects.get(pointer) == null) {\n+            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n+                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n+        }\n+    }\n+\n+    public static void validate(MapFile mapFile, String classLoadLogFile) throws IOException {\n+        validateOops(mapFile);\n+        if (classLoadLogFile != null) {\n+            validateClasses(mapFile, classLoadLogFile);\n+        }\n+    }\n+\n+    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n+    static void validateOops(MapFile mapFile) {\n+        int count1 = 0;\n+        int count2 = 0;\n+        for (HeapObject heapObject : mapFile.heapObjects) {\n+            if (heapObject.fields != null) {\n+                for (Field field : heapObject.fields) {\n+                    HeapAddress referentAddress = field.referentAddress;\n+                    long oop = referentAddress.oop;\n+                    long narrowOop = referentAddress.narrowOop;\n+                    \/\/ Is this test actually doing something?\n+                    \/\/     To see how an invalidate pointer may be found, change oop in the\n+                    \/\/     following line to oop+1\n+                    if (oop != 0) {\n+                        mustContain(mapFile.oopToObject, field, oop, false);\n+                        count1 ++;\n+                    }\n+                    if (narrowOop != 0) {\n+                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n+                        count2 ++;\n+                    }\n+                }\n+            }\n+        }\n+        System.out.println(\"Found \" + count1 + \" non-null oop field references (normal)\");\n+        System.out.println(\"Found \" + count2 + \" non-null oop field references (narrow)\");\n+\n+        if (mapFile.heapObjectCount() > 0) {\n+            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n+            if (mapFile.stringCount <= 0) {\n+                throw new RuntimeException(\"AOT map file should contain at least one string\");\n+            }\n+            if (count1 < mapFile.stringCount) {\n+                throw new RuntimeException(\"AOT map file seems incorrect: \" + mapFile.heapObjectCount() +\n+                                           \" objects (\" + mapFile.stringCount + \" strings). Each string should\" +\n+                                           \" have one non-null oop field but we found only \" + count1 +\n+                                           \" non-null oop field references\");\n+            }\n+        }\n+    }\n+\n+    \/\/ classLoadLogFile should be generated with -Xlog:class+load:file=<classLoadLogFile>:none:filesize=0\n+    \/\/ Check that every class loaded from \"source: shared objects file\" have an entry inside the mapFile.\n+    static void validateClasses(MapFile mapFile, String classLoadLogFile) throws IOException {\n+        try (BufferedReader r = new BufferedReader(new FileReader(classLoadLogFile))) {\n+            String line;\n+            String suffix = \" source: shared objects file\";\n+            int suffixLen = suffix.length();\n+            while ((line = r.readLine()) != null) {\n+                if (line.endsWith(suffix)) {\n+                    String className = line.substring(0, line.length() - suffixLen);\n+                    if (!mapFile.hasClass(className)) {\n+                        throw new RuntimeException(\"AOT map file is missing class \" + className);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) throws IOException {\n+        MapFile mapFile = read(args[0]);\n+        validate(mapFile, null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/AOTMapReader.java","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- * @run driver\/timeout=240 CDSMapTest\n+ * @run driver\/timeout=240 AOTMapTest\n@@ -40,1 +40,1 @@\n-public class CDSMapTest {\n+public class AOTMapTest {\n@@ -82,2 +82,2 @@\n-        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n-        CDSMapReader.validate(mapFile);\n+        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapName);\n+        AOTMapReader.validate(mapFile, null);\n@@ -101,2 +101,2 @@\n-        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n-        CDSMapReader.validate(mapFile);\n+        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapName);\n+        AOTMapReader.validate(mapFile, null);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/AOTMapTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","status":"renamed"},{"patch":"@@ -1,351 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/*\n-\n-This is a simple parser for parsing the output of\n-\n-   java -Xshare:dump -Xlog:aot+map=debug,aot+map+oops=trace:file=cds.map:none:filesize=0\n-\n-The map file contains patterns like this for the heap objects:\n-\n-======================================================================\n-0x00000000ffe00000: @@ Object (0xffe00000) java.lang.String \"\"\n- - klass: 'java\/lang\/String' 0x0000000800010220\n- - fields (3 words):\n- - private 'hash' 'I' @12  0 (0x00000000)\n- - private final 'coder' 'B' @16  0 (0x00)\n- - private 'hashIsZero' 'Z' @17  true (0x01)\n- - injected 'flags' 'B' @18  1 (0x01)\n- - private final 'value' '[B' @20 0x00000000ffe00018 (0xffe00018) [B length: 0\n-0x00000000ffe00018: @@ Object (0xffe00018) [B length: 0\n- - klass: {type array byte} 0x00000008000024d8\n-======================================================================\n-\n-Currently this parser just check the output related to JDK-8308903.\n-I.e., each oop field must point to a valid HeapObject. For example, the 'value' field\n-in the String must point to a valid byte array.\n-\n-This parser can be extended to check for the other parts of the map file, or perform\n-more analysis on the HeapObjects.\n-\n-*\/\n-\n-public class CDSMapReader {\n-    public static class MapFile {\n-        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n-        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n-        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n-        public int stringCount = 0;\n-\n-        void add(HeapObject heapObject) {\n-            heapObjects.add(heapObject);\n-            oopToObject.put(heapObject.address.oop, heapObject);\n-            if (heapObject.address.narrowOop != 0) {\n-                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n-            }\n-            if (heapObject.className.equals(\"java.lang.String\")) {\n-                stringCount ++;\n-            }\n-        }\n-\n-        public int heapObjectCount() {\n-            return heapObjects.size();\n-        }\n-    }\n-\n-    public static class HeapAddress {\n-        long oop;\n-        long narrowOop;\n-\n-        HeapAddress(String oopStr, String narrowOopStr) {\n-            oop = Long.parseUnsignedLong(oopStr, 16);\n-            if (narrowOopStr != null) {\n-                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n-            }\n-        }\n-    }\n-\n-    public static class Klass {\n-        long address;\n-        String name;\n-\n-        static Klass getKlass(String name, String addr) {\n-            \/\/ TODO: look up from a table of known Klasses\n-            Klass k = new Klass();\n-            k.name = name;\n-            k.address =  Long.parseUnsignedLong(addr, 16);\n-            return k;\n-        }\n-    }\n-\n-    public static class HeapObject {\n-        HeapAddress address;\n-        ArrayList<Field> fields;\n-        String className;\n-        Klass klass;\n-\n-        HeapObject(String className, String oop, String narrowOop) {\n-            this.className = className;\n-            address = new HeapAddress(oop, narrowOop);\n-        }\n-\n-        void setKlass(String klassName, String address) {\n-            klass = Klass.getKlass(klassName, address);\n-        }\n-\n-        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n-            if (fields == null) {\n-                fields = new ArrayList<Field>();\n-            }\n-            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n-        }\n-    }\n-\n-    public static class Field {\n-        String name;\n-        int offset;\n-        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n-        int lineCount;\n-\n-        Field(String name, String offset, String oopStr, String narrowOopStr) {\n-            this.name = name;\n-            this.offset = Integer.parseInt(offset);\n-            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n-            this.lineCount = CDSMapReader.lineCount;\n-        }\n-    }\n-\n-    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n-    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n-\n-    \/\/ (one address)\n-    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n-    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object ([^ ]*)\");\n-\n-    \/\/ (two addresses)\n-    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n-    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] ([^ ]*)\");\n-\n-    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n-    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n-\n-    \/\/  - klass: {type array byte} 0x00000008000024c8\n-    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n-\n-    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n-    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n-\n-    \/\/  - fields (3 words):\n-    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n-\n-    \/\/ (one address)\n-    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n-    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n-\n-    \/\/ (two addresses)\n-    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n-    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n-\n-    \/\/ (injected module_entry)\n-    \/\/  - injected 'module_entry' 'J' @16 0 (0x0000000000000000)\n-    static Pattern moduleEntryPattern = Pattern.compile(\"- injected 'module_entry' 'J' @[0-9]+[ ]+([0-9]+)\");\n-\n-    private static Matcher match(String line, Pattern pattern) {\n-        Matcher m = pattern.matcher(line);\n-        if (m.find()) {\n-            return m;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n-        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n-        mapFile.add(heapObject);\n-    }\n-\n-    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n-        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n-        Matcher m;\n-\n-        nextLine();\n-        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n-            nextLine();\n-        }\n-\n-        if (line == null || !line.startsWith(\" - \")) {\n-            return heapObject;\n-        }\n-\n-        if ((m = match(line, instanceObjKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(2));\n-            nextLine();\n-            if ((m = match(line, fieldsWordsPattern)) == null) {\n-                throw new RuntimeException(\"Expected field size info\");\n-            }\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-                if (!line.contains(\"marked metadata pointer\")) {\n-                    if ((m = match(line, oopFieldPattern2)) != null) {\n-                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n-                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n-                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n-                    } else if ((m = match(line, moduleEntryPattern)) != null) {\n-                        String value = m.group(1);\n-                        if (!value.equals(\"0\")) {\n-                            throw new RuntimeException(\"module_entry should be 0 but found: \" + line);\n-                        }\n-                    }\n-                }\n-            }\n-        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(2));\n-            \/\/ TODO: read all the array elements\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-            }\n-        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(3));\n-            \/\/ TODO: read all the array elements\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-            }\n-        } else {\n-            throw new RuntimeException(\"Expected klass info\");\n-        }\n-    }\n-\n-    static MapFile mapFile;\n-    static BufferedReader reader;\n-    static String line = null; \/\/ current line being parsed\n-    static int lineCount = 0;\n-    static String nextLine()  throws IOException {\n-        line = reader.readLine();\n-        ++ lineCount;\n-        return line;\n-    }\n-\n-    public static MapFile read(String fileName) {\n-        mapFile = new MapFile();\n-        lineCount = 0;\n-\n-        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n-            reader = r;\n-            nextLine();\n-\n-            Matcher m;\n-            while (line != null) {\n-                if ((m = match(line, objPattern2)) != null) {\n-                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n-                } else if ((m = match(line, objPattern1)) != null) {\n-                    parseHeapObject(m.group(2), m.group(1), null);\n-                } else {\n-                    nextLine();\n-                }\n-            }\n-            return mapFile;\n-        } catch (Throwable t) {\n-            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n-            throw new RuntimeException(t);\n-        } finally {\n-            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n-            System.out.println(\"Found \" + mapFile.heapObjectCount() + \" heap objects (\"\n-                               + mapFile.stringCount + \" strings)\");\n-            mapFile = null;\n-            reader = null;\n-            line = null;\n-            lineCount = 0;\n-        }\n-    }\n-\n-    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n-        if (allObjects.get(pointer) == null) {\n-            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n-                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n-        }\n-    }\n-\n-    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n-    public static void validate(MapFile mapFile) {\n-        int count1 = 0;\n-        int count2 = 0;\n-        for (HeapObject heapObject : mapFile.heapObjects) {\n-            if (heapObject.fields != null) {\n-                for (Field field : heapObject.fields) {\n-                    HeapAddress referentAddress = field.referentAddress;\n-                    long oop = referentAddress.oop;\n-                    long narrowOop = referentAddress.narrowOop;\n-                    \/\/ Is this test actually doing something?\n-                    \/\/     To see how an invalidate pointer may be found, change oop in the\n-                    \/\/     following line to oop+1\n-                    if (oop != 0) {\n-                        mustContain(mapFile.oopToObject, field, oop, false);\n-                        count1 ++;\n-                    }\n-                    if (narrowOop != 0) {\n-                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n-                        count2 ++;\n-                    }\n-                }\n-            }\n-        }\n-        System.out.println(\"Found \" + count1 + \" non-null oop field references (normal)\");\n-        System.out.println(\"Found \" + count2 + \" non-null oop field references (narrow)\");\n-\n-        if (mapFile.heapObjectCount() > 0) {\n-            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n-            if (mapFile.stringCount <= 0) {\n-                throw new RuntimeException(\"CDS map file should contain at least one string\");\n-            }\n-            if (count1 < mapFile.stringCount) {\n-                throw new RuntimeException(\"CDS map file seems incorrect: \" + mapFile.heapObjectCount() +\n-                                           \" objects (\" + mapFile.stringCount + \" strings). Each string should\" +\n-                                           \" have one non-null oop field but we found only \" + count1 +\n-                                           \" non-null oop field references\");\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) {\n-        MapFile mapFile = read(args[0]);\n-        validate(mapFile);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapReader.java","additions":0,"deletions":351,"binary":false,"changes":351,"status":"deleted"},{"patch":"@@ -29,2 +29,2 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n- * @build AOTMapTest\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build AOTMapTest Hello\n@@ -32,0 +32,1 @@\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar Hello\n@@ -40,1 +41,1 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n@@ -43,1 +44,1 @@\n- * @build AOTMapTest\n+ * @build AOTMapTest Hello\n@@ -45,0 +46,1 @@\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar Hello\n@@ -48,1 +50,3 @@\n-\n+import java.io.File;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n@@ -57,0 +61,1 @@\n+    static final String classLoadLogFile = \"production.class.load.log\";\n@@ -66,2 +71,8 @@\n-        validate(tester.dumpMapFile);\n-        validate(tester.runMapFile);\n+        if (tester.isDynamicWorkflow()) {\n+            \/\/ For dynamic workflow, the AOT map file doesn't include classes in the base archive, so\n+            \/\/ AOTMapReader.validateClasses() will fail.\n+            validate(tester.dumpMapFile, false);\n+        } else {\n+            validate(tester.dumpMapFile, true);\n+        }\n+        validate(tester.runMapFile, true);\n@@ -70,3 +81,9 @@\n-    static void validate(String mapFileName) {\n-        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapFileName);\n-        CDSMapReader.validate(mapFile);\n+    static void validate(String mapFileName, boolean checkClases) throws Exception {\n+        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapFileName);\n+        if (checkClases) {\n+            AOTMapReader.validate(mapFile, classLoadLogFile);\n+        } else {\n+            AOTMapReader.validate(mapFile, null);\n+        }\n+        mapFile.shouldHaveClass(\"AOTMapTestApp\"); \/\/ built-in class\n+        mapFile.shouldHaveClass(\"Hello\"); \/\/ unregistered class\n@@ -100,1 +117,1 @@\n-            String logMapSuffix = \":none:filesize=0\";\n+            String logSuffix = \":none:filesize=0\";\n@@ -103,1 +120,1 @@\n-                vmArgs.add(logMapPrefix + dumpMapFile + logMapSuffix);\n+                vmArgs.add(logMapPrefix + dumpMapFile + logSuffix);\n@@ -105,1 +122,2 @@\n-                vmArgs.add(logMapPrefix + runMapFile + logMapSuffix);\n+                vmArgs.add(logMapPrefix + runMapFile + logSuffix);\n+                vmArgs.add(\"-Xlog:class+load:file=\" + classLoadLogFile + logSuffix);\n@@ -121,1 +139,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -123,0 +141,9 @@\n+        testCustomLoader();\n+    }\n+\n+    static void testCustomLoader() throws Exception {\n+        File custJar = new File(\"cust.jar\");\n+        URL[] urls = new URL[] {custJar.toURI().toURL()};\n+        URLClassLoader loader = new URLClassLoader(urls, AOTMapTestApp.class.getClassLoader());\n+        Class<?> c = loader.loadClass(\"Hello\");\n+        System.out.println(c);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTMapTest.java","additions":41,"deletions":14,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -177,3 +177,0 @@\n-               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n-               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\")\n-               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldClass is excluded\")\n@@ -182,3 +179,1 @@\n-               .shouldNotMatch(\"klasses.* app *SubOfOldClass[$][$]Lambda\/\")\n-               .shouldMatch(\"archived indy *CP entry.*StringConcatTest .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\")\n-               .shouldNotMatch(\"archived indy *CP entry.*StringConcatTestOld .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\");\n+               .shouldMatch(\"archived indy *CP entry.*StringConcatTest .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeWalkStackTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import com.sun.tools.attach.AgentLoadException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test EarlyDynamicLoad\n+ * @summary Test that dynamic attach fails gracefully when the JVM is not in live phase.\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @run junit EarlyDynamicLoad\n+ *\/\n+public class EarlyDynamicLoad {\n+    private static final String EXPECTED_MESSAGE = \"Dynamic agent loading is only permitted in the live phase\";\n+\n+    private static Process child;\n+\n+    @BeforeAll\n+    static void startAndWaitChild() throws Exception {\n+        child = ProcessTools.createTestJavaProcessBuilder(\n+                        \"-XX:+StartAttachListener\",\n+                        \"-agentpath:\" + Utils.TEST_NATIVE_PATH + File.separator + System.mapLibraryName(\"EarlyDynamicLoad\"),\n+                        \"--version\").start();\n+\n+        \/\/ Wait until the process enters VMStartCallback\n+        try (InputStream is = child.getInputStream()) {\n+            is.read();\n+        }\n+    }\n+\n+    @AfterAll\n+    static void stopChild() throws Exception {\n+        try (OutputStream os = child.getOutputStream()) {\n+            os.write(0);\n+        }\n+\n+        if (!child.waitFor(5, TimeUnit.SECONDS)) {\n+            child.destroyForcibly();\n+            throw new AssertionError(\"Timed out while waiting child process to complete\");\n+        }\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(child);\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.stderrShouldBeEmpty();\n+    }\n+\n+    @Test\n+    public void virtualMachine() throws Exception {\n+        try {\n+            VirtualMachine vm = VirtualMachine.attach(String.valueOf(child.pid()));\n+            vm.loadAgent(\"some.jar\");\n+            vm.detach();\n+            throw new AssertionError(\"Should have failed with AgentLoadException\");\n+        } catch(AgentLoadException exception) {\n+            if (!exception.getMessage().contains(EXPECTED_MESSAGE)) {\n+                throw new AssertionError(\"Unexpected error message\", exception);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void jcmd() throws Exception {\n+        PidJcmdExecutor executor = new PidJcmdExecutor(String.valueOf(child.pid()));\n+        OutputAnalyzer out = executor.execute(\"JVMTI.agent_load some.jar\");\n+\n+        out.shouldHaveExitValue(0);\n+        out.stdoutShouldContain(EXPECTED_MESSAGE);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/EarlyDynamicLoad\/EarlyDynamicLoad.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+#include <cstdio>\n+#include <cstring>\n+\n+extern \"C\" {\n+\n+static void JNICALL VMStartCallback(jvmtiEnv* jvmti, JNIEnv* env) {\n+  putchar('1');\n+  fflush(stdout);\n+  getchar();\n+}\n+\n+JNIEXPORT int Agent_OnLoad(JavaVM* vm, char* options, void* reserved) {\n+  jvmtiEnv* jvmti;\n+  if (vm->GetEnv((void**) &jvmti, JVMTI_VERSION_1_0) != JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"JVMTI error occurred during GetEnv\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  jvmtiEventCallbacks callbacks;\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VMStart = VMStartCallback;\n+\n+  if (jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks)) != JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"JVMTI error occurred during SetEventCallbacks\\n\");\n+    return JNI_ERR;\n+  }\n+  if (jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr) != JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"JVMTI error occurred during SetEventNotificationMode\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/EarlyDynamicLoad\/libEarlyDynamicLoad.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -36,5 +35,4 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n@@ -61,20 +59,10 @@\n-        ClassReader reader = new ClassReader(classfileBuffer);\n-        final int[] frameCount = {0};\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM9) {\n-            @Override\n-            public MethodVisitor visitMethod(int access, String name,\n-                                             String descriptor, String signature,\n-                                             String[] exceptions) {\n-                return new MethodVisitor(Opcodes.ASM9) {\n-                    private int methodFrames = 0;\n-                    @Override\n-                    public void visitFrame(int type, int numLocal, Object[] local,\n-                                           int numStack, Object[] stack) {\n-                        methodFrames++;\n-                    }\n-                    @Override\n-                    public void visitEnd() {\n-                        log(\"  method \" + name + \" - \" + methodFrames + \" frames\");\n-                        frameCount[0] += methodFrames;\n-                    }\n-                };\n+        ClassModel clazz = ClassFile.of().parse(classfileBuffer);\n+        int count = 0;\n+        for (MethodModel method : clazz.methods()) {\n+            var foundStackMapTable = method.code().flatMap(code -> code.findAttribute(Attributes.stackMapTable()));\n+            if (foundStackMapTable.isPresent()) {\n+                int methodFrames = foundStackMapTable.get().entries().size();\n+                log(\"  method \" + method.methodName() + \" - \" + methodFrames + \" frames\");\n+                count += methodFrames;\n+            } else {\n+                log(\"  method \" + method.methodName() + \" - No StackMapTable\");\n@@ -82,3 +70,2 @@\n-        };\n-        reader.accept(cv, 0);\n-        return frameCount[0];\n+        }\n+        return count;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/MissedStackMapFrames.java","additions":16,"deletions":29,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @library \/testlibrary\/asm\n@@ -49,0 +48,5 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.FieldModel;\n@@ -58,1 +62,0 @@\n-import java.lang.reflect.TypeVariable;\n@@ -60,2 +63,1 @@\n-import java.util.Arrays;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n@@ -64,5 +66,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.FieldVisitor;\n-import static org.objectweb.asm.Opcodes.ASM7;\n@@ -89,24 +86,4 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            ClassVisitor cv = new ReAddDummyFieldsClassVisitor(ASM7, cw) { };\n-            ClassReader cr = new ClassReader(classfileBuffer);\n-            cr.accept(cv, 0);\n-            return cw.toByteArray();\n-        }\n-\n-        public class ReAddDummyFieldsClassVisitor extends ClassVisitor {\n-\n-            LinkedList<F> fields = new LinkedList<>();\n-\n-            public ReAddDummyFieldsClassVisitor(int api, ClassVisitor cv) {\n-                super(api, cv);\n-            }\n-\n-            @Override public FieldVisitor visitField(int access, String name,\n-                    String desc, String signature, Object value) {\n-                if (name.startsWith(\"dummy\")) {\n-                    \/\/ Remove dummy field\n-                    fields.addLast(new F(access, name, desc, signature, value));\n-                    return null;\n-                }\n-                return cv.visitField(access, name, desc, signature, value);\n-            }\n+            \/\/ Shuffle constant pool\n+            ClassFile context = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL);\n+            return context.transformClass(context.parse(classfileBuffer), new ClassTransform() {\n+                final List<FieldModel> dummyFields = new ArrayList<>();\n@@ -114,5 +91,8 @@\n-            @Override public void visitEnd() {\n-                F f;\n-                while ((f = fields.pollFirst()) != null) {\n-                    \/\/ Re-add dummy fields\n-                    cv.visitField(f.access, f.name, f.desc, f.signature, f.value);\n+                @Override\n+                public void accept(ClassBuilder builder, ClassElement element) {\n+                    if (element instanceof FieldModel field && field.fieldName().stringValue().startsWith(\"dummy\")) {\n+                        \/\/ Hold on to the associated constant pool entries too\n+                        dummyFields.addLast(field);\n+                    } else {\n+                        builder.with(element);\n+                    }\n@@ -120,1 +100,0 @@\n-            }\n@@ -122,12 +101,4 @@\n-            private class F {\n-                private int access;\n-                private String name;\n-                private String desc;\n-                private String signature;\n-                private Object value;\n-                F(int access, String name, String desc, String signature, Object value) {\n-                    this.access = access;\n-                    this.name = name;\n-                    this.desc = desc;\n-                    this.signature = signature;\n-                    this.value = value;\n+                @Override\n+                public void atEnd(ClassBuilder builder) {\n+                    \/\/ Add the associated constant pool entries to the end of the CP\n+                    dummyFields.forEach(builder);\n@@ -135,1 +106,1 @@\n-            }\n+            });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineAnnotations.java","additions":23,"deletions":52,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n@@ -144,3 +149,2 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassReader cr = new ClassReader(bytecode);\n-        cr.accept(new ClassVisitor(Opcodes.ASM7, cw) {\n+        ClassFile context = ClassFile.of();\n+        return context.transformClass(context.parse(bytecode), new ClassTransform() {\n@@ -149,4 +153,8 @@\n-            public void visitSource(String source, String debug) {\n-                sourceSet = true;\n-                log(\"Changing source: \\\"\" + source + \"\\\" -> \\\"\" + sourceFileNameNew + \"\\\"\");\n-                super.visitSource(sourceFileNameNew, debug);\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                if (element instanceof SourceFileAttribute src) {\n+                    sourceSet = true;\n+                    log(\"Changing source: \\\"\" + src.sourceFile() + \"\\\" -> \\\"\" + sourceFileNameNew + \"\\\"\");\n+                    builder.with(SourceFileAttribute.of(sourceFileNameNew));\n+                } else {\n+                    builder.with(element);\n+                }\n@@ -156,1 +164,1 @@\n-            public void visitEnd() {\n+            public void atEnd(ClassBuilder builder) {\n@@ -159,1 +167,1 @@\n-                    super.visitSource(sourceFileNameNew, null);\n+                    builder.with(SourceFileAttribute.of(sourceFileNameNew));\n@@ -161,1 +169,0 @@\n-                super.visitEnd();\n@@ -163,2 +170,1 @@\n-        }, 0);\n-        return cw.toByteArray();\n+        });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineGenericSignatureTest.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -44,0 +43,4 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileVersion;\n@@ -49,8 +52,0 @@\n-import java.util.Arrays;\n-\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-\n-import static org.objectweb.asm.Opcodes.ASM6;\n-import static org.objectweb.asm.Opcodes.V1_8;\n@@ -72,25 +67,8 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            \/\/ Force an older ASM to force a bytecode update\n-            ClassVisitor cv = new DummyClassVisitor(ASM6, cw) { };\n-            ClassReader cr = new ClassReader(classfileBuffer);\n-            cr.accept(cv, 0);\n-            byte[] bytes = cw.toByteArray();\n-            return bytes;\n-        }\n-\n-        public class DummyClassVisitor extends ClassVisitor {\n-\n-            public DummyClassVisitor(int api, ClassVisitor cv) {\n-                super(api, cv);\n-            }\n-\n-            public void visit(\n-                    final int version,\n-                    final int access,\n-                    final String name,\n-                    final String signature,\n-                    final String superName,\n-                    final String[] interfaces) {\n-                \/\/ Artificially lower to JDK 8 version to force a redefine\n-                cv.visit(V1_8, access, name, signature, superName, interfaces);\n-            }\n+            return ClassFile.of().transformClass(ClassFile.of().parse(classfileBuffer), (classBuilder, classElement) -> {\n+                if (classElement instanceof ClassFileVersion cfv) {\n+                    \/\/ Force a redefine with different class file versions\n+                    classBuilder.with(ClassFileVersion.of(cfv.majorVersion() - 1, 0));\n+                } else {\n+                    classBuilder.with(classElement);\n+                }\n+            });\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineObject.java","additions":12,"deletions":34,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/testlibrary\/asm\n@@ -45,7 +44,11 @@\n-\n-import org.objectweb.asm.AnnotationVisitor;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.Type;\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n@@ -84,43 +87,1 @@\n-    private static class VersionScanner extends ClassVisitor {\n-        private Integer detectedVersion;\n-        private Integer versionToSet;\n-        \/\/ to get version\n-        public VersionScanner() {\n-            super(Opcodes.ASM7);\n-        }\n-        \/\/ to set version\n-        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n-            super(Opcodes.ASM7, classVisitor);\n-            versionToSet = verToSet;\n-        }\n-\n-        public int detectedVersion() {\n-            if (detectedVersion == null) {\n-                throw new RuntimeException(\"Version not detected\");\n-            }\n-            return detectedVersion;\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n-            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n-                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n-                    @Override\n-                    public void visit(String name, Object value) {\n-                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n-                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n-                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n-                            detectedVersion = intValue;\n-                            if (versionToSet != null) {\n-                                \/\/log(\"replace with \" + versionToSet);\n-                                value = versionToSet;\n-                            }\n-                        }\n-                        super.visit(name, value);\n-                    }\n-                };\n-            }\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-    }\n+    private static final ClassDesc CD_ClassVersion = ClassVersion.class.describeConstable().orElseThrow();\n@@ -133,4 +94,4 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        ClassReader cr = new ClassReader(initialClassBytes);\n-        cr.accept(new VersionScanner(ver, cw), 0);\n-        return cw.toByteArray();\n+        return ClassFile.of().transformClass(ClassFile.of().parse(initialClassBytes),\n+                \/\/ overwrites previously passed RVAA\n+                ClassTransform.endHandler(classBuilder -> classBuilder.with(RuntimeVisibleAnnotationsAttribute\n+                        .of(Annotation.of(CD_ClassVersion, AnnotationElement.ofInt(\"value\", ver))))));\n@@ -141,4 +102,11 @@\n-        ClassReader cr = new ClassReader(classBytes);\n-        VersionScanner scanner = new VersionScanner();\n-        cr.accept(scanner, 0);\n-        return scanner.detectedVersion();\n+        ClassModel classModel = ClassFile.of().parse(classBytes);\n+        RuntimeVisibleAnnotationsAttribute rvaa = classModel.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow();\n+        List<AnnotationElement> classVersionElementValuePairs = rvaa.annotations().stream()\n+                .filter(anno -> anno.className().isFieldType(CD_ClassVersion))\n+                .findFirst().orElseThrow().elements();\n+        if (classVersionElementValuePairs.size() != 1)\n+            throw new NoSuchElementException();\n+        AnnotationElement elementValuePair = classVersionElementValuePairs.getFirst();\n+        if (!elementValuePair.name().equalsString(\"value\") || !(elementValuePair.value() instanceof AnnotationValue.OfInt intVal))\n+            throw new NoSuchElementException();\n+        return intVal.intValue();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":27,"deletions":59,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -33,1 +34,0 @@\n-import java.util.concurrent.*;\n@@ -37,2 +37,4 @@\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -62,1 +64,1 @@\n-            ThreadFactory factory = virtualThreadBuilder(scheduler).factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadBuilder(scheduler).factory();\n@@ -101,18 +103,0 @@\n-\n-    private static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n-        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n-        try {\n-            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-            ctor.setAccessible(true);\n-            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (cause instanceof RuntimeException re) {\n-                throw re;\n-            }\n-            throw new RuntimeException(e);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest\/ThreadStateTest.java","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LingeredAppWithVirtualThread extends LingeredApp implements Runnable {\n+\n+    private static final String THREAD_NAME = \"target thread\";\n+\n+    private static final MethodHandle hndSleep;\n+\n+    private static final int sleepArg;\n+\n+    private static final CountDownLatch signal = new CountDownLatch(1);\n+\n+    static {\n+        MemorySegment func;\n+        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            func = SymbolLookup.libraryLookup(\"Kernel32\", Arena.global())\n+                               .findOrThrow(\"Sleep\");\n+            sleepArg = 3600_000; \/\/ 1h in milliseconds\n+        } else {\n+            func = Linker.nativeLinker()\n+                         .defaultLookup()\n+                         .findOrThrow(\"sleep\");\n+            sleepArg = 3600; \/\/ 1h in seconds\n+        }\n+\n+        var desc = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);\n+        hndSleep = Linker.nativeLinker().downcallHandle(func, desc);\n+    }\n+\n+    @Override\n+    public void run() {\n+        Thread.yield();\n+        signal.countDown();\n+        try {\n+            hndSleep.invoke(sleepArg);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            Thread.ofVirtual()\n+                  .name(THREAD_NAME)\n+                  .start(new LingeredAppWithVirtualThread());\n+\n+            signal.await();\n+            LingeredApp.main(args);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithVirtualThread.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8369505\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackWithVirtualThread\n+ *\/\n+public class TestJhsdbJstackWithVirtualThread {\n+\n+    private static void runJstack(LingeredApp app) throws Exception {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n+        launcher.addVMArgs(Utils.getFilteredTestJavaOpts(\"-showversion\"));\n+        launcher.addToolArg(\"jstack\");\n+        launcher.addToolArg(\"--pid\");\n+        launcher.addToolArg(Long.toString(app.getPid()));\n+\n+        ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+        Process jhsdb = pb.start();\n+        OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+        jhsdb.waitFor();\n+\n+        System.out.println(out.getStdout());\n+        System.err.println(out.getStderr());\n+\n+        out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+        out.shouldNotContain(\"must have non-zero frame size\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        LingeredApp app = null;\n+\n+        try {\n+            app = new LingeredAppWithVirtualThread();\n+            LingeredApp.startApp(app);\n+            System.out.println(\"Started LingeredApp with pid \" + app.getPid());\n+            runJstack(app);\n+            System.out.println(\"Test Completed\");\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackWithVirtualThread.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -394,1 +394,1 @@\n-        Asserts.assertNotNull(G.uniformDoubles(0, 0));\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformDoubles(0, 0));\n@@ -400,1 +400,1 @@\n-        Asserts.assertNotNull(G.uniformFloats(0, 0));\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformFloats(0, 0));\n@@ -595,2 +595,7 @@\n-            float a = floatBoundGen.next(), b = floatBoundGen.next();\n-            float lo = Math.min(a, b), hi = Math.max(a, b);\n+            float lo = 1, hi = 0;\n+            \/\/ Failure of a single round is very rare, repeated failure even rarer.\n+            while (lo >= hi) {\n+                float a = floatBoundGen.next(), b = floatBoundGen.next();\n+                lo = Math.min(a, b);\n+                hi = Math.max(a, b);\n+            }\n@@ -607,2 +612,7 @@\n-            double a = doubleBoundGen.next(), b = doubleBoundGen.next();\n-            double lo = Math.min(a, b), hi = Math.max(a, b);\n+            double lo = 1, hi = 0;\n+            \/\/ Failure of a single round is very rare, repeated failure even rarer.\n+            while (lo >= hi) {\n+                double a = doubleBoundGen.next(), b = doubleBoundGen.next();\n+                lo = Math.min(a, b);\n+                hi = Math.max(a, b);\n+            }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/generators\/tests\/TestGenerators.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,7 @@\n-import java.util.Set;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n@@ -29,1 +35,0 @@\n-import compiler.lib.ir_framework.shared.TestRunException;\n@@ -31,0 +36,1 @@\n+import compiler.lib.ir_framework.shared.TestRunException;\n@@ -35,0 +41,1 @@\n+ * @bug 8365262 8369232\n@@ -42,5 +49,0 @@\n-    static void hasNFailures(String s, int count) {\n-        if (!s.matches(\"The following scenarios have failed: (#[0-9](, )?){\" + count + \"}. Please check stderr for more information.\")) {\n-            throw new RuntimeException(\"Expected \" + count + \" failures in \\\"\" + s + \"\\\"\");\n-        }\n-    }\n@@ -49,11 +51,3 @@\n-        \/\/ Test argument handling\n-        try {\n-            TestFramework t = new TestFramework();\n-            t.addCrossProductScenarios((Set<String>[]) null);\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestFormatException e) {}\n-        try {\n-            TestFramework t = new TestFramework();\n-            t.addCrossProductScenarios(Set.of(\"foo\", \"bar\"), null);\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestFormatException e) {}\n+        expectFormatFailure((Set<String>[]) null);\n+        expectFormatFailure(Set.of(\"foo\", \"bar\"), null);\n+\n@@ -63,2 +57,6 @@\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (NullPointerException e) {} \/\/ Set.of prevents null elements\n+            shouldHaveThrown();\n+        } catch (NullPointerException _) {\n+            \/\/ Expected: Set.of prevents null elements\n+        }\n+\n+\n@@ -73,10 +71,13 @@\n-        try {\n-            TestFramework t1 = new TestFramework();\n-            t1.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\",\n-                                               \"-XX:TLABRefillWasteFraction=53\",\n-                                               \"-XX:TLABRefillWasteFraction=64\"));\n-            t1.start();\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestRunException e) {\n-            hasNFailures(e.getMessage(), 3);\n-        }\n+        new TestCase()\n+                .inputFlags(Set.of(\n+                                    Set.of(\"-XX:TLABRefillWasteFraction=51\",\n+                                           \"-XX:TLABRefillWasteFraction=53\",\n+                                           \"-XX:TLABRefillWasteFraction=64\")\n+                            )\n+                )\n+                .expectedScenariosWithFlags(Set.of(\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=64\")\n+                ))\n+                .run();\n@@ -85,9 +86,13 @@\n-        try {\n-            TestFramework t2 = new TestFramework();\n-            t2.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n-                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\", \"-XX:+UseNewCode3\"));\n-            t2.start();\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestRunException e) {\n-            hasNFailures(e.getMessage(), 3);\n-        }\n+        new TestCase()\n+                .inputFlags(Set.of(\n+                                    Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n+                                    Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\", \"-XX:+UseNewCode3\")\n+                            )\n+                )\n+                .expectedScenariosWithFlags(Set.of(\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode3\")\n+                ))\n+                .run();\n+\n@@ -96,9 +101,14 @@\n-        try {\n-            TestFramework t3 = new TestFramework();\n-            t3.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:TLABRefillWasteFraction=64\"),\n-                                        Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\"));\n-            t3.start();\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestRunException e) {\n-            hasNFailures(e.getMessage(), 4);\n-        }\n+        new TestCase()\n+                .inputFlags(Set.of(\n+                                    Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:TLABRefillWasteFraction=64\"),\n+                                    Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\")\n+                            )\n+                )\n+                .expectedScenariosWithFlags(Set.of(\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:-UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=64\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=64\", \"-XX:-UseNewCode\")\n+                ))\n+                .run();\n+\n@@ -107,0 +117,56 @@\n+        new TestCase()\n+                .inputFlags(Set.of(\n+                                    Set.of(\"-XX:TLABRefillWasteFraction=50 -XX:+UseNewCode\", \"-XX:TLABRefillWasteFraction=40\"),\n+                                    Set.of(\"-XX:+UseNewCode2\")\n+                            )\n+                )\n+                .expectedScenariosWithFlags(Set.of(\n+                        Set.of(\"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=40\", \"-XX:+UseNewCode2\")\n+                ))\n+                .run();\n+\n+        \/\/ Test with an empty string, resulting in 6 scenarios.\n+        new TestCase()\n+                .inputFlags(Set.of(\n+                                    Set.of(\"\", \"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                    Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\")\n+                            )\n+                )\n+                .expectedScenariosWithFlags(Set.of(\n+                        Set.of(\"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode2\")\n+                ))\n+                .run();\n+\n+        \/\/ Test with 3 input sets which equals to 2x2x2 = 8 scenarios.\n+        new TestCase()\n+                .inputFlags(Set.of(\n+                                    Set.of(\"-XX:TLABRefillWasteFraction=51\",\n+                                           \"-XX:TLABRefillWasteFraction=53\"),\n+                                    Set.of(\"-XX:+UseNewCode\",\n+                                           \"-XX:-UseNewCode\"),\n+                                    Set.of(\"-XX:+UseNewCode2\",\n+                                           \"-XX:-UseNewCode2\")\n+                            )\n+                )\n+                .expectedScenariosWithFlags(Set.of(\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:-UseNewCode\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:-UseNewCode\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\", \"-XX:-UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\", \"-XX:-UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:-UseNewCode\", \"-XX:-UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:-UseNewCode\", \"-XX:-UseNewCode2\")\n+                ))\n+                .run();\n+\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.addScenarios(new Scenario(0, \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\"));\n+        testFramework.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                               Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n@@ -108,7 +174,4 @@\n-            TestFramework t4 = new TestFramework();\n-            t4.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=50 -XX:+UseNewCode\", \"-XX:TLABRefillWasteFraction=40\"),\n-                                        Set.of(\"-XX:+UseNewCode2\"));\n-            t4.start();\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestRunException e) {\n-            hasNFailures(e.getMessage(), 1);\n+            testFramework.addScenarios(new Scenario(4, \"-XX:+UseNewCode3\")); \/\/ fails because index 4 is already used\n+            shouldHaveThrown();\n+        } catch (TestFormatException _) {\n+            \/\/ Expected.\n@@ -116,0 +179,15 @@\n+        testFramework.addScenarios(new Scenario(5, \"-XX:+UseNewCode3\"));\n+\n+        new TestCase()\n+                .expectedScenariosWithFlags(Set.of(\n+                        Set.of(\"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n+                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode2\"),\n+                        Set.of(\"-XX:+UseNewCode3\")\n+                ))\n+                .runWithPreAddedScenarios(testFramework);\n+\n+        runEndToEndTest();\n+    }\n@@ -117,1 +195,2 @@\n-        \/\/ Test with an empty string. All 6 scenarios fail because 64 is the default value for TLABRefillWasteFraction.\n+    private static void expectFormatFailure(Set<String>... flagSets) {\n+        TestFramework testFramework = new TestFramework();\n@@ -119,7 +198,4 @@\n-            TestFramework t5 = new TestFramework();\n-            t5.addCrossProductScenarios(Set.of(\"\", \"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n-                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n-            t5.start();\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestRunException e) {\n-            hasNFailures(e.getMessage(), 6);\n+            testFramework.addCrossProductScenarios(flagSets);\n+            shouldHaveThrown();\n+        } catch (TestFormatException _) {\n+            \/\/ Expected.\n@@ -127,0 +203,1 @@\n+    }\n@@ -128,14 +205,92 @@\n-        try {\n-            TestFramework t6 = new TestFramework();\n-            t6.addScenarios(new Scenario(0, \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\")); \/\/ failPair\n-            t6.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n-                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n-            try {\n-                t6.addScenarios(new Scenario(4, \"-XX:+UseNewCode3\")); \/\/ fails because index 4 is already used\n-            Asserts.fail(\"Should have thrown exception\");\n-            } catch (TestFormatException e) {}\n-            t6.addScenarios(new Scenario(5, \"-XX:+UseNewCode3\")); \/\/ fail default\n-            t6.start();\n-            Asserts.fail(\"Should have thrown exception\");\n-        } catch (TestRunException e) {\n-            hasNFailures(e.getMessage(), 6);\n+    private static void shouldHaveThrown() {\n+        Asserts.fail(\"Should have thrown exception\");\n+    }\n+\n+    static class TestCase {\n+        private Set<Set<String>> inputFlags;\n+        private Set<Set<String>> expectedScenariosWithFlags;\n+\n+        public TestCase inputFlags(Set<Set<String>> inputFlags) {\n+            this.inputFlags = inputFlags;\n+            return this;\n+        }\n+\n+        public TestCase expectedScenariosWithFlags(Set<Set<String>> expectedScenariosWithFlags) {\n+            this.expectedScenariosWithFlags = expectedScenariosWithFlags;\n+            return this;\n+        }\n+\n+        public void run() {\n+            TestFramework testFramework = new TestFramework();\n+            testFramework.addCrossProductScenarios(inputFlags.toArray(new Set[0]));\n+            runWithPreAddedScenarios(testFramework);\n+        }\n+\n+        public void runWithPreAddedScenarios(TestFramework testFramework) {\n+            List<Scenario> scenariosFromCrossProduct = getScenarios(testFramework);\n+            assertScenarioCount(expectedScenariosWithFlags.size(), scenariosFromCrossProduct);\n+            assertScenariosWithFlags(scenariosFromCrossProduct, expectedScenariosWithFlags);\n+            assertSameResultWhenManuallyAdding(scenariosFromCrossProduct, expectedScenariosWithFlags);\n+        }\n+\n+        private static void assertScenarioCount(int expectedCount, List<Scenario> scenarios) {\n+            Asserts.assertEQ(expectedCount, scenarios.size(), \"Scenario count is off\");\n+        }\n+\n+        \/**\n+         * Check that the added scenarios to the IR framework with TestFramework.addCrossProductScenarios()\n+         * (i.e. 'scenariosFromCrossProduct') match the expected flag combos (i.e. 'expectedScenariosWithFlags').\n+         *\/\n+        private static void assertScenariosWithFlags(List<Scenario> scenariosFromCrossProduct,\n+                                                     Set<Set<String>> expectedScenariosWithFlags) {\n+            for (Set<String> expectedScenarioFlags : expectedScenariosWithFlags) {\n+                if (scenariosFromCrossProduct.stream()\n+                        .map(Scenario::getFlags)\n+                        .map(Set::copyOf)\n+                        .anyMatch(flags -> flags.equals(expectedScenarioFlags))) {\n+                    continue;\n+                }\n+                System.err.println(\"Scenarios from cross product:\");\n+                for (Scenario s : scenariosFromCrossProduct) {\n+                    System.err.println(Arrays.toString(s.getFlags().toArray()));\n+                }\n+                throw new RuntimeException(\"Could not find a scenario with the provided flags: \" + Arrays.toString(expectedScenarioFlags.toArray()));\n+            }\n+        }\n+\n+        \/**\n+         * Add scenarios for the provided flag sets in 'expectedScenariosWithFlags' by using TestFramework.addScenarios().\n+         * We should end up with the same scenarios as if we added them with TestFramework.addCrossProductScenarios().\n+         * This is verified by this method by comparing the flags of the scenarios, ignoring scenario indices.\n+         *\/\n+        private static void assertSameResultWhenManuallyAdding(List<Scenario> scenariosFromCrossProduct,\n+                                                               Set<Set<String>> expectedScenariosWithFlags) {\n+            List<Scenario> expectedScenarios = getScenariosWithFlags(expectedScenariosWithFlags);\n+            List<Scenario> fetchedScenarios = addScenariosAndFetchFromFramework(expectedScenarios);\n+            assertSameScenarios(scenariosFromCrossProduct, fetchedScenarios);\n+        }\n+\n+        private static List<Scenario> getScenariosWithFlags(Set<Set<String>> expectedScenariosWithFlags) {\n+            List<Scenario> expecedScenarioList = new ArrayList<>();\n+            int index = -1; \/\/ Use some different indices - should not matter what we choose.\n+            for (Set<String> expectedScenarioFlags : expectedScenariosWithFlags) {\n+                expecedScenarioList.add(new Scenario(index--, expectedScenarioFlags.toArray(new String[0])));\n+            }\n+            return expecedScenarioList;\n+        }\n+\n+        private static List<Scenario> addScenariosAndFetchFromFramework(List<Scenario> expecedScenarioList) {\n+            TestFramework testFramework = new TestFramework();\n+            testFramework.addScenarios(expecedScenarioList.toArray(new Scenario[0]));\n+            return getScenarios(testFramework);\n+        }\n+\n+        private static void assertSameScenarios(List<Scenario> scenariosFromCrossProduct,\n+                                                List<Scenario> expectedScenarios) {\n+            assertScenariosWithFlags(scenariosFromCrossProduct, fetchFlags(expectedScenarios));\n+        }\n+\n+        private static Set<Set<String>> fetchFlags(List<Scenario> scenarios) {\n+            return scenarios.stream()\n+                    .map(scenario -> new HashSet<>(scenario.getFlags()))\n+                    .collect(Collectors.toSet());\n@@ -145,3 +300,9 @@\n-    @Test\n-    @IR(applyIf = {\"TLABRefillWasteFraction\", \"64\"}, counts = {IRNode.CALL, \"1\"})\n-    public void failDefault() {\n+    private static List<Scenario> getScenarios(TestFramework testFramework) {\n+        Field field;\n+        try {\n+            field = TestFramework.class.getDeclaredField(\"scenarios\");\n+            field.setAccessible(true);\n+            return (List<Scenario>)field.get(testFramework);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n@@ -150,3 +311,31 @@\n-    @Test\n-    @IR(applyIf = {\"TLABRefillWasteFraction\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n-    public void fail1() {\n+    \/**\n+     *  Also run a simple end-to-end test to sanity check the API method. We capture the stderr to fetch the\n+     *  scenario flags.\n+     *\/\n+    private static void runEndToEndTest() {\n+        TestFramework testFramework = new TestFramework();\n+\n+        \/\/ Capture stderr\n+        PrintStream originalErr = System.err;\n+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+        PrintStream printStream = new PrintStream(outputStream);\n+        System.setErr(printStream);\n+\n+        try {\n+            testFramework\n+                    .addCrossProductScenarios(Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\"),\n+                                              Set.of(\"-XX:+UseNewCode2\", \"-XX:-UseNewCode2\"))\n+                    .addFlags()\n+                    .start();\n+            shouldHaveThrown();\n+        } catch (TestRunException e) {\n+            \/\/ Expected.\n+            System.setErr(originalErr);\n+            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #0, #1, #2, #3.\"));\n+            String stdErr = outputStream.toString();\n+            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:+UseNewCode, -XX:+UseNewCode2]\"));\n+            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:-UseNewCode, -XX:-UseNewCode2]\"));\n+            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:+UseNewCode, -XX:-UseNewCode2]\"));\n+            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:-UseNewCode, -XX:+UseNewCode2]\"));\n+            Asserts.assertEQ(4, scenarioCount(stdErr));\n+        }\n@@ -155,3 +344,8 @@\n-    @Test\n-    @IR(applyIf = {\"TLABRefillWasteFraction\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n-    public void fail2() {\n+    public static int scenarioCount(String stdErr) {\n+        Pattern pattern = Pattern.compile(\"Scenario flags\");\n+        Matcher matcher = pattern.matcher(stdErr);\n+        int count = 0;\n+        while (matcher.find()) {\n+            count++;\n+        }\n+        return count;\n@@ -161,2 +355,2 @@\n-    @IR(applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseNewCode\", \"true\"}, counts = {IRNode.CALL, \"1\"})\n-    public void failPair() {\n+    public void endToEndTest() {\n+        throw new RuntimeException(\"executed test\");\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenariosCrossProduct.java","additions":282,"deletions":88,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -73,0 +73,7 @@\n+            \/\/\n+            \/\/ Some expressions can throw Exceptions. We have to catch them. In such a case, we return\n+            \/\/ the Exception instead of the value from the expression, and compare the Exceptions.\n+            \/\/\n+            \/\/ Some Expressions do not have a deterministic result. For example, different NaN or\n+            \/\/ precision results from some operators. We only compare the results if we know that the\n+            \/\/ result is deterministically the same.\n@@ -79,3 +86,5 @@\n-                    #returnType v0 = ${primitiveConTest}_compiled();\n-                    #returnType v1 = ${primitiveConTest}_reference();\n-                    Verify.checkEQ(v0, v1);\n+                    Object v0 = ${primitiveConTest}_compiled();\n+                    Object v1 = ${primitiveConTest}_reference();\n+                \"\"\",\n+                expression.info.isResultDeterministic ? \"Verify.checkEQ(v0, v1);\\n\" : \"\",\n+                \"\"\"\n@@ -85,1 +94,2 @@\n-                public static #returnType ${primitiveConTest}_compiled() {\n+                public static Object ${primitiveConTest}_compiled() {\n+                try {\n@@ -87,1 +97,4 @@\n-                \"return \", expressionToken, \";\\n\",\n+                    \"return \", expressionToken, \";\\n\",\n+                    expression.info.exceptions.stream().map(exception ->\n+                        \"} catch (\" + exception + \" e) { return e;\\n\"\n+                    ).toList(),\n@@ -89,0 +102,3 @@\n+                    } finally {\n+                        \/\/ Just so that javac is happy if there are no exceptions to catch.\n+                    }\n@@ -92,1 +108,2 @@\n-                public static #returnType ${primitiveConTest}_reference() {\n+                public static Object ${primitiveConTest}_reference() {\n+                try {\n@@ -94,1 +111,4 @@\n-                \"return \", expressionToken, \";\\n\",\n+                    \"return \", expressionToken, \";\\n\",\n+                    expression.info.exceptions.stream().map(exception ->\n+                        \"} catch (\" + exception + \" e) { return e;\\n\"\n+                    ).toList(),\n@@ -96,0 +116,3 @@\n+                    } finally {\n+                        \/\/ Just so that javac is happy if there are no exceptions to catch.\n+                    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestExpressions.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.constant.ClassDesc;\n@@ -45,5 +48,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-\n@@ -264,5 +262,4 @@\n-       ClassReader cr = new ClassReader(classToMorph);\n-       ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);\n-       ClassVisitor cv = new ClassRenamer(cw, newName);\n-       cr.accept(cv, 0);\n-       return cw.toByteArray();\n+       var context = ClassFile.of();\n+       return context.transformClass(context.parse(classToMorph),\n+               ClassDesc.ofInternalName(newName),\n+               ClassTransform.ACCEPT_ALL);\n@@ -270,18 +267,0 @@\n-\n-    \/**\n-     * Visitor to rename class.\n-     *\/\n-    static class ClassRenamer extends ClassVisitor implements Opcodes {\n-        private final String newName;\n-\n-        public ClassRenamer(ClassVisitor cv, String newName) {\n-            super(ASM4, cv);\n-            this.newName = newName;\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            cv.visit(version, access, newName, signature, superName, interfaces);\n-        }\n-\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/GenClassPoolJar.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @requires vm.gc != \"Serial\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * @requires vm.gc != \"Serial\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/LinearListLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,0 +139,9 @@\n+        } catch (InvocationTargetException ite) {\n+            Throwable cause = ite.getCause();\n+            if (cause != null && (cause instanceof OutOfMemoryError) && cause.getMessage().contains(\"Metaspace\")) {\n+                \/\/ avoid string concatenation, which may create more classes.\n+                System.out.println(\"Got OOME in metaspace in PerformChecksHelper.callMethods(Class clazz). \");\n+                System.out.println(\"This is possible with -triggerUnloadingByFillingMetaspace\");\n+            } else {\n+                throw ite;\n+            }\n@@ -140,1 +149,1 @@\n-            if (e.getMessage().trim().toLowerCase().contains(\"metaspace\")) {\n+            if (e.getMessage().contains(\"Metaspace\")) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/PerformChecksHelper.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n@@ -31,5 +34,0 @@\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.FieldVisitor;\n-import org.objectweb.asm.Opcodes;\n-\n@@ -82,2 +80,1 @@\n-        FieldExplorer explorer = new FieldExplorer(cls);\n-        List<String> fields = explorer.get();\n+        List<String> fields = getFields(cls);\n@@ -87,23 +84,5 @@\n-    \/\/ helper class to get list of the class fields\n-    \/\/ in the order they appear in the class file\n-    static class FieldExplorer extends ClassVisitor {\n-        private final Class cls;\n-        private List<String> fieldNameAndSig = new ArrayList<>();\n-        private FieldExplorer(Class cls) {\n-            super(Opcodes.ASM7);\n-            this.cls = cls;\n-        }\n-\n-        @Override\n-        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-            System.out.println(\"  field '\" + name + \"', type = \" + descriptor);\n-            fieldNameAndSig.add(name);\n-            fieldNameAndSig.add(descriptor);\n-            return super.visitField(access, name, descriptor, signature, value);\n-        }\n-\n-        private InputStream getClassBytes() throws Exception {\n-            String clsName = cls.getName();\n-            String clsPath = clsName.replace('.', '\/') + \".class\";\n-            return cls.getClassLoader().getResourceAsStream(clsPath);\n-        }\n+    private static InputStream getClassBytes(Class<?> cls) throws Exception {\n+        String clsName = cls.getName();\n+        String clsPath = clsName.replace('.', '\/') + \".class\";\n+        return cls.getClassLoader().getResourceAsStream(clsPath);\n+    }\n@@ -111,6 +90,10 @@\n-        \/\/ each field is represented by 2 Strings in the list: name and type descriptor\n-        public List<String> get() throws Exception {\n-            System.out.println(\"Class \" + cls.getName());\n-            try (InputStream classBytes = getClassBytes()) {\n-                ClassReader classReader = new ClassReader(classBytes);\n-                classReader.accept(this, 0);\n+    \/\/ get list of the class fields in the order they appear in the class file\n+    \/\/ each field is represented by 2 Strings in the list: name and type descriptor\n+    public static List<String> getFields(Class<?> cls) throws Exception {\n+        System.out.println(\"Class \" + cls.getName());\n+        List<String> fieldNameAndSig = new ArrayList<>();\n+        try (InputStream classBytes = getClassBytes(cls)) {\n+            ClassModel classModel = ClassFile.of().parse(classBytes.readAllBytes());\n+            for (FieldModel field : classModel.fields()) {\n+                fieldNameAndSig.add(field.fieldName().stringValue());\n+                fieldNameAndSig.add(field.fieldType().stringValue());\n@@ -118,1 +101,0 @@\n-            return fieldNameAndSig;\n@@ -120,0 +102,1 @@\n+        return fieldNameAndSig;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007.java","additions":20,"deletions":37,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentThreadCpuTime\/curthrcputime001\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadCpuTime\/thrcputime001\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,2 @@\n+    \/\/ The thread name prefix is used to find thread from jvmti agent.\n+    final static String threadNamePrefix = \"Debuggee Thread\";\n@@ -133,1 +135,1 @@\n-        super(\"Debuggee Thread \" + o1 + o2);\n+        super(threadNamePrefix + \" \" + o1 + o2);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t001.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-static threadDesc *threadList = nullptr;\n-static jint threads_count = 0;\n+static threadDesc *debuggee_threads = nullptr;\n+static jint debuggee_threads_cnt = 0;\n@@ -48,0 +48,3 @@\n+static const char* THREAD_NAME_PREFIX = \"Debugee Thread\";\n+static const size_t THREAD_NAME_PREFIX_LEN = strlen(THREAD_NAME_PREFIX);\n+\n@@ -59,1 +62,1 @@\n-        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", threadList[pThread].name);\n+        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", debuggee_threads[pThread].name);\n@@ -61,1 +64,1 @@\n-                jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n+                jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n@@ -77,2 +80,2 @@\n-        for (cThread = 0; cThread < threads_count; cThread++) {\n-            if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n+        for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n+            if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n@@ -87,1 +90,1 @@\n-        if (!NSK_VERIFY(cThread != threads_count))\n+        if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n@@ -90,1 +93,1 @@\n-            threadList[cThread].name);\n+            debuggee_threads[cThread].name);\n@@ -106,0 +109,1 @@\n+    int threads_count = 0;\n@@ -107,1 +111,1 @@\n-    NSK_DISPLAY0(\"Create threadList\\n\");\n+    NSK_DISPLAY0(\"Create debuggee_threads\\n\");\n@@ -117,1 +121,1 @@\n-            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&threadList)))\n+            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&debuggee_threads)))\n@@ -130,3 +134,11 @@\n-        threadList[i].thread = threads[i];\n-        threadList[i].dfn = -1;\n-        threadList[i].name = info.name;\n+        if (!strncmp(info.name, THREAD_NAME_PREFIX, THREAD_NAME_PREFIX_LEN)) {\n+            NSK_DISPLAY1(\"Skipping thread %s\\n\", info.name);\n+            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)info.name)))\n+                return NSK_FALSE;\n+            continue;\n+        }\n+\n+        debuggee_threads[debuggee_threads_cnt].thread = threads[i];\n+        debuggee_threads[debuggee_threads_cnt].dfn = -1;\n+        debuggee_threads[debuggee_threads_cnt].name = info.name;\n+        debuggee_threads_cnt++;\n@@ -139,2 +151,2 @@\n-    for (i = 0; i < threads_count; i++) {\n-        if (threadList[i].dfn < 0) {\n+    for (i = 0; i < debuggee_threads_cnt; i++) {\n+        if (debuggee_threads[i].dfn < 0) {\n@@ -142,1 +154,1 @@\n-            threadList[i].dfn = gDfn++;\n+            debuggee_threads[i].dfn = gDfn++;\n@@ -145,1 +157,1 @@\n-                        jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n+                        jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n@@ -153,2 +165,2 @@\n-                for (cThread = 0; cThread < threads_count; cThread++) {\n-                    if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n+                for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n+                    if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n@@ -163,1 +175,1 @@\n-                if (!NSK_VERIFY(cThread != threads_count))\n+                if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n@@ -165,2 +177,2 @@\n-                if (threadList[cThread].dfn < 0) {\n-                    threadList[cThread].dfn = gDfn++;\n+                if (debuggee_threads[cThread].dfn < 0) {\n+                    debuggee_threads[cThread].dfn = gDfn++;\n@@ -182,3 +194,3 @@\n-    for (i = 0; i < threads_count; i++) {\n-        if (threadList[i].name != nullptr) {\n-            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threadList[i].name)))\n+    for (i = 0; i < debuggee_threads_cnt; i++) {\n+        if (debuggee_threads[i].name != nullptr) {\n+            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)debuggee_threads[i].name)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t001\/tc03t001.cpp","additions":38,"deletions":26,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,2 @@\n-\n+    \/\/ The thread name prefix is used to find thread from jvmti agent.\n+    final static String threadNamePrefix = \"Debuggee Thread\";\n@@ -115,1 +116,1 @@\n-        super(\"Debuggee Thread \" + o1 + o2);\n+        super(threadNamePrefix + \" \" + o1 + o2);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t002.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-static threadDesc *threadList = nullptr;\n-static jint threads_count = 0;\n+static threadDesc *debuggee_threads = nullptr;\n+static jint debuggee_threads_cnt = 0;\n@@ -48,0 +48,3 @@\n+static const char* THREAD_NAME_PREFIX = \"Debugee Thread\";\n+static const size_t THREAD_NAME_PREFIX_LEN = strlen(THREAD_NAME_PREFIX);\n+\n@@ -59,1 +62,1 @@\n-        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", threadList[pThread].name);\n+        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", debuggee_threads[pThread].name);\n@@ -61,1 +64,1 @@\n-                jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n+                jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n@@ -77,2 +80,2 @@\n-        for (cThread = 0; cThread < threads_count; cThread++) {\n-            if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n+        for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n+            if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n@@ -87,1 +90,1 @@\n-        if (!NSK_VERIFY(cThread != threads_count))\n+        if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n@@ -90,1 +93,1 @@\n-            threadList[cThread].name);\n+            debuggee_threads[cThread].name);\n@@ -106,0 +109,1 @@\n+    int threads_count = 0;\n@@ -107,1 +111,1 @@\n-    NSK_DISPLAY0(\"Create threadList\\n\");\n+    NSK_DISPLAY0(\"Create debuggee_threads\\n\");\n@@ -117,1 +121,1 @@\n-            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&threadList)))\n+            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&debuggee_threads)))\n@@ -130,3 +134,11 @@\n-        threadList[i].thread = threads[i];\n-        threadList[i].dfn = -1;\n-        threadList[i].name = info.name;\n+        if (!strncmp(info.name, THREAD_NAME_PREFIX, THREAD_NAME_PREFIX_LEN)) {\n+            NSK_DISPLAY1(\"Skipping thread %s\\n\", info.name);\n+            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)info.name)))\n+                return NSK_FALSE;\n+            continue;\n+        }\n+\n+        debuggee_threads[debuggee_threads_cnt].thread = threads[i];\n+        debuggee_threads[debuggee_threads_cnt].dfn = -1;\n+        debuggee_threads[debuggee_threads_cnt].name = info.name;\n+        debuggee_threads_cnt++;\n@@ -139,2 +151,3 @@\n-    for (i = 0; i < threads_count; i++) {\n-        if (threadList[i].dfn < 0) {\n+    for (i = 0; i < debuggee_threads_cnt; i++) {\n+\n+        if (debuggee_threads[i].dfn < 0) {\n@@ -142,1 +155,1 @@\n-            threadList[i].dfn = gDfn++;\n+            debuggee_threads[i].dfn = gDfn++;\n@@ -145,1 +158,1 @@\n-                        jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n+                        jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n@@ -153,2 +166,2 @@\n-                for (cThread = 0; cThread < threads_count; cThread++) {\n-                    if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n+                for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n+                    if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n@@ -163,1 +176,1 @@\n-                if (!NSK_VERIFY(cThread != threads_count))\n+                if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n@@ -165,2 +178,2 @@\n-                if (threadList[cThread].dfn < 0) {\n-                    threadList[cThread].dfn = gDfn++;\n+                if (debuggee_threads[cThread].dfn < 0) {\n+                    debuggee_threads[cThread].dfn = gDfn++;\n@@ -182,3 +195,3 @@\n-    for (i = 0; i < threads_count; i++) {\n-        if (threadList[i].name != nullptr) {\n-            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threadList[i].name)))\n+    for (i = 0; i < debuggee_threads_cnt; i++) {\n+        if (debuggee_threads[i].name != nullptr) {\n+            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)debuggee_threads[i].name)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t002\/tc03t002.cpp","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.lang.ref.Cleaner;\n+import java.lang.ref.PhantomReference;\n@@ -80,1 +80,1 @@\n-     * Whole amount of time in milliseconds to wait for class loader to be reclaimed.\n+     * Phantom reference to the class loader.\n@@ -82,11 +82,1 @@\n-    private static final int WAIT_TIMEOUT = 15000;\n-\n-    \/**\n-     * Sleep time in milliseconds for the loop waiting for the class loader to be reclaimed.\n-     *\/\n-    private static final int WAIT_DELTA = 1000;\n-\n-    \/**\n-     * Has class loader been reclaimed or not.\n-     *\/\n-    volatile boolean is_reclaimed = false;\n+    private PhantomReference<Object> customClassLoaderPhantomRef = null;\n@@ -104,0 +94,8 @@\n+    \/**\n+     * Has class loader been reclaimed or not.\n+     *\/\n+    private boolean isClassLoaderReclaimed() {\n+        return customClassLoaderPhantomRef != null\n+            && customClassLoaderPhantomRef.refersTo(null);\n+    }\n+\n@@ -141,2 +139,1 @@\n-        \/\/ Register a Cleaner to inform us when the class loader has been reclaimed.\n-        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n+        customClassLoaderPhantomRef = new PhantomReference<>(customClassLoader, null);\n@@ -157,2 +154,1 @@\n-        \/\/ Register a Cleaner to inform us when the class loader has been reclaimed.\n-        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n+        customClassLoaderPhantomRef = new PhantomReference<>(customClassLoader, null);\n@@ -247,2 +243,0 @@\n-        is_reclaimed = false;\n-\n@@ -250,1 +244,0 @@\n-        long waitTimeout = (customClassLoader == null) ? 0 : WAIT_TIMEOUT;\n@@ -257,14 +250,0 @@\n-        \/\/ give GC chance to run and wait for receiving reclaim notification\n-        long timeToFinish = System.currentTimeMillis() + waitTimeout;\n-        while (!is_reclaimed && System.currentTimeMillis() < timeToFinish) {\n-            if (!stresser.continueExecution()) {\n-                return false;\n-            }\n-            try {\n-                \/\/ suspend thread for a while\n-                Thread.sleep(WAIT_DELTA);\n-            } catch (InterruptedException e) {\n-                throw new Failure(\"Unexpected InterruptedException while class unloading: \" + e);\n-            }\n-        }\n-\n@@ -272,1 +251,1 @@\n-        if (is_reclaimed) {\n+        if (isClassLoaderReclaimed()) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/ClassUnloader.java","additions":15,"deletions":36,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,2 +152,0 @@\n-    public static final int MAX_UNLOAD_ATTEMPS = 5;\n-\n@@ -157,2 +155,0 @@\n-        int unloadAttemps = 0;\n-\n@@ -160,5 +156,1 @@\n-            boolean wasUnloaded = false;\n-\n-            while (!wasUnloaded && (unloadAttemps++ < MAX_UNLOAD_ATTEMPS)) {\n-                wasUnloaded = classUnloader.unloadClass();\n-            }\n+            boolean wasUnloaded = classUnloader.unloadClass();\n@@ -186,7 +178,0 @@\n-    static public void sleep1sec() {\n-        try {\n-            Thread.sleep(1000);\n-        } catch (InterruptedException e) {\n-        }\n-    }\n-\n@@ -365,3 +350,0 @@\n-    public void voidValueMethod() {\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/AbstractDebuggeeTest.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-javax\/management\/remote\/mandatory\/loading\/MissingClassTest.java 8145413 windows-x64\n-\n@@ -43,21 +41,0 @@\n-##########\n-## Tests incompatible with virtual test thread factory.\n-## There is no goal to run all test with virtual test thread factory.\n-## So any test might be added as incompatible, the bug id is not required.\n-\n-# Incorrect stack\/threadgroup\/exception expectations for main thread\n-java\/lang\/StackWalker\/DumpStackTest.java 0000000 generic-all\n-java\/lang\/StackWalker\/StackWalkTest.java 0000000 generic-all\n-java\/lang\/StackWalker\/CallerFromMain.java 0000000 generic-all\n-java\/lang\/Thread\/MainThreadTest.java 0000000 generic-all\n-java\/lang\/Thread\/UncaughtExceptionsTest.java 0000000 generic-all\n-java\/lang\/invoke\/condy\/CondyNestedResolutionTest.java 0000000 generic-all\n-java\/lang\/ref\/OOMEInReferenceHandler.java 0000000 generic-all\n-java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 0000000 generic-all\n-jdk\/internal\/vm\/Continuation\/Scoped.java 0000000 generic-all\n-\n-# The problems with permissions\n-jdk\/jfr\/startupargs\/TestDumpOnExit.java 0000000 generic-all\n-java\/util\/Properties\/StoreReproducibilityTest.java 0000000 generic-all\n-javax\/management\/ImplementationVersion\/ImplVersionTest.java 0000000 generic-all\n-javax\/management\/remote\/mandatory\/version\/ImplVersionTest.java 0000000 generic-all\n@@ -66,1 +43,1 @@\n-java\/lang\/Thread\/virtual\/stress\/PingPong.java 8314996 macosx-all\n+java\/lang\/Thread\/virtual\/stress\/PingPong.java 8342977 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -687,1 +687,0 @@\n-javax\/swing\/JTabbedPane\/4624207\/bug4624207.java 8064922 macosx-all\n@@ -766,0 +765,1 @@\n+jdk\/jfr\/jvm\/TestWaste.java                                      8369949 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.Box;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.KeyStroke;\n+import javax.swing.UIManager;\n+\n+import static javax.swing.BorderFactory.createEmptyBorder;\n+\n+\/*\n+ * @test id=windows\n+ * @bug 8348760 8365375 8365389 8365625\n+ * @requires (os.family == \"windows\")\n+ * @summary Verify that Windows Look & Feel allows changing\n+ *          accelerator colors\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MenuItemAcceleratorColor\n+ *\/\n+\n+\/*\n+ * @test id=classic\n+ * @bug 8348760 8365375 8365389 8365625\n+ * @requires (os.family == \"windows\")\n+ * @summary Verify that Windows Classic Look & Feel allows changing\n+ *          accelerator colors\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MenuItemAcceleratorColor classic\n+ *\/\n+public final class MenuItemAcceleratorColor {\n+    private static final String INSTRUCTIONS =\n+            \"Click the Menu to open it.\\n\" +\n+            \"\\n\" +\n+            \"Verify that the first and the last menu items render \" +\n+            \"their accelerators using the default colors, the color \" +\n+            \"should match that of the menu item itself in regular and \" +\n+            \"selected states.\\n\" +\n+            \"\\n\" +\n+            \"Verify that the second menu item renders its accelerator \" +\n+            \"with green and that the color changes to red when selected.\\n\" +\n+            \"\\n\" +\n+            \"Verify that the third menu item renders its accelerator \" +\n+            \"with magenta and yellow correspondingly.\\n\" +\n+            \"\\n\" +\n+            \"Verify that only the fifth menu item renders its accelerator \" +\n+            \"with blue; both the fourth and sixth should render their \" +\n+            \"accelerator with a shade of gray.\\n\" +\n+            \"\\n\" +\n+            \"If the above conditions are satisfied, press the Pass button; \" +\n+            \"otherwise, press the Fail button.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel((args.length > 0 && \"classic\".equals(args[0]))\n+                                 ? \"com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel\"\n+                                 : \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n+\n+        PassFailJFrame.builder()\n+                      .instructions(INSTRUCTIONS)\n+                      .rows(20)\n+                      .columns(60)\n+                      .testUI(MenuItemAcceleratorColor::createUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Box createInfoPanel() {\n+        Box box = Box.createVerticalBox();\n+        box.add(new JLabel(\"Look and Feel: \"\n+                           + UIManager.getLookAndFeel()\n+                                      .getName()));\n+        box.add(new JLabel(\"Java version: \"\n+                           + System.getProperty(\"java.runtime.version\")));\n+        return box;\n+    }\n+\n+    private static JFrame createUI() {\n+        JPanel content = new JPanel(new BorderLayout());\n+        content.setBorder(createEmptyBorder(8, 8, 8, 8));\n+        content.add(createInfoPanel(),\n+                    BorderLayout.SOUTH);\n+\n+        JFrame frame = new JFrame(\"Accelerator colors in Windows L&F\");\n+        frame.setJMenuBar(createMenuBar());\n+        frame.add(content, BorderLayout.CENTER);\n+        frame.setSize(350, 370);\n+        return frame;\n+    }\n+\n+    private static JMenuBar createMenuBar() {\n+        JMenuItem first = new JMenuItem(\"First menu item\");\n+        first.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,\n+                                                    InputEvent.CTRL_DOWN_MASK));\n+\n+        \/\/ Modify colors for accelerator rendering\n+        Color acceleratorForeground = UIManager.getColor(\"MenuItem.acceleratorForeground\");\n+        Color acceleratorSelectionForeground = UIManager.getColor(\"MenuItem.acceleratorSelectionForeground\");\n+        UIManager.put(\"MenuItem.acceleratorForeground\", Color.GREEN);\n+        UIManager.put(\"MenuItem.acceleratorSelectionForeground\", Color.RED);\n+\n+        JMenuItem second = new JMenuItem(\"Second menu item\");\n+        second.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,\n+                                                     InputEvent.SHIFT_DOWN_MASK\n+                                                     | InputEvent.CTRL_DOWN_MASK));\n+\n+        UIManager.put(\"MenuItem.acceleratorForeground\", Color.MAGENTA);\n+        UIManager.put(\"MenuItem.acceleratorSelectionForeground\", Color.YELLOW);\n+        JMenuItem third = new JMenuItem(\"Third menu item\");\n+        third.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_T,\n+                                                    InputEvent.ALT_DOWN_MASK));\n+\n+        \/\/ Restore colors\n+        UIManager.put(\"MenuItem.acceleratorForeground\", acceleratorForeground);\n+        UIManager.put(\"MenuItem.acceleratorSelectionForeground\", acceleratorSelectionForeground);\n+\n+\n+        \/\/ Disabled foreground\n+        JMenuItem fourth = new JMenuItem(\"Fourth menu item\");\n+        fourth.setEnabled(false);\n+        fourth.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,\n+                                                     InputEvent.CTRL_DOWN_MASK));\n+\n+        Color disabledForeground = UIManager.getColor(\"MenuItem.disabledForeground\");\n+        UIManager.put(\"MenuItem.disabledForeground\", Color.BLUE);\n+\n+        JMenuItem fifth = new JMenuItem(\"Fifth menu item\");\n+        fifth.setEnabled(false);\n+        fifth.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,\n+                                                    InputEvent.CTRL_DOWN_MASK\n+                                                    | InputEvent.SHIFT_DOWN_MASK));\n+\n+        \/\/ Restore disabled foreground\n+        UIManager.put(\"MenuItem.disabledForeground\", disabledForeground);\n+\n+        JMenuItem sixth = new JMenuItem(\"Sixth menu item\");\n+        sixth.setEnabled(false);\n+        sixth.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X,\n+                                                    InputEvent.CTRL_DOWN_MASK\n+                                                    | InputEvent.ALT_DOWN_MASK));\n+\n+\n+        JMenuItem quit = new JMenuItem(\"Quit\");\n+        quit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,\n+                                                   InputEvent.CTRL_DOWN_MASK));\n+\n+        JMenu menu = new JMenu(\"Menu\");\n+        menu.add(first);\n+        menu.add(second);\n+        menu.add(third);\n+        menu.addSeparator();\n+        menu.add(fourth);\n+        menu.add(fifth);\n+        menu.add(sixth);\n+        menu.addSeparator();\n+        menu.add(quit);\n+\n+        JMenuBar menuBar = new JMenuBar();\n+        menuBar.add(menu);\n+\n+        return menuBar;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/windows\/MenuItem\/MenuItemAcceleratorColor.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -48,1 +48,1 @@\n-class FieldWatchpointsTarg {\n+value class FieldWatchpointsTarg {\n@@ -63,0 +63,2 @@\n+    \/\/ flattened field\n+    Value instanceField = new Value(2);\n@@ -66,3 +68,6 @@\n-        Value obj = new Value(2); \/\/ modify\n-        System.out.println(\"obj value = \" + obj.v); \/\/ access\n-        System.out.println(\"staticField value = \" + staticField.v); \/\/ access\n+        \/\/ modify FieldWatchpointsTarg.instanceField and FieldWatchpointsTarg.instanceField.v\n+        FieldWatchpointsTarg targ = new FieldWatchpointsTarg();\n+        \/\/ access FieldWatchpointsTarg.instanceField and FieldWatchpointsTarg.instanceField.v\n+        System.out.println(\"obj value = \" + targ.instanceField.v);\n+        \/\/ access FieldWatchpointsTarg.staticField and FieldWatchpointsTarg.staticField.v\n+        System.out.println(\"staticField value = \" + staticField.v);\n@@ -114,0 +119,1 @@\n+            Field instanceValueField = testClass.fieldByName(\"instanceField\");\n@@ -120,1 +126,1 @@\n-            testCases.add(new TestCase(\"modify\", 1, request)); \/\/ obj ctor\n+            testCases.add(new TestCase(\"modify\", 1, request)); \/\/ instanceField ctor\n@@ -123,1 +129,7 @@\n-            testCases.add(new TestCase(\"access\", 2, request)); \/\/ staticField, obj\n+            testCases.add(new TestCase(\"access\", 2, request)); \/\/ staticField, instanceField\n+\n+            request = eventRequestManager().createModificationWatchpointRequest(instanceValueField);\n+            testCases.add(new TestCase(\"modify flat\", 1, request)); \/\/ instanceField ctor\n+\n+            request = eventRequestManager().createAccessWatchpointRequest(instanceValueField);\n+            testCases.add(new TestCase(\"access flat\", 1, request)); \/\/ println(targ.instanceField.v)\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/FieldWatchpointsTest.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -145,8 +145,9 @@\n-        for (ArrayReference arr1: arrays) {\n-            for (ArrayReference arr2: arrays) {\n-                if (!arraysEquals(arr1, arr2)) {\n-                    System.out.println(\"Arrays are different (1):\"\n-                                     + \"\\n    - \" + arrayToString(arr1)\n-                                     + \"\\n    - \" + arrayToString(arr2));\n-                    throw new RuntimeException(\"Arrays are different\");\n-                }\n+        \/\/ Compare 1st and 2nd, 2nd and 3rd, etc.\n+        for (int i = 1; i < arrays.size(); i++) { \/\/ start from 1\n+            ArrayReference arr1 = arrays.get(i - 1);\n+            ArrayReference arr2 = arrays.get(i);\n+            if (!arraysEquals(arr1, arr2)) {\n+                System.out.println(\"Arrays are different (\" + (i - 1) + \" and \" + i + \"):\"\n+                                 + \"\\n    - \" + arrayToString(arr1)\n+                                 + \"\\n    - \" + arrayToString(arr2));\n+                throw new RuntimeException(\"Arrays are different\");\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/ValueArrayReferenceTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -101,2 +101,0 @@\n-            Field valueField = valueClass.fieldByName(\"staticField\");\n-            ObjectReference value2 = (ObjectReference)valueClass.getValue(valueField);\n@@ -107,1 +105,0 @@\n-            ObjectReference newValue2 = valueClass.newInstance(mainThread, valueCtor, List.of(vm().mirrorOf(11)), 0);\n@@ -110,1 +107,0 @@\n-            newValue2.disableCollection();\n@@ -113,1 +109,0 @@\n-            valueClass.setValue(valueField, newValue2);\n@@ -116,1 +111,0 @@\n-            ObjectReference updatedValue2 = (ObjectReference)valueClass.getValue(valueField);\n@@ -120,2 +114,0 @@\n-            assertEqual(updatedValue2, newValue2);\n-            assertNotEqual(value2, newValue2);\n@@ -125,1 +117,0 @@\n-            newValue2.enableCollection();\n","filename":"test\/jdk\/com\/sun\/jdi\/valhalla\/ValueClassTypeTest.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-  @bug 50510568367702\n+  @bug 5051056 8367702\n","filename":"test\/jdk\/java\/awt\/PrintJob\/GetGraphicsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8020443 6899304 4737732\n+ * @bug 8020443 6899304 4737732 8357390\n@@ -47,1 +47,1 @@\n-    private static final int MARGIN_TOLERANCE = 1;\n+    private static final int MARGIN_TOLERANCE = 2;\n","filename":"test\/jdk\/java\/awt\/Toolkit\/ScreenInsetsTest\/ScreenInsetsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+\n+\/**\n+ * @test\n+ * @bug 8369032\n+ * @summary Checks the size of the serialized ICC_Profile for standard and\n+ *          non-standard profiles.\n+ *\/\n+public final class SerializedFormSize {\n+\n+    private static final ICC_Profile[] PROFILES = {\n+            ICC_Profile.getInstance(ColorSpace.CS_sRGB),\n+            ICC_Profile.getInstance(ColorSpace.CS_LINEAR_RGB),\n+            ICC_Profile.getInstance(ColorSpace.CS_CIEXYZ),\n+            ICC_Profile.getInstance(ColorSpace.CS_PYCC),\n+            ICC_Profile.getInstance(ColorSpace.CS_GRAY)\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        for (ICC_Profile profile : PROFILES) {\n+            byte[] data = profile.getData();\n+            int dataSize = data.length;\n+            int min = 3; \/\/ At least version, name and data fields\n+            int max = 200; \/\/ Small enough to confirm no data saved\n+\n+            \/\/ Standard profile: should serialize to a small size, no data\n+            test(profile, min, max);\n+            \/\/ Non-standard profile: includes full data, but only once\n+            test(ICC_Profile.getInstance(data), dataSize, dataSize + max);\n+        }\n+    }\n+\n+    private static void test(ICC_Profile p, int min, int max) throws Exception {\n+        try (var bos = new ByteArrayOutputStream();\n+             var oos = new ObjectOutputStream(bos))\n+        {\n+            oos.writeObject(p);\n+            int size = bos.size();\n+            if (size < min || size > max) {\n+                System.err.println(\"Expected: >= \" + min + \" and <= \" + max);\n+                System.err.println(\"Actual: \" + size);\n+                throw new RuntimeException(\"Wrong size\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/SerializedFormSize.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365077\n+ * @summary confirm that an instance which is created with Enum ranges is\n+ * equal to another instance which is created with equivalent traditional\n+ * ranges, and that in such a case the hashCodes are also equal.\n+ *\/\n+\n+import java.awt.font.NumericShaper;\n+import java.awt.font.NumericShaper.Range;\n+import static java.awt.font.NumericShaper.Range.*;\n+import java.util.EnumSet;\n+\n+public class NSEqualsTest {\n+\n+    public static void main(String[] args) {\n+\n+        for (Range r1 : Range.values()) {\n+           test(r1);\n+           for (Range r2 : Range.values()) {\n+              test(r1, r2);\n+           }\n+        }\n+    }\n+\n+    static void test(Range r) {\n+        if (r.ordinal() > MONGOLIAN.ordinal()) {\n+            return;\n+        }\n+        int o = 1 << r.ordinal();\n+        NumericShaper nsr = NumericShaper.getContextualShaper(EnumSet.of(r));\n+        NumericShaper nso = NumericShaper.getContextualShaper(o);\n+        printAndCompare(nsr, nso);\n+    }\n+\n+    static void test(Range r1, Range r2) {\n+        if (r1.ordinal() > MONGOLIAN.ordinal() || r2.ordinal() > MONGOLIAN.ordinal()) {\n+            return;\n+        }\n+        int o1 = 1 << r1.ordinal();\n+        int o2 = 1 << r2.ordinal();\n+\n+        NumericShaper nsr = NumericShaper.getContextualShaper(EnumSet.of(r1, r2));\n+        NumericShaper nso = NumericShaper.getContextualShaper(o1 | o2);\n+        printAndCompare(nsr, nso);\n+    }\n+\n+    static void printAndCompare(NumericShaper nsr, NumericShaper nso) {\n+        System.err.println(nsr);\n+        System.err.println(nso);\n+        System.err.println(nsr.hashCode() + \" vs \" + nso.hashCode() +\n+                           \" equal: \" + nsr.equals(nso));\n+        if (!nsr.equals(nso)) {\n+            throw new RuntimeException(\"Expected equal\");\n+        }\n+        if (nsr.hashCode() != nso.hashCode()) {\n+            throw new RuntimeException(\"Different hash codes:\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/font\/NumericShaper\/NSEqualsTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -37,1 +38,0 @@\n-import java.lang.reflect.Constructor;\n@@ -40,1 +40,0 @@\n-import java.util.concurrent.ExecutorService;\n@@ -43,0 +42,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -45,0 +45,1 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -56,1 +57,1 @@\n-            Thread.Builder builder = virtualThreadBuilder(scheduler);\n+            Thread.Builder builder = VThreadScheduler.virtualThreadBuilder(scheduler);\n@@ -121,10 +122,0 @@\n-\n-    \/**\n-     * Returns a builder to create virtual threads that use the given scheduler.\n-     *\/\n-    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) throws Exception {\n-        Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-        Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-        ctor.setAccessible(true);\n-        return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n-    }\n","filename":"test\/jdk\/java\/io\/ByteArrayOutputStream\/WriteToReleasesCarrier.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Stuart Marks, Joseph D. Darcy\n","filename":"test\/jdk\/java\/io\/Serializable\/cloneArray\/CloneArray.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n- * @author madbot\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Byte\/Decode.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/IsAnnotationType.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/IsEnum.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/IsSynthetic.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingConstructor\/EnclosingConstructorTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingMethod\/EnclosingMethodTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/BitwiseConversion.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/Constants.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/Extrema.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/NaNInfinityParsing.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/ParseHexFloatingPoint.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/ToHexString.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/BitwiseConversion.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/Constants.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/Extrema.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/NaNInfinityParsing.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n- * @author madbot\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Integer\/Decode.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Integer\/ParsingTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Integer\/Unsigned.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n- * @author madbot\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Long\/Decode.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Long\/ParsingTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Long\/Unsigned.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n- * @author madbot\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Short\/Decode.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/test\/lib\n@@ -29,0 +28,2 @@\n+ * @requires test.thread.factory == null\n+ * @library \/test\/lib\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerFromMain.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackWalkTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/Thread\/MainThreadTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/Thread\/UncaughtExceptionsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author  Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Throwable\/SuppressedExceptions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/annotation\/Missing\/MissingTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author  Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/annotation\/TestIncompleteAnnotationExceptionNPE.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm ModulesInCustomFileSystem\n+ * @run testng\/othervm -Djava.io.tmpdir=. ModulesInCustomFileSystem\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/ModulesInCustomFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/ref\/OOMEInReferenceHandler.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/AnnotatedElement\/TestAnnotatedElementDefaults.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Constructor\/GenericStringTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Constructor\/TestParameterAnnotations.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/DefaultAccessibility.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/GenericStringTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/HashCodeTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/Probe.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/StringsAndBounds.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TestParameterizedType.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/exceptionCauseTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/getAnnotationTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/GenericStringTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/IsDefaultTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/defaultMethodModeling\/DefaultMethodModeling.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/TypeVariable\/TestAnnotatedElement.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/AddTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/CompareToTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DivideTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/IntegralDivisionTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/NegateTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/PowTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/PrecisionTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/RoundingTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ScaleByPowerOfTenTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/StrippingZerosTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ToPlainStringTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ZeroScalingTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/CompareToTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/ExtremeShiftingTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/OperatorNpeTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/StringConstructor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/TestValueExact.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/RoundingMode\/RoundingModeTests.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.H3_DISCOVERY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test id\n+ * @bug 8367976\n+ * @summary Verifies that setting the `jdk.httpclient.bufsize` system property\n+ *          to its lowest possible value, 1, does not wedge the client\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @run junit\/othervm -Djdk.httpclient.bufsize=1 BufferSize1Test\n+ *\/\n+\n+class BufferSize1Test implements HttpServerAdapters {\n+\n+    @BeforeAll\n+    static void verifyBufferSize() {\n+        assertEquals(1, Utils.BUFSIZE);\n+    }\n+\n+    static Object[][] testArgs() {\n+        return new Object[][]{\n+                {HTTP_1_1, false},\n+                {HTTP_1_1, true},\n+                {HTTP_2, false},\n+                {HTTP_2, true},\n+                {HTTP_3, true}\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testArgs\")\n+    void test(Version version, boolean secure) throws Exception {\n+\n+        \/\/ Create the server\n+        var sslContext = secure || HTTP_3.equals(version) ? new SimpleSSLContext().get() : null;\n+        try (var server = switch (version) {\n+            case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext);\n+            case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext);\n+        }) {\n+\n+            \/\/ Add the handler and start the server\n+            var serverHandlerPath = \"\/\" + BufferSize1Test.class.getSimpleName();\n+            server.addHandler(new HttpTestEchoHandler(), serverHandlerPath);\n+            server.start();\n+\n+            \/\/ Create the client\n+            try (var client = createClient(version, sslContext)) {\n+\n+                \/\/ Create the request with body to ensure that `ByteBuffer`s\n+                \/\/ will be used throughout the entire end-to-end interaction.\n+                byte[] requestBodyBytes = \"body\".repeat(1000).getBytes(StandardCharsets.US_ASCII);\n+                var request = createRequest(sslContext, server, serverHandlerPath, version, requestBodyBytes);\n+\n+                \/\/ Execute and verify the request.\n+                \/\/ Do it twice to cover code paths before and after a protocol upgrade.\n+                requestAndVerify(client, request, requestBodyBytes);\n+                requestAndVerify(client, request, requestBodyBytes);\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    private HttpClient createClient(Version version, SSLContext sslContext) {\n+        var clientBuilder = newClientBuilderForH3()\n+                .proxy(NO_PROXY)\n+                .version(version);\n+        if (sslContext != null) {\n+            clientBuilder.sslContext(sslContext);\n+        }\n+        return clientBuilder.build();\n+    }\n+\n+    private static HttpRequest createRequest(\n+            SSLContext sslContext,\n+            HttpTestServer server,\n+            String serverHandlerPath,\n+            Version version,\n+            byte[] requestBodyBytes) {\n+        var requestUri = URI.create(String.format(\n+                \"%s:\/\/%s%s\/x\",\n+                sslContext == null ? \"http\" : \"https\",\n+                server.serverAuthority(),\n+                serverHandlerPath));\n+        var requestBuilder = HttpRequest\n+                .newBuilder(requestUri)\n+                .version(version)\n+                .POST(HttpRequest.BodyPublishers.ofByteArray(requestBodyBytes));\n+        if (HTTP_3.equals(version)) {\n+            requestBuilder.setOption(H3_DISCOVERY, HTTP_3_URI_ONLY);\n+        }\n+        return requestBuilder.build();\n+    }\n+\n+    private static void requestAndVerify(HttpClient client, HttpRequest request, byte[] requestBodyBytes)\n+            throws IOException, InterruptedException {\n+        var response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());\n+        if (response.statusCode() != 200) {\n+            throw new AssertionError(\"Was expecting status code 200, found: \" + response.statusCode());\n+        }\n+        byte[] responseBodyBytes = response.body();\n+        int mismatchIndex = Arrays.mismatch(requestBodyBytes, responseBodyBytes);\n+        assertTrue(\n+                mismatchIndex < 0,\n+                String.format(\n+                        \"Response body (%s bytes) mismatches the request body (%s bytes) at index %s!\",\n+                        responseBodyBytes.length, requestBodyBytes.length, mismatchIndex));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSize1Test.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Handler;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8367976\n+ * @summary Verifies that the `jdk.httpclient.bufsize` system property is\n+ *          clamped correctly\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @comment `-Djdk.httpclient.HttpClient.log=errors` is needed to enable\n+ *          logging and verify that invalid input gets logged\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.HttpClient.log=errors\n+ *      -Djdk.httpclient.bufsize=-1\n+ *      BufferSizePropertyClampTest\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.HttpClient.log=errors\n+ *      -Djdk.httpclient.bufsize=0\n+ *      BufferSizePropertyClampTest\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.HttpClient.log=errors\n+ *      -Djdk.httpclient.bufsize=16385\n+ *      BufferSizePropertyClampTest\n+ *\/\n+\n+class BufferSizePropertyClampTest {\n+\n+    \/** Anchor to avoid the {@code Logger} instance get GC'ed *\/\n+    private static final Logger CLIENT_LOGGER =\n+            Logger.getLogger(\"jdk.httpclient.HttpClient\");\n+\n+    private static final List<String> CLIENT_LOGGER_MESSAGES =\n+            Collections.synchronizedList(new ArrayList<>());\n+\n+    @BeforeAll\n+    static void registerLoggerHandler() {\n+        CLIENT_LOGGER.addHandler(new Handler() {\n+\n+            @Override\n+            public void publish(LogRecord record) {\n+                var message = MessageFormat.format(record.getMessage(), record.getParameters());\n+                CLIENT_LOGGER_MESSAGES.add(message);\n+            }\n+\n+            @Override\n+            public void flush() {\n+                \/\/ Do nothing\n+            }\n+\n+            @Override\n+            public void close() {\n+                \/\/ Do nothing\n+            }\n+\n+        });\n+    }\n+\n+    @Test\n+    void test() {\n+        assertEquals(16384, Utils.BUFSIZE);\n+        assertEquals(\n+                1, CLIENT_LOGGER_MESSAGES.size(),\n+                \"Unexpected number of logger messages: \" + CLIENT_LOGGER_MESSAGES);\n+        var expectedMessage = \"ERROR: Property value for jdk.httpclient.bufsize=\" +\n+                System.getProperty(\"jdk.httpclient.bufsize\") +\n+                \" not in [1..16384]: using default=16384\";\n+        assertEquals(expectedMessage, CLIENT_LOGGER_MESSAGES.getFirst().replaceAll(\",\", \"\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSizePropertyClampTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * @bug 8283544\n+ * @bug 8283544 8358942\n@@ -34,0 +34,1 @@\n+ *          -Djdk.httpclient.allowRestrictedHeaders=content-length\n@@ -98,2 +99,2 @@\n-        testContentLengthServerH2.addHandler(new OptionalContentLengthHandler(), BODY_PATH);\n-        testContentLengthServerH3.addHandler(new OptionalContentLengthHandler(), BODY_PATH);\n+        testContentLengthServerH2.addHandler(new ContentLengthHandler(), BODY_PATH);\n+        testContentLengthServerH3.addHandler(new ContentLengthHandler(), BODY_PATH);\n@@ -166,0 +167,7 @@\n+    @DataProvider(name = \"h1body\")\n+    Object[][] h1body() {\n+        return new Object[][]{\n+                {HTTP_1_1, URI.create(testContentLengthURIH1 + BODY_PATH)}\n+        };\n+    }\n+\n@@ -189,0 +197,29 @@\n+    @Test(dataProvider = \"nobodies\")\n+    \/\/ A GET request with empty request body should have no Content-length header\n+    public void getWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking GET with no request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .method(\"GET\", HttpRequest.BodyPublishers.noBody())\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n+    @Test(dataProvider = \"bodies\")\n+    \/\/ A GET request with empty request body and explicitly added Content-length header\n+    public void getWithZeroContentLength(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking GET with no request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .method(\"GET\", HttpRequest.BodyPublishers.noBody())\n+                .header(\"Content-length\", \"0\")\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n@@ -218,0 +255,14 @@\n+    @Test(dataProvider = \"nobodies\")\n+    \/\/ A DELETE request with empty request body should have no Content-length header\n+    public void deleteWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking DELETE with no request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .method(\"DELETE\", HttpRequest.BodyPublishers.noBody())\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n@@ -247,0 +298,14 @@\n+    @Test(dataProvider = \"nobodies\")\n+    \/\/ A HEAD request with empty request body should have no Content-length header\n+    public void headWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking HEAD with no request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .method(\"HEAD\", HttpRequest.BodyPublishers.noBody())\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n@@ -264,0 +329,60 @@\n+    @Test(dataProvider = \"h1body\")\n+    \/\/ A POST request with empty request body should have a Content-length header\n+    \/\/ in HTTP\/1.1\n+    public void postWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking POST with request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .method(\"POST\", HttpRequest.BodyPublishers.noBody())\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n+    @Test(dataProvider = \"bodies\")\n+    \/\/ A POST request with a request body should have a Content-length header\n+    \/\/ in HTTP\/1.1\n+    public void postWithBody(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking POST with request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .POST(HttpRequest.BodyPublishers.ofString(\"POST Body\"))\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n+    @Test(dataProvider = \"h1body\")\n+    \/\/ A PUT request with empty request body should have a Content-length header\n+    \/\/ in HTTP\/1.1\n+    public void putWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking PUT with request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .method(\"PUT\", HttpRequest.BodyPublishers.noBody())\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n+    @Test(dataProvider = \"bodies\")\n+    \/\/ A PUT request with a request body should have a Content-length header\n+    \/\/ in HTTP\/1.1\n+    public void putWithBody(Version version, URI uri) throws IOException, InterruptedException {\n+        testLog.println(version + \" Checking PUT with request body\");\n+        HttpRequest req = HttpRequest.newBuilder()\n+                .version(version)\n+                .PUT(HttpRequest.BodyPublishers.ofString(\"PUT Body\"))\n+                .uri(uri)\n+                .build();\n+        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n+        assertEquals(resp.statusCode(), 200, resp.body());\n+        assertEquals(resp.version(), version);\n+    }\n+\n@@ -327,23 +452,0 @@\n-\n-    \/**\n-     * A handler used for cases where the presence of a Content-Length\n-     * header is optional. If present, its value must match the number of\n-     * bytes sent in the request body.\n-     *\/\n-    static class OptionalContentLengthHandler implements HttpTestHandler {\n-\n-        @Override\n-        public void handle(HttpTestExchange exchange) throws IOException {\n-            testLog.println(\"OptionalContentLengthHandler: Received Headers \"\n-                    + exchange.getRequestHeaders().entrySet() +\n-                    \" from \" + exchange.getRequestMethod() + \" request.\");\n-            Optional<String> contentLength = exchange.getRequestHeaders().firstValue(\"Content-Length\");\n-\n-            \/\/ Check Content-length header was set\n-            if (contentLength.isPresent()) {\n-                handleResponse(Long.parseLong(contentLength.get()), exchange, \"Request completed\", 200);\n-            } else {\n-                handleResponse(-1, exchange, \"Request completed, no content length\", 200);\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/java\/net\/httpclient\/ContentLengthHeaderTest.java","additions":128,"deletions":26,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n- * @run main\/othervm -Djdk.httpclient.bufsize=-1 OfByteArrayTest testInvalidBufferSize\n- * @run main\/othervm -Djdk.httpclient.bufsize=0 OfByteArrayTest testInvalidBufferSize\n@@ -91,1 +89,0 @@\n-            case \"testInvalidBufferSize\" -> testInvalidBufferSize();\n@@ -105,4 +102,0 @@\n-    private static void testInvalidBufferSize() {\n-        assertThrows(IllegalArgumentException.class, () -> HttpRequest.BodyPublishers.ofByteArray(new byte[1]));\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfByteArrayTest.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -30,0 +31,1 @@\n+import java.security.PEMDecoder;\n@@ -38,2 +40,0 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.CRL;\n@@ -43,1 +43,0 @@\n-import java.io.ByteArrayInputStream;\n@@ -48,0 +47,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -95,1 +96,1 @@\n-    private static X509Certificate getTrustedCertificate() throws Exception {\n+    private static X509Certificate getTrustedCertificate() {\n@@ -107,3 +108,1 @@\n-        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n-        return (X509Certificate)certFactory.generateCertificate(bytes);\n+        return pemDecoder.decode(sCert, X509Certificate.class);\n@@ -112,1 +111,1 @@\n-    private static X509Certificate getUserCertificate1() throws Exception {\n+    private static X509Certificate getUserCertificate1() {\n@@ -126,3 +125,1 @@\n-        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n-        return (X509Certificate)certFactory.generateCertificate(bytes);\n+        return pemDecoder.decode(sCert, X509Certificate.class);\n@@ -131,1 +128,1 @@\n-    private static X509Certificate getUserCertificate2() throws Exception {\n+    private static X509Certificate getUserCertificate2() {\n@@ -143,3 +140,1 @@\n-        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n-        return (X509Certificate)certFactory.generateCertificate(bytes);\n+        return pemDecoder.decode(sCert, X509Certificate.class);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/NoExtensions.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+ * @enablePreview\n@@ -39,1 +40,0 @@\n- * @author Xuelei Fan\n@@ -42,3 +42,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -46,2 +45,16 @@\n-import java.security.cert.*;\n-import java.security.cert.CertPathValidatorException.BasicReason;\n+import java.security.cert.CertPathBuilder;\n+import java.security.cert.CertStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CollectionCertStoreParameters;\n+import java.security.cert.PKIXBuilderParameters;\n+import java.security.cert.PKIXCertPathBuilderResult;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509CertSelector;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n@@ -186,4 +199,1 @@\n-    private static Set<TrustAnchor> generateTrustAnchors()\n-            throws CertificateException {\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -191,3 +201,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+    private static Set<TrustAnchor> generateTrustAnchors() {\n+        X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -197,1 +206,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -203,4 +212,0 @@\n-        Collection entries = new HashSet();\n-\n-        \/\/ generate certificate from certificate string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -208,1 +213,1 @@\n-        ByteArrayInputStream is;\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -210,2 +215,1 @@\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n+        DEREncodable cert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n@@ -214,2 +218,1 @@\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(subCaCertStr, X509Certificate.class);\n@@ -218,2 +221,1 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -222,2 +224,1 @@\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n@@ -226,2 +227,1 @@\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n@@ -231,3 +231,2 @@\n-        is = new ByteArrayInputStream(topCrlStr.getBytes());\n-        Collection mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -235,3 +234,2 @@\n-        is = new ByteArrayInputStream(subCrlStr.getBytes());\n-        mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -240,1 +238,1 @@\n-                            new CollectionCertStoreParameters(entries));\n+                new CollectionCertStoreParameters(entries));\n@@ -248,2 +246,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = null;\n+        String cert;\n@@ -251,1 +248,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            cert = subCaCertStr;\n@@ -253,1 +250,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            cert = subCrlIssuerCertStr;\n@@ -255,1 +252,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            cert = targetCertStr;\n@@ -258,1 +255,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = pemDecoder.decode(cert, X509Certificate.class);\n@@ -272,3 +269,1 @@\n-    private static boolean match(String name, Certificate cert)\n-                throws Exception {\n-        X509CertSelector selector = new X509CertSelector();\n+    private static boolean match(String name, Certificate cert) {\n@@ -277,2 +272,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = null;\n+        String newCert;\n@@ -280,1 +274,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            newCert = subCaCertStr;\n@@ -282,1 +276,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            newCert = subCrlIssuerCertStr;\n@@ -284,1 +278,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            newCert = targetCertStr;\n@@ -286,1 +280,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = pemDecoder.decode(newCert, X509Certificate.class);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/selfIssued\/StatusLoopDependency.java","additions":46,"deletions":52,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -39,3 +40,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -43,1 +43,3 @@\n-import java.security.cert.*;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n@@ -45,0 +47,16 @@\n+import java.security.cert.CertStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CollectionCertStoreParameters;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -152,0 +170,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -157,10 +177,3 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        Certificate subCaCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate targetCert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n+        Certificate subCaCert =  pemDecoder.decode(subCaCertStr, X509Certificate.class);\n+        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -169,2 +182,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, subCaCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n@@ -178,1 +190,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -180,3 +191,1 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        final X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -186,1 +195,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -192,1 +201,1 @@\n-        Collection entries = new HashSet();\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -195,1 +204,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -197,4 +205,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(topCrlStr.getBytes());\n-        Collection mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -202,3 +208,2 @@\n-        is = new ByteArrayInputStream(subCrlStr.getBytes());\n-        mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -207,3 +212,2 @@\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n@@ -211,3 +215,2 @@\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLTwoLevel.java","additions":40,"deletions":37,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -39,3 +40,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -43,1 +43,3 @@\n-import java.security.cert.*;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n@@ -45,0 +47,16 @@\n+import java.security.cert.CertStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CollectionCertStoreParameters;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -153,0 +171,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -158,10 +178,3 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        Certificate subCaCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate targetCert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n+        Certificate subCaCert = pemDecoder.decode(subCaCertStr, X509Certificate.class);\n+        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -170,2 +183,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, subCaCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n@@ -179,5 +191,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        final X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -187,1 +195,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -193,1 +201,1 @@\n-        Collection entries = new HashSet();\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -198,4 +206,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(topCrlStr.getBytes());\n-        Collection mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -203,3 +209,2 @@\n-        is = new ByteArrayInputStream(subCrlStr.getBytes());\n-        mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -208,3 +213,2 @@\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n@@ -212,3 +216,2 @@\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n@@ -217,1 +220,1 @@\n-                            new CollectionCertStoreParameters(entries));\n+                new CollectionCertStoreParameters(entries));\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLTwoLevelRevoked.java","additions":41,"deletions":38,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,2 @@\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertThrows;\n@@ -118,0 +120,38 @@\n+    @Test\n+    public void test_min() {\n+        assertEquals(Duration.MIN.getSeconds(), Long.MIN_VALUE);\n+        assertEquals(Duration.MIN.getNano(), 0);\n+        \/\/ no duration minimally less than MIN\n+        assertThrows(ArithmeticException.class, () -> Duration.MIN.minusNanos(1));\n+    }\n+\n+    @Test\n+    public void test_max() {\n+        assertEquals(Duration.MAX.getSeconds(), Long.MAX_VALUE);\n+        assertEquals(Duration.MAX.getNano(), 999_999_999);\n+        \/\/ no duration minimally greater than MAX\n+        assertThrows(ArithmeticException.class, () -> Duration.MAX.plusNanos(1));\n+    }\n+\n+    @Test\n+    public void test_constant_properties() {\n+        assertTrue(Duration.MIN.compareTo(Duration.MIN) == 0);\n+        assertEquals(Duration.MIN, Duration.MIN);\n+        assertTrue(Duration.ZERO.compareTo(Duration.ZERO) == 0);\n+        assertEquals(Duration.ZERO, Duration.ZERO);\n+        assertTrue(Duration.MAX.compareTo(Duration.MAX) == 0);\n+        assertEquals(Duration.MAX, Duration.MAX);\n+\n+        assertTrue(Duration.MIN.compareTo(Duration.ZERO) < 0);\n+        assertTrue(Duration.ZERO.compareTo(Duration.MIN) > 0);\n+        assertNotEquals(Duration.ZERO, Duration.MIN);\n+\n+        assertTrue(Duration.ZERO.compareTo(Duration.MAX) < 0);\n+        assertTrue(Duration.MAX.compareTo(Duration.ZERO) > 0);\n+        assertNotEquals(Duration.ZERO, Duration.MAX);\n+\n+        assertTrue(Duration.MIN.compareTo(Duration.MAX) < 0);\n+        assertTrue(Duration.MAX.compareTo(Duration.MIN) > 0);\n+        assertNotEquals(Duration.MIN, Duration.MAX);\n+    }\n+\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKDuration.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -35,2 +36,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n@@ -50,0 +49,5 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -52,1 +56,1 @@\n-\/**\n+\/*\n@@ -56,0 +60,1 @@\n+ *      8369590\n@@ -58,1 +63,0 @@\n- * @compile LocaleEnhanceTest.java\n@@ -63,7 +67,0 @@\n-    public LocaleEnhanceTest() {\n-    }\n-\n-    \/\/\/\n-    \/\/\/ Generic sanity tests\n-    \/\/\/\n-\n@@ -82,0 +79,4 @@\n+    \/\/\/\n+    \/\/\/ Generic sanity tests\n+    \/\/\/\n+\n@@ -127,6 +128,6 @@\n-                assertEquals(msg + \"language\", idl, l.getLanguage());\n-                assertEquals(msg + \"script\", ids, l.getScript());\n-                assertEquals(msg + \"country\", idc, l.getCountry());\n-                assertEquals(msg + \"variant\", idv, l.getVariant());\n-                assertEquals(msg + \"tag\", tag, l.toLanguageTag());\n-                assertEquals(msg + \"id\", id, l.toString());\n+                assertEquals(idl, l.getLanguage(), msg + \"language\");\n+                assertEquals(ids, l.getScript(), msg + \"script\");\n+                assertEquals(idc, l.getCountry(), msg + \"country\");\n+                assertEquals(idv, l.getVariant(), msg + \"variant\");\n+                assertEquals(tag, l.toLanguageTag(), msg + \"tag\");\n+                assertEquals(id, l.toString(), msg + \"id\");\n@@ -184,4 +185,4 @@\n-                assertEquals(msg + \" language\", idl, l.getLanguage());\n-                assertEquals(msg + \" script\", ids, l.getScript());\n-                assertEquals(msg + \" country\", idc, l.getCountry());\n-                assertEquals(msg + \" variant\", idv, l.getVariant());\n+                assertEquals(idl, l.getLanguage(), msg + \" language\");\n+                assertEquals(ids, l.getScript(), msg + \" script\");\n+                assertEquals(idc, l.getCountry(), msg + \" country\");\n+                assertEquals(idv, l.getVariant(), msg + \" variant\");\n@@ -189,2 +190,2 @@\n-                assertEquals(msg + \"tag\", tag, l.toLanguageTag());\n-                assertEquals(msg + \"id\", id, l.toString());\n+                assertEquals(tag, l.toLanguageTag(), msg + \"tag\");\n+                assertEquals(id, l.toString(), msg + \"id\");\n@@ -238,1 +239,1 @@\n-            assertEquals(id, \"und\", l.toLanguageTag());\n+            assertEquals(\"und\", l.toLanguageTag(), id);\n@@ -258,1 +259,1 @@\n-                assertEquals(\"tagResult\", target, tagResult);\n+                assertEquals(target, tagResult, \"tagResult\");\n@@ -265,1 +266,1 @@\n-                assertEquals(\"builderResult\", target, builderResult);\n+                assertEquals(target, builderResult, \"builderResult\");\n@@ -278,1 +279,1 @@\n-                \"UTF-8\"));\n+                    StandardCharsets.UTF_8));\n@@ -282,1 +283,1 @@\n-            assertEquals(\"ulocale\", id, result.toLanguageTag());\n+            assertEquals(id, result.toLanguageTag(), \"ulocale\");\n@@ -294,20 +295,20 @@\n-            \/\/ language to lower case, region to upper, variant unchanged\n-            \/\/ short\n-            { \"X\", \"y\", \"z\", \"x\", \"Y\" },\n-            \/\/ long\n-            { \"xXxXxXxXxXxX\", \"yYyYyYyYyYyYyYyY\", \"zZzZzZzZzZzZzZzZ\",\n-              \"xxxxxxxxxxxx\", \"YYYYYYYYYYYYYYYY\" },\n-            \/\/ mapped language ids\n-            { \"he\", \"IL\", \"\", \"he\" },\n-            { \"iw\", \"IL\", \"\", \"he\" },\n-            { \"yi\", \"DE\", \"\", \"yi\" },\n-            { \"ji\", \"DE\", \"\", \"yi\" },\n-            { \"id\", \"ID\", \"\", \"id\" },\n-            { \"in\", \"ID\", \"\", \"id\" },\n-            \/\/ special variants\n-            { \"ja\", \"JP\", \"JP\" },\n-            { \"th\", \"TH\", \"TH\" },\n-            { \"no\", \"NO\", \"NY\" },\n-            { \"no\", \"NO\", \"NY\" },\n-            \/\/ no canonicalization of 3-letter language codes\n-            { \"eng\", \"US\", \"\" }\n+                \/\/ language to lower case, region to upper, variant unchanged\n+                \/\/ short\n+                {\"X\", \"y\", \"z\", \"x\", \"Y\"},\n+                \/\/ long\n+                {\"xXxXxXxXxXxX\", \"yYyYyYyYyYyYyYyY\", \"zZzZzZzZzZzZzZzZ\",\n+                        \"xxxxxxxxxxxx\", \"YYYYYYYYYYYYYYYY\"},\n+                \/\/ mapped language ids\n+                {\"he\", \"IL\", \"\", \"he\"},\n+                {\"iw\", \"IL\", \"\", \"he\"},\n+                {\"yi\", \"DE\", \"\", \"yi\"},\n+                {\"ji\", \"DE\", \"\", \"yi\"},\n+                {\"id\", \"ID\", \"\", \"id\"},\n+                {\"in\", \"ID\", \"\", \"id\"},\n+                \/\/ special variants\n+                {\"ja\", \"JP\", \"JP\"},\n+                {\"th\", \"TH\", \"TH\"},\n+                {\"no\", \"NO\", \"NY\"},\n+                {\"no\", \"NO\", \"NY\"},\n+                \/\/ no canonicalization of 3-letter language codes\n+                {\"eng\", \"US\", \"\"}\n@@ -315,1 +316,1 @@\n-        for (int i = 0; i < tests.length; ++ i) {\n+        for (int i = 0; i < tests.length; ++i) {\n@@ -319,3 +320,3 @@\n-            assertEquals(id + \" lang\", test.length > 3 ? test[3] : test[0], locale.getLanguage());\n-            assertEquals(id + \" region\", test.length > 4 ? test[4] : test[1], locale.getCountry());\n-            assertEquals(id + \" variant\", test.length > 5 ? test[5] : test[2], locale.getVariant());\n+            assertEquals(test.length > 3 ? test[3] : test[0], locale.getLanguage(), id + \" lang\");\n+            assertEquals(test.length > 4 ? test[4] : test[1], locale.getCountry(), id + \" region\");\n+            assertEquals(test.length > 5 ? test[5] : test[2], locale.getVariant(), id + \" variant\");\n@@ -326,1 +327,1 @@\n-    \/\/\/ Locale API tests.\n+    \/\/\/ Locale API Tests\n@@ -333,1 +334,1 @@\n-        assertEquals(\"forLanguageTag\", \"Latn\", locale.getScript());\n+        assertEquals(\"Latn\", locale.getScript(), \"forLanguageTag\");\n@@ -337,1 +338,1 @@\n-        assertEquals(\"builder\", \"Latn\", locale.getScript());\n+        assertEquals(\"Latn\", locale.getScript(), \"builder\");\n@@ -341,1 +342,1 @@\n-        assertEquals(\"script is empty string\", \"\", locale.getScript());\n+        assertEquals(\"\", locale.getScript(), \"script is empty string\");\n@@ -348,1 +349,1 @@\n-        assertEquals(\"some_ex-tension\", null, locale.getExtension('a'));\n+        assertNull(locale.getExtension('a'), \"some_ex-tension\");\n@@ -352,1 +353,1 @@\n-        assertEquals(\"builder\", \"some-ex-tension\", locale.getExtension('a'));\n+        assertEquals(\"some-ex-tension\", locale.getExtension('a'), \"builder\");\n@@ -355,1 +356,1 @@\n-        assertEquals(\"empty b\", null, locale.getExtension('b'));\n+        assertNull(locale.getExtension('b'), \"empty b\");\n@@ -358,1 +359,1 @@\n-        new ExpectIAE() { public void call() { Locale.forLanguageTag(\"\").getExtension('\\uD800'); }};\n+        assertThrows(IllegalArgumentException.class, () -> Locale.forLanguageTag(\"\").getExtension('\\uD800'));\n@@ -362,1 +363,1 @@\n-        assertEquals(\"x\", \"y-z-blork\", locale.getExtension('x'));\n+        assertEquals(\"y-z-blork\", locale.getExtension('x'), \"x\");\n@@ -369,2 +370,2 @@\n-        assertEquals(\"result size\", 2, result.size());\n-        assertTrue(\"'a','b'\", result.contains('a') && result.contains('b'));\n+        assertEquals(2, result.size(), \"result size\");\n+        assertTrue(result.contains('a') && result.contains('b'), \"'a','b'\");\n@@ -373,7 +374,1 @@\n-        try {\n-            result.add('x');\n-            fail(\"expected exception on add to extension key set\");\n-        }\n-        catch (UnsupportedOperationException e) {\n-            \/\/ ok\n-        }\n+        assertThrows(UnsupportedOperationException.class, () -> result.add('x'));\n@@ -383,1 +378,1 @@\n-        assertTrue(\"empty result\", locale.getExtensionKeys().isEmpty());\n+        assertTrue(locale.getExtensionKeys().isEmpty(), \"empty result\");\n@@ -390,3 +385,3 @@\n-        assertEquals(\"number of attributes\", 2, attributes.size());\n-        assertTrue(\"attribute abc\", attributes.contains(\"abc\"));\n-        assertTrue(\"attribute def\", attributes.contains(\"def\"));\n+        assertEquals(2, attributes.size(), \"number of attributes\");\n+        assertTrue(attributes.contains(\"abc\"), \"attribute abc\");\n+        assertTrue(attributes.contains(\"def\"), \"attribute def\");\n@@ -396,1 +391,1 @@\n-        assertTrue(\"empty attributes\", attributes.isEmpty());\n+        assertTrue(attributes.isEmpty(), \"empty attributes\");\n@@ -402,2 +397,2 @@\n-        assertEquals(\"collation\", \"japanese\", locale.getUnicodeLocaleType(\"co\"));\n-        assertEquals(\"numbers\", \"thai\", locale.getUnicodeLocaleType(\"nu\"));\n+        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"co\"), \"collation\");\n+        assertEquals(\"thai\", locale.getUnicodeLocaleType(\"nu\"), \"numbers\");\n@@ -406,1 +401,1 @@\n-        assertEquals(\"key case\", \"japanese\", locale.getUnicodeLocaleType(\"Co\"));\n+        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"Co\"), \"key case\");\n@@ -409,1 +404,1 @@\n-        assertEquals(\"locale keyword not present\", null, locale.getUnicodeLocaleType(\"xx\"));\n+        assertNull(locale.getUnicodeLocaleType(\"xx\"), \"locale keyword not present\");\n@@ -413,1 +408,1 @@\n-        assertEquals(\"locale extension not present\", null, locale.getUnicodeLocaleType(\"co\"));\n+        assertNull(locale.getUnicodeLocaleType(\"co\"), \"locale extension not present\");\n@@ -417,1 +412,1 @@\n-        assertEquals(\"typeless keyword\", \"\", locale.getUnicodeLocaleType(\"kn\"));\n+        assertEquals(\"\", locale.getUnicodeLocaleType(\"kn\"), \"typeless keyword\");\n@@ -420,2 +415,2 @@\n-        new ExpectIAE() { public void call() { Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"q\"); }};\n-        new ExpectIAE() { public void call() { Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"abcdefghi\"); }};\n+        assertThrows(IllegalArgumentException.class, () -> Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"q\"));\n+        assertThrows(IllegalArgumentException.class, () -> Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"abcdefghi\"));\n@@ -424,1 +419,1 @@\n-        new ExpectNPE() { public void call() { Locale.forLanguageTag(\"\").getUnicodeLocaleType(null); }};\n+        assertThrows(NullPointerException.class, () -> Locale.forLanguageTag(\"\").getUnicodeLocaleType(null));\n@@ -431,2 +426,2 @@\n-        assertEquals(\"two keys\", 2, result.size());\n-        assertTrue(\"co and nu\", result.contains(\"co\") && result.contains(\"nu\"));\n+        assertEquals(2, result.size(), \"two keys\");\n+        assertTrue(result.contains(\"co\") && result.contains(\"nu\"), \"co and nu\");\n@@ -435,7 +430,1 @@\n-        try {\n-            result.add(\"frobozz\");\n-            fail(\"expected exception when add to locale key set\");\n-        }\n-        catch (UnsupportedOperationException e) {\n-            \/\/ ok\n-        }\n+        assertThrows(UnsupportedOperationException.class, () -> result.add(\"frobozz\"));\n@@ -447,1 +436,1 @@\n-        assertEquals(\"blork\", \"y-x-blork\", locale.getExtension(Locale.PRIVATE_USE_EXTENSION));\n+        assertEquals(\"y-x-blork\", locale.getExtension(Locale.PRIVATE_USE_EXTENSION), \"blork\");\n@@ -450,1 +439,1 @@\n-        assertEquals(\"no privateuse\", null, locale.getExtension(Locale.PRIVATE_USE_EXTENSION));\n+        assertNull(locale.getExtension(Locale.PRIVATE_USE_EXTENSION), \"no privateuse\");\n@@ -458,36 +447,36 @@\n-            \/\/ empty locale canonicalizes to 'und'\n-            { \"\", \"\", \"\", \"und\" },\n-            \/\/ variant alone is not a valid Locale, but has a valid language tag\n-            { \"\", \"\", \"NewYork\", \"und-NewYork\" },\n-            \/\/ standard valid locales\n-            { \"\", \"Us\", \"\", \"und-US\" },\n-            { \"\", \"US\", \"NewYork\", \"und-US-NewYork\" },\n-            { \"EN\", \"\", \"\", \"en\" },\n-            { \"EN\", \"\", \"NewYork\", \"en-NewYork\" },\n-            { \"EN\", \"US\", \"\", \"en-US\" },\n-            { \"EN\", \"US\", \"NewYork\", \"en-US-NewYork\" },\n-            \/\/ underscore in variant will be emitted as multiple variant subtags\n-            { \"en\", \"US\", \"Newer_Yorker\", \"en-US-Newer-Yorker\" },\n-            \/\/ invalid variant subtags are appended as private use\n-            { \"en\", \"US\", \"new_yorker\", \"en-US-x-lvariant-new-yorker\" },\n-            \/\/ the first invalid variant subtags and following variant subtags are appended as private use\n-            { \"en\", \"US\", \"Windows_XP_Home\", \"en-US-Windows-x-lvariant-XP-Home\" },\n-            \/\/ too long variant and following variant subtags disappear\n-            { \"en\", \"US\", \"WindowsVista_SP2\", \"en-US\" },\n-            \/\/ invalid region subtag disappears\n-            { \"en\", \"USA\", \"\", \"en\" },\n-            \/\/ invalid language tag disappears\n-            { \"e\", \"US\", \"\", \"und-US\" },\n-            \/\/ three-letter language tags are not canonicalized\n-            { \"Eng\", \"\", \"\", \"eng\" },\n-            \/\/ legacy languages canonicalize to modern equivalents\n-            { \"he\", \"IL\", \"\", \"he-IL\" },\n-            { \"iw\", \"IL\", \"\", \"he-IL\" },\n-            { \"yi\", \"DE\", \"\", \"yi-DE\" },\n-            { \"ji\", \"DE\", \"\", \"yi-DE\" },\n-            { \"id\", \"ID\", \"\", \"id-ID\" },\n-            { \"in\", \"ID\", \"\", \"id-ID\" },\n-            \/\/ special values are converted on output\n-            { \"ja\", \"JP\", \"JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\" },\n-            { \"th\", \"TH\", \"TH\", \"th-TH-u-nu-thai-x-lvariant-TH\" },\n-            { \"no\", \"NO\", \"NY\", \"nn-NO\" }\n+                \/\/ empty locale canonicalizes to 'und'\n+                {\"\", \"\", \"\", \"und\"},\n+                \/\/ variant alone is not a valid Locale, but has a valid language tag\n+                {\"\", \"\", \"NewYork\", \"und-NewYork\"},\n+                \/\/ standard valid locales\n+                {\"\", \"Us\", \"\", \"und-US\"},\n+                {\"\", \"US\", \"NewYork\", \"und-US-NewYork\"},\n+                {\"EN\", \"\", \"\", \"en\"},\n+                {\"EN\", \"\", \"NewYork\", \"en-NewYork\"},\n+                {\"EN\", \"US\", \"\", \"en-US\"},\n+                {\"EN\", \"US\", \"NewYork\", \"en-US-NewYork\"},\n+                \/\/ underscore in variant will be emitted as multiple variant subtags\n+                {\"en\", \"US\", \"Newer_Yorker\", \"en-US-Newer-Yorker\"},\n+                \/\/ invalid variant subtags are appended as private use\n+                {\"en\", \"US\", \"new_yorker\", \"en-US-x-lvariant-new-yorker\"},\n+                \/\/ the first invalid variant subtags and following variant subtags are appended as private use\n+                {\"en\", \"US\", \"Windows_XP_Home\", \"en-US-Windows-x-lvariant-XP-Home\"},\n+                \/\/ too long variant and following variant subtags disappear\n+                {\"en\", \"US\", \"WindowsVista_SP2\", \"en-US\"},\n+                \/\/ invalid region subtag disappears\n+                {\"en\", \"USA\", \"\", \"en\"},\n+                \/\/ invalid language tag disappears\n+                {\"e\", \"US\", \"\", \"und-US\"},\n+                \/\/ three-letter language tags are not canonicalized\n+                {\"Eng\", \"\", \"\", \"eng\"},\n+                \/\/ legacy languages canonicalize to modern equivalents\n+                {\"he\", \"IL\", \"\", \"he-IL\"},\n+                {\"iw\", \"IL\", \"\", \"he-IL\"},\n+                {\"yi\", \"DE\", \"\", \"yi-DE\"},\n+                {\"ji\", \"DE\", \"\", \"yi-DE\"},\n+                {\"id\", \"ID\", \"\", \"id-ID\"},\n+                {\"in\", \"ID\", \"\", \"id-ID\"},\n+                \/\/ special values are converted on output\n+                {\"ja\", \"JP\", \"JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\"},\n+                {\"th\", \"TH\", \"TH\", \"th-TH-u-nu-thai-x-lvariant-TH\"},\n+                {\"no\", \"NO\", \"NY\", \"nn-NO\"}\n@@ -498,1 +487,1 @@\n-            assertEquals(\"case \" + i, test[3], locale.toLanguageTag());\n+            assertEquals(test[3], locale.toLanguageTag(), \"case \" + i);\n@@ -503,8 +492,8 @@\n-            \/\/ case is normalized during the round trip\n-            { \"EN-us\", \"en-US\" },\n-            { \"en-Latn-US\", \"en-Latn-US\" },\n-            \/\/ reordering Unicode locale extensions\n-            { \"de-u-co-phonebk-ca-gregory\", \"de-u-ca-gregory-co-phonebk\" },\n-            \/\/ private use only language tag is preserved (no extra \"und\")\n-            { \"x-elmer\", \"x-elmer\" },\n-            { \"x-lvariant-JP\", \"x-lvariant-JP\" },\n+                \/\/ case is normalized during the round trip\n+                {\"EN-us\", \"en-US\"},\n+                {\"en-Latn-US\", \"en-Latn-US\"},\n+                \/\/ reordering Unicode locale extensions\n+                {\"de-u-co-phonebk-ca-gregory\", \"de-u-ca-gregory-co-phonebk\"},\n+                \/\/ private use only language tag is preserved (no extra \"und\")\n+                {\"x-elmer\", \"x-elmer\"},\n+                {\"x-lvariant-JP\", \"x-lvariant-JP\"},\n@@ -514,1 +503,1 @@\n-            assertEquals(\"case \" + test[0], test[1], locale.toLanguageTag());\n+            assertEquals(test[1], locale.toLanguageTag(), \"case \" + test[0]);\n@@ -527,35 +516,35 @@\n-            \/\/ private use tags only\n-            { \"x-abc\", \"x-abc\" },\n-            { \"x-a-b-c\", \"x-a-b-c\" },\n-            { \"x-a-12345678\", \"x-a-12345678\" },\n-\n-            \/\/ legacy language tags with preferred mappings\n-            { \"i-ami\", \"ami\" },\n-            { \"i-bnn\", \"bnn\" },\n-            { \"i-hak\", \"hak\" },\n-            { \"i-klingon\", \"tlh\" },\n-            { \"i-lux\", \"lb\" }, \/\/ two-letter tag\n-            { \"i-navajo\", \"nv\" }, \/\/ two-letter tag\n-            { \"i-pwn\", \"pwn\" },\n-            { \"i-tao\", \"tao\" },\n-            { \"i-tay\", \"tay\" },\n-            { \"i-tsu\", \"tsu\" },\n-            { \"art-lojban\", \"jbo\" },\n-            { \"no-bok\", \"nb\" },\n-            { \"no-nyn\", \"nn\" },\n-            { \"sgn-BE-FR\", \"sfb\" },\n-            { \"sgn-BE-NL\", \"vgt\" },\n-            { \"sgn-CH-DE\", \"sgg\" },\n-            { \"zh-guoyu\", \"cmn\" },\n-            { \"zh-hakka\", \"hak\" },\n-            { \"zh-min-nan\", \"nan\" },\n-            { \"zh-xiang\", \"hsn\" },\n-\n-            \/\/ irregular legacy language tags, no preferred mappings, drop illegal fields\n-            \/\/ from end.  If no subtag is mappable, fallback to 'und'\n-            { \"i-default\", \"en-x-i-default\" },\n-            { \"i-enochian\", \"x-i-enochian\" },\n-            { \"i-mingo\", \"see-x-i-mingo\" },\n-            { \"en-GB-oed\", \"en-GB-x-oed\" },\n-            { \"zh-min\", \"nan-x-zh-min\" },\n-            { \"cel-gaulish\", \"xtg-x-cel-gaulish\" },\n+                \/\/ private use tags only\n+                {\"x-abc\", \"x-abc\"},\n+                {\"x-a-b-c\", \"x-a-b-c\"},\n+                {\"x-a-12345678\", \"x-a-12345678\"},\n+\n+                \/\/ legacy language tags with preferred mappings\n+                {\"i-ami\", \"ami\"},\n+                {\"i-bnn\", \"bnn\"},\n+                {\"i-hak\", \"hak\"},\n+                {\"i-klingon\", \"tlh\"},\n+                {\"i-lux\", \"lb\"}, \/\/ two-letter tag\n+                {\"i-navajo\", \"nv\"}, \/\/ two-letter tag\n+                {\"i-pwn\", \"pwn\"},\n+                {\"i-tao\", \"tao\"},\n+                {\"i-tay\", \"tay\"},\n+                {\"i-tsu\", \"tsu\"},\n+                {\"art-lojban\", \"jbo\"},\n+                {\"no-bok\", \"nb\"},\n+                {\"no-nyn\", \"nn\"},\n+                {\"sgn-BE-FR\", \"sfb\"},\n+                {\"sgn-BE-NL\", \"vgt\"},\n+                {\"sgn-CH-DE\", \"sgg\"},\n+                {\"zh-guoyu\", \"cmn\"},\n+                {\"zh-hakka\", \"hak\"},\n+                {\"zh-min-nan\", \"nan\"},\n+                {\"zh-xiang\", \"hsn\"},\n+\n+                \/\/ irregular legacy language tags, no preferred mappings, drop illegal fields\n+                \/\/ from end.  If no subtag is mappable, fallback to 'und'\n+                {\"i-default\", \"en-x-i-default\"},\n+                {\"i-enochian\", \"x-i-enochian\"},\n+                {\"i-mingo\", \"see-x-i-mingo\"},\n+                {\"en-GB-oed\", \"en-GB-x-oed\"},\n+                {\"zh-min\", \"nan-x-zh-min\"},\n+                {\"cel-gaulish\", \"xtg-x-cel-gaulish\"},\n@@ -566,1 +555,1 @@\n-            assertEquals(\"legacy language tag case \" + i, test[1], locale.toLanguageTag());\n+            assertEquals(test[1], locale.toLanguageTag(), \"legacy language tag case \" + i);\n@@ -571,27 +560,27 @@\n-        tests = new String[][] {\n-            { \"valid\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\" },\n-            { \"segment of private use tag too long\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-123456789-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\" },\n-            { \"segment of private use tag is empty\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y--12345678-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\" },\n-            { \"first segment of private use tag is empty\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x--y-12345678-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\" },\n-            { \"illegal extension tag\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-\\uD800-y-12345678-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\" },\n-            { \"locale subtag with no value\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\" },\n-            { \"locale key subtag invalid\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-123456789-def-x-y-12345678-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc\" },\n-            \/\/ locale key subtag invalid in earlier position, all following subtags\n-            \/\/ dropped (and so the locale extension dropped as well)\n-            { \"locale key subtag invalid in earlier position\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd-u-123456789-abc-bb-def-x-y-12345678-z\",\n-              \"en-US-Newer-Yorker-a-bb-cc-dd\" },\n+        tests = new String[][]{\n+                {\"valid\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\"},\n+                {\"segment of private use tag too long\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-123456789-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\"},\n+                {\"segment of private use tag is empty\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y--12345678-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\"},\n+                {\"first segment of private use tag is empty\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x--y-12345678-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\"},\n+                {\"illegal extension tag\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-\\uD800-y-12345678-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\"},\n+                {\"locale subtag with no value\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\"},\n+                {\"locale key subtag invalid\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-123456789-def-x-y-12345678-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc\"},\n+                \/\/ locale key subtag invalid in earlier position, all following subtags\n+                \/\/ dropped (and so the locale extension dropped as well)\n+                {\"locale key subtag invalid in earlier position\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-123456789-abc-bb-def-x-y-12345678-z\",\n+                        \"en-US-Newer-Yorker-a-bb-cc-dd\"},\n@@ -604,3 +593,2 @@\n-                assertEquals(msg, test[2], locale.toLanguageTag());\n-            }\n-            catch (IllegalArgumentException e) {\n+                assertEquals(test[2], locale.toLanguageTag(), msg);\n+            } catch (IllegalArgumentException e) {\n@@ -613,2 +601,2 @@\n-        assertEquals(\"extension\", \"aa-00-bb-01\", locale.getExtension('d'));\n-        assertEquals(\"extension c\", \"1234\", locale.getExtension('c'));\n+        assertEquals(\"aa-00-bb-01\", locale.getExtension('d'), \"extension\");\n+        assertEquals(\"1234\", locale.getExtension('c'), \"extension c\");\n@@ -617,1 +605,1 @@\n-        assertEquals(\"Unicode extension\", \"ca-gregory\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION));\n+        assertEquals(\"ca-gregory\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION), \"Unicode extension\");\n@@ -621,2 +609,2 @@\n-        assertEquals(\"Unicode keywords\", \"aa-000-bb-001-cc-003\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION));\n-        assertEquals(\"Duplicated Unicode locake key followed by an extension\", \"1234\", locale.getExtension('c'));\n+        assertEquals(\"aa-000-bb-001-cc-003\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION), \"Unicode keywords\");\n+        assertEquals(\"1234\", locale.getExtension('c'), \"Duplicated Unicode locake key followed by an extension\");\n@@ -633,2 +621,2 @@\n-        assertEquals(\"latn US\", \"Latin\", latnLocale.getDisplayScript());\n-        assertEquals(\"hans US\", \"Simplified\", hansLocale.getDisplayScript());\n+        assertEquals(\"Latin\", latnLocale.getDisplayScript(), \"latn US\");\n+        assertEquals(\"Simplified\", hansLocale.getDisplayScript(), \"hans US\");\n@@ -637,2 +625,2 @@\n-        assertEquals(\"latn DE\", \"Lateinisch\", latnLocale.getDisplayScript());\n-        assertEquals(\"hans DE\", \"Vereinfacht\", hansLocale.getDisplayScript());\n+        assertEquals(\"Lateinisch\", latnLocale.getDisplayScript(), \"latn DE\");\n+        assertEquals(\"Vereinfacht\", hansLocale.getDisplayScript(), \"hans DE\");\n@@ -648,2 +636,2 @@\n-        assertEquals(\"latn US\", \"Latin\", latnLocale.getDisplayScript(Locale.US));\n-        assertEquals(\"hans US\", \"Simplified\", hansLocale.getDisplayScript(Locale.US));\n+        assertEquals(\"Latin\", latnLocale.getDisplayScript(Locale.US), \"latn US\");\n+        assertEquals(\"Simplified\", hansLocale.getDisplayScript(Locale.US), \"hans US\");\n@@ -651,2 +639,2 @@\n-        assertEquals(\"latn DE\", \"Lateinisch\", latnLocale.getDisplayScript(Locale.GERMANY));\n-        assertEquals(\"hans DE\", \"Vereinfacht\", hansLocale.getDisplayScript(Locale.GERMANY));\n+        assertEquals(\"Lateinisch\", latnLocale.getDisplayScript(Locale.GERMANY), \"latn DE\");\n+        assertEquals(\"Vereinfacht\", hansLocale.getDisplayScript(Locale.GERMANY), \"hans DE\");\n@@ -698,4 +686,4 @@\n-            assertEquals(\"English display name for \" + loc.toLanguageTag(),\n-                    displayNameEnglish[i], loc.getDisplayName(Locale.ENGLISH));\n-            assertEquals(\"Simplified Chinese display name for \" + loc.toLanguageTag(),\n-                    displayNameSimplifiedChinese[i], loc.getDisplayName(Locale.CHINA));\n+            assertEquals(displayNameEnglish[i], loc.getDisplayName(Locale.ENGLISH),\n+                    \"English display name for \" + loc.toLanguageTag());\n+            assertEquals(displayNameSimplifiedChinese[i], loc.getDisplayName(Locale.CHINA),\n+                    \"Simplified Chinese display name for \" + loc.toLanguageTag());\n@@ -719,4 +707,4 @@\n-            .setLocale(locale)\n-            .build();\n-        assertEquals(\"long tag\", target, result.toLanguageTag());\n-        assertEquals(\"long tag\", locale, result);\n+                .setLocale(locale)\n+                .build();\n+        assertEquals(target, result.toLanguageTag(), \"long tag\");\n+        assertEquals(locale, result, \"long tag\");\n@@ -725,3 +713,2 @@\n-        new BuilderNPE(\"locale\") {\n-            public void call() { b.setLocale(null); }\n-        };\n+        assertThrows(NullPointerException.class, () -> builder.setLocale(null),\n+                \"Setting null locale should throw NPE\");\n@@ -732,2 +719,2 @@\n-        assertEquals(\"ja_JP_JP languagetag\", \"ja-JP-u-ca-japanese\", locale.toLanguageTag());\n-        assertEquals(\"ja_JP_JP variant\", \"\", locale.getVariant());\n+        assertEquals(\"ja-JP-u-ca-japanese\", locale.toLanguageTag(), \"ja_JP_JP languagetag\");\n+        assertEquals(\"\", locale.getVariant(), \"ja_JP_JP variant\");\n@@ -736,2 +723,2 @@\n-        assertEquals(\"th_TH_TH languagetag\", \"th-TH-u-nu-thai\", locale.toLanguageTag());\n-        assertEquals(\"th_TH_TH variant\", \"\", locale.getVariant());\n+        assertEquals(\"th-TH-u-nu-thai\", locale.toLanguageTag(), \"th_TH_TH languagetag\");\n+        assertEquals(\"\", locale.getVariant(), \"th_TH_TH variant\");\n@@ -740,3 +727,3 @@\n-        assertEquals(\"no_NO_NY languagetag\", \"nn-NO\", locale.toLanguageTag());\n-        assertEquals(\"no_NO_NY language\", \"nn\", locale.getLanguage());\n-        assertEquals(\"no_NO_NY variant\", \"\", locale.getVariant());\n+        assertEquals(\"nn-NO\", locale.toLanguageTag(), \"no_NO_NY languagetag\");\n+        assertEquals(\"nn\", locale.getLanguage(), \"no_NO_NY language\");\n+        assertEquals(\"\", locale.getVariant(), \"no_NO_NY variant\");\n@@ -745,5 +732,2 @@\n-        new BuilderILE(\"123_4567_89\") {\n-            public void call() {\n-                b.setLocale(Locale.of(\"123\", \"4567\", \"89\"));\n-            }\n-        };\n+        assertThrows(IllformedLocaleException.class,\n+                () -> new Builder().setLocale(Locale.of(\"123\", \"4567\", \"89\")), \"123_4567_89\");\n@@ -758,10 +742,14 @@\n-            .setLanguageTag(source)\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"language\", target, result);\n-\n-        \/\/ redundant extensions cause a failure\n-        new BuilderILE() { public void call() { b.setLanguageTag(\"und-a-xx-yy-b-ww-A-00-11-c-vv\"); }};\n-\n-        \/\/ redundant Unicode locale extension keys within an Unicode locale extension cause a failure\n-        new BuilderILE() { public void call() { b.setLanguageTag(\"und-u-nu-thai-NU-chinese-xx-1234\"); }};\n+                .setLanguageTag(source)\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(target, result, \"language\");\n+\n+        \/\/ redundant extensions are ignored\n+        assertEquals(\"und-a-xx-yy-b-ww-c-vv\",\n+                new Builder().setLanguageTag(\"und-a-xx-yy-b-ww-A-00-11-c-vv\").build().toLanguageTag());\n+        \/\/ redundant Unicode locale extension keys are ignored\n+        assertEquals(\"und-u-cu-usd-nu-thai-xx-1234\",\n+                new Builder().setLanguageTag(\"und-u-nu-thai-cu-usd-NU-chinese-xx-1234\").build().toLanguageTag());\n+        \/\/ redundant Unicode locale extension attributes are ignored\n+        assertEquals(\"und-u-bar-foo\",\n+                new Builder().setLanguageTag(\"und-u-foo-bar-FOO\").build().toLanguageTag());\n@@ -779,3 +767,3 @@\n-        assertEquals(\"Setting a %s language tag did not clear the builder\"\n-                .formatted(tag == null ? \"null\" : \"empty\"),\n-                empty.build(), bldr.build());\n+        assertEquals(empty.build(), bldr.build(),\n+                \"Setting a %s language tag did not clear the builder\"\n+                .formatted(tag == null ? \"null\" : \"empty\"));\n@@ -792,4 +780,4 @@\n-            .setLanguage(source)\n-            .build()\n-            .getLanguage();\n-        assertEquals(\"en\", target, result);\n+                .setLanguage(source)\n+                .build()\n+                .getLanguage();\n+        assertEquals(target, result, \"en\");\n@@ -799,5 +787,5 @@\n-            .setLanguage(target)\n-            .setLanguage(\"\")\n-            .build()\n-            .getLanguage();\n-        assertEquals(\"empty\", defaulted, result);\n+                .setLanguage(target)\n+                .setLanguage(\"\")\n+                .build()\n+                .getLanguage();\n+        assertEquals(defaulted, result, \"empty\");\n@@ -811,1 +799,1 @@\n-        assertEquals(\"null\", defaulted, result);\n+        assertEquals(defaulted, result, \"null\");\n@@ -816,1 +804,3 @@\n-        new BuilderILE(\"q\", \"abcdefghi\", \"13\") { public void call() { b.setLanguage(arg); }};\n+        for (String arg : List.of(\"q\", \"abcdefghi\", \"13\")) {\n+            assertThrows(IllformedLocaleException.class, () -> new Builder().setLanguage(arg));\n+        }\n@@ -819,2 +809,2 @@\n-        assertNotNull(\"2alpha\", builder.setLanguage(\"zz\").build());\n-        assertNotNull(\"8alpha\", builder.setLanguage(\"abcdefgh\").build());\n+        assertNotNull(builder.setLanguage(\"zz\").build(), \"2alpha\");\n+        assertNotNull(builder.setLanguage(\"abcdefgh\").build(), \"8alpha\");\n@@ -824,4 +814,4 @@\n-            .setLanguage(\"eng\")\n-            .build()\n-            .getLanguage();\n-        assertEquals(\"eng\", \"eng\", result);\n+                .setLanguage(\"eng\")\n+                .build()\n+                .getLanguage();\n+        assertEquals(\"eng\", result, \"eng\");\n@@ -838,4 +828,4 @@\n-            .setScript(source)\n-            .build()\n-            .getScript();\n-        assertEquals(\"script\", target, result);\n+                .setScript(source)\n+                .build()\n+                .getScript();\n+        assertEquals(target, result, \"script\");\n@@ -845,5 +835,5 @@\n-            .setScript(target)\n-            .setScript(\"\")\n-            .build()\n-            .getScript();\n-        assertEquals(\"empty\", defaulted, result);\n+                .setScript(target)\n+                .setScript(\"\")\n+                .build()\n+                .getScript();\n+        assertEquals(defaulted, result, \"empty\");\n@@ -857,1 +847,1 @@\n-        assertEquals(\"null\", defaulted, result);\n+        assertEquals(defaulted, result, \"null\");\n@@ -861,1 +851,4 @@\n-        new BuilderILE(\"abc\", \"abcde\", \"l3tn\") { public void call() { b.setScript(arg); }};\n+        for (String arg : List.of(\"abc\", \"abcde\", \"l3tn\")) {\n+            assertThrows(IllformedLocaleException.class, () -> new Builder().setScript(arg));\n+        }\n+\n@@ -864,1 +857,1 @@\n-        assertEquals(\"4alpha\", \"Wxyz\", builder.setScript(\"wxyz\").build().getScript());\n+        assertEquals(\"Wxyz\", builder.setScript(\"wxyz\").build().getScript(), \"4alpha\");\n@@ -875,4 +868,4 @@\n-            .setRegion(source)\n-            .build()\n-            .getCountry();\n-        assertEquals(\"us\", target, result);\n+                .setRegion(source)\n+                .build()\n+                .getCountry();\n+        assertEquals(target, result, \"us\");\n@@ -882,5 +875,5 @@\n-            .setRegion(target)\n-            .setRegion(\"\")\n-            .build()\n-            .getCountry();\n-        assertEquals(\"empty\", defaulted, result);\n+                .setRegion(target)\n+                .setRegion(\"\")\n+                .build()\n+                .getCountry();\n+        assertEquals(defaulted, result, \"empty\");\n@@ -894,1 +887,1 @@\n-        assertEquals(\"null\", defaulted, result);\n+        assertEquals(defaulted, result, \"null\");\n@@ -898,1 +891,3 @@\n-        new BuilderILE(\"q\", \"abc\", \"12\", \"1234\", \"a3\", \"12a\") { public void call() { b.setRegion(arg); }};\n+        for (String arg : List.of(\"q\", \"abc\", \"12\", \"1234\", \"a3\", \"12a\")) {\n+            assertThrows(IllformedLocaleException.class, () -> new Builder().setRegion(arg));\n+        }\n@@ -901,2 +896,2 @@\n-        assertEquals(\"2alpha\", \"ZZ\", builder.setRegion(\"ZZ\").build().getCountry());\n-        assertEquals(\"3digit\", \"000\", builder.setRegion(\"000\").build().getCountry());\n+        assertEquals(\"ZZ\", builder.setRegion(\"ZZ\").build().getCountry(), \"2alpha\");\n+        assertEquals(\"000\", builder.setRegion(\"000\").build().getCountry(), \"3digit\");\n@@ -913,4 +908,4 @@\n-            .setVariant(source)\n-            .build()\n-            .getVariant();\n-        assertEquals(\"NewYork\", target, result);\n+                .setVariant(source)\n+                .build()\n+                .getVariant();\n+        assertEquals(target, result, \"NewYork\");\n@@ -919,4 +914,4 @@\n-            .setVariant(\"NeWeR_YoRkEr\")\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"newer yorker\", \"und-NeWeR-YoRkEr\", result);\n+                .setVariant(\"NeWeR_YoRkEr\")\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und-NeWeR-YoRkEr\", result, \"newer yorker\");\n@@ -926,4 +921,4 @@\n-            .setVariant(\"zzzzz_yyyyy_xxxxx\")\n-            .build()\n-            .getVariant();\n-        assertEquals(\"zyx\", \"zzzzz_yyyyy_xxxxx\", result);\n+                .setVariant(\"zzzzz_yyyyy_xxxxx\")\n+                .build()\n+                .getVariant();\n+        assertEquals(\"zzzzz_yyyyy_xxxxx\", result, \"zyx\");\n@@ -933,5 +928,5 @@\n-            .setVariant(target)\n-            .setVariant(\"\")\n-            .build()\n-            .getVariant();\n-        assertEquals(\"empty\", defaulted, result);\n+                .setVariant(target)\n+                .setVariant(\"\")\n+                .build()\n+                .getVariant();\n+        assertEquals(defaulted, result, \"empty\");\n@@ -945,1 +940,1 @@\n-        assertEquals(\"null\", defaulted, result);\n+        assertEquals(defaulted, result, \"null\");\n@@ -949,1 +944,4 @@\n-        new BuilderILE(\"abcd\", \"abcdefghi\", \"1ab\", \"1abcdefgh\") { public void call() { b.setVariant(arg); }};\n+        for (String arg : List.of(\"abcd\", \"abcdefghi\", \"1ab\", \"1abcdefgh\")) {\n+            assertThrows(IllformedLocaleException.class, () -> new Builder().setVariant(arg));\n+        }\n+\n@@ -952,1 +950,1 @@\n-        assertEquals(\"digit+3alpha\", \"1abc\", builder.setVariant(\"1abc\").build().getVariant());\n+        assertEquals(\"1abc\", builder.setVariant(\"1abc\").build().getVariant(), \"digit+3alpha\");\n@@ -955,1 +953,2 @@\n-        new BuilderILE(\"abcde-fg\") { public void call() { b.setVariant(arg); }};\n+        assertThrows(IllformedLocaleException.class, () -> new Builder().setVariant(\"abcde-fg\"));\n+\n@@ -966,4 +965,4 @@\n-            .setExtension(sourceKey, sourceValue)\n-            .build()\n-            .getExtension(sourceKey);\n-        assertEquals(\"extension\", target, result);\n+                .setExtension(sourceKey, sourceValue)\n+                .build()\n+                .getExtension(sourceKey);\n+        assertEquals(target, result, \"extension\");\n@@ -973,5 +972,5 @@\n-            .setExtension(sourceKey, sourceValue)\n-            .setExtension(sourceKey, \"\")\n-            .build()\n-            .getExtension(sourceKey);\n-        assertEquals(\"empty\", null, result);\n+                .setExtension(sourceKey, sourceValue)\n+                .setExtension(sourceKey, \"\")\n+                .build()\n+                .getExtension(sourceKey);\n+        assertNull(result, \"empty\");\n@@ -985,1 +984,1 @@\n-        assertEquals(\"null\", null, result);\n+        assertNull(result, \"null\");\n@@ -989,1 +988,3 @@\n-        new BuilderILE(\"$\") { public void call() { b.setExtension('$', sourceValue); }};\n+        assertThrows(IllformedLocaleException.class,\n+                () -> new Builder().setExtension('$', sourceValue));\n+\n@@ -992,1 +993,3 @@\n-        new BuilderILE(\"ab-cd-123456789\") { public void call() { b.setExtension(sourceKey, arg); }};\n+        assertThrows(IllformedLocaleException.class,\n+                () -> new Builder().setExtension(sourceKey, \"ab-cd-123456789\"));\n+\n@@ -995,1 +998,3 @@\n-        new BuilderILE(\"ab--cd\") { public void call() { b.setExtension(sourceKey, arg); }};\n+        assertThrows(IllformedLocaleException.class,\n+                () -> new Builder().setExtension(sourceKey, \"ab--cd\"));\n+\n@@ -999,3 +1004,3 @@\n-            .setExtension('u', \"co-japanese\")\n-            .build();\n-        assertEquals(\"locale extension\", \"japanese\", locale.getUnicodeLocaleType(\"co\"));\n+                .setExtension('u', \"co-japanese\")\n+                .build();\n+        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"co\"), \"locale extension\");\n@@ -1005,3 +1010,3 @@\n-            .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n-            .build();\n-        assertEquals(\"locales with extension\", locale, locale2);\n+                .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n+                .build();\n+        assertEquals(locale, locale2, \"locales with extension\");\n@@ -1011,5 +1016,5 @@\n-            .setExtension('u', \"xxx-nu-thai\")\n-            .build();\n-        assertEquals(\"remove co\", null, locale3.getUnicodeLocaleType(\"co\"));\n-        assertEquals(\"override thai\", \"thai\", locale3.getUnicodeLocaleType(\"nu\"));\n-        assertEquals(\"override attribute\", 1, locale3.getUnicodeLocaleAttributes().size());\n+                .setExtension('u', \"xxx-nu-thai\")\n+                .build();\n+        assertNull(locale3.getUnicodeLocaleType(\"co\"), \"remove co\");\n+        assertEquals(\"thai\", locale3.getUnicodeLocaleType(\"nu\"), \"override thai\");\n+        assertEquals(1, locale3.getUnicodeLocaleAttributes().size(), \"override attribute\");\n@@ -1019,4 +1024,4 @@\n-            .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n-            .build();\n-        assertEquals(\"extend\", \"japanese\", locale4.getUnicodeLocaleType(\"co\"));\n-        assertEquals(\"extend\", \"thai\", locale4.getUnicodeLocaleType(\"nu\"));\n+                .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n+                .build();\n+        assertEquals(\"japanese\", locale4.getUnicodeLocaleType(\"co\"), \"extend\");\n+        assertEquals(\"thai\", locale4.getUnicodeLocaleType(\"nu\"), \"extend\");\n@@ -1026,5 +1031,5 @@\n-            .clear()\n-            .setExtension('u', \"456-123-zz-123-yy-456-xx-789\")\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"reorder\", \"und-u-123-456-xx-789-yy-456-zz-123\", result);\n+                .clear()\n+                .setExtension('u', \"456-123-zz-123-yy-456-xx-789\")\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und-u-123-456-xx-789-yy-456-zz-123\", result, \"reorder\");\n@@ -1034,5 +1039,5 @@\n-            .clear()\n-            .setExtension('u', \"nu-thai-foobar\")\n-            .build()\n-            .getUnicodeLocaleType(\"nu\");\n-        assertEquals(\"multiple types\", \"thai-foobar\", result);\n+                .clear()\n+                .setExtension('u', \"nu-thai-foobar\")\n+                .build()\n+                .getUnicodeLocaleType(\"nu\");\n+        assertEquals(\"thai-foobar\", result, \"multiple types\");\n@@ -1042,5 +1047,13 @@\n-            .clear()\n-            .setExtension('u', \"nu-thai-NU-chinese-xx-1234\")\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"duplicate keys\", \"und-u-nu-thai-xx-1234\", result);\n+                .clear()\n+                .setExtension('u', \"nu-thai-NU-chinese-xx-1234\")\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und-u-nu-thai-xx-1234\", result, \"duplicate keys\");\n+\n+        \/\/ redundant locale attributes are ignored\n+        result = builder\n+                .clear()\n+                .setExtension('u', \"posix-posix\")\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und-u-posix\", result, \"duplicate attributes\");\n@@ -1053,3 +1066,3 @@\n-            .addUnicodeLocaleAttribute(\"def\")\n-            .addUnicodeLocaleAttribute(\"abc\")\n-            .build();\n+                .addUnicodeLocaleAttribute(\"def\")\n+                .addUnicodeLocaleAttribute(\"abc\")\n+                .build();\n@@ -1058,3 +1071,3 @@\n-        assertEquals(\"number of attributes\", 2, uattrs.size());\n-        assertTrue(\"attribute abc\", uattrs.contains(\"abc\"));\n-        assertTrue(\"attribute def\", uattrs.contains(\"def\"));\n+        assertEquals(2, uattrs.size(), \"number of attributes\");\n+        assertTrue(uattrs.contains(\"abc\"), \"attribute abc\");\n+        assertTrue(uattrs.contains(\"def\"), \"attribute def\");\n@@ -1064,1 +1077,1 @@\n-            .build();\n+                .build();\n@@ -1066,1 +1079,2 @@\n-        assertEquals(\"remove bogus\", 2, uattrs.size());\n+        uattrs = locale.getUnicodeLocaleAttributes();\n+        assertEquals(2, uattrs.size(), \"remove bogus\");\n@@ -1070,2 +1084,3 @@\n-            .build();\n-        assertEquals(\"add duplicate\", 2, uattrs.size());\n+                .build();\n+        uattrs = locale.getUnicodeLocaleAttributes();\n+        assertEquals(2, uattrs.size(), \"add duplicate\");\n@@ -1074,2 +1089,5 @@\n-        new BuilderNPE(\"null attribute\") { public void call() { b.addUnicodeLocaleAttribute(null); }};\n-        new BuilderNPE(\"null attribute removal\") { public void call() { b.removeUnicodeLocaleAttribute(null); }};\n+        assertThrows(NullPointerException.class,\n+                () ->  new Builder().addUnicodeLocaleAttribute(null), \"null attribute\");\n+\n+        assertThrows(NullPointerException.class,\n+                () -> new Builder().removeUnicodeLocaleAttribute(null), \"null attribute removal\");\n@@ -1078,1 +1096,2 @@\n-        new BuilderILE(\"invalid attribute\") { public void call() { b.addUnicodeLocaleAttribute(\"ca\"); }};\n+        assertThrows(IllformedLocaleException.class,\n+                     () -> new Builder().addUnicodeLocaleAttribute(\"ca\"), \"invalid attribute\");\n@@ -1086,6 +1105,6 @@\n-            .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n-            .setUnicodeLocaleKeyword(\"nu\", \"thai\")\n-            .build();\n-        assertEquals(\"co\", \"japanese\", locale.getUnicodeLocaleType(\"co\"));\n-        assertEquals(\"nu\", \"thai\", locale.getUnicodeLocaleType(\"nu\"));\n-        assertEquals(\"keys\", 2, locale.getUnicodeLocaleKeys().size());\n+                .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n+                .setUnicodeLocaleKeyword(\"nu\", \"thai\")\n+                .build();\n+        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"co\"), \"co\");\n+        assertEquals(\"thai\", locale.getUnicodeLocaleType(\"nu\"), \"nu\");\n+        assertEquals(2, locale.getUnicodeLocaleKeys().size(), \"keys\");\n@@ -1095,4 +1114,4 @@\n-            .setUnicodeLocaleKeyword(\"co\", null)\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"empty co\", \"und-u-nu-thai\", result);\n+                .setUnicodeLocaleKeyword(\"co\", null)\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und-u-nu-thai\", result, \"empty co\");\n@@ -1102,4 +1121,4 @@\n-            .setUnicodeLocaleKeyword(\"nu\", null)\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"empty nu\", \"und\", result);\n+                .setUnicodeLocaleKeyword(\"nu\", null)\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und\", result, \"empty nu\");\n@@ -1109,5 +1128,5 @@\n-            .setUnicodeLocaleKeyword(\"zz\", \"012\")\n-            .setUnicodeLocaleKeyword(\"aa\", \"345\")\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"reordered\", \"und-u-aa-345-zz-012\", result);\n+                .setUnicodeLocaleKeyword(\"zz\", \"012\")\n+                .setUnicodeLocaleKeyword(\"aa\", \"345\")\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und-u-aa-345-zz-012\", result, \"reordered\");\n@@ -1116,1 +1135,3 @@\n-        new BuilderNPE(\"keyword\") { public void call() { b.setUnicodeLocaleKeyword(null, \"thai\"); }};\n+        assertThrows(NullPointerException.class,\n+                () -> new Builder().setUnicodeLocaleKeyword(null, \"thai\"), \"keyword\");\n+\n@@ -1119,1 +1140,4 @@\n-        new BuilderILE(\"a\", \"abc\") { public void call() { b.setUnicodeLocaleKeyword(arg, \"value\"); }};\n+        for (String arg : List.of(\"a\", \"abc\")) {\n+            assertThrows(IllformedLocaleException.class,\n+                    () -> new Builder().setUnicodeLocaleKeyword(arg, \"value\"));\n+        }\n@@ -1122,1 +1146,4 @@\n-        new BuilderILE(\"ab\", \"abcdefghi\") { public void call() { b.setUnicodeLocaleKeyword(\"ab\", arg); }};\n+        for (String arg : List.of(\"ab\", \"abcdefghi\")) {\n+            assertThrows(IllformedLocaleException.class,\n+                    () -> new Builder().setUnicodeLocaleKeyword(\"ab\", arg));\n+        }\n@@ -1132,4 +1159,4 @@\n-            .setExtension(Locale.PRIVATE_USE_EXTENSION, source)\n-            .build()\n-            .getExtension(Locale.PRIVATE_USE_EXTENSION);\n-        assertEquals(\"abc\", target, result);\n+                .setExtension(Locale.PRIVATE_USE_EXTENSION, source)\n+                .build()\n+                .getExtension(Locale.PRIVATE_USE_EXTENSION);\n+        assertEquals(target, result, \"abc\");\n@@ -1138,1 +1165,3 @@\n-        new BuilderILE(\"a--b\") { public void call() { b.setExtension(Locale.PRIVATE_USE_EXTENSION, arg); }};\n+        assertThrows(IllformedLocaleException.class,\n+                () -> new Builder().setExtension(Locale.PRIVATE_USE_EXTENSION, \"a--b\"),\n+                \"multiple-hyphens should throw IAE\");\n@@ -1147,5 +1176,5 @@\n-            .setLocale(locale)\n-            .clear()\n-            .build()\n-            .toLanguageTag();\n-        assertEquals(\"clear\", \"und\", result);\n+                .setLocale(locale)\n+                .clear()\n+                .build()\n+                .toLanguageTag();\n+        assertEquals(\"und\", result, \"clear\");\n@@ -1167,27 +1196,27 @@\n-            Locale.ROOT,\n-            Locale.ENGLISH,\n-            Locale.US,\n-            Locale.of(\"en\", \"US\", \"Win\"),\n-            Locale.of(\"en\", \"US\", \"Win_XP\"),\n-            Locale.JAPAN,\n-            Locale.of(\"ja\", \"JP\", \"JP\"),\n-            Locale.of(\"th\", \"TH\"),\n-            Locale.of(\"th\", \"TH\", \"TH\"),\n-            Locale.of(\"no\", \"NO\"),\n-            Locale.of(\"nb\", \"NO\"),\n-            Locale.of(\"nn\", \"NO\"),\n-            Locale.of(\"no\", \"NO\", \"NY\"),\n-            Locale.of(\"nn\", \"NO\", \"NY\"),\n-            Locale.of(\"he\", \"IL\"),\n-            Locale.of(\"he\", \"IL\", \"var\"),\n-            Locale.of(\"Language\", \"Country\", \"Variant\"),\n-            Locale.of(\"\", \"US\"),\n-            Locale.of(\"\", \"\", \"Java\"),\n-            Locale.forLanguageTag(\"en-Latn-US\"),\n-            Locale.forLanguageTag(\"zh-Hans\"),\n-            Locale.forLanguageTag(\"zh-Hant-TW\"),\n-            Locale.forLanguageTag(\"ja-JP-u-ca-japanese\"),\n-            Locale.forLanguageTag(\"und-Hant\"),\n-            Locale.forLanguageTag(\"und-a-123-456\"),\n-            Locale.forLanguageTag(\"en-x-java\"),\n-            Locale.forLanguageTag(\"th-TH-u-ca-buddist-nu-thai-x-lvariant-TH\"),\n+                Locale.ROOT,\n+                Locale.ENGLISH,\n+                Locale.US,\n+                Locale.of(\"en\", \"US\", \"Win\"),\n+                Locale.of(\"en\", \"US\", \"Win_XP\"),\n+                Locale.JAPAN,\n+                Locale.of(\"ja\", \"JP\", \"JP\"),\n+                Locale.of(\"th\", \"TH\"),\n+                Locale.of(\"th\", \"TH\", \"TH\"),\n+                Locale.of(\"no\", \"NO\"),\n+                Locale.of(\"nb\", \"NO\"),\n+                Locale.of(\"nn\", \"NO\"),\n+                Locale.of(\"no\", \"NO\", \"NY\"),\n+                Locale.of(\"nn\", \"NO\", \"NY\"),\n+                Locale.of(\"he\", \"IL\"),\n+                Locale.of(\"he\", \"IL\", \"var\"),\n+                Locale.of(\"Language\", \"Country\", \"Variant\"),\n+                Locale.of(\"\", \"US\"),\n+                Locale.of(\"\", \"\", \"Java\"),\n+                Locale.forLanguageTag(\"en-Latn-US\"),\n+                Locale.forLanguageTag(\"zh-Hans\"),\n+                Locale.forLanguageTag(\"zh-Hant-TW\"),\n+                Locale.forLanguageTag(\"ja-JP-u-ca-japanese\"),\n+                Locale.forLanguageTag(\"und-Hant\"),\n+                Locale.forLanguageTag(\"und-a-123-456\"),\n+                Locale.forLanguageTag(\"en-x-java\"),\n+                Locale.forLanguageTag(\"th-TH-u-ca-buddist-nu-thai-x-lvariant-TH\"),\n@@ -1208,1 +1237,1 @@\n-                assertEquals(\"roundtrip \" + locale, locale, o);\n+                assertEquals(locale, o, \"roundtrip \" + locale);\n@@ -1234,2 +1263,1 @@\n-            fail(\"'dataDir' is null. serialized.data.dir Property value is \"+dataDirName);\n-            return;\n+            fail(\"'dataDir' is null. serialized.data.dir Property value is \" + dataDirName);\n@@ -1237,2 +1265,1 @@\n-            fail(\"'dataDir' is not a directory. dataDir: \"+dataDir.toString());\n-            return;\n+            fail(\"'dataDir' is not a directory. dataDir: \" + dataDir.toString());\n@@ -1264,2 +1291,1 @@\n-                 ObjectInputStream ois = new ObjectInputStream(fis))\n-            {\n+                 ObjectInputStream ois = new ObjectInputStream(fis)) {\n@@ -1267,1 +1293,1 @@\n-                assertEquals(\"Deserialize Java 6 Locale \" + locale, o, locale);\n+                assertEquals(o, locale, \"Deserialize Java 6 Locale \" + locale);\n@@ -1287,9 +1313,9 @@\n-            {\"ja-JP-x-lvariant-JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\"},   \/\/ special case 1\n-            {\"ja-JP-x-lvariant-JP-XXX\"},\n-            {\"ja-JP-u-ca-japanese-x-lvariant-JP\"},\n-            {\"ja-JP-u-ca-gregory-x-lvariant-JP\"},\n-            {\"ja-JP-u-cu-jpy-x-lvariant-JP\"},\n-            {\"ja-x-lvariant-JP\"},\n-            {\"th-TH-x-lvariant-TH\", \"th-TH-u-nu-thai-x-lvariant-TH\"},   \/\/ special case 2\n-            {\"th-TH-u-nu-thai-x-lvariant-TH\"},\n-            {\"en-US-x-lvariant-JP\"},\n+                {\"ja-JP-x-lvariant-JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\"},   \/\/ special case 1\n+                {\"ja-JP-x-lvariant-JP-XXX\"},\n+                {\"ja-JP-u-ca-japanese-x-lvariant-JP\"},\n+                {\"ja-JP-u-ca-gregory-x-lvariant-JP\"},\n+                {\"ja-JP-u-cu-jpy-x-lvariant-JP\"},\n+                {\"ja-x-lvariant-JP\"},\n+                {\"th-TH-x-lvariant-TH\", \"th-TH-u-nu-thai-x-lvariant-TH\"},   \/\/ special case 2\n+                {\"th-TH-u-nu-thai-x-lvariant-TH\"},\n+                {\"en-US-x-lvariant-JP\"},\n@@ -1307,1 +1333,1 @@\n-            assertEquals(\"Language tag roundtrip by forLanguageTag with input: \" + in, expected, out);\n+            assertEquals(expected, out, \"Language tag roundtrip by forLanguageTag with input: \" + in);\n@@ -1314,1 +1340,1 @@\n-            assertEquals(\"Language tag roundtrip by Builder.setLanguageTag with input: \" + in, expected, out);\n+            assertEquals(expected, out, \"Language tag roundtrip by Builder.setLanguageTag with input: \" + in);\n@@ -1321,2 +1347,2 @@\n-            {\"en-Latn\", \"en__#Latn\"},\n-            {\"en-u-ca-japanese\", \"en__#u-ca-japanese\"},\n+                {\"en-Latn\", \"en__#Latn\"},\n+                {\"en-u-ca-japanese\", \"en__#u-ca-japanese\"},\n@@ -1331,1 +1357,1 @@\n-            assertEquals(\"Empty country field with non-empty script\/extension with input: \" + in, expected, out);\n+            assertEquals(expected, out, \"Empty country field with non-empty script\/extension with input: \" + in);\n@@ -1345,1 +1371,1 @@\n-                      \"java.util.JapaneseImperialCalendar\");\n+                \"java.util.JapaneseImperialCalendar\");\n@@ -1356,1 +1382,1 @@\n-        assertEquals(\"Wrong calendar\", expected, cal.getClass().getName());\n+        assertEquals(expected, cal.getClass().getName(), \"Wrong calendar\");\n@@ -1362,140 +1388,1 @@\n-        assertEquals(\"Wrong digit zero char\", expected, zero);\n-    }\n-\n-    \/\/\/\n-    \/\/\/ utility asserts\n-    \/\/\/\n-\n-    private void assertTrue(String msg, boolean v) {\n-        if (!v) {\n-            fail(msg + \": expected true\");\n-        }\n-    }\n-\n-    private void assertFalse(String msg, boolean v) {\n-        if (v) {\n-            fail(msg + \": expected false\");\n-        }\n-    }\n-\n-    private void assertEquals(String msg, Object e, Object v) {\n-        if (e == null ? v != null : !e.equals(v)) {\n-            if (e != null) {\n-                e = \"'\" + e + \"'\";\n-            }\n-            if (v != null) {\n-                v = \"'\" + v + \"'\";\n-            }\n-            fail(msg + \": expected \" + e + \" but got \" + v);\n-        }\n-    }\n-\n-    private void assertNotEquals(String msg, Object e, Object v) {\n-        if (e == null ? v == null : e.equals(v)) {\n-            if (e != null) {\n-                e = \"'\" + e + \"'\";\n-            }\n-            fail(msg + \": expected not equal \" + e);\n-        }\n-    }\n-\n-    private void assertNull(String msg, Object o) {\n-        if (o != null) {\n-            fail(msg + \": expected null but got '\" + o + \"'\");\n-        }\n-    }\n-\n-    private void assertNotNull(String msg, Object o) {\n-        if (o == null) {\n-            fail(msg + \": expected non null\");\n-        }\n-    }\n-\n-    \/\/ not currently used, might get rid of exceptions from the API\n-    private abstract class ExceptionTest {\n-        private final Class<? extends Exception> exceptionClass;\n-\n-        ExceptionTest(Class<? extends Exception> exceptionClass) {\n-            this.exceptionClass = exceptionClass;\n-        }\n-\n-        public void run() {\n-            String failMsg = null;\n-            try {\n-                call();\n-                failMsg = \"expected \" + exceptionClass.getName() + \"  but no exception thrown.\";\n-            }\n-            catch (Exception e) {\n-                if (!exceptionClass.isAssignableFrom(e.getClass())) {\n-                    failMsg = \"expected \" + exceptionClass.getName() + \" but caught \" + e;\n-                }\n-            }\n-            if (failMsg != null) {\n-                String msg = message();\n-                msg = msg == null ? \"\" : msg + \" \";\n-                fail(msg + failMsg);\n-            }\n-        }\n-\n-        public String message() {\n-            return null;\n-        }\n-\n-        public abstract void call();\n-    }\n-\n-    private abstract class ExpectNPE extends ExceptionTest {\n-        ExpectNPE() {\n-            super(NullPointerException.class);\n-            run();\n-        }\n-    }\n-\n-    private abstract class BuilderNPE extends ExceptionTest {\n-        protected final String msg;\n-        protected final Builder b = new Builder();\n-\n-        BuilderNPE(String msg) {\n-            super(NullPointerException.class);\n-\n-            this.msg = msg;\n-\n-            run();\n-        }\n-\n-        public String message() {\n-            return msg;\n-        }\n-    }\n-\n-    private abstract class ExpectIAE extends ExceptionTest {\n-        ExpectIAE() {\n-            super(IllegalArgumentException.class);\n-            run();\n-        }\n-    }\n-\n-    private abstract class BuilderILE extends ExceptionTest {\n-        protected final String[] args;\n-        protected final Builder b = new Builder();\n-\n-        protected String arg; \/\/ mutates during call\n-\n-        BuilderILE(String... args) {\n-            super(IllformedLocaleException.class);\n-\n-            this.args = args;\n-\n-            run();\n-        }\n-\n-        public void run() {\n-            for (String arg : args) {\n-                this.arg = arg;\n-                super.run();\n-            }\n-        }\n-\n-        public String message() {\n-            return \"arg: '\" + arg + \"'\";\n-        }\n+        assertEquals(expected, zero, \"Wrong digit zero char\");\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleEnhanceTest.java","additions":485,"deletions":598,"binary":false,"changes":1083,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -41,4 +42,17 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.PEMDecoder;\n+import java.security.PEMEncoder;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -50,3 +64,1 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n+import java.util.ArrayList;\n@@ -54,0 +66,1 @@\n+import java.util.List;\n@@ -77,16 +90,16 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA3WhcNMzMwMzI4MTIwNjA3WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n-        \"KoZIhvcNAQEBBQADgY0AMIGJAoGBANY+7Enp+1S566kLcKk+qe4Ki6BxaHGZ+v7r\\n\" +\n-        \"vLksx9IQZCbAEf4YLbrZhKzKD3SPIJXyxPFwknAknIh3Knk8mViOZks7T8L3GnJr\\n\" +\n-        \"TBaVvDyTzDJum\/QYiahfO2qpfN\/Oya2UILmqsBAeLyWpzbQsAyWBXfoUtkOUgnzK\\n\" +\n-        \"fk6QAKYrAgMBAAGjgaUwgaIwHQYDVR0OBBYEFEtmQi7jT1ijXOafPsfkrLwSVu9e\\n\" +\n-        \"MGMGA1UdIwRcMFqAFEtmQi7jT1ijXOafPsfkrLwSVu9eoT+kPTA7MQswCQYDVQQG\\n\" +\n-        \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-        \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n-        \"BQADgYEAkKWxMc4+ODk5WwLXXweB8\/IKfVfrizNn0KLEgsZ6xNXFIXDpiPGAFcgl\\n\" +\n-        \"MzFO424JgyvUulsUc\/X16Cnuwwntkk6KUG7vEV7h4o9sAV7Cax3gfQE\/EZFb4ybn\\n\" +\n-        \"aBm1UsujMKd\/ovqbbbxJbmOWzCeo0QfIGleDEyh3NBBZ0i11Kiw=\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA3WhcNMzMwMzI4MTIwNjA3WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n+            \"KoZIhvcNAQEBBQADgY0AMIGJAoGBANY+7Enp+1S566kLcKk+qe4Ki6BxaHGZ+v7r\\n\" +\n+            \"vLksx9IQZCbAEf4YLbrZhKzKD3SPIJXyxPFwknAknIh3Knk8mViOZks7T8L3GnJr\\n\" +\n+            \"TBaVvDyTzDJum\/QYiahfO2qpfN\/Oya2UILmqsBAeLyWpzbQsAyWBXfoUtkOUgnzK\\n\" +\n+            \"fk6QAKYrAgMBAAGjgaUwgaIwHQYDVR0OBBYEFEtmQi7jT1ijXOafPsfkrLwSVu9e\\n\" +\n+            \"MGMGA1UdIwRcMFqAFEtmQi7jT1ijXOafPsfkrLwSVu9eoT+kPTA7MQswCQYDVQQG\\n\" +\n+            \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n+            \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n+            \"BQADgYEAkKWxMc4+ODk5WwLXXweB8\/IKfVfrizNn0KLEgsZ6xNXFIXDpiPGAFcgl\\n\" +\n+            \"MzFO424JgyvUulsUc\/X16Cnuwwntkk6KUG7vEV7h4o9sAV7Cax3gfQE\/EZFb4ybn\\n\" +\n+            \"aBm1UsujMKd\/ovqbbbxJbmOWzCeo0QfIGleDEyh3NBBZ0i11Kiw=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -96,15 +109,15 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVTCCAb6gAwIBAgIBAjANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA4WhcNMzIwMTAzMTIwNjA4WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-        \"BAMTD3d3dy5leGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-        \"4zFp3PZNzsd3ZwG6FNNWO9eSN+UBymlf8oCwpKJM2tIinmMWvWIXnlx\/2UXIfSAq\\n\" +\n-        \"QEG3aXkAFyEiGGpQlBbqcfrESsHsiz2pnnm5dG2v\/eS0Bwz1jmcuNmwnh3UQw2Vl\\n\" +\n-        \"+BLk8ukdrLjiCT8jARiHExYf1Xg+wUqQ9y8NV26hdaUCAwEAAaNPME0wCwYDVR0P\\n\" +\n-        \"BAQDAgPoMB0GA1UdDgQWBBQwtx+gqzn2w4y82brXlp7tqBYEZDAfBgNVHSMEGDAW\\n\" +\n-        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQAJWo8B6Ud+\\n\" +\n-        \"\/OU+UcZLihlfMX02OSlK2ZB7mfqpj2G3JT9yb0A+VbY3uuajmaYYIIxl3kXGz\/n8\\n\" +\n-        \"M2Q\/Ux\/MDxG+IFKHC26Kuj4dAQgzjq2pILVPTE2QnaQTNCsgVZtTaC47SG9FRSoC\\n\" +\n-        \"qvnIvn\/oTpKSqus76I1cR4joDtiV2OEuVw==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVTCCAb6gAwIBAgIBAjANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA4WhcNMzIwMTAzMTIwNjA4WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+            \"BAMTD3d3dy5leGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+            \"4zFp3PZNzsd3ZwG6FNNWO9eSN+UBymlf8oCwpKJM2tIinmMWvWIXnlx\/2UXIfSAq\\n\" +\n+            \"QEG3aXkAFyEiGGpQlBbqcfrESsHsiz2pnnm5dG2v\/eS0Bwz1jmcuNmwnh3UQw2Vl\\n\" +\n+            \"+BLk8ukdrLjiCT8jARiHExYf1Xg+wUqQ9y8NV26hdaUCAwEAAaNPME0wCwYDVR0P\\n\" +\n+            \"BAQDAgPoMB0GA1UdDgQWBBQwtx+gqzn2w4y82brXlp7tqBYEZDAfBgNVHSMEGDAW\\n\" +\n+            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQAJWo8B6Ud+\\n\" +\n+            \"\/OU+UcZLihlfMX02OSlK2ZB7mfqpj2G3JT9yb0A+VbY3uuajmaYYIIxl3kXGz\/n8\\n\" +\n+            \"M2Q\/Ux\/MDxG+IFKHC26Kuj4dAQgzjq2pILVPTE2QnaQTNCsgVZtTaC47SG9FRSoC\\n\" +\n+            \"qvnIvn\/oTpKSqus76I1cR4joDtiV2OEuVw==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -114,14 +127,16 @@\n-        \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAOMxadz2Tc7Hd2cB\\n\" +\n-        \"uhTTVjvXkjflAcppX\/KAsKSiTNrSIp5jFr1iF55cf9lFyH0gKkBBt2l5ABchIhhq\\n\" +\n-        \"UJQW6nH6xErB7Is9qZ55uXRtr\/3ktAcM9Y5nLjZsJ4d1EMNlZfgS5PLpHay44gk\/\\n\" +\n-        \"IwEYhxMWH9V4PsFKkPcvDVduoXWlAgMBAAECgYAqX2nuIyXp3fvgA0twXOYlbRRB\\n\" +\n-        \"Rn3qAXM6qFPJsNeCrFR2k+aG1cev6nKR1FkLNTeMGnWZv06MAcr5IML8i7WXyG4C\\n\" +\n-        \"LY\/C0gedn94FDKFlln+bTENwQTGjn4lKysDA+IuNpasTeMCajbic+dPByhIdTOjZ\\n\" +\n-        \"iMCyxbLfpk40zQopVQJBAPyfGmkeHB3GjdbdgujWCGKb2UxBa4O8dy3O4l2yizTn\\n\" +\n-        \"uUqMGcwGY4ciNSVvZQ7jKo4vDmkSuYib4\/woPChaNfMCQQDmO0BQuSWYGNtSwV35\\n\" +\n-        \"lafZfX1dNCLKm1iNA6A12evXgvQiE9WT4mqionig0VZW16HtiY4\/BkHOcos\/K9Um\\n\" +\n-        \"ARQHAkA8mkaRtSF1my5nv1gqVz5Hua+VdZQ\/VDUbDiiL5cszc+ulkJqXsWirAG\/T\\n\" +\n-        \"fTe3LJQG7A7+8fkEZrF4yoY0AAA1AkEAotokezULj5N9iAL5SzL9wIzQYV4ggfny\\n\" +\n-        \"YATBjXXxKccakwQ+ndWZIiMUeoS4ssLialhTgucVI0fIkU2a\/r\/ifwJAc6e+5Pvh\\n\" +\n-        \"MghQj\/U788Od\/v6rgqz\/NGsduZ7uilCMcWiwA73OR2MHMH\/OIuoofuEPrfuV9isV\\n\" +\n-        \"xVXhgpKfP\/pdOA==\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAOMxadz2Tc7Hd2cB\\n\" +\n+            \"uhTTVjvXkjflAcppX\/KAsKSiTNrSIp5jFr1iF55cf9lFyH0gKkBBt2l5ABchIhhq\\n\" +\n+            \"UJQW6nH6xErB7Is9qZ55uXRtr\/3ktAcM9Y5nLjZsJ4d1EMNlZfgS5PLpHay44gk\/\\n\" +\n+            \"IwEYhxMWH9V4PsFKkPcvDVduoXWlAgMBAAECgYAqX2nuIyXp3fvgA0twXOYlbRRB\\n\" +\n+            \"Rn3qAXM6qFPJsNeCrFR2k+aG1cev6nKR1FkLNTeMGnWZv06MAcr5IML8i7WXyG4C\\n\" +\n+            \"LY\/C0gedn94FDKFlln+bTENwQTGjn4lKysDA+IuNpasTeMCajbic+dPByhIdTOjZ\\n\" +\n+            \"iMCyxbLfpk40zQopVQJBAPyfGmkeHB3GjdbdgujWCGKb2UxBa4O8dy3O4l2yizTn\\n\" +\n+            \"uUqMGcwGY4ciNSVvZQ7jKo4vDmkSuYib4\/woPChaNfMCQQDmO0BQuSWYGNtSwV35\\n\" +\n+            \"lafZfX1dNCLKm1iNA6A12evXgvQiE9WT4mqionig0VZW16HtiY4\/BkHOcos\/K9Um\\n\" +\n+            \"ARQHAkA8mkaRtSF1my5nv1gqVz5Hua+VdZQ\/VDUbDiiL5cszc+ulkJqXsWirAG\/T\\n\" +\n+            \"fTe3LJQG7A7+8fkEZrF4yoY0AAA1AkEAotokezULj5N9iAL5SzL9wIzQYV4ggfny\\n\" +\n+            \"YATBjXXxKccakwQ+ndWZIiMUeoS4ssLialhTgucVI0fIkU2a\/r\/ifwJAc6e+5Pvh\\n\" +\n+            \"MghQj\/U788Od\/v6rgqz\/NGsduZ7uilCMcWiwA73OR2MHMH\/OIuoofuEPrfuV9isV\\n\" +\n+            \"xVXhgpKfP\/pdOA==\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -131,15 +146,15 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVTCCAb6gAwIBAgIBBDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-        \"BAMTD3d3dy5leGFtcGxlLm5ldDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-        \"2VlzF1fvWYczDChrUeJiLJ1M\/dIShCaOTfYGiXfQGEZCAWTacUclwr+rVMnZ75\/c\\n\" +\n-        \"wwg5pNdXRijxMil8DBTS1gFcIFQhosLHvzIAe6ULlg\/xB+\/L6KBz+NTWfo\/2KF6t\\n\" +\n-        \"xatmcToNrCcwi7eUOfbzQje65Tizs56jJYem2m7Rk0ECAwEAAaNPME0wCwYDVR0P\\n\" +\n-        \"BAQDAgPoMB0GA1UdDgQWBBQT\/FR0cAWcZQ7h0X79KGki34OSQjAfBgNVHSMEGDAW\\n\" +\n-        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQB67cPIT6fz\\n\" +\n-        \"6Ws8fBpYgW2ad4ci66i1WduBD9CpGFE+jRK2feRj6hvYBXocKj0AMWUFIEB2E3hA\\n\" +\n-        \"oIjxcf1GxIpHVl9DjlhxqXbA0Ktl7\/NGNRlDSLTizOTl3FB1mMTlOGvXDVmpcFhl\\n\" +\n-        \"HuoP1hYvhTsBwPx5igGNchuPtDIUzL2mXw==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVTCCAb6gAwIBAgIBBDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+            \"BAMTD3d3dy5leGFtcGxlLm5ldDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+            \"2VlzF1fvWYczDChrUeJiLJ1M\/dIShCaOTfYGiXfQGEZCAWTacUclwr+rVMnZ75\/c\\n\" +\n+            \"wwg5pNdXRijxMil8DBTS1gFcIFQhosLHvzIAe6ULlg\/xB+\/L6KBz+NTWfo\/2KF6t\\n\" +\n+            \"xatmcToNrCcwi7eUOfbzQje65Tizs56jJYem2m7Rk0ECAwEAAaNPME0wCwYDVR0P\\n\" +\n+            \"BAQDAgPoMB0GA1UdDgQWBBQT\/FR0cAWcZQ7h0X79KGki34OSQjAfBgNVHSMEGDAW\\n\" +\n+            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQB67cPIT6fz\\n\" +\n+            \"6Ws8fBpYgW2ad4ci66i1WduBD9CpGFE+jRK2feRj6hvYBXocKj0AMWUFIEB2E3hA\\n\" +\n+            \"oIjxcf1GxIpHVl9DjlhxqXbA0Ktl7\/NGNRlDSLTizOTl3FB1mMTlOGvXDVmpcFhl\\n\" +\n+            \"HuoP1hYvhTsBwPx5igGNchuPtDIUzL2mXw==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -148,14 +163,16 @@\n-        \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANlZcxdX71mHMwwo\\n\" +\n-        \"a1HiYiydTP3SEoQmjk32Bol30BhGQgFk2nFHJcK\/q1TJ2e+f3MMIOaTXV0Yo8TIp\\n\" +\n-        \"fAwU0tYBXCBUIaLCx78yAHulC5YP8Qfvy+igc\/jU1n6P9ihercWrZnE6DawnMIu3\\n\" +\n-        \"lDn280I3uuU4s7OeoyWHptpu0ZNBAgMBAAECgYEAl19H26sfhD+32rDPxZCgBShs\\n\" +\n-        \"dZ33zVe45i0Bcn4iTLWpxKTDyf7eGps4rO2DvfKdYqt40ggzvSZIjUH9JcDe8GmG\\n\" +\n-        \"d3m0ILB7pg4jsFlpyeHpTO8grPLxA1G9s3o0DoFpz\/rooqgFfe\/DrRDmRoOSkgfV\\n\" +\n-        \"\/gseIbgJHRO\/Ctyvdh0CQQD6uFd0HxhH1jl\/JzvPzIH4LSnPcdEh9zsMEb6uzh75\\n\" +\n-        \"9qL+IHD5N2I\/pYZTKqDFIwhJf701+LKag55AX\/zrDt7rAkEA3e00AbnwanDMa6Wj\\n\" +\n-        \"+gFekUQveSVra38LiihzCkyVvQpFjbiF1rUhSNQ0dpU5\/hmrYF0C6H9VXAesfkUY\\n\" +\n-        \"WhpDgwJAYjgZOop77piDycZK7isFt32p5XSHIzFBVocVFlH1XKM8UyXOXDNQL\/Le\\n\" +\n-        \"XnJSrSf+NRzvuNcG0PVC56Ey6brXpQJAY4M4vcltt5zq3R5CQBmbGRJ1IyKXX3Vx\\n\" +\n-        \"bDslEqoyvri7ZYgnY5aG3UxiVgYmIf3KrgQnCLAIS6MZQumiuMxsFwJAK5pEG063\\n\" +\n-        \"9ngUof4fDMvZphqZjZR1zMKz\/V\/9ge0DWBINaqFgsgebNu+MyImsC8C6WKjGmV\/2\\n\" +\n-        \"f1MY0D7sC2vU\/Q==\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANlZcxdX71mHMwwo\\n\" +\n+            \"a1HiYiydTP3SEoQmjk32Bol30BhGQgFk2nFHJcK\/q1TJ2e+f3MMIOaTXV0Yo8TIp\\n\" +\n+            \"fAwU0tYBXCBUIaLCx78yAHulC5YP8Qfvy+igc\/jU1n6P9ihercWrZnE6DawnMIu3\\n\" +\n+            \"lDn280I3uuU4s7OeoyWHptpu0ZNBAgMBAAECgYEAl19H26sfhD+32rDPxZCgBShs\\n\" +\n+            \"dZ33zVe45i0Bcn4iTLWpxKTDyf7eGps4rO2DvfKdYqt40ggzvSZIjUH9JcDe8GmG\\n\" +\n+            \"d3m0ILB7pg4jsFlpyeHpTO8grPLxA1G9s3o0DoFpz\/rooqgFfe\/DrRDmRoOSkgfV\\n\" +\n+            \"\/gseIbgJHRO\/Ctyvdh0CQQD6uFd0HxhH1jl\/JzvPzIH4LSnPcdEh9zsMEb6uzh75\\n\" +\n+            \"9qL+IHD5N2I\/pYZTKqDFIwhJf701+LKag55AX\/zrDt7rAkEA3e00AbnwanDMa6Wj\\n\" +\n+            \"+gFekUQveSVra38LiihzCkyVvQpFjbiF1rUhSNQ0dpU5\/hmrYF0C6H9VXAesfkUY\\n\" +\n+            \"WhpDgwJAYjgZOop77piDycZK7isFt32p5XSHIzFBVocVFlH1XKM8UyXOXDNQL\/Le\\n\" +\n+            \"XnJSrSf+NRzvuNcG0PVC56Ey6brXpQJAY4M4vcltt5zq3R5CQBmbGRJ1IyKXX3Vx\\n\" +\n+            \"bDslEqoyvri7ZYgnY5aG3UxiVgYmIf3KrgQnCLAIS6MZQumiuMxsFwJAK5pEG063\\n\" +\n+            \"9ngUof4fDMvZphqZjZR1zMKz\/V\/9ge0DWBINaqFgsgebNu+MyImsC8C6WKjGmV\/2\\n\" +\n+            \"f1MY0D7sC2vU\/Q==\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -165,15 +182,15 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVTCCAb6gAwIBAgIBAzANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-        \"BAMTD3d3dy5pbnZhbGlkLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-        \"q6MyQwzCr2nJ41l0frmHL0qULSyW51MhevBC+1W28i0LE\/efrmpwV3LdnlQEGFak\\n\" +\n-        \"DLDwtnff3iru8dSMcA7KdWVkivsE7ZTP+qFDaWBAy7XXiSsv6yZ2Nh4jJb0YcD28\\n\" +\n-        \"45zk2nAl5Az1\/PuoTi1vpQxzFZKuBm1HGgz3MEZvBvMCAwEAAaNPME0wCwYDVR0P\\n\" +\n-        \"BAQDAgPoMB0GA1UdDgQWBBRRMifrND015Nm8N6gV5X7cg1YjjjAfBgNVHSMEGDAW\\n\" +\n-        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQBjkUO6Ri\/B\\n\" +\n-        \"uDC2gDMIyL5+NTe\/1dPPQYM4HhCNa\/KQYvU5lzCKO9Vpa+i+nyrUNNXUu8Tkyq4Y\\n\" +\n-        \"A+aGSm6+FT\/i9rFwkYUdorBtD3KfQiwTIWrVERXBkWI5iZNaVZhx0TFy4vUpf65d\\n\" +\n-        \"QtwkbHpC66fdKc2EdLXkuY9KkmtZZJJ7YA==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVTCCAb6gAwIBAgIBAzANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+            \"BAMTD3d3dy5pbnZhbGlkLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+            \"q6MyQwzCr2nJ41l0frmHL0qULSyW51MhevBC+1W28i0LE\/efrmpwV3LdnlQEGFak\\n\" +\n+            \"DLDwtnff3iru8dSMcA7KdWVkivsE7ZTP+qFDaWBAy7XXiSsv6yZ2Nh4jJb0YcD28\\n\" +\n+            \"45zk2nAl5Az1\/PuoTi1vpQxzFZKuBm1HGgz3MEZvBvMCAwEAAaNPME0wCwYDVR0P\\n\" +\n+            \"BAQDAgPoMB0GA1UdDgQWBBRRMifrND015Nm8N6gV5X7cg1YjjjAfBgNVHSMEGDAW\\n\" +\n+            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQBjkUO6Ri\/B\\n\" +\n+            \"uDC2gDMIyL5+NTe\/1dPPQYM4HhCNa\/KQYvU5lzCKO9Vpa+i+nyrUNNXUu8Tkyq4Y\\n\" +\n+            \"A+aGSm6+FT\/i9rFwkYUdorBtD3KfQiwTIWrVERXBkWI5iZNaVZhx0TFy4vUpf65d\\n\" +\n+            \"QtwkbHpC66fdKc2EdLXkuY9KkmtZZJJ7YA==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -182,14 +199,16 @@\n-        \"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAKujMkMMwq9pyeNZ\\n\" +\n-        \"dH65hy9KlC0sludTIXrwQvtVtvItCxP3n65qcFdy3Z5UBBhWpAyw8LZ3394q7vHU\\n\" +\n-        \"jHAOynVlZIr7BO2Uz\/qhQ2lgQMu114krL+smdjYeIyW9GHA9vOOc5NpwJeQM9fz7\\n\" +\n-        \"qE4tb6UMcxWSrgZtRxoM9zBGbwbzAgMBAAECgYASJDK40Y12Wvki1Z6xkkyOnBRj\\n\" +\n-        \"XfYpRykfxGtgA2RN3qLwHlk7Zzaul46DIKA6LlYynTUkJDF+Ww1cdDnP0lBlwcmM\\n\" +\n-        \"iD0ck3zYyYBLhQHuVbkK3SYE+ANRhM0icvvqANP2at\/U4awQcPNEae\/KCiecLNu3\\n\" +\n-        \"CJGqyhPDdrEAqPuJGQJBAN46pQC6l3yrcSYE2s53jSmsm2HVVOFlFXjU6k\/RMTxG\\n\" +\n-        \"FfDJtGUAOQ37rPQ06ugr\/gjLAmmPp+FXozaBdA32D80CQQDFuGRgv3WYqbglIcRL\\n\" +\n-        \"JRs6xlj9w1F97s\/aiUenuwhIPNiUoRbV7mnNuZ\/sGF0svOVE7SazRjuFX6UqL9Y9\\n\" +\n-        \"HzG\/AkEA170pCI8cl4w8eUNHRB9trGKEKjMXhwVCFh7lJf2ZBcGodSzr8w2HVhrZ\\n\" +\n-        \"Ke7hiemDYffrbJ1oxmv05+o+x3r0lQJBAL6adVm2+FyFMFnLZXmzeb59O4jWY5bt\\n\" +\n-        \"Qz6\/HG6bpO5OidMuP99YCHMkQQDOs\/PO3Y5GuAoW6IY4n\/Y9S2B80+0CQBl1\/H9\/\\n\" +\n-        \"0n\/vrb6vW6Azds49tuS82RFAnOhtwTyBEajs08WF8rZQ3WD2RHJnH0+jjfL0anIp\\n\" +\n-        \"dQBSeNN7s7b6rRk=\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAKujMkMMwq9pyeNZ\\n\" +\n+            \"dH65hy9KlC0sludTIXrwQvtVtvItCxP3n65qcFdy3Z5UBBhWpAyw8LZ3394q7vHU\\n\" +\n+            \"jHAOynVlZIr7BO2Uz\/qhQ2lgQMu114krL+smdjYeIyW9GHA9vOOc5NpwJeQM9fz7\\n\" +\n+            \"qE4tb6UMcxWSrgZtRxoM9zBGbwbzAgMBAAECgYASJDK40Y12Wvki1Z6xkkyOnBRj\\n\" +\n+            \"XfYpRykfxGtgA2RN3qLwHlk7Zzaul46DIKA6LlYynTUkJDF+Ww1cdDnP0lBlwcmM\\n\" +\n+            \"iD0ck3zYyYBLhQHuVbkK3SYE+ANRhM0icvvqANP2at\/U4awQcPNEae\/KCiecLNu3\\n\" +\n+            \"CJGqyhPDdrEAqPuJGQJBAN46pQC6l3yrcSYE2s53jSmsm2HVVOFlFXjU6k\/RMTxG\\n\" +\n+            \"FfDJtGUAOQ37rPQ06ugr\/gjLAmmPp+FXozaBdA32D80CQQDFuGRgv3WYqbglIcRL\\n\" +\n+            \"JRs6xlj9w1F97s\/aiUenuwhIPNiUoRbV7mnNuZ\/sGF0svOVE7SazRjuFX6UqL9Y9\\n\" +\n+            \"HzG\/AkEA170pCI8cl4w8eUNHRB9trGKEKjMXhwVCFh7lJf2ZBcGodSzr8w2HVhrZ\\n\" +\n+            \"Ke7hiemDYffrbJ1oxmv05+o+x3r0lQJBAL6adVm2+FyFMFnLZXmzeb59O4jWY5bt\\n\" +\n+            \"Qz6\/HG6bpO5OidMuP99YCHMkQQDOs\/PO3Y5GuAoW6IY4n\/Y9S2B80+0CQBl1\/H9\/\\n\" +\n+            \"0n\/vrb6vW6Azds49tuS82RFAnOhtwTyBEajs08WF8rZQ3WD2RHJnH0+jjfL0anIp\\n\" +\n+            \"dQBSeNN7s7b6rRk=\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -198,16 +217,16 @@\n-    static String targetCertStr_D=\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVDCCAb2gAwIBAgIBBTANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjEwWhcNMzIwMTAzMTIwNjEwWjBUMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxFzAVBgNV\\n\" +\n-        \"BAMTDkludGVyT3AgVGVzdGVyMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDo\\n\" +\n-        \"Q\/KoAIAC2ljFfW2KwjnxTzi4NQJeUuk2seqKpsAY8x4O5dvixzUl6142zmljapqi\\n\" +\n-        \"bJloQVpfB+CEc5\/l4h5gzGRVzkuqP1oPzDrpZ5GsvmvuHenV\/TzCIgX1cLETzQVt\\n\" +\n-        \"6Rk06okoBPnw3hDJEJiEc1Rv7HCE8p\/p+SaiHrskwwIDAQABo08wTTALBgNVHQ8E\\n\" +\n-        \"BAMCA+gwHQYDVR0OBBYEFPr91O33RIGfFSqza2AwQIgE4QswMB8GA1UdIwQYMBaA\\n\" +\n-        \"FEtmQi7jT1ijXOafPsfkrLwSVu9eMA0GCSqGSIb3DQEBBAUAA4GBANIDFYgAhoj3\\n\" +\n-        \"B8u1YpqeoEp2Lt9TwrYBshaIrbmBPCwCGio0JIsoov3n8BCSg5F+8MnOtPl+TjeO\\n\" +\n-        \"0Ug+7guPdCk\/wg8YNxLHgSsQlpcNJDjWiErqmUPVrg5BPPQb65qMund6KTmMN0y6\\n\" +\n-        \"4EbSmxRpZO\/N0\/5oK4umTk0EeXKNekBj\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+    static String targetCertStr_D =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVDCCAb2gAwIBAgIBBTANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjEwWhcNMzIwMTAzMTIwNjEwWjBUMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxFzAVBgNV\\n\" +\n+            \"BAMTDkludGVyT3AgVGVzdGVyMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDo\\n\" +\n+            \"Q\/KoAIAC2ljFfW2KwjnxTzi4NQJeUuk2seqKpsAY8x4O5dvixzUl6142zmljapqi\\n\" +\n+            \"bJloQVpfB+CEc5\/l4h5gzGRVzkuqP1oPzDrpZ5GsvmvuHenV\/TzCIgX1cLETzQVt\\n\" +\n+            \"6Rk06okoBPnw3hDJEJiEc1Rv7HCE8p\/p+SaiHrskwwIDAQABo08wTTALBgNVHQ8E\\n\" +\n+            \"BAMCA+gwHQYDVR0OBBYEFPr91O33RIGfFSqza2AwQIgE4QswMB8GA1UdIwQYMBaA\\n\" +\n+            \"FEtmQi7jT1ijXOafPsfkrLwSVu9eMA0GCSqGSIb3DQEBBAUAA4GBANIDFYgAhoj3\\n\" +\n+            \"B8u1YpqeoEp2Lt9TwrYBshaIrbmBPCwCGio0JIsoov3n8BCSg5F+8MnOtPl+TjeO\\n\" +\n+            \"0Ug+7guPdCk\/wg8YNxLHgSsQlpcNJDjWiErqmUPVrg5BPPQb65qMund6KTmMN0y6\\n\" +\n+            \"4EbSmxRpZO\/N0\/5oK4umTk0EeXKNekBj\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -216,14 +235,16 @@\n-        \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAOhD8qgAgALaWMV9\\n\" +\n-        \"bYrCOfFPOLg1Al5S6Tax6oqmwBjzHg7l2+LHNSXrXjbOaWNqmqJsmWhBWl8H4IRz\\n\" +\n-        \"n+XiHmDMZFXOS6o\/Wg\/MOulnkay+a+4d6dX9PMIiBfVwsRPNBW3pGTTqiSgE+fDe\\n\" +\n-        \"EMkQmIRzVG\/scITyn+n5JqIeuyTDAgMBAAECgYBw37yIKp4LRONJLnhSq6sO+0n8\\n\" +\n-        \"Mz6waiiN\/Q6XTQwj09pysQAYCGlqwSRrDAqpVsBJWO+Ae+oYLrLMi4hUZnwN75v3\\n\" +\n-        \"pe1nXlrD11RmPLXwBxqFxNSvAs2FgLHZEtwHI7Bn8KybT\/8bGkQ8csLceInYtMDD\\n\" +\n-        \"MuTyy2KRk\/pj60zIKQJBAPgebQiAH6viFQ88AwHaNvQhlUfwmSC1i6f8LVoeqaHC\\n\" +\n-        \"lnP0LJBwlyDeeEInhHrCR2ibnCB6I\/Pig+49XQgabK8CQQDvpJwuGEbsOO+3rkJJ\\n\" +\n-        \"OpOw4toG0QJZdRnT6l8I6BlboQRZSfFh+lGGahvFXkxc4KdUpJ7QPtXU7HHk6Huk\\n\" +\n-        \"8RYtAkA9CW8VGj+wTuuTVdX\/jKjcIa7RhbSFwWNbrcOSWdys+Gt+luCnn6rt4QyA\\n\" +\n-        \"aaxDbquWZkFgE+voQR7nap0KM0XtAkAznd0WAJymHM1lXt9gLoHJQ9N6TGKZKiPa\\n\" +\n-        \"BU1a+cMcfV4WbVrUo7oTnZ9Fr73681iXXq3mZOJh7lvJ1llreZIxAkBEnbiTgEf4\\n\" +\n-        \"tvku68jHcRbRPmdS7CBSWNEBaHLOm4pUSTcxVTKKMHw7vmM5\/UYUxJ8QNKCYxn6O\\n\" +\n-        \"+vtiBwBawwzN\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAOhD8qgAgALaWMV9\\n\" +\n+            \"bYrCOfFPOLg1Al5S6Tax6oqmwBjzHg7l2+LHNSXrXjbOaWNqmqJsmWhBWl8H4IRz\\n\" +\n+            \"n+XiHmDMZFXOS6o\/Wg\/MOulnkay+a+4d6dX9PMIiBfVwsRPNBW3pGTTqiSgE+fDe\\n\" +\n+            \"EMkQmIRzVG\/scITyn+n5JqIeuyTDAgMBAAECgYBw37yIKp4LRONJLnhSq6sO+0n8\\n\" +\n+            \"Mz6waiiN\/Q6XTQwj09pysQAYCGlqwSRrDAqpVsBJWO+Ae+oYLrLMi4hUZnwN75v3\\n\" +\n+            \"pe1nXlrD11RmPLXwBxqFxNSvAs2FgLHZEtwHI7Bn8KybT\/8bGkQ8csLceInYtMDD\\n\" +\n+            \"MuTyy2KRk\/pj60zIKQJBAPgebQiAH6viFQ88AwHaNvQhlUfwmSC1i6f8LVoeqaHC\\n\" +\n+            \"lnP0LJBwlyDeeEInhHrCR2ibnCB6I\/Pig+49XQgabK8CQQDvpJwuGEbsOO+3rkJJ\\n\" +\n+            \"OpOw4toG0QJZdRnT6l8I6BlboQRZSfFh+lGGahvFXkxc4KdUpJ7QPtXU7HHk6Huk\\n\" +\n+            \"8RYtAkA9CW8VGj+wTuuTVdX\/jKjcIa7RhbSFwWNbrcOSWdys+Gt+luCnn6rt4QyA\\n\" +\n+            \"aaxDbquWZkFgE+voQR7nap0KM0XtAkAznd0WAJymHM1lXt9gLoHJQ9N6TGKZKiPa\\n\" +\n+            \"BU1a+cMcfV4WbVrUo7oTnZ9Fr73681iXXq3mZOJh7lvJ1llreZIxAkBEnbiTgEf4\\n\" +\n+            \"tvku68jHcRbRPmdS7CBSWNEBaHLOm4pUSTcxVTKKMHw7vmM5\/UYUxJ8QNKCYxn6O\\n\" +\n+            \"+vtiBwBawwzN\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -238,1 +259,1 @@\n-    static char passphrase[] = \"passphrase\".toCharArray();\n+    static char[] passphrase = \"passphrase\".toCharArray();\n@@ -248,1 +269,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -365,2 +386,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -372,5 +392,2 @@\n-        \/\/ import the trused cert\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trustedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+        \/\/ generate certificate from cert string\n+        Certificate trusedCert = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n@@ -378,0 +395,1 @@\n+        \/\/ import the trused cert\n@@ -393,2 +411,1 @@\n-            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                                Base64.getMimeDecoder().decode(keySpecStr));\n+            PKCS8EncodedKeySpec priKeySpec = pemDecoder.decode(keySpecStr, PKCS8EncodedKeySpec.class);\n@@ -401,3 +418,1 @@\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n+            Certificate keyCert = pemDecoder.decode(keyCertStr, X509Certificate.class);\n@@ -524,14 +539,12 @@\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died, because of \" + e);\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n+            serverThread = new Thread(() -> {\n+                try {\n+                    doServerSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our server thread just died.\n+                     *\n+                     * Release the client, if not active already...\n+                     *\/\n+                    System.err.println(\"Server died, because of \" + e);\n+                    serverReady = true;\n+                    serverException = e;\n@@ -539,1 +552,1 @@\n-            };\n+            });\n@@ -554,11 +567,9 @@\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died, because of \" + e);\n-                        clientException = e;\n-                    }\n+            clientThread = new Thread(() -> {\n+                try {\n+                    doClientSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our client thread just died.\n+                     *\/\n+                    System.err.println(\"Client died, because of \" + e);\n+                    clientException = e;\n@@ -566,1 +577,1 @@\n-            };\n+            });\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketSNISensitive.java","additions":193,"deletions":182,"binary":false,"changes":375,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloBufferUnderflowException.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloChromeInterOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,8 @@\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.nio.*;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+import java.nio.ByteBuffer;\n@@ -29,0 +33,2 @@\n+import java.security.PEMDecoder;\n+import java.security.PEMRecord;\n@@ -30,1 +36,0 @@\n-import java.security.KeyFactory;\n@@ -32,3 +37,3 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.util.Base64;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.ECPrivateKey;\n+import java.security.interfaces.RSAPrivateKey;\n@@ -141,0 +146,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -143,1 +149,2 @@\n-        \"Ay6zUapMW9ydE84KGXyy5my+Sw7QKlmoveGNeZVf12nUVX+tQEYujVob\",\n+        \"Ay6zUapMW9ydE84KGXyy5my+Sw7QKlmoveGNeZVf12nUVX+tQEYujVob\\n\" +\n+        \"-----END PRIVATE KEY-----\",\n@@ -148,0 +155,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -173,2 +181,3 @@\n-        \"dKUqlw5BPHdbxoWB\/JpSHGCV\"\n-        };\n+        \"dKUqlw5BPHdbxoWB\/JpSHGCV\\n\" +\n+        \"-----END PRIVATE KEY-----\"\n+    };\n@@ -182,0 +191,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -254,4 +265,1 @@\n-        char passphrase[] = \"passphrase\".toCharArray();\n-\n-        \/\/ Generate certificate from cert string.\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        char[] passphrase = \"passphrase\".toCharArray();\n@@ -260,1 +268,0 @@\n-        ByteArrayInputStream is;\n@@ -269,7 +276,2 @@\n-\n-                is = new ByteArrayInputStream(trustedCertStr.getBytes());\n-                try {\n-                    trustedCert[i] = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n+                \/\/ Generate certificate from cert string.\n+                trustedCert[i] = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n@@ -298,5 +300,5 @@\n-                PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                    Base64.getMimeDecoder().decode(keyMaterialKeys[i]));\n-                KeyFactory kf =\n-                    KeyFactory.getInstance(keyMaterialKeyAlgs[i]);\n-                PrivateKey priKey = kf.generatePrivate(priKeySpec);\n+                PrivateKey priKey = switch (keyMaterialKeyAlgs[i]) {\n+                    case \"RSA\" -> pemDecoder.decode(keyMaterialKeys[i], RSAPrivateKey.class);\n+                    case \"EC\" -> pemDecoder.decode(keyMaterialKeys[i], ECPrivateKey.class);\n+                    default -> pemDecoder.decode(keyMaterialKeys[i], PrivateKey.class);\n+                };\n@@ -305,8 +307,1 @@\n-                is = new ByteArrayInputStream(keyCertStr.getBytes());\n-                Certificate keyCert = null;\n-                try {\n-                    keyCert = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n-\n+                Certificate keyCert  = pemDecoder.decode(keyCertStr, X509Certificate.class);\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloInterOp.java","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @key headful\n@@ -28,0 +27,1 @@\n+ * @key headful\n@@ -29,1 +29,3 @@\n- * @author Oleg Mokhovikov\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException\n+ * @run main Test4234761\n@@ -38,0 +40,3 @@\n+import javax.swing.UIManager;\n+\n+import jtreg.SkippedException;\n@@ -43,0 +48,3 @@\n+        if (UIManager.getLookAndFeel().getName().contains(\"GTK\")) {\n+            throw new SkippedException(\"Test skipped for GTK\");\n+        }\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test4234761.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                    frame = new JFrame();\n+                    frame = new JFrame(\"JSpinnerButtonFocusTest\");\n@@ -75,0 +75,9 @@\n+                    editor1.getTextField().addFocusListener(new FocusAdapter() {\n+                        @Override\n+                        public void focusGained(FocusEvent e) {\n+                            super.focusGained(e);\n+                            robot.keyPress(KeyEvent.VK_TAB);\n+                            robot.keyRelease(KeyEvent.VK_TAB);\n+                            latch1.countDown();\n+                        }\n+                    });\n@@ -87,1 +96,2 @@\n-                    frame.pack();\n+                    frame.setSize(100, 100);\n+                    frame.setLocationRelativeTo(null);\n@@ -91,10 +101,1 @@\n-\n-                editor1.getTextField().addFocusListener(new FocusAdapter() {\n-                    @Override\n-                    public void focusGained(FocusEvent e) {\n-                        super.focusGained(e);\n-                        robot.keyPress(KeyEvent.VK_TAB);\n-                        robot.keyRelease(KeyEvent.VK_TAB);\n-                        latch1.countDown();\n-                    }\n-                });\n+                robot.delay(1000);\n@@ -106,1 +107,1 @@\n-                if (!latch1.await(15, TimeUnit.MINUTES)) {\n+                if (!latch1.await(1, TimeUnit.MINUTES)) {\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/8223788\/JSpinnerButtonFocusTest.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -29,4 +30,0 @@\n- * @author Oleg Mokhovikov\n- * @library \/test\/lib\n- * @library ..\/..\/regtesthelpers\n- * @build Util jdk.test.lib.Platform\n@@ -35,4 +32,3 @@\n-import javax.swing.*;\n-import javax.swing.event.ChangeEvent;\n-import javax.swing.event.ChangeListener;\n-import java.awt.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Robot;\n@@ -43,1 +39,7 @@\n-import jdk.test.lib.Platform;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JTabbedPane;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n@@ -46,1 +48,0 @@\n-\n@@ -74,7 +75,1 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-\n-                public void run() {\n-                    createAndShowGUI();\n-                }\n-            });\n-\n+            SwingUtilities.invokeAndWait(() -> createAndShowGUI());\n@@ -82,8 +77,1 @@\n-\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-\n-                public void run() {\n-                    txtField.requestFocus();\n-                }\n-            });\n-\n+            SwingUtilities.invokeAndWait(() -> txtField.requestFocus());\n@@ -96,6 +84,3 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-\n-                public void run() {\n-                    tab.addChangeListener((ChangeListener) listener);\n-                    txtField.removeFocusListener((FocusListener) listener);\n-                }\n+            SwingUtilities.invokeAndWait(() -> {\n+                tab.addChangeListener((ChangeListener) listener);\n+                txtField.removeFocusListener((FocusListener) listener);\n@@ -106,5 +91,4 @@\n-            if (Platform.isOSX()) {\n-                Util.hitKeys(robot, KeyEvent.VK_CONTROL, KeyEvent.VK_ALT, KeyEvent.VK_B);\n-            } else {\n-                Util.hitKeys(robot, KeyEvent.VK_ALT, KeyEvent.VK_B);\n-            }\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_B);\n+            robot.keyRelease(KeyEvent.VK_B);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n@@ -115,1 +99,2 @@\n-                throw new RuntimeException(\"JTabbedPane mnemonics don't work from outside the tabbed pane\");\n+                throw new RuntimeException(\"JTabbedPane mnemonics don't \" +\n+                        \"work from outside the tabbed pane\");\n@@ -118,1 +103,5 @@\n-            if (frame != null) SwingUtilities.invokeAndWait(() ->  frame.dispose());\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/4624207\/bug4624207.java","additions":28,"deletions":39,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.internal.jimage.ImageLocation;\n+import jdk.internal.jimage.ModuleReference;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ImageLocation.\n+ * @modules java.base\/jdk.internal.jimage\n+ * @run junit\/othervm -esa -DDISABLE_PREVIEW_PATCHING=false ImageLocationTest\n+ *\/\n+public class ImageLocationTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\/modfoo\/com\",\n+            \"\/modules\/modfoo\/com\/foo\/Foo.class\"})\n+    public void getFlags_resourceNames(String name) {\n+        String previewName = previewName(name);\n+\n+        int noPreviewFlags =\n+                ImageLocation.getFlags(name, Set.of(name)::contains);\n+        assertEquals(0, noPreviewFlags);\n+        assertFalse(ImageLocation.hasPreviewVersion(noPreviewFlags));\n+        assertFalse(ImageLocation.isPreviewOnly(noPreviewFlags));\n+\n+        int withPreviewFlags =\n+                ImageLocation.getFlags(name, Set.of(name, previewName)::contains);\n+        assertTrue(ImageLocation.hasPreviewVersion(withPreviewFlags));\n+        assertFalse(ImageLocation.isPreviewOnly(withPreviewFlags));\n+\n+        int previewOnlyFlags = ImageLocation.getFlags(previewName, Set.of(previewName)::contains);\n+        assertFalse(ImageLocation.hasPreviewVersion(previewOnlyFlags));\n+        assertTrue(ImageLocation.isPreviewOnly(previewOnlyFlags));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\",\n+            \"\/packages\",\n+            \"\/modules\/modfoo\",\n+            \"\/modules\/modfoo\/META-INF\",\n+            \"\/modules\/modfoo\/META-INF\/module-info.class\"})\n+    public void getFlags_zero(String name) {\n+        assertEquals(0, ImageLocation.getFlags(name, Set.of(name)::contains));\n+    }\n+\n+    @Test\n+    public void getFlags_packageFlags() {\n+        assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ImageLocation.getFlags(\"\/packages\/pkgname\", p -> true));\n+    }\n+\n+    @Test\n+    public void getPackageFlags_noPreview() {\n+        List<ModuleReference> refs = List.of(\n+                ModuleReference.forPackage(\"modfoo\", false),\n+                ModuleReference.forEmptyPackage(\"modbar\", false),\n+                ModuleReference.forEmptyPackage(\"modbaz\", false));\n+        int noPreviewFlags = ImageLocation.getPackageFlags(refs);\n+        assertEquals(0, noPreviewFlags);\n+        assertFalse(ImageLocation.hasPreviewVersion(noPreviewFlags));\n+        assertFalse(ImageLocation.isPreviewOnly(noPreviewFlags));\n+    }\n+\n+    @Test\n+    public void getPackageFlags_withPreview() {\n+        List<ModuleReference> refs = List.of(\n+                ModuleReference.forPackage(\"modfoo\", true),\n+                ModuleReference.forEmptyPackage(\"modbar\", false),\n+                ModuleReference.forEmptyPackage(\"modbaz\", true));\n+        int withPreviewFlags = ImageLocation.getPackageFlags(refs);\n+        assertTrue(ImageLocation.hasPreviewVersion(withPreviewFlags));\n+        assertFalse(ImageLocation.isPreviewOnly(withPreviewFlags));\n+    }\n+\n+    @Test\n+    public void getPackageFlags_previewOnly() {\n+        List<ModuleReference> refs = List.of(\n+                ModuleReference.forPackage(\"modfoo\", true),\n+                ModuleReference.forEmptyPackage(\"modbar\", true),\n+                ModuleReference.forEmptyPackage(\"modbaz\", true));\n+        int previewOnlyFlags = ImageLocation.getPackageFlags(refs);\n+        \/\/ Note the asymmetry between this and the getFlags() case. Unlike\n+        \/\/ module resources, there is no concept of a separate package directory\n+        \/\/ existing in the preview namespace, so a single entry serves both\n+        \/\/ purposes, and hasPreviewVersion() and isPreviewOnly() can both be set.\n+        assertTrue(ImageLocation.hasPreviewVersion(previewOnlyFlags));\n+        assertTrue(ImageLocation.isPreviewOnly(previewOnlyFlags));\n+    }\n+\n+    private static final Pattern MODULES_PATH = Pattern.compile(\"\/modules\/([^\/]+)\/(.+)\");\n+\n+    private static String previewName(String name) {\n+        var m = MODULES_PATH.matcher(name);\n+        if (m.matches() && !m.group(2).startsWith(\"\/META-INF\/preview\/\")) {\n+            return \"\/modules\/\" + m.group(1) + \"\/META-INF\/preview\/\" + m.group(2);\n+        }\n+        throw new IllegalStateException(\"Invalid modules name: \" + name);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageLocationTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -46,0 +47,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -66,1 +68,1 @@\n- * @run junit\/othervm ImageReaderTest\n+ * @run junit\/othervm -esa -DDISABLE_PREVIEW_PATCHING=false ImageReaderTest\n@@ -73,1 +75,2 @@\n-\n+    \/\/ The '@' prefix marks the entry as a preview entry which will be placed in\n+    \/\/ the '\/modules\/<module>\/META-INF\/preview\/...' namespace.\n@@ -76,3 +79,7 @@\n-                    \"com.foo.Alpha\",\n-                    \"com.foo.Beta\",\n-                    \"com.foo.bar.Gamma\"),\n+                    \"com.foo.HasPreviewVersion\",\n+                    \"com.foo.NormalFoo\",\n+                    \"com.foo.bar.NormalBar\",\n+                    \/\/ Replaces original class in preview mode.\n+                    \"@com.foo.HasPreviewVersion\",\n+                    \/\/ New class in existing package in preview mode.\n+                    \"@com.foo.bar.IsPreviewOnly\"),\n@@ -81,1 +88,7 @@\n-                    \"com.bar.Two\"));\n+                    \"com.bar.Two\",\n+                    \/\/ Two new packages in preview mode (new symbolic links).\n+                    \"@com.bar.preview.stuff.Foo\",\n+                    \"@com.bar.preview.stuff.Bar\"),\n+            \"modgus\", Arrays.asList(\n+                    \/\/ A second module with a preview-only empty package (preview).\n+                    \"@com.bar.preview.other.Gus\"));\n@@ -94,1 +107,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -109,1 +122,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -116,2 +129,2 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n-            assertNode(reader, \"\/modules\/modfoo\/com\/foo\/Alpha.class\");\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n+            assertNode(reader, \"\/modules\/modfoo\/com\/foo\/HasPreviewVersion.class\");\n@@ -121,3 +134,3 @@\n-            assertEquals(\"Class: com.foo.Alpha\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Alpha\"));\n-            assertEquals(\"Class: com.foo.Beta\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Beta\"));\n-            assertEquals(\"Class: com.foo.bar.Gamma\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.Gamma\"));\n+            assertEquals(\"Class: com.foo.HasPreviewVersion\", loader.loadAndGetToString(\"modfoo\", \"com.foo.HasPreviewVersion\"));\n+            assertEquals(\"Class: com.foo.NormalFoo\", loader.loadAndGetToString(\"modfoo\", \"com.foo.NormalFoo\"));\n+            assertEquals(\"Class: com.foo.bar.NormalBar\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.NormalBar\"));\n@@ -130,1 +143,1 @@\n-            \"modfoo:com\/foo\/Alpha.class\",\n+            \"modfoo:com\/foo\/HasPreviewVersion.class\",\n@@ -134,1 +147,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -150,1 +163,1 @@\n-            \"modbar:com\/foo\/Alpha.class\",\n+            \"modbar:com\/foo\/HasPreviewVersion.class\",\n@@ -155,1 +168,1 @@\n-            \"modules:modfoo\/com\/foo\/Alpha.class\",\n+            \"modules:modfoo\/com\/foo\/HasPreviewVersion.class\",\n@@ -158,1 +171,1 @@\n-            \"'':modfoo\/com\/foo\/Alpha.class\",\n+            \"'':modfoo\/com\/foo\/HasPreviewVersion.class\",\n@@ -161,1 +174,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -178,1 +191,1 @@\n-            \"modules\/modfoo\/com:foo\/Alpha.class\",\n+            \"modules\/modfoo\/com:foo\/HasPreviewVersion.class\",\n@@ -181,1 +194,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -189,1 +202,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -191,1 +204,1 @@\n-            Set<String> pkgNames = root.getChildNames().collect(Collectors.toSet());\n+            Set<String> pkgNames = root.getChildNames().collect(toSet());\n@@ -206,1 +219,1 @@\n-        try (ImageReader reader = ImageReader.open(image)) {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n@@ -214,0 +227,117 @@\n+    @Test\n+    public void testPreviewResources_disabled() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+\n+            \/\/ No preview classes visible.\n+            assertEquals(\"Class: com.foo.HasPreviewVersion\", loader.loadAndGetToString(\"modfoo\", \"com.foo.HasPreviewVersion\"));\n+            assertEquals(\"Class: com.foo.NormalFoo\", loader.loadAndGetToString(\"modfoo\", \"com.foo.NormalFoo\"));\n+            assertEquals(\"Class: com.foo.bar.NormalBar\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.NormalBar\"));\n+\n+            \/\/ NormalBar exists but IsPreviewOnly doesn't.\n+            assertResource(reader, \"modfoo\", \"com\/foo\/bar\/NormalBar.class\");\n+            assertAbsent(reader, \"\/modules\/modfoo\/com\/foo\/bar\/IsPreviewOnly.class\");\n+            assertDirContents(reader, \"\/modules\/modfoo\/com\/foo\", \"HasPreviewVersion.class\", \"NormalFoo.class\", \"bar\");\n+            assertDirContents(reader, \"\/modules\/modfoo\/com\/foo\/bar\", \"NormalBar.class\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewResources_enabled() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.ENABLED)) {\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+\n+            \/\/ Preview version of classes either overwrite existing entries or are added to directories.\n+            assertEquals(\"Preview: com.foo.HasPreviewVersion\", loader.loadAndGetToString(\"modfoo\", \"com.foo.HasPreviewVersion\"));\n+            assertEquals(\"Class: com.foo.NormalFoo\", loader.loadAndGetToString(\"modfoo\", \"com.foo.NormalFoo\"));\n+            assertEquals(\"Class: com.foo.bar.NormalBar\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.NormalBar\"));\n+            assertEquals(\"Preview: com.foo.bar.IsPreviewOnly\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.IsPreviewOnly\"));\n+\n+            \/\/ Both NormalBar and IsPreviewOnly exist (direct lookup and as child nodes).\n+            assertResource(reader, \"modfoo\", \"com\/foo\/bar\/NormalBar.class\");\n+            assertResource(reader, \"modfoo\", \"com\/foo\/bar\/IsPreviewOnly.class\");\n+            assertDirContents(reader, \"\/modules\/modfoo\/com\/foo\", \"HasPreviewVersion.class\", \"NormalFoo.class\", \"bar\");\n+            assertDirContents(reader, \"\/modules\/modfoo\/com\/foo\/bar\", \"NormalBar.class\", \"IsPreviewOnly.class\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewOnlyPackages_disabled() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+\n+            \/\/ No 'preview' package or anything inside it.\n+            assertDirContents(reader, \"\/modules\/modbar\/com\/bar\", \"One.class\", \"Two.class\");\n+            assertAbsent(reader, \"\/modules\/modbar\/com\/bar\/preview\");\n+            assertAbsent(reader, \"\/modules\/modbar\/com\/bar\/preview\/stuff\/Foo.class\");\n+\n+            \/\/ And no package link.\n+            assertAbsent(reader, \"\/packages\/com.bar.preview\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewOnlyPackages_enabled() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.ENABLED)) {\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+\n+            \/\/ In preview mode 'preview' package exists with preview only content.\n+            assertDirContents(reader, \"\/modules\/modbar\/com\/bar\", \"One.class\", \"Two.class\", \"preview\");\n+            assertDirContents(reader, \"\/modules\/modbar\/com\/bar\/preview\/stuff\", \"Foo.class\", \"Bar.class\");\n+            assertResource(reader, \"modbar\", \"com\/bar\/preview\/stuff\/Foo.class\");\n+\n+            \/\/ And package links exists.\n+            assertDirContents(reader, \"\/packages\/com.bar.preview\", \"modbar\", \"modgus\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewModeLinks_disabled() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.DISABLED)) {\n+            assertDirContents(reader, \"\/packages\/com.bar\", \"modbar\");\n+            \/\/ Missing symbolic link and directory when not in preview mode.\n+            assertAbsent(reader, \"\/packages\/com.bar.preview\");\n+            assertAbsent(reader, \"\/packages\/com.bar.preview.stuff\");\n+            assertAbsent(reader, \"\/modules\/modbar\/com\/bar\/preview\");\n+            assertAbsent(reader, \"\/modules\/modbar\/com\/bar\/preview\/stuff\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewModeLinks_enabled() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image, PreviewMode.ENABLED)) {\n+            \/\/ In preview mode there is a new preview-only module visible.\n+            assertDirContents(reader, \"\/packages\/com.bar\", \"modbar\", \"modgus\");\n+            \/\/ And additional packages are present.\n+            assertDirContents(reader, \"\/packages\/com.bar.preview\", \"modbar\", \"modgus\");\n+            assertDirContents(reader, \"\/packages\/com.bar.preview.stuff\", \"modbar\");\n+            assertDirContents(reader, \"\/packages\/com.bar.preview.other\", \"modgus\");\n+            \/\/ And the preview-only content appears as we expect.\n+            assertDirContents(reader, \"\/modules\/modbar\/com\/bar\", \"One.class\", \"Two.class\", \"preview\");\n+            assertDirContents(reader, \"\/modules\/modbar\/com\/bar\/preview\", \"stuff\");\n+            assertDirContents(reader, \"\/modules\/modbar\/com\/bar\/preview\/stuff\", \"Foo.class\", \"Bar.class\");\n+            \/\/ In both modules in which it was added.\n+            assertDirContents(reader, \"\/modules\/modgus\/com\/bar\", \"preview\");\n+            assertDirContents(reader, \"\/modules\/modgus\/com\/bar\/preview\", \"other\");\n+            assertDirContents(reader, \"\/modules\/modgus\/com\/bar\/preview\/other\", \"Gus.class\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void testPreviewEntriesAlwaysHidden(boolean previewMode) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image, previewMode ? PreviewMode.ENABLED : PreviewMode.DISABLED)) {\n+            \/\/ The META-INF directory exists, but does not contain the preview directory.\n+            Node dir = assertDir(reader, \"\/modules\/modfoo\/META-INF\");\n+            assertEquals(0, dir.getChildNames().filter(n -> n.endsWith(\"\/preview\")).count());\n+            \/\/ Neither the preview directory, nor anything in it, can be looked-up directly.\n+            assertAbsent(reader, \"\/modules\/modfoo\/META-INF\/preview\");\n+            assertAbsent(reader, \"\/modules\/modfoo\/META-INF\/preview\/com\/foo\");\n+            \/\/ HasPreviewVersion.class is a preview class in the test data, and thus appears in\n+            \/\/ two places in the jimage). Ensure the preview version is always hidden.\n+            String alphaPath = \"com\/foo\/HasPreviewVersion.class\";\n+            assertNode(reader, \"\/modules\/modfoo\/\" + alphaPath);\n+            assertAbsent(reader, \"\/modules\/modfoo\/META-INF\/preview\/\" + alphaPath);\n+        }\n+    }\n+\n@@ -226,0 +356,21 @@\n+    private static void assertDirContents(ImageReader reader, String name, String... expectedChildNames) throws IOException {\n+        Node dir = assertDir(reader, name);\n+        Set<String> localChildNames = dir.getChildNames()\n+                .peek(s -> assertTrue(s.startsWith(name + \"\/\")))\n+                .map(s -> s.substring(name.length() + 1))\n+                .collect(toSet());\n+        assertEquals(\n+                Set.of(expectedChildNames),\n+                localChildNames,\n+                String.format(\"Unexpected child names in directory '%s'\", name));\n+    }\n+\n+    private static void assertResource(ImageReader reader, String modName, String resPath) throws IOException {\n+        assertTrue(reader.containsResource(modName, resPath), \"Resource should exist: \" + modName + \"\/\" + resPath);\n+        Node resNode = reader.findResourceNode(modName, resPath);\n+        assertTrue(resNode.isResource(), \"Node should be a resource: \" + resNode.getName());\n+        String nodeName = \"\/modules\/\" + modName + \"\/\" + resPath;\n+        assertEquals(nodeName, resNode.getName());\n+        assertSame(resNode, reader.findNode(nodeName));\n+    }\n+\n@@ -228,1 +379,1 @@\n-        assertTrue(link.isLink(), \"Node was not a symbolic link: \" + name);\n+        assertTrue(link.isLink(), \"Node should be a symbolic link: \" + link.getName());\n@@ -253,0 +404,4 @@\n+                boolean isPreviewEntry = fqn.startsWith(\"@\");\n+                if (isPreviewEntry) {\n+                    fqn = fqn.substring(1);\n+                }\n@@ -256,2 +411,0 @@\n-\n-                String path = fqn.replace('.', '\/') + \".class\";\n@@ -263,1 +416,1 @@\n-                                return \"Class: %s\";\n+                                return \"%s: %s\";\n@@ -266,1 +419,2 @@\n-                        \"\"\", pkg, cls, fqn);\n+                        \"\"\", pkg, cls, isPreviewEntry ? \"Preview\" : \"Class\", fqn);\n+                String path = (isPreviewEntry ? \"META-INF\/preview\/\" : \"\") + fqn.replace('.', '\/') + \".class\";\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":183,"deletions":29,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -61,1 +62,1 @@\n-    @DataProvider(name=\"classes\")\n+    @DataProvider(name = \"classes\")\n@@ -63,1 +64,1 @@\n-        return new Object[][] {\n+        return new Object[][]{\n@@ -81,1 +82,1 @@\n-    @Test(dataProvider=\"classes\")\n+    @Test(dataProvider = \"classes\")\n@@ -106,2 +107,2 @@\n-                    + moduleName\n-                    + \", or class: \" + className);\n+                            + moduleName\n+                            + \", or class: \" + className);\n@@ -233,1 +234,1 @@\n-            System.arraycopy(nativeNames,0, combined, names.length, nativeNames.length);\n+            System.arraycopy(nativeNames, 0, combined, names.length, nativeNames.length);\n@@ -340,1 +341,1 @@\n-        try (ImageReader nativeReader = ImageReader.open(imageFile)) {\n+        try (ImageReader nativeReader = ImageReader.open(imageFile, PreviewMode.DISABLED)) {\n@@ -343,1 +344,1 @@\n-        } catch (IOException expected) {\n+        } catch (IOException unexpected) {\n@@ -349,1 +350,1 @@\n-        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder));\n+        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder, PreviewMode.DISABLED));\n@@ -357,1 +358,1 @@\n-        Class<?>[] testclass = { JImageReadTest.class};\n+        Class<?>[] testclass = {JImageReadTest.class};\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ModuleReference;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.nio.IntBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static jdk.internal.jimage.ModuleReference.forEmptyPackageIn;\n+import static jdk.internal.jimage.ModuleReference.forPackageIn;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ModuleReference.\n+ * @modules java.base\/jdk.internal.jimage\n+ * @run junit\/othervm -esa ModuleReferenceTest\n+ *\/\n+public final class ModuleReferenceTest {\n+    \/\/ Copied (not referenced) for testing.\n+    private static final int FLAGS_HAS_PREVIEW_VERSION = 0x1;\n+    private static final int FLAGS_HAS_NORMAL_VERSION = 0x2;\n+    private static final int FLAGS_HAS_CONTENT = 0x4;\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void emptyRefs(boolean isPreview) {\n+        ModuleReference ref = forEmptyPackageIn(\"module\", isPreview);\n+\n+        assertEquals(\"module\", ref.name());\n+        assertFalse(ref.hasResources());\n+        assertEquals(isPreview, ref.hasPreviewVersion());\n+        assertEquals(isPreview, ref.isPreviewOnly());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void resourceRefs(boolean isPreview) {\n+        ModuleReference ref = forPackageIn(\"module\", isPreview);\n+\n+        assertEquals(\"module\", ref.name());\n+        assertTrue(ref.hasResources());\n+        assertEquals(isPreview, ref.hasPreviewVersion());\n+        assertEquals(isPreview, ref.isPreviewOnly());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {false, true})\n+    public void mergedRefs(boolean isPreview) {\n+        ModuleReference emptyRef = forEmptyPackageIn(\"module\", true);\n+        ModuleReference resourceRef = forPackageIn(\"module\", isPreview);\n+        ModuleReference merged = emptyRef.merge(resourceRef);\n+\n+        \/\/ Merging preserves whether there's content.\n+        assertTrue(merged.hasResources());\n+        \/\/ And clears the preview-only status unless it was set in both.\n+        assertEquals(isPreview, merged.isPreviewOnly());\n+    }\n+\n+    @Test\n+    public void writeBuffer() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackageIn(\"alpha\", true),\n+                forEmptyPackageIn(\"beta\", false).merge(forEmptyPackageIn(\"beta\", true)),\n+                forPackageIn(\"gamma\", false),\n+                forEmptyPackageIn(\"zeta\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        ModuleReference.write(refs, buffer, fakeEncoder());\n+        assertArrayEquals(\n+                new int[]{\n+                        FLAGS_HAS_PREVIEW_VERSION, 100,\n+                        FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION, 101,\n+                        FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_CONTENT, 102,\n+                        FLAGS_HAS_NORMAL_VERSION, 103},\n+                buffer.array());\n+    }\n+\n+    @Test\n+    public void writeBuffer_emptyList() {\n+        IntBuffer buffer = IntBuffer.allocate(0);\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(List.of(), buffer, null));\n+        assertTrue(err.getMessage().contains(\"non-empty\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_badCapacity() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forPackageIn(\"first\", false),\n+                forEmptyPackageIn(\"alpha\", false));\n+        IntBuffer buffer = IntBuffer.allocate(10);\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"buffer capacity\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_multiplePackagesWithResources() {\n+        \/\/ Only one module reference (at most) can have resources.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forPackageIn(\"alpha\", false),\n+                forPackageIn(\"beta\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"resources\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_badOrdering() {\n+        \/\/ Badly ordered because preview references should come first.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackageIn(\"alpha\", false),\n+                forEmptyPackageIn(\"beta\", true));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"strictly ordered\"));\n+    }\n+\n+    @Test\n+    public void writeBuffer_duplicateRef() {\n+        \/\/ Technically distinct, and correctly sorted, but with duplicate names.\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackageIn(\"duplicate\", true),\n+                forEmptyPackageIn(\"duplicate\", false));\n+        IntBuffer buffer = IntBuffer.allocate(2 * refs.size());\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.write(refs, buffer, null));\n+        assertTrue(err.getMessage().contains(\"unique\"));\n+    }\n+\n+    @Test\n+    public void readNameOffsets() {\n+        \/\/ Preview versions must be first (important for early exit).\n+        IntBuffer buffer = IntBuffer.wrap(new int[]{\n+                FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_PREVIEW_VERSION, 100,\n+                FLAGS_HAS_PREVIEW_VERSION, 101,\n+                FLAGS_HAS_NORMAL_VERSION | FLAGS_HAS_CONTENT, 102,\n+                FLAGS_HAS_NORMAL_VERSION, 103});\n+\n+        List<Integer> normalOffsets = asList(ModuleReference.readNameOffsets(buffer, true, false));\n+        List<Integer> previewOffsets = asList(ModuleReference.readNameOffsets(buffer, false, true));\n+        List<Integer> allOffsets = asList(ModuleReference.readNameOffsets(buffer, true, true));\n+\n+        assertEquals(List.of(100, 102, 103), normalOffsets);\n+        assertEquals(List.of(100, 101), previewOffsets);\n+        assertEquals(List.of(100, 101, 102, 103), allOffsets);\n+    }\n+\n+    @Test\n+    public void readNameOffsets_badBufferSize() {\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.readNameOffsets(IntBuffer.allocate(3), true, false));\n+        assertTrue(err.getMessage().contains(\"buffer size\"));\n+    }\n+\n+    @Test\n+    public void readNameOffsets_badFlags() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[]{FLAGS_HAS_CONTENT, 100});\n+        var err = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> ModuleReference.readNameOffsets(buffer, false, false));\n+        assertTrue(err.getMessage().contains(\"flags\"));\n+    }\n+\n+    @Test\n+    public void sortOrder_previewFirst() {\n+        List<ModuleReference> refs = Arrays.asList(\n+                forEmptyPackageIn(\"normal.beta\", false),\n+                forPackageIn(\"preview.beta\", true),\n+                forEmptyPackageIn(\"preview.alpha\", true),\n+                forEmptyPackageIn(\"normal.alpha\", false));\n+        refs.sort(Comparator.naturalOrder());\n+        \/\/ Non-empty first with remaining sorted by name.\n+        assertEquals(\n+                List.of(\"preview.alpha\", \"preview.beta\", \"normal.alpha\", \"normal.beta\"),\n+                refs.stream().map(ModuleReference::name).toList());\n+    }\n+\n+    private static <T> List<T> asList(Iterator<T> src) {\n+        List<T> list = new ArrayList<>();\n+        src.forEachRemaining(list::add);\n+        return list;\n+    }\n+\n+    \/\/ Encodes strings sequentially starting from index 100.\n+    private static Function<String, Integer> fakeEncoder() {\n+        List<String> cache = new ArrayList<>();\n+        return s -> {\n+            int i = cache.indexOf(s);\n+            if (i == -1) {\n+                cache.add(s);\n+                return 100 + (cache.size() - 1);\n+            } else {\n+                return 100 + i;\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ModuleReferenceTest.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.reflect.Constructor;\n@@ -28,1 +27,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -40,0 +38,2 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n+\n@@ -49,0 +49,1 @@\n+ * @library \/test\/lib\n@@ -142,1 +143,1 @@\n-            ThreadFactory factory = virtualThreadBuilder(pool)\n+            ThreadFactory factory = VThreadScheduler.virtualThreadBuilder(pool)\n@@ -205,20 +206,0 @@\n-\n-    \/**\n-     * Returns a builder to create virtual threads that use the given scheduler.\n-     *\/\n-    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n-        try {\n-            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-            ctor.setAccessible(true);\n-            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (cause instanceof RuntimeException re) {\n-                throw re;\n-            }\n-            throw new RuntimeException(e);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-            System.out.println(\"No swap memory limits, test case skipped\");\n+            System.out.println(\"No swap memory limits. Ignoring test!\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jtreg.SkippedException;\n@@ -115,1 +116,5 @@\n-        \/\/ 'java -Xms{mem-limit} -Xmx{mem-limit} -version' would fail due to swap space size being 0.\n+        \/\/ 'java -Xms{mem-limit} -Xmx{mem-limit} -XX:+AlwaysPreTouch -version'\n+        \/\/ would fail due to swap space size being 0. Note that when swap is\n+        \/\/ properly enabled on the system the container gets the same amount\n+        \/\/ of swap as is configured for memory. Thus, 2x{mem-limit} is the actual\n+        \/\/ memory and swap bound for this pre-test.\n@@ -120,0 +125,1 @@\n+                .addJavaOpts(\"-XX:+AlwaysPreTouch\")\n@@ -125,2 +131,1 @@\n-            System.out.println(\"Swapping doesn't work for this test.\");\n-            return;\n+            throw new SkippedException(\"Swapping doesn't work for this test.\");\n@@ -140,2 +145,1 @@\n-            System.out.println(\"Ignored by the tester\");\n-            return;\n+            throw new SkippedException(\"Ignored by the tester\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Scoped.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,601 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.CubicCurve2D;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Handler;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Timer;\n+\n+import static java.lang.System.out;\n+\n+\/**\n+ * @test\n+ * @bug 8341381\n+ * @summary fix cubic offsetting issue (numerical accuracy)\n+ * @run main\/othervm\/timeout=20 Bug8341381\n+ * @modules java.desktop\/sun.java2d.marlin\n+ *\/\n+public final class Bug8341381 {\n+\n+    static final boolean SHOW_GUI = false;\n+\n+    static final boolean CHECK_PIXELS = true;\n+    static final boolean TRACE_ALL = false;\n+    static final boolean TRACE_CHECK_PIXELS = false;\n+\n+    static final boolean SAVE_IMAGE = false;\n+\n+    static final boolean INTENSIVE = false;\n+\n+    static final double DPI = 96;\n+    static final float STROKE_WIDTH = 15f;\n+\n+    \/\/ delay is 1 frame at 60hz\n+    static final int DELAY = 16;\n+    \/\/ off-screen test step (1.0 by default)\n+    static final double STEP = (INTENSIVE) ? 1.0 \/ 117 : 1.0;\n+\n+    \/\/ stats:\n+    static int N_TEST = 0;\n+    static int N_FAIL = 0;\n+\n+    static final AtomicBoolean isMarlin = new AtomicBoolean();\n+    static final CountDownLatch latch = new CountDownLatch(1);\n+\n+    public static void main(final String[] args) {\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ FIRST: Get Marlin runtime state from its log:\n+\n+        \/\/ initialize j.u.l Logger:\n+        final Logger log = Logger.getLogger(\"sun.java2d.marlin\");\n+        log.addHandler(new Handler() {\n+            @Override\n+            public void publish(LogRecord record) {\n+                final String msg = record.getMessage();\n+                if (msg != null) {\n+                    \/\/ last space to avoid matching other settings:\n+                    if (msg.startsWith(\"sun.java2d.renderer \")) {\n+                        isMarlin.set(msg.contains(\"DMarlinRenderingEngine\"));\n+                    }\n+                }\n+\n+                final Throwable th = record.getThrown();\n+                \/\/ detect any Throwable:\n+                if (th != null) {\n+                    out.println(\"Test failed:\\n\" + record.getMessage());\n+                    th.printStackTrace(out);\n+                    throw new RuntimeException(\"Test failed: \", th);\n+                }\n+            }\n+\n+            @Override\n+            public void flush() {\n+            }\n+\n+            @Override\n+            public void close() throws SecurityException {\n+            }\n+        });\n+\n+        out.println(\"Bug8341381: start\");\n+        final long startTime = System.currentTimeMillis();\n+\n+        \/\/ enable Marlin logging & internal checks:\n+        System.setProperty(\"sun.java2d.renderer.log\", \"true\");\n+        System.setProperty(\"sun.java2d.renderer.useLogger\", \"true\");\n+\n+        try {\n+            startTest();\n+\n+            out.println(\"WAITING ...\");\n+            latch.await(15, TimeUnit.SECONDS); \/\/ 2s typically\n+\n+            if (isMarlin.get()) {\n+                out.println(\"Marlin renderer used at runtime.\");\n+            } else {\n+                throw new RuntimeException(\"Marlin renderer NOT used at runtime !\");\n+            }\n+\n+            \/\/ show test report:\n+            out.println(\"TESTS: \" + N_TEST + \" FAILS: \" + N_FAIL);\n+\n+            if (N_FAIL > 0) {\n+                throw new RuntimeException(\"Bug8341381: \" + N_FAIL + \" \/ \" + N_TEST + \" test(s) failed !\");\n+            }\n+\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } catch (InvocationTargetException ite) {\n+            throw new RuntimeException(ite);\n+        } finally {\n+            final double elapsed = (System.currentTimeMillis() - startTime) \/ 1000.0;\n+            out.println(\"Bug8341381: end (\" + elapsed + \" s)\");\n+        }\n+    }\n+\n+    private static void startTest() throws InterruptedException, InvocationTargetException {\n+        if (SHOW_GUI) {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    final JFrame viewer = new JFrame();\n+                    viewer.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+                    viewer.setContentPane(new CanvasPanel(viewer));\n+                    viewer.pack();\n+                    viewer.setVisible(true);\n+                }\n+            });\n+            return;\n+        } else {\n+            out.println(\"STEP: \" + STEP);\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    final Context ctx = new Context();\n+                    final Dimension initialDim = ctx.bugDisplay.getSize(DPI);\n+\n+                    double w = initialDim.width;\n+                    double h = initialDim.height;\n+                    do {\n+                        ctx.shouldScale(w, h);\n+                        ctx.paintImage();\n+\n+                        \/\/ resize component:\n+                        w -= STEP;\n+                        h -= STEP;\n+\n+                    } while (ctx.iterate());\n+                }\n+            }).start();\n+        }\n+    }\n+\n+    static final class Context {\n+\n+        final BugDisplay bugDisplay = new BugDisplay();\n+        double width = 0.0, height = 0.0;\n+\n+        BufferedImage bimg = null;\n+\n+        boolean shouldScale(final double w, final double h) {\n+            if ((w != width) || (h != height) || !bugDisplay.isScaled) {\n+                width = w;\n+                height = h;\n+                bugDisplay.scale(width, height);\n+                N_TEST++;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        void paintImage() {\n+            final int w = bugDisplay.canvasWidth;\n+            final int h = bugDisplay.canvasHeight;\n+\n+            if ((bimg == null) || (w > bimg.getWidth()) || (h > bimg.getHeight())) {\n+                bimg = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);\n+            }\n+            final Graphics gi = bimg.getGraphics();\n+            try {\n+                bugDisplay.paint(gi);\n+            } finally {\n+                gi.dispose();\n+            }\n+            if (!bugDisplay.checkImage(bimg)) {\n+                N_FAIL++;\n+            }\n+        }\n+\n+        boolean iterate() {\n+            if ((bugDisplay.canvasWidth > 10) || (bugDisplay.canvasHeight > 10)) {\n+                \/\/ continue:\n+                return true;\n+            }\n+            out.println(\"Stop\");\n+            latch.countDown();\n+            return false;\n+        }\n+    }\n+\n+    static final class CanvasPanel extends JPanel {\n+        private static final long serialVersionUID = 1L;\n+\n+        private final Context ctx = new Context();\n+        private boolean resized = false;\n+        private Timer timer = null;\n+\n+        public CanvasPanel(final JFrame frame) {\n+            timer = new Timer(DELAY, e -> {\n+                if (resized) {\n+                    resized = false;\n+\n+                    if (ctx.iterate()) {\n+                        \/\/ resize component:\n+                        setSize((int) Math.round(ctx.width - 1), (int) Math.round(ctx.height - 1));\n+                    } else {\n+                        timer.stop();\n+                        if (frame != null) {\n+                            frame.setVisible(false);\n+                        }\n+                    }\n+                }\n+            });\n+            timer.setCoalesce(true);\n+            timer.setRepeats(true);\n+            timer.start();\n+        }\n+\n+        @Override\n+        public void paint(final Graphics g) {\n+            final Dimension dim = getSize();\n+            if (ctx.shouldScale(dim.width, dim.height)) {\n+                this.resized = true;\n+            }\n+            super.paint(g);\n+\n+            \/\/ paint on buffered image:\n+            if (CHECK_PIXELS) {\n+                final int w = ctx.bugDisplay.canvasWidth;\n+                final int h = ctx.bugDisplay.canvasHeight;\n+                if (this.resized) {\n+                    ctx.paintImage();\n+                }\n+                g.drawImage(ctx.bimg.getSubimage(0, 0, w, h), 0, 0, null);\n+            } else {\n+                ctx.bugDisplay.paint(g);\n+            }\n+        }\n+\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return ctx.bugDisplay.getSize(DPI);\n+        }\n+    }\n+\n+    static final class BugDisplay {\n+\n+        boolean isScaled = false;\n+        int canvasWidth;\n+        int canvasHeight;\n+\n+        private final static java.util.List<CubicCurve2D> curves1 = Arrays.asList(\n+                new CubicCurve2D.Double(2191.0, 7621.0, 2191.0, 7619.0, 2191.0, 7618.0, 2191.0, 7617.0),\n+                new CubicCurve2D.Double(2191.0, 7617.0, 2191.0, 7617.0, 2191.0, 7616.0, 2191.0, 7615.0),\n+                new CubicCurve2D.Double(2198.0, 7602.0, 2200.0, 7599.0, 2203.0, 7595.0, 2205.0, 7590.0),\n+                new CubicCurve2D.Double(2205.0, 7590.0, 2212.0, 7580.0, 2220.0, 7571.0, 2228.0, 7563.0),\n+                new CubicCurve2D.Double(2228.0, 7563.0, 2233.0, 7557.0, 2239.0, 7551.0, 2245.0, 7546.0),\n+                new CubicCurve2D.Double(2245.0, 7546.0, 2252.0, 7540.0, 2260.0, 7534.0, 2267.0, 7528.0),\n+                new CubicCurve2D.Double(2267.0, 7528.0, 2271.0, 7526.0, 2275.0, 7524.0, 2279.0, 7521.0),\n+                new CubicCurve2D.Double(2279.0, 7521.0, 2279.0, 7520.0, 2280.0, 7520.0, 2281.0, 7519.0)\n+        );\n+        private final static java.util.List<CubicCurve2D> curves2 = Arrays.asList(\n+                new CubicCurve2D.Double(2281.0, 7519.0, 2282.0, 7518.0, 2282.0, 7517.0, 2283.0, 7516.0),\n+                new CubicCurve2D.Double(2283.0, 7516.0, 2284.0, 7515.0, 2284.0, 7515.0, 2285.0, 7514.0),\n+                new CubicCurve2D.Double(2291.0, 7496.0, 2292.0, 7495.0, 2292.0, 7494.0, 2291.0, 7493.0),\n+                new CubicCurve2D.Double(2291.0, 7493.0, 2290.0, 7492.0, 2290.0, 7492.0, 2289.0, 7492.0),\n+                new CubicCurve2D.Double(2289.0, 7492.0, 2288.0, 7491.0, 2286.0, 7492.0, 2285.0, 7492.0),\n+                new CubicCurve2D.Double(2262.0, 7496.0, 2260.0, 7497.0, 2259.0, 7497.0, 2257.0, 7498.0),\n+                new CubicCurve2D.Double(2257.0, 7498.0, 2254.0, 7498.0, 2251.0, 7499.0, 2248.0, 7501.0),\n+                new CubicCurve2D.Double(2248.0, 7501.0, 2247.0, 7501.0, 2245.0, 7502.0, 2244.0, 7503.0),\n+                new CubicCurve2D.Double(2207.0, 7523.0, 2203.0, 7525.0, 2199.0, 7528.0, 2195.0, 7530.0),\n+                new CubicCurve2D.Double(2195.0, 7530.0, 2191.0, 7534.0, 2186.0, 7538.0, 2182.0, 7541.0)\n+        );\n+        private final static java.util.List<CubicCurve2D> curves3 = Arrays.asList(\n+                new CubicCurve2D.Double(2182.0, 7541.0, 2178.0, 7544.0, 2174.0, 7547.0, 2170.0, 7551.0),\n+                new CubicCurve2D.Double(2170.0, 7551.0, 2164.0, 7556.0, 2158.0, 7563.0, 2152.0, 7569.0),\n+                new CubicCurve2D.Double(2152.0, 7569.0, 2148.0, 7573.0, 2145.0, 7577.0, 2141.0, 7582.0),\n+                new CubicCurve2D.Double(2141.0, 7582.0, 2138.0, 7588.0, 2134.0, 7595.0, 2132.0, 7602.0),\n+                new CubicCurve2D.Double(2132.0, 7602.0, 2132.0, 7605.0, 2131.0, 7608.0, 2131.0, 7617.0),\n+                new CubicCurve2D.Double(2131.0, 7617.0, 2131.0, 7620.0, 2131.0, 7622.0, 2131.0, 7624.0),\n+                new CubicCurve2D.Double(2131.0, 7624.0, 2131.0, 7630.0, 2132.0, 7636.0, 2135.0, 7641.0),\n+                new CubicCurve2D.Double(2135.0, 7641.0, 2136.0, 7644.0, 2137.0, 7647.0, 2139.0, 7650.0),\n+                new CubicCurve2D.Double(2139.0, 7650.0, 2143.0, 7658.0, 2149.0, 7664.0, 2155.0, 7670.0),\n+                new CubicCurve2D.Double(2155.0, 7670.0, 2160.0, 7676.0, 2165.0, 7681.0, 2171.0, 7686.0)\n+        );\n+        private final static java.util.List<CubicCurve2D> curves4 = Arrays.asList(\n+                new CubicCurve2D.Double(2171.0, 7686.0, 2174.0, 7689.0, 2177.0, 7692.0, 2180.0, 7694.0),\n+                new CubicCurve2D.Double(2180.0, 7694.0, 2185.0, 7698.0, 2191.0, 7702.0, 2196.0, 7706.0),\n+                new CubicCurve2D.Double(2196.0, 7706.0, 2199.0, 7708.0, 2203.0, 7711.0, 2207.0, 7713.0),\n+                new CubicCurve2D.Double(2244.0, 7734.0, 2245.0, 7734.0, 2247.0, 7735.0, 2248.0, 7736.0),\n+                new CubicCurve2D.Double(2248.0, 7736.0, 2251.0, 7738.0, 2254.0, 7739.0, 2257.0, 7739.0),\n+                new CubicCurve2D.Double(2257.0, 7739.0, 2259.0, 7739.0, 2260.0, 7739.0, 2262.0, 7740.0),\n+                new CubicCurve2D.Double(2285.0, 7745.0, 2286.0, 7745.0, 2288.0, 7745.0, 2289.0, 7745.0),\n+                new CubicCurve2D.Double(2289.0, 7745.0, 2290.0, 7745.0, 2290.0, 7744.0, 2291.0, 7743.0),\n+                new CubicCurve2D.Double(2291.0, 7743.0, 2292.0, 7742.0, 2292.0, 7741.0, 2291.0, 7740.0),\n+                new CubicCurve2D.Double(2285.0, 7722.0, 2284.0, 7721.0, 2284.0, 7721.0, 2283.0, 7720.0),\n+                new CubicCurve2D.Double(2283.0, 7720.0, 2282.0, 7719.0, 2282.0, 7719.0, 2281.0, 7718.0),\n+                new CubicCurve2D.Double(2281.0, 7718.0, 2280.0, 7717.0, 2279.0, 7716.0, 2279.0, 7716.0),\n+                new CubicCurve2D.Double(2279.0, 7716.0, 2275.0, 7712.0, 2271.0, 7710.0, 2267.0, 7708.0),\n+                new CubicCurve2D.Double(2267.0, 7708.0, 2260.0, 7702.0, 2252.0, 7697.0, 2245.0, 7691.0),\n+                new CubicCurve2D.Double(2245.0, 7691.0, 2239.0, 7685.0, 2233.0, 7679.0, 2228.0, 7673.0),\n+                new CubicCurve2D.Double(2228.0, 7673.0, 2220.0, 7665.0, 2212.0, 7656.0, 2205.0, 7646.0),\n+                new CubicCurve2D.Double(2205.0, 7646.0, 2203.0, 7641.0, 2200.0, 7637.0, 2198.0, 7634.0)\n+        );\n+\n+        private final static Point2D.Double[] extent = {new Point2D.Double(0.0, 0.0), new Point2D.Double(7777.0, 10005.0)};\n+\n+        private final static Stroke STROKE = new BasicStroke(STROKE_WIDTH);\n+        private final static Stroke STROKE_DASHED = new BasicStroke(STROKE_WIDTH, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,\n+                10.0f, new float[] {100f, 0f}, 0.0f);\n+\n+        \/\/ members:\n+        private final java.util.List<CubicCurve2D> allCurves = new ArrayList<>();\n+        private final Rectangle2D bboxAllCurves = new Rectangle2D.Double();\n+\n+        BugDisplay() {\n+            allCurves.addAll(curves1);\n+            allCurves.addAll(curves2);\n+            allCurves.addAll(curves3);\n+            allCurves.addAll(curves4);\n+\n+            \/\/ initialize bounding box:\n+            double x1 = Double.POSITIVE_INFINITY;\n+            double y1 = Double.POSITIVE_INFINITY;\n+            double x2 = Double.NEGATIVE_INFINITY;\n+            double y2 = Double.NEGATIVE_INFINITY;\n+\n+            for (final CubicCurve2D c : allCurves) {\n+                final Rectangle2D r = c.getBounds2D();\n+                if (r.getMinX() < x1) {\n+                    x1 = r.getMinX();\n+                }\n+                if (r.getMinY() < y1) {\n+                    y1 = r.getMinY();\n+                }\n+                if (r.getMaxX() > x2) {\n+                    x2 = r.getMaxX();\n+                }\n+                if (r.getMaxY() > y2) {\n+                    y2 = r.getMaxY();\n+                }\n+            }\n+            \/\/ add margin of 10%:\n+            final double m = 1.1 * STROKE_WIDTH;\n+            bboxAllCurves.setFrameFromDiagonal(x1 - m, y1 - m, x2 + m, y2 + m);\n+        }\n+\n+        public void paint(final Graphics g) {\n+            final Graphics2D g2d = (Graphics2D) g;\n+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n+            g2d.setColor(Color.WHITE);\n+            g2d.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n+\n+            \/\/ ------ scale\n+            final AffineTransform tx_orig = g2d.getTransform();\n+            final AffineTransform tx = getDrawTransform();\n+            g2d.transform(tx);\n+\n+            \/\/ draw bbox:\n+            if (!CHECK_PIXELS) {\n+                g2d.setColor(Color.RED);\n+                g2d.setStroke(STROKE);\n+                g2d.draw(bboxAllCurves);\n+            }\n+            \/\/ draw curves:\n+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n+            g2d.setColor(Color.BLACK);\n+\n+            \/\/ dasher + stroker:\n+            g2d.setStroke(STROKE_DASHED);\n+            this.allCurves.forEach(g2d::draw);\n+\n+            \/\/ reset\n+            g2d.setTransform(tx_orig);\n+        }\n+\n+        private AffineTransform getDrawTransform() {\n+            \/\/ ------ scale\n+            double minX = extent[0].x, maxX = extent[1].x;\n+            double minY = extent[0].y, maxY = extent[1].y;\n+\n+            \/\/ we're scaling and respecting the proportions, check which scale to use\n+            double sx = this.canvasWidth \/ Math.abs(maxX - minX);\n+            double sy = this.canvasHeight \/ Math.abs(maxY - minY);\n+            double s = Math.min(sx, sy);\n+\n+            double m00, m11, m02, m12;\n+            if (minX < maxX) {\n+                m00 = s;\n+                m02 = -s * minX;\n+            } else {\n+                \/\/ inverted X axis\n+                m00 = -s;\n+                m02 = this.canvasWidth + s * maxX;\n+            }\n+            if (minY < maxY) {\n+                m11 = s;\n+                m12 = -s * minY;\n+            } else {\n+                \/\/ inverted Y axis\n+                m11 = -s;\n+                m12 = this.canvasHeight + s * maxY;\n+            }\n+\n+            \/\/ scale to the available view port\n+            AffineTransform scaleTransform = new AffineTransform(m00, 0, 0, m11, m02, m12);\n+\n+            \/\/ invert the Y axis since (0, 0) is at top left for AWT\n+            AffineTransform invertY = new AffineTransform(1, 0, 0, -1, 0, this.canvasHeight);\n+            invertY.concatenate(scaleTransform);\n+\n+            return invertY;\n+        }\n+\n+        public Dimension getSize(double dpi) {\n+            double metricScalingFactor = 0.02539999969303608;\n+            \/\/ 1 inch = 25,4 millimeter\n+            final double factor = dpi * metricScalingFactor \/ 25.4;\n+\n+            int width = (int) Math.ceil(Math.abs(extent[1].x - extent[0].x) * factor);\n+            int height = (int) Math.ceil(Math.abs(extent[1].y - extent[0].y) * factor);\n+\n+            return new Dimension(width, height);\n+        }\n+\n+        public void scale(double w, double h) {\n+            double extentWidth = Math.abs(extent[1].x - extent[0].x);\n+            double extentHeight = Math.abs(extent[1].y - extent[0].y);\n+\n+            double fx = w \/ extentWidth;\n+            if (fx * extentHeight > h) {\n+                fx = h \/ extentHeight;\n+            }\n+            this.canvasWidth = (int) Math.round(fx * extentWidth);\n+            this.canvasHeight = (int) Math.round(fx * extentHeight);\n+\n+            \/\/ out.println(\"canvas scaled (\" + canvasWidth + \" x \" + canvasHeight + \")\");\n+\n+            this.isScaled = true;\n+        }\n+\n+        protected boolean checkImage(BufferedImage image) {\n+            final AffineTransform tx = getDrawTransform();\n+\n+            final Point2D pMin = new Point2D.Double(bboxAllCurves.getMinX(), bboxAllCurves.getMinY());\n+            final Point2D pMax = new Point2D.Double(bboxAllCurves.getMaxX(), bboxAllCurves.getMaxY());\n+\n+            final Point2D tMin = tx.transform(pMin, null);\n+            final Point2D tMax = tx.transform(pMax, null);\n+\n+            int xMin = (int) tMin.getX();\n+            int xMax = (int) tMax.getX();\n+            if (xMin > xMax) {\n+                int t = xMin;\n+                xMin = xMax;\n+                xMax = t;\n+            }\n+\n+            int yMin = (int) tMin.getY();\n+            int yMax = (int) tMax.getY();\n+            if (yMin > yMax) {\n+                int t = yMin;\n+                yMin = yMax;\n+                yMax = t;\n+            }\n+            \/\/ add pixel margin (AA):\n+            xMin -= 3;\n+            xMax += 4;\n+            yMin -= 3;\n+            yMax += 4;\n+\n+            if (xMin < 0 || xMax > image.getWidth()\n+                    || yMin < 0 || yMax > image.getHeight()) {\n+                return true;\n+            }\n+\n+            \/\/ out.println(\"Checking rectangle: \" + tMin + \" to \" + tMax);\n+            \/\/ out.println(\"X min: \" + xMin + \" - max: \" + xMax);\n+            \/\/ out.println(\"Y min: \" + yMin + \" - max: \" + yMax);\n+\n+            final Raster raster = image.getData();\n+            final int expected = Color.WHITE.getRGB();\n+            int nBadPixels = 0;\n+\n+            \/\/ horizontal lines:\n+            for (int x = xMin; x <= xMax; x++) {\n+                if (!checkPixel(raster, x, yMin, expected)) {\n+                    nBadPixels++;\n+                }\n+                if (!checkPixel(raster, x, yMax, expected)) {\n+                    nBadPixels++;\n+                }\n+            }\n+\n+            \/\/ vertical lines:\n+            for (int y = yMin; y <= yMax; y++) {\n+                if (!checkPixel(raster, xMin, y, expected)) {\n+                    nBadPixels++;\n+                }\n+                if (!checkPixel(raster, xMax, y, expected)) {\n+                    nBadPixels++;\n+                }\n+            }\n+\n+            if (nBadPixels != 0) {\n+                out.println(\"(\" + canvasWidth + \" x \" + canvasHeight + \") BAD pixels = \" + nBadPixels);\n+\n+                if (SAVE_IMAGE) {\n+                    try {\n+                        final File file = new File(\"Bug8341381-\" + canvasWidth + \"-\" + canvasHeight + \".png\");\n+\n+                        out.println(\"Writing file: \" + file.getAbsolutePath());\n+                        ImageIO.write(image.getSubimage(0, 0, canvasWidth, canvasHeight), \"PNG\", file);\n+                    } catch (IOException ioe) {\n+                        ioe.printStackTrace();\n+                    }\n+                }\n+                return false;\n+            } else if (TRACE_ALL) {\n+                out.println(\"(\" + canvasWidth + \" x \" + canvasHeight + \") OK\");\n+            }\n+            return true;\n+        }\n+\n+        private final static int[] TMP_RGB = new int[1];\n+\n+        private static boolean checkPixel(final Raster raster,\n+                                          final int x, final int y,\n+                                          final int expected) {\n+\n+            final int[] rgb = (int[]) raster.getDataElements(x, y, TMP_RGB);\n+\n+            if (rgb[0] != expected) {\n+                if (TRACE_CHECK_PIXELS) {\n+                    out.println(\"bad pixel at (\" + x + \", \" + y + \") = \" + rgb[0]\n+                            + \" expected = \" + expected);\n+                }\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/marlin\/Bug8341381.java","additions":601,"deletions":0,"binary":false,"changes":601,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @enablePreview\n@@ -38,3 +39,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.io.ByteArrayInputStream;\n+import java.security.PEMDecoder;\n@@ -42,2 +42,16 @@\n-import java.security.cert.*;\n-import java.security.cert.CertPathValidatorException.*;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.CertPathValidatorException.BasicReason;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Set;\n@@ -47,0 +61,2 @@\n+    private static final PEMDecoder pemDecoder = java.security.PEMDecoder.of();\n+\n@@ -107,2 +123,0 @@\n-        \/\/ generate certificate from cert strings\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -110,1 +124,1 @@\n-        ByteArrayInputStream is;\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -112,2 +126,2 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        \/\/ generate certificate from cert strings\n+        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -116,2 +130,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        selfSignedCert});\n+        List<Certificate> list = Collections.singletonList(selfSignedCert);\n@@ -122,4 +135,1 @@\n-    private static Set<TrustAnchor> generateTrustAnchors()\n-            throws CertificateException {\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+    private static Set<TrustAnchor> generateTrustAnchors() {\n@@ -127,3 +137,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        \/\/ generate certificate from cert string\n+        X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -133,1 +142,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -167,1 +176,1 @@\n-            throws CertPathValidatorException, Exception {\n+            throws Exception {\n@@ -179,1 +188,5 @@\n-        params.setDate(new Date(109, 9, 1));   \/\/ 2009-09-01\n+        final Calendar calendar = Calendar.getInstance();\n+        calendar.set(Calendar.YEAR, 2009);\n+        calendar.set(Calendar.MONTH, 9);\n+        calendar.set(Calendar.DATE, 1);\n+        params.setDate(calendar.getTime());   \/\/ 2009-09-01\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPValidatorTrustAnchor.java","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,2 +30,1 @@\n-import java.io.InputStream;\n-import java.io.ByteArrayInputStream;\n+import java.security.PEMDecoder;\n@@ -32,1 +32,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -35,0 +34,1 @@\n+import java.security.cert.X509Certificate;\n@@ -90,3 +90,3 @@\n-    public static void main(String args[]) throws Exception {\n-\n-        Certificate signer = generate(signerCertStr);\n+    public static void main(String[] args) throws Exception {\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n+        Certificate signer = pemDecoder.decode(signerCertStr, X509Certificate.class);\n@@ -95,1 +95,1 @@\n-        Certificate normal = generate(normalCertStr);\n+        Certificate normal = pemDecoder.decode(normalCertStr, X509Certificate.class);\n@@ -97,1 +97,1 @@\n-        Certificate longer = generate(longerCertStr);\n+        Certificate longer = pemDecoder.decode(longerCertStr, X509Certificate.class);\n@@ -99,1 +99,1 @@\n-        Certificate shorter = generate(shorterCertStr);\n+        Certificate shorter = pemDecoder.decode(shorterCertStr, X509Certificate.class);\n@@ -108,13 +108,0 @@\n-    private static Certificate generate(String certStr) throws Exception {\n-        InputStream is = null;\n-        try {\n-            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-            is = new ByteArrayInputStream(certStr.getBytes());\n-            return cf.generateCertificate(is);\n-        } finally {\n-            if (is != null) {\n-                is.close();\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/rsa\/InvalidBitString.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @enablePreview\n@@ -200,2 +201,3 @@\n-import java.io.*;\n-import java.net.*;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.PEMDecoder;\n@@ -206,4 +208,7 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n-import javax.net.ssl.*;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -211,0 +216,3 @@\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.RSAPrivateKeySpec;\n@@ -315,1 +323,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -389,1 +397,1 @@\n-            String enabledSuites[] = {\n+            String[] enabledSuites = {\n@@ -474,14 +482,12 @@\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\" + e);\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n+            serverThread = new Thread(() -> {\n+                try {\n+                    doServerSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our server thread just died.\n+                     *\n+                     * Release the client, if not active already...\n+                     *\/\n+                    System.err.println(\"Server died...\" + e);\n+                    serverReady = true;\n+                    serverException = e;\n@@ -489,1 +495,1 @@\n-            };\n+            });\n@@ -498,11 +504,9 @@\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n+            clientThread = new Thread(() -> {\n+                try {\n+                    doClientSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our client thread just died.\n+                     *\/\n+                    System.err.println(\"Client died...\");\n+                    clientException = e;\n@@ -510,1 +514,1 @@\n-            };\n+            });\n@@ -520,1 +524,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -522,3 +525,3 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trustedCert = cf.generateCertificate(is);\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n+        Certificate trustedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n@@ -543,2 +546,1 @@\n-            is = new ByteArrayInputStream(serverCertStr.getBytes());\n-            Certificate serverCert = cf.generateCertificate(is);\n+            Certificate serverCert = pemDecoder.decode(serverCertStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/ssl\/ClientHandshaker\/RSAExport.java","additions":44,"deletions":42,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @enablePreview\n@@ -38,3 +39,18 @@\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.PEMDecoder;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -43,3 +59,0 @@\n-import java.security.cert.*;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n@@ -47,1 +60,1 @@\n-import java.util.Base64;\n+import java.util.Arrays;\n@@ -99,27 +112,0 @@\n-    static String trustedPrivateKey = \/\/ Private key in the format of PKCS#8\n-        \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDUJ3hT\/9jY\/i8i\\n\" +\n-        \"70EEaL6mbrhhdg\/Ys1E0r97n+dZaY0olqkIBhh1r8UkKWtvOkj8WBFQ0sz0HhSjT\\n\" +\n-        \"rkVEisGLW+7zPJiDBPtQrRawvCDpnzUofnQ98zQKUTHji1OqhxgNzsKCy9vIh5Mh\\n\" +\n-        \"tX0CdGUScEDXlYUkAkxMKCVo2V5dRn34D+1rNGEeWxGnQ5vyPi0IwlpEOkYxhPLV\\n\" +\n-        \"dsb5aoLzBc\/rdrrdzCM+svm7O38LhbVuA0F9NHAgdJRKE2F91ztkk1KvY0U9zCh1\\n\" +\n-        \"3u5WV7kl481qDujKGM4UURoEarbV2Xr+jNVGSpJZYCLU\/sxFrL15iPeYtmJlovo2\\n\" +\n-        \"VbFed\/NXAgMBAAECggEAUZvlQ5q1VbNhenTCc+m+\/NK2hncd3WQNJtFIU7\/dXuO2\\n\" +\n-        \"0ApQXbmzc6RbTmppB2tmbRe5NJSGM3BbpiHxb05Y6TyyDEsQ98Vgz0Xl5pJXrsaZ\\n\" +\n-        \"cjxChtoY+KcHI9qikoRpElaoqBu3LcpJJLxlnB4eCxu3NbbEgneH1fvTeCO1kvcp\\n\" +\n-        \"i3DDdyfY7WB9RW1yWAveiuqvtnbsPfJJLKEhFvZL2ArYCRTm\/oIw64yukNe\/QLR5\\n\" +\n-        \"bGzEJMT2ZNQMld1f+CW9tOrUKrnnPCGfMa351T5we+8B6sujWfftPutgEVx5TmHs\\n\" +\n-        \"AOW1SntMapbgg46K9EC\/C5YQa5D1aNOH9ZTEMkgUMQKBgQDrpPQIHFozeeyZ0iiq\\n\" +\n-        \"HtReLPcqpkwr\/9ELc3SjgUypSvpu0l\/m++um0yLinlXMn25km\/BP6Mv3t\/+1uzAc\\n\" +\n-        \"qpopkcyek8X1hzNRhDkWuMv4KDOKk5c6qLx8FGSm6q8PYm5KbsiyeCM7CJoeoqJ5\\n\" +\n-        \"74IZjOIw7UrYLckCb6W8xGQLIwKBgQDmew3vGRR3JmCCSumtJQOqhF6bBYrNb6Qc\\n\" +\n-        \"r4vrng+QhNIquwGqHKPorAI1J8J1jOS+dkDWTxSz2xQKQ83nsOspzVPskpDh5mWL\\n\" +\n-        \"gGk5QCkX87jFsXfhvZFLksZMbIdpWze997Zs2fe\/PWfPaH6o3erqo2zAhQV0eA9q\\n\" +\n-        \"C7tfImREPQKBgQDi2Xq\/8CN52M9IScQx+dnyC5Gqckt0NCKXxn8sBIa7l129oDMI\\n\" +\n-        \"187FXA8CYPEyOu14V5KiKvdos66s0daAUlB04lI8+v+g3ZYuzH50\/FQHwxPTPUBi\\n\" +\n-        \"DRzeyncXJWiAA\/8vErWM8hDgfOh5w5Fsl4EEfdcmyNm7gWA4Qyknr1ysRwKBgQDC\\n\" +\n-        \"JSPepUy09VHUTxA59nT5HRmoEeoTFRizxTfi2LkZrphuwCotxoRXiRUu+3f1lyJU\\n\" +\n-        \"Qb5qCCFTQ5bE8squgTwGcVxhajC66V3ePePlAuPatkWN2ek28X1DoLaDR+Rk3h69\\n\" +\n-        \"Wb2EQbNMl4grkUUoMA8jaVhBb4vhyQSK+qjyAUFerQKBgQDXZPuflfsjH\/d\/O2yw\\n\" +\n-        \"qZbssKe9AKORjv795teblAc3vmsSlNwwVnPdS2aq1LHyoNbetc\/OaZV151hTQ\/9z\\n\" +\n-        \"bsA48oOojgrDD07Ovg3uDcNEIufxR0aGeSSvqhElp1r7wAYj8bAr6W\/RH6MS16WW\\n\" +\n-        \"dRd+PH6hsap8BD2RlVCnrT3vIQ==\";\n@@ -159,27 +145,0 @@\n-    static String caSignerPrivateKey = \/\/ Private key in the format of PKCS#8\n-        \"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDAvGeLKlW1ljae\\n\" +\n-        \"eu8NvDCjfW5BNK2c0C4ry7Is+1mM4PC7FA4bRpMaQHKIjLsZ5D1hoA9183cv3p1a\\n\" +\n-        \"P75\/ZYMOyx1id\/hXmbd3jp8BR0wbvrKxa53+4lO0S5AL5dOpU2AVhcdeQ7+DwoL6\\n\" +\n-        \"iAuHqNcABg3CijrIcFeZHcPMwaZMd9YxJG6YrnNHMWjbXTGKpma02NMB1UnRxsdN\\n\" +\n-        \"phqfRt2gkUs18l6697sSJ7eblvSWEWw1Bmtrg9No28UUsiF8q0m9i\/G0QzYOrS6v\\n\" +\n-        \"ghum5bpHAixxfA9Z\/ozHrN8gf8gNDTRnG6phDwVb1Uj9nO2f9yTArx7Kz5EtRNmD\\n\" +\n-        \"x9SNMS9rAgMBAAECggEAZk6cF\/8s5+sIqy9OXdgbaW1XbT1tOuQ23gCOX9o8Os\/c\\n\" +\n-        \"eTG4GzpnM3QqV9l8J85D1uKD0nSeO8bLd\/CGSlG0M9IVkwNjy\/xIqyoFtUQHXmLn\\n\" +\n-        \"r84UXAv\/qqDBoc8pf6RGSKZuodcMfgBuTlaQ6D3zgou0GiQN9\/\/KP\/jQyouwnr3A\\n\" +\n-        \"LyXQekxriwPuSYAPak8s5XLfugOebbSRm2UdGEgX3yrT9FVu9rtgeMKdRaCOU8T4\\n\" +\n-        \"G2UdpGaiDfm5yrR+2XEIv4oaH3WFxmmfQCxVcOFJ1iRvfKBbLb1UCgtJuCBD067y\\n\" +\n-        \"dq5PrwUTeAvd7hwZd0lxCSnWY7VvYFNr7iJfyElowQKBgQD8eosot+Th03hpkYDs\\n\" +\n-        \"BIVsw7oqhJmcrPV1bSZ+aQwqqrOGypNmb7nLGTC8Cj1sT+EzfGs7GqxiLOEn4NXr\\n\" +\n-        \"TYV\/\/RUPBSEXVp2y+2dot1a9oq0BJ8FwGTYL0qSwJrIXJfkQFrYhVVz3JLIWJbwV\\n\" +\n-        \"cy4YCQr094BhXTS7joJOUDRsYwKBgQDDbI3Lv+bBK8lLfIBll1RY1k5Gqy\/H+qxp\\n\" +\n-        \"sMN8FmadmIGzHhe9xml6b5EfAZphAUF4vZJhQXloT5Wm+NNIAf6X6dRjvzyw7N9B\\n\" +\n-        \"d48EFJF4ChqNGBocsQRNr2wPRzQ+k2caw9YyYMIjbhktDzO1U\/FJGYW6\/Vgr2v4K\\n\" +\n-        \"siROnXfLWQKBgBOVAZQP5z2opC8z7NbhZuPPrnG7xRpEw+jupUyqoxnwEWqD7bjF\\n\" +\n-        \"M5jQBFqhRLBQ5buTi9GSuQoIRxJLuuu8IH2TyH1YvX9M5YBLRXL2vVCJ\/HcZeURT\\n\" +\n-        \"gECcfs92wNtQw6d+y3N8ZnB4tSNIm\/Th8RJGKUZkp91lWECvxeWDDP3XAoGASfNq\\n\" +\n-        \"NRAJYlAPfGFAtTDu2i8+r79X9XUGiXg6gVp4umpbqkxY75eFkq9lWzZgFRVEkUwr\\n\" +\n-        \"eGIubyquluDSEw2uKg5yMMzNSqZYVY3IsOKXqbUpFvtn5jOWTU90tNNdEdD100sI\\n\" +\n-        \"Y0f6Ly4amNKH3rZFOERQNtJn6zCTsbh3xMgR7QECgYBhQTqxLU5eIu38MKobzRue\\n\" +\n-        \"RoUkMcoY3DePkKPSYjilFhkUDozIXf\/xUGnB8kERZKO+44wUkuPGljiFL1\/P\/RO9\\n\" +\n-        \"zhHAV94Kw2ddtfxy05GVtUZ99miBmsMb2m8vumGJqfR8h2xpfc1Ra0zfrsPgLNru\\n\" +\n-        \"xDTDW+bNbM7XyPvg9mOf7Q==\";\n@@ -219,27 +178,0 @@\n-    static String certIssuerPrivateKey = \/\/ Private key in the format of PKCS#8\n-        \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC1lDVpzmzwbKOL\\n\" +\n-        \"yFWkjPjqtX9xLMq7SVqobvhBv+VChMGGjQbNQPbtczOcXNOcuMFyXxY++eXY7c37\\n\" +\n-        \"MzhbdZHv4Y4aWEn+A3EiX2\/fTAbxx165qxKiHbD2EmlKk\/Q6yIvi9M9EXXr\/viEC\\n\" +\n-        \"Y4\/Sdtd4KYtfETa0FpfF5\/ZpZMYQo8I9RqBQOmhfvXL1l\/Lodla5elZtvIUyp5k2\\n\" +\n-        \"nRQe58AxeP5hrilbIgfmEySf9mOkaTalRf2epBE\/wRNA7Qi5Sr2O4pY2x3PPdmMy\\n\" +\n-        \"NL4cZaOJTgdyeDYbEMSW6vpiJW26ma\/qeFgPIXZ8COFJZLSOEu310M4QOdSR1Y2c\\n\" +\n-        \"l3\/V2E0VAgMBAAECggEBAJjfVrjl2kHwtSCSYchQB6FTfSBDnctgTrtP8iMo9FO0\\n\" +\n-        \"gVpOkVNtRndTbjhOzro7smIgPBJ5QlIIpErBLMmTinJza7gybNk2\/KD7yKwuzgnw\\n\" +\n-        \"2IdoyB9E8B+8EHmBZzW2ck953KaqLUvzPsdMG2IOPAomr\/gx\/eRQwScVzBefiEGo\\n\" +\n-        \"sN+rGfUt\/RNAHwWje1KuNDj21S84agQhN6hdYUnIMsvJLu\/9mOwUb9ff+AzTUfFr\\n\" +\n-        \"zyx2MJL4Cx59DkUUMESCfinlHUc21llQjFWmX\/zOoGY0X0qV\/YM\/GRsv1ZDFHw9o\\n\" +\n-        \"hQ6m8Ov7D9wB3TKZBI97sCyggjBfSeuYQlNbs99KWQECgYEA7IKNL0ME7FuIrKYu\\n\" +\n-        \"FCQ\/Duz1N3oQXLzrTGKUSU1qSbrU2Jwk4SfJ8ZYCW1TP6vZkaQsTXmXun3yyCAqZ\\n\" +\n-        \"hcOtDBhI+b7Wpmmyf6nb83oYJtzHMRQZ5qS+9vOBfV9Uf1za8XI4p90EqkFHByCF\\n\" +\n-        \"tHfjVbjK39zN4CvaO3tqpOaYtL0CgYEAxIrTAhGWy9nBsxf8QeqDou0rV5Cw50Kl\\n\" +\n-        \"kQsE7KLmjvrMaFFpUc5lgWoC+pm\/69VpNBUuN\/38YozwxVjVi\/nMJuuK150mhdWI\\n\" +\n-        \"B28FI7ORnFmVeSvTrP4mBX1ct2Tny9zpchXn3rpHR5NZUs7oBhjudHSfRMrHxeBs\\n\" +\n-        \"Kv2pr2s6uzkCgYAtrEh3iAm7WzHZpX3ghd9nknsIa5odTp5h8eeRAFI2Ss4vxneY\\n\" +\n-        \"w4ZMERwDZy1\/wnVBk9H5uNWMFxiKVQGww0j3vPjawe\/R0zeVT8gaDMn9N0WARNF7\\n\" +\n-        \"qPT3265196LptZTSa6xlPllYR6LfzXgEkeJk+3qyIIHheJZ8RikiDyYOQQKBgQC\/\\n\" +\n-        \"rxlegiMNC4KDldf7vanGxAKqcz5lPbXWQOX7mGC+f9HNx+Cs3VxYHDltiXgJnOju\\n\" +\n-        \"191s1HRK9WR5REt5KhY2uzB9WxJQItJ5VYiwqhhQYXqLY\/gdVv1kC0DayDndtMWk\\n\" +\n-        \"88JhklGkeAv83DikgbpGr9sJr6+oyFkWkLDmmfD82QKBgQCMgkZJzrdSNNlB0n5x\\n\" +\n-        \"xC3MzlsQ5aBJuUctnMfuyDi+11yLAuP1oLzGEJ7qEfFoGRO0V8zJWmHAfNhmVYEX\\n\" +\n-        \"ow5g0WbPT16GoRCiOAzq+ewH+TEELMF6HWqnDuTnCg28Jg0dw2kdVTqeyzKOQlLG\\n\" +\n-        \"ua9c2DY3PUTXQPNqLVhz+XxZKA==\";\n@@ -280,0 +212,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -305,1 +238,2 @@\n-        \"TiSXLpQ1Q9GvDpzngDzJzzY=\";\n+        \"TiSXLpQ1Q9GvDpzngDzJzzY=\\n\" +\n+        \"-----END PRIVATE KEY-----\";\n@@ -340,0 +274,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -365,1 +300,2 @@\n-        \"i1pnyMPaloBOhz3Y07sWXxCz\";\n+        \"i1pnyMPaloBOhz3Y07sWXxCz\\n\" +\n+        \"-----END PRIVATE KEY-----\";\n@@ -367,1 +303,1 @@\n-    static char passphrase[] = \"passphrase\".toCharArray();\n+    static char[] passphrase = \"passphrase\".toCharArray();\n@@ -377,1 +313,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -450,2 +386,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -457,5 +392,1 @@\n-        \/\/ import the trused cert\n-        ByteArrayInputStream is =\n-            new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+        \/\/ generate certificate from cert string\n@@ -463,0 +394,3 @@\n+        Certificate trusedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n+\n+        \/\/ import the trused cert\n@@ -468,3 +402,1 @@\n-        is = new ByteArrayInputStream(caSignerStr.getBytes());\n-        Certificate caSignerCert = cf.generateCertificate(is);\n-        is.close();\n+        Certificate caSignerCert =pemDecoder.decode(caSignerStr, X509Certificate.class);\n@@ -473,3 +405,1 @@\n-        is = new ByteArrayInputStream(certIssuerStr.getBytes());\n-        Certificate certIssuerCert = cf.generateCertificate(is);\n-        is.close();\n+        Certificate certIssuerCert =pemDecoder.decode(certIssuerStr, X509Certificate.class);\n@@ -478,1 +408,2 @@\n-        PKCS8EncodedKeySpec priKeySpec = null;\n+        PKCS8EncodedKeySpec priKeySpec;\n+        Certificate keyCert;\n@@ -480,3 +411,2 @@\n-            priKeySpec = new PKCS8EncodedKeySpec(\n-                            Base64.getMimeDecoder().decode(serverPrivateKey));\n-            is = new ByteArrayInputStream(serverCertStr.getBytes());\n+            priKeySpec =pemDecoder.decode(serverPrivateKey, PKCS8EncodedKeySpec.class);\n+            keyCert = pemDecoder.decode(serverCertStr, X509Certificate.class);\n@@ -484,3 +414,2 @@\n-            priKeySpec = new PKCS8EncodedKeySpec(\n-                            Base64.getMimeDecoder().decode(clientPrivateKey));\n-            is = new ByteArrayInputStream(clientCertStr.getBytes());\n+            priKeySpec = pemDecoder.decode(clientPrivateKey, PKCS8EncodedKeySpec.class);\n+            keyCert = pemDecoder.decode(clientCertStr, X509Certificate.class);\n@@ -490,2 +419,0 @@\n-        Certificate keyCert = cf.generateCertificate(is);\n-        is.close();\n@@ -499,1 +426,2 @@\n-        CertPath path = cf.generateCertPath(Arrays.asList(chain));\n+        CertPath path = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertPath(Arrays.asList(chain));\n@@ -534,1 +462,1 @@\n-    public static void main(String args[]) throws Exception {\n+    public static void main(String[] args) throws Exception {\n@@ -589,14 +517,12 @@\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n+            serverThread = new Thread(() -> {\n+                try {\n+                    doServerSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our server thread just died.\n+                     *\n+                     * Release the client, if not active already...\n+                     *\/\n+                    System.err.println(\"Server died...\");\n+                    serverReady = true;\n+                    serverException = e;\n@@ -604,1 +530,1 @@\n-            };\n+            });\n@@ -613,11 +539,9 @@\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n+            clientThread = new Thread(() -> {\n+                try {\n+                    doClientSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our client thread just died.\n+                     *\/\n+                    System.err.println(\"Client died...\");\n+                    clientException = e;\n@@ -625,1 +549,1 @@\n-            };\n+            });\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/BasicConstraints.java","additions":68,"deletions":144,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -32,4 +33,2 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n@@ -37,0 +36,1 @@\n+import java.security.PEMDecoder;\n@@ -38,1 +38,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -41,2 +40,0 @@\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n@@ -216,0 +213,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -256,2 +255,0 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -263,0 +260,2 @@\n+        \/\/ generate certificate from cert string\n+        Certificate trustedCert = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n@@ -264,5 +263,1 @@\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(trustedCertStr.getBytes())) {\n-            Certificate trustedCert = cf.generateCertificate(is);\n-            ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n-        }\n+        ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n@@ -279,2 +274,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n@@ -282,19 +275,4 @@\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(targetCertStr.getBytes())) {\n-            chain[0] = (X509Certificate)cf.generateCertificate(is);\n-        }\n-\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(intermediateCertStr.getBytes())) {\n-            chain[1] = (X509Certificate)cf.generateCertificate(is);\n-        }\n-\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(compromisedCertStr.getBytes())) {\n-            chain[2] = (X509Certificate)cf.generateCertificate(is);\n-        }\n-\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(untrustedCrossCertStr.getBytes())) {\n-            chain[3] = (X509Certificate)cf.generateCertificate(is);\n-        }\n+        chain[0] = pemDecoder.decode(targetCertStr, X509Certificate.class);\n+        chain[1] = pemDecoder.decode(intermediateCertStr, X509Certificate.class);\n+        chain[2] = pemDecoder.decode(compromisedCertStr, X509Certificate.class);\n+        chain[3] = pemDecoder.decode(untrustedCrossCertStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/ComodoHacker.java","additions":14,"deletions":36,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @bug 4170635 8258247\n+ * @bug 4170635 8258247 8367008\n+ * @library \/test\/lib\n@@ -32,1 +33,1 @@\n-import java.io.*;\n+import java.io.IOException;\n@@ -37,0 +38,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -100,0 +103,15 @@\n+\n+        \/\/ Construct an AlgorithmId with explicit DER NULL parameters\n+        DerValue explicitNullParams = new DerValue(DerValue.tag_Null, new byte[0]);\n+        AlgorithmId aiNullParams = new AlgorithmId(AlgorithmId.SHA256_oid,\n+                explicitNullParams);\n+        \/\/ The constructor should canonicalize this to \"no parameters\"\n+        Asserts.assertTrue(aiNullParams.getEncodedParams() == null);\n+        AlgorithmId aiNormal = AlgorithmId.get(\"SHA-256\");\n+        Asserts.assertEquals(aiNullParams, aiNormal);\n+        Asserts.assertEquals(aiNullParams.hashCode(), aiNormal.hashCode());\n+\n+        \/\/ Test invalid ASN.1 NULL (non-zero length)\n+        DerValue invalidNull = new DerValue(DerValue.tag_Null, new byte[]{0x00});\n+        Asserts.assertThrows(IOException.class,\n+                () -> new AlgorithmId(AlgorithmId.SHA256_oid, invalidNull));\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/AlgorithmIdEqualsHashCode.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,7 @@\n+        test(\"HmacSHA1\", true);\n+        test(\"HmacSHA224\", true);\n+        test(\"HmacSHA256\", true);\n+        test(\"HmacSHA384\", true);\n+        test(\"HmacSHA512\", true);\n+        test(\"HmacSHA512\/224\", true);\n+        test(\"HmacSHA512\/256\", true);\n@@ -86,1 +93,0 @@\n-        test(\"HmacSHA1\", false);\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/NullParams.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -30,3 +31,10 @@\n-import java.io.ByteArrayInputStream;\n-import java.security.*;\n-import java.security.cert.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PEMDecoder;\n+import java.security.Provider;\n+import java.security.PublicKey;\n+import java.security.Security;\n+import java.security.SignatureException;\n+import java.security.cert.CRLException;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n@@ -147,2 +155,1 @@\n-    private static void setup() throws CertificateException, CRLException {\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+    private static void setup() {\n@@ -150,0 +157,1 @@\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -151,3 +159,1 @@\n-        ByteArrayInputStream inputStream =\n-                new ByteArrayInputStream(crlStr.getBytes());\n-        crl = (X509CRL)cf.generateCRL(inputStream);\n+        crl = pemDecoder.decode(crlStr, X509CRL.class);\n@@ -156,4 +162,3 @@\n-        inputStream = new ByteArrayInputStream(crlIssuerCertStr.getBytes());\n-        X509Certificate cert\n-                = (X509Certificate)cf.generateCertificate(inputStream);\n-        crlIssuerCertPubKey = cert.getPublicKey();\n+        crlIssuerCertPubKey = pemDecoder.decode(crlIssuerCertStr, X509Certificate.class)\n+                .getPublicKey();\n+\n@@ -162,2 +167,3 @@\n-        inputStream = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        selfSignedCertPubKey = cf.generateCertificate(inputStream).getPublicKey();\n+        selfSignedCertPubKey = pemDecoder.decode(selfSignedCertStr, X509Certificate.class)\n+                .getPublicKey();\n+\n","filename":"test\/jdk\/sun\/security\/x509\/X509CRLImpl\/Verify.java","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -57,1 +58,1 @@\n-        try (final ImageReader reader = ImageReader.open(imagePath)) {\n+        try (final ImageReader reader = ImageReader.open(imagePath, PreviewMode.DISABLED)) {\n","filename":"test\/jdk\/tools\/jimage\/ImageReaderDuplicateChildNodesTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Whitebox tests for ImageResourcesTree.\n+ * @modules jdk.jlink\/jdk.tools.jlink.internal\n+ * @build jdk.jlink\/jdk.tools.jlink.internal.ImageResourcesTreeTest\n+ * @run junit\/othervm -ea -esa jdk.jlink\/jdk.tools.jlink.internal.ImageResourcesTreeTest\n+ *\/\n+public class ImageResourcesTreeTestDriver {}\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/ImageResourcesTreeTestDriver.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+modules = \\\n+    jdk.jlink\/jdk.tools.jlink.internal\n+bootclasspath.dirs=.\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/TEST.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import jdk.internal.jimage.ModuleReference;\n+import jdk.tools.jlink.internal.ImageResourcesTree.Node;\n+import jdk.tools.jlink.internal.ImageResourcesTree.PackageNode;\n+import jdk.tools.jlink.internal.ImageResourcesTree.ResourceNode;\n+import jdk.tools.jlink.internal.ImageResourcesTree.Tree;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ImageResourcesTreeTest {\n+\n+    private static final String MODULES_PREFIX = \"\/modules\/\";\n+    private static final String PACKAGES_PREFIX = \"\/packages\/\";\n+\n+    @Test\n+    public void directoryNodes() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/java\/util\/SomeOtherClass.class\",\n+                \"\/java.base\/java\/util\/resource.txt\",\n+                \"\/java.logging\/java\/util\/logging\/LoggingClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/OtherLoggingClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        \/\/ All paths from the root (but not the root itself).\n+        assertTrue(nodes.containsKey(\"\/modules\"));\n+        assertTrue(nodes.containsKey(\"\/modules\/java.base\"));\n+        assertTrue(nodes.containsKey(\"\/modules\/java.base\/java\"));\n+        assertTrue(nodes.containsKey(\"\/modules\/java.base\/java\/util\"));\n+        assertFalse(nodes.containsKey(\"\/\"));\n+\n+        \/\/ Check for mismatched modules.\n+        assertTrue(nodes.containsKey(\"\/modules\/java.logging\/java\/util\/logging\"));\n+        assertFalse(nodes.containsKey(\"\/modules\/java.base\/java\/util\/logging\"));\n+\n+        Set<String> dirPaths = nodes.keySet().stream()\n+                .filter(p -> p.startsWith(MODULES_PREFIX))\n+                .collect(Collectors.toSet());\n+        for (String path : dirPaths) {\n+            Node dir = nodes.get(path);\n+            assertFalse(dir instanceof ResourceNode, \"Unexpected resource: \" + dir);\n+            assertEquals(path, dir.getPath());\n+            assertTrue(path.endsWith(\"\/\" + dir.getName()), \"Unexpected directory name: \" + dir);\n+        }\n+    }\n+\n+    @Test\n+    public void resourceNodes() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/java\/util\/SomeOtherClass.class\",\n+                \"\/java.base\/java\/util\/resource.txt\",\n+                \"\/java.logging\/java\/util\/logging\/LoggingClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/OtherLoggingClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        \/\/ This map *does not* contain the resources, only the \"directory\" nodes.\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        assertContainsResources(\n+                nodes.get(\"\/modules\/java.base\/java\/util\"),\n+                \"SomeClass.class\", \"SomeOtherClass.class\", \"resource.txt\");\n+\n+        assertContainsResources(\n+                nodes.get(\"\/modules\/java.logging\/java\/util\/logging\"),\n+                \"LoggingClass.class\", \"OtherLoggingClass.class\");\n+    }\n+\n+    @Test\n+    public void expectedPackages() {\n+        \/\/ Paths are only to resources. Packages are inferred.\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+        Node packages = nodes.get(\"\/packages\");\n+        List<String> pkgNames = nodes.keySet().stream()\n+                .filter(p -> p.startsWith(PACKAGES_PREFIX))\n+                .map(p -> p.substring(PACKAGES_PREFIX.length()))\n+                .sorted()\n+                .toList();\n+\n+        assertEquals(List.of(\"java\", \"java.util\", \"java.util.logging\"), pkgNames);\n+        for (String pkgName : pkgNames) {\n+            PackageNode pkgNode = assertInstanceOf(PackageNode.class, packages.getChildren(pkgName));\n+            assertSame(nodes.get(PACKAGES_PREFIX + pkgNode.getName()), pkgNode);\n+        }\n+    }\n+\n+    @Test\n+    public void expectedPackageEntries() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+        PackageNode pkgUtil = getPackageNode(nodes, \"java.util\");\n+        List<ModuleReference> modRefs = pkgUtil.getModuleReferences();\n+        assertEquals(2, modRefs.size());\n+\n+        List<String> modNames = modRefs.stream().map(ModuleReference::name).toList();\n+        assertEquals(List.of(\"java.base\", \"java.logging\"), modNames);\n+\n+        \/\/ Ordered by name.\n+        assertNonEmptyRef(modRefs.get(0), \"java.base\");\n+        assertEmptyRef(modRefs.get(1), \"java.logging\");\n+    }\n+\n+    @Test\n+    public void expectedPackageEntries_withPreviewResources() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/java\/util\/OtherClass.class\",\n+                \"\/java.base\/META-INF\/preview\/java\/util\/OtherClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+        PackageNode pkgUtil = getPackageNode(nodes, \"java.util\");\n+        List<ModuleReference> modRefs = pkgUtil.getModuleReferences();\n+\n+        ModuleReference baseRef = modRefs.get(0);\n+        assertNonEmptyRef(baseRef, \"java.base\");\n+        assertTrue(baseRef.hasPreviewVersion());\n+    }\n+\n+    @Test\n+    public void expectedPackageEntries_withPreviewOnlyPackages() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/META-INF\/preview\/java\/util\/preview\/only\/PreviewClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        \/\/ Preview only package (with content).\n+        PackageNode nonEmptyPkg = getPackageNode(nodes, \"java.util.preview.only\");\n+        ModuleReference nonEmptyRef = nonEmptyPkg.getModuleReferences().getFirst();\n+        assertNonEmptyPreviewOnlyRef(nonEmptyRef, \"java.base\");\n+\n+        \/\/ Preview only packages can be empty.\n+        PackageNode emptyPkg = getPackageNode(nodes, \"java.util.preview\");\n+        ModuleReference emptyRef = emptyPkg.getModuleReferences().getFirst();\n+        assertEmptyPreviewOnlyRef(emptyRef, \"java.base\");\n+    }\n+\n+    @Test\n+    public void expectedPackageOrder_sharedPackage() {\n+        \/\/ Resource in many modules define the same package (java.shared), but\n+        \/\/ this only has content in one module (java.content).\n+        \/\/ Order of test data is shuffled to show reordering in entry list.\n+        \/\/ \"java.moduleN\" would sort before after \"java.previewN\" if it were\n+        \/\/ only sorted by name, but preview entries come first.\n+        \/\/ Expect: preview{1..3) -> content -> module{1..3}\n+        List<String> paths = List.of(\n+                \/\/ Module with content in \"java.shared\".\n+                \"\/java.content\/java\/shared\/MainPackageClass.class\",\n+                \/\/ Other resources (in other modules) which implicitly define \"java.shared\".\n+                \"\/java.module3\/java\/shared\/three\/SomeClass.class\",\n+                \"\/java.module2\/java\/shared\/two\/SomeClass.class\",\n+                \"\/java.module1\/java\/shared\/one\/SomeClass.class\",\n+                \/\/ Preview resources in other modules which implicitly define \"java.shared\".\n+                \"\/java.preview3\/META-INF\/preview\/java\/shared\/baz\/SomeClass.class\",\n+                \"\/java.preview2\/META-INF\/preview\/java\/shared\/bar\/SomeClass.class\",\n+                \"\/java.preview1\/META-INF\/preview\/java\/shared\/foo\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        PackageNode sharedPkg = getPackageNode(nodes, \"java.shared\");\n+        List<ModuleReference> refs = sharedPkg.getModuleReferences();\n+\n+        \/\/ Preview packages first, by name.\n+        int n = 1;\n+        for (ModuleReference ref : refs.subList(0, 3)) {\n+            assertEmptyPreviewOnlyRef(ref, \"java.preview\" + (n++));\n+        }\n+        \/\/ The content package (simply due to its name).\n+        assertNonEmptyRef(refs.get(3), \"java.content\");\n+        \/\/ And the non-preview empty packages after.\n+        n = 1;\n+        for (ModuleReference ref : refs.subList(4, 7)) {\n+            assertEmptyRef(ref, \"java.module\" + (n++));\n+        }\n+    }\n+\n+    static PackageNode getPackageNode(Map<String, Node> nodes, String pkgName) {\n+        return assertInstanceOf(PackageNode.class, nodes.get(PACKAGES_PREFIX + pkgName));\n+    }\n+\n+    static void assertContainsResources(Node dirNode, String... resourceNames) {\n+        for (String name : resourceNames) {\n+            Node node = assertInstanceOf(ResourceNode.class, dirNode.getChildren(name));\n+            assertEquals(name, node.getName());\n+            assertEquals(dirNode.getPath() + \"\/\" + name, node.getPath());\n+        }\n+    }\n+\n+    static void assertNonEmptyRef(ModuleReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertTrue(ref.hasResources(), \"Expected non-empty reference: \" + ref);\n+        assertFalse(ref.isPreviewOnly(), \"Expected not preview-only: \" + ref);\n+    }\n+\n+    static void assertEmptyRef(ModuleReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertFalse(ref.hasResources(), \"Expected empty reference: \" + ref);\n+        assertFalse(ref.isPreviewOnly(), \"Expected not preview-only: \" + ref);\n+    }\n+\n+    static void assertNonEmptyPreviewOnlyRef(ModuleReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertTrue(ref.hasResources(), \"Expected empty reference: \" + ref);\n+        assertTrue(ref.isPreviewOnly(), \"Expected preview-only: \" + ref);\n+    }\n+\n+    static void assertEmptyPreviewOnlyRef(ModuleReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertFalse(ref.hasResources(), \"Expected empty reference: \" + ref);\n+        assertTrue(ref.isPreviewOnly(), \"Expected preview-only: \" + ref);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/jdk.jlink\/jdk\/tools\/jlink\/internal\/ImageResourcesTreeTest.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -72,0 +72,1 @@\n+                        .sorted()\n","filename":"test\/jdk\/tools\/jpackage\/apps\/PrintEnv.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,2 +123,1 @@\n-      -e 's|\"\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"\/jdk.jpackage\/|' \\\n-      -e 's|\"file:\/\/\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"file:\/\/\/jdk.jpackage\/|' \\\n+      -e 's|\/jdk.jpackage[0-9]\\{1,\\}\/|\/jdk.jpackage\/|' \\\n","filename":"test\/jdk\/tools\/jpackage\/clean_stashed_files.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+      # Strip variable part of temporary directory name `jdk.jpackage.test217379316521032539`\n+      -e 's|\\([\\\/]\\)jdk\\.jpackage\\.test[0-9]\\{1,\\}\\b|\\1jdk.jpackage.test|g'\n+\n@@ -79,0 +82,35 @@\n+\n+      # Whipe out entire output of \/usr\/bin\/hdiutil command.\n+      # It is of little to no interest and contains too many variable parts to deal with individually.\n+      -e '\/^Running \\\/usr\\\/bin\\\/hdiutil\/,\/^Returned:\/{\n+            \/\/,\/^Output:\/!d\n+          }'\n+\n+      # Zip stack traces.\n+      -e $'\/^\\tat \/{\n+            :a\n+            g\n+            N\n+            s\/.*\\\\n\/\/\n+            \/^\\tat \/ba\n+            s\/\\\\(^\\t... \\\\)[0-9]\\\\{1,\\\\}\\\\( more\\\\)\/\\\\1N\\\\2\/\n+            s\/\\(.*\\)\/\\tat <stacktrace>\\\\n\\\\1\/\n+            P\n+            D\n+          }'\n+\n+      # Convert PID value in `taskkill \/F \/PID 5640`\n+      -e 's|taskkill \/F \/PID [0-9]\\{1,\\}|taskkill \/F \/PID <pid>|'\n+\n+      # Convert PID value in `The process with PID 5640 has been terminated`\n+      -e 's|\\(The process with PID \\)[0-9]\\{1,\\}\\( has been terminated\\)|\\1<pid>\\2|'\n+\n+      # Convert timeout value in `Check timeout value 57182ms is positive`\n+      -e 's|\\(Check timeout value \\)[0-9]\\{1,\\}\\(ms is positive\\)|\\1<timeout>\\2|'\n+\n+      # Convert variable part of \/usr\/bin\/osascript output `jdk.jpackage\/config\/SigningRuntimeImagePackageTest-dmg-setup.scpt:455:497: execution error: Finder got an error: Cant set 1 to icon view. (-10006)`\n+      -e 's|\\(-dmg-setup.scpt:\\)[0-9]\\{1,\\}:[0-9]\\{1,\\}\\(: execution error: \\)|\\1<N:M>\\2|'\n+\n+      # Use the same name for all exceptions.\n+      -e 's|[^ ]\\{1,\\}\\.[^ ]\\{1,\\}\\Exception:|<Exception>:|g'\n+      -e 's|[^ ]\\{1,\\}\\.[^ ]\\{1,\\}\\ExceptionBox:|<Exception>:|g'\n","filename":"test\/jdk\/tools\/jpackage\/clean_test_output.sh","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -98,0 +98,12 @@\n+        enum Tack {\n+            STARBOARD,\n+            PORTSIDE;\n+        }\n+\n+        @Test\n+        @Parameter({\"STARBOARD\"})\n+        @Parameter({\"PORTSIDE\", \"STARBOARD\"})\n+        public void testEnumVarArg(Tack ... cource) {\n+            recordTestCase((Object[]) cource);\n+        }\n+\n@@ -121,0 +133,2 @@\n+                    \"().testEnumVarArg(STARBOARD)\",\n+                    \"().testEnumVarArg(PORTSIDE, STARBOARD)\",\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/AnnotationsTest.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Map;\n+import org.junit.jupiter.api.Test;\n+\n+public class JUnitUtilsTest {\n+\n+    @Test\n+    public void test_assertArrayEquals() {\n+        JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {1, 2, 3});\n+        JUnitUtils.assertArrayEquals(new long[] {1, 2, 3}, new long[] {1, 2, 3});\n+        JUnitUtils.assertArrayEquals(new boolean[] {true, true}, new boolean[] {true, true});\n+    }\n+\n+    @Test\n+    public void test_assertArrayEquals_negative() {\n+        assertThrows(AssertionError.class, () -> {\n+            JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {2, 3});\n+        });\n+    }\n+\n+    @Test\n+    public void test_exceptionAsPropertyMapWithMessageWithoutCause() {\n+\n+        var ex = new Exception(\"foo\");\n+\n+        var map = JUnitUtils.exceptionAsPropertyMap(ex);\n+\n+        assertEquals(Map.of(\"getClass\", Exception.class.getName(), \"getMessage\", \"foo\"), map);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitUtilsTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,731 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import org.junit.jupiter.api.Test;\n+\n+public class ObjectMapperTest {\n+\n+    @Test\n+    public void test_String() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(\"foo\");\n+\n+        assertEquals(\"foo\", map);\n+    }\n+\n+    @Test\n+    public void test_int() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(100);\n+\n+        assertEquals(100, map);\n+    }\n+\n+    @Test\n+    public void test_null() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(null);\n+\n+        assertNull(map);\n+    }\n+\n+    @Test\n+    public void test_Object() {\n+        var obj = new Object();\n+        assertSame(obj, ObjectMapper.blank().create().map(obj));\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_Path() {\n+        var obj = Path.of(\"foo\/bar\");\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_UUID() {\n+        var obj = UUID.randomUUID();\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_BigInteger() {\n+        var obj = BigInteger.TEN;\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_Enum() {\n+\n+        var expected = Map.of(\n+                \"name\", TestEnum.BAR.name(),\n+                \"ordinal\", TestEnum.BAR.ordinal(),\n+                \"a\", \"A\",\n+                \"b\", 123,\n+                \"num\", 100\n+        );\n+\n+        assertEquals(expected, ObjectMapper.standard().create().map(TestEnum.BAR));\n+    }\n+\n+    @Test\n+    public void test_array_int() {\n+\n+        var obj = new int[] { 1, 4, 5 };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_String() {\n+\n+        var obj = new String[] { \"Hello\", \"Bye\" };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_empty() {\n+\n+        var obj = new Thread[0];\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_nulls() {\n+\n+        var obj = new Thread[10];\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_Path() {\n+\n+        var obj = new Path[] { Path.of(\"foo\/bar\"), null, Path.of(\"\").toAbsolutePath() };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_Object() {\n+\n+        var obj = new Object[] { Path.of(\"foo\/bar\"), null, 145, new Simple.Stub(\"Hello\", 738), \"foo\" };\n+\n+        var expected = new Object[] { Path.of(\"foo\/bar\"), null, 145, Map.of(\"a\", \"Hello\", \"b\", 738), \"foo\" };\n+\n+        assertArrayEquals(expected, (Object[])ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_functional() {\n+        assertWrappedIdentity(new Function<Object, Integer>() {\n+\n+            @Override\n+            public Integer apply(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new BiFunction<Object, String, Integer>() {\n+\n+            @Override\n+            public Integer apply(Object a, String b) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Consumer<>() {\n+\n+            @Override\n+            public void accept(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new BiConsumer<>() {\n+\n+            @Override\n+            public void accept(Object a, Object b) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Predicate<>() {\n+\n+            @Override\n+            public boolean test(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Supplier<>() {\n+\n+            @Override\n+            public Object get() {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+    }\n+\n+    @Test\n+    public void testIdentityWrapper() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var a = new Object() {};\n+        var b = new Object() {};\n+\n+        var amap = om.map(a);\n+        var amap2 = om.map(a);\n+\n+        assertEquals(amap, amap2);\n+        assertEquals(ObjectMapper.wrapIdentity(a), amap);\n+\n+        var bmap = om.map(b);\n+\n+        assertNotEquals(amap, bmap);\n+        assertEquals(ObjectMapper.wrapIdentity(b), bmap);\n+    }\n+\n+    @Test\n+    public void test_wrapIdentity() {\n+\n+        assertThrowsExactly(NullPointerException.class, () -> ObjectMapper.wrapIdentity(null));\n+\n+        var iw = ObjectMapper.wrapIdentity(new Object());\n+\n+        assertSame(iw, ObjectMapper.wrapIdentity(iw));\n+\n+        var simpleStubA = new Simple.Stub(\"Hello\", 77);\n+        var simpleStubB = new Simple.Stub(\"Hello\", 77);\n+\n+        assertEquals(simpleStubA, simpleStubB);\n+        assertNotEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubB));\n+        assertEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubA));\n+    }\n+\n+    @Test\n+    public void test_empty_List() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(List.of());\n+\n+        assertEquals(List.of(), map);\n+    }\n+\n+    @Test\n+    public void test_List() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(List.of(100, \"foo\"));\n+\n+        assertEquals(List.of(100, \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_empty_Map() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(Map.of());\n+\n+        assertEquals(Map.of(), map);\n+    }\n+\n+    @Test\n+    public void test_Map() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(Map.of(100, \"foo\"));\n+\n+        assertEquals(Map.of(100, \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_MapSimple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Map.of(123, \"foo\", 321, new Simple.Stub(\"Hello\", 567)));\n+\n+        assertEquals(Map.of(123, \"foo\", 321, Map.of(\"a\", \"Hello\", \"b\", 567)), map);\n+    }\n+\n+    @Test\n+    public void test_ListSimple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(List.of(100, new Simple.Stub(\"Hello\", 567), \"bar\", new Simple() {}));\n+\n+        assertEquals(List.of(100, Map.of(\"a\", \"Hello\", \"b\", 567), \"bar\", Map.of(\"a\", \"foo\", \"b\", 123)), map);\n+    }\n+\n+    @Test\n+    public void test_Simple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(new Simple() {});\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), map);\n+    }\n+\n+    @Test\n+    public void test_Proxy() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Proxy.newProxyInstance(Simple.class.getClassLoader(), new Class<?>[] { Simple.class }, new InvocationHandler() {\n+\n+            @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                switch (method.getName()) {\n+                    case \"a\" -> {\n+                        return \"Bye\";\n+                    }\n+                    case \"b\" -> {\n+                        return 335;\n+                    }\n+                    default -> {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+            }\n+\n+        }));\n+\n+        assertEquals(Map.of(\"a\", \"Bye\", \"b\", 335), map);\n+    }\n+\n+    @Test\n+    public void test_Simple_null_property() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(new Simple.Stub(null, 123));\n+\n+        assertEquals(Map.of(\"b\", 123, \"a\", ObjectMapper.NULL), map);\n+    }\n+\n+    @Test\n+    public void test_Optional_String() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Optional.of(\"foo\"));\n+\n+        assertEquals(Map.of(\"get\", \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_Optional_empty() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Optional.empty());\n+\n+        assertEquals(Map.of(\"get\", ObjectMapper.NULL), map);\n+    }\n+\n+    @Test\n+    public void test_toMap() {\n+        var om = ObjectMapper.standard().create();\n+\n+        assertNull(om.toMap(null));\n+        assertEquals(Map.of(\"value\", \"Hello\"), om.toMap(\"Hello\"));\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+    }\n+\n+    @Test\n+    public void test_getter_throws() {\n+        var om = ObjectMapper.blank()\n+                .mutate(ObjectMapper.configureObject())\n+                .mutate(ObjectMapper.configureLeafClasses())\n+                .mutate(ObjectMapper.configureException())\n+                .create();\n+\n+        var expected = Map.of(\"get\", om.toMap(new UnsupportedOperationException(\"Not for you!\")));\n+\n+        var actual = om.toMap(new Supplier<>() {\n+            @Override\n+            public Object get() {\n+                throw new UnsupportedOperationException(\"Not for you!\");\n+            }\n+        });\n+\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void test_exception_with_message_with_cause() {\n+\n+        var ex = new Exception(\"foo\", new IllegalArgumentException(\"Cause\", new RuntimeException(\"Ops!\")));\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", Exception.class.getName(),\n+                \"getMessage\", \"foo\",\n+                \"getCause\", Map.of(\n+                        \"getClass\", IllegalArgumentException.class.getName(),\n+                        \"getMessage\", \"Cause\",\n+                        \"getCause\", Map.of(\n+                                \"getClass\", RuntimeException.class.getName(),\n+                                \"getMessage\", \"Ops!\"\n+                        )\n+                )\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_exception_without_message_with_cause() {\n+\n+        var ex = new RuntimeException(null, new UnknownError(\"Ops!\"));\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", RuntimeException.class.getName(),\n+                \"getCause\", Map.of(\n+                        \"getMessage\", \"Ops!\",\n+                        \"getCause\", ObjectMapper.NULL\n+                )\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_exception_without_message_without_cause() {\n+\n+        var ex = new UnsupportedOperationException();\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\"getClass\", UnsupportedOperationException.class.getName()), map);\n+    }\n+\n+    @Test\n+    public void test_exception_CustomException() {\n+\n+        var ex = new CustomException(\"Hello\", Path.of(\"\"), Optional.empty(), null);\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", CustomException.class.getName(),\n+                \"getMessage\", \"Hello\",\n+                \"op\", Map.of(\"get\", ObjectMapper.NULL),\n+                \"path2\", Path.of(\"\")\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_Builder_accessPackageMethods() {\n+\n+        var obj = new TestType().foo(\"Hello\").bar(81);\n+\n+        var map = ObjectMapper.standard().create().toMap(obj);\n+\n+        assertEquals(Map.of(\"foo\", \"Hello\"), map);\n+\n+        map = ObjectMapper.standard().accessPackageMethods(TestType.class.getPackage()).create().toMap(obj);\n+\n+        assertEquals(Map.of(\"foo\", \"Hello\", \"bar\", 81), map);\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_Simple() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleStub() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleDefault() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleDefaultExt() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleStub_and_SimpleDefault() {\n+\n+        var om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"a\").apply()\n+                .exceptSomeMethods(Simple.Default.class).add(\"a\").apply()\n+                .create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n+                .exceptSomeMethods(Simple.Default.class).add(\"b\").apply()\n+                .create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_all_excluded() {\n+\n+        var om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.class).add(\"a\").apply()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n+                .create();\n+\n+        var obj = new Simple.Stub(\"Hello\", 345);\n+\n+        assertEquals(ObjectMapper.wrapIdentity(obj), om.map(obj));\n+    }\n+\n+    interface Simple {\n+        default String a() {\n+            return \"foo\";\n+        }\n+\n+        default int b() {\n+            return 123;\n+        }\n+\n+        record Stub(String a, int b) implements Simple {}\n+\n+        static class Default implements Simple {\n+            Default(String a) {\n+                this.a = a;\n+            }\n+\n+            @Override\n+            public String a() {\n+                return a;\n+            }\n+\n+            private final String a;\n+        }\n+\n+        static class DefaultExt extends Default {\n+            DefaultExt(String a, int b) {\n+                super(a);\n+                this.b = b;\n+            }\n+\n+            @Override\n+            public String a() {\n+                return \"[\" + super.a() + \"]\";\n+            }\n+\n+            @Override\n+            public int b() {\n+                return 10 + b;\n+            }\n+\n+            private final int b;\n+        }\n+    }\n+\n+    final class TestType {\n+\n+        public String foo() {\n+            return foo;\n+        }\n+\n+        public TestType foo(String v) {\n+            foo = v;\n+            return this;\n+        }\n+\n+        int bar() {\n+            return bar;\n+        }\n+\n+        TestType bar(int v) {\n+            bar = v;\n+            return this;\n+        }\n+\n+        private String foo;\n+        private int bar;\n+    }\n+\n+    enum TestEnum implements Simple {\n+        FOO,\n+        BAR;\n+\n+        public int num() {\n+            return 100;\n+        }\n+\n+        public int num(int v) {\n+            return v;\n+        }\n+\n+        @Override\n+        public String a() {\n+            return \"A\";\n+        }\n+    }\n+\n+    static final class CustomException extends Exception {\n+\n+        CustomException(String message, Path path, Optional<Object> optional, Throwable cause) {\n+            super(message, cause);\n+            this.path = path;\n+            this.optional = optional;\n+        }\n+\n+        Path path() {\n+            return path;\n+        }\n+\n+        public Path path2() {\n+            return path;\n+        }\n+\n+        public Optional<Object> op() {\n+            return optional;\n+        }\n+\n+        private final Path path;\n+        private final Optional<Object> optional;\n+\n+        private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    private static void assertWrappedIdentity(ObjectMapper om, Object obj) {\n+        var map = om.toMap(obj);\n+        assertEquals(Map.of(\"value\", ObjectMapper.wrapIdentity(obj)), map);\n+    }\n+\n+    private static void assertWrappedIdentity(Object obj) {\n+        assertWrappedIdentity(ObjectMapper.standard().create(), obj);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ObjectMapperTest.java","additions":731,"deletions":0,"binary":false,"changes":731,"status":"added"},{"patch":"@@ -344,1 +344,1 @@\n-                    JPackageCommand assertAppLayout() {\n+                    JPackageCommand runStandardAsserts() {\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-    static PropertyFile getAdditionalLauncherProperties(\n+    public static PropertyFile getAdditionalLauncherProperties(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,7 @@\n-    public static ApplicationLayout javaRuntime() {\n+    public static ApplicationLayout platformJavaRuntime() {\n+        Path runtime = Path.of(\"\");\n+        Path runtimeHome = runtime;\n+        if (TKit.isOSX()) {\n+            runtimeHome = Path.of(\"Contents\/Home\");\n+        }\n+\n@@ -105,2 +111,2 @@\n-                Path.of(\"\"),\n-                null,\n+                runtime,\n+                runtimeHome,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ApplicationLayout.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -377,2 +377,8 @@\n-            \/\/ Use absolute path as jpackage can be executed in another directory\n-            cmd.setArgumentValue(argName, TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath());\n+            \/\/ Use absolute path as jpackage can be executed in another directory.\n+            \/\/ Some tests expect a specific last argument, don't interfere with them\n+            \/\/ and insert the argument at the beginning of the command line.\n+            List<String> args = new ArrayList<>();\n+            args.add(argName);\n+            args.add(TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath().toString());\n+            args.addAll(cmd.getAllArguments());\n+            cmd.clearArguments().addArguments(args);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Provides uniform way to configure {@code JPackageCommand} and\n+ * {@code PackageTest} instances.\n+ *\/\n+public record ConfigurationTarget(Optional<JPackageCommand> cmd, Optional<PackageTest> test) {\n+\n+    public ConfigurationTarget {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(test);\n+        if (cmd.isEmpty() == test.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public ConfigurationTarget(JPackageCommand target) {\n+        this(Optional.of(target), Optional.empty());\n+    }\n+\n+    public ConfigurationTarget(PackageTest target) {\n+        this(Optional.empty(), Optional.of(target));\n+    }\n+\n+    public ConfigurationTarget apply(Consumer<JPackageCommand> a, Consumer<PackageTest> b) {\n+        cmd.ifPresent(Objects.requireNonNull(a));\n+        test.ifPresent(Objects.requireNonNull(b));\n+        return this;\n+    }\n+\n+    public ConfigurationTarget addInitializer(Consumer<JPackageCommand> initializer) {\n+        cmd.ifPresent(Objects.requireNonNull(initializer));\n+        test.ifPresent(v -> {\n+            v.addInitializer(initializer::accept);\n+        });\n+        return this;\n+    }\n+\n+    public ConfigurationTarget add(AdditionalLauncher addLauncher) {\n+        return apply(addLauncher::applyTo, addLauncher::applyTo);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigurationTarget.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.HashMap;\n@@ -35,1 +34,1 @@\n-import java.util.stream.Stream;\n+import java.util.TreeMap;\n@@ -47,1 +46,1 @@\n-        Map<String, String> entries = new HashMap<>(Map.of(\n+        Map<String, String> entries = new TreeMap<>(Map.of(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/FileAssociations.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -128,0 +128,2 @@\n+        \/\/ Use an old release number to make test app classes runnable on older runtimes.\n+        builder.setRelease(11);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.HashMap;\n@@ -71,0 +70,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -74,0 +74,1 @@\n+        excludeStandardAsserts(StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n@@ -89,1 +90,1 @@\n-        appLayoutAsserts = cmd.appLayoutAsserts;\n+        standardAsserts = cmd.standardAsserts;\n@@ -205,0 +206,11 @@\n+    public JPackageCommand mutate(Consumer<JPackageCommand> mutator) {\n+        return mutate(List.of(mutator));\n+    }\n+\n+    public JPackageCommand mutate(Iterable<Consumer<JPackageCommand>> mutators) {\n+        for (var mutator : mutators) {\n+            mutator.accept(this);\n+        }\n+        return this;\n+    }\n+\n@@ -463,1 +475,1 @@\n-            layout = ApplicationLayout.javaRuntime();\n+            layout = ApplicationLayout.platformJavaRuntime();\n@@ -694,1 +706,1 @@\n-        defaultToolProvider = Optional.of(jpackageToolProvider);\n+        defaultToolProvider.set(Optional.of(jpackageToolProvider));\n@@ -702,1 +714,1 @@\n-        defaultToolProvider = Optional.empty();\n+        defaultToolProvider.set(Optional.empty());\n@@ -811,1 +823,3 @@\n-        return Optional.ofNullable(withToolProvider).orElseGet(defaultToolProvider::isPresent);\n+        return Optional.ofNullable(withToolProvider).orElseGet(() -> {\n+            return defaultToolProvider.get().isPresent();\n+        });\n@@ -827,1 +841,1 @@\n-            exec.setToolProvider(defaultToolProvider.orElseGet(JavaTool.JPACKAGE::asToolProvider));\n+            exec.setToolProvider(defaultToolProvider.get().orElseGet(JavaTool.JPACKAGE::asToolProvider));\n@@ -935,1 +949,1 @@\n-        assertAppLayout();\n+        runStandardAsserts();\n@@ -978,4 +992,4 @@\n-                final var snapshopGroup = snapshots.get(a);\n-                final var newSnapshopGroup = newSnapshots.get(a);\n-                for (int i = 0; i < snapshopGroup.size(); i++) {\n-                    TKit.PathSnapshot.assertEquals(snapshopGroup.get(i), newSnapshopGroup.get(i),\n+                final var snapshotGroup = snapshots.get(a);\n+                final var newSnapshotGroup = newSnapshots.get(a);\n+                for (int i = 0; i < snapshotGroup.size(); i++) {\n+                    snapshotGroup.get(i).assertEquals(newSnapshotGroup.get(i),\n@@ -1096,1 +1110,1 @@\n-    public static enum AppLayoutAssert {\n+    public static enum StandardAssert {\n@@ -1116,0 +1130,5 @@\n+        MAIN_LAUNCHER_DESCRIPTION(cmd -> {\n+            if (!cmd.isRuntime()) {\n+                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_DESCRIPTION);\n+            }\n+        }),\n@@ -1133,0 +1152,5 @@\n+        MAC_BUNDLE_UNSIGNED_SIGNATURE(cmd -> {\n+            if (TKit.isOSX() && !MacHelper.appImageSigned(cmd)) {\n+                MacHelper.verifyUnsignedBundleSignature(cmd);\n+            }\n+        }),\n@@ -1135,1 +1159,1 @@\n-        AppLayoutAssert(Consumer<JPackageCommand> action) {\n+        StandardAssert(Consumer<JPackageCommand> action) {\n@@ -1153,1 +1177,1 @@\n-    public JPackageCommand setAppLayoutAsserts(AppLayoutAssert ... asserts) {\n+    public JPackageCommand setStandardAsserts(StandardAssert ... asserts) {\n@@ -1155,1 +1179,1 @@\n-        appLayoutAsserts = Set.of(asserts);\n+        standardAsserts = Set.of(asserts);\n@@ -1159,1 +1183,1 @@\n-    public JPackageCommand excludeAppLayoutAsserts(AppLayoutAssert... asserts) {\n+    public JPackageCommand excludeStandardAsserts(StandardAssert... asserts) {\n@@ -1161,2 +1185,2 @@\n-        return setAppLayoutAsserts(appLayoutAsserts.stream().filter(Predicate.not(\n-                asSet::contains)).toArray(AppLayoutAssert[]::new));\n+        return setStandardAsserts(standardAsserts.stream().filter(Predicate.not(\n+                asSet::contains)).toArray(StandardAssert[]::new));\n@@ -1165,3 +1189,3 @@\n-    JPackageCommand assertAppLayout() {\n-        for (var appLayoutAssert : appLayoutAsserts.stream().sorted().toList()) {\n-            appLayoutAssert.action.accept(this);\n+    JPackageCommand runStandardAsserts() {\n+        for (var standardAssert : standardAsserts.stream().sorted().toList()) {\n+            standardAssert.action.accept(this);\n@@ -1259,4 +1283,1 @@\n-            if (expectedPath.isAbsolute()) {\n-                throw new IllegalArgumentException();\n-            }\n-            if (!expectedPath.getFileName().equals(filename.getFileName())) {\n+            if (expectedPath.isAbsolute() || !expectedPath.getFileName().equals(filename.getFileName())) {\n@@ -1348,1 +1369,1 @@\n-        if (!hasArgument(\"--verbose\") && TKit.VERBOSE_JPACKAGE && !ignoreDefaultVerbose) {\n+        if (!hasArgument(\"--verbose\") && TKit.verboseJPackage() && !ignoreDefaultVerbose) {\n@@ -1372,5 +1393,1 @@\n-                if (TKit.isLinux() && typesSet.equals(PackageType.LINUX)) {\n-                    return;\n-                }\n-\n-                if (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS)) {\n+                if ((TKit.isLinux() && typesSet.equals(PackageType.LINUX)) || (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS))) {\n@@ -1524,1 +1541,1 @@\n-    private Set<AppLayoutAssert> appLayoutAsserts = Set.of(AppLayoutAssert.values());\n+    private Set<StandardAssert> standardAsserts = Set.of(StandardAssert.values());\n@@ -1526,20 +1543,4 @@\n-    private static Optional<ToolProvider> defaultToolProvider = Optional.empty();\n-\n-    private static final Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n-            () -> {\n-                Map<String, PackageType> reply = new HashMap<>();\n-                for (PackageType type : PackageType.values()) {\n-                    reply.put(type.getType(), type);\n-                }\n-                return reply;\n-            }).get();\n-\n-    public static final Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n-        \/\/ Set the property to the path of run-time image to speed up\n-        \/\/ building app images and platform bundles by avoiding running jlink\n-        \/\/ The value of the property will be automativcally appended to\n-        \/\/ jpackage command line if the command line doesn't have\n-        \/\/ `--runtime-image` parameter set.\n-        String val = TKit.getConfigProperty(\"runtime-image\");\n-        if (val != null) {\n-            return Path.of(val);\n+    private static InheritableThreadLocal<Optional<ToolProvider>> defaultToolProvider = new InheritableThreadLocal<>() {\n+        @Override\n+        protected Optional<ToolProvider> initialValue() {\n+            return Optional.empty();\n@@ -1547,2 +1548,10 @@\n-        return null;\n-    }).get();\n+    };\n+\n+    private static final Map<String, PackageType> PACKAGE_TYPES = Stream.of(PackageType.values()).collect(toMap(PackageType::getType, x -> x));\n+\n+    \/\/ Set the property to the path of run-time image to speed up\n+    \/\/ building app images and platform bundles by avoiding running jlink.\n+    \/\/ The value of the property will be automatically appended to\n+    \/\/ jpackage command line if the command line doesn't have\n+    \/\/ `--runtime-image` parameter set.\n+    public static final Path DEFAULT_RUNTIME_IMAGE = Optional.ofNullable(TKit.getConfigProperty(\"runtime-image\")).map(Path::of).orElse(null);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":64,"deletions":55,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -51,0 +52,5 @@\n+    public JarBuilder setRelease(int v) {\n+        release = v;\n+        return this;\n+    }\n+\n@@ -64,1 +70,1 @@\n-                new Executor()\n+                var exec = new Executor()\n@@ -66,3 +72,7 @@\n-                        .addArguments(\"-d\", workDir.toString())\n-                        .addPathArguments(sourceFiles)\n-                        .execute();\n+                        .addArguments(\"-d\", workDir.toString());\n+\n+                Optional.ofNullable(release).ifPresent(r -> {\n+                    exec.addArguments(\"--release\", r.toString());\n+                });\n+\n+                exec.addPathArguments(sourceFiles).execute();\n@@ -95,0 +105,1 @@\n+    private Integer release;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JarBuilder.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.file.Files;\n@@ -29,0 +28,1 @@\n+import java.util.Optional;\n@@ -41,0 +41,1 @@\n+        expectedDefault = false;\n@@ -45,0 +46,1 @@\n+        expectedIcon = null;\n@@ -49,0 +51,4 @@\n+    public LauncherIconVerifier setExpectedNoIcon() {\n+        return setExpectedIcon(null);\n+    }\n+\n@@ -54,0 +60,8 @@\n+    public boolean expectDefaultIcon() {\n+        return expectedDefault;\n+    }\n+\n+    public Optional<Path> expectIcon() {\n+        return Optional.ofNullable(expectedIcon);\n+    }\n+\n@@ -74,1 +88,1 @@\n-            TKit.assertPathExists(iconPath, true);\n+            TKit.assertFileExists(iconPath);\n@@ -80,1 +94,1 @@\n-                TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n+                TKit.assertSameFileContent(expectedIcon, iconPath,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -342,0 +342,11 @@\n+        var customFile = Optional.ofNullable(cmd.getArgumentValue(\"--mac-entitlements\")).map(Path::of);\n+        if (customFile.isEmpty()) {\n+            \/\/ Try from the resource dir.\n+            var resourceDirFile = Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).map(resourceDir -> {\n+                return resourceDir.resolve(cmd.name() + \".entitlements\");\n+            }).filter(Files::exists);\n+            if (resourceDirFile.isPresent()) {\n+                customFile = resourceDirFile;\n+            }\n+        }\n+\n@@ -343,2 +354,2 @@\n-        if (cmd.hasArgument(\"--mac-entitlements\")) {\n-            expected = new PListReader(Files.readAllBytes(Path.of(cmd.getArgumentValue(\"--mac-entitlements\")))).toMap(true);\n+        if (customFile.isPresent()) {\n+            expected = new PListReader(Files.readAllBytes(customFile.orElseThrow())).toMap(true);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,0 +25,6 @@\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+import static java.util.Collections.unmodifiableSortedSet;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+\n@@ -35,1 +41,0 @@\n-import java.util.HashSet;\n@@ -41,0 +46,2 @@\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n@@ -45,1 +52,0 @@\n-import java.util.stream.Collectors;\n@@ -164,2 +170,1 @@\n-                        \"Depends\").split(\",\")).map(String::strip).collect(\n-                        Collectors.toList());\n+                        \"Depends\").split(\",\")).map(String::strip).toList();\n@@ -326,1 +331,1 @@\n-                    runtimeDir::resolve).collect(Collectors.toSet());\n+                    runtimeDir::resolve).collect(toSet());\n@@ -328,2 +333,1 @@\n-                    expectedCriticalRuntimePaths::contains).collect(\n-                            Collectors.toSet());\n+                    expectedCriticalRuntimePaths::contains).collect(toSet());\n@@ -375,2 +379,1 @@\n-                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(\n-                        Collectors.toSet());\n+                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(toSet());\n@@ -392,2 +395,1 @@\n-                Set<Scriptlet> requiredScriptlets = Stream.of(Scriptlet.values()).sorted().collect(\n-                        Collectors.toSet());\n+                var requiredScriptlets = Stream.of(Scriptlet.values()).sorted().toList();\n@@ -455,0 +457,1 @@\n+\n@@ -456,0 +459,16 @@\n+\n+        return relativePackageFilesInSubdirectory(cmd, ApplicationLayout::desktopIntegrationDirectory)\n+                .filter(path -> {\n+                    return path.getNameCount() == 1;\n+                })\n+                .filter(path -> {\n+                    return \".desktop\".equals(PathUtils.getSuffix(path));\n+                })\n+                .map(unpackedDir::resolve)\n+                .toList();\n+    }\n+\n+    private static Stream<Path> relativePackageFilesInSubdirectory(\n+            JPackageCommand cmd, Function<ApplicationLayout, Path> subdirFunc) {\n+\n+        var unpackedDir = subdirFunc.apply(cmd.appLayout());\n@@ -457,0 +476,1 @@\n+\n@@ -458,2 +478,2 @@\n-            return packageDir.equals(path.getParent()) && path.getFileName().toString().endsWith(\".desktop\");\n-        }).map(Path::getFileName).map(unpackedDir::resolve).toList();\n+            return path.startsWith(packageDir);\n+        }).map(packageDir::relativize);\n@@ -491,1 +511,1 @@\n-        final Set<String> mandatoryKeys = new HashSet<>(Set.of(\"Name\", \"Comment\",\n+        final Set<String> mandatoryKeys = new TreeSet<>(Set.of(\"Name\", \"Comment\",\n@@ -497,1 +517,14 @@\n-        for (var e : Map.of(\"Type\", \"Application\", \"Terminal\", \"false\").entrySet()) {\n+        final String launcherDescription;\n+        if (cmd.name().equals(launcherName) || predefinedAppImage.isPresent()) {\n+            launcherDescription = Optional.ofNullable(cmd.getArgumentValue(\"--description\")).orElseGet(cmd::name);\n+        } else {\n+            launcherDescription = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"description\").or(() -> {\n+                return Optional.ofNullable(cmd.getArgumentValue(\"--description\"));\n+            }).orElseGet(cmd::name);\n+        }\n+\n+        for (var e : List.of(\n+                Map.entry(\"Type\", \"Application\"),\n+                Map.entry(\"Terminal\", \"false\"),\n+                Map.entry(\"Comment\", launcherDescription)\n+        )) {\n@@ -713,1 +746,1 @@\n-        Map<Scriptlet, List<String>> result = new HashMap<>();\n+        Map<Scriptlet, List<String>> result = new TreeMap<>();\n@@ -735,1 +768,1 @@\n-        Map<Scriptlet, List<String>> result = new HashMap<>();\n+        Map<Scriptlet, List<String>> result = new TreeMap<>();\n@@ -769,1 +802,1 @@\n-                        v -> v.rpm).collect(Collectors.joining(\"|\"))));\n+                        v -> v.rpm).collect(joining(\"|\"))));\n@@ -772,1 +805,1 @@\n-                Collectors.toMap(v -> v.rpm, v -> v));\n+                toMap(v -> v.rpm, v -> v));\n@@ -849,1 +882,1 @@\n-                }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+                }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -890,1 +923,2 @@\n-    private static final Set<Integer> XDG_CMD_VALID_ICON_SIZES = Set.of(16, 22, 32, 48, 64, 128);\n+    private static final Set<Integer> XDG_CMD_VALID_ICON_SIZES = unmodifiableSortedSet(\n+            new TreeSet<>(List.of(16, 22, 32, 48, 64, 128)));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":55,"deletions":21,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.function.BiConsumer;\n@@ -56,0 +57,1 @@\n+import java.util.function.Consumer;\n@@ -69,0 +71,1 @@\n+import jdk.jpackage.test.MacSign.CertificateRequest;\n@@ -232,0 +235,10 @@\n+    \/**\n+     * Returns {@code true} if the given jpackage command line is configured to sign\n+     * predefined app image in place.\n+     * <p>\n+     * jpackage will not create a new app image or a native bundle.\n+     *\n+     * @param cmd the jpackage command to examine\n+     * @return {@code true} if the given jpackage command line is configured to sign\n+     *         predefined app image in place and {@code false} otherwise.\n+     *\/\n@@ -237,1 +250,1 @@\n-        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\");\n+        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\") && cmd.isImagePackageType();\n@@ -240,0 +253,12 @@\n+    \/**\n+     * Returns {@code true} if the given jpackage command line is configured such\n+     * that the app image it will produce will be signed.\n+     * <p>\n+     * If the jpackage command line is bundling a native package, the function\n+     * returns {@code true} if the bundled app image will be signed.\n+     *\n+     * @param cmd the jpackage command to examine\n+     * @return {@code true} if the given jpackage command line is configured such\n+     *         that the app image it will produce will be signed and {@code false}\n+     *         otherwise.\n+     *\/\n@@ -246,1 +271,7 @@\n-        if (Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n+        var runtimeImage = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of);\n+        var appImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+\n+        if (cmd.isRuntime() && Files.isDirectory(runtimeImage.orElseThrow().resolve(\"Contents\/_CodeSignature\"))) {\n+            \/\/ If the predefined runtime is a signed bundle, bundled image should be signed too.\n+            return true;\n+        } else if (appImage.map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n@@ -251,0 +282,8 @@\n+        if (!cmd.isImagePackageType() && appImage.isPresent()) {\n+            \/\/ Building a \".pkg\" or a \".dmg\" bundle from the predefined app image.\n+            \/\/ The predefined app image is unsigned, so the app image bundled\n+            \/\/ in the output native package will be unsigned too\n+            \/\/ (even if the \".pkg\" file may be signed itself, and we never sign \".dmg\" files).\n+            return false;\n+        }\n+\n@@ -335,0 +374,104 @@\n+    public static Consumer<JPackageCommand> useKeychain(MacSign.ResolvedKeychain keychain) {\n+        return useKeychain(keychain.spec().keychain());\n+    }\n+\n+    public static Consumer<JPackageCommand> useKeychain(MacSign.Keychain keychain) {\n+        return cmd -> {\n+            useKeychain(cmd, keychain);\n+        };\n+    }\n+\n+    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.ResolvedKeychain keychain) {\n+        return useKeychain(cmd, keychain.spec().keychain());\n+    }\n+\n+    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.Keychain keychain) {\n+        return sign(cmd).addArguments(\"--mac-signing-keychain\", keychain.name());\n+    }\n+\n+    public static JPackageCommand sign(JPackageCommand cmd) {\n+        if (!cmd.hasArgument(\"--mac-sign\")) {\n+            cmd.addArgument(\"--mac-sign\");\n+        }\n+        return cmd;\n+    }\n+\n+    public record SignKeyOption(Type type, CertificateRequest certRequest) {\n+\n+        public SignKeyOption {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(certRequest);\n+        }\n+\n+        public enum Type {\n+            SIGN_KEY_USER_NAME,\n+            SIGN_KEY_IDENTITY,\n+            ;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuffer();\n+            applyTo((optionName, _) -> {\n+                sb.append(String.format(\"{%s: %s}\", optionName, certRequest));\n+            });\n+            return sb.toString();\n+        }\n+\n+        public JPackageCommand addTo(JPackageCommand cmd) {\n+            applyTo(cmd::addArguments);\n+            return sign(cmd);\n+        }\n+\n+        public JPackageCommand setTo(JPackageCommand cmd) {\n+            applyTo(cmd::setArgumentValue);\n+            return sign(cmd);\n+        }\n+\n+        private void applyTo(BiConsumer<String, String> sink) {\n+            switch (certRequest.type()) {\n+                case INSTALLER -> {\n+                    switch (type) {\n+                        case SIGN_KEY_IDENTITY -> {\n+                            sink.accept(\"--mac-installer-sign-identity\", certRequest.name());\n+                            return;\n+                        }\n+                        case SIGN_KEY_USER_NAME -> {\n+                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n+                            return;\n+                        }\n+                    }\n+                }\n+                case CODE_SIGN -> {\n+                    switch (type) {\n+                        case SIGN_KEY_IDENTITY -> {\n+                            sink.accept(\"--mac-app-image-sign-identity\", certRequest.name());\n+                            return;\n+                        }\n+                        case SIGN_KEY_USER_NAME -> {\n+                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    static void verifyUnsignedBundleSignature(JPackageCommand cmd) {\n+        if (!cmd.isImagePackageType()) {\n+            MacSignVerify.assertUnsigned(cmd.outputBundle());\n+        }\n+\n+        final Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n+        }\n+\n+        MacSignVerify.assertAdhocSigned(bundleRoot);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":145,"deletions":2,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.function.Consumer;\n@@ -354,0 +355,46 @@\n+        public static final class UsageBuilder {\n+\n+            UsageBuilder(Collection<Keychain> keychains) {\n+                this.keychains = List.copyOf(keychains);\n+            }\n+\n+            public void run(Runnable runnable) {\n+                Objects.requireNonNull(runnable);\n+\n+                final Optional<List<Path>> oldKeychains;\n+                if (addToSearchList) {\n+                    oldKeychains = Optional.ofNullable(activeKeychainFiles());\n+                    Keychain.addToSearchList(keychains);\n+                } else {\n+                    oldKeychains = Optional.empty();\n+                }\n+\n+                try {\n+                    \/\/ Ensure keychains to be used for signing are unlocked.\n+                    \/\/ When the codesign command operates on a locked keychain in a ssh session\n+                    \/\/ it emits cryptic \"errSecInternalComponent\" error without other details.\n+                    keychains.forEach(Keychain::unlock);\n+                    runnable.run();\n+                } finally {\n+                    oldKeychains.ifPresent(restoreKeychains -> {\n+                        security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n+                                .addArguments(restoreKeychains.stream().map(Path::toString).toList())\n+                                .execute();\n+                    });\n+                }\n+            }\n+\n+            public UsageBuilder addToSearchList(boolean v) {\n+                addToSearchList = v;\n+                return this;\n+            }\n+\n+            public UsageBuilder addToSearchList() {\n+                return addToSearchList(true);\n+            }\n+\n+            private final Collection<Keychain> keychains;\n+            private boolean addToSearchList;\n+        }\n+\n+\n@@ -418,1 +465,1 @@\n-        public static void addToSearchList(Collection<Keychain> keychains) {\n+        static void addToSearchList(Collection<Keychain> keychains) {\n@@ -424,12 +471,0 @@\n-        public static void withAddedKeychains(Collection<Keychain> keychains, Runnable runnable) {\n-            final var curKeychains = activeKeychainFiles();\n-            addToSearchList(keychains);\n-            try {\n-                runnable.run();\n-            } finally {\n-                security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n-                        .addArguments(curKeychains.stream().map(Path::toString).toList())\n-                        .execute();\n-            }\n-        }\n-\n@@ -1040,0 +1075,41 @@\n+    public static Keychain.UsageBuilder withKeychains(KeychainWithCertsSpec... keychains) {\n+        return withKeychains(Stream.of(keychains).map(KeychainWithCertsSpec::keychain).toArray(Keychain[]::new));\n+    }\n+\n+    public static Keychain.UsageBuilder withKeychains(Keychain... keychains) {\n+        return new Keychain.UsageBuilder(List.of(keychains));\n+    }\n+\n+    public static void withKeychains(Runnable runnable, Consumer<Keychain.UsageBuilder> mutator, Keychain... keychains) {\n+        Objects.requireNonNull(runnable);\n+        var builder = withKeychains(keychains);\n+        mutator.accept(builder);\n+        builder.run(runnable);\n+    }\n+\n+    public static void withKeychains(Runnable runnable, Keychain... keychains) {\n+        withKeychains(runnable, _ -> {}, keychains);\n+    }\n+\n+    public static void withKeychain(Consumer<Keychain> consumer, Consumer<Keychain.UsageBuilder> mutator, Keychain keychain) {\n+        Objects.requireNonNull(consumer);\n+        withKeychains(() -> {\n+            consumer.accept(keychain);\n+        }, mutator, keychain);\n+    }\n+\n+    public static void withKeychain(Consumer<Keychain> consumer, Keychain keychain) {\n+        withKeychain(consumer, _ -> {}, keychain);\n+    }\n+\n+    public static void withKeychain(Consumer<ResolvedKeychain> consumer, Consumer<Keychain.UsageBuilder> mutator, ResolvedKeychain keychain) {\n+        Objects.requireNonNull(consumer);\n+        withKeychains(() -> {\n+            consumer.accept(keychain);\n+        }, mutator, keychain.spec().keychain());\n+    }\n+\n+    public static void withKeychain(Consumer<ResolvedKeychain> consumer, ResolvedKeychain keychain) {\n+        withKeychain(consumer, _ -> {}, keychain);\n+    }\n+\n@@ -1049,0 +1125,4 @@\n+        public String name() {\n+            return spec.keychain().name();\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":93,"deletions":13,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -47,0 +47,37 @@\n+    public static void verifyAppImageSigned(\n+            JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+\n+        cmd.verifyIsOfType(PackageType.MAC);\n+        Objects.requireNonNull(certRequest);\n+        Objects.requireNonNull(keychain);\n+\n+        final Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(\n+                    cmd.appInstallationDirectory());\n+        }\n+\n+        assertSigned(bundleRoot, certRequest);\n+\n+        if (!cmd.isRuntime()) {\n+            cmd.addLauncherNames().stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n+                assertSigned(launcherPath, certRequest);\n+            });\n+        }\n+\n+        \/\/ Set to \"null\" if the sign origin is not found, instead of bailing out with an exception.\n+        \/\/ Let is fail in the following TKit.assertEquals() call with a proper log message.\n+        var signOrigin = findSpctlSignOrigin(SpctlType.EXEC, bundleRoot).orElse(null);\n+\n+        TKit.assertEquals(certRequest.name(), signOrigin,\n+                String.format(\"Check [%s] has sign origin as expected\", bundleRoot));\n+    }\n+\n+    public static void verifyPkgSigned(JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+        cmd.verifyIsOfType(PackageType.MAC_PKG);\n+        assertPkgSigned(cmd.outputBundle(), certRequest,\n+                Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest)));\n+    }\n+\n@@ -117,2 +154,2 @@\n-        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString()).saveOutput();\n-        final var result = exec.executeWithoutExitCodeCheck();\n+        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString());\n+        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n@@ -147,6 +184,28 @@\n-        final var verifier = TKit.TextStreamVerifier.group()\n-                .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n-                .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n-                .create();\n-        verifier.accept(Executor.of(\"\/usr\/bin\/codesign\", \"--verify\", \"--deep\",\n-                \"--strict\", \"--verbose=2\", path.toString()).executeAndGetOutput().iterator());\n+        assertSigned(path, false);\n+    }\n+\n+    private static void assertSigned(Path path, boolean sudo) {\n+        final Executor exec;\n+        if (sudo) {\n+            exec = Executor.of(\"sudo\", \"\/usr\/bin\/codesign\");\n+        } else {\n+            exec = Executor.of(\"\/usr\/bin\/codesign\");\n+        }\n+        exec.addArguments(\"--verify\", \"--deep\", \"--strict\", \"--verbose=2\", path.toString());\n+        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n+        if (result.getExitCode() == 0) {\n+            TKit.TextStreamVerifier.group()\n+                    .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n+                    .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n+                    .create().accept(result.getOutput().iterator());\n+        } else if (!sudo && result.getOutput().stream().findFirst().filter(str -> {\n+            \/\/ By some reason \/usr\/bin\/codesign command fails for some installed bundles.\n+            \/\/ It is known to fail for some AppContentTest test cases and all FileAssociationsTest test cases.\n+            \/\/ Rerunning the command with \"sudo\" works, though.\n+            return str.equals(String.format(\"%s: Permission denied\", path));\n+        }).isPresent()) {\n+                TKit.trace(\"Try \/usr\/bin\/codesign again with `sudo`\");\n+                assertSigned(path, true);\n+        } else {\n+            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":67,"deletions":8,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static void main(String args[]) throws Throwable {\n+    public static void main(String... args) throws Throwable {\n@@ -48,1 +48,1 @@\n-    public static void main(TestBuilder.Builder builder, String args[]) throws Throwable {\n+    public static void main(TestBuilder.Builder builder, String... args) throws Throwable {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,780 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.stream.XMLStreamWriter;\n+import jdk.jpackage.internal.util.IdentityWrapper;\n+\n+public final class ObjectMapper {\n+\n+    private ObjectMapper(\n+            Predicate<String> classFilter,\n+            Predicate<List<String>> methodFilter,\n+            Predicate<String> leafClassFilter,\n+            Map<Method, Function<?, Object>> substitutes,\n+            Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators,\n+            Set<String> accessPackageMethods) {\n+\n+        this.classFilter = Objects.requireNonNull(classFilter);\n+        this.methodFilter = Objects.requireNonNull(methodFilter);\n+        this.leafClassFilter = Objects.requireNonNull(leafClassFilter);\n+        this.substitutes = Objects.requireNonNull(substitutes);\n+        this.mutators = Objects.requireNonNull(mutators);\n+        this.accessPackageMethods = accessPackageMethods;\n+    }\n+\n+    public static Builder blank() {\n+        return new Builder().allowAllLeafClasses(false).exceptLeafClasses().add(Stream.of(\n+                Object.class,\n+                String.class, String[].class,\n+                boolean.class, Boolean.class, boolean[].class, Boolean[].class,\n+                byte.class, Byte.class, byte[].class, Byte[].class,\n+                char.class, Character.class, char[].class, Character[].class,\n+                short.class, Short.class, short[].class, Short[].class,\n+                int.class, Integer.class, int[].class, Integer[].class,\n+                long.class, Long.class, long[].class, Long[].class,\n+                float.class, Float.class, float[].class, Float[].class,\n+                double.class, Double.class, double[].class, Double[].class,\n+                void.class, Void.class, Void[].class\n+        ).map(Class::getName).toList()).apply();\n+    }\n+\n+    public static Builder standard() {\n+        return blank()\n+                .mutate(configureObject())\n+                .mutate(configureLeafClasses())\n+                .mutate(configureOptional())\n+                .mutate(configureFunctionalTypes())\n+                .mutate(configureEnum())\n+                .mutate(configureException());\n+    }\n+\n+    public static Consumer<Builder> configureObject() {\n+        \/\/ Exclude all method of Object class.\n+        return builder -> {\n+            builder.exceptMethods().add(OBJECT_METHODS).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureLeafClasses() {\n+        return builder -> {\n+            builder.exceptLeafClasses().add(Stream.of(\n+                    IdentityWrapper.class,\n+                    Class.class,\n+                    Path.class,\n+                    Path.of(\"\").getClass(),\n+                    UUID.class,\n+                    BigInteger.class\n+            ).map(Class::getName).toList()).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureOptional() {\n+        return builder -> {\n+            \/\/ Filter out all but \"get()\" methods of \"Optional\" class.\n+            builder.exceptAllMethods(Optional.class).remove(\"get\").apply();\n+            \/\/ Substitute \"Optional.get()\" with the function that will return \"null\" if the value is \"null\".\n+            builder.subst(Optional.class, \"get\", opt -> {\n+                if (opt.isPresent()) {\n+                    return opt.get();\n+                } else {\n+                    return null;\n+                }\n+            });\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureFunctionalTypes() {\n+        \/\/ Remove all getters from the standard functional types.\n+        return builder -> {\n+            builder.exceptAllMethods(Predicate.class).apply();\n+            builder.exceptAllMethods(Supplier.class).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureEnum() {\n+        return builder -> {\n+            \/\/ Filter out \"getDeclaringClass()\" and \"describeConstable()\" methods of \"Enum\" class.\n+            builder.exceptSomeMethods(Enum.class).add(\"getDeclaringClass\", \"describeConstable\").apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureException() {\n+        return builder -> {\n+            \/\/ Include only \"getMessage()\" and \"getCause()\" methods of \"Exception\" class.\n+            builder.exceptAllMethods(Exception.class).remove(\"getMessage\", \"getCause\").apply();\n+            builder.mutator(Exception.class, (ex, map) -> {\n+                var eit = map.entrySet().iterator();\n+                while (eit.hasNext()) {\n+                    var e = eit.next();\n+                    if (e.getValue() == NULL) {\n+                        \/\/ Remove property with the \"null\" value.\n+                        eit.remove();\n+                    }\n+                }\n+                map.put(\"getClass\", ex.getClass().getName());\n+            });\n+        };\n+    }\n+\n+    public static String lookupFullMethodName(Method m) {\n+        return lookupFullMethodName(m.getDeclaringClass(), m.getName());\n+    }\n+\n+    public static String lookupFullMethodName(Class<?> c, String m) {\n+        return Objects.requireNonNull(c).getName() + lookupMethodName(m);\n+    }\n+\n+    public static String lookupMethodName(Method m) {\n+        return lookupMethodName(m.getName());\n+    }\n+\n+    public static String lookupMethodName(String m) {\n+        return \"#\" + Objects.requireNonNull(m);\n+    }\n+\n+    public static Object wrapIdentity(Object v) {\n+        if (v instanceof IdentityWrapper<?> wrapper) {\n+            return wrapper;\n+        } else {\n+            return new IdentityWrapper<Object>(v);\n+        }\n+    }\n+\n+    public static void store(Map<String, Object> map, XMLStreamWriter xml) {\n+        XmlWriter.writePropertyMap(map, xml);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Optional<T> findNonNullProperty(Map<String, Object> map, String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        Objects.requireNonNull(map);\n+\n+        return Optional.ofNullable(map.get(propertyName)).filter(Predicate.not(NULL::equals)).map(v -> {\n+            return (T)v;\n+        });\n+    }\n+\n+    public Object map(Object obj) {\n+        if (obj != null) {\n+            return mapObject(obj).orElseGet(Map::of);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<String, Object> toMap(Object obj) {\n+        if (obj == null) {\n+            return null;\n+        } else {\n+            var mappedObj = map(obj);\n+            if (mappedObj instanceof Map<?, ?> m) {\n+                return (Map<String, Object>)m;\n+            } else {\n+                return Map.of(\"value\", mappedObj);\n+            }\n+        }\n+    }\n+\n+    public Optional<Object> mapObject(Object obj) {\n+        if (obj == null) {\n+            return Optional.empty();\n+        }\n+\n+        if (leafClassFilter.test(obj.getClass().getName())) {\n+            return Optional.of(obj);\n+        }\n+\n+        if (!filter(obj.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        if (obj instanceof Iterable<?> col) {\n+            return Optional.of(mapIterable(col));\n+        }\n+\n+        if (obj instanceof Map<?, ?> map) {\n+            return Optional.of(mapMap(map));\n+        }\n+\n+        if (obj.getClass().isArray()) {\n+            return Optional.of(mapArray(obj));\n+        }\n+\n+        var theMap = getMethods(obj).map(m -> {\n+            final Object propertyValue;\n+            final var subst = substitutes.get(m);\n+            if (subst != null) {\n+                propertyValue = applyGetter(obj, subst);\n+            } else {\n+                propertyValue = invoke(m, obj);\n+            }\n+            return Map.entry(m.getName(), mapObject(propertyValue).orElse(NULL));\n+        }).collect(toMutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        mutators.entrySet().stream().filter(m -> {\n+            return m.getKey().isInstance(obj);\n+        }).findFirst().ifPresent(m -> {\n+            m.getValue().accept(obj, theMap);\n+        });\n+\n+        if (theMap.isEmpty()) {\n+            return Optional.of(wrapIdentity(obj));\n+        }\n+\n+        return Optional.of(theMap);\n+    }\n+\n+    private Object invoke(Method m, Object obj) {\n+        try {\n+            return m.invoke(obj);\n+        } catch (IllegalAccessException ex) {\n+            throw rethrowUnchecked(ex);\n+        } catch (InvocationTargetException ex) {\n+            return map(ex.getTargetException());\n+        }\n+    }\n+\n+    private Collection<Object> mapIterable(Iterable<?> col) {\n+        final List<Object> list = new ArrayList<>();\n+        for (var obj : col) {\n+            list.add(mapObject(obj).orElse(NULL));\n+        }\n+        return list;\n+    }\n+\n+    private Map<Object, Object> mapMap(Map<?, ?> map) {\n+        return map.entrySet().stream().collect(toMutableMap(e -> {\n+            return mapObject(e.getKey()).orElse(NULL);\n+        }, e -> {\n+            return mapObject(e.getValue()).orElse(NULL);\n+        }));\n+    }\n+\n+    private Object mapArray(Object arr) {\n+        final var len = Array.getLength(arr);\n+\n+        if (len == 0) {\n+            return arr;\n+        }\n+\n+        Object[] buf = null;\n+\n+        for (int i = 0; i != len; i++) {\n+            var from = Array.get(arr, i);\n+            if (from != null) {\n+                var to = mapObject(from).orElseThrow();\n+                if (from != to || buf != null) {\n+                    if (buf == null) {\n+                        buf = (Object[])Array.newInstance(Object.class, len);\n+                        System.arraycopy(arr, 0, buf, 0, i);\n+                    }\n+                    buf[i] = to;\n+                }\n+            }\n+        }\n+\n+        return Optional.ofNullable((Object)buf).orElse(arr);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> Object applyGetter(Object obj, Function<T, Object> getter) {\n+        return getter.apply((T)obj);\n+    }\n+\n+    private boolean filter(Class<?> type) {\n+        return classFilter.test(type.getName());\n+    }\n+\n+    private boolean filter(Method m) {\n+        return methodFilter.test(List.of(lookupMethodName(m), lookupFullMethodName(m)));\n+    }\n+\n+    private Stream<Method> getMethods(Object obj) {\n+        return MethodGroups.create(obj.getClass(), accessPackageMethods).filter(this::filter).map(MethodGroup::callable);\n+    }\n+\n+    private static boolean defaultFilter(Method m) {\n+        if (Modifier.isStatic(m.getModifiers()) || (m.getParameterCount() > 0) || void.class.equals(m.getReturnType())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static <T, K, U>\n+    Collector<T, ?, Map<K,U>> toMutableMap(Function<? super T, ? extends K> keyMapper,\n+            Function<? super T, ? extends U> valueMapper) {\n+        return Collectors.toMap(keyMapper, valueMapper, (x , y) -> {\n+            throw new UnsupportedOperationException(\n+                    String.format(\"Entries with the same key and different values [%s] and [%s]\", x, y));\n+        }, HashMap::new);\n+    }\n+\n+    public static final class Builder {\n+\n+        private Builder() {\n+            allowAllClasses();\n+            allowAllLeafClasses();\n+            allowAllMethods();\n+        }\n+\n+        public ObjectMapper create() {\n+            return new ObjectMapper(\n+                    classFilter.createPredicate(),\n+                    methodFilter.createMultiPredicate(),\n+                    leafClassFilter.createPredicate(),\n+                    Map.copyOf(substitutes),\n+                    Map.copyOf(mutators),\n+                    accessPackageMethods);\n+        }\n+\n+\n+        public final class NamePredicateBuilder {\n+\n+            NamePredicateBuilder(Filter sink) {\n+                this.sink = Objects.requireNonNull(sink);\n+            }\n+\n+            public Builder apply() {\n+                sink.addAll(items);\n+                return Builder.this;\n+            }\n+\n+            public NamePredicateBuilder add(String... v) {\n+                return add(List.of(v));\n+            }\n+\n+            public NamePredicateBuilder add(Collection<String> v) {\n+                items.addAll(v);\n+                return this;\n+            }\n+\n+            private final Filter sink;\n+            private final Set<String> items = new HashSet<>();\n+        }\n+\n+\n+        public final class AllMethodPredicateBuilder {\n+\n+            AllMethodPredicateBuilder(Class<?> type) {\n+                impl = new MethodPredicateBuilder(type, false);\n+            }\n+\n+            public AllMethodPredicateBuilder remove(String... v) {\n+                return remove(List.of(v));\n+            }\n+\n+            public AllMethodPredicateBuilder remove(Collection<String> v) {\n+                impl.add(v);\n+                return this;\n+            }\n+\n+            public Builder apply() {\n+                return impl.apply();\n+            }\n+\n+            private final MethodPredicateBuilder impl;\n+        }\n+\n+\n+        public final class SomeMethodPredicateBuilder {\n+\n+            SomeMethodPredicateBuilder(Class<?> type) {\n+                impl = new MethodPredicateBuilder(type, true);\n+            }\n+\n+            public SomeMethodPredicateBuilder add(String... v) {\n+                return add(List.of(v));\n+            }\n+\n+            public SomeMethodPredicateBuilder add(Collection<String> v) {\n+                impl.add(v);\n+                return this;\n+            }\n+\n+            public Builder apply() {\n+                return impl.apply();\n+            }\n+\n+            private final MethodPredicateBuilder impl;\n+        }\n+\n+\n+        public Builder allowAllClasses(boolean v) {\n+            classFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllClasses() {\n+            return allowAllClasses(true);\n+        }\n+\n+        public Builder allowAllMethods(boolean v) {\n+            methodFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllMethods() {\n+            return allowAllMethods(true);\n+        }\n+\n+        public Builder allowAllLeafClasses(boolean v) {\n+            leafClassFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllLeafClasses() {\n+            return allowAllLeafClasses(true);\n+        }\n+\n+        public NamePredicateBuilder exceptClasses() {\n+            return new NamePredicateBuilder(classFilter);\n+        }\n+\n+        public AllMethodPredicateBuilder exceptAllMethods(Class<?> type) {\n+            return new AllMethodPredicateBuilder(type);\n+        }\n+\n+        public SomeMethodPredicateBuilder exceptSomeMethods(Class<?> type) {\n+            return new SomeMethodPredicateBuilder(type);\n+        }\n+\n+        public NamePredicateBuilder exceptMethods() {\n+            return new NamePredicateBuilder(methodFilter);\n+        }\n+\n+        public NamePredicateBuilder exceptLeafClasses() {\n+            return new NamePredicateBuilder(leafClassFilter);\n+        }\n+\n+        public Builder subst(Method target, Function<?, Object> substitute) {\n+            substitutes.put(Objects.requireNonNull(target), Objects.requireNonNull(substitute));\n+            return this;\n+        }\n+\n+        public <T> Builder subst(Class<? extends T> targetClass, String targetMethodName, Function<T, Object> substitute) {\n+            var method = toSupplier(() -> targetClass.getMethod(targetMethodName)).get();\n+            return subst(method, substitute);\n+        }\n+\n+        public Builder mutator(Class<?> targetClass, BiConsumer<Object, Map<String, Object>> mutator) {\n+            mutators.put(Objects.requireNonNull(targetClass), Objects.requireNonNull(mutator));\n+            return this;\n+        }\n+\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        public Builder accessPackageMethods(Package... packages) {\n+            Stream.of(packages).map(Package::getName).forEach(accessPackageMethods::add);\n+            return this;\n+        }\n+\n+\n+        private final class MethodPredicateBuilder {\n+\n+            MethodPredicateBuilder(Class<?> type, boolean negate) {\n+                this.type = Objects.requireNonNull(type);\n+                buffer.negate(negate);\n+            }\n+\n+            void add(Collection<String> v) {\n+                buffer.addAll(v);\n+            }\n+\n+            Builder apply() {\n+                var pred = buffer.createPredicate();\n+\n+                var items = MethodGroups.create(type, accessPackageMethods).groups().stream().map(MethodGroup::primary).filter(m -> {\n+                    return !OBJECT_METHODS.contains(ObjectMapper.lookupMethodName(m));\n+                }).filter(m -> {\n+                    return !pred.test(m.getName());\n+                }).map(ObjectMapper::lookupFullMethodName).toList();\n+\n+                return exceptMethods().add(items).apply();\n+            }\n+\n+            private final Class<?> type;\n+            private final Filter buffer = new Filter();\n+        }\n+\n+\n+        private static final class Filter {\n+            Predicate<List<String>> createMultiPredicate() {\n+                if (items.isEmpty()) {\n+                    var match = negate;\n+                    return v -> match;\n+                } else if (negate) {\n+                    return v -> {\n+                        return v.stream().noneMatch(Set.copyOf(items)::contains);\n+                    };\n+                } else {\n+                    return v -> {\n+                        return v.stream().anyMatch(Set.copyOf(items)::contains);\n+                    };\n+                }\n+            }\n+\n+            Predicate<String> createPredicate() {\n+                if (items.isEmpty()) {\n+                    var match = negate;\n+                    return v -> match;\n+                } else if (negate) {\n+                    return Predicate.not(Set.copyOf(items)::contains);\n+                } else {\n+                    return Set.copyOf(items)::contains;\n+                }\n+            }\n+\n+            void addAll(Collection<String> v) {\n+                items.addAll(v);\n+            }\n+\n+            void negate(boolean v) {\n+                negate = v;\n+            }\n+\n+            private boolean negate;\n+            private final Set<String> items = new HashSet<>();\n+        }\n+\n+\n+        private final Filter classFilter = new Filter();\n+        private final Filter methodFilter = new Filter();\n+        private final Filter leafClassFilter = new Filter();\n+        private final Map<Method, Function<?, Object>> substitutes = new HashMap<>();\n+        private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators = new HashMap<>();\n+        private final Set<String> accessPackageMethods = new HashSet<>();\n+    }\n+\n+\n+    private record MethodGroup(List<Method> methods) {\n+\n+        MethodGroup {\n+            Objects.requireNonNull(methods);\n+\n+            if (methods.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            methods.stream().map(Method::getName).reduce((a, b) -> {\n+                if (!a.equals(b)) {\n+                    throw new IllegalArgumentException();\n+                } else {\n+                    return a;\n+                }\n+            });\n+        }\n+\n+        Method callable() {\n+            var primary = primary();\n+            if (!primary.getDeclaringClass().isInterface()) {\n+                primary = methods.stream().filter(m -> {\n+                    return m.getDeclaringClass().isInterface();\n+                }).findFirst().orElse(primary);\n+            }\n+            return primary;\n+        }\n+\n+        Method primary() {\n+            return methods.getFirst();\n+        }\n+\n+        boolean match(Predicate<Method> predicate) {\n+            Objects.requireNonNull(predicate);\n+            return methods.stream().allMatch(predicate);\n+        }\n+    }\n+\n+\n+    private record MethodGroups(Collection<MethodGroup> groups) {\n+\n+        MethodGroups {\n+            Objects.requireNonNull(groups);\n+        }\n+\n+        Stream<MethodGroup> filter(Predicate<Method> predicate) {\n+            Objects.requireNonNull(predicate);\n+\n+            return groups.stream().filter(g -> {\n+                return g.match(predicate);\n+            });\n+        }\n+\n+        static MethodGroups create(Class<?> type, Set<String> accessPackageMethods) {\n+            List<Class<?>> types = new ArrayList<>();\n+\n+            collectSuperclassAndInterfaces(type, types::add);\n+\n+            final var methodGroups = types.stream()\n+                    .map(c -> {\n+                        if (accessPackageMethods.contains(c.getPackageName())) {\n+                            return PUBLIC_AND_PACKAGE_METHODS_GETTER.apply(c);\n+                        } else {\n+                            return PUBLIC_METHODS_GETTER.apply(c);\n+                        }\n+                    })\n+                    .flatMap(x -> x)\n+                    .filter(ObjectMapper::defaultFilter)\n+                    .collect(groupingBy(Method::getName));\n+\n+            return new MethodGroups(methodGroups.values().stream().distinct().map(MethodGroup::new).toList());\n+        }\n+\n+        private static void collectSuperclassAndInterfaces(Class<?> type, Consumer<Class<?>> sink) {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(sink);\n+\n+            for (; type != null; type = type.getSuperclass()) {\n+                sink.accept(type);\n+                for (var i : type.getInterfaces()) {\n+                    collectSuperclassAndInterfaces(i, sink);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static final class XmlWriter {\n+        static void write(Object obj,  XMLStreamWriter xml) {\n+            if (obj instanceof Map<?, ?> map) {\n+                writePropertyMap(map, xml);\n+            } else if (obj instanceof Collection<?> col) {\n+                writeCollection(col, xml);\n+            } else if (obj.getClass().isArray()) {\n+                writeArray(obj, xml);\n+            } else {\n+                toRunnable(() -> xml.writeCharacters(obj.toString())).run();\n+            }\n+        }\n+\n+        private static void writePropertyMap(Map<?, ?> map, XMLStreamWriter xml) {\n+            map.entrySet().stream().sorted(Comparator.comparing(e -> e.getKey().toString())).forEach(toConsumer(e -> {\n+                xml.writeStartElement(\"property\");\n+                xml.writeAttribute(\"name\", e.getKey().toString());\n+                write(e.getValue(), xml);\n+                xml.writeEndElement();\n+            }));\n+        }\n+\n+        private static void writeCollection(Collection<?> col, XMLStreamWriter xml) {\n+            try {\n+                xml.writeStartElement(\"collection\");\n+                xml.writeAttribute(\"size\", Integer.toString(col.size()));\n+                for (var item : col) {\n+                    xml.writeStartElement(\"item\");\n+                    write(item, xml);\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            } catch (Exception ex) {\n+                rethrowUnchecked(ex);\n+            }\n+        }\n+\n+        private static void writeArray(Object arr, XMLStreamWriter xml) {\n+            var len = Array.getLength(arr);\n+            try {\n+                xml.writeStartElement(\"array\");\n+                xml.writeAttribute(\"size\", Integer.toString(len));\n+                for (int i = 0; i != len; i++) {\n+                    xml.writeStartElement(\"item\");\n+                    write(Array.get(arr, i), xml);\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            } catch (Exception ex) {\n+                rethrowUnchecked(ex);\n+            }\n+        }\n+    }\n+\n+\n+    private final Predicate<String> classFilter;\n+    private final Predicate<List<String>> methodFilter;\n+    private final Predicate<String> leafClassFilter;\n+    private final Map<Method, Function<?, Object>> substitutes;\n+    private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators;\n+    private final Set<String> accessPackageMethods;\n+\n+    static final Object NULL = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"<null>\";\n+        }\n+    };\n+\n+    private static final Set<String> OBJECT_METHODS =\n+            Stream.of(Object.class.getMethods()).map(ObjectMapper::lookupMethodName).collect(toSet());\n+\n+    private static final Function<Class<?>, Stream<Method>> PUBLIC_METHODS_GETTER = type -> {\n+        return Stream.of(type.getMethods());\n+    };\n+\n+    private static final Function<Class<?>, Stream<Method>> PUBLIC_AND_PACKAGE_METHODS_GETTER = type -> {\n+        return Stream.of(type.getDeclaredMethods()).filter(m -> {\n+            return Stream.<IntPredicate>of(Modifier::isPrivate, Modifier::isProtected).map(p -> {\n+                return p.test(m.getModifiers());\n+            }).allMatch(v -> !v);\n+        }).map(m -> {\n+            m.setAccessible(true);\n+            return m;\n+        });\n+    };\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ObjectMapper.java","additions":780,"deletions":0,"binary":false,"changes":780,"status":"added"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Collections;\n@@ -321,0 +320,5 @@\n+    public PackageTest mutate(Consumer<PackageTest> mutator) {\n+        mutator.accept(this);\n+        return this;\n+    }\n+\n@@ -337,1 +341,5 @@\n-        return forTypes(List.of(type), () -> action.accept(this));\n+        return forTypes(List.of(type), action);\n+    }\n+\n+    public PackageTest forTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n+        return forTypes(types, () -> action.accept(this));\n@@ -351,1 +359,5 @@\n-        return notForTypes(List.of(type), () -> action.accept(this));\n+        return notForTypes(List.of(type), action);\n+    }\n+\n+    public PackageTest notForTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n+        return notForTypes(types, () -> action.accept(this));\n@@ -783,1 +795,1 @@\n-            cmd.assertAppLayout();\n+            cmd.runStandardAsserts();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingBiFunction.toBiFunction;\n@@ -31,1 +32,0 @@\n-import java.io.FileOutputStream;\n@@ -41,0 +41,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -112,1 +113,1 @@\n-        if (extraLogStream != null) {\n+        if (state().extraLogStream != null) {\n@@ -122,1 +123,33 @@\n-        var oldExtraLogStream = extraLogStream;\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.extraLogStream(logStream);\n+        });\n+    }\n+\n+    public static void withMainLogStream(ThrowingRunnable action, PrintStream logStream) {\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.mainLogStream(logStream);\n+        });\n+    }\n+\n+    public static void withStackTraceStream(ThrowingRunnable action, PrintStream logStream) {\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.stackTraceStream(logStream);\n+        });\n+    }\n+\n+    public static State state() {\n+        return STATE.get();\n+    }\n+\n+    public static void state(State v) {\n+        STATE.set(Objects.requireNonNull(v));\n+    }\n+\n+    private static void withNewState(ThrowingRunnable action, Consumer<State.Builder> stateBuilderMutator) {\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(stateBuilderMutator);\n+\n+        var oldState = state();\n+        var builder = oldState.buildCopy();\n+        stateBuilderMutator.accept(builder);\n+        var newState = builder.create();\n@@ -124,1 +157,1 @@\n-            extraLogStream = logStream;\n+            state(newState);\n@@ -127,1 +160,1 @@\n-            extraLogStream = oldExtraLogStream;\n+            state(oldState);\n@@ -144,3 +177,2 @@\n-        if (currentTest != null) {\n-            throw new IllegalStateException(\n-                    \"Unexpected nested or concurrent Test.run() call\");\n+        if (currentTest() != null) {\n+            throw new IllegalStateException(\"Unexpected nested Test.run() call\");\n@@ -151,11 +183,9 @@\n-                currentTest = test;\n-                try {\n-                    if (modes.contains(RunTestMode.FAIL_FAST)) {\n-                        ThrowingRunnable.toRunnable(test::run).run();\n-                    } else {\n-                        ignoreExceptions(test).run();\n-                    }\n-                } finally {\n-                    currentTest = null;\n-                    if (extraLogStream != null) {\n-                        extraLogStream.flush();\n+                withNewState(() -> {\n+                    try {\n+                        if (modes.contains(RunTestMode.FAIL_FAST)) {\n+                            test.run();\n+                        } else {\n+                            ignoreExceptions(test).run();\n+                        }\n+                    } finally {\n+                        Optional.ofNullable(state().extraLogStream).ifPresent(PrintStream::flush);\n@@ -163,1 +193,3 @@\n-                }\n+                }, stateBuilder -> {\n+                    stateBuilder.currentTest(test);\n+                });\n@@ -220,1 +252,1 @@\n-        return currentTest.workDir();\n+        return currentTest().workDir();\n@@ -227,1 +259,1 @@\n-        String appNamePrefix = currentTest.functionName();\n+        String appNamePrefix = currentTest().functionName();\n@@ -231,1 +263,1 @@\n-        return Stream.of(appNamePrefix, currentTest.baseName()).filter(\n+        return Stream.of(appNamePrefix, currentTest().baseName()).filter(\n@@ -259,3 +291,4 @@\n-        System.out.println(v);\n-        if (extraLogStream != null) {\n-            extraLogStream.println(v);\n+        var state = state();\n+        state.mainLogStream.println(v);\n+        if (state.extraLogStream != null) {\n+            state.extraLogStream.println(v);\n@@ -311,1 +344,1 @@\n-        if (TRACE) {\n+        if (state().trace) {\n@@ -317,1 +350,1 @@\n-        if (TRACE_ASSERTS) {\n+        if (state().traceAsserts) {\n@@ -578,1 +611,1 @@\n-        currentTest.notifySkipped(ex);\n+        currentTest().notifySkipped(ex);\n@@ -582,0 +615,4 @@\n+    public static boolean isSkippedException(Throwable t) {\n+        return JtregSkippedExceptionClass.INSTANCE.isInstance(t);\n+    }\n+\n@@ -656,4 +693,3 @@\n-        if (extraLogStream != null) {\n-            throwable.printStackTrace(extraLogStream);\n-        }\n-        throwable.printStackTrace();\n+        var state = state();\n+        Optional.ofNullable(state.extraLogStream).ifPresent(throwable::printStackTrace);\n+        throwable.printStackTrace(state.stackTraceStream);\n@@ -670,1 +706,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -681,1 +717,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -692,1 +728,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -703,1 +739,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -715,1 +751,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -727,1 +763,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -740,1 +776,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -750,1 +786,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -767,1 +803,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -779,1 +815,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -800,0 +836,29 @@\n+    public static void assertMismatchFileContent(Path a, Path b) {\n+        assertFilesMismatch(a, b, true, Optional.empty());\n+    }\n+\n+    public static void assertMismatchFileContent(Path a, Path b, String msg) {\n+        assertFilesMismatch(a, b, true, Optional.of(msg));\n+    }\n+\n+    public static void assertSameFileContent(Path a, Path b) {\n+        assertFilesMismatch(a, b, false, Optional.empty());\n+    }\n+\n+    public static void assertSameFileContent(Path a, Path b, String msg) {\n+        assertFilesMismatch(a, b, false, Optional.of(msg));\n+    }\n+\n+    public static void assertFilesMismatch(Path a, Path b, boolean expectMismatch, Optional<String> msg) {\n+        var mismatch = toBiFunction(Files::mismatch).apply(a, b) != -1;\n+        if (expectMismatch) {\n+            assertTrue(mismatch, msg.orElseGet(() -> {\n+                return String.format(\"Check the content of [%s] and [%s] files mismatch\", a, b);\n+            }));\n+        } else {\n+            assertTrue(!mismatch, msg.orElseGet(() -> {\n+                return String.format(\"Check the content of [%s] and [%s] files is the same\", a, b);\n+            }));\n+        }\n+    }\n+\n@@ -856,1 +921,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -882,1 +947,1 @@\n-            currentTest.notifyAssert();\n+            currentTest().notifyAssert();\n@@ -909,1 +974,1 @@\n-            currentTest.notifyAssert();\n+            currentTest().notifyAssert();\n@@ -954,1 +1019,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -1180,6 +1245,7 @@\n-        if (LOG_FILE == null) {\n-            return null;\n-        }\n-\n-        return ThrowingSupplier.toSupplier(() -> new PrintStream(\n-                new FileOutputStream(LOG_FILE.toFile(), true))).get();\n+        return state().logFile.map(logfile -> {\n+            try {\n+                return Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }).map(PrintStream::new).orElse(null);\n@@ -1197,2 +1263,2 @@\n-        public static void assertEquals(PathSnapshot a, PathSnapshot b, String msg) {\n-            assertStringListEquals(a.contentHashes(), b.contentHashes(), msg);\n+        public void assertEquals(PathSnapshot other, String msg) {\n+            assertStringListEquals(contentHashes(), other.contentHashes(), msg);\n@@ -1229,9 +1295,0 @@\n-    private static TestInstance currentTest;\n-    private static PrintStream extraLogStream;\n-\n-    private static final boolean TRACE;\n-    private static final boolean TRACE_ASSERTS;\n-\n-    static final boolean VERBOSE_JPACKAGE;\n-    static final boolean VERBOSE_TEST_SETUP;\n-\n@@ -1265,7 +1322,3 @@\n-    static final Path LOG_FILE = Functional.identity(() -> {\n-        String val = getConfigProperty(\"logfile\");\n-        if (val == null) {\n-            return null;\n-        }\n-        return Path.of(val);\n-    }).get();\n+    private static TestInstance currentTest() {\n+        return state().currentTest;\n+    }\n@@ -1273,16 +1326,3 @@\n-    static {\n-        Set<String> logOptions = tokenizeConfigProperty(\"suppress-logging\");\n-        if (logOptions == null) {\n-            TRACE = true;\n-            TRACE_ASSERTS = true;\n-            VERBOSE_JPACKAGE = true;\n-            VERBOSE_TEST_SETUP = true;\n-        } else if (logOptions.contains(\"all\")) {\n-            TRACE = false;\n-            TRACE_ASSERTS = false;\n-            VERBOSE_JPACKAGE = false;\n-            VERBOSE_TEST_SETUP = false;\n-        } else {\n-            Predicate<Set<String>> isNonOf = options -> {\n-                return Collections.disjoint(logOptions, options);\n-            };\n+    static boolean verboseJPackage() {\n+        return state().verboseJPackage;\n+    }\n@@ -1290,5 +1330,2 @@\n-            TRACE = isNonOf.test(Set.of(\"trace\", \"t\"));\n-            TRACE_ASSERTS = isNonOf.test(Set.of(\"assert\", \"a\"));\n-            VERBOSE_JPACKAGE = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n-            VERBOSE_TEST_SETUP = isNonOf.test(Set.of(\"init\", \"i\"));\n-        }\n+    static boolean verboseTestSetup() {\n+        return state().verboseTestSetup;\n@@ -1297,0 +1334,1 @@\n+\n@@ -1322,0 +1360,155 @@\n+\n+\n+    public static final class State {\n+\n+        private State(\n+                Optional<Path> logFile,\n+                TestInstance currentTest,\n+                PrintStream mainLogStream,\n+                PrintStream stackTraceStream,\n+                PrintStream extraLogStream,\n+                boolean trace,\n+                boolean traceAsserts,\n+                boolean verboseJPackage,\n+                boolean verboseTestSetup) {\n+\n+            Objects.requireNonNull(logFile);\n+            Objects.requireNonNull(mainLogStream);\n+            Objects.requireNonNull(stackTraceStream);\n+\n+            this.logFile = logFile;\n+            this.currentTest = currentTest;\n+            this.mainLogStream = mainLogStream;\n+            this.stackTraceStream = stackTraceStream;\n+            this.extraLogStream = extraLogStream;\n+\n+            this.trace = trace;\n+            this.traceAsserts = traceAsserts;\n+\n+            this.verboseJPackage = verboseJPackage;\n+            this.verboseTestSetup = verboseTestSetup;\n+        }\n+\n+\n+        Builder buildCopy() {\n+            return build().initFrom(this);\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+\n+        static final class Builder {\n+\n+            Builder initDefaults() {\n+                logFile = Optional.ofNullable(getConfigProperty(\"logfile\")).map(Path::of);\n+                currentTest = null;\n+                mainLogStream = System.out;\n+                stackTraceStream = System.err;\n+                extraLogStream = null;\n+\n+                var logOptions = tokenizeConfigProperty(\"suppress-logging\");\n+                if (logOptions == null) {\n+                    trace = true;\n+                    traceAsserts = true;\n+                    verboseJPackage = true;\n+                    verboseTestSetup = true;\n+                } else if (logOptions.contains(\"all\")) {\n+                    trace = false;\n+                    traceAsserts = false;\n+                    verboseJPackage = false;\n+                    verboseTestSetup = false;\n+                } else {\n+                    Predicate<Set<String>> isNonOf = options -> {\n+                        return Collections.disjoint(logOptions, options);\n+                    };\n+\n+                    trace = isNonOf.test(Set.of(\"trace\", \"t\"));\n+                    traceAsserts = isNonOf.test(Set.of(\"assert\", \"a\"));\n+                    verboseJPackage = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n+                    verboseTestSetup = isNonOf.test(Set.of(\"init\", \"i\"));\n+                }\n+\n+                return this;\n+            }\n+\n+            Builder initFrom(State state) {\n+                logFile = state.logFile;\n+                currentTest = state.currentTest;\n+                mainLogStream = state.mainLogStream;\n+                stackTraceStream = state.stackTraceStream;\n+                extraLogStream = state.extraLogStream;\n+\n+                trace = state.trace;\n+                traceAsserts = state.traceAsserts;\n+\n+                verboseJPackage = state.verboseJPackage;\n+                verboseTestSetup = state.verboseTestSetup;\n+\n+                return this;\n+            }\n+\n+            Builder logFile(Optional<Path> v) {\n+                logFile = v;\n+                return this;\n+            }\n+\n+            Builder currentTest(TestInstance v) {\n+                currentTest = v;\n+                return this;\n+            }\n+\n+            Builder mainLogStream(PrintStream v) {\n+                mainLogStream = v;\n+                return this;\n+            }\n+\n+            Builder stackTraceStream(PrintStream v) {\n+                stackTraceStream = v;\n+                return this;\n+            }\n+\n+            Builder extraLogStream(PrintStream v) {\n+                extraLogStream = v;\n+                return this;\n+            }\n+\n+            State create() {\n+                return new State(logFile, currentTest, mainLogStream, stackTraceStream, extraLogStream, trace, traceAsserts, verboseJPackage, verboseTestSetup);\n+            }\n+\n+            private Optional<Path> logFile;\n+            private TestInstance currentTest;\n+            private PrintStream mainLogStream;\n+            private PrintStream stackTraceStream;\n+            private PrintStream extraLogStream;\n+\n+            private boolean trace;\n+            private boolean traceAsserts;\n+\n+            private boolean verboseJPackage;\n+            private boolean verboseTestSetup;\n+        }\n+\n+\n+        private final Optional<Path> logFile;\n+        private final TestInstance currentTest;\n+        private final PrintStream mainLogStream;\n+        private final PrintStream stackTraceStream;\n+        private final PrintStream extraLogStream;\n+\n+        private final boolean trace;\n+        private final boolean traceAsserts;\n+\n+        private final boolean verboseJPackage;\n+        private final boolean verboseTestSetup;\n+    }\n+\n+\n+    private static final InheritableThreadLocal<State> STATE = new InheritableThreadLocal<>() {\n+        @Override\n+        protected State initialValue() {\n+            return State.build().initDefaults().create();\n+        }\n+    };\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":285,"deletions":92,"binary":false,"changes":377,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-        if (TKit.VERBOSE_TEST_SETUP) {\n+        if (TKit.verboseTestSetup()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-        if (TKit.VERBOSE_TEST_SETUP) {\n+        if (TKit.verboseTestSetup()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestMethodSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class IdentityWrapperTest {\n+\n+    @Test\n+    public void test_null() {\n+        assertThrows(NullPointerException.class, () -> identityOf(null));\n+    }\n+\n+    @Test\n+    public void test_equals() {\n+        var obj = new TestRecord(10);\n+        assertEquals(identityOf(obj), identityOf(obj));\n+    }\n+\n+    @Test\n+    public void test_not_equals() {\n+        var identity = identityOf(new TestRecord(10));\n+        var identity2 = identityOf(new TestRecord(10));\n+        assertNotEquals(identity, identity2);\n+        assertEquals(identity.value(), identity2.value());\n+    }\n+\n+    @Test\n+    public void test_Foo() {\n+        var foo = new Foo(10);\n+        assertFalse(foo.accessed());\n+\n+        foo.hashCode();\n+        assertTrue(foo.accessed());\n+        assertTrue(foo.hashCodeCalled());\n+        assertFalse(foo.equalsCalled());\n+\n+        foo = new Foo(1);\n+        foo.equals(null);\n+        assertTrue(foo.accessed());\n+        assertFalse(foo.hashCodeCalled());\n+        assertTrue(foo.equalsCalled());\n+    }\n+\n+    @Test\n+    public void test_wrappedValue_not_accessed() {\n+        var identity = identityOf(new Foo(10));\n+        var identity2 = identityOf(new Foo(10));\n+        assertNotEquals(identity, identity2);\n+\n+        assertFalse(identity.value().accessed());\n+        assertFalse(identity2.value().accessed());\n+\n+        assertEquals(identity.value(), identity2.value());\n+        assertEquals(identity2.value(), identity.value());\n+\n+        assertTrue(identity.value().accessed());\n+        assertTrue(identity2.value().accessed());\n+    }\n+\n+    @Test\n+    public void test_wrappedValue_not_accessed_in_set() {\n+        var identitySet = Set.of(identityOf(new Foo(10)), identityOf(new Foo(10)), identityOf(new Foo(10)));\n+        assertEquals(3, identitySet.size());\n+\n+        var valueSet = identitySet.stream().peek(identity -> {\n+            assertFalse(identity.value().accessed());\n+        }).map(IdentityWrapper::value).collect(Collectors.toSet());\n+\n+        assertEquals(1, valueSet.size());\n+    }\n+\n+    private static <T> IdentityWrapper<T> identityOf(T obj) {\n+        return new IdentityWrapper<>(obj);\n+    }\n+\n+    private record TestRecord(int v) {}\n+\n+    private final static class Foo {\n+\n+        Foo(int v) {\n+            this.v = v;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            try {\n+                return Objects.hash(v);\n+            } finally {\n+                hashCodeCalled = true;\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            try {\n+                if (this == obj)\n+                    return true;\n+                if (obj == null)\n+                    return false;\n+                if (getClass() != obj.getClass())\n+                    return false;\n+                Foo other = (Foo) obj;\n+                return v == other.v;\n+            } finally {\n+                equalsCalled = true;\n+            }\n+        }\n+\n+        boolean equalsCalled() {\n+            return equalsCalled;\n+        }\n+\n+        boolean hashCodeCalled() {\n+            return hashCodeCalled;\n+        }\n+\n+        boolean accessed() {\n+            return equalsCalled() || hashCodeCalled();\n+        }\n+\n+        private final int v;\n+        private boolean equalsCalled;\n+        private boolean hashCodeCalled;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/IdentityWrapperTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import org.junit.jupiter.api.Assertions;\n+\n+\n+public final class JUnitUtils {\n+\n+    \/**\n+     * Convenience adapter for {@link Assertions#assertArrayEquals(byte[], byte[])},\n+     * {@link Assertions#assertArrayEquals(int[], int[])},\n+     * {@link Assertions#assertArrayEquals(Object[], Object[])}, etc. methods.\n+     *\n+     * @param expected the expected array to test for equality\n+     * @param actual   the actual array to test for equality\n+     *\/\n+    public static void assertArrayEquals(Object expected, Object actual) {\n+        ARRAY_ASSERTERS.getOrDefault(expected.getClass().componentType(), OBJECT_ARRAY_ASSERTER).acceptUnchecked(expected, actual);\n+    }\n+\n+    \/**\n+     * Converts the given exception object to a property map.\n+     * <p>\n+     * Values returned by public getters are added to the map. Names of getters are\n+     * the keys in the returned map. The values are property map representations of\n+     * the objects returned by the getters. Only {@link Throwable#getMessage()} and\n+     * {@link Throwable#getCause()} getters are picked for the property map by\n+     * default. If the exception class has additional getters, they will be added to\n+     * the map. {@code null} is permitted.\n+     *\n+     * @param ex the exception to convert into a property map\n+     * @return the property map view of the given exception object\n+     *\/\n+    public static Map<String, Object> exceptionAsPropertyMap(Exception ex) {\n+        return EXCEPTION_OM.toMap(ex);\n+    }\n+\n+\n+    public static final class ExceptionPattern {\n+\n+        public ExceptionPattern() {\n+        }\n+\n+        public boolean match(Exception ex) {\n+            Objects.requireNonNull(ex);\n+\n+            if (expectedType != null && !expectedType.isInstance(ex)) {\n+                return false;\n+            }\n+\n+            if (expectedMessage != null && !expectedMessage.equals(ex.getMessage())) {\n+                return false;\n+            }\n+\n+            if (expectedCauseType != null && !expectedCauseType.isInstance(ex.getCause())) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        public ExceptionPattern hasMessage(String v) {\n+            expectedMessage = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern isInstanceOf(Class<? extends Exception> v) {\n+            expectedType = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern isCauseInstanceOf(Class<? extends Throwable> v) {\n+            expectedCauseType = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern hasCause(boolean v) {\n+            return isCauseInstanceOf(v ? Exception.class : null);\n+        }\n+\n+        public ExceptionPattern hasCause() {\n+            return hasCause(true);\n+        }\n+\n+        private String expectedMessage;\n+        private Class<? extends Exception> expectedType;\n+        private Class<? extends Throwable> expectedCauseType;\n+    }\n+\n+\n+    @FunctionalInterface\n+    private interface ArrayEqualsAsserter<T> {\n+        void accept(T expected, T actual);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default void acceptUnchecked(Object expected, Object actual) {\n+            accept((T)expected, (T)actual);\n+        }\n+    }\n+\n+\n+    private static final Map<Class<?>, ArrayEqualsAsserter<?>> ARRAY_ASSERTERS = Map.of(\n+            boolean.class, (ArrayEqualsAsserter<boolean[]>)Assertions::assertArrayEquals,\n+            byte.class, (ArrayEqualsAsserter<byte[]>)Assertions::assertArrayEquals,\n+            char.class, (ArrayEqualsAsserter<char[]>)Assertions::assertArrayEquals,\n+            double.class, (ArrayEqualsAsserter<double[]>)Assertions::assertArrayEquals,\n+            float.class, (ArrayEqualsAsserter<float[]>)Assertions::assertArrayEquals,\n+            int.class, (ArrayEqualsAsserter<int[]>)Assertions::assertArrayEquals,\n+            long.class, (ArrayEqualsAsserter<long[]>)Assertions::assertArrayEquals,\n+            short.class, (ArrayEqualsAsserter<short[]>)Assertions::assertArrayEquals\n+    );\n+\n+    private static final ArrayEqualsAsserter<Object[]> OBJECT_ARRAY_ASSERTER = Assertions::assertArrayEquals;\n+\n+    private static final ObjectMapper EXCEPTION_OM = ObjectMapper.standard().create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitUtils.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -167,1 +167,1 @@\n-                            \"Comment=\",\n+                            \"Comment=APPLICATION_DESCRIPTION\",\n","filename":"test\/jdk\/tools\/jpackage\/linux\/ShortcutHintTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import static java.util.Collections.unmodifiableSortedSet;\n@@ -43,0 +44,1 @@\n+import java.util.TreeSet;\n@@ -145,0 +147,1 @@\n+            customPLists = unmodifiableSortedSet(new TreeSet<>(customPLists));\n@@ -150,1 +153,0 @@\n-                    .sorted(Comparator.comparing(CustomPListType::role))\n@@ -158,1 +160,1 @@\n-                var map = Map.ofEntries(\n+                final var props = List.of(\n@@ -163,1 +165,1 @@\n-                TKit.createPropertiesFile(propFile, map);\n+                TKit.createPropertiesFile(propFile, props);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/CustomInfoPListTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.jpackage.internal.util.PListWriter.writeBoolean;\n+import static jdk.jpackage.internal.util.PListWriter.writeDict;\n+import static jdk.jpackage.internal.util.PListWriter.writePList;\n+import static jdk.jpackage.internal.util.XmlUtils.createXml;\n+import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * Test generates signed app-image with custom entitlements file from the\n+ * \"--mac-entitlements\" parameter and the resource directory. Following cases\n+ * are covered:\n+ * - Custom entitlements file in the resource directory.\n+ * - Custom entitlements file specified with the \"--mac-entitlements\" parameter.\n+ * - Custom entitlements file in the resource directory and specified with the\n+ * \"--mac-entitlements\" parameter.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type app-image \"--mac-entitlements\" parameter\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @library base\n+ * @build SigningBase\n+ * @build jdk.jpackage.test.*\n+ * @build EntitlementsTest\n+ * @requires (jpackage.test.MacSignTests == \"run\")\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=EntitlementsTest\n+ *  --jpt-before-run=SigningBase.verifySignTestEnvReady\n+ *\/\n+public class EntitlementsTest {\n+\n+    private static void createEntitlementsFile(Path file, boolean microphone) throws IOException {\n+        createXml(file, xml -> {\n+            writePList(xml, toXmlConsumer(() -> {\n+                writeDict(xml, toXmlConsumer(() -> {\n+                    writeBoolean(xml, \"com.apple.security.cs.allow-jit\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.allow-unsigned-executable-memory\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.disable-library-validation\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.allow-dyld-environment-variables\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.debugger\", true);\n+                    writeBoolean(xml, \"com.apple.security.device.audio-input\", true);\n+                    writeBoolean(xml, \"com.apple.security.device.microphone\", microphone);\n+                }));\n+            }));\n+        });\n+    }\n+\n+    public enum EntitlementsSource implements Consumer<JPackageCommand> {\n+        CMDLINE(cmd -> {\n+            var macEntitlementsFile = TKit.createTempFile(\"foo.plist\");\n+            createEntitlementsFile(macEntitlementsFile, true);\n+            cmd.addArguments(\"--mac-entitlements\", macEntitlementsFile);\n+        }),\n+        RESOURCE_DIR(cmd -> {\n+            if (!cmd.hasArgument(\"--resource-dir\")) {\n+                cmd.setArgumentValue(\"--resource-dir\", TKit.createTempDirectory(\"resources\"));\n+            }\n+\n+            var resourcesDir = Path.of(cmd.getArgumentValue(\"--resource-dir\"));\n+            createEntitlementsFile(resourcesDir.resolve(cmd.name() + \".entitlements\"), false);\n+        }),\n+        ;\n+\n+        EntitlementsSource(ThrowingConsumer<JPackageCommand> initializer) {\n+            this.initializer = toConsumer(initializer);\n+        }\n+\n+        @Override\n+        public void accept(JPackageCommand cmd) {\n+            initializer.accept(cmd);\n+        }\n+\n+        private final Consumer<JPackageCommand> initializer;\n+    }\n+\n+    @Test\n+    @Parameter({\"CMDLINE\"})\n+    @Parameter({\"RESOURCE_DIR\"})\n+    @Parameter({\"CMDLINE\", \"RESOURCE_DIR\"})\n+    public static void test(EntitlementsSource... entitlementsSources) {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, Stream.of(entitlementsSources));\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    @Test\n+    @Parameter({\"CMDLINE\"})\n+    @Parameter({\"RESOURCE_DIR\"})\n+    @Parameter({\"CMDLINE\", \"RESOURCE_DIR\"})\n+    public static void testAppStore(EntitlementsSource... entitlementsSources) {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, Stream.concat(Stream.of(cmd -> {\n+                cmd.addArguments(\"--mac-app-store\");\n+                \/\/ Ignore externally supplied runtime as it may have the \"bin\"\n+                \/\/ directory that will cause jpackage to bail out.\n+                cmd.ignoreDefaultRuntime(true);\n+            }), Stream.of(entitlementsSources)));\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, Stream<Consumer<JPackageCommand>> mutators) {\n+\n+        var cmd = JPackageCommand.helloAppImage();\n+\n+        cmd.mutate(MacHelper.useKeychain(keychain)).mutate(new SignKeyOption(\n+                SignKeyOption.Type.SIGN_KEY_IDENTITY,\n+                SigningBase.StandardCertificateRequest.CODESIGN.spec()\n+        )::addTo);\n+\n+        cmd.mutate(new AdditionalLauncher(\"x\")::applyTo);\n+\n+        mutators.forEach(cmd::mutate);\n+\n+        cmd.executeAndAssertHelloAppImageCreated();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/EntitlementsTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.List;\n@@ -64,1 +65,1 @@\n-        Map<String, String> map = Map.ofEntries(\n+        final var props = List.of(\n@@ -76,1 +77,1 @@\n-        TKit.createPropertiesFile(propFile, map);\n+        TKit.createPropertiesFile(propFile, props);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n+\n@@ -78,3 +80,1 @@\n-        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+        MacSign.withKeychain(keychain -> {\n@@ -89,2 +89,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -98,2 +96,30 @@\n-            cmd.execute(1);\n-        });\n+            MacHelper.useKeychain(cmd, keychain).execute(1);\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    @Test\n+    public static void testCodesignUnspecifiedFailure() throws IOException {\n+\n+        var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n+\n+        appImageCmd.executeIgnoreExitCode().assertExitCodeIsZero();\n+\n+        \/\/ This test expects jpackage to respond in a specific way on a codesign failure.\n+        \/\/ The simplest option to trigger codesign failure is to request the signing of an invalid bundle.\n+        \/\/ Create app content directory with the name known to fail signing.\n+        final var appContent = appImageCmd.appLayout().contentDirectory().resolve(\"foo.1\");\n+        Files.createDirectory(appContent);\n+        Files.createFile(appContent.resolve(\"file\"));\n+\n+        final List<CannedFormattedString> expectedStrings = new ArrayList<>();\n+        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n+\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = new JPackageCommand().setPackageType(PackageType.IMAGE)\n+                    .ignoreDefaultVerbose(true)\n+                    .validateOutput(expectedStrings.toArray(CannedFormattedString[]::new))\n+                    .addArguments(\"--app-image\", appImageCmd.outputBundle())\n+                    .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec().name());\n+\n+            MacHelper.useKeychain(cmd, keychain).execute(1);\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n@@ -119,4 +145,2 @@\n-        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -124,2 +148,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -132,1 +154,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.EXPIRED.keychain());\n@@ -151,4 +173,2 @@\n-        final var keychain = SigningBase.StandardKeychain.DUPLICATE.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -156,2 +176,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -164,1 +182,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.DUPLICATE.keychain());\n@@ -171,4 +189,2 @@\n-        final var keychain = SigningBase.StandardKeychain.MAIN.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -176,2 +192,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -183,1 +197,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacSignTest.java","additions":42,"deletions":28,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -26,3 +26,1 @@\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import java.nio.file.Path;\n@@ -30,0 +28,4 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacSign;\n@@ -71,0 +73,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, doSign, signingKey, certEnum);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private void test(MacSign.ResolvedKeychain keychain, boolean doSign, boolean signingKey, SigningBase.CertIndex certEnum) throws Exception {\n@@ -77,1 +85,1 @@\n-                    SigningBase.getKeyChain());\n+                    keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -26,0 +26,4 @@\n+import java.nio.file.Path;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +31,1 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacSign;\n@@ -29,3 +33,1 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.TKit;\n@@ -70,0 +72,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signAppImage, signingKey);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -81,1 +89,1 @@\n-                    SigningBase.getKeyChain());\n+                    keychain.name());\n@@ -106,1 +114,1 @@\n-            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n+            .addArguments(\"--mac-signing-keychain\", keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,0 +27,2 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +31,2 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacSign;\n@@ -30,3 +35,1 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.TKit;\n@@ -105,0 +108,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signAppImage, signingKey);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -115,1 +124,1 @@\n-                    \"--mac-signing-keychain\", SigningBase.getKeyChain());\n+                    \"--mac-signing-keychain\", keychain.name());\n@@ -136,1 +145,1 @@\n-            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n+            .addArguments(\"--mac-signing-keychain\", keychain.name());\n@@ -157,1 +166,1 @@\n-                                SigningBase.getKeyChain());\n+                                keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,0 +27,2 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,0 +31,2 @@\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacSign;\n@@ -29,3 +35,0 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n@@ -147,0 +150,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signingKey, signAppImage, signPKG, certEnum);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean signingKey, boolean signAppImage, boolean signPKG, SigningBase.CertIndex certEnum) throws Exception {\n@@ -154,1 +163,1 @@\n-                            \"--mac-signing-keychain\", SigningBase.getKeyChain());\n+                            \"--mac-signing-keychain\", keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,1 +27,12 @@\n-import jdk.jpackage.test.ApplicationLayout;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +40,6 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.MacSignVerify;\n+import jdk.jpackage.test.PackageFile;\n@@ -30,3 +48,1 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.TKit;\n@@ -35,14 +51,6 @@\n- * Note: Testing unsgined app image is done to verify support for per-user\n- * configuration by checking for PackageFile.\n- * Tests generation of dmg and pkg from signed or unsigned predefined app image.\n- * Test will generate pkg and verifies its signature. It verifies that dmg\n- * is not signed, but app image inside dmg is signed or unsigned. This test\n- * requires that the machine is configured with test certificate for\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n- * jpackagerTest keychain with\n- * always allowed access to this keychain for user which runs test.\n- * note:\n- * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n- * \"jpackage.mac.signing.key.user.name\", and\n- * \"jpackagerTest\" can be over-ridden by system property\n- * \"jpackage.mac.signing.keychain\"\n+ * Tests packaging of a signed\/unsigned predefined app image into a\n+ * signed\/unsigned .pkg or .dmg package.\n+ *\n+ * <p>\n+ * Prerequisites: A keychain with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN}.\n@@ -67,3 +75,23 @@\n-    private static void verifyPKG(JPackageCommand cmd) {\n-        if (!cmd.hasArgument(\"--mac-sign\")) {\n-            return; \/\/ Nothing to check if not signed\n+    @Test\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            spec.test(keychain);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    public record TestSpec(Optional<SignKeyOption> signAppImage, Map<PackageType, SignKeyOption> signPackage) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(signAppImage);\n+            Objects.requireNonNull(signPackage);\n+\n+            if ((signAppImage.isEmpty() && signPackage.isEmpty()) || !PackageType.MAC.containsAll(signPackage.keySet())) {\n+                \/\/ Unexpected package types.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            \/\/ Ensure stable result of toString() call.\n+            if (!SortedMap.class.isInstance(signPackage)) {\n+                signPackage = new TreeMap<>(signPackage);\n+            }\n@@ -72,4 +100,3 @@\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyPkgutil(outputBundle, true, SigningBase.DEFAULT_INDEX);\n-        SigningBase.verifySpctl(outputBundle, \"install\", SigningBase.DEFAULT_INDEX);\n-    }\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder();\n@@ -77,5 +104,3 @@\n-    private static void verifyDMG(JPackageCommand cmd) {\n-        \/\/ DMG always unsigned, so we will check it\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyDMG(outputBundle);\n-    }\n+            signAppImage.ifPresent(signOption -> {\n+                sb.append(String.format(\"app-image=%s\", signOption));\n+            });\n@@ -83,13 +108,2 @@\n-    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n-            \/\/ we only need to verify app.\n-            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n-                boolean isSigned = cmd.hasArgument(\"--mac-sign\");\n-                Path launcherPath = ApplicationLayout.platformAppImage()\n-                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n-                SigningBase.verifyCodesign(launcherPath, isSigned, SigningBase.DEFAULT_INDEX);\n-                SigningBase.verifyCodesign(dmgImage, isSigned, SigningBase.DEFAULT_INDEX);\n-                if (isSigned) {\n-                    SigningBase.verifySpctl(dmgImage, \"exec\", SigningBase.DEFAULT_INDEX);\n-                }\n+            if (!sb.isEmpty() && !signPackage.isEmpty()) {\n+                sb.append(\"; \");\n@@ -97,2 +111,0 @@\n-        });\n-    }\n@@ -100,23 +112,2 @@\n-    @Test\n-    \/\/ (Signed, \"signing-key or sign-identity\"})\n-    \/\/ Signed and signing-key\n-    @Parameter({\"true\", \"true\"})\n-    \/\/ Signed and signing-identity\n-    @Parameter({\"true\", \"false\"})\n-    \/\/ Unsigned\n-    @Parameter({\"false\", \"true\"})\n-    public static void test(boolean signAppImage, boolean signingKey) throws Exception {\n-        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n-\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n-        if (signAppImage) {\n-            appImageCmd.addArguments(\"--mac-sign\")\n-                       .addArguments(\"--mac-signing-keychain\",\n-                                     SigningBase.getKeyChain());\n-            if (signingKey) {\n-                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n-                                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-            } else {\n-                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n-                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+            if (!signPackage.isEmpty()) {\n+                sb.append(signPackage);\n@@ -124,0 +115,6 @@\n+\n+            return sb.toString();\n+        }\n+\n+        boolean signNativeBundle() {\n+            return signPackage.isEmpty();\n@@ -126,36 +123,127 @@\n-        new PackageTest()\n-                .addRunOnceInitializer(() -> appImageCmd.execute())\n-                .forTypes(PackageType.MAC)\n-                .addInitializer(cmd -> {\n-                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    cmd.removeArgumentWithValue(\"--input\");\n-                    if (signAppImage) {\n-                        cmd.addArguments(\"--mac-sign\",\n-                                \"--mac-signing-keychain\",\n-                                SigningBase.getKeyChain());\n-                        if (signingKey) {\n-                            cmd.addArguments(\"--mac-signing-key-user-name\",\n-                                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-                        } else {\n-                            cmd.addArguments(\"--mac-installer-sign-identity\",\n-                                    SigningBase.getInstallerCert(SigningBase.DEFAULT_INDEX));\n-                        }\n-                    }\n-                })\n-                .forTypes(PackageType.MAC_PKG)\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyPKG)\n-                .forTypes(PackageType.MAC_DMG)\n-                .addInitializer(cmd -> {\n-                    if (signAppImage && !signingKey) {\n-                        \/\/ jpackage throws expected error with\n-                        \/\/ --mac-installer-sign-identity and DMG type\n-                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n-                        \/\/ It will do nothing, but it signals test that app\n-                        \/\/ image itself is signed for verification.\n-                        cmd.addArguments(\"--mac-app-image-sign-identity\",\n-                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n-                    }\n-                })\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyDMG)\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyAppImageInDMG)\n-                .run();\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(Optional.ofNullable(signAppImage), signPackage);\n+            }\n+\n+            Builder certRequest(SigningBase.StandardCertificateRequest v) {\n+                return certRequest(v.spec());\n+            }\n+\n+            Builder certRequest(MacSign.CertificateRequest v) {\n+                certRequest = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder signIdentityType(SignKeyOption.Type v) {\n+                signIdentityType = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder signAppImage() {\n+                signAppImage = createSignKeyOption();\n+                return this;\n+            }\n+\n+            Builder signPackage(PackageType type) {\n+                Objects.requireNonNull(type);\n+                signPackage.put(type, createSignKeyOption());\n+                return this;\n+            }\n+\n+            Builder signPackage() {\n+                PackageType.MAC.forEach(this::signPackage);\n+                return this;\n+            }\n+\n+            private SignKeyOption createSignKeyOption() {\n+                return new SignKeyOption(signIdentityType, certRequest);\n+            }\n+\n+            private MacSign.CertificateRequest certRequest = SigningBase.StandardCertificateRequest.CODESIGN.spec();\n+            private SignKeyOption.Type signIdentityType = SignKeyOption.Type.SIGN_KEY_IDENTITY;\n+\n+            private SignKeyOption signAppImage;\n+            private Map<PackageType, SignKeyOption> signPackage = new HashMap<>();\n+        }\n+\n+        void test(MacSign.ResolvedKeychain keychain) {\n+\n+            var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n+            MacHelper.useKeychain(appImageCmd, keychain);\n+            signAppImage.ifPresent(signOption -> {\n+                signOption.setTo(appImageCmd);\n+            });\n+\n+            var test = new PackageTest();\n+\n+            signAppImage.map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n+                \/\/ The predefined app image is signed, verify bundled app image is signed too.\n+                test.addInstallVerifier(cmd -> {\n+                    MacSignVerify.verifyAppImageSigned(cmd, certRequest, keychain);\n+                });\n+            });\n+\n+            Optional.ofNullable(signPackage.get(PackageType.MAC_PKG)).map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n+                test.forTypes(PackageType.MAC_PKG, () -> {\n+                    test.addBundleVerifier(cmd -> {\n+                        MacSignVerify.verifyPkgSigned(cmd, certRequest, keychain);\n+                    });\n+                });\n+            });\n+\n+            test.forTypes(signPackage.keySet()).addRunOnceInitializer(() -> {\n+                appImageCmd.setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\")).execute(0);\n+            }).addInitializer(cmd -> {\n+                MacHelper.useKeychain(cmd, keychain);\n+                cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+                cmd.removeArgumentWithValue(\"--input\");\n+                Optional.ofNullable(signPackage.get(cmd.packageType())).ifPresent(signOption -> {\n+                    signOption.setTo(cmd);\n+                });\n+\n+                if (signAppImage.isPresent()) {\n+                    \/\/ Predefined app image is signed. Expect a warning.\n+                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\n+                            \"warning.per.user.app.image.signed\",\n+                            PackageFile.getPathInAppImage(Path.of(\"\"))));\n+                } else if (cmd.packageType() == PackageType.MAC_PKG && signPackage.containsKey(cmd.packageType())) {\n+                    \/\/ Create signed \".pkg\" bundle from the unsigned predefined app image. Expect a warning.\n+                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\"warning.unsigned.app.image\", \"pkg\"));\n+                }\n+            })\n+            .run();\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+\n+        List<TestSpec.Builder> data = new ArrayList<>();\n+\n+        Stream.of(SignKeyOption.Type.values()).flatMap(signIdentityType -> {\n+            return Stream.of(\n+                    \/\/ Sign both predefined app image and native package.\n+                    TestSpec.build().signIdentityType(signIdentityType)\n+                            .signAppImage()\n+                            .signPackage()\n+                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n+                            .signPackage(PackageType.MAC_PKG),\n+\n+                    \/\/ Don't sign predefined app image, sign native package.\n+                    TestSpec.build().signIdentityType(signIdentityType)\n+                            .signPackage()\n+                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n+                            .signPackage(PackageType.MAC_PKG),\n+\n+                    \/\/ Sign predefined app image, don't sign native package.\n+                    TestSpec.build().signIdentityType(signIdentityType).signAppImage()\n+            );\n+        }).forEach(data::add);\n+\n+        return data.stream().map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":194,"deletions":106,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -28,1 +30,0 @@\n-\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.test.MacSign;\n@@ -39,3 +41,3 @@\n- * Tests generation of dmg and pkg with --mac-sign and related arguments.\n- * Test will generate pkg and verifies its signature. It verifies that dmg\n- * is not signed, but runtime image inside dmg is signed.\n+ * Tests generation of dmg and pkg with --mac-sign and related arguments. Test\n+ * will generate pkg and verifies its signature. It verifies that dmg is not\n+ * signed, but runtime image inside dmg is signed.\n@@ -43,2 +45,3 @@\n- * Note: Specific UNICODE signing is not tested, since it is shared code\n- * with app image signing and it will be covered by SigningPackageTest.\n+ * <p>\n+ * Note: Specific UNICODE signing is not tested, since it is shared code with\n+ * app image signing and it will be covered by SigningPackageTest.\n@@ -46,0 +49,1 @@\n+ * <p>\n@@ -47,1 +51,2 @@\n- * 1) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n+ * <ol>\n+ * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n@@ -49,1 +54,1 @@\n- * 2) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n+ * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n@@ -51,1 +56,1 @@\n- * 3) \"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n+ * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n@@ -53,1 +58,1 @@\n- * 4) \"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n+ * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n@@ -55,1 +60,1 @@\n- * 5) \"--runtime-image\" points to JDK image and --mac-sign is not provided.\n+ * <li>\"--runtime-image\" points to JDK image and --mac-sign is not provided.\n@@ -57,1 +62,1 @@\n- * 6) \"--runtime-image\" points to JDK image and --mac-sign is provided.\n+ * <li>\"--runtime-image\" points to JDK image and --mac-sign is provided.\n@@ -59,0 +64,1 @@\n+ * <\/ol>\n@@ -61,4 +67,2 @@\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n- * jpackagerTest keychain with\n- * always allowed access to this keychain for user which runs test.\n- * note:\n+ * \"Developer ID Installer: jpackage.openjdk.java.net\" in jpackagerTest keychain\n+ * with always allowed access to this keychain for user which runs test. note:\n@@ -66,3 +70,1 @@\n- * \"jpackage.mac.signing.key.user.name\", and\n- * \"jpackagerTest\" can be over-ridden by system property\n- * \"jpackage.mac.signing.keychain\"\n+ * \"jpackage.mac.signing.key.user.name\"\n@@ -87,1 +89,1 @@\n-    private static JPackageCommand addSignOptions(JPackageCommand cmd, int certIndex) {\n+    private static JPackageCommand addSignOptions(JPackageCommand cmd, MacSign.ResolvedKeychain keychain, int certIndex) {\n@@ -91,1 +93,1 @@\n-                    \"--mac-signing-keychain\", SigningBase.getKeyChain(),\n+                    \"--mac-signing-keychain\", keychain.name(),\n@@ -97,1 +99,1 @@\n-    private static Path createInputRuntimeBundle(int certIndex) throws IOException {\n+    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) throws IOException {\n@@ -114,1 +116,1 @@\n-        addSignOptions(cmd, certIndex);\n+        addSignOptions(cmd, keychain, certIndex);\n@@ -150,0 +152,8 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, useJDKBundle, jdkBundleCert, signCert);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean useJDKBundle,\n+            SigningBase.CertIndex jdkBundleCert,\n+            SigningBase.CertIndex signCert) throws Exception {\n@@ -156,1 +166,1 @@\n-                        inputRuntime[0] = createInputRuntimeBundle(jdkBundleCert.value());\n+                        inputRuntime[0] = createInputRuntimeBundle(keychain, jdkBundleCert.value());\n@@ -167,1 +177,1 @@\n-                    addSignOptions(cmd, signCert.value());\n+                    addSignOptions(cmd, keychain, signCert.value());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+    \/**\n+     * Standard keychains used in signing tests.\n+     *\/\n@@ -94,1 +97,4 @@\n-        MAIN(DEFAULT_KEYCHAIN,\n+        \/**\n+         * The primary keychain with good certificates.\n+         *\/\n+        MAIN(\"jpackagerTest.keychain\",\n@@ -99,0 +105,3 @@\n+        \/**\n+         * A keychain with some good and some expired certificates.\n+         *\/\n@@ -104,0 +113,3 @@\n+        \/**\n+         * A keychain with duplicated certificates.\n+         *\/\n@@ -117,1 +129,1 @@\n-            this.spec = new ResolvedKeychain(builder.create());\n+            this.keychain = new ResolvedKeychain(builder.create());\n@@ -120,2 +132,2 @@\n-        public KeychainWithCertsSpec spec() {\n-            return spec.spec();\n+        public ResolvedKeychain keychain() {\n+            return keychain;\n@@ -125,1 +137,1 @@\n-            return Objects.requireNonNull(spec.mapCertificateRequests().get(certRequest));\n+            return Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest));\n@@ -132,4 +144,0 @@\n-        private static CertificateRequest.Builder cert() {\n-            return new CertificateRequest.Builder();\n-        }\n-\n@@ -137,1 +145,1 @@\n-            return Stream.of(values()).map(StandardKeychain::spec).toList();\n+            return Stream.of(values()).map(StandardKeychain::keychain).map(ResolvedKeychain::spec).toList();\n@@ -140,1 +148,1 @@\n-        private final ResolvedKeychain spec;\n+        private final ResolvedKeychain keychain;\n@@ -182,1 +190,0 @@\n-    private static String DEFAULT_KEYCHAIN = \"jpackagerTest.keychain\";\n@@ -198,10 +205,0 @@\n-    \/\/ Returns 'true' if dev name from DEV_NAMES\n-    public static boolean isDevNameDefault() {\n-        String value = System.getProperty(\"jpackage.mac.signing.key.user.name\");\n-        if (value != null) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n@@ -216,10 +213,0 @@\n-    public static String getKeyChain() {\n-        \/\/ Always use values from system properties if set\n-        String value = System.getProperty(\"jpackage.mac.signing.keychain\");\n-        if (value != null) {\n-            return value;\n-        }\n-\n-        return DEFAULT_KEYCHAIN;\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -121,0 +121,6 @@\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and launchers will be attempted to be executed through their shortcuts.\n+            packageTest.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import java.nio.file.Path;\n-import java.util.Map;\n@@ -27,2 +25,3 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.FileAssociations;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import jdk.internal.util.OperatingSystem;\n@@ -30,0 +29,5 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.CfgFile;\n+import jdk.jpackage.test.ConfigurationTarget;\n+import jdk.jpackage.test.FileAssociations;\n@@ -32,0 +36,3 @@\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n@@ -33,3 +40,0 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.CfgFile;\n@@ -236,0 +240,55 @@\n+    \/**\n+     * Test --description option\n+     *\/\n+    @Test(ifNotOS = OperatingSystem.MACOS) \/\/ Don't run on macOS as launcher description is ignored on this platform\n+    @Parameter(\"true\")\n+    @Parameter(\"fase\")\n+    public void testDescription(boolean withPredefinedAppImage) {\n+\n+        ConfigurationTarget target;\n+        if (TKit.isWindows() || withPredefinedAppImage) {\n+            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n+        } else {\n+            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n+        }\n+\n+        target.addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--name\", \"Foo\").setArgumentValue(\"--description\", \"Hello\");\n+            cmd.setFakeRuntime();\n+            cmd.setStandardAsserts(JPackageCommand.StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n+        });\n+\n+        target.add(new AdditionalLauncher(\"x\"));\n+        target.add(new AdditionalLauncher(\"bye\").setProperty(\"description\", \"Bye\"));\n+\n+        target.test().ifPresent(test -> {\n+            \/\/ Make all launchers have shortcuts and thus .desktop files.\n+            \/\/ Launcher description is recorded in a desktop file and verified automatically.\n+            test.mutate(addLinuxShortcuts());\n+        });\n+\n+        target.cmd().ifPresent(withPredefinedAppImage ? JPackageCommand::execute : JPackageCommand::executeAndAssertImageCreated);\n+        target.test().ifPresent(test -> {\n+            test.run(Action.CREATE_AND_UNPACK);\n+        });\n+\n+        if (withPredefinedAppImage) {\n+            new PackageTest().addInitializer(cmd -> {\n+                cmd.setArgumentValue(\"--name\", \"Bar\");\n+                \/\/ Should not have impact of launcher descriptions, but it does.\n+                cmd.setArgumentValue(\"--description\", \"Installer\");\n+                cmd.removeArgumentWithValue(\"--input\").setArgumentValue(\"--app-image\", target.cmd().orElseThrow().outputBundle());\n+            }).mutate(addLinuxShortcuts()).run(Action.CREATE_AND_UNPACK);\n+        }\n+    }\n+\n+    private static Consumer<PackageTest> addLinuxShortcuts() {\n+        return test -> {\n+            test.forTypes(PackageType.LINUX, () -> {\n+                test.addInitializer(cmd -> {\n+                    cmd.addArgument(\"--linux-shortcut\");\n+                });\n+            });\n+        };\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.AppImageFile;\n+import jdk.jpackage.test.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary test order in which jpackage fills app image\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror AppImageFillOrderTest.java\n+ * @run main\/othervm\/timeout=1440 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=AppImageFillOrderTest\n+ *\/\n+\n+\/**\n+ * Test order in which overlapping items are added to the app image. jpackage\n+ * defaults should go first to let user-provided content override them.\n+ *\n+ * <p>\n+ * Custom content comes from:\n+ * <ul>\n+ * <li>input directory (--input)\n+ * <li>app content (--app-content)\n+ * <ul>\n+ *\/\n+public class AppImageFillOrderTest {\n+\n+    @Test\n+    @ParameterSupplier\n+    public void test(AppImageOverlay overlays[]) {\n+        test(createJPackage().setFakeRuntime(), overlays);\n+    }\n+\n+    \/**\n+     * Test they can override a file in the runtime.\n+     * @param jlink\n+     *\/\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testRuntime(boolean jlink) {\n+        var cmd = createJPackage();\n+        if (jlink) {\n+            cmd.ignoreDefaultRuntime(true);\n+        } else {\n+            \/\/ Configure fake runtime and create it.\n+            cmd.setFakeRuntime().executePrerequisiteActions();\n+\n+            var runtimeDir = Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n+            if (!runtimeDir.toAbsolutePath().normalize().startsWith(TKit.workDir().toAbsolutePath().normalize())) {\n+                throw new IllegalStateException(String.format(\n+                        \"Fake runtime [%s] created outside of the test work directory [%s]\",\n+                        runtimeDir, TKit.workDir()));\n+            }\n+\n+            TKit.createTextFile(runtimeDir.resolve(RUNTIME_RELEASE_FILE), List.of(\"Foo release\"));\n+        }\n+\n+        test(cmd, AppImageAppContentOverlay.APP_CONTENT_RUNTIME_RELEASE_FILE);\n+    }\n+\n+    \/**\n+     * Test they can not override .jpackage.xml file.\n+     * @throws IOException\n+     *\/\n+    @Test\n+    public void testAppImageFile() throws IOException {\n+\n+        var cmd = createJPackage().setFakeRuntime();\n+\n+        var outputBundle = cmd.outputBundle();\n+\n+        buildOverlay(cmd, TKit.createTempDirectory(\"app-content\"), AppImageFile.getPathInAppImage(outputBundle))\n+                .textContent(\"This is not a valid XML content\")\n+                .configureCmdOptions().createOverlayFile();\n+\n+        \/\/ Run jpackage and verify it created valid .jpackage.xml file ignoring the overlay.\n+        cmd.executeAndAssertImageCreated();\n+\n+        TKit.trace(String.format(\"Parse [%s] file...\", AppImageFile.getPathInAppImage(outputBundle)));\n+        AppImageFile.load(outputBundle);\n+    }\n+\n+    private static void test(JPackageCommand cmd, AppImageOverlay... overlays) {\n+        if (overlays.length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        final var outputDir = Path.of(cmd.getArgumentValue(\"--dest\"));\n+        final var noOverlaysOutputDir = Path.of(outputDir.toString() + \"-no-overlay\");\n+        cmd.setArgumentValue(\"--dest\", noOverlaysOutputDir);\n+\n+        \/\/ Run the command without overlays with redirected output directory.\n+        cmd.execute();\n+\n+        final Optional<Path> appContentRoot;\n+        if (Stream.of(overlays).anyMatch(AppImageAppContentOverlay.class::isInstance)) {\n+            appContentRoot = Optional.of(TKit.createTempDirectory(\"app-content\"));\n+        } else {\n+            appContentRoot = Optional.empty();\n+        }\n+\n+        \/\/ Apply overlays to the command.\n+        var fileCopies = Stream.of(overlays).map(overlay -> {\n+            switch (overlay) {\n+                case AppImageDefaultOverlay v -> {\n+                    return v.addOverlay(cmd);\n+                }\n+                case AppImageAppContentOverlay v -> {\n+                    return v.addOverlay(cmd, appContentRoot.orElseThrow());\n+                }\n+            }\n+        }).flatMap(Collection::stream).collect(toMap(FileCopy::out, x -> x, (a, b) -> {\n+            return b;\n+        }, TreeMap::new)).values().stream().toList();\n+\n+        \/\/ Collect paths in the app image that will be affected by overlays.\n+        var noOverlayOutputPaths = fileCopies.stream().map(FileCopy::out).toList();\n+\n+        fileCopies = fileCopies.stream().map(v -> {\n+            return new FileCopy(v.in(), outputDir.resolve(noOverlaysOutputDir.relativize(v.out())));\n+        }).toList();\n+\n+        \/\/ Restore the original output directory for the command and execute it.\n+        cmd.setArgumentValue(\"--dest\", outputDir).execute();\n+\n+        for (var i = 0; i != fileCopies.size(); i++) {\n+            var noOverlayPath = noOverlayOutputPaths.get(i);\n+            var fc = fileCopies.get(i);\n+            TKit.assertSameFileContent(fc.in(), fc.out());\n+            TKit.assertMismatchFileContent(noOverlayPath, fc.out());\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir.\n+                List.of(AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir and from the app content dir.\n+                \/\/ The one from app content should win.\n+                List.<AppImageOverlay>of(\n+                        AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG,\n+                        AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG\n+                ),\n+\n+                \/\/ Overwrite main jar from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_JAR)\n+        ).map(args -> {\n+            return args.toArray(AppImageOverlay[]::new);\n+        }).map(args -> {\n+            return new Object[] {args};\n+        }).toList();\n+    }\n+\n+\n+    public sealed interface AppImageOverlay {\n+    }\n+\n+\n+    private enum AppImageDefaultOverlay implements AppImageOverlay {\n+        INPUT_MAIN_LAUNCHER_CFG(AppImageFillOrderTest::replaceMainLauncherCfgFile),\n+        ;\n+\n+        AppImageDefaultOverlay(Function<JPackageCommand, FileCopy> func) {\n+            Objects.requireNonNull(func);\n+            this.func = cmd -> {\n+                return List.of(func.apply(cmd));\n+            };\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd) {\n+            return func.apply(cmd);\n+        }\n+\n+        private final Function<JPackageCommand, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private enum AppImageAppContentOverlay implements AppImageOverlay {\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the app content.\n+        APP_CONTENT_MAIN_LAUNCHER_CFG((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLauncherCfgPath(null))\n+                    .textContent(\"!Olleh\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+\n+        \/\/ Replace the jar file that jpackage will pick up from the input directory with the custom one.\n+        APP_CONTENT_MAIN_JAR((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLayout().appDirectory().resolve(cmd.getArgumentValue(\"--main-jar\")))\n+                    .textContent(\"Surprise!\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+\n+        \/\/ Replace \"release\" file in the runtime directory.\n+        APP_CONTENT_RUNTIME_RELEASE_FILE((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLayout().runtimeHomeDirectory().resolve(\"release\"))\n+                    .textContent(\"blob\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+        ;\n+\n+        AppImageAppContentOverlay(BiFunction<JPackageCommand, Path, FileCopy> func) {\n+            Objects.requireNonNull(func);\n+            this.func = (cmd, appContentRoot) -> {\n+                return List.of(func.apply(cmd, appContentRoot));\n+            };\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd, Path appContentRoot) {\n+            return func.apply(cmd, appContentRoot);\n+        }\n+\n+        private final BiFunction<JPackageCommand, Path, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private record FileCopy(Path in, Path out) {\n+        FileCopy {\n+            Objects.requireNonNull(in);\n+            Objects.requireNonNull(out);\n+        }\n+    }\n+\n+\n+    private static FileCopy replaceMainLauncherCfgFile(JPackageCommand cmd) {\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the input dir.\n+        final var outputFile = cmd.appLauncherCfgPath(null);\n+\n+        final var inputDir = Path.of(cmd.getArgumentValue(\"--input\"));\n+\n+        final var file = inputDir.resolve(outputFile.getFileName());\n+\n+        TKit.createTextFile(file, List.of(\"Hello!\"));\n+\n+        return new FileCopy(file, outputFile);\n+    }\n+\n+    private static AppContentOverlayFileBuilder buildOverlay(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n+        return new AppContentOverlayFileBuilder(cmd, appContentRoot, outputFile);\n+    }\n+\n+\n+    private static final class AppContentOverlayFileBuilder {\n+\n+        AppContentOverlayFileBuilder(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n+            if (outputFile.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (!outputFile.startsWith(cmd.outputBundle())) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.cmd = Objects.requireNonNull(cmd);\n+            this.outputFile = Objects.requireNonNull(outputFile);\n+            this.appContentRoot = Objects.requireNonNull(appContentRoot);\n+        }\n+\n+        FileCopy createOverlayFile() {\n+            final var file = appContentRoot.resolve(pathInAppContentDirectory());\n+\n+            try {\n+                Files.createDirectories(file.getParent());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            fileContentInitializer.accept(file);\n+\n+            return new FileCopy(file, outputFile);\n+        }\n+\n+        AppContentOverlayFileBuilder configureCmdOptions() {\n+            cmd.addArguments(\"--app-content\", appContentRoot.resolve(pathInAppContentDirectory().getName(0)));\n+            return this;\n+        }\n+\n+        AppContentOverlayFileBuilder content(Consumer<Path> v) {\n+            fileContentInitializer = v;\n+            return this;\n+        }\n+\n+        AppContentOverlayFileBuilder textContent(String... lines) {\n+            return content(path -> {\n+                TKit.createTextFile(path, List.of(lines));\n+            });\n+        }\n+\n+        private Path pathInAppContentDirectory() {\n+            return APP_IMAGE_LAYOUT.resolveAt(cmd.outputBundle()).contentDirectory().relativize(outputFile);\n+        }\n+\n+        private Consumer<Path> fileContentInitializer;\n+        private final JPackageCommand cmd;\n+        private final Path outputFile;\n+        private final Path appContentRoot;\n+    }\n+\n+\n+    private static JPackageCommand createJPackage() {\n+        \/\/ With short name.\n+        var cmd = JPackageCommand.helloAppImage().setArgumentValue(\"--name\", \"Foo\");\n+\n+        \/\/ Clean leftovers in the input dir from the previous test run if any.\n+        TKit.deleteDirectoryContentsRecursive(cmd.inputDir());\n+\n+        return cmd;\n+    }\n+\n+    private static final ApplicationLayout APP_IMAGE_LAYOUT = ApplicationLayout.platformAppImage();\n+    private static final Path RUNTIME_RELEASE_FILE = Path.of(\"release\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImageFillOrderTest.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -24,2 +24,0 @@\n-import java.nio.file.Path;\n-import java.nio.file.Files;\n@@ -27,1 +25,3 @@\n-import java.util.List;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n@@ -29,1 +29,0 @@\n-import jdk.jpackage.test.AppImageFile;\n@@ -31,0 +30,2 @@\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.AppImageFile;\n@@ -32,1 +33,0 @@\n-import jdk.jpackage.test.TKit;\n@@ -34,0 +34,1 @@\n+import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -37,1 +38,1 @@\n-import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.TKit;\n@@ -58,0 +59,3 @@\n+    \/**\n+     * Create a native bundle from a valid predefined app image produced by jpackage.\n+     *\/\n@@ -60,1 +64,0 @@\n-        Path appimageOutput = TKit.workDir().resolve(\"appimage\");\n@@ -62,2 +65,2 @@\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n@@ -66,1 +69,1 @@\n-        .addRunOnceInitializer(() -> appImageCmd.execute())\n+        .addRunOnceInitializer(appImageCmd::execute)\n@@ -73,0 +76,7 @@\n+    \/**\n+     * Create a native bundle from a predefined app image not produced by jpackage\n+     * but having a valid \".jpackage.xml\" file.\n+     *\n+     * @param withIcon {@code true} if jpackage command line should have \"--icon\"\n+     *                 option\n+     *\/\n@@ -77,3 +87,0 @@\n-        final String name = \"EmptyAppImagePackageTest\";\n-        final String imageName = name + (TKit.isOSX() ? \".app\" : \"\");\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\").resolve(imageName);\n@@ -81,4 +88,4 @@\n-        Files.createDirectories(appImageDir.resolve(\"bin\"));\n-        Path libDir = Files.createDirectories(appImageDir.resolve(\"lib\"));\n-        TKit.createTextFile(libDir.resolve(\"README\"),\n-                List.of(\"This is some arbitrary text for the README file\\n\"));\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setFakeRuntime()\n+                .setArgumentValue(\"--name\", \"EmptyAppImagePackageTest\")\n+                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n@@ -87,0 +94,25 @@\n+        .addRunOnceInitializer(appImageCmd::execute)\n+        .addRunOnceInitializer(() -> {\n+            var layout = appImageCmd.appLayout();\n+            if (!TKit.isOSX()) {\n+                \/\/ Delete the launcher if not on macOS.\n+                \/\/ On macOS, deleting the launcher will render the app bundle invalid.\n+                TKit.deleteIfExists(appImageCmd.appLauncherPath());\n+            }\n+            \/\/ Delete the runtime.\n+            TKit.deleteDirectoryRecursive(layout.runtimeDirectory());\n+            \/\/ Delete the \"app\" dir.\n+            TKit.deleteDirectoryRecursive(layout.appDirectory());\n+\n+            new AppImageFile(appImageCmd.name(), \"PhonyMainClass\").save(appImageCmd.outputBundle());\n+            var appImageDir = appImageCmd.outputBundle();\n+\n+            TKit.trace(String.format(\"Files in [%s] app image:\", appImageDir));\n+            try (var files = Files.walk(appImageDir)) {\n+                files.sequential()\n+                        .filter(Predicate.isEqual(appImageDir).negate())\n+                        .map(path -> String.format(\"[%s]\", appImageDir.relativize(path)))\n+                        .forEachOrdered(TKit::trace);\n+                TKit.trace(\"Done\");\n+            }\n+        })\n@@ -88,1 +120,1 @@\n-            cmd.addArguments(\"--app-image\", appImageDir);\n+            cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n@@ -93,1 +125,0 @@\n-            new AppImageFile(\"EmptyAppImagePackageTest\", \"Hello\").save(appImageDir);\n@@ -95,5 +126,5 @@\n-            \/\/ on mac, with --app-image and without --mac-package-identifier,\n-            \/\/ will try to infer it from the image, so foreign image needs it.\n-            if (TKit.isOSX()) {\n-                cmd.addArguments(\"--mac-package-identifier\", name);\n-            }\n+            cmd.excludeStandardAsserts(\n+                    StandardAssert.MAIN_JAR_FILE,\n+                    StandardAssert.MAIN_LAUNCHER_FILES,\n+                    StandardAssert.MAC_BUNDLE_STRUCTURE,\n+                    StandardAssert.RUNTIME_DIRECTORY);\n@@ -101,5 +132,1 @@\n-        \/\/ On macOS we always signing app image and signing will fail, since\n-        \/\/ test produces invalid app bundle.\n-        .setExpectedExitCode(TKit.isOSX() ? 1 : 0)\n-        .run(Action.CREATE, Action.UNPACK);\n-        \/\/ default: {CREATE, UNPACK, VERIFY}, but we can't verify foreign image\n+        .run(Action.CREATE_AND_UNPACK);\n@@ -108,0 +135,4 @@\n+    \/**\n+     * Bad predefined app image - not an output of jpackage.\n+     * jpackage command using the bad predefined app image doesn't have \"--name\" option.\n+     *\/\n@@ -117,0 +148,3 @@\n+    \/**\n+     * Bad predefined app image - not an output of jpackage.\n+     *\/\n@@ -124,0 +158,3 @@\n+    \/**\n+     * Bad predefined app image - valid app image missing \".jpackage.xml\" file.\n+     *\/\n@@ -125,1 +162,1 @@\n-    public static void testBadAppImage3() throws IOException {\n+    public static void testBadAppImage3() {\n@@ -137,0 +174,3 @@\n+    \/**\n+     * Bad predefined app image - valid app image with invalid \".jpackage.xml\" file.\n+     *\/\n@@ -138,1 +178,1 @@\n-    public static void testBadAppImageFile() throws IOException {\n+    public static void testBadAppImageFile() {\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":71,"deletions":31,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import static java.util.Map.entry;\n@@ -27,0 +28,1 @@\n+import java.util.List;\n@@ -28,0 +30,1 @@\n+import java.util.TreeMap;\n@@ -117,3 +120,3 @@\n-            TKit.createPropertiesFile(propFile, Map.of(\n-                \"extension\", \"foo\",\n-                \"description\", \"bar\"\n+            TKit.createPropertiesFile(propFile, List.of(\n+                    entry(\"extension\", \"foo\"),\n+                    entry(\"description\", \"bar\")\n@@ -134,4 +137,4 @@\n-            TKit.createPropertiesFile(propFile, Map.of(\n-                \"mime-type\", \"application\/x-jpackage-foo, application\/x-jpackage-bar\",\n-                \"extension\", \"foo\",\n-                \"description\", \"bar\"\n+            TKit.createPropertiesFile(propFile, List.of(\n+                    entry(\"mime-type\", \"application\/x-jpackage-foo, application\/x-jpackage-bar\"),\n+                    entry(\"extension\", \"foo\"),\n+                    entry(\"description\", \"bar\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/FileAssociationsTest.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n@@ -25,3 +27,1 @@\n-import java.util.stream.Stream;\n-import java.util.stream.Collectors;\n-import java.util.function.Consumer;\n+import java.io.UncheckedIOException;\n@@ -35,0 +35,1 @@\n+import java.util.Objects;\n@@ -37,8 +38,3 @@\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.LauncherIconVerifier;\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.Executor;\n-import jdk.jpackage.test.LinuxHelper;\n-import jdk.jpackage.test.AdditionalLauncher;\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -46,0 +42,2 @@\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.AdditionalLauncher;\n@@ -48,0 +46,9 @@\n+import jdk.jpackage.test.CannedFormattedString;\n+import jdk.jpackage.test.ConfigurationTarget;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.LauncherIconVerifier;\n+import jdk.jpackage.test.LinuxHelper;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.TKit;\n@@ -95,1 +102,1 @@\n-        config = Map.of(\n+        config = new TreeMap<>(Map.of(\n@@ -97,1 +104,1 @@\n-                Launcher.Additional, additionalLauncherIconType);\n+                Launcher.Additional, additionalLauncherIconType));\n@@ -104,1 +111,1 @@\n-        config = Map.of(\n+        config = new TreeMap<>(Map.of(\n@@ -106,1 +113,1 @@\n-                Launcher.Additional, additionalLauncherIconType);\n+                Launcher.Additional, additionalLauncherIconType));\n@@ -161,0 +168,2 @@\n+\n+        final ConfigurationTarget target;\n@@ -162,4 +171,1 @@\n-            JPackageCommand cmd = initAppImageTest();\n-            var result = cmd.executeAndAssertImageCreated();\n-            ThrowingConsumer.toConsumer(createInstallVerifier()).accept(cmd);\n-            ThrowingBiConsumer.toBiConsumer(createBundleVerifier()).accept(cmd, result);\n+            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n@@ -167,3 +173,7 @@\n-            PackageTest test = initPackageTest();\n-            test.addInstallVerifier(createInstallVerifier());\n-            test.addBundleVerifier(createBundleVerifier());\n+            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n+        }\n+\n+        initTest(target);\n+\n+        var installVerifier = createInstallVerifier();\n+        var bundleVerifier = createBundleVerifier();\n@@ -171,0 +181,8 @@\n+        var cmdResult = target.cmd().map(JPackageCommand::executeAndAssertImageCreated);\n+\n+        target.apply(ThrowingConsumer.toConsumer(installVerifier), test -> {\n+            test.addInstallVerifier(installVerifier);\n+        }).apply(cmd -> {\n+            ThrowingBiConsumer.toBiConsumer(bundleVerifier).accept(cmd, cmdResult.orElseThrow());\n+        }, test -> {\n+            test.addBundleVerifier(bundleVerifier);\n@@ -173,0 +191,1 @@\n+        });\n@@ -174,2 +193,3 @@\n-            test.run(PackageTest.Action.CREATE_AND_UNPACK);\n-        }\n+        target.test().ifPresent(v -> {\n+            v.run(PackageTest.Action.CREATE_AND_UNPACK);\n+        });\n@@ -179,3 +199,0 @@\n-        if (appImage) {\n-            return false;\n-        }\n@@ -191,11 +208,2 @@\n-            var verifier = createConsoleOutputVerifier(cmd.name(), config.get(\n-                    Launcher.Main), null);\n-            if (verifier != null) {\n-                verifier.apply(result.getOutput());\n-            }\n-\n-            if (config.containsKey(Launcher.Additional)) {\n-                verifier = createConsoleOutputVerifier(\n-                        Launcher.Additional.launcherName, config.get(\n-                                Launcher.Additional), config.get(Launcher.Main));\n-                if (verifier != null) {\n+            Stream.of(Launcher.Main, Launcher.Additional).filter(config::containsKey).forEach(launcher -> {\n+                createConsoleOutputVerifier(cmd, launcher).ifPresent(verifier -> {\n@@ -203,2 +211,2 @@\n-                }\n-            }\n+                });\n+            });\n@@ -208,4 +216,14 @@\n-    private TKit.TextStreamVerifier createConsoleOutputVerifier(\n-            String launcherName, IconType iconType, IconType mainIconType) {\n-        if (iconType == IconType.DefaultIcon && mainIconType != null) {\n-            iconType = mainIconType;\n+    private Optional<TKit.TextStreamVerifier> createConsoleOutputVerifier(\n+            JPackageCommand cmd, Launcher launcher) {\n+\n+        var launcherName = Optional.ofNullable(launcher.launcherName).orElseGet(cmd::name);\n+        var resourceName = launcherName;\n+        Optional<Path> customIcon;\n+\n+        if (launcherName.equals(cmd.name())) {\n+            customIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of);\n+        } else if (config.get(launcher) == IconType.DefaultIcon) {\n+            resourceName = cmd.name();\n+            customIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of);\n+        } else {\n+            customIcon = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"icon\").map(Path::of);\n@@ -213,1 +231,6 @@\n-        return createConsoleOutputVerifier(launcherName, iconType);\n+\n+        return createConsoleOutputVerifier(\n+                getBundleIconType(cmd, launcher),\n+                launcherName,\n+                resourceName,\n+                customIcon);\n@@ -216,3 +239,9 @@\n-    private static TKit.TextStreamVerifier createConsoleOutputVerifier(\n-            String launcherName, IconType iconType) {\n-        String lookupString = null;\n+    private static Optional<TKit.TextStreamVerifier> createConsoleOutputVerifier(\n+            IconType iconType, String launcherName, String resourceName, Optional<Path> customIcon) {\n+\n+        Objects.requireNonNull(launcherName);\n+        Objects.requireNonNull(resourceName);\n+        Objects.requireNonNull(customIcon);\n+\n+        CannedFormattedString lookupString;\n+\n@@ -221,2 +250,2 @@\n-                lookupString = String.format(\n-                        \"Using default package resource %s [icon] (add %s%s to the resource-dir to customize)\",\n+                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"message.using-default-resource\",\n@@ -224,1 +253,2 @@\n-                        launcherName, TKit.ICON_SUFFIX);\n+                        \"[icon]\",\n+                        launcherName + TKit.ICON_SUFFIX);\n@@ -228,3 +258,4 @@\n-                lookupString = String.format(\n-                        \"Using custom package resource [icon] (loaded from %s%s)\",\n-                        launcherName, TKit.ICON_SUFFIX);\n+                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"message.using-custom-resource\",\n+                        \"[icon]\",\n+                        resourceName + TKit.ICON_SUFFIX);\n@@ -235,1 +266,4 @@\n-                lookupString = \"Using custom package resource [icon] (loaded from file\";\n+                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"message.using-custom-resource-from-file\",\n+                        \"[icon]\",\n+                        customIcon.orElseThrow());\n@@ -239,1 +273,1 @@\n-                return null;\n+                return Optional.empty();\n@@ -242,1 +276,1 @@\n-        return TKit.assertTextStream(lookupString);\n+        return Optional.of(TKit.assertTextStream(lookupString.getValue()));\n@@ -246,5 +280,2 @@\n-        LauncherIconVerifier verifier = new LauncherIconVerifier();\n-        switch (config.get(Launcher.Main)) {\n-            case NoIcon:\n-                verifier.setExpectedIcon(null);\n-                break;\n+        return cmd -> {\n+            var verifier = new LauncherIconVerifier();\n@@ -252,3 +283,1 @@\n-            case DefaultIcon:\n-                verifier.setExpectedDefaultIcon();\n-                break;\n+            var bundleIconType = getBundleIconType(cmd, Launcher.Main);\n@@ -256,3 +285,4 @@\n-            case CustomIcon:\n-                verifier.setExpectedIcon(Launcher.Main.cmdlineIcon);\n-                break;\n+            switch (bundleIconType) {\n+                case NoIcon:\n+                    verifier.setExpectedNoIcon();\n+                    break;\n@@ -260,3 +290,3 @@\n-            case ResourceDirIcon:\n-                verifier.setExpectedIcon(Launcher.Main.resourceDirIcon);\n-                break;\n+                case DefaultIcon:\n+                    verifier.setExpectedDefaultIcon();\n+                    break;\n@@ -264,4 +294,12 @@\n-            case CustomWithResourceDirIcon:\n-                verifier.setExpectedIcon(Launcher.Main2.cmdlineIcon);\n-                break;\n-        }\n+                case CustomIcon:\n+                    verifier.setExpectedIcon(Launcher.Main.cmdlineIcon);\n+                    break;\n+\n+                case ResourceDirIcon:\n+                    verifier.setExpectedIcon(Launcher.Main.resourceDirIcon);\n+                    break;\n+\n+                case CustomWithResourceDirIcon:\n+                    verifier.setExpectedIcon(Launcher.Main2.cmdlineIcon);\n+                    break;\n+            }\n@@ -269,1 +307,0 @@\n-        return cmd -> {\n@@ -271,0 +308,1 @@\n+\n@@ -273,1 +311,1 @@\n-                if (isWithDesktopIntegration(config.get(Launcher.Main))) {\n+                if (isWithDesktopIntegration(bundleIconType)) {\n@@ -282,1 +320,1 @@\n-    private void initTest(JPackageCommand cmd, PackageTest test) {\n+    private void initTest(ConfigurationTarget target) {\n@@ -284,1 +322,1 @@\n-            initTest(entry.getKey(), entry.getValue(), cmd, test);\n+            initTest(entry.getKey(), entry.getValue(), target);\n@@ -287,11 +325,5 @@\n-        ThrowingConsumer<JPackageCommand> initializer = testCmd -> {\n-            testCmd.saveConsoleOutput(true);\n-            testCmd.setFakeRuntime();\n-            testCmd.addArguments(extraJPackageArgs);\n-        };\n-\n-        if (test != null) {\n-            test.addInitializer(initializer);\n-        } else {\n-            ThrowingConsumer.toConsumer(initializer).accept(cmd);\n-        }\n+        target.addInitializer(cmd -> {\n+            cmd.saveConsoleOutput(true);\n+            cmd.setFakeRuntime();\n+            cmd.addArguments(extraJPackageArgs);\n+        });\n@@ -301,8 +333,1 @@\n-            JPackageCommand cmd, PackageTest test) throws IOException {\n-        Consumer<AdditionalLauncher> addLauncher = v -> {\n-            if (test != null) {\n-                v.applyTo(test);\n-            } else {\n-                v.applyTo(cmd);\n-            }\n-        };\n+            ConfigurationTarget target) throws IOException {\n@@ -312,3 +337,2 @@\n-                if (cfg.launcherName != null) {\n-                    addLauncher.accept(new AdditionalLauncher(cfg.launcherName));\n-                }\n+                Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n+                        .ifPresent(target::add);\n@@ -318,4 +342,3 @@\n-                if (cfg.launcherName != null) {\n-                    addLauncher.accept(\n-                            new AdditionalLauncher(cfg.launcherName).setNoIcon());\n-                }\n+                Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n+                        .map(AdditionalLauncher::setNoIcon)\n+                        .ifPresent(target::add);\n@@ -325,5 +348,1 @@\n-                if (test != null) {\n-                    addCustomIcon(null, test, cfg.launcherName, cfg.cmdlineIcon);\n-                } else {\n-                    addCustomIcon(cmd, null, cfg.launcherName, cfg.cmdlineIcon);\n-                }\n+                addCustomIcon(target, cfg.launcherName, cfg.cmdlineIcon);\n@@ -333,10 +352,3 @@\n-                if (Launcher.PRIMARY.contains(cfg) && cfg.launcherName != null) {\n-                    addLauncher.accept(new AdditionalLauncher(cfg.launcherName));\n-                }\n-                if (test != null) {\n-                    test.addInitializer(testCmd -> {\n-                        addResourceDirIcon(testCmd, cfg.launcherName,\n-                                cfg.resourceDirIcon);\n-                    });\n-                } else {\n-                    addResourceDirIcon(cmd, cfg.launcherName, cfg.resourceDirIcon);\n+                if (Launcher.PRIMARY.contains(cfg)) {\n+                    Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n+                            .ifPresent(target::add);\n@@ -344,0 +356,7 @@\n+                target.addInitializer(cmd -> {\n+                    try {\n+                        addResourceDirIcon(cmd, cfg.launcherName, cfg.resourceDirIcon);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                });\n@@ -349,2 +368,2 @@\n-                        initTest(Launcher.Main2, IconType.CustomIcon, cmd, test);\n-                        initTest(Launcher.Main2, IconType.ResourceDirIcon, cmd, test);\n+                        initTest(Launcher.Main2, IconType.CustomIcon, target);\n+                        initTest(Launcher.Main2, IconType.ResourceDirIcon, target);\n@@ -354,2 +373,2 @@\n-                        initTest(Launcher.Additional2, IconType.CustomIcon, cmd, test);\n-                        initTest(Launcher.Additional2, IconType.ResourceDirIcon, cmd, test);\n+                        initTest(Launcher.Additional2, IconType.CustomIcon, target);\n+                        initTest(Launcher.Additional2, IconType.ResourceDirIcon, target);\n@@ -365,4 +384,2 @@\n-    private JPackageCommand initAppImageTest() {\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n-        initTest(cmd, null);\n-        return cmd;\n+    private IconType getBundleIconType(JPackageCommand cmd, Launcher launcher) {\n+        return getBundleIconType(cmd, config.get(Launcher.Main), launcher, config.get(launcher));\n@@ -371,4 +388,25 @@\n-    private PackageTest initPackageTest() {\n-        PackageTest test = new PackageTest().configureHelloApp();\n-        initTest(null, test);\n-        return test;\n+    \/**\n+     * Returns the expected icon type of the given launcher in the output bundle\n+     * that the given jpackage command line will output based on the icon type\n+     * configured for the launcher.\n+     *\n+     * @param cmd                  jpackage command line\n+     * @param mainLauncherIconType the icon type configured for the main launcher\n+     * @param launcher             the launcher\n+     * @param iconType             the icon type configured for the specified\n+     *                             launcher\n+     * @return the type of of an icon of the given launcher in the output bundle\n+     *\/\n+    private static IconType getBundleIconType(JPackageCommand cmd,\n+            IconType mainLauncherIconType, Launcher launcher, IconType iconType) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(mainLauncherIconType);\n+        Objects.requireNonNull(launcher);\n+        Objects.requireNonNull(iconType);\n+\n+        if (iconType == IconType.DefaultIcon) {\n+            iconType = mainLauncherIconType;\n+        }\n+\n+        return iconType;\n@@ -379,6 +417,5 @@\n-        Path resourceDir = cmd.getArgumentValue(\"--resource-dir\", () -> null,\n-                Path::of);\n-        if (resourceDir == null) {\n-            resourceDir = TKit.createTempDirectory(\"resources\");\n-            cmd.addArguments(\"--resource-dir\", resourceDir);\n-        }\n+        var resourceDir = Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).orElseGet(() -> {\n+            return TKit.createTempDirectory(\"resources\");\n+        });\n+\n+        cmd.addArguments(\"--resource-dir\", resourceDir);\n@@ -386,2 +423,1 @@\n-        String dstIconFileName = Optional.ofNullable(launcherName).orElseGet(\n-                () -> cmd.name()) + TKit.ICON_SUFFIX;\n+        String dstIconFileName = Optional.ofNullable(launcherName).orElseGet(cmd::name) + TKit.ICON_SUFFIX;\n@@ -395,2 +431,2 @@\n-    private static void addCustomIcon(JPackageCommand cmd, PackageTest test,\n-            String launcherName, Path iconPath) throws IOException {\n+    private static void addCustomIcon(ConfigurationTarget target,\n+            String launcherName, Path iconPath) {\n@@ -399,11 +435,2 @@\n-            AdditionalLauncher al = new AdditionalLauncher(launcherName).setIcon(\n-                    iconPath);\n-            if (test != null) {\n-                al.applyTo(test);\n-            } else {\n-                al.applyTo(cmd);\n-            }\n-        } else if (test != null) {\n-            test.addInitializer(testCmd -> {\n-                testCmd.addArguments(\"--icon\", iconPath);\n-            });\n+            var al = new AdditionalLauncher(launcherName).setIcon(iconPath);\n+            target.apply(al::applyTo, al::applyTo);\n@@ -411,1 +438,3 @@\n-            cmd.addArguments(\"--icon\", iconPath);\n+            target.addInitializer(cmd -> {\n+                cmd.addArguments(\"--icon\", iconPath);\n+            });\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":183,"deletions":154,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.jpackage.test.JPackageCommand.AppLayoutAssert;\n+import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -180,1 +180,1 @@\n-                cmd.excludeAppLayoutAsserts(AppLayoutAssert.APP_IMAGE_FILE);\n+                cmd.excludeStandardAsserts(StandardAssert.APP_IMAGE_FILE);\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-                expectedLicensePath)).findFirst().orElse(null) != null,\n+                expectedLicensePath)).findFirst().isPresent(),\n","filename":"test\/jdk\/tools\/jpackage\/share\/LicenseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,5 +138,1 @@\n-            Path dest = cmd.appRuntimeDirectory();\n-            if (TKit.isOSX()) {\n-                dest = dest.resolve(\"Contents\/Home\");\n-            }\n-\n+            var dest = cmd.appLayout().runtimeHomeDirectory();\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+\n@@ -27,3 +29,0 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import jdk.jpackage.test.JPackageCommand;\n@@ -33,1 +32,1 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -96,5 +95,4 @@\n-            try ( \/\/ Launch the app in a separate thread\n-                ExecutorService exec = Executors.newSingleThreadExecutor()) {\n-                exec.execute(() -> {\n-                    HelloApp.executeLauncher(cmd);\n-                });\n+            \/\/ Launch the app in a separate thread\n+            new Thread(() -> {\n+                HelloApp.executeLauncher(cmd);\n+            }).start();\n@@ -102,2 +100,2 @@\n-                \/\/ Wait a bit to let the app start\n-                Thread.sleep(Duration.ofSeconds(10));\n+            \/\/ Wait a bit to let the app start\n+            Thread.sleep(Duration.ofSeconds(10));\n@@ -105,3 +103,2 @@\n-                \/\/ Find the main app launcher process and kill it\n-                killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n-            }\n+            \/\/ Find the main app launcher process and kill it\n+            killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @author Joseph D. Darcy, ksrini\n","filename":"test\/jdk\/tools\/launcher\/ChangeDataModel.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @author Joseph D. Darcy, Kumar Srinivasan\n","filename":"test\/jdk\/tools\/launcher\/I18NTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @author Joseph D. Darcy, ksrini\n","filename":"test\/jdk\/tools\/launcher\/UnresolvedExceptions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+        vmOptFinalIntxFlags(map);\n@@ -393,0 +394,20 @@\n+    \/**\n+     * Selected final flag of type intx.\n+     *\n+     * @param map - property-value pairs\n+     * @param flagName - flag name\n+     *\/\n+    private void vmOptFinalIntxFlag(SafeMap map, String flagName) {\n+        map.put(\"vm.opt.final.\" + flagName,\n+                () -> String.valueOf(WB.getIntxVMFlag(flagName)));\n+    }\n+\n+    \/**\n+     * Selected sets of final flags of type intx.\n+     *\n+     * @param map - property-value pairs\n+     *\/\n+    protected void vmOptFinalIntxFlags(SafeMap map) {\n+        vmOptFinalIntxFlag(map, \"MaxVectorSize\");\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+            \"resource-files\/sort-a-z.svg\",\n@@ -268,1 +269,0 @@\n-\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import sun.security.x509.X500Name;\n@@ -93,1 +94,1 @@\n-    private X500Principal subjectName = null;\n+    private X500Name subjectName = null;\n@@ -202,1 +203,1 @@\n-        subjectName = name;\n+        subjectName = X500Name.asX500Name(name);\n@@ -212,1 +213,17 @@\n-        subjectName = new X500Principal(name);\n+        try {\n+            subjectName = new X500Name(name);\n+        } catch (IOException ioe) {\n+            throw new IllegalArgumentException(ioe);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Set the subject name for the certificate. This method is useful when\n+     * you need more control over the contents of the subject name.\n+     *\n+     * @param name an {@code X500Name} to be used as the subject name\n+     * on this certificate\n+     *\/\n+    public CertificateBuilder setSubjectName(X500Name name) {\n+        subjectName = name;\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/\/\/ Tests the generated equals and hashCode for records.\n+\/\/\/ There are 4 types of methods:\n+\/\/\/  - distinct: distinct sites for type profiling\n+\/\/\/  - polluted: megamorphic site that blocks type profiling\n+\/\/\/  - generated: actual body generated by ObjectMethods::bootstrap\n+\/\/\/  - specialized: generated body for non-extensible types\n+\/\/\/ The result of generated compared to the other distinct\/polluted shows\n+\/\/\/ whether the generated code could perform type profiling.\n+\/\/\/ Specialized is the result of distinct without trap, should be even faster.\n+@Fork(3)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class RecordMethodsBenchmark {\n+\n+    record One(int a) {}\n+\n+    @State(Scope.Thread)\n+    public static class BenchmarkState {\n+        Key k1 = new Key(new One(1), \"a\");\n+        Key k2 = new Key(new One(1), new String(\"a\"));\n+        SpecializedKey sk1 = new SpecializedKey(new One(1), \"a\");\n+        SpecializedKey sk2 = new SpecializedKey(new One(1), new String(\"a\"));\n+    }\n+\n+    @Benchmark\n+    public int hashCodeDistinct(BenchmarkState state) {\n+        return state.k1.hashCodeDistinct();\n+    }\n+\n+    @Benchmark\n+    public int hashCodePolluted(BenchmarkState state) {\n+        return state.k1.hashCodePolluted();\n+    }\n+\n+    @Benchmark\n+    public int hashCodeGenerated(BenchmarkState state) {\n+        return state.k1.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int hashCodeSpecial(BenchmarkState state) {\n+        return state.sk1.hashCode();\n+    }\n+\n+    @Benchmark\n+    public boolean equalsDistinct(BenchmarkState state) {\n+        return state.k1.equalsDistinct(state.k2);\n+    }\n+\n+    @Benchmark\n+    public boolean equalsPolluted(BenchmarkState state) {\n+        return state.k1.equalsPolluted(state.k2);\n+    }\n+\n+    @Benchmark\n+    public boolean equalsGenerated(BenchmarkState state) {\n+        return state.k1.equals(state.k2);\n+    }\n+\n+    @Benchmark\n+    public boolean equalsSpecial(BenchmarkState state) {\n+        return state.sk1.equals(state.sk2);\n+    }\n+\n+    \/\/\/ A key object.\n+    \/\/\/\n+    \/\/\/ Having both field as Object pollutes Object.equals for record object\n+    \/\/\/ method MH tree.  We must verify the leaf Object.equals calls don't\n+    \/\/\/ share the same profile in generated code.\n+    record Key(Object key1, Object key2) {\n+        \/\/\/ A hashCode method which has distinct hashCode invocations\n+        \/\/\/ in bytecode for each field for type profiling.\n+        public int hashCodeDistinct() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + ((key1 == null) ? 0 : key1.hashCode());\n+            result = prime * result + ((key2 == null) ? 0 : key2.hashCode());\n+            return result;\n+        }\n+\n+        \/\/\/ A hashCode method which uses a megamorphic polluted\n+        \/\/\/ Object.hashCode virtual invocation in Objects.hashCode.\n+        public int hashCodePolluted() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + Objects.hashCode(key1);\n+            result = prime * result + Objects.hashCode(key2);\n+            return result;\n+        }\n+\n+        \/\/\/ An equals method which has distinct equals invocations\n+        \/\/\/ in bytecode for each field for type profiling.\n+        public boolean equalsDistinct(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Key other = (Key) obj;\n+            if (key1 == null) {\n+                if (other.key1 != null)\n+                    return false;\n+            }\n+            else if (!key1.equals(other.key1))\n+                return false;\n+            if (key2 == null) {\n+                if (other.key2 != null)\n+                    return false;\n+            }\n+            else if (!key2.equals(other.key2))\n+                return false;\n+            return true;\n+        }\n+\n+        \/\/\/ An equals method which uses a megamorphic polluted\n+        \/\/\/ Object.equals virtual invocation in Objects.equals.\n+        public boolean equalsPolluted(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Key other = (Key) obj;\n+            return Objects.equals(key1, other.key1) && Objects.equals(key2, other.key2);\n+        }\n+    }\n+\n+    record SpecializedKey(One key1, String key2) {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/RecordMethodsBenchmark.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.jimage.PreviewMode;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -42,1 +44,0 @@\n-import java.nio.ByteOrder;\n@@ -47,0 +48,1 @@\n+import java.util.Map;\n@@ -49,0 +51,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -51,0 +55,3 @@\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n@@ -70,1 +77,1 @@\n-    \/\/\/ per-benchmark or a per-iteration state object. The subclasses provide\n+    \/\/\/ per-trial or a per-iteration state object. The subclasses provide\n@@ -74,1 +81,0 @@\n-        protected ByteOrder byteOrder;\n@@ -79,1 +85,0 @@\n-            byteOrder = ByteOrder.nativeOrder();\n@@ -89,0 +94,2 @@\n+    \/\/\/ A {@link Level#Trial per-trial} state which provides an image reader,\n+    \/\/\/ suitable for {@link Mode#AverageTime average time} benchmarks.\n@@ -90,1 +97,3 @@\n-    public static class WarmStartWithImageReader extends BaseState {\n+    public static class WarmStart extends BaseState {\n+        @Param({\"DISABLED\", \"ENABLED\"})\n+        PreviewMode previewMode;\n@@ -96,1 +105,1 @@\n-            reader = ImageReader.open(copiedImageFile, byteOrder);\n+            reader = ImageReader.open(copiedImageFile, previewMode);\n@@ -105,0 +114,12 @@\n+    @State(Scope.Benchmark)\n+    public static class WarmStartWithCachedNodes extends WarmStart {\n+        @Setup(Level.Trial)\n+        public void setUp() throws IOException {\n+            super.setUp();\n+            countAllNodes(reader, reader.findNode(\"\/\"));\n+        }\n+    }\n+\n+    \/\/\/ A {@link Level#Iteration per-iteration} state suitable for\n+    \/\/\/ {@link Mode#SingleShotTime single shot} benchmarks. Unlike\n+    \/\/\/ {@link WarmStart}, this state does not provide a reader instance.\n@@ -107,0 +128,3 @@\n+        @Param({\"DISABLED\", \"ENABLED\"})\n+        PreviewMode previewMode;\n+\n@@ -119,1 +143,1 @@\n-    public static class ColdStartWithImageReader extends BaseState {\n+    public static class ColdStartWithImageReader extends ColdStart {\n@@ -125,1 +149,1 @@\n-            reader = ImageReader.open(copiedImageFile, byteOrder);\n+            reader = ImageReader.open(copiedImageFile, previewMode);\n@@ -140,1 +164,1 @@\n-    public void warmCache_CountAllNodes(WarmStartWithImageReader state) throws IOException {\n+    public void warmStart_CountAllNodes(WarmStartWithCachedNodes state) throws IOException {\n@@ -144,0 +168,39 @@\n+    \/\/\/ Benchmarks {@link ImageReader#containsResource(String, String)} when no\n+    \/\/\/ nodes have been cached in the {@link ImageReader}. In non-preview mode,\n+    \/\/\/ this should be identical to the case where nodes are cached (because the\n+    \/\/\/ cache isn't used) but in preview mode, the cache will be tested for\n+    \/\/\/ preview resources, and thus differ depending on whether nodes are present.\n+    \/\/\/\n+    \/\/\/ This doesn't need to be a cold start because it never modifies the nodes\n+    \/\/\/ cache.\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public void warmStart_ContainsResource_emptyNodeCache(WarmStart state) throws IOException {\n+        state.count = countContainsResource(state.reader, ClassList.pathMap());\n+    }\n+\n+    \/\/\/ As above, but the nodes cache has been filled, giving preview mode a\n+    \/\/\/ different code path.\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public void warmStart_ContainsResource_fullNodeCache(WarmStartWithCachedNodes state) throws IOException {\n+        state.count = countContainsResource(state.reader, ClassList.pathMap());\n+    }\n+\n+    \/\/\/ As {@link #warmStart_ContainsResource_emptyNodeCache}, but tests\n+    \/\/\/ {@link ImageReader#findResourceNode(String, String)}.\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public void warmStart_FindResourceNode_emptyNodeCache(WarmStart state) throws IOException {\n+        state.count = countFindResourceNode(state.reader, ClassList.pathMap());\n+    }\n+\n+    \/\/\/ As {@link #warmStart_ContainsResource_fullNodeCache}, but tests\n+    \/\/\/ {@link ImageReader#findResourceNode(String, String)}.\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public void warmStart_FindResourceNode_fullNodeCache(WarmStartWithCachedNodes state) throws IOException {\n+        state.count = countFindResourceNode(state.reader, ClassList.pathMap());\n+    }\n+\n+\n@@ -152,1 +215,1 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, state.previewMode)) {\n@@ -157,1 +220,1 @@\n-    \/\/\/ As above, but includes the time to initialize the `ImageReader`.\n+    \/\/\/ As above, but excludes the time to initialize the `ImageReader`.\n@@ -176,2 +239,2 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n-            for (String path : INIT_CLASSES) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, state.previewMode)) {\n+            for (String path : ClassList.names()) {\n@@ -188,1 +251,1 @@\n-        state.count = INIT_CLASSES.size();\n+        state.count = ClassList.count();\n@@ -190,1 +253,1 @@\n-        if ((100 * errors) \/ INIT_CLASSES.size() >= 2) {\n+        if ((100 * errors) \/ ClassList.count() >= 2) {\n@@ -209,0 +272,27 @@\n+    static long countContainsResource(ImageReader reader, Map<String, List<String>> modToPaths)\n+            throws IOException {\n+        long count = 0;\n+        for (Map.Entry<String, List<String>> e : modToPaths.entrySet()) {\n+            String mod = e.getKey();\n+            for (String path : e.getValue()) {\n+                if (reader.containsResource(mod, path)) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n+    static long countFindResourceNode(ImageReader reader, Map<String, List<String>> modToPaths) throws IOException {\n+        long count = 0;\n+        for (Map.Entry<String, List<String>> e : modToPaths.entrySet()) {\n+            String mod = e.getKey();\n+            for (String path : e.getValue()) {\n+                if (reader.findResourceNode(mod, path) != null) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n@@ -213,2 +303,2 @@\n-        try (var reader = ImageReader.open(state.copiedImageFile, state.byteOrder)) {\n-            for (String path : INIT_CLASSES) {\n+        try (var reader = ImageReader.open(state.copiedImageFile, state.previewMode)) {\n+            for (String path : ClassList.names()) {\n@@ -225,1 +315,1 @@\n-                        errors, INIT_CLASSES.size(), String.join(\"\\n\\t\", missing)));\n+                        errors, ClassList.count(), String.join(\"\\n\\t\", missing)));\n@@ -228,851 +318,884 @@\n-    \/\/ Note: This list is inherently a little fragile and may end up being more\n-    \/\/ trouble than it's worth to maintain. If it turns out that it needs to be\n-    \/\/ regenerated often when this benchmark is run, then a new approach should\n-    \/\/ be considered, such as:\n-    \/\/ * Limit the list of classes to non-internal ones.\n-    \/\/ * Calculate the list dynamically based on the running JVM.\n-    \/\/\n-    \/\/ Created by running \"java -verbose:class\", throwing away anonymous inner\n-    \/\/ classes and anything without a reliable name, and grouping by the stated\n-    \/\/ source. It's not perfect, but it's representative.\n-    \/\/\n-    \/\/ <jdk_root>\/bin\/java -verbose:class HelloWorld 2>&1 \\\n-    \/\/   | fgrep '[class,load]' | cut -d' ' -f2 \\\n-    \/\/   | tr '.' '\/' \\\n-    \/\/   | egrep -v '\\$[0-9$]' \\\n-    \/\/   | fgrep -v 'HelloWorld' \\\n-    \/\/   | fgrep -v '\/META-INF\/preview\/' \\\n-    \/\/   | while read f ; do echo \"${f}.class\" ; done \\\n-    \/\/   > initclasses.txt\n-    \/\/\n-    \/\/ Output:\n-    \/\/    java\/lang\/Object.class\n-    \/\/    java\/io\/Serializable.class\n-    \/\/    ...\n-    \/\/\n-    \/\/ jimage list <jdk_root>\/images\/jdk\/lib\/modules \\\n-    \/\/     | awk '\/^Module: *\/ { MOD=$2 }; \/^    *\/ { print \"\/modules\/\"MOD\"\/\"$1 }' \\\n-    \/\/     > fullpaths.txt\n-    \/\/\n-    \/\/ Output:\n-    \/\/     ...\n-    \/\/     \/modules\/java.base\/java\/lang\/Object.class\n-    \/\/     \/modules\/java.base\/java\/lang\/OutOfMemoryError.class\n-    \/\/     ...\n-    \/\/\n-    \/\/ while read c ; do grep \"\/$c\" fullpaths.txt ; done < initclasses.txt \\\n-    \/\/     | while read c ; do printf '    \"%s\",\\n' \"$c\" ; done \\\n-    \/\/     > initpaths.txt\n-    \/\/\n-    \/\/ Output:\n-    private static final Set<String> INIT_CLASSES = Set.of(\n-            \"\/modules\/java.base\/java\/lang\/Object.class\",\n-            \"\/modules\/java.base\/java\/io\/Serializable.class\",\n-            \"\/modules\/java.base\/java\/lang\/Comparable.class\",\n-            \"\/modules\/java.base\/java\/lang\/CharSequence.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/Constable.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/ConstantDesc.class\",\n-            \"\/modules\/java.base\/java\/lang\/String.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/AnnotatedElement.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/GenericDeclaration.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Type.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor$OfField.class\",\n-            \"\/modules\/java.base\/java\/lang\/Class.class\",\n-            \"\/modules\/java.base\/java\/lang\/Cloneable.class\",\n-            \"\/modules\/java.base\/java\/lang\/ClassLoader.class\",\n-            \"\/modules\/java.base\/java\/lang\/System.class\",\n-            \"\/modules\/java.base\/java\/lang\/Throwable.class\",\n-            \"\/modules\/java.base\/java\/lang\/Error.class\",\n-            \"\/modules\/java.base\/java\/lang\/Exception.class\",\n-            \"\/modules\/java.base\/java\/lang\/RuntimeException.class\",\n-            \"\/modules\/java.base\/java\/security\/ProtectionDomain.class\",\n-            \"\/modules\/java.base\/java\/security\/SecureClassLoader.class\",\n-            \"\/modules\/java.base\/java\/lang\/ReflectiveOperationException.class\",\n-            \"\/modules\/java.base\/java\/lang\/ClassNotFoundException.class\",\n-            \"\/modules\/java.base\/java\/lang\/Record.class\",\n-            \"\/modules\/java.base\/java\/lang\/LinkageError.class\",\n-            \"\/modules\/java.base\/java\/lang\/NoClassDefFoundError.class\",\n-            \"\/modules\/java.base\/java\/lang\/ClassCastException.class\",\n-            \"\/modules\/java.base\/java\/lang\/ArrayStoreException.class\",\n-            \"\/modules\/java.base\/java\/lang\/VirtualMachineError.class\",\n-            \"\/modules\/java.base\/java\/lang\/InternalError.class\",\n-            \"\/modules\/java.base\/java\/lang\/OutOfMemoryError.class\",\n-            \"\/modules\/java.base\/java\/lang\/StackOverflowError.class\",\n-            \"\/modules\/java.base\/java\/lang\/IllegalMonitorStateException.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/Reference.class\",\n-            \"\/modules\/java.base\/java\/lang\/IllegalCallerException.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/SoftReference.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/WeakReference.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/FinalReference.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/PhantomReference.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/Finalizer.class\",\n-            \"\/modules\/java.base\/java\/lang\/Runnable.class\",\n-            \"\/modules\/java.base\/java\/lang\/Thread.class\",\n-            \"\/modules\/java.base\/java\/lang\/Thread$FieldHolder.class\",\n-            \"\/modules\/java.base\/java\/lang\/Thread$Constants.class\",\n-            \"\/modules\/java.base\/java\/lang\/Thread$UncaughtExceptionHandler.class\",\n-            \"\/modules\/java.base\/java\/lang\/ThreadGroup.class\",\n-            \"\/modules\/java.base\/java\/lang\/BaseVirtualThread.class\",\n-            \"\/modules\/java.base\/java\/lang\/VirtualThread.class\",\n-            \"\/modules\/java.base\/java\/lang\/ThreadBuilders$BoundVirtualThread.class\",\n-            \"\/modules\/java.base\/java\/util\/Map.class\",\n-            \"\/modules\/java.base\/java\/util\/Dictionary.class\",\n-            \"\/modules\/java.base\/java\/util\/Hashtable.class\",\n-            \"\/modules\/java.base\/java\/util\/Properties.class\",\n-            \"\/modules\/java.base\/java\/lang\/Module.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/AccessibleObject.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Member.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Field.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Parameter.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Executable.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Method.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Constructor.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/ContinuationScope.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/Continuation.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/StackChunk.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodAccessor.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodAccessorImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstantPool.class\",\n-            \"\/modules\/java.base\/java\/lang\/annotation\/Annotation.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/CallerSensitive.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstructorAccessor.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstructorAccessorImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/DirectConstructorHandleAccessor$NativeAccessor.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MemberName.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/ResolvedMethodName.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleNatives.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor$OfMethod.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodType.class\",\n-            \"\/modules\/java.base\/java\/lang\/BootstrapMethodError.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/CallSite.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/ABIDescriptor.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/VMStorage.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/UpcallLinker$CallRegs.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/ConstantCallSite.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MutableCallSite.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VolatileCallSite.class\",\n-            \"\/modules\/java.base\/java\/lang\/AssertionStatusDirectives.class\",\n-            \"\/modules\/java.base\/java\/lang\/Appendable.class\",\n-            \"\/modules\/java.base\/java\/lang\/AbstractStringBuilder.class\",\n-            \"\/modules\/java.base\/java\/lang\/StringBuffer.class\",\n-            \"\/modules\/java.base\/java\/lang\/StringBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/UnsafeConstants.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/Unsafe.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/Modules.class\",\n-            \"\/modules\/java.base\/java\/lang\/AutoCloseable.class\",\n-            \"\/modules\/java.base\/java\/io\/Closeable.class\",\n-            \"\/modules\/java.base\/java\/io\/InputStream.class\",\n-            \"\/modules\/java.base\/java\/io\/ByteArrayInputStream.class\",\n-            \"\/modules\/java.base\/java\/net\/URL.class\",\n-            \"\/modules\/java.base\/java\/lang\/Enum.class\",\n-            \"\/modules\/java.base\/java\/util\/jar\/Manifest.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/BuiltinClassLoader.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$AppClassLoader.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$PlatformClassLoader.class\",\n-            \"\/modules\/java.base\/java\/security\/CodeSource.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentMap.class\",\n-            \"\/modules\/java.base\/java\/util\/AbstractMap.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap.class\",\n-            \"\/modules\/java.base\/java\/lang\/Iterable.class\",\n-            \"\/modules\/java.base\/java\/util\/Collection.class\",\n-            \"\/modules\/java.base\/java\/util\/SequencedCollection.class\",\n-            \"\/modules\/java.base\/java\/util\/List.class\",\n-            \"\/modules\/java.base\/java\/util\/RandomAccess.class\",\n-            \"\/modules\/java.base\/java\/util\/AbstractCollection.class\",\n-            \"\/modules\/java.base\/java\/util\/AbstractList.class\",\n-            \"\/modules\/java.base\/java\/util\/ArrayList.class\",\n-            \"\/modules\/java.base\/java\/lang\/StackTraceElement.class\",\n-            \"\/modules\/java.base\/java\/nio\/Buffer.class\",\n-            \"\/modules\/java.base\/java\/lang\/StackWalker.class\",\n-            \"\/modules\/java.base\/java\/lang\/StackStreamFactory$AbstractStackWalker.class\",\n-            \"\/modules\/java.base\/java\/lang\/StackWalker$StackFrame.class\",\n-            \"\/modules\/java.base\/java\/lang\/ClassFrameInfo.class\",\n-            \"\/modules\/java.base\/java\/lang\/StackFrameInfo.class\",\n-            \"\/modules\/java.base\/java\/lang\/LiveStackFrame.class\",\n-            \"\/modules\/java.base\/java\/lang\/LiveStackFrameInfo.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractOwnableSynchronizer.class\",\n-            \"\/modules\/java.base\/java\/lang\/Boolean.class\",\n-            \"\/modules\/java.base\/java\/lang\/Character.class\",\n-            \"\/modules\/java.base\/java\/lang\/Number.class\",\n-            \"\/modules\/java.base\/java\/lang\/Float.class\",\n-            \"\/modules\/java.base\/java\/lang\/Double.class\",\n-            \"\/modules\/java.base\/java\/lang\/Byte.class\",\n-            \"\/modules\/java.base\/java\/lang\/Short.class\",\n-            \"\/modules\/java.base\/java\/lang\/Integer.class\",\n-            \"\/modules\/java.base\/java\/lang\/Long.class\",\n-            \"\/modules\/java.base\/java\/lang\/Void.class\",\n-            \"\/modules\/java.base\/java\/util\/Iterator.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/RecordComponent.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$Vector.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorMask.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/FillerObject.class\",\n-            \"\/modules\/java.base\/java\/lang\/NullPointerException.class\",\n-            \"\/modules\/java.base\/java\/lang\/ArithmeticException.class\",\n-            \"\/modules\/java.base\/java\/lang\/IndexOutOfBoundsException.class\",\n-            \"\/modules\/java.base\/java\/lang\/ArrayIndexOutOfBoundsException.class\",\n-            \"\/modules\/java.base\/java\/io\/ObjectStreamField.class\",\n-            \"\/modules\/java.base\/java\/util\/Comparator.class\",\n-            \"\/modules\/java.base\/java\/lang\/String$CaseInsensitiveComparator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/VM.class\",\n-            \"\/modules\/java.base\/java\/lang\/Module$ArchivedData.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/CDS.class\",\n-            \"\/modules\/java.base\/java\/util\/Set.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableCollection.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableSet.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$Set12.class\",\n-            \"\/modules\/java.base\/java\/util\/Objects.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableList.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$ListN.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$SetN.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableMap.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$MapN.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangReflectAccess.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/ReflectAccess.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/SharedSecrets.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/ReflectionFactory.class\",\n-            \"\/modules\/java.base\/java\/io\/ObjectStreamClass.class\",\n-            \"\/modules\/java.base\/java\/lang\/Math.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/ReflectionFactory$Config.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangRefAccess.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue$Null.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue$Lock.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangAccess.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/SystemProps.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/SystemProps$Raw.class\",\n-            \"\/modules\/java.base\/java\/nio\/charset\/Charset.class\",\n-            \"\/modules\/java.base\/java\/nio\/charset\/spi\/CharsetProvider.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/StandardCharsets.class\",\n-            \"\/modules\/java.base\/java\/lang\/StringLatin1.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/HistoricallyNamedCharset.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/Unicode.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_8.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap.class\",\n-            \"\/modules\/java.base\/java\/lang\/StrictMath.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/ArraysSupport.class\",\n-            \"\/modules\/java.base\/java\/util\/Map$Entry.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$Node.class\",\n-            \"\/modules\/java.base\/java\/util\/LinkedHashMap$Entry.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$TreeNode.class\",\n-            \"\/modules\/java.base\/java\/lang\/StringConcatHelper.class\",\n-            \"\/modules\/java.base\/java\/lang\/VersionProps.class\",\n-            \"\/modules\/java.base\/java\/lang\/Runtime.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/Lock.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Segment.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$CounterCell.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Node.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/LockSupport.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ReservationNode.class\",\n-            \"\/modules\/java.base\/java\/util\/AbstractSet.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$EntrySet.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$HashIterator.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$EntryIterator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/StaticProperty.class\",\n-            \"\/modules\/java.base\/java\/io\/FileInputStream.class\",\n-            \"\/modules\/java.base\/java\/lang\/System$In.class\",\n-            \"\/modules\/java.base\/java\/io\/FileDescriptor.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.class\",\n-            \"\/modules\/java.base\/java\/io\/Flushable.class\",\n-            \"\/modules\/java.base\/java\/io\/OutputStream.class\",\n-            \"\/modules\/java.base\/java\/io\/FileOutputStream.class\",\n-            \"\/modules\/java.base\/java\/lang\/System$Out.class\",\n-            \"\/modules\/java.base\/java\/io\/FilterInputStream.class\",\n-            \"\/modules\/java.base\/java\/io\/BufferedInputStream.class\",\n-            \"\/modules\/java.base\/java\/io\/FilterOutputStream.class\",\n-            \"\/modules\/java.base\/java\/io\/PrintStream.class\",\n-            \"\/modules\/java.base\/java\/io\/BufferedOutputStream.class\",\n-            \"\/modules\/java.base\/java\/io\/Writer.class\",\n-            \"\/modules\/java.base\/java\/io\/OutputStreamWriter.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/StreamEncoder.class\",\n-            \"\/modules\/java.base\/java\/nio\/charset\/CharsetEncoder.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_8$Encoder.class\",\n-            \"\/modules\/java.base\/java\/nio\/charset\/CodingErrorAction.class\",\n-            \"\/modules\/java.base\/java\/util\/Arrays.class\",\n-            \"\/modules\/java.base\/java\/nio\/ByteBuffer.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/ScopedMemoryAccess.class\",\n-            \"\/modules\/java.base\/java\/util\/function\/Function.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/Preconditions.class\",\n-            \"\/modules\/java.base\/java\/util\/function\/BiFunction.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaNioAccess.class\",\n-            \"\/modules\/java.base\/java\/nio\/HeapByteBuffer.class\",\n-            \"\/modules\/java.base\/java\/nio\/ByteOrder.class\",\n-            \"\/modules\/java.base\/java\/io\/BufferedWriter.class\",\n-            \"\/modules\/java.base\/java\/lang\/Terminator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/Signal$Handler.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/Signal.class\",\n-            \"\/modules\/java.base\/java\/util\/Hashtable$Entry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/Signal$NativeHandler.class\",\n-            \"\/modules\/java.base\/java\/lang\/Integer$IntegerCache.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/OSEnvironment.class\",\n-            \"\/modules\/java.base\/java\/lang\/Thread$State.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/Reference$ReferenceHandler.class\",\n-            \"\/modules\/java.base\/java\/lang\/Thread$ThreadIdentifiers.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/Finalizer$FinalizerThread.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/Cleaner.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections$EmptySet.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections$EmptyList.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections$EmptyMap.class\",\n-            \"\/modules\/java.base\/java\/lang\/IllegalArgumentException.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleStatics.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/ClassFileFormatVersion.class\",\n-            \"\/modules\/java.base\/java\/lang\/CharacterData.class\",\n-            \"\/modules\/java.base\/java\/lang\/CharacterDataLatin1.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/ClassFileDumper.class\",\n-            \"\/modules\/java.base\/java\/util\/HexFormat.class\",\n-            \"\/modules\/java.base\/java\/lang\/Character$CharacterCache.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/atomic\/AtomicInteger.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MemberName$Factory.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/Reflection.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles$Lookup.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$MapN$MapNIterator.class\",\n-            \"\/modules\/java.base\/java\/util\/KeyValueHolder.class\",\n-            \"\/modules\/java.base\/sun\/invoke\/util\/VerifyAccess.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Modifier.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangModuleAccess.class\",\n-            \"\/modules\/java.base\/java\/io\/File.class\",\n-            \"\/modules\/java.base\/java\/io\/DefaultFileSystem.class\",\n-            \"\/modules\/java.base\/java\/io\/FileSystem.class\",\n-            \"\/modules\/java.base\/java\/io\/UnixFileSystem.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/DecimalDigits.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModulePatcher.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$IllegalNativeAccess.class\",\n-            \"\/modules\/java.base\/java\/util\/HashSet.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap$Modules.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$Counters.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ArchivedBootLayer.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ArchivedModuleGraph.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/SystemModuleFinders.class\",\n-            \"\/modules\/java.base\/java\/net\/URI.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaNetUriAccess.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/SystemModules.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ExplodedSystemModules.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/Watchable.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/Path.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/FileSystems.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/DefaultFileSystemProvider.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/spi\/FileSystemProvider.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/AbstractFileSystemProvider.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileSystemProvider.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/LinuxFileSystemProvider.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/OpenOption.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/StandardOpenOption.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/FileSystem.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileSystem.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/LinuxFileSystem.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixPath.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/Util.class\",\n-            \"\/modules\/java.base\/java\/lang\/StringCoding.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixNativeDispatcher.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/BootLoader.class\",\n-            \"\/modules\/java.base\/java\/lang\/Module$EnableNativeAccess.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaderHelper.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$CollectionView.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$KeySetView.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$LibraryPaths.class\",\n-            \"\/modules\/java.base\/java\/io\/File$PathStatus.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$CountedLock.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock$Sync.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock$NonfairSync.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$NativeLibraryContext.class\",\n-            \"\/modules\/java.base\/java\/util\/Queue.class\",\n-            \"\/modules\/java.base\/java\/util\/Deque.class\",\n-            \"\/modules\/java.base\/java\/util\/ArrayDeque.class\",\n-            \"\/modules\/java.base\/java\/util\/ArrayDeque$DeqIterator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibrary.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$NativeLibraryImpl.class\",\n-            \"\/modules\/java.base\/java\/security\/cert\/Certificate.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ValuesView.class\",\n-            \"\/modules\/java.base\/java\/util\/Enumeration.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Traverser.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$BaseIterator.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ValueIterator.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/BasicFileAttributes.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/PosixFileAttributes.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributes.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileStoreAttributes.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixMountEntry.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/CopyOption.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/LinkOption.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/Files.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffers.class\",\n-            \"\/modules\/java.base\/java\/lang\/ThreadLocal.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/CarrierThreadLocal.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/TerminatingThreadLocal.class\",\n-            \"\/modules\/java.base\/java\/lang\/ThreadLocal$ThreadLocalMap.class\",\n-            \"\/modules\/java.base\/java\/lang\/ThreadLocal$ThreadLocalMap$Entry.class\",\n-            \"\/modules\/java.base\/java\/util\/IdentityHashMap.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections$SetFromMap.class\",\n-            \"\/modules\/java.base\/java\/util\/IdentityHashMap$KeySet.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffer.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerFactory.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/ThreadFactory.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/Cleaner.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanableList.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanableList$Node.class\",\n-            \"\/modules\/java.base\/java\/lang\/ref\/Cleaner$Cleanable.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/PhantomCleanable.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanerCleanable.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/InnocuousThread.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffer$Deallocator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$PhantomCleanableRef.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleFinder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModulePath.class\",\n-            \"\/modules\/java.base\/java\/util\/jar\/Attributes$Name.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/Array.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/perf\/PerfCounter.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/perf\/Perf.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/DirectBuffer.class\",\n-            \"\/modules\/java.base\/java\/nio\/MappedByteBuffer.class\",\n-            \"\/modules\/java.base\/java\/nio\/DirectByteBuffer.class\",\n-            \"\/modules\/java.base\/java\/nio\/Bits.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/atomic\/AtomicLong.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/VM$BufferPool.class\",\n-            \"\/modules\/java.base\/java\/nio\/LongBuffer.class\",\n-            \"\/modules\/java.base\/java\/nio\/DirectLongBufferU.class\",\n-            \"\/modules\/java.base\/java\/util\/zip\/ZipConstants.class\",\n-            \"\/modules\/java.base\/java\/util\/zip\/ZipFile.class\",\n-            \"\/modules\/java.base\/java\/util\/jar\/JarFile.class\",\n-            \"\/modules\/java.base\/java\/util\/BitSet.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilZipFileAccess.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilJarAccess.class\",\n-            \"\/modules\/java.base\/java\/util\/jar\/JavaUtilJarAccessImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/Runtime$Version.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$List12.class\",\n-            \"\/modules\/java.base\/java\/util\/Optional.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/DosFileAttributes.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/AttributeView.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/FileAttributeView.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/BasicFileAttributeView.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/DosFileAttributeView.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/UserDefinedFileAttributeView.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributeViews.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/DynamicFileAttributeView.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/AbstractBasicFileAttributeView.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributeViews$Basic.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributes$UnixAsBasicFileAttributes.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/DirectoryStream$Filter.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/Files$AcceptAllFilter.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/DirectoryStream.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/SecureDirectoryStream.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixSecureDirectoryStream.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixDirectoryStream.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReadWriteLock.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$Sync.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$FairSync.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$ReadLock.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$WriteLock.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixDirectoryStream$UnixDirectoryIterator.class\",\n-            \"\/modules\/java.base\/java\/nio\/file\/attribute\/FileAttribute.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileModeAttribute.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixChannelFactory.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixChannelFactory$Flags.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections$EmptyIterator.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/Channel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/ReadableByteChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/WritableByteChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/ByteChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/SeekableByteChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/GatheringByteChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/ScatteringByteChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/InterruptibleChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/FileChannel.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/FileChannelImpl.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/NativeDispatcher.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/FileDispatcher.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/UnixFileDispatcherImpl.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/FileDispatcherImpl.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/IOUtil.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/Interruptible.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/NativeThreadSet.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/FileChannelImpl$Closer.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/Channels.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/Streams.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/SelChImpl.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/NetworkChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/SelectableChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/spi\/AbstractSelectableChannel.class\",\n-            \"\/modules\/java.base\/java\/nio\/channels\/SocketChannel.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/SocketChannelImpl.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/ChannelInputStream.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaMetafactory.class\",\n-            \"\/modules\/java.base\/java\/util\/function\/Supplier.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/ReferencedKeySet.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/ReferencedKeyMap.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/ReferenceKey.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/StrongReferenceKey.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodTypeForm.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/WeakReferenceKey.class\",\n-            \"\/modules\/java.base\/sun\/invoke\/util\/Wrapper.class\",\n-            \"\/modules\/java.base\/sun\/invoke\/util\/Wrapper$Format.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/ConstantDescs.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/ClassDesc.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/constant\/ArrayClassDescImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/constant\/ConstantUtils.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/DirectMethodHandleDesc$Kind.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/MethodTypeDesc.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/constant\/MethodTypeDescImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/MethodHandleDesc.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/DirectMethodHandleDesc.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/constant\/DirectMethodHandleDescImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/DynamicConstantDesc.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/constant\/PrimitiveClassDescImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/constant\/DynamicConstantDesc$AnonymousDynamicConstantDesc.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$NamedFunction.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Holder.class\",\n-            \"\/modules\/java.base\/sun\/invoke\/util\/ValueConversions.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/Invokers.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Kind.class\",\n-            \"\/modules\/java.base\/java\/lang\/NoSuchMethodException.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$BasicType.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/TypeKind.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Name.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Holder.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/InvokerBytecodeGenerator.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/AnnotationElement.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Annotation.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ConstantPool.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/PoolEntry.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/AnnotationConstantValueEntry.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/Utf8Entry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$Utf8EntryImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$Utf8EntryImpl$State.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AnnotationImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassFileElement.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Attribute.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassElement.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/MethodElement.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/FieldElement.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/Util$Writable.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractElement.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$UnboundRuntimeVisibleAnnotationsAttribute.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Attributes.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/AttributeMapper.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$RuntimeVisibleAnnotationsMapper.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/AttributeMapper$AttributeStability.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleImpl$Intrinsic.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/SplitConstantPool.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/BootstrapMethodEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/EntryMap.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/Util.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ClassEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractRefEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractNamedEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$ClassEntryImpl.class\",\n-            \"\/modules\/java.base\/java\/util\/function\/Consumer.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassFile.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassFileImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassFileBuilder.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AttributeHolder.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Superclass.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/SuperclassImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/attribute\/SourceFileAttribute.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$UnboundSourceFileAttribute.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$SourceFileMapper.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BoundAttribute.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/MethodBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/MethodInfo.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalMethodBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/NameAndTypeEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractRefsEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$NameAndTypeEntryImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/MemberRefEntry.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/FieldRefEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractMemberRefEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$FieldRefEntryImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/InvokerBytecodeGenerator$ClassData.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/CodeBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/LabelContext.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/CodeElement.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/PseudoInstruction.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/CharacterRange.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LocalVariable.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LocalVariableType.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder$DeferredLabel.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/BufWriter.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BufWriterImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Label.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LabelTarget.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/LabelImpl.class\",\n-            \"\/modules\/java.base\/sun\/invoke\/util\/VerifyType.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Opcode.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Opcode$Kind.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/MethodRefEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$MethodRefEntryImpl.class\",\n-            \"\/modules\/java.base\/sun\/invoke\/empty\/Empty.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$AdHocAttribute.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$CodeMapper.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/FieldBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalFieldBuilder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/CustomAttribute.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AnnotationReader.class\",\n-            \"\/modules\/java.base\/java\/util\/ListIterator.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$ListItr.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator$Frame.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator$Type.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper$CodeRange.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassHierarchyResolver.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$ClassLoadingClassHierarchyResolver.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$CachedClassHierarchyResolver.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassHierarchyResolver$ClassHierarchyInfo.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$ClassHierarchyInfoImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/ClassReader.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/ModifiedUtf.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles$Lookup$ClassDefiner.class\",\n-            \"\/modules\/java.base\/java\/lang\/IncompatibleClassChangeError.class\",\n-            \"\/modules\/java.base\/java\/lang\/NoSuchMethodError.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/BootstrapMethodInvoker.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/InnerClassLambdaMetafactory.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleInfo.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/InfoFromMemberName.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$Access.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilCollectionAccess.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/Interfaces.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/InterfacesImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/TypeConvertingMethodAdapter.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Constructor.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangInvokeAccess.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessMode.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessType.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/Invokers$Holder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo.class\",\n-            \"\/modules\/java.base\/java\/io\/DataInput.class\",\n-            \"\/modules\/java.base\/java\/io\/DataInputStream.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$CountingDataInput.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/NativeThread.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/Blocker.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/Util.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/Util$BufferCache.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ch\/IOStatus.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/util\/ByteArray.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandles.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsShorts$ByteArrayViewVarHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsShorts$ArrayHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleGuards.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarForm.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsChars$ByteArrayViewVarHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsChars$ArrayHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsInts$ByteArrayViewVarHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsInts$ArrayHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsFloats$ByteArrayViewVarHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsFloats$ArrayHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsLongs$ByteArrayViewVarHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsLongs$ArrayHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsDoubles$ByteArrayViewVarHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsDoubles$ArrayHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessDescriptor.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$Entry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$IndexEntry.class\",\n-            \"\/modules\/java.base\/java\/nio\/charset\/StandardCharsets.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/US_ASCII.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/ISO_8859_1.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16BE.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16LE.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32BE.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32LE.class\",\n-            \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$ValueEntry.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Builder.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Modifier.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/AccessFlag.class\",\n-            \"\/modules\/java.base\/java\/lang\/reflect\/AccessFlag$Location.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Requires$Modifier.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Requires.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$KeySet.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$KeyIterator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/Checks.class\",\n-            \"\/modules\/java.base\/java\/util\/ArrayList$Itr.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Provides.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections$UnmodifiableCollection.class\",\n-            \"\/modules\/java.base\/java\/util\/Collections$UnmodifiableSet.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$Values.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$ValueIterator.class\",\n-            \"\/modules\/java.base\/java\/util\/ImmutableCollections$SetN$SetNIterator.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$Attributes.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleReferences.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleReader.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixUriUtils.class\",\n-            \"\/modules\/java.base\/java\/net\/URI$Parser.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleReference.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleReferenceImpl.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Exports.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Opens.class\",\n-            \"\/modules\/java.base\/sun\/nio\/fs\/UnixException.class\",\n-            \"\/modules\/java.base\/java\/io\/IOException.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/ArchivedClassLoaders.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$BootClassLoader.class\",\n-            \"\/modules\/java.base\/java\/lang\/ClassLoader$ParallelLoaders.class\",\n-            \"\/modules\/java.base\/java\/util\/WeakHashMap.class\",\n-            \"\/modules\/java.base\/java\/util\/WeakHashMap$Entry.class\",\n-            \"\/modules\/java.base\/java\/util\/WeakHashMap$KeySet.class\",\n-            \"\/modules\/java.base\/java\/security\/Principal.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath.class\",\n-            \"\/modules\/java.base\/java\/net\/URLStreamHandlerFactory.class\",\n-            \"\/modules\/java.base\/java\/net\/URL$DefaultFactory.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/access\/JavaNetURLAccess.class\",\n-            \"\/modules\/java.base\/sun\/net\/www\/ParseUtil.class\",\n-            \"\/modules\/java.base\/java\/net\/URLStreamHandler.class\",\n-            \"\/modules\/java.base\/sun\/net\/www\/protocol\/file\/Handler.class\",\n-            \"\/modules\/java.base\/sun\/net\/util\/IPAddressUtil.class\",\n-            \"\/modules\/java.base\/sun\/net\/util\/IPAddressUtil$MASKS.class\",\n-            \"\/modules\/java.base\/sun\/net\/www\/protocol\/jar\/Handler.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ServicesCatalog.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/AbstractClassLoaderValue.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaderValue.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/BuiltinClassLoader$LoadedModule.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/DefaultRoots.class\",\n-            \"\/modules\/java.base\/java\/util\/Spliterator.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$HashMapSpliterator.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$ValueSpliterator.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/StreamSupport.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/BaseStream.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/Stream.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/PipelineHelper.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/AbstractPipeline.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline$Head.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag$Type.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag$MaskBuilder.class\",\n-            \"\/modules\/java.base\/java\/util\/EnumMap.class\",\n-            \"\/modules\/java.base\/java\/lang\/Class$ReflectionData.class\",\n-            \"\/modules\/java.base\/java\/lang\/Class$Atomic.class\",\n-            \"\/modules\/java.base\/java\/lang\/PublicMethods$MethodList.class\",\n-            \"\/modules\/java.base\/java\/lang\/PublicMethods$Key.class\",\n-            \"\/modules\/java.base\/sun\/reflect\/annotation\/AnnotationParser.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodHandleAccessorFactory$LazyStaticHolder.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Specializer.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/annotation\/Stable.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer$SpeciesData.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$SpeciesData.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer$Factory.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Specializer$Factory.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/SimpleMethodHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/NoSuchFieldException.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Accessor.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle$Holder.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor$TransformKey.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormBuffer.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor$Transform.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/reflect\/DirectMethodHandleAccessor.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/Collectors.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/Collector$Characteristics.class\",\n-            \"\/modules\/java.base\/java\/util\/EnumSet.class\",\n-            \"\/modules\/java.base\/java\/util\/RegularEnumSet.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/Collector.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/Collectors$CollectorImpl.class\",\n-            \"\/modules\/java.base\/java\/util\/function\/BiConsumer.class\",\n-            \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Interface.class\",\n-            \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/InterfaceMethodRefEntry.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$InterfaceMethodRefEntryImpl.class\",\n-            \"\/modules\/java.base\/java\/util\/function\/BinaryOperator.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/TerminalOp.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$ReduceOp.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/StreamShape.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/Sink.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/TerminalSink.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$AccumulatingSink.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$Box.class\",\n-            \"\/modules\/java.base\/java\/util\/HashMap$KeySpliterator.class\",\n-            \"\/modules\/java.base\/java\/util\/function\/Predicate.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline$StatelessOp.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/Sink$ChainedReference.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleResolution.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/FindOps.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindSink.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindSink$OfRef.class\",\n-            \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindOp.class\",\n-            \"\/modules\/java.base\/java\/util\/Spliterators.class\",\n-            \"\/modules\/java.base\/java\/util\/Spliterators$IteratorSpliterator.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/Configuration.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/Resolver.class\",\n-            \"\/modules\/java.base\/java\/lang\/ModuleLayer.class\",\n-            \"\/modules\/java.base\/java\/util\/SequencedSet.class\",\n-            \"\/modules\/java.base\/java\/util\/LinkedHashSet.class\",\n-            \"\/modules\/java.base\/java\/util\/SequencedMap.class\",\n-            \"\/modules\/java.base\/java\/util\/LinkedHashMap.class\",\n-            \"\/modules\/java.base\/java\/lang\/module\/ResolvedModule.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap$Mapper.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/AbstractClassLoaderValue$Memoizer.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ServicesCatalog$ServiceProvider.class\",\n-            \"\/modules\/java.base\/java\/util\/concurrent\/CopyOnWriteArrayList.class\",\n-            \"\/modules\/java.base\/java\/lang\/ModuleLayer$Controller.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$SafeModuleFinder.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/ContinuationSupport.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/vm\/Continuation$Pinned.class\",\n-            \"\/modules\/java.base\/sun\/launcher\/LauncherHelper.class\",\n-            \"\/modules\/java.base\/sun\/net\/util\/URLUtil.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath$Loader.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath$FileLoader.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/loader\/Resource.class\",\n-            \"\/modules\/java.base\/java\/io\/FileCleanable.class\",\n-            \"\/modules\/java.base\/sun\/nio\/ByteBuffered.class\",\n-            \"\/modules\/java.base\/java\/security\/SecureClassLoader$CodeSourceKey.class\",\n-            \"\/modules\/java.base\/java\/security\/PermissionCollection.class\",\n-            \"\/modules\/java.base\/java\/security\/Permissions.class\",\n-            \"\/modules\/java.base\/java\/lang\/NamedPackage.class\",\n-            \"\/modules\/java.base\/jdk\/internal\/misc\/MethodFinder.class\",\n-            \"\/modules\/java.base\/java\/lang\/Readable.class\",\n-            \"\/modules\/java.base\/java\/nio\/CharBuffer.class\",\n-            \"\/modules\/java.base\/java\/nio\/HeapCharBuffer.class\",\n-            \"\/modules\/java.base\/java\/nio\/charset\/CoderResult.class\",\n-            \"\/modules\/java.base\/java\/util\/IdentityHashMap$IdentityHashMapIterator.class\",\n-            \"\/modules\/java.base\/java\/util\/IdentityHashMap$KeyIterator.class\",\n-            \"\/modules\/java.base\/java\/lang\/Shutdown.class\",\n-            \"\/modules\/java.base\/java\/lang\/Shutdown$Lock.class\");\n+    \/\/\/ Note: This list is inherently a little fragile and may end up being more\n+    \/\/\/ trouble than it's worth to maintain. If it turns out that it needs to be\n+    \/\/\/ regenerated often when this benchmark is run, then a new approach should\n+    \/\/\/ be considered, such as:\n+    \/\/\/ * Limit the list of classes to non-internal ones.\n+    \/\/\/ * Calculate the list dynamically based on the running JVM.\n+    \/\/\/ * Build a custom jimage file similar to ImageReaderTest\n+    private static final class ClassList {\n+        \/\/\/ Returns the names of resource nodes expected to be present in the\n+        \/\/\/ reader, excluding preview mode paths (i.e. \"\/META-INF\/preview\/\").\n+        private static Set<String> names() {\n+            return INIT_CLASSES;\n+        }\n+\n+        \/\/\/ Returns the number of resources present.\n+        private static int count() {\n+            return INIT_CLASSES.size();\n+        }\n+\n+        \/\/\/ Returns the resource nodes represented as a map from module name to\n+        \/\/\/ resource path. This is suitable for testing functions like\n+        \/\/\/ {@link ImageReader#containsResource(String, String)} without the\n+        \/\/\/ overhead of splitting resource names during the trial.\n+        private static Map<String, List<String>> pathMap() {\n+            return MODULE_TO_PATHS;\n+        }\n+\n+        \/\/ Created by running \"java -verbose:class\", throwing away anonymous inner\n+        \/\/ classes and anything without a reliable name, and grouping by the stated\n+        \/\/ source. It's not perfect, but it's representative.\n+        \/\/\n+        \/\/ <jdk_root>\/bin\/java -verbose:class HelloWorld 2>&1 \\\n+        \/\/   | fgrep '[class,load]' | cut -d' ' -f2 \\\n+        \/\/   | tr '.' '\/' \\\n+        \/\/   | egrep -v '\\$[0-9$]' \\\n+        \/\/   | fgrep -v 'HelloWorld' \\\n+        \/\/   | fgrep -v '\/META-INF\/preview\/' \\\n+        \/\/   | while read f ; do echo \"${f}.class\" ; done \\\n+        \/\/   > initclasses.txt\n+        \/\/\n+        \/\/ Output:\n+        \/\/    java\/lang\/Object.class\n+        \/\/    java\/io\/Serializable.class\n+        \/\/    ...\n+        \/\/\n+        \/\/ jimage list <jdk_root>\/images\/jdk\/lib\/modules \\\n+        \/\/     | awk '\/^Module: *\/ { MOD=$2 }; \/^    *\/ { print \"\/modules\/\"MOD\"\/\"$1 }' \\\n+        \/\/     > fullpaths.txt\n+        \/\/\n+        \/\/ Output:\n+        \/\/     ...\n+        \/\/     \/modules\/java.base\/java\/lang\/Object.class\n+        \/\/     \/modules\/java.base\/java\/lang\/OutOfMemoryError.class\n+        \/\/     ...\n+        \/\/\n+        \/\/ while read c ; do grep \"\/$c\" fullpaths.txt ; done < initclasses.txt \\\n+        \/\/     | while read c ; do printf '    \"%s\",\\n' \"$c\" ; done \\\n+        \/\/     > initpaths.txt\n+        \/\/\n+        \/\/ Output:\n+        private static final Set<String> INIT_CLASSES = Set.of(\n+                \"\/modules\/java.base\/java\/lang\/Object.class\",\n+                \"\/modules\/java.base\/java\/io\/Serializable.class\",\n+                \"\/modules\/java.base\/java\/lang\/Comparable.class\",\n+                \"\/modules\/java.base\/java\/lang\/CharSequence.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/Constable.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/ConstantDesc.class\",\n+                \"\/modules\/java.base\/java\/lang\/String.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/AnnotatedElement.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/GenericDeclaration.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Type.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor$OfField.class\",\n+                \"\/modules\/java.base\/java\/lang\/Class.class\",\n+                \"\/modules\/java.base\/java\/lang\/Cloneable.class\",\n+                \"\/modules\/java.base\/java\/lang\/ClassLoader.class\",\n+                \"\/modules\/java.base\/java\/lang\/System.class\",\n+                \"\/modules\/java.base\/java\/lang\/Throwable.class\",\n+                \"\/modules\/java.base\/java\/lang\/Error.class\",\n+                \"\/modules\/java.base\/java\/lang\/Exception.class\",\n+                \"\/modules\/java.base\/java\/lang\/RuntimeException.class\",\n+                \"\/modules\/java.base\/java\/security\/ProtectionDomain.class\",\n+                \"\/modules\/java.base\/java\/security\/SecureClassLoader.class\",\n+                \"\/modules\/java.base\/java\/lang\/ReflectiveOperationException.class\",\n+                \"\/modules\/java.base\/java\/lang\/ClassNotFoundException.class\",\n+                \"\/modules\/java.base\/java\/lang\/Record.class\",\n+                \"\/modules\/java.base\/java\/lang\/LinkageError.class\",\n+                \"\/modules\/java.base\/java\/lang\/NoClassDefFoundError.class\",\n+                \"\/modules\/java.base\/java\/lang\/ClassCastException.class\",\n+                \"\/modules\/java.base\/java\/lang\/ArrayStoreException.class\",\n+                \"\/modules\/java.base\/java\/lang\/VirtualMachineError.class\",\n+                \"\/modules\/java.base\/java\/lang\/InternalError.class\",\n+                \"\/modules\/java.base\/java\/lang\/OutOfMemoryError.class\",\n+                \"\/modules\/java.base\/java\/lang\/StackOverflowError.class\",\n+                \"\/modules\/java.base\/java\/lang\/IllegalMonitorStateException.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/Reference.class\",\n+                \"\/modules\/java.base\/java\/lang\/IllegalCallerException.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/SoftReference.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/WeakReference.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/FinalReference.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/PhantomReference.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/Finalizer.class\",\n+                \"\/modules\/java.base\/java\/lang\/Runnable.class\",\n+                \"\/modules\/java.base\/java\/lang\/Thread.class\",\n+                \"\/modules\/java.base\/java\/lang\/Thread$FieldHolder.class\",\n+                \"\/modules\/java.base\/java\/lang\/Thread$Constants.class\",\n+                \"\/modules\/java.base\/java\/lang\/Thread$UncaughtExceptionHandler.class\",\n+                \"\/modules\/java.base\/java\/lang\/ThreadGroup.class\",\n+                \"\/modules\/java.base\/java\/lang\/BaseVirtualThread.class\",\n+                \"\/modules\/java.base\/java\/lang\/VirtualThread.class\",\n+                \"\/modules\/java.base\/java\/lang\/ThreadBuilders$BoundVirtualThread.class\",\n+                \"\/modules\/java.base\/java\/util\/Map.class\",\n+                \"\/modules\/java.base\/java\/util\/Dictionary.class\",\n+                \"\/modules\/java.base\/java\/util\/Hashtable.class\",\n+                \"\/modules\/java.base\/java\/util\/Properties.class\",\n+                \"\/modules\/java.base\/java\/lang\/Module.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/AccessibleObject.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Member.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Field.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Parameter.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Executable.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Method.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Constructor.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/ContinuationScope.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/Continuation.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/StackChunk.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodAccessor.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodAccessorImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstantPool.class\",\n+                \"\/modules\/java.base\/java\/lang\/annotation\/Annotation.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/CallerSensitive.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstructorAccessor.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/ConstructorAccessorImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/DirectConstructorHandleAccessor$NativeAccessor.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MemberName.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/ResolvedMethodName.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleNatives.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/TypeDescriptor$OfMethod.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodType.class\",\n+                \"\/modules\/java.base\/java\/lang\/BootstrapMethodError.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/CallSite.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/ABIDescriptor.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/VMStorage.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/foreign\/abi\/UpcallLinker$CallRegs.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/ConstantCallSite.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MutableCallSite.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VolatileCallSite.class\",\n+                \"\/modules\/java.base\/java\/lang\/AssertionStatusDirectives.class\",\n+                \"\/modules\/java.base\/java\/lang\/Appendable.class\",\n+                \"\/modules\/java.base\/java\/lang\/AbstractStringBuilder.class\",\n+                \"\/modules\/java.base\/java\/lang\/StringBuffer.class\",\n+                \"\/modules\/java.base\/java\/lang\/StringBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/UnsafeConstants.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/Unsafe.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/Modules.class\",\n+                \"\/modules\/java.base\/java\/lang\/AutoCloseable.class\",\n+                \"\/modules\/java.base\/java\/io\/Closeable.class\",\n+                \"\/modules\/java.base\/java\/io\/InputStream.class\",\n+                \"\/modules\/java.base\/java\/io\/ByteArrayInputStream.class\",\n+                \"\/modules\/java.base\/java\/net\/URL.class\",\n+                \"\/modules\/java.base\/java\/lang\/Enum.class\",\n+                \"\/modules\/java.base\/java\/util\/jar\/Manifest.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/BuiltinClassLoader.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$AppClassLoader.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$PlatformClassLoader.class\",\n+                \"\/modules\/java.base\/java\/security\/CodeSource.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentMap.class\",\n+                \"\/modules\/java.base\/java\/util\/AbstractMap.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap.class\",\n+                \"\/modules\/java.base\/java\/lang\/Iterable.class\",\n+                \"\/modules\/java.base\/java\/util\/Collection.class\",\n+                \"\/modules\/java.base\/java\/util\/SequencedCollection.class\",\n+                \"\/modules\/java.base\/java\/util\/List.class\",\n+                \"\/modules\/java.base\/java\/util\/RandomAccess.class\",\n+                \"\/modules\/java.base\/java\/util\/AbstractCollection.class\",\n+                \"\/modules\/java.base\/java\/util\/AbstractList.class\",\n+                \"\/modules\/java.base\/java\/util\/ArrayList.class\",\n+                \"\/modules\/java.base\/java\/lang\/StackTraceElement.class\",\n+                \"\/modules\/java.base\/java\/nio\/Buffer.class\",\n+                \"\/modules\/java.base\/java\/lang\/StackWalker.class\",\n+                \"\/modules\/java.base\/java\/lang\/StackStreamFactory$AbstractStackWalker.class\",\n+                \"\/modules\/java.base\/java\/lang\/StackWalker$StackFrame.class\",\n+                \"\/modules\/java.base\/java\/lang\/ClassFrameInfo.class\",\n+                \"\/modules\/java.base\/java\/lang\/StackFrameInfo.class\",\n+                \"\/modules\/java.base\/java\/lang\/LiveStackFrame.class\",\n+                \"\/modules\/java.base\/java\/lang\/LiveStackFrameInfo.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractOwnableSynchronizer.class\",\n+                \"\/modules\/java.base\/java\/lang\/Boolean.class\",\n+                \"\/modules\/java.base\/java\/lang\/Character.class\",\n+                \"\/modules\/java.base\/java\/lang\/Number.class\",\n+                \"\/modules\/java.base\/java\/lang\/Float.class\",\n+                \"\/modules\/java.base\/java\/lang\/Double.class\",\n+                \"\/modules\/java.base\/java\/lang\/Byte.class\",\n+                \"\/modules\/java.base\/java\/lang\/Short.class\",\n+                \"\/modules\/java.base\/java\/lang\/Integer.class\",\n+                \"\/modules\/java.base\/java\/lang\/Long.class\",\n+                \"\/modules\/java.base\/java\/lang\/Void.class\",\n+                \"\/modules\/java.base\/java\/util\/Iterator.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/RecordComponent.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$Vector.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorMask.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/FillerObject.class\",\n+                \"\/modules\/java.base\/java\/lang\/NullPointerException.class\",\n+                \"\/modules\/java.base\/java\/lang\/ArithmeticException.class\",\n+                \"\/modules\/java.base\/java\/lang\/IndexOutOfBoundsException.class\",\n+                \"\/modules\/java.base\/java\/lang\/ArrayIndexOutOfBoundsException.class\",\n+                \"\/modules\/java.base\/java\/io\/ObjectStreamField.class\",\n+                \"\/modules\/java.base\/java\/util\/Comparator.class\",\n+                \"\/modules\/java.base\/java\/lang\/String$CaseInsensitiveComparator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/VM.class\",\n+                \"\/modules\/java.base\/java\/lang\/Module$ArchivedData.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/CDS.class\",\n+                \"\/modules\/java.base\/java\/util\/Set.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableCollection.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableSet.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$Set12.class\",\n+                \"\/modules\/java.base\/java\/util\/Objects.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableList.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$ListN.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$SetN.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$AbstractImmutableMap.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$MapN.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangReflectAccess.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/ReflectAccess.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/SharedSecrets.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/ReflectionFactory.class\",\n+                \"\/modules\/java.base\/java\/io\/ObjectStreamClass.class\",\n+                \"\/modules\/java.base\/java\/lang\/Math.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/ReflectionFactory$Config.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangRefAccess.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue$Null.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/ReferenceQueue$Lock.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangAccess.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/SystemProps.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/SystemProps$Raw.class\",\n+                \"\/modules\/java.base\/java\/nio\/charset\/Charset.class\",\n+                \"\/modules\/java.base\/java\/nio\/charset\/spi\/CharsetProvider.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/StandardCharsets.class\",\n+                \"\/modules\/java.base\/java\/lang\/StringLatin1.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/HistoricallyNamedCharset.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/Unicode.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_8.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap.class\",\n+                \"\/modules\/java.base\/java\/lang\/StrictMath.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/ArraysSupport.class\",\n+                \"\/modules\/java.base\/java\/util\/Map$Entry.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$Node.class\",\n+                \"\/modules\/java.base\/java\/util\/LinkedHashMap$Entry.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$TreeNode.class\",\n+                \"\/modules\/java.base\/java\/lang\/StringConcatHelper.class\",\n+                \"\/modules\/java.base\/java\/lang\/VersionProps.class\",\n+                \"\/modules\/java.base\/java\/lang\/Runtime.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/Lock.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Segment.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$CounterCell.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Node.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/LockSupport.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ReservationNode.class\",\n+                \"\/modules\/java.base\/java\/util\/AbstractSet.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$EntrySet.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$HashIterator.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$EntryIterator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/StaticProperty.class\",\n+                \"\/modules\/java.base\/java\/io\/FileInputStream.class\",\n+                \"\/modules\/java.base\/java\/lang\/System$In.class\",\n+                \"\/modules\/java.base\/java\/io\/FileDescriptor.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.class\",\n+                \"\/modules\/java.base\/java\/io\/Flushable.class\",\n+                \"\/modules\/java.base\/java\/io\/OutputStream.class\",\n+                \"\/modules\/java.base\/java\/io\/FileOutputStream.class\",\n+                \"\/modules\/java.base\/java\/lang\/System$Out.class\",\n+                \"\/modules\/java.base\/java\/io\/FilterInputStream.class\",\n+                \"\/modules\/java.base\/java\/io\/BufferedInputStream.class\",\n+                \"\/modules\/java.base\/java\/io\/FilterOutputStream.class\",\n+                \"\/modules\/java.base\/java\/io\/PrintStream.class\",\n+                \"\/modules\/java.base\/java\/io\/BufferedOutputStream.class\",\n+                \"\/modules\/java.base\/java\/io\/Writer.class\",\n+                \"\/modules\/java.base\/java\/io\/OutputStreamWriter.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/StreamEncoder.class\",\n+                \"\/modules\/java.base\/java\/nio\/charset\/CharsetEncoder.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_8$Encoder.class\",\n+                \"\/modules\/java.base\/java\/nio\/charset\/CodingErrorAction.class\",\n+                \"\/modules\/java.base\/java\/util\/Arrays.class\",\n+                \"\/modules\/java.base\/java\/nio\/ByteBuffer.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/ScopedMemoryAccess.class\",\n+                \"\/modules\/java.base\/java\/util\/function\/Function.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/Preconditions.class\",\n+                \"\/modules\/java.base\/java\/util\/function\/BiFunction.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaNioAccess.class\",\n+                \"\/modules\/java.base\/java\/nio\/HeapByteBuffer.class\",\n+                \"\/modules\/java.base\/java\/nio\/ByteOrder.class\",\n+                \"\/modules\/java.base\/java\/io\/BufferedWriter.class\",\n+                \"\/modules\/java.base\/java\/lang\/Terminator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/Signal$Handler.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/Signal.class\",\n+                \"\/modules\/java.base\/java\/util\/Hashtable$Entry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/Signal$NativeHandler.class\",\n+                \"\/modules\/java.base\/java\/lang\/Integer$IntegerCache.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/OSEnvironment.class\",\n+                \"\/modules\/java.base\/java\/lang\/Thread$State.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/Reference$ReferenceHandler.class\",\n+                \"\/modules\/java.base\/java\/lang\/Thread$ThreadIdentifiers.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/Finalizer$FinalizerThread.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/Cleaner.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections$EmptySet.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections$EmptyList.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections$EmptyMap.class\",\n+                \"\/modules\/java.base\/java\/lang\/IllegalArgumentException.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleStatics.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/ClassFileFormatVersion.class\",\n+                \"\/modules\/java.base\/java\/lang\/CharacterData.class\",\n+                \"\/modules\/java.base\/java\/lang\/CharacterDataLatin1.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/ClassFileDumper.class\",\n+                \"\/modules\/java.base\/java\/util\/HexFormat.class\",\n+                \"\/modules\/java.base\/java\/lang\/Character$CharacterCache.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/atomic\/AtomicInteger.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MemberName$Factory.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/Reflection.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles$Lookup.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$MapN$MapNIterator.class\",\n+                \"\/modules\/java.base\/java\/util\/KeyValueHolder.class\",\n+                \"\/modules\/java.base\/sun\/invoke\/util\/VerifyAccess.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Modifier.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangModuleAccess.class\",\n+                \"\/modules\/java.base\/java\/io\/File.class\",\n+                \"\/modules\/java.base\/java\/io\/DefaultFileSystem.class\",\n+                \"\/modules\/java.base\/java\/io\/FileSystem.class\",\n+                \"\/modules\/java.base\/java\/io\/UnixFileSystem.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/DecimalDigits.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModulePatcher.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$IllegalNativeAccess.class\",\n+                \"\/modules\/java.base\/java\/util\/HashSet.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap$Modules.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$Counters.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ArchivedBootLayer.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ArchivedModuleGraph.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/SystemModuleFinders.class\",\n+                \"\/modules\/java.base\/java\/net\/URI.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaNetUriAccess.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/SystemModulesMap.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/SystemModules.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ExplodedSystemModules.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/Watchable.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/Path.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/FileSystems.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/DefaultFileSystemProvider.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/spi\/FileSystemProvider.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/AbstractFileSystemProvider.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileSystemProvider.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/LinuxFileSystemProvider.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/OpenOption.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/StandardOpenOption.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/FileSystem.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileSystem.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/LinuxFileSystem.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixPath.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/Util.class\",\n+                \"\/modules\/java.base\/java\/lang\/StringCoding.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixNativeDispatcher.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/BootLoader.class\",\n+                \"\/modules\/java.base\/java\/lang\/Module$EnableNativeAccess.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaderHelper.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$CollectionView.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$KeySetView.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$LibraryPaths.class\",\n+                \"\/modules\/java.base\/java\/io\/File$PathStatus.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$CountedLock.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock$Sync.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantLock$NonfairSync.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$NativeLibraryContext.class\",\n+                \"\/modules\/java.base\/java\/util\/Queue.class\",\n+                \"\/modules\/java.base\/java\/util\/Deque.class\",\n+                \"\/modules\/java.base\/java\/util\/ArrayDeque.class\",\n+                \"\/modules\/java.base\/java\/util\/ArrayDeque$DeqIterator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibrary.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/NativeLibraries$NativeLibraryImpl.class\",\n+                \"\/modules\/java.base\/java\/security\/cert\/Certificate.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ValuesView.class\",\n+                \"\/modules\/java.base\/java\/util\/Enumeration.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$Traverser.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$BaseIterator.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ConcurrentHashMap$ValueIterator.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/BasicFileAttributes.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/PosixFileAttributes.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributes.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileStoreAttributes.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixMountEntry.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/CopyOption.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/LinkOption.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/Files.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffers.class\",\n+                \"\/modules\/java.base\/java\/lang\/ThreadLocal.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/CarrierThreadLocal.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/TerminatingThreadLocal.class\",\n+                \"\/modules\/java.base\/java\/lang\/ThreadLocal$ThreadLocalMap.class\",\n+                \"\/modules\/java.base\/java\/lang\/ThreadLocal$ThreadLocalMap$Entry.class\",\n+                \"\/modules\/java.base\/java\/util\/IdentityHashMap.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections$SetFromMap.class\",\n+                \"\/modules\/java.base\/java\/util\/IdentityHashMap$KeySet.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffer.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerFactory.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/ThreadFactory.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/Cleaner.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanableList.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanableList$Node.class\",\n+                \"\/modules\/java.base\/java\/lang\/ref\/Cleaner$Cleanable.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/PhantomCleanable.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$CleanerCleanable.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/InnocuousThread.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/NativeBuffer$Deallocator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/ref\/CleanerImpl$PhantomCleanableRef.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleFinder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModulePath.class\",\n+                \"\/modules\/java.base\/java\/util\/jar\/Attributes$Name.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/Array.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/perf\/PerfCounter.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/perf\/Perf.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/DirectBuffer.class\",\n+                \"\/modules\/java.base\/java\/nio\/MappedByteBuffer.class\",\n+                \"\/modules\/java.base\/java\/nio\/DirectByteBuffer.class\",\n+                \"\/modules\/java.base\/java\/nio\/Bits.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/atomic\/AtomicLong.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/VM$BufferPool.class\",\n+                \"\/modules\/java.base\/java\/nio\/LongBuffer.class\",\n+                \"\/modules\/java.base\/java\/nio\/DirectLongBufferU.class\",\n+                \"\/modules\/java.base\/java\/util\/zip\/ZipConstants.class\",\n+                \"\/modules\/java.base\/java\/util\/zip\/ZipFile.class\",\n+                \"\/modules\/java.base\/java\/util\/jar\/JarFile.class\",\n+                \"\/modules\/java.base\/java\/util\/BitSet.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilZipFileAccess.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilJarAccess.class\",\n+                \"\/modules\/java.base\/java\/util\/jar\/JavaUtilJarAccessImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/Runtime$Version.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$List12.class\",\n+                \"\/modules\/java.base\/java\/util\/Optional.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/DosFileAttributes.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/AttributeView.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/FileAttributeView.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/BasicFileAttributeView.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/DosFileAttributeView.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/UserDefinedFileAttributeView.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributeViews.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/DynamicFileAttributeView.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/AbstractBasicFileAttributeView.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributeViews$Basic.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileAttributes$UnixAsBasicFileAttributes.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/DirectoryStream$Filter.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/Files$AcceptAllFilter.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/DirectoryStream.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/SecureDirectoryStream.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixSecureDirectoryStream.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixDirectoryStream.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReadWriteLock.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$Sync.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$FairSync.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$ReadLock.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock$WriteLock.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixDirectoryStream$UnixDirectoryIterator.class\",\n+                \"\/modules\/java.base\/java\/nio\/file\/attribute\/FileAttribute.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixFileModeAttribute.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixChannelFactory.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixChannelFactory$Flags.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections$EmptyIterator.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/Channel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/ReadableByteChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/WritableByteChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/ByteChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/SeekableByteChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/GatheringByteChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/ScatteringByteChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/InterruptibleChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/FileChannel.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/FileChannelImpl.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/NativeDispatcher.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/FileDispatcher.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/UnixFileDispatcherImpl.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/FileDispatcherImpl.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/IOUtil.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/Interruptible.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/NativeThreadSet.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/FileChannelImpl$Closer.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/Channels.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/Streams.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/SelChImpl.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/NetworkChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/SelectableChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/spi\/AbstractSelectableChannel.class\",\n+                \"\/modules\/java.base\/java\/nio\/channels\/SocketChannel.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/SocketChannelImpl.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/ChannelInputStream.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaMetafactory.class\",\n+                \"\/modules\/java.base\/java\/util\/function\/Supplier.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/ReferencedKeySet.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/ReferencedKeyMap.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/ReferenceKey.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/StrongReferenceKey.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodTypeForm.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/WeakReferenceKey.class\",\n+                \"\/modules\/java.base\/sun\/invoke\/util\/Wrapper.class\",\n+                \"\/modules\/java.base\/sun\/invoke\/util\/Wrapper$Format.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/ConstantDescs.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/ClassDesc.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/constant\/ArrayClassDescImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/constant\/ConstantUtils.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/DirectMethodHandleDesc$Kind.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/MethodTypeDesc.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/constant\/MethodTypeDescImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/MethodHandleDesc.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/DirectMethodHandleDesc.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/constant\/DirectMethodHandleDescImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/DynamicConstantDesc.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/constant\/PrimitiveClassDescImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/constant\/DynamicConstantDesc$AnonymousDynamicConstantDesc.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$NamedFunction.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Holder.class\",\n+                \"\/modules\/java.base\/sun\/invoke\/util\/ValueConversions.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/Invokers.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Kind.class\",\n+                \"\/modules\/java.base\/java\/lang\/NoSuchMethodException.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$BasicType.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/TypeKind.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Name.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaForm$Holder.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/InvokerBytecodeGenerator.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/AnnotationElement.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Annotation.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ConstantPool.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/PoolEntry.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/AnnotationConstantValueEntry.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/Utf8Entry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$Utf8EntryImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$Utf8EntryImpl$State.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AnnotationImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassFileElement.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Attribute.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassElement.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/MethodElement.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/FieldElement.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/Util$Writable.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractElement.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$UnboundRuntimeVisibleAnnotationsAttribute.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Attributes.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/AttributeMapper.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$RuntimeVisibleAnnotationsMapper.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/AttributeMapper$AttributeStability.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleImpl$Intrinsic.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/SplitConstantPool.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/BootstrapMethodEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/EntryMap.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/Util.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/ClassEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractRefEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractNamedEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$ClassEntryImpl.class\",\n+                \"\/modules\/java.base\/java\/util\/function\/Consumer.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassFile.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassFileImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassFileBuilder.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AttributeHolder.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Superclass.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/SuperclassImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/attribute\/SourceFileAttribute.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$UnboundSourceFileAttribute.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$SourceFileMapper.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BoundAttribute.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/MethodBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/MethodInfo.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalMethodBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/NameAndTypeEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractRefsEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$NameAndTypeEntryImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/MemberRefEntry.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/FieldRefEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$AbstractMemberRefEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$FieldRefEntryImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/InvokerBytecodeGenerator$ClassData.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/CodeBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/LabelContext.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/CodeElement.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/PseudoInstruction.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/CharacterRange.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LocalVariable.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LocalVariableType.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder$DeferredLabel.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/BufWriter.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BufWriterImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Label.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/instruction\/LabelTarget.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/LabelImpl.class\",\n+                \"\/modules\/java.base\/sun\/invoke\/util\/VerifyType.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Opcode.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Opcode$Kind.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/MethodRefEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$MethodRefEntryImpl.class\",\n+                \"\/modules\/java.base\/sun\/invoke\/empty\/Empty.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/UnboundAttribute$AdHocAttribute.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper$CodeMapper.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/FieldBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/TerminalFieldBuilder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/CustomAttribute.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AnnotationReader.class\",\n+                \"\/modules\/java.base\/java\/util\/ListIterator.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$ListItr.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator$Frame.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/StackMapGenerator$Type.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper$CodeRange.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassHierarchyResolver.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$ClassLoadingClassHierarchyResolver.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$CachedClassHierarchyResolver.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassHierarchyResolver$ClassHierarchyInfo.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl$ClassHierarchyInfoImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/ClassReader.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/ModifiedUtf.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandles$Lookup$ClassDefiner.class\",\n+                \"\/modules\/java.base\/java\/lang\/IncompatibleClassChangeError.class\",\n+                \"\/modules\/java.base\/java\/lang\/NoSuchMethodError.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/BootstrapMethodInvoker.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/InnerClassLambdaMetafactory.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/MethodHandleInfo.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/InfoFromMemberName.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$Access.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaUtilCollectionAccess.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/Interfaces.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/InterfacesImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/TypeConvertingMethodAdapter.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Constructor.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaLangInvokeAccess.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessMode.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessType.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/Invokers$Holder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo.class\",\n+                \"\/modules\/java.base\/java\/io\/DataInput.class\",\n+                \"\/modules\/java.base\/java\/io\/DataInputStream.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$CountingDataInput.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/NativeThread.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/Blocker.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/Util.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/Util$BufferCache.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ch\/IOStatus.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/util\/ByteArray.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandles.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsShorts$ByteArrayViewVarHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsShorts$ArrayHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleGuards.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarForm.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsChars$ByteArrayViewVarHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsChars$ArrayHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsInts$ByteArrayViewVarHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsInts$ArrayHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsFloats$ByteArrayViewVarHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsFloats$ArrayHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsLongs$ByteArrayViewVarHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsLongs$ArrayHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsDoubles$ByteArrayViewVarHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandleByteArrayAsDoubles$ArrayHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/VarHandle$AccessDescriptor.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$Entry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$IndexEntry.class\",\n+                \"\/modules\/java.base\/java\/nio\/charset\/StandardCharsets.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/US_ASCII.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/ISO_8859_1.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16BE.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16LE.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_16.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32BE.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32LE.class\",\n+                \"\/modules\/java.base\/sun\/nio\/cs\/UTF_32.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$ConstantPool$ValueEntry.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Builder.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Modifier.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/AccessFlag.class\",\n+                \"\/modules\/java.base\/java\/lang\/reflect\/AccessFlag$Location.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Requires$Modifier.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Requires.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$KeySet.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$KeyIterator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/Checks.class\",\n+                \"\/modules\/java.base\/java\/util\/ArrayList$Itr.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Provides.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections$UnmodifiableCollection.class\",\n+                \"\/modules\/java.base\/java\/util\/Collections$UnmodifiableSet.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$Values.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$ValueIterator.class\",\n+                \"\/modules\/java.base\/java\/util\/ImmutableCollections$SetN$SetNIterator.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleInfo$Attributes.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleReferences.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleReader.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixUriUtils.class\",\n+                \"\/modules\/java.base\/java\/net\/URI$Parser.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleReference.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleReferenceImpl.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Exports.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ModuleDescriptor$Opens.class\",\n+                \"\/modules\/java.base\/sun\/nio\/fs\/UnixException.class\",\n+                \"\/modules\/java.base\/java\/io\/IOException.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/ArchivedClassLoaders.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaders$BootClassLoader.class\",\n+                \"\/modules\/java.base\/java\/lang\/ClassLoader$ParallelLoaders.class\",\n+                \"\/modules\/java.base\/java\/util\/WeakHashMap.class\",\n+                \"\/modules\/java.base\/java\/util\/WeakHashMap$Entry.class\",\n+                \"\/modules\/java.base\/java\/util\/WeakHashMap$KeySet.class\",\n+                \"\/modules\/java.base\/java\/security\/Principal.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath.class\",\n+                \"\/modules\/java.base\/java\/net\/URLStreamHandlerFactory.class\",\n+                \"\/modules\/java.base\/java\/net\/URL$DefaultFactory.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/access\/JavaNetURLAccess.class\",\n+                \"\/modules\/java.base\/sun\/net\/www\/ParseUtil.class\",\n+                \"\/modules\/java.base\/java\/net\/URLStreamHandler.class\",\n+                \"\/modules\/java.base\/sun\/net\/www\/protocol\/file\/Handler.class\",\n+                \"\/modules\/java.base\/sun\/net\/util\/IPAddressUtil.class\",\n+                \"\/modules\/java.base\/sun\/net\/util\/IPAddressUtil$MASKS.class\",\n+                \"\/modules\/java.base\/sun\/net\/www\/protocol\/jar\/Handler.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ServicesCatalog.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/AbstractClassLoaderValue.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/ClassLoaderValue.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/BuiltinClassLoader$LoadedModule.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/DefaultRoots.class\",\n+                \"\/modules\/java.base\/java\/util\/Spliterator.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$HashMapSpliterator.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$ValueSpliterator.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/StreamSupport.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/BaseStream.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/Stream.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/PipelineHelper.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/AbstractPipeline.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline$Head.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag$Type.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/StreamOpFlag$MaskBuilder.class\",\n+                \"\/modules\/java.base\/java\/util\/EnumMap.class\",\n+                \"\/modules\/java.base\/java\/lang\/Class$ReflectionData.class\",\n+                \"\/modules\/java.base\/java\/lang\/Class$Atomic.class\",\n+                \"\/modules\/java.base\/java\/lang\/PublicMethods$MethodList.class\",\n+                \"\/modules\/java.base\/java\/lang\/PublicMethods$Key.class\",\n+                \"\/modules\/java.base\/sun\/reflect\/annotation\/AnnotationParser.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/MethodHandleAccessorFactory$LazyStaticHolder.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Specializer.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/annotation\/Stable.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer$SpeciesData.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$SpeciesData.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/ClassSpecializer$Factory.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Specializer$Factory.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/SimpleMethodHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/NoSuchFieldException.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/BoundMethodHandle$Species_L.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Accessor.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle$Holder.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor$TransformKey.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormBuffer.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/LambdaFormEditor$Transform.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/reflect\/DirectMethodHandleAccessor.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/Collectors.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/Collector$Characteristics.class\",\n+                \"\/modules\/java.base\/java\/util\/EnumSet.class\",\n+                \"\/modules\/java.base\/java\/util\/RegularEnumSet.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/Collector.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/Collectors$CollectorImpl.class\",\n+                \"\/modules\/java.base\/java\/util\/function\/BiConsumer.class\",\n+                \"\/modules\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Interface.class\",\n+                \"\/modules\/java.base\/java\/lang\/classfile\/constantpool\/InterfaceMethodRefEntry.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry$InterfaceMethodRefEntryImpl.class\",\n+                \"\/modules\/java.base\/java\/util\/function\/BinaryOperator.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/ReduceOps.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/TerminalOp.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$ReduceOp.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/StreamShape.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/Sink.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/TerminalSink.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$AccumulatingSink.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/ReduceOps$Box.class\",\n+                \"\/modules\/java.base\/java\/util\/HashMap$KeySpliterator.class\",\n+                \"\/modules\/java.base\/java\/util\/function\/Predicate.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/ReferencePipeline$StatelessOp.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/Sink$ChainedReference.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleResolution.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/FindOps.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindSink.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindSink$OfRef.class\",\n+                \"\/modules\/java.base\/java\/util\/stream\/FindOps$FindOp.class\",\n+                \"\/modules\/java.base\/java\/util\/Spliterators.class\",\n+                \"\/modules\/java.base\/java\/util\/Spliterators$IteratorSpliterator.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/Configuration.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/Resolver.class\",\n+                \"\/modules\/java.base\/java\/lang\/ModuleLayer.class\",\n+                \"\/modules\/java.base\/java\/util\/SequencedSet.class\",\n+                \"\/modules\/java.base\/java\/util\/LinkedHashSet.class\",\n+                \"\/modules\/java.base\/java\/util\/SequencedMap.class\",\n+                \"\/modules\/java.base\/java\/util\/LinkedHashMap.class\",\n+                \"\/modules\/java.base\/java\/lang\/module\/ResolvedModule.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleLoaderMap$Mapper.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/AbstractClassLoaderValue$Memoizer.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ServicesCatalog$ServiceProvider.class\",\n+                \"\/modules\/java.base\/java\/util\/concurrent\/CopyOnWriteArrayList.class\",\n+                \"\/modules\/java.base\/java\/lang\/ModuleLayer$Controller.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/module\/ModuleBootstrap$SafeModuleFinder.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/ContinuationSupport.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/vm\/Continuation$Pinned.class\",\n+                \"\/modules\/java.base\/sun\/launcher\/LauncherHelper.class\",\n+                \"\/modules\/java.base\/sun\/net\/util\/URLUtil.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath$Loader.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/URLClassPath$FileLoader.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/loader\/Resource.class\",\n+                \"\/modules\/java.base\/java\/io\/FileCleanable.class\",\n+                \"\/modules\/java.base\/sun\/nio\/ByteBuffered.class\",\n+                \"\/modules\/java.base\/java\/security\/SecureClassLoader$CodeSourceKey.class\",\n+                \"\/modules\/java.base\/java\/security\/PermissionCollection.class\",\n+                \"\/modules\/java.base\/java\/security\/Permissions.class\",\n+                \"\/modules\/java.base\/java\/lang\/NamedPackage.class\",\n+                \"\/modules\/java.base\/jdk\/internal\/misc\/MethodFinder.class\",\n+                \"\/modules\/java.base\/java\/lang\/Readable.class\",\n+                \"\/modules\/java.base\/java\/nio\/CharBuffer.class\",\n+                \"\/modules\/java.base\/java\/nio\/HeapCharBuffer.class\",\n+                \"\/modules\/java.base\/java\/nio\/charset\/CoderResult.class\",\n+                \"\/modules\/java.base\/java\/util\/IdentityHashMap$IdentityHashMapIterator.class\",\n+                \"\/modules\/java.base\/java\/util\/IdentityHashMap$KeyIterator.class\",\n+                \"\/modules\/java.base\/java\/lang\/Shutdown.class\",\n+                \"\/modules\/java.base\/java\/lang\/Shutdown$Lock.class\");\n+\n+        private static final Pattern SPLIT_MODULE_AND_PATH = Pattern.compile(\"\/modules\/([^\/]+)\/(.*)\");\n+\n+        private static final Map<String, List<String>> MODULE_TO_PATHS = INIT_CLASSES.stream()\n+                .map(name -> {\n+                    Matcher m = SPLIT_MODULE_AND_PATH.matcher(name);\n+                    if (!m.matches()) {\n+                        throw new IllegalArgumentException(\"Bad resource name: \" + name);\n+                    }\n+                    return m.toMatchResult();\n+                })\n+                .collect(groupingBy(m -> m.group(1), mapping(m -> m.group(2), toList())));\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":992,"deletions":869,"binary":false,"changes":1861,"status":"modified"}]}