{"files":[{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights vectorReserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood ShovectorRes, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.stream.IntStream;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--enable-preview\", \"-Xbatch\",  \"-XX:-TieredCompilation\"})\n+public class Float16OpsBenchmark {\n+    @Param({\"256\", \"512\", \"1024\", \"2048\"})\n+    int vectorDim;\n+\n+    int     [] rexp;\n+    Float16 [] vectorRes;\n+    Float16 [] vector1;\n+    Float16 [] vector2;\n+    Float16 [] vector3;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        rexp      = new int[vectorDim];\n+        vectorRes = new Float16[vectorDim];\n+        vector1   = new Float16[vectorDim];\n+        vector2   = new Float16[vectorDim];\n+        vector3   = new Float16[vectorDim];\n+\n+        IntStream.range(0, vectorDim).forEach(i -> {vector1[i] = Float16.valueOf((short)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector2[i] = Float16.valueOf((short)i);});\n+        IntStream.range(0, vectorDim).forEach(i -> {vector3[i] = Float16.valueOf((short)i);});\n+\n+        \/\/ Special Values\n+        Float16 [] specialValues = {Float16.NaN, Float16.NEGATIVE_INFINITY, Float16.valueOf(0.0), Float16.valueOf(-0.0), Float16.POSITIVE_INFINITY};\n+        IntStream.range(0, vectorDim).forEach(\n+            i -> {\n+                if ((i % 64) == 0) {\n+                    int idx1 = i % specialValues.length;\n+                    int idx2 = (i + 1) % specialValues.length;\n+                    int idx3 = (i + 2) % specialValues.length;\n+                    vector1[i] = specialValues[idx1];\n+                    vector2[i] = specialValues[idx2];\n+                    vector3[i] = specialValues[idx3];\n+                }\n+            }\n+        );\n+    }\n+\n+    @Benchmark\n+    public void addBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.add(vector1[i], vector2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void subBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.subtract(vector1[i], vector2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void mulBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.multiply(vector1[i], vector2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void divBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.divide(vector1[i], vector2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fmaBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.fma(vector1[i], vector2[i], vector3[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public boolean isInfiniteBenchmark() {\n+        boolean res = true;\n+        for (int i = 0; i < vectorDim; i++) {\n+            res &= Float16.isInfinite(vector1[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean isFiniteBenchmark() {\n+        boolean res = true;\n+        for (int i = 0; i < vectorDim; i++) {\n+            res &= Float16.isFinite(vector1[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean isNaNBenchmark() {\n+        boolean res = true;\n+        for (int i = 0; i < vectorDim; i++) {\n+            res &= Float16.isNaN(vector1[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public void maxBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.max(vector1[i], vector2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void minBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.min(vector1[i], vector2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void sqrtBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.sqrt(vector1[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void negateBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.negate(vector1[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void absBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            vectorRes[i] = Float16.abs(vector1[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void getExponentBenchmark() {\n+        for (int i = 0; i < vectorDim; i++) {\n+            rexp[i] = Float16.getExponent(vector1[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public Float16 cosineSimilarityDoubleRoundingFP16() {\n+        Float16 macRes = Float16.valueOf(0.0f);\n+        Float16 vector1Square = Float16.valueOf(0.0f);\n+        Float16 vector2Square = Float16.valueOf(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            \/\/ Explicit add and multiply operation ensures double rounding.\n+            macRes = Float16.add(Float16.multiply(vector1[i], vector2[i]), macRes);\n+            vector1Square = Float16.fma(vector1[i], vector1[i], vector1Square);\n+            vector2Square = Float16.fma(vector2[i], vector2[i], vector2Square);\n+        }\n+        return Float16.divide(macRes, Float16.add(vector1Square, vector2Square));\n+    }\n+\n+    @Benchmark\n+    public Float16 cosineSimilaritySingleRoundingFP16() {\n+        Float16 macRes = Float16.valueOf(0.0f);\n+        Float16 vector1Square = Float16.valueOf(0.0f);\n+        Float16 vector2Square = Float16.valueOf(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            macRes = Float16.fma(vector1[i], vector2[i], macRes);\n+            vector1Square = Float16.fma(vector1[i], vector1[i], vector1Square);\n+            vector2Square = Float16.fma(vector2[i], vector2[i], vector2Square);\n+        }\n+        return Float16.divide(macRes, Float16.add(vector1Square, vector2Square));\n+    }\n+\n+    @Benchmark\n+    public Float16 cosineSimilarityDequantizedFP16() {\n+        float macRes = 0.0f;\n+        float vector1Square = 0.0f;\n+        float vector2Square = 0.0f;\n+        for (int i = 0; i < vectorDim; i++) {\n+            macRes = Math.fma(vector1[i].floatValue(), vector2[i].floatValue(), macRes);\n+            vector1Square = Math.fma(vector1[i].floatValue(), vector1[i].floatValue(), vector1Square);\n+            vector2Square = Math.fma(vector2[i].floatValue(), vector2[i].floatValue(), vector2Square);\n+        }\n+        return Float16.valueOf(macRes \/ (vector1Square + vector2Square));\n+    }\n+\n+    @Benchmark\n+    public Float16 euclideanDistanceFP16() {\n+        Float16 distRes = Float16.valueOf(0.0f);\n+        Float16 squareRes = Float16.valueOf(0.0f);\n+        for (int i = 0; i < vectorDim; i++) {\n+            squareRes = Float16.subtract(vector1[i], vector2[i]);\n+            distRes = Float16.fma(squareRes, squareRes, distRes);\n+        }\n+        return Float16.sqrt(distRes);\n+    }\n+\n+    @Benchmark\n+    public Float16 euclideanDistanceDequantizedFP16() {\n+        float distRes = 0.0f;\n+        float squareRes = 0.0f;\n+        for (int i = 0; i < vectorDim; i++) {\n+            squareRes = vector1[i].floatValue() - vector2[i].floatValue();\n+            distRes = distRes + squareRes * squareRes;\n+        }\n+        return Float16.sqrt(Float16.valueOf(distRes));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Float16OpsBenchmark.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"}]}