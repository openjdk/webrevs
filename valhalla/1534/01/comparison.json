{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,59 +151,0 @@\n-\/\/ ImageModuleData constructor maps out sub-tables for faster access.\n-ImageModuleData::ImageModuleData(const ImageFileReader* image_file) :\n-        _image_file(image_file),\n-        _endian(image_file->endian()) {\n-}\n-\n-\/\/ Release module data resource.\n-ImageModuleData::~ImageModuleData() {\n-}\n-\n-\n-\/\/ Return the module in which a package resides.    Returns NULL if not found.\n-const char* ImageModuleData::package_to_module(const char* package_name) {\n-    \/\/ replace all '\/' by '.'\n-    char* replaced = new char[(int) strlen(package_name) + 1];\n-    assert(replaced != NULL && \"allocation failed\");\n-    int i;\n-    for (i = 0; package_name[i] != '\\0'; i++) {\n-      replaced[i] = package_name[i] == '\/' ? '.' : package_name[i];\n-    }\n-    replaced[i] = '\\0';\n-\n-    \/\/ build path \/packages\/<package_name>\n-    const char* radical = \"\/packages\/\";\n-    char* path = new char[(int) strlen(radical) + (int) strlen(package_name) + 1];\n-    assert(path != NULL && \"allocation failed\");\n-    strcpy(path, radical);\n-    strcat(path, replaced);\n-    delete[] replaced;\n-\n-    \/\/ retrieve package location\n-    ImageLocation location;\n-    bool found = _image_file->find_location(path, location);\n-    delete[] path;\n-    if (!found) {\n-        return NULL;\n-    }\n-\n-    \/\/ retrieve offsets to module name\n-    int size = (int)location.get_attribute(ImageLocation::ATTRIBUTE_UNCOMPRESSED);\n-    u1* content = new u1[size];\n-    assert(content != NULL && \"allocation failed\");\n-    _image_file->get_resource(location, content);\n-    u1* ptr = content;\n-    \/\/ sequence of sizeof(8) isEmpty|offset. Use the first module that is not empty.\n-    u4 offset = 0;\n-    for (i = 0; i < size; i+=8) {\n-        u4 isEmpty = _endian->get(*((u4*)ptr));\n-        ptr += 4;\n-        if (!isEmpty) {\n-            offset = _endian->get(*((u4*)ptr));\n-            break;\n-        }\n-        ptr += 4;\n-    }\n-    delete[] content;\n-    return _image_file->get_strings().get(offset);\n-}\n-\n@@ -343,2 +284,1 @@\n-ImageFileReader::ImageFileReader(const char* name, bool big_endian) :\n-    _module_data(NULL) {\n+ImageFileReader::ImageFileReader(const char* name, bool big_endian) {\n@@ -365,4 +305,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-    }\n@@ -417,5 +353,1 @@\n-\n-    \/\/ Initialize the module data\n-    _module_data = new ImageModuleData(this);\n-    \/\/ Successful open (if memory allocation succeeded).\n-    return _module_data != NULL;\n+    return true;\n@@ -436,5 +368,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-        _module_data = NULL;\n-    }\n@@ -570,5 +497,0 @@\n-\n-\/\/ Return the ImageModuleData for this image\n-ImageModuleData * ImageFileReader::get_image_module_data() {\n-    return _module_data;\n-}\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":3,"deletions":81,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,14 +305,0 @@\n-\/\/\n-\/\/ Manage the image module meta data.\n-class ImageModuleData {\n-    const ImageFileReader* _image_file; \/\/ Source image file\n-    Endian* _endian;                    \/\/ Endian handler\n-\n-public:\n-    ImageModuleData(const ImageFileReader* image_file);\n-    ~ImageModuleData();\n-\n-    \/\/ Return the module in which a package resides.    Returns NULL if not found.\n-    const char* package_to_module(const char* package_name);\n-};\n-\n@@ -431,1 +417,0 @@\n-    ImageModuleData *_module_data;       \/\/ The ImageModuleData for this image\n@@ -580,4 +565,0 @@\n-\n-    \/\/ Return the ImageModuleData for this image\n-    ImageModuleData * get_image_module_data();\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,17 +89,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-extern \"C\" JNIEXPORT const char*\n-JIMAGE_PackageToModule(JImageFile* image, const char* package_name) {\n-    return ((ImageFileReader*) image)->get_image_module_data()->package_to_module(package_name);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,19 +96,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-\n-extern \"C\" JNIEXPORT const char *\n-JIMAGE_PackageToModule(JImageFile* jimage, const char* package_name);\n-\n-typedef const char* (*JImagePackageToModule_t)(JImageFile* jimage, const char* package_name);\n-\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Comparator;\n@@ -39,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -106,0 +108,11 @@\n+        \/\/ Sort references so the module for which the package is non-empty is\n+        \/\/ the first in the list. This will save time scanning for the module.\n+        private static final Comparator<PackageReference> NON_EMPTY_FIRST =\n+                Comparator.comparing(PackageReference::isEmpty)\n+                        .thenComparing(PackageReference::name);\n+\n+        \/\/ Bit masks for the flags held in \"\/packages\/xxx\" entries.\n+        \/\/ Should match same-named constants defined in:\n+        \/\/  src\/java.base\/share\/native\/libjimage\/imageFile.hpp\n+        private static final int PKG_FLAG_IS_EMPTY = 0x1;\n+\n@@ -120,0 +133,12 @@\n+            String name() {\n+                return name;\n+            }\n+\n+            boolean isEmpty() {\n+                return isEmpty;\n+            }\n+\n+            int flags() {\n+                return isEmpty() ? PKG_FLAG_IS_EMPTY : 0;\n+            }\n+\n@@ -122,1 +147,1 @@\n-                return name + \"[empty:\" + isEmpty + \"]\";\n+                return name() + \"[empty:\" + isEmpty() + \"]\";\n@@ -126,1 +151,1 @@\n-        private final Map<String, PackageReference> references = new TreeMap<>();\n+        private final Map<String, PackageReference> references = new HashMap<>();\n@@ -132,0 +157,8 @@\n+        int refCount() {\n+            return references.size();\n+        }\n+\n+        Stream<PackageReference> sortedRefs() {\n+            return references.values().stream().sorted(NON_EMPTY_FIRST);\n+        }\n+\n@@ -134,1 +167,1 @@\n-            if (ref == null || ref.isEmpty) {\n+            if (ref == null || ref.isEmpty()) {\n@@ -140,10 +173,5 @@\n-            boolean exists = false;\n-            for (PackageReference ref : references.values()) {\n-                if (!ref.isEmpty) {\n-                    if (exists) {\n-                        throw new RuntimeException(\"Multiple modules to contain package \"\n-                                + getName());\n-                    } else {\n-                        exists = true;\n-                    }\n-                }\n+            if (refCount() == 0) {\n+                throw new RuntimeException(\"Package nodes should not be empty \" + getName());\n+            }\n+            if (!sortedRefs().skip(1).allMatch(PackageReference::isEmpty)) {\n+                throw new RuntimeException(\"Multiple modules to contain package \" + getName());\n@@ -214,6 +242,1 @@\n-                                    Set<String> pkgs = moduleToPackage.get(module);\n-                                    if (pkgs == null) {\n-                                        pkgs = new TreeSet<>();\n-                                        moduleToPackage.put(module, pkgs);\n-                                    }\n-                                    pkgs.add(pkg);\n+                                    moduleToPackage.computeIfAbsent(module, k -> new TreeSet<>()).add(pkg);\n@@ -226,6 +249,1 @@\n-                                    Set<String> mods = packageToModule.get(pkg);\n-                                    if (mods == null) {\n-                                        mods = new TreeSet<>();\n-                                        packageToModule.put(pkg, mods);\n-                                    }\n-                                    mods.add(module);\n+                                    packageToModule.computeIfAbsent(pkg, k -> new TreeSet<>()).add(module);\n@@ -343,1 +361,1 @@\n-                int size = pkgNode.references.size() * 8;\n+                int size = pkgNode.refCount() * 8;\n@@ -383,1 +401,1 @@\n-                int size = pkgNode.references.size() * 8;\n+                int size = pkgNode.refCount() * 8;\n@@ -386,4 +404,4 @@\n-                for (PackageNode.PackageReference mod : pkgNode.references.values()) {\n-                    buff.putInt(mod.isEmpty ? 1 : 0);\n-                    buff.putInt(writer.addString(mod.name));\n-                }\n+                pkgNode.sortedRefs().forEach(ref -> {\n+                    buff.putInt(ref.flags());\n+                    buff.putInt(writer.addString(ref.name()));\n+                });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageResourcesTree.java","additions":49,"deletions":31,"binary":false,"changes":80,"status":"modified"}]}