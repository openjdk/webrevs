{"files":[{"patch":"@@ -151,61 +151,0 @@\n-\/\/ ImageModuleData constructor maps out sub-tables for faster access.\n-ImageModuleData::ImageModuleData(const ImageFileReader* image_file) :\n-        _image_file(image_file),\n-        _endian(image_file->endian()) {\n-}\n-\n-\/\/ Release module data resource.\n-ImageModuleData::~ImageModuleData() {\n-}\n-\n-\n-\/\/ Return the module in which a package resides.    Returns NULL if not found.\n-const char* ImageModuleData::package_to_module(const char* package_name) {\n-    \/\/ replace all '\/' by '.'\n-    char* replaced = new char[(int) strlen(package_name) + 1];\n-    assert(replaced != NULL && \"allocation failed\");\n-    int i;\n-    for (i = 0; package_name[i] != '\\0'; i++) {\n-      replaced[i] = package_name[i] == '\/' ? '.' : package_name[i];\n-    }\n-    replaced[i] = '\\0';\n-\n-    \/\/ build path \/packages\/<package_name>\n-    const char* radical = \"\/packages\/\";\n-    char* path = new char[(int) strlen(radical) + (int) strlen(package_name) + 1];\n-    assert(path != NULL && \"allocation failed\");\n-    strcpy(path, radical);\n-    strcat(path, replaced);\n-    delete[] replaced;\n-\n-    \/\/ retrieve package location\n-    ImageLocation location;\n-    bool found = _image_file->find_location(path, location);\n-    delete[] path;\n-    if (!found) {\n-        return NULL;\n-    }\n-\n-    \/\/ retrieve offsets to module name\n-    int size = (int)location.get_attribute(ImageLocation::ATTRIBUTE_UNCOMPRESSED);\n-    u1* content = new u1[size];\n-    assert(content != NULL && \"allocation failed\");\n-    _image_file->get_resource(location, content);\n-    u1* ptr = content;\n-    \/\/ Sequence of sizeof(8) flags|offset. Use the first module that is not empty.\n-    \/\/ Recent jimage files are built to put the non-empty module entry first in\n-    \/\/ the sequence, but there is no guarantee we are reading a new jimage file.\n-    u4 offset = 0;\n-    for (i = 0; i < size; i+=8) {\n-        u4 pkg_flags = _endian->get(*((u4*)ptr));\n-        ptr += 4;\n-        if ((pkg_flags & PKG_FLAG_IS_EMPTY) == 0) {\n-            offset = _endian->get(*((u4*)ptr));\n-            break;\n-        }\n-        ptr += 4;\n-    }\n-    delete[] content;\n-    return _image_file->get_strings().get(offset);\n-}\n-\n@@ -345,2 +284,1 @@\n-ImageFileReader::ImageFileReader(const char* name, bool big_endian) :\n-    _module_data(NULL) {\n+ImageFileReader::ImageFileReader(const char* name, bool big_endian) {\n@@ -367,4 +305,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-    }\n@@ -419,5 +353,1 @@\n-\n-    \/\/ Initialize the module data\n-    _module_data = new ImageModuleData(this);\n-    \/\/ Successful open (if memory allocation succeeded).\n-    return _module_data != NULL;\n+    return true;\n@@ -438,5 +368,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-        _module_data = NULL;\n-    }\n@@ -572,5 +497,0 @@\n-\n-\/\/ Return the ImageModuleData for this image\n-ImageModuleData * ImageFileReader::get_image_module_data() {\n-    return _module_data;\n-}\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -305,23 +305,0 @@\n-\/\/\n-\/\/ Manage the image module meta data.\n-class ImageModuleData {\n-    const ImageFileReader* _image_file; \/\/ Source image file\n-    Endian* _endian;                    \/\/ Endian handler\n-\n-public:\n-    ImageModuleData(const ImageFileReader* image_file);\n-    ~ImageModuleData();\n-\n-    \/\/ Bit masks for the flags held in \"\/packages\/xxx\" entries.\n-    \/\/ Should match same-named constants defined in:\n-    \/\/   src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageResourcesTree.java\n-    enum {\n-        \/\/ If set, the package is empty in the module of the offset entry.\n-        \/\/ For any package at most one module can have a non-empty reference.\n-        PKG_FLAG_IS_EMPTY = 0x1,\n-    };\n-\n-    \/\/ Return the module in which a package resides.    Returns NULL if not found.\n-    const char* package_to_module(const char* package_name);\n-};\n-\n@@ -440,1 +417,0 @@\n-    ImageModuleData *_module_data;       \/\/ The ImageModuleData for this image\n@@ -589,4 +565,0 @@\n-\n-    \/\/ Return the ImageModuleData for this image\n-    ImageModuleData * get_image_module_data();\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,17 +89,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-extern \"C\" JNIEXPORT const char*\n-JIMAGE_PackageToModule(JImageFile* image, const char* package_name) {\n-    return ((ImageFileReader*) image)->get_image_module_data()->package_to_module(package_name);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,19 +96,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-\n-extern \"C\" JNIEXPORT const char *\n-JIMAGE_PackageToModule(JImageFile* jimage, const char* package_name);\n-\n-typedef const char* (*JImagePackageToModule_t)(JImageFile* jimage, const char* package_name);\n-\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"}]}