{"files":[{"patch":"@@ -1337,2 +1337,5 @@\n-      assert(call->in(0)->is_Proj() && call->in(0)->in(0)->is_MemBar(), \"missing membar\");\n-      membar = call->in(0)->in(0)->as_MemBar();\n+      \/\/ If there is no explicit flat array accesses in the compilation unit, there would be no\n+      \/\/ membar here\n+      if (call->in(0)->is_Proj() && call->in(0)->in(0)->is_MemBar()) {\n+        membar = call->in(0)->in(0)->as_MemBar();\n+      }\n@@ -1395,1 +1398,3 @@\n-  membar->remove(igvn);\n+  if (membar != nullptr) {\n+    membar->remove(igvn);\n+  }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2152,14 +2152,1 @@\n-  if (memnodes.size() > 0) {\n-    _flat_accesses_share_alias = false;\n-\n-    \/\/ We are going to change the slice for the flat array\n-    \/\/ accesses so we need to clear the cache entries that refer to\n-    \/\/ them.\n-    for (uint i = 0; i < AliasCacheSize; i++) {\n-      AliasCacheEntry* ace = &_alias_cache[i];\n-      if (ace->_adr_type != nullptr &&\n-          ace->_adr_type->is_flat()) {\n-        ace->_adr_type = nullptr;\n-        ace->_index = (i != 0) ? 0 : AliasIdxTop; \/\/ Make sure the nullptr adr_type resolves to AliasIdxTop\n-      }\n-    }\n+  _flat_accesses_share_alias = false;\n@@ -2167,14 +2154,9 @@\n-    \/\/ Find what aliases we are going to add\n-    int start_alias = num_alias_types()-1;\n-    int stop_alias = 0;\n-\n-    for (uint i = 0; i < memnodes.size(); i++) {\n-      Node* m = memnodes.at(i);\n-      const TypePtr* adr_type = nullptr;\n-      adr_type = m->adr_type();\n-#ifdef ASSERT\n-      m->as_Mem()->set_adr_type(adr_type);\n-#endif\n-      int idx = get_alias_index(adr_type);\n-      start_alias = MIN2(start_alias, idx);\n-      stop_alias = MAX2(stop_alias, idx);\n+  \/\/ We are going to change the slice for the flat array\n+  \/\/ accesses so we need to clear the cache entries that refer to\n+  \/\/ them.\n+  for (uint i = 0; i < AliasCacheSize; i++) {\n+    AliasCacheEntry* ace = &_alias_cache[i];\n+    if (ace->_adr_type != nullptr &&\n+        ace->_adr_type->is_flat()) {\n+      ace->_adr_type = nullptr;\n+      ace->_index = (i != 0) ? 0 : AliasIdxTop; \/\/ Make sure the nullptr adr_type resolves to AliasIdxTop\n@@ -2182,0 +2164,1 @@\n+  }\n@@ -2183,1 +2166,7 @@\n-    assert(stop_alias >= start_alias, \"should have expanded aliases\");\n+#ifdef ASSERT\n+  for (uint i = 0; i < memnodes.size(); i++) {\n+    Node* m = memnodes.at(i);\n+    const TypePtr* adr_type = m->adr_type();\n+    m->as_Mem()->set_adr_type(adr_type);\n+  }\n+#endif \/\/ ASSERT\n@@ -2185,1 +2174,2 @@\n-    Node_Stack stack(0);\n+  int start_alias = num_alias_types(); \/\/ Start of new aliases\n+  Node_Stack stack(0);\n@@ -2187,1 +2177,1 @@\n-    VectorSet seen(Thread::current()->resource_area());\n+  VectorSet seen(Thread::current()->resource_area());\n@@ -2189,50 +2179,40 @@\n-    \/\/ Now let's fix the memory graph so each flat array access\n-    \/\/ is moved to the right slice. Start from the MergeMem nodes.\n-    uint last = unique();\n-    for (uint i = 0; i < mergememnodes.size(); i++) {\n-      MergeMemNode* current = mergememnodes.at(i)->as_MergeMem();\n-      if (current->outcnt() == 0) {\n-        \/\/ This node is killed by a previous iteration\n-        continue;\n-      }\n-\n-      Node* n = current->memory_at(index);\n-      MergeMemNode* mm = nullptr;\n-      do {\n-        \/\/ Follow memory edges through memory accesses, phis and\n-        \/\/ narrow membars and push nodes on the stack. Once we hit\n-        \/\/ bottom memory, we pop element off the stack one at a\n-        \/\/ time, in reverse order, and move them to the right slice\n-        \/\/ by changing their memory edges.\n-        if ((n->is_Phi() && n->adr_type() != TypePtr::BOTTOM) || n->is_Mem() ||\n-            (n->adr_type() == TypeAryPtr::INLINES && !n->is_NarrowMemProj())) {\n-          assert(!seen.test_set(n->_idx), \"\");\n-          \/\/ Uses (a load for instance) will need to be moved to the\n-          \/\/ right slice as well and will get a new memory state\n-          \/\/ that we don't know yet. The use could also be the\n-          \/\/ backedge of a loop. We put a place holder node between\n-          \/\/ the memory node and its uses. We replace that place\n-          \/\/ holder with the correct memory state once we know it,\n-          \/\/ i.e. when nodes are popped off the stack. Using the\n-          \/\/ place holder make the logic work in the presence of\n-          \/\/ loops.\n-          if (n->outcnt() > 1) {\n-            Node* place_holder = nullptr;\n-            assert(!n->has_out_with(Op_Node), \"\");\n-            for (DUIterator k = n->outs(); n->has_out(k); k++) {\n-              Node* u = n->out(k);\n-              if (u != current && u->_idx < last) {\n-                bool success = false;\n-                for (uint l = 0; l < u->req(); l++) {\n-                  if (!stack.is_empty() && u == stack.node() && l == stack.index()) {\n-                    continue;\n-                  }\n-                  Node* in = u->in(l);\n-                  if (in == n) {\n-                    if (place_holder == nullptr) {\n-                      place_holder = new Node(1);\n-                      place_holder->init_req(0, n);\n-                    }\n-                    igvn.replace_input_of(u, l, place_holder);\n-                    success = true;\n-                  }\n+  \/\/ Now let's fix the memory graph so each flat array access\n+  \/\/ is moved to the right slice. Start from the MergeMem nodes.\n+  uint last = unique();\n+  for (uint i = 0; i < mergememnodes.size(); i++) {\n+    MergeMemNode* current = mergememnodes.at(i)->as_MergeMem();\n+    if (current->outcnt() == 0) {\n+      \/\/ This node is killed by a previous iteration\n+      continue;\n+    }\n+\n+    Node* n = current->memory_at(index);\n+    MergeMemNode* mm = nullptr;\n+    do {\n+      \/\/ Follow memory edges through memory accesses, phis and\n+      \/\/ narrow membars and push nodes on the stack. Once we hit\n+      \/\/ bottom memory, we pop element off the stack one at a\n+      \/\/ time, in reverse order, and move them to the right slice\n+      \/\/ by changing their memory edges.\n+      if ((n->is_Phi() && n->adr_type() != TypePtr::BOTTOM) || n->is_Mem() ||\n+          (n->adr_type() == TypeAryPtr::INLINES && !n->is_NarrowMemProj())) {\n+        assert(!seen.test_set(n->_idx), \"\");\n+        \/\/ Uses (a load for instance) will need to be moved to the\n+        \/\/ right slice as well and will get a new memory state\n+        \/\/ that we don't know yet. The use could also be the\n+        \/\/ backedge of a loop. We put a place holder node between\n+        \/\/ the memory node and its uses. We replace that place\n+        \/\/ holder with the correct memory state once we know it,\n+        \/\/ i.e. when nodes are popped off the stack. Using the\n+        \/\/ place holder make the logic work in the presence of\n+        \/\/ loops.\n+        if (n->outcnt() > 1) {\n+          Node* place_holder = nullptr;\n+          assert(!n->has_out_with(Op_Node), \"\");\n+          for (DUIterator k = n->outs(); n->has_out(k); k++) {\n+            Node* u = n->out(k);\n+            if (u != current && u->_idx < last) {\n+              bool success = false;\n+              for (uint l = 0; l < u->req(); l++) {\n+                if (!stack.is_empty() && u == stack.node() && l == stack.index()) {\n+                  continue;\n@@ -2240,2 +2220,8 @@\n-                if (success) {\n-                  --k;\n+                Node* in = u->in(l);\n+                if (in == n) {\n+                  if (place_holder == nullptr) {\n+                    place_holder = new Node(1);\n+                    place_holder->init_req(0, n);\n+                  }\n+                  igvn.replace_input_of(u, l, place_holder);\n+                  success = true;\n@@ -2244,0 +2230,3 @@\n+              if (success) {\n+                --k;\n+              }\n@@ -2246,11 +2235,7 @@\n-          if (n->is_Phi()) {\n-            stack.push(n, 1);\n-            n = n->in(1);\n-          } else if (n->is_Mem()) {\n-            stack.push(n, n->req());\n-            n = n->in(MemNode::Memory);\n-          } else {\n-            assert(n->is_Proj() && n->in(0)->Opcode() == Op_MemBarCPUOrder, \"\");\n-            stack.push(n, n->req());\n-            n = n->in(0)->in(TypeFunc::Memory);\n-          }\n+        }\n+        if (n->is_Phi()) {\n+          stack.push(n, 1);\n+          n = n->in(1);\n+        } else if (n->is_Mem()) {\n+          stack.push(n, n->req());\n+          n = n->in(MemNode::Memory);\n@@ -2258,53 +2243,47 @@\n-          assert(n->adr_type() == TypePtr::BOTTOM || (n->Opcode() == Op_Node && n->_idx >= last) || n->is_NarrowMemProj(), \"\");\n-          \/\/ Build a new MergeMem node to carry the new memory state\n-          \/\/ as we build it. IGVN should fold extraneous MergeMem\n-          \/\/ nodes.\n-          if (n->is_NarrowMemProj()) {\n-            \/\/ We need 1 NarrowMemProj for each slice of this array\n-            InitializeNode* init = n->in(0)->as_Initialize();\n-            AllocateNode* alloc = init->allocation();\n-            Node* klass_node = alloc->in(AllocateNode::KlassNode);\n-            const TypeAryKlassPtr* klass_type = klass_node->bottom_type()->isa_aryklassptr();\n-            assert(klass_type != nullptr, \"must be an array\");\n-            assert(klass_type->klass_is_exact(), \"must be an exact klass\");\n-            ciArrayKlass* klass = klass_type->exact_klass()->as_array_klass();\n-            assert(klass->is_flat_array_klass(), \"must be a flat array\");\n-            ciInlineKlass* elem_klass = klass->element_klass()->as_inline_klass();\n-            const TypeAryPtr* oop_type = klass_type->as_instance_type()->is_aryptr();\n-            assert(oop_type->klass_is_exact(), \"must be an exact klass\");\n-\n-            Node* base = alloc->in(TypeFunc::Memory);\n-            assert(base->bottom_type() == Type::MEMORY, \"the memory input of AllocateNode must be a memory\");\n-            assert(base->adr_type() == TypePtr::BOTTOM, \"the memory input of AllocateNode must be a bottom memory\");\n-            \/\/ Must create a MergeMem with base as the base memory, do not clone if base is a\n-            \/\/ MergeMem because it may not be processed yet\n-            mm = MergeMemNode::make(nullptr);\n-            mm->set_base_memory(base);\n-            for (int j = 0; j < elem_klass->nof_nonstatic_fields(); j++) {\n-              int field_offset = elem_klass->nonstatic_field_at(j)->offset_in_bytes() - elem_klass->payload_offset();\n-              const TypeAryPtr* field_ptr = oop_type->with_offset(Type::OffsetBot)->with_field_offset(field_offset);\n-              int field_alias_idx = get_alias_index(field_ptr);\n-              assert(field_ptr == get_adr_type(field_alias_idx), \"must match\");\n-              Node* new_proj = new NarrowMemProjNode(init, field_ptr);\n-              igvn.register_new_node_with_optimizer(new_proj);\n-              mm->set_memory_at(field_alias_idx, new_proj);\n-            }\n-            if (!klass->is_elem_null_free()) {\n-              int nm_offset = elem_klass->null_marker_offset_in_payload();\n-              const TypeAryPtr* nm_ptr = oop_type->with_offset(Type::OffsetBot)->with_field_offset(nm_offset);\n-              int nm_alias_idx = get_alias_index(nm_ptr);\n-              assert(nm_ptr == get_adr_type(nm_alias_idx), \"must match\");\n-              Node* new_proj = new NarrowMemProjNode(init, nm_ptr);\n-              igvn.register_new_node_with_optimizer(new_proj);\n-              mm->set_memory_at(nm_alias_idx, new_proj);\n-            }\n-\n-            \/\/ Replace all uses of the old NarrowMemProj with the correct state\n-            MergeMemNode* new_n = MergeMemNode::make(mm);\n-            igvn.register_new_node_with_optimizer(new_n);\n-            igvn.replace_node(n, new_n);\n-          } else {\n-            \/\/ Must create a MergeMem with n as the base memory, do not clone if n is a MergeMem\n-            \/\/ because it may not be processed yet\n-            mm = MergeMemNode::make(nullptr);\n-            mm->set_base_memory(n);\n+          assert(n->is_Proj() && n->in(0)->Opcode() == Op_MemBarCPUOrder, \"\");\n+          stack.push(n, n->req());\n+          n = n->in(0)->in(TypeFunc::Memory);\n+        }\n+      } else {\n+        assert(n->adr_type() == TypePtr::BOTTOM || (n->Opcode() == Op_Node && n->_idx >= last) || n->is_NarrowMemProj(), \"\");\n+        \/\/ Build a new MergeMem node to carry the new memory state\n+        \/\/ as we build it. IGVN should fold extraneous MergeMem\n+        \/\/ nodes.\n+        if (n->is_NarrowMemProj()) {\n+          \/\/ We need 1 NarrowMemProj for each slice of this array\n+          InitializeNode* init = n->in(0)->as_Initialize();\n+          AllocateNode* alloc = init->allocation();\n+          Node* klass_node = alloc->in(AllocateNode::KlassNode);\n+          const TypeAryKlassPtr* klass_type = klass_node->bottom_type()->isa_aryklassptr();\n+          assert(klass_type != nullptr, \"must be an array\");\n+          assert(klass_type->klass_is_exact(), \"must be an exact klass\");\n+          ciArrayKlass* klass = klass_type->exact_klass()->as_array_klass();\n+          assert(klass->is_flat_array_klass(), \"must be a flat array\");\n+          ciInlineKlass* elem_klass = klass->element_klass()->as_inline_klass();\n+          const TypeAryPtr* oop_type = klass_type->as_instance_type()->is_aryptr();\n+          assert(oop_type->klass_is_exact(), \"must be an exact klass\");\n+\n+          Node* base = alloc->in(TypeFunc::Memory);\n+          assert(base->bottom_type() == Type::MEMORY, \"the memory input of AllocateNode must be a memory\");\n+          assert(base->adr_type() == TypePtr::BOTTOM, \"the memory input of AllocateNode must be a bottom memory\");\n+          \/\/ Must create a MergeMem with base as the base memory, do not clone if base is a\n+          \/\/ MergeMem because it may not be processed yet\n+          mm = MergeMemNode::make(nullptr);\n+          mm->set_base_memory(base);\n+          for (int j = 0; j < elem_klass->nof_nonstatic_fields(); j++) {\n+            int field_offset = elem_klass->nonstatic_field_at(j)->offset_in_bytes() - elem_klass->payload_offset();\n+            const TypeAryPtr* field_ptr = oop_type->with_offset(Type::OffsetBot)->with_field_offset(field_offset);\n+            int field_alias_idx = get_alias_index(field_ptr);\n+            assert(field_ptr == get_adr_type(field_alias_idx), \"must match\");\n+            Node* new_proj = new NarrowMemProjNode(init, field_ptr);\n+            igvn.register_new_node_with_optimizer(new_proj);\n+            mm->set_memory_at(field_alias_idx, new_proj);\n+          }\n+          if (!klass->is_elem_null_free()) {\n+            int nm_offset = elem_klass->null_marker_offset_in_payload();\n+            const TypeAryPtr* nm_ptr = oop_type->with_offset(Type::OffsetBot)->with_field_offset(nm_offset);\n+            int nm_alias_idx = get_alias_index(nm_ptr);\n+            assert(nm_ptr == get_adr_type(nm_alias_idx), \"must match\");\n+            Node* new_proj = new NarrowMemProjNode(init, nm_ptr);\n+            igvn.register_new_node_with_optimizer(new_proj);\n+            mm->set_memory_at(nm_alias_idx, new_proj);\n@@ -2313,29 +2292,33 @@\n-          igvn.register_new_node_with_optimizer(mm);\n-          while (stack.size() > 0) {\n-            Node* m = stack.node();\n-            uint idx = stack.index();\n-            if (m->is_Mem()) {\n-              \/\/ Move memory node to its new slice\n-              const TypePtr* adr_type = m->adr_type();\n-              int alias = get_alias_index(adr_type);\n-              Node* prev = mm->memory_at(alias);\n-              igvn.replace_input_of(m, MemNode::Memory, prev);\n-              mm->set_memory_at(alias, m);\n-            } else if (m->is_Phi()) {\n-              \/\/ We need as many new phis as there are new aliases\n-              Node* new_phi_in = MergeMemNode::make(mm);\n-              igvn.register_new_node_with_optimizer(new_phi_in);\n-              igvn.replace_input_of(m, idx, new_phi_in);\n-              if (idx == m->req()-1) {\n-                Node* r = m->in(0);\n-                for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n-                  const TypePtr* adr_type = get_adr_type(j);\n-                  if (!adr_type->isa_aryptr() || !adr_type->is_flat() || j == (uint)index) {\n-                    continue;\n-                  }\n-                  Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));\n-                  igvn.register_new_node_with_optimizer(phi);\n-                  for (uint k = 1; k < m->req(); k++) {\n-                    phi->init_req(k, m->in(k)->as_MergeMem()->memory_at(j));\n-                  }\n-                  mm->set_memory_at(j, phi);\n+          \/\/ Replace all uses of the old NarrowMemProj with the correct state\n+          MergeMemNode* new_n = MergeMemNode::make(mm);\n+          igvn.register_new_node_with_optimizer(new_n);\n+          igvn.replace_node(n, new_n);\n+        } else {\n+          \/\/ Must create a MergeMem with n as the base memory, do not clone if n is a MergeMem\n+          \/\/ because it may not be processed yet\n+          mm = MergeMemNode::make(nullptr);\n+          mm->set_base_memory(n);\n+        }\n+\n+        igvn.register_new_node_with_optimizer(mm);\n+        while (stack.size() > 0) {\n+          Node* m = stack.node();\n+          uint idx = stack.index();\n+          if (m->is_Mem()) {\n+            \/\/ Move memory node to its new slice\n+            const TypePtr* adr_type = m->adr_type();\n+            int alias = get_alias_index(adr_type);\n+            Node* prev = mm->memory_at(alias);\n+            igvn.replace_input_of(m, MemNode::Memory, prev);\n+            mm->set_memory_at(alias, m);\n+          } else if (m->is_Phi()) {\n+            \/\/ We need as many new phis as there are new aliases\n+            Node* new_phi_in = MergeMemNode::make(mm);\n+            igvn.register_new_node_with_optimizer(new_phi_in);\n+            igvn.replace_input_of(m, idx, new_phi_in);\n+            if (idx == m->req()-1) {\n+              Node* r = m->in(0);\n+              for (int j = start_alias; j < num_alias_types(); j++) {\n+                const TypePtr* adr_type = get_adr_type(j);\n+                if (!adr_type->isa_aryptr() || !adr_type->is_flat()) {\n+                  continue;\n@@ -2343,2 +2326,2 @@\n-                Node* base_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);\n-                igvn.register_new_node_with_optimizer(base_phi);\n+                Node* phi = new PhiNode(r, Type::MEMORY, get_adr_type(j));\n+                igvn.register_new_node_with_optimizer(phi);\n@@ -2346,1 +2329,1 @@\n-                  base_phi->init_req(k, m->in(k)->as_MergeMem()->base_memory());\n+                  phi->init_req(k, m->in(k)->as_MergeMem()->memory_at(j));\n@@ -2348,1 +2331,1 @@\n-                mm->set_base_memory(base_phi);\n+                mm->set_memory_at(j, phi);\n@@ -2350,26 +2333,4 @@\n-            } else {\n-              \/\/ This is a MemBarCPUOrder node from\n-              \/\/ Parse::array_load()\/Parse::array_store(), in the\n-              \/\/ branch that handles flat arrays hidden under\n-              \/\/ an Object[] array. We also need one new membar per\n-              \/\/ new alias to keep the unknown access that the\n-              \/\/ membars protect properly ordered with accesses to\n-              \/\/ known flat array.\n-              assert(m->is_Proj(), \"projection expected\");\n-              Node* ctrl = m->in(0)->in(TypeFunc::Control);\n-              igvn.replace_input_of(m->in(0), TypeFunc::Control, top());\n-              for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n-                const TypePtr* adr_type = get_adr_type(j);\n-                if (!adr_type->isa_aryptr() || !adr_type->is_flat() || j == (uint)index) {\n-                  continue;\n-                }\n-                MemBarNode* mb = new MemBarCPUOrderNode(this, j, nullptr);\n-                igvn.register_new_node_with_optimizer(mb);\n-                Node* mem = mm->memory_at(j);\n-                mb->init_req(TypeFunc::Control, ctrl);\n-                mb->init_req(TypeFunc::Memory, mem);\n-                ctrl = new ProjNode(mb, TypeFunc::Control);\n-                igvn.register_new_node_with_optimizer(ctrl);\n-                mem = new ProjNode(mb, TypeFunc::Memory);\n-                igvn.register_new_node_with_optimizer(mem);\n-                mm->set_memory_at(j, mem);\n+              Node* base_phi = new PhiNode(r, Type::MEMORY, TypePtr::BOTTOM);\n+              igvn.register_new_node_with_optimizer(base_phi);\n+              for (uint k = 1; k < m->req(); k++) {\n+                base_phi->init_req(k, m->in(k)->as_MergeMem()->base_memory());\n@@ -2377,7 +2338,1 @@\n-              igvn.replace_node(m->in(0)->as_Multi()->proj_out(TypeFunc::Control), ctrl);\n-            }\n-            if (idx < m->req()-1) {\n-              idx += 1;\n-              stack.set_index(idx);\n-              n = m->in(idx);\n-              break;\n+              mm->set_base_memory(base_phi);\n@@ -2385,10 +2340,15 @@\n-            \/\/ Take care of place holder nodes\n-            if (m->has_out_with(Op_Node)) {\n-              Node* place_holder = m->find_out_with(Op_Node);\n-              if (place_holder != nullptr) {\n-                Node* mm_clone = mm->clone();\n-                igvn.register_new_node_with_optimizer(mm_clone);\n-                Node* hook = new Node(1);\n-                hook->init_req(0, mm);\n-                igvn.replace_node(place_holder, mm_clone);\n-                hook->destruct(&igvn);\n+          } else {\n+            \/\/ This is a MemBarCPUOrder node from\n+            \/\/ Parse::array_load()\/Parse::array_store(), in the\n+            \/\/ branch that handles flat arrays hidden under\n+            \/\/ an Object[] array. We also need one new membar per\n+            \/\/ new alias to keep the unknown access that the\n+            \/\/ membars protect properly ordered with accesses to\n+            \/\/ known flat array.\n+            assert(m->is_Proj(), \"projection expected\");\n+            Node* ctrl = m->in(0)->in(TypeFunc::Control);\n+            igvn.replace_input_of(m->in(0), TypeFunc::Control, top());\n+            for (int j = start_alias; j < num_alias_types(); j++) {\n+              const TypePtr* adr_type = get_adr_type(j);\n+              if (!adr_type->isa_aryptr() || !adr_type->is_flat()) {\n+                continue;\n@@ -2396,1 +2356,10 @@\n-              assert(!m->has_out_with(Op_Node), \"place holder should be gone now\");\n+              MemBarNode* mb = new MemBarCPUOrderNode(this, j, nullptr);\n+              igvn.register_new_node_with_optimizer(mb);\n+              Node* mem = mm->memory_at(j);\n+              mb->init_req(TypeFunc::Control, ctrl);\n+              mb->init_req(TypeFunc::Memory, mem);\n+              ctrl = new ProjNode(mb, TypeFunc::Control);\n+              igvn.register_new_node_with_optimizer(ctrl);\n+              mem = new ProjNode(mb, TypeFunc::Memory);\n+              igvn.register_new_node_with_optimizer(mem);\n+              mm->set_memory_at(j, mem);\n@@ -2398,1 +2367,1 @@\n-            stack.pop();\n+            igvn.replace_node(m->in(0)->as_Multi()->proj_out(TypeFunc::Control), ctrl);\n@@ -2400,0 +2369,20 @@\n+          if (idx < m->req()-1) {\n+            idx += 1;\n+            stack.set_index(idx);\n+            n = m->in(idx);\n+            break;\n+          }\n+          \/\/ Take care of place holder nodes\n+          if (m->has_out_with(Op_Node)) {\n+            Node* place_holder = m->find_out_with(Op_Node);\n+            if (place_holder != nullptr) {\n+              Node* mm_clone = mm->clone();\n+              igvn.register_new_node_with_optimizer(mm_clone);\n+              Node* hook = new Node(1);\n+              hook->init_req(0, mm);\n+              igvn.replace_node(place_holder, mm_clone);\n+              hook->destruct(&igvn);\n+            }\n+            assert(!m->has_out_with(Op_Node), \"place holder should be gone now\");\n+          }\n+          stack.pop();\n@@ -2401,9 +2390,0 @@\n-      } while(stack.size() > 0);\n-      \/\/ Fix the memory state at the MergeMem we started from\n-      igvn.rehash_node_delayed(current);\n-      for (uint j = (uint)start_alias; j <= (uint)stop_alias; j++) {\n-        const TypePtr* adr_type = get_adr_type(j);\n-        if (!adr_type->isa_aryptr() || !adr_type->is_flat()) {\n-          continue;\n-        }\n-        current->set_memory_at(j, mm);\n@@ -2411,1 +2391,9 @@\n-      current->set_memory_at(index, current->base_memory());\n+    } while(stack.size() > 0);\n+    \/\/ Fix the memory state at the MergeMem we started from\n+    igvn.rehash_node_delayed(current);\n+    for (int j = start_alias; j < num_alias_types(); j++) {\n+      const TypePtr* adr_type = get_adr_type(j);\n+      if (!adr_type->isa_aryptr() || !adr_type->is_flat()) {\n+        continue;\n+      }\n+      current->set_memory_at(j, mm);\n@@ -2413,1 +2401,1 @@\n-    igvn.optimize();\n+    current->set_memory_at(index, current->base_memory());\n@@ -2415,1 +2403,2 @@\n-  print_method(PHASE_SPLIT_INLINES_ARRAY, 2);\n+  igvn.optimize();\n+\n@@ -2417,11 +2406,9 @@\n-  if (!_flat_accesses_share_alias) {\n-    wq.clear();\n-    wq.push(root());\n-    for (uint i = 0; i < wq.size(); i++) {\n-      Node* n = wq.at(i);\n-      assert(n->adr_type() != TypeAryPtr::INLINES, \"should have been removed from the graph\");\n-      for (uint j = 0; j < n->req(); j++) {\n-        Node* m = n->in(j);\n-        if (m != nullptr) {\n-          wq.push(m);\n-        }\n+  wq.clear();\n+  wq.push(root());\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    assert(n->adr_type() != TypeAryPtr::INLINES, \"should have been removed from the graph\");\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* m = n->in(j);\n+      if (m != nullptr) {\n+        wq.push(m);\n@@ -2432,0 +2419,2 @@\n+\n+  print_method(PHASE_SPLIT_INLINES_ARRAY, 2);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":237,"deletions":248,"binary":false,"changes":485,"status":"modified"},{"patch":"@@ -4346,1 +4346,0 @@\n-#if 0  \/\/ TODO: Fix 8372259\n@@ -4353,3 +4352,0 @@\n-#else\n-        }\n-#endif\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4206,1 +4206,5 @@\n-      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(elemidx))));\n+      const TypePtr* alias_adr_type = C->get_adr_type(elemidx);\n+      if (alias_adr_type->is_flat()) {\n+        C->set_flat_accesses();\n+      }\n+      hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, alias_adr_type)));\n@@ -4208,1 +4212,0 @@\n-      set_memory(minit_out, C->get_alias_index(oop_type)); \/\/ mark word\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}