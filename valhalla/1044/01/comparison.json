{"files":[{"patch":"@@ -671,0 +671,12 @@\n+    \/**\n+     * Returns a {@code Class} object representing the null restricted type\n+     * of this class or interface.\n+     *\n+     * @return the {@code Class} representing the null restricted type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    public Class<?> asNullRestrictedType() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * A restricted interface optionally implemented by value objects.\n+ *\n+ * A value object is an instance of a value class, lacking identity.\n+ *\n+ * Every object is either an *identity object* or a *value object*. Identity\n+ * objects have a unique identity determined for them at instance creation time and\n+ * preserved throughout their life.\n+ *\n+ * value objects do *not* have an identity. Instead, they simply aggregate a\n+ * set of immutable field values. The lack of identity enables certain performance\n+ * optimizations by Java Virtual Machine implementations.\n+ * The following operations have special behavior when applied to value\n+ * objects:\n+ *\n+ * - The `==` operator, and the default implementation of the `Object.equals`\n+ * method, compare the values of the operands' fields. Value objects\n+ * created at different points in a program may be `==`.\n+ *\n+ * - The `System.identityHashCode` method, and the default implementation of the\n+ * `Object.hashCode` method, generate a hash code from the hash codes of a\n+ * value object's fields.\n+ *\n+ * - The `synchronized` modifier and `synchronized` statement always fail when\n+ * applied to a value object.\n+ *\n+ * A value class with an `implicit` constructor may also declare that it tolerates\n+ * implicit creation of instances via non-atomic field and array updates.\n+ * This means that, in a race condition, new class instances may be accidentally\n+ * created by intermixing field values from other instances, without any code\n+ * execution or other additional cooperation from the value class. A value class\n+ * opts in to allowing this behavior by implementing this interface.\n+ *\n+ * @since Valhalla\n+ *\/\n+\n+public interface LooselyConsistentValue {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LooselyConsistentValue.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -87,0 +87,6 @@\n+    \/**\n+     * The modifier {@code implicit}\n+     * @since 21\n+     *\/\n+    IMPLICIT,\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    public static final int ACC_NON_ATOMIC = 0x0002;\n@@ -418,0 +419,5 @@\n+    \/**\n+     * Flag to indicate that a value class constructor is implicit\n+     *\/\n+    public static final int IMPLICIT    = 1<<59; \/\/ MethodSymbols\n+\n@@ -441,0 +447,1 @@\n+        ImplicitConstructorFlags          = PUBLIC | IMPLICIT,\n@@ -454,1 +461,1 @@\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS | IMPLICIT,\n@@ -481,0 +488,1 @@\n+            if (0 != (flags & IMPLICIT))        modifiers.add(Modifier.IMPLICIT);\n@@ -528,0 +536,1 @@\n+        IMPLICIT(Flags.IMPLICIT),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -239,0 +239,5 @@\n+        \/**\n+         * Warn about operations on null-restricted and nullable types.\n+         *\/\n+        NULL(\"null\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -358,0 +358,8 @@\n+        \/*if (isValueClassConst()) {\n+            \/\/ previously we had vnew methods which had a return type, not `void`, and we were attaching metadata to it\n+            \/\/ like nullness for example. Type `void` doesn't accept metadata so if we need to state that the result of\n+            \/\/ invoking a value class constructor is never null, we will need another way.\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }*\/\n@@ -469,0 +477,6 @@\n+    \/** Is this symbol an implicit constructor?\n+     *\/\n+    public boolean isImplicitConstructor() {\n+        return isConstructor() && ((flags() & IMPLICIT) != 0);\n+    }\n+\n@@ -1314,0 +1328,2 @@\n+        private boolean hasImplicitConstructor = false;\n+\n@@ -1657,0 +1673,29 @@\n+\n+        public boolean hasImplicitConstructor() {\n+            if (hasImplicitConstructor) {\n+                return true;\n+            } else {\n+                if (getImplicitConstructor() != null) {\n+                    hasImplicitConstructor = true;\n+                }\n+                return hasImplicitConstructor;\n+            }\n+        }\n+\n+        public void implicitConstructorFound() {\n+            hasImplicitConstructor = true;\n+        }\n+\n+        private MethodSymbol getImplicitConstructor() {\n+            for (Symbol s : members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case MTH:\n+                        if (s.isConstructor()) {\n+                            if (s.isImplicitConstructor()) {\n+                                return (MethodSymbol) s;\n+                            }\n+                        }\n+                }\n+            }\n+            return null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -250,0 +250,4 @@\n+    \/\/ for value objects\n+    public final Type looselyConsistentValueType;\n+    public final Type reflectArrayType;\n+\n@@ -648,0 +652,4 @@\n+        \/\/ for value objects\n+        looselyConsistentValueType = enterClass(\"java.lang.LooselyConsistentValue\");\n+        reflectArrayType = enterClass(\"java.lang.reflect.Array\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -242,0 +243,4 @@\n+    public boolean hasImplicitConstructor() {\n+        return false;\n+    }\n+\n@@ -538,0 +543,7 @@\n+        if (isNullable()) {\n+            sb.append(\"?\");\n+        } else if (isNonNullable()) {\n+            sb.append(\"!\");\n+        } else if (isParametric()) {\n+            sb.append(\"*\");\n+        }\n@@ -742,0 +754,31 @@\n+    \/\/ support for null-marked types\n+\n+    public Type asNullMarked(NullMarker nullMarker) {\n+        if (nullMarker == NullMarker.UNSPECIFIED) {\n+            return this;\n+        } else {\n+            return addMetadata(new TypeMetadata.NullMarker(nullMarker));\n+        }\n+    }\n+\n+    public boolean isNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NULLABLE;\n+    }\n+\n+    public boolean isNonNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isParametric() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.PARAMETRIC;\n+    }\n+\n+    public boolean isNullUnspecified() {\n+        return getMetadata(TypeMetadata.NullMarker.class) == null;\n+    }\n+\n+    \/\/ end of support for null-marked types\n+\n@@ -1103,0 +1146,8 @@\n+            if (isNullable()) {\n+                buf.append(\"?\");\n+            } else if (isNonNullable()) {\n+                buf.append(\"!\");\n+            } else if (isParametric()) {\n+                buf.append(\"*\");\n+            }\n+\n@@ -1183,0 +1234,5 @@\n+        @Override\n+        public boolean hasImplicitConstructor() {\n+            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).hasImplicitConstructor();\n+        }\n+\n@@ -1413,0 +1469,7 @@\n+                if (t.isNullable()) {\n+                    sb.append(\"?\");\n+                } else if (t.isNonNullable()) {\n+                    sb.append(\"!\");\n+                } else if (t.isParametric()) {\n+                    sb.append(\"*\");\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression;\n+import com.sun.tools.javac.util.Assert;\n@@ -79,0 +81,5 @@\n+\n+    record NullMarker(JCNullableTypeExpression.NullMarker nullMarker) implements TypeMetadata {\n+        @Override\n+        public String toString() { return \"NULL_MARKER [ \" + nullMarker.typeSuffix() + \" ]\"; }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeMetadata.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -128,0 +130,2 @@\n+        Options options = Options.instance(context);\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -1085,1 +1089,4 @@\n-        if (t.equalsIgnoreMetadata(s))\n+        if (t.equalsIgnoreMetadata(s)) {\n+            if (allowNullRestrictedTypes) {\n+                new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+            }\n@@ -1087,0 +1094,1 @@\n+        }\n@@ -1111,2 +1119,2 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        private IsSubtype isSubtype = new IsSubtype();\n+        class IsSubtype extends TypeRelation {\n@@ -1127,1 +1135,4 @@\n-                 case BOT:\n+                 case BOT: {\n+                     if (s.isNonNullable()) {\n+                         return false;\n+                     }\n@@ -1129,2 +1140,3 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1195,1 +1207,1 @@\n-                return sup.tsym == s.tsym\n+                boolean result = sup.tsym == s.tsym\n@@ -1200,0 +1212,4 @@\n+                if (result && allowNullRestrictedTypes) {\n+                    new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+                }\n+                return result;\n@@ -1240,1 +1256,47 @@\n-        };\n+        }\n+\n+        public class NullabilityComparator extends TypeRelation {\n+            BiFunction<Type, Type, Boolean> differentNullability;\n+\n+            NullabilityComparator(BiFunction<Type, Type, Boolean> differentNullability) {\n+                this.differentNullability = differentNullability;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return s != null && (!s.isParameterized() || compareTypeArgsRecursive(t, s))\n+                            && visit(t.getEnclosingType(), s.getEnclosingType());\n+                }\n+            }\n+            \/\/ where\n+            boolean compareTypeArgsRecursive(Type t, Type s) {\n+                return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    if (visit(ts.head, ss.head)) {\n+                        return true;\n+                    }\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return false;\n+            }\n+        }\n@@ -1427,3 +1489,7 @@\n-                return t.tsym == s.tsym\n-                    && visit(t.getEnclosingType(), s.getEnclosingType())\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                boolean equal = t.tsym == s.tsym\n+                        && visit(t.getEnclosingType(), s.getEnclosingType())\n+                        && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                if (equal && allowNullRestrictedTypes) {\n+                    new NullabilityComparator((t1, t2) -> !hasSameNullability(t1, t2)).visit(s, t);\n+                }\n+                return equal;\n@@ -1746,1 +1812,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT) && (!t.hasImplicitConstructor() || !t.isNonNullable()))\n@@ -2156,0 +2222,10 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n+    }\n+    \/\/ <\/editor-fold>\n+\n@@ -2821,1 +2897,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -5292,0 +5377,28 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null) {\n+            return t.isNullUnspecified();\n+        }\n+        if (t.isNullUnspecified()) {\n+            return s.isNullUnspecified();\n+        }\n+        if (t.isNonNullable()) {\n+            return s.isNonNullable();\n+        }\n+        throw new AssertionError(\"shouldn't get here\");\n+    }\n+\n+    \/**\n+     * Does t has narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (t.isNonNullable()) {\n+            return s != null && !s.isNonNullable();\n+        }\n+        return false;\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":126,"deletions":13,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -186,0 +187,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -219,0 +221,4 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n@@ -734,0 +740,5 @@\n+        if (allowNullRestrictedTypes &&\n+                tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -1169,0 +1180,8 @@\n+            if (allowNullRestrictedTypes && tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1331,0 +1350,13 @@\n+            if (allowNullRestrictedTypes) {\n+                Type elemOrType = result;\n+                while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                    elemOrType = types.elemtype(elemOrType);\n+                }\n+                if ((result.isNonNullable() || elemOrType.isNonNullable()) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor())) {\n+                    log.error(tree.pos(),\n+                            types.elemtype(result) == null?\n+                                    Errors.TypeCantBeNullRestricted(result) :\n+                                    Errors.TypeCantBeNullRestricted2(result)\n+                    );\n+                }\n+            }\n@@ -2890,1 +2922,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -2892,0 +2924,4 @@\n+                if (allowNullRestrictedTypes && owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -4380,0 +4416,9 @@\n+        \/\/ check nullness of site\n+        if (site.isNullable()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (site.isParametric()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -4692,0 +4737,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5339,0 +5389,6 @@\n+            if (c.type.isValueClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (allowNullRestrictedTypes &&\n+                        env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -188,0 +189,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -235,0 +237,3 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n@@ -309,0 +314,10 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnNullableTypes(DiagnosticPosition pos, Warning warnKey) {\n+        if (allowNullRestrictedTypes && lint.isEnabled(LintCategory.NULL)) {\n+            log.warning(LintCategory.NULL, pos, warnKey);\n+        }\n+    }\n+\n@@ -681,3 +696,6 @@\n-                if (lint.isEnabled(LintCategory.CAST))\n-                    log.warning(LintCategory.CAST,\n-                            tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                if (lint.isEnabled(LintCategory.CAST)) {\n+                    if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n+                        log.warning(LintCategory.CAST,\n+                                tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                    }\n+                }\n@@ -710,1 +728,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -715,1 +733,11 @@\n-             return types.isSubtype(a, bound);\n+             try {\n+                 if (pos != null) {\n+                     types.pushWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.popWarner();\n+                 }\n+             }\n+\n@@ -769,0 +797,1 @@\n+        checkConstraintsOfValueClassesWithImplicitConst(tree, c);\n@@ -792,0 +821,24 @@\n+    void checkConstraintsOfValueClassesWithImplicitConst(JCClassDecl classDecl, ClassSymbol c) {\n+        if (allowNullRestrictedTypes) {\n+            JCMethodDecl implicitConstructor = TreeInfo.getImplicitConstructor(classDecl.defs);\n+            if (implicitConstructor != null) {\n+                Type encl = c.type.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitCannotBeInner(c));\n+                }\n+                \/*if ((c.flags() & HASINITBLOCK) != 0) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitDeclaresInitBlock(c));\n+                }*\/\n+                for (Symbol s : c.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0 & (s.flags() & HASINIT) != 0) {\n+                                log.error(classDecl.pos(), Errors.ValueClassWithImplicitInstanceFieldInitializer(c));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1153,1 +1206,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1156,1 +1213,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1193,1 +1250,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1277,1 +1334,9 @@\n-                } else\n+                } else if ((flags & IMPLICIT) != 0) {\n+                    if ((flags & PUBLIC) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBePublic);\n+                    }\n+                    if ((sym.owner.flags_field & VALUE_CLASS) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBeDeclaredInValueClass);\n+                    }\n+                    mask = ImplicitConstructorFlags;\n+                } else {\n@@ -1279,0 +1344,1 @@\n+                }\n@@ -1542,1 +1608,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1949,0 +2015,9 @@\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+        }\n+        overrideWarner.remove(LintCategory.NULL);\n+        \/\/ at this point we know this will be true but to gather the warnings\n+        types.isSubSignature(mt, ot, overrideWarner);\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+        }\n@@ -2425,0 +2500,41 @@\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n+    \/\/ TODO, update this method once we have null restricted types\n+    void checkNonCyclicMembership(JCClassDecl tree) {\n+        if (!tree.sym.type.hasImplicitConstructor()) {\n+            return;\n+        }\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                    }\n+                }\n+            }\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n+            return;\n+        }\n+        try {\n+            c.flags_field |= LOCKED;\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+        \/\/ where\n+        private boolean cyclePossible(VarSymbol symbol) {\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n+        }\n+\n@@ -2674,0 +2790,6 @@\n+        boolean implementsLooselyConsistentValue = false;\n+        try {\n+            implementsLooselyConsistentValue = allowValueClasses && allowNullRestrictedTypes ? types.asSuper(c, syms.looselyConsistentValueType.tsym) != null : false;\n+        } catch (CompletionFailure cf) {\n+            \/\/ ignore\n+        }\n@@ -2675,0 +2797,6 @@\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        if (c.getKind() == TypeKind.DECLARED && implementsLooselyConsistentValue && !c.tsym.isAbstract()) {\n+            if (!cIsValue || !((ClassSymbol)c.tsym).hasImplicitConstructor()) {\n+                log.error(pos, Errors.CantImplementInterface(c.tsym));\n+            }\n+        }\n@@ -4439,0 +4567,22 @@\n+    private class NullnessWarner extends Warner {\n+        public NullnessWarner(DiagnosticPosition pos) {\n+            super(pos);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (allowNullRestrictedTypes) {\n+                boolean warned = this.warned;\n+                super.warn(lint);\n+                if (warned) return; \/\/ suppress redundant diagnostics\n+                switch (lint) {\n+                    case NULL:\n+                        Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                        break;\n+                    default:\n+                        throw new AssertionError(\"Unexpected lint: \" + lint);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -4467,0 +4617,3 @@\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n@@ -4470,0 +4623,21 @@\n+            this.warned = true;\n+        }\n+    }\n+\n+    private class CastWarner extends ConversionWarner {\n+        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n+            super(pos, key, found, expected);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (lint != LintCategory.NULL) {\n+                super.warn(lint);\n+            } else {\n+                boolean warned = this.warned;\n+                if (warned) return;\n+                if (expected.isParametric()) {\n+                    \/\/ not sure this is the right warning\n+                    Check.this.warnNullableTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                }\n+            }\n@@ -4474,1 +4648,1 @@\n-        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":185,"deletions":11,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2123,1 +2123,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedNonNullableOrParametricField(sym));\n@@ -2136,0 +2137,7 @@\n+        boolean isUninitializedNonNullableOrParametricField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            (sym.type.isNonNullable() || sym.type.isParametric()));\n+        }\n+\n@@ -2224,0 +2232,9 @@\n+                if (isUninitializedNonNullableOrParametricField(sym)) {\n+                    if (lint.isEnabled(Lint.LintCategory.NULL)) {\n+                        if (sym.type.isNonNullable()) {\n+                            log.warning(pos, Warnings.NonNullableShouldBeInitialized);\n+                        } else {\n+                            log.warning(pos, Warnings.ParametricShouldBeInitialized);\n+                        }\n+                    }\n+                } else {\n@@ -2225,0 +2242,1 @@\n+                }\n@@ -2468,1 +2486,1 @@\n-                                } else {\n+                                } else if (!tree.sym.isImplicitConstructor()) { \/\/ implicit constructors are special, ignore them\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final boolean allowNullRestrictedTypes;\n@@ -136,0 +137,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -4202,0 +4204,2 @@\n+        \/\/ nullness info could be lost in the translation process, let's keep the original element type\n+        JCExpression originalElemType = tree.elemtype;\n@@ -4203,1 +4207,2 @@\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n+        int noOfDims = 0;\n+        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail) {\n@@ -4205,0 +4210,2 @@\n+            noOfDims++;\n+        }\n@@ -4206,1 +4213,26 @@\n-        result = tree;\n+        if (emitQDesc || !allowNullRestrictedTypes || tree.elemtype == null || !originalElemType.type.isNonNullable()) {\n+            result = tree;\n+        } else {\n+            Symbol elemClass = syms.getClassField(tree.elemtype.type, types);\n+            JCFieldAccess elemClassExpr = make.Select(make.Ident(tree.elemtype.type.tsym).setType(tree.elemtype.type), elemClass);\n+            MethodSymbol asNullRestrictedTypeMeth = lookupMethod(tree.pos(), names.asNullRestrictedType, syms.classType, List.nil());\n+            JCExpression asNullRestrictedTypeCall = make.Apply(\n+                        null,\n+                        make.Select(elemClassExpr, asNullRestrictedTypeMeth).setType(syms.classType), List.nil()).setType(syms.classType);\n+            List<JCExpression> dimsExp = tree.dims;\n+            if (noOfDims > 1) {\n+                JCNewArray dimsArr = make.NewArray(make.Type(syms.intType), List.nil(), tree.dims);\n+                dimsArr.type = types.makeArrayType(syms.intType);\n+                dimsExp = List.of(dimsArr);\n+            }\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.newInstance,\n+                syms.reflectArrayType, List.of(syms.classType, noOfDims == 1 ? syms.intType : types.makeArrayType(syms.intType)));\n+            JCExpression call =\n+                    make.Apply(\n+                            null,\n+                            make.Select(make.Ident(syms.reflectArrayType.tsym).setType(syms.reflectArrayType), appyMeth).setType(syms.objectType),\n+                            dimsExp.prepend(asNullRestrictedTypeCall))\n+                            .setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(types.makeArrayType(tree.elemtype.type, noOfDims), call);\n+            result = cast;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -42,0 +43,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -60,0 +62,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1317,0 +1317,33 @@\n+            new AttributeReader(names.ImplicitCreation, V66, CLASS_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (((ClassSymbol)sym).hasImplicitConstructor()) { \/\/ there can only be one per class\n+                        throw badClassFile(\"attribute.must.be.unique\", names.ImplicitCreation);\n+                    }\n+                    if (sym.kind == TYP) {\n+                        nextChar();\n+                        ((ClassSymbol)sym).implicitConstructorFound();\n+                    }\n+                }\n+            },\n+            new AttributeReader(names.NullRestricted, V66, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind != VAR) {\n+                        throw badClassFile(\"attribute.only.applicable.to.fields\", names.NullRestricted);\n+                    }\n+                    if (sym.type.isPrimitive() || sym.type.hasTag(TypeTag.ARRAY)) {\n+                        throw badClassFile(\"attribute.not.applicable.to.field.type\", names.NullRestricted, sym.type);\n+                    }\n+                    if (sym.type.isNonNullable()) {\n+                        throw badClassFile(\"attribute.must.be.unique\", names.NullRestricted);\n+                    }\n+                    sym.type = sym.type.asNullMarked(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL);\n+                }\n+            },\n@@ -2630,0 +2663,11 @@\n+        if (names.isInit(name) && ((flags & STATIC) != 0)) {\n+            flags &= ~STATIC;\n+            type = new MethodType(type.getParameterTypes(),\n+                    syms.voidType,\n+                    type.getThrownTypes(),\n+                    syms.methodClass);\n+            if (((ClassSymbol)currentOwner).hasImplicitConstructor() && type.getParameterTypes().size() == 0) {\n+                \/\/ this has to be the implicit constructor\n+                flags |= IMPLICIT;\n+            }\n+        }\n@@ -3132,0 +3176,2 @@\n+        \/\/ we need to do some checks now that the class has been loaded\n+        checkNonCyclicMembership(c);\n@@ -3407,0 +3453,51 @@\n+\n+    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n+    void checkNonCyclicMembership(ClassSymbol csym) {\n+        if (!allowValueClasses || !csym.type.hasImplicitConstructor()) {\n+            \/\/ nothing to see here\n+            return;\n+        }\n+        Assert.check((csym.flags_field & LOCKED) == 0);\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(field);\n+            }\n+            csym.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            csym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            JavaFileObject prevSource = log.useSource(currentClassFile);\n+            try {\n+                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n+                return;\n+            } finally {\n+                log.useSource(prevSource);\n+            }\n+        }\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(fld);\n+            }\n+            c.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private boolean cyclePossible(VarSymbol symbol) {\n+        return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+    \/** Switch: are null-restricted types allowed\n+     *\/\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -144,0 +148,2 @@\n+    private final Symtab syms;\n+\n@@ -178,0 +184,1 @@\n+        syms = Symtab.instance(context);\n@@ -193,0 +200,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -377,0 +385,3 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeNullRestrictedIfNeeded(sym);\n+        }\n@@ -838,1 +849,1 @@\n-            int flags = adjustFlags(inner.flags_field);\n+            int flags = adjustFlags(inner, inner.flags_field);\n@@ -948,0 +959,24 @@\n+    \/** Write \"ImplicitCreation\" attribute.\n+     *\/\n+    int writeImplicitCreationIfNeeded(ClassSymbol csym) {\n+        if (allowNullRestrictedTypes && csym.isValueClass() && csym.hasImplicitConstructor()) {\n+            int alenIdx = writeAttr(names.ImplicitCreation);\n+            int flags = ACC_DEFAULT | (csym.isSubClass(syms.looselyConsistentValueType.tsym, types) ? ACC_NON_ATOMIC : 0);\n+            databuf.appendChar(flags);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/** Write \"NullRestricted\" attribute.\n+     *\/\n+    int writeNullRestrictedIfNeeded(Symbol sym) {\n+        if (allowNullRestrictedTypes && sym.kind == VAR && sym.type.isNonNullable() && !sym.type.hasTag(ARRAY)) {\n+            int alenIdx = writeAttr(names.NullRestricted);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n@@ -979,1 +1014,1 @@\n-        int flags = adjustFlags(v.flags());\n+        int flags = adjustFlags(v, v.flags());\n@@ -1008,1 +1043,1 @@\n-        int flags = adjustFlags(m.flags());\n+        int flags = adjustFlags(m, m.flags());\n@@ -1293,0 +1328,4 @@\n+                if (debugstackmap) System.out.print(\"object(\" + types.erasure(t).tsym + \")\");\n+                databuf.appendByte(7);\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n+                break;\n@@ -1724,0 +1763,4 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeImplicitCreationIfNeeded(c);\n+        }\n+\n@@ -1769,1 +1812,1 @@\n-    int adjustFlags(final long flags) {\n+    int adjustFlags(Symbol sym, final long flags) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":47,"deletions":4,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private static final Object[] NO_STATIC_ARGS = new Object[0];\n@@ -895,0 +896,4 @@\n+            if (pts.head.isNonNullable() && !l.head.type.isNonNullable()) {\n+                code.emitop0(dup);\n+                genNullCheck(l.head);\n+            }\n@@ -1042,0 +1047,2 @@\n+                selfType = selfType.hasImplicitConstructor() ?\n+                        selfType.addMetadata(new TypeMetadata.NullMarker(JCNullableTypeExpression.NullMarker.NOT_NULL)) : selfType;\n@@ -1074,0 +1081,4 @@\n+                if (tree.type.isNonNullable() && !tree.init.type.isNonNullable()) {\n+                    code.emitop0(dup);\n+                    genNullCheck(tree.init);\n+                }\n@@ -2074,0 +2085,4 @@\n+        if (tree.lhs.type.isNonNullable() && !tree.rhs.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.rhs);\n+        }\n@@ -2279,0 +2294,4 @@\n+        if (tree.clazz.type.isNonNullable() && !tree.expr.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.expr);\n+        }\n@@ -2349,1 +2368,2 @@\n-            code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type,\n+                    tree.selected.type.hasImplicitConstructor() && tree.selected.type.isNonNullable()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -200,0 +201,1 @@\n+        this.allowNullRestrictedTypes = fac.options.isSet(\"enableNullRestrictedTypes\");\n@@ -224,0 +226,1 @@\n+        this.allowNullRestrictedTypes = parser.allowNullRestrictedTypes;\n@@ -269,0 +272,4 @@\n+    \/** Switch: are null-restricted types allowed?\n+     *\/\n+    boolean allowNullRestrictedTypes;\n+\n@@ -279,0 +286,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -286,0 +294,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -304,1 +313,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -308,1 +317,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -703,0 +712,4 @@\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            setNullMarker(t);\n+            nextToken();\n+        }\n@@ -1140,1 +1153,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (allowNullRestrictedTypes && token.kind == QUES && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1321,0 +1345,1 @@\n+        boolean emotionalMarkersOK = false;\n@@ -1470,0 +1495,6 @@\n+                if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    emotionalMarkersOK = true;\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1489,0 +1520,4 @@\n+                            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                setNullMarker(t);\n+                                nextToken();\n+                            }\n@@ -1616,0 +1651,10 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (token.kind == QUES || token.kind == BANG || (token.kind == STAR))) {\n+                if (peekToken(LBRACKET) || peekToken(LT) || emotionalMarkersOK) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                } else {\n+                    \/\/ not a type\n+                    break;\n+                }\n+            }\n@@ -1732,1 +1777,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (allowNullRestrictedTypes && isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1741,0 +1791,4 @@\n+                        if (allowNullRestrictedTypes && isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1825,0 +1879,13 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        ((JCNullableTypeExpression)exp).setNullMarker(\n+                tk.kind == QUES ?\n+                        NullMarker.NULLABLE :\n+                        token.kind == BANG ?\n+                                NullMarker.NOT_NULL :\n+                                NullMarker.PARAMETRIC);\n+    }\n+\n@@ -1889,1 +1956,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -1957,0 +2024,15 @@\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW))) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET)) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -1979,0 +2061,1 @@\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -1981,0 +2064,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -1983,0 +2067,6 @@\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2001,0 +2091,1 @@\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2060,0 +2151,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -2399,0 +2494,6 @@\n+        } else if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && peekToken(LBRACKET)) {\n+            Token nullMarker = token;\n+            nextToken();\n+            int pos = token.pos;\n+            nextToken();\n+            t = bracketsOptCont(t, pos, nextLevelAnnotations, nullMarker);\n@@ -2421,0 +2522,5 @@\n+        return bracketsOptCont(t, pos, annotations, null);\n+    }\n+\n+    private JCExpression bracketsOptCont(JCExpression t, int pos,\n+                                         List<JCAnnotation> annotations, Token nullMarker) {\n@@ -2424,0 +2530,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -3339,0 +3448,13 @@\n+                    } \/*else if (typeDepth == 0 && allowNullRestrictedTypes &&\n+                            ((peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) ) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } *\/else if ( allowNullRestrictedTypes &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) ) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3353,0 +3475,2 @@\n+                case BANG:\n+                    if (allowNullRestrictedTypes && !peekToken(lookahead, LPAREN)) break;\n@@ -3532,0 +3656,4 @@\n+                if (allowNullRestrictedTypes && isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3805,0 +3933,7 @@\n+        if (name == names.implicit) {\n+            if (allowNullRestrictedTypes && allowValueClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":140,"deletions":5,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -3210,0 +3210,3 @@\n+compiler.misc.feature.bang.types=\\\n+    bang types\n+\n@@ -4068,0 +4071,39 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n+# 0: symbol, 1: type\n+compiler.misc.superclass.of.value.class=\\\n+    The super class {1} of the value class {0}\n+\n+# 0: symbol\n+compiler.misc.abstract.value.class=\\\n+    The abstract value class {0}\n+\n+compiler.err.call.to.super.not.allowed.in.value.ctor=\\\n+    call to super not allowed in value class constructor\n+\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n+compiler.err.implicit.const.must.be.public=\\\n+    implicit constructors must be public\n+\n+compiler.err.implicit.const.must.be.declared.in.value.class=\\\n+    only value classes can declare implicit constructors\n+\n+# 0: symbol\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n+     be value classes and declare an implicit constructor.\n+\n@@ -4092,0 +4134,51 @@\n+\n+### null-restricted types\n+\n+compiler.err.non.nullable.cannot.be.assigned.null=\\\n+    non-nullable type cannot be assigned null\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    it must be a value class with an implicit constructor\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted.2=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    its element type must be a value class with an implicit constructor\n+\n+# 0: name\n+compiler.misc.attribute.must.be.unique=\\\n+    attribute {0} must be unique\n+\n+# 0: name\n+compiler.misc.attribute.only.applicable.to.fields=\\\n+    attribute {0} is only applicable to fields\n+\n+# 0: name, 1: type\n+compiler.misc.attribute.not.applicable.to.field.type=\\\n+    attribute {0} is not applicable to {1}\n+\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+compiler.warn.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -228,0 +228,3 @@\n+javac.opt.Xlint.desc.null=\\\n+    Warn about operations on null-restricted and nullable types.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2569,1 +2569,1 @@\n-    public static class JCFieldAccess extends JCExpression implements MemberSelectTree {\n+    public static class JCFieldAccess extends JCNullableTypeExpression implements MemberSelectTree {\n@@ -2706,1 +2706,1 @@\n-    public static class JCIdent extends JCExpression implements IdentifierTree {\n+    public static class JCIdent extends JCNullableTypeExpression implements IdentifierTree {\n@@ -2815,1 +2815,1 @@\n-    public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {\n+    public static class JCArrayTypeTree extends JCNullableTypeExpression implements ArrayTypeTree {\n@@ -2840,1 +2840,1 @@\n-    public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {\n+    public static class JCTypeApply extends JCNullableTypeExpression implements ParameterizedTypeTree {\n@@ -2898,0 +2898,34 @@\n+    \/**\n+     * A nullable type expression. Supported nullable expression types are: simple type names,\n+     * qualified type names, parameterized types and array types.\n+     *\/\n+\n+    public static abstract class JCNullableTypeExpression extends JCExpression {\n+        private NullMarker nullMarker = NullMarker.UNSPECIFIED;\n+\n+        public NullMarker getNullMarker() {\n+            return nullMarker;\n+        }\n+\n+        public void setNullMarker(NullMarker nullMarker) {\n+            this.nullMarker = nullMarker;\n+        }\n+\n+        public enum NullMarker {\n+            NOT_NULL(\"!\"),\n+            NULLABLE(\"?\"),\n+            PARAMETRIC(\"*\"),\n+            UNSPECIFIED(\"\");\n+\n+            private final String typeSuffix;\n+\n+            NullMarker(String typeSuffix) {\n+                this.typeSuffix = typeSuffix;\n+            }\n+\n+            public String typeSuffix() {\n+                return typeSuffix;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+                if (tree instanceof JCNullableTypeExpression nullableType) {\n+                    print(nullableType.getNullMarker().typeSuffix());\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -117,0 +117,6 @@\n+    public static JCMethodDecl getImplicitConstructor(List<JCTree> trees) {\n+        for (List<JCTree> l = trees; l.nonEmpty(); l = l.tail)\n+            if (isConstructor(l.head) && (((JCMethodDecl)l.head).mods.flags & IMPLICIT) != 0) return (JCMethodDecl) l.head;\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+    public final Name ImplicitCreation;\n+    public final Name NullRestricted;\n@@ -245,0 +247,5 @@\n+    \/\/ value classes\n+    public final Name implicit;\n+    public final Name newInstance;\n+    public final Name asNullRestrictedType;\n+\n@@ -376,0 +383,2 @@\n+        ImplicitCreation = fromString(\"ImplicitCreation\");\n+        NullRestricted = fromString(\"NullRestricted\");\n@@ -440,0 +449,5 @@\n+\n+        \/\/value classes\n+        implicit = fromString(\"implicit\");\n+        newInstance = fromString(\"newInstance\");\n+        asNullRestrictedType = fromString(\"asNullRestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+    public void remove(LintCategory lint) {\n+        nonSilentLintSet.remove(lint);\n+        silentLintSet.remove(lint);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -286,0 +286,8 @@\n+                void addValue(TypeElement e) {\n+                    if (e.getModifiers().contains(Modifier.VALUE)) {\n+                        list.add(\"value\");\n+                    } else if (e.getModifiers().contains(Modifier.IDENTITY)) {\n+                        list.add(\"identity\");\n+                    }\n+                }\n+\n@@ -297,0 +305,1 @@\n+                    addValue(e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -64,1 +64,4 @@\n-    public static enum Kind { Class, InnerClass, Field, Method}\n+    public static final int ACC_DEFAULT       = 0x0001; \/\/ ImplicitCreation attribute\n+    public static final int ACC_NON_ATOMIC    = 0x0002; \/\/ ImplicitCreation attribute\n+\n+    public static enum Kind { Class, InnerClass, Field, Method, ImplicitCreationAttr}\n@@ -160,0 +163,6 @@\n+    private static final int[] implicitCreationAttrFlags = { ACC_DEFAULT, ACC_NON_ATOMIC };\n+\n+    public Set<String> getImplicitCreationAttrFlags() {\n+        return getFlags(implicitCreationAttrFlags, Kind.ImplicitCreationAttr);\n+    }\n+\n@@ -224,1 +233,1 @@\n-            return \"ACC_PUBLIC\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_DEFAULT\" : \"ACC_PUBLIC\";\n@@ -226,1 +235,1 @@\n-            return \"ACC_PRIVATE\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_NON_ATOMIC\" : \"ACC_PRIVATE\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    public static final String ImplicitCreation         = \"ImplicitCreation\";\n@@ -63,0 +64,1 @@\n+    public static final String NullRestricted           = \"NullRestricted\";\n@@ -127,0 +129,1 @@\n+            standardAttributes.put(ImplicitCreation, ImplicitCreation_attribute.class);\n@@ -140,0 +143,1 @@\n+            standardAttributes.put(NullRestricted, NullRestricted_attribute.class);\n@@ -195,0 +199,1 @@\n+        R visitImplicitCreation(ImplicitCreation_attribute attr, P p);\n@@ -208,0 +213,1 @@\n+        R visitNullRestricted(NullRestricted_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -469,0 +469,6 @@\n+        @Override\n+        public Void visitImplicitCreation(ImplicitCreation_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.flags);\n+            return null;\n+        }\n+\n@@ -535,0 +541,5 @@\n+        @Override\n+        public Void visitNullRestricted(NullRestricted_attribute attr, ClassOutputStream out) {\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+public class ImplicitCreation_attribute extends Attribute {\n+\n+    public int flags;\n+\n+    ImplicitCreation_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        flags = cr.readUnsignedShort();\n+    }\n+\n+    public ImplicitCreation_attribute(int name_index, int flags) {\n+        super(name_index, 2);\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitImplicitCreation(this, data);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ImplicitCreation_attribute.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+public class NullRestricted_attribute extends Attribute {\n+    NullRestricted_attribute(ClassReader cr, int name_index, int length) {\n+        super(name_index, length);\n+    }\n+\n+    public NullRestricted_attribute(int name_index) {\n+        super(name_index, 0);\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitNullRestricted(this, data);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/NullRestricted_attribute.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -84,1 +84,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">DeprecatedClassByAnnotation<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">DeprecatedClassByAnnotation<\/span>\n@@ -140,1 +140,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestClass<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestClass<\/span>\n@@ -238,1 +238,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestError<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestError<\/span>\n@@ -249,1 +249,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestException<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestException<\/span>\n@@ -260,1 +260,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">TestInterface<\/span>\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">TestInterface<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public static class <\/span><\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public static identity class <\/span><\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/TestHiddenTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-label\">C1<\/span>\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">C1<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDefinitionListTag\/TestHtmlDefinitionListTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -185,1 +185,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlTag\/TestHtmlTag.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public static class <\/span><\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public static identity class <\/span><\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -191,1 +191,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestLinkOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1363,1 +1363,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -543,1 +543,1 @@\n-                    <\/span><span class=\"modifiers\">public class <\/span><span class=\"element-name type-name-l\\\n+                    <\/span><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-l\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/TestNewLanguageFeatures.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -269,1 +269,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOptions\/TestOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span><span cl\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span cl\\\n@@ -239,1 +239,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -244,1 +244,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\"> class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -97,1 +97,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -118,1 +118,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -143,1 +143,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R<\/span>\"\"\",\n@@ -174,1 +174,1 @@\n-                    <span class=\"modifiers\">public record <\/span><span class=\"element-name type-name-label\">R&lt;T&gt;<\/span>\"\"\",\n+                    <span class=\"modifiers\">public identity record <\/span><span class=\"element-name type-name-label\">R&lt;T&gt;<\/span>\"\"\",\n@@ -472,1 +472,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">public record <\/span><span c\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public identity record <\/span><span c\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -97,1 +97,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -102,1 +102,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public non-sealed class <\/span><span class=\"element-name type-name-label\">B<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public non-sealed identity class <\/span><span class=\"element-name type-name-label\">B<\/span>\n@@ -144,1 +144,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -192,1 +192,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -215,1 +215,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -238,1 +238,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -263,1 +263,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -288,1 +288,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -312,1 +312,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n@@ -336,1 +336,1 @@\n-                <div class=\"type-signature\"><span class=\"modifiers\">public sealed class <\/span><span class=\"element-name type-name-label\">A<\/span>\n+                <div class=\"type-signature\"><span class=\"modifiers\">public sealed identity class <\/span><span class=\"element-name type-name-label\">A<\/span>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSealedTypes\/TestSealedTypes.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -95,1 +95,1 @@\n-                    <div class=\"type-signature\"><span class=\"modifiers\">class <\/span><span class=\"el\\\n+                    <div class=\"type-signature\"><span class=\"modifiers\">identity class <\/span><span class=\"el\\\n@@ -469,1 +469,1 @@\n-                    <\/span><span class=\"modifiers\">class <\/span><span class=\"element-name type-name-\\\n+                    <\/span><span class=\"modifiers\">identity class <\/span><span class=\"element-name type-name-\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeAnnotations\/TestTypeAnnotations.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                    public class <\/span><span class=\"element-name\"><a href=\"..\/src-html\/pkg\/ClassUse\\\n+                    public identity class <\/span><span class=\"element-name\"><a href=\"..\/src-html\/pkg\/ClassUse\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/TestTypeParameters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,24 @@\n+\n+    @Test\n+    public void testImplicitConstModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+\n+                public value class ValueClassWithImplicitConst {\n+                    public implicit ValueClassWithImplicitConst();\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-XDenableNullRestrictedTypes\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueClassWithImplicitConst.html\", true,\n+                \"\"\"\n+                <div class=\"member-signature\"><span class=\"modifiers\">public implicit<\/span>&nbsp;<span class=\"element-name\">ValueClassWithImplicitConst<\/span>()<\/div>\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueClasses\/TestValueClasses.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -230,1 +230,16 @@\n-compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n\\ No newline at end of file\n+compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n+\n+#nullable types\n+compiler.misc.feature.bang.types\n+compiler.warn.accessing.member.of.nullable\n+compiler.warn.narrowing.nullness.conversion\n+compiler.warn.non.nullable.should.be.initialized\n+compiler.warn.accessing.member.of.parametric\n+compiler.warn.parametric.should.be.initialized\n+compiler.err.non.nullable.cannot.be.assigned.null\n+compiler.warn.unchecked.nullness.conversion\n+compiler.warn.overrides.with.different.nullness.1\n+compiler.warn.overrides.with.different.nullness.2\n+compiler.misc.attribute.must.be.unique                                   # bad class file\n+compiler.misc.attribute.not.applicable.to.field.type                     # bad class file\n+compiler.misc.attribute.only.applicable.to.fields                        # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+<<<<<<<< HEAD:test\/langtools\/tools\/javac\/diags\/examples\/CantImplementInterface.java\n+\/\/ key: compiler.err.cant.implement.interface\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+class CantImplementInterface implements LooselyConsistentValue {\n+========\n@@ -30,0 +36,1 @@\n+>>>>>>>> lworld:test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.type.cant.be.null.restricted\n+\/\/ key: compiler.err.type.cant.be.null.restricted.2\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+public class CantBeNonNullableType {\n+    String! s;\n+    String[]! sa;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantBeNonNullableType.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.cant.have.body\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+value class ImplicitConstructorWithBody {\n+    public implicit ImplicitConstructorWithBody() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitConstructorWithBody.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.must.be.declared.in.value.class\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+class ImplicitMustBeInValueClass {\n+    public implicit ImplicitMustBeInValueClass();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitMustBeInValueClass.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.must.be.public\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+value class ImplicitMustBePublic {\n+    implicit ImplicitMustBePublic();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitMustBePublic.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.cannot.be.inner\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+class ValueClassWithImplicitCannotBeInner {\n+    value class V {\n+        public implicit V();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCannotBeInner.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.declares.init.block\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+value class ValueClassWithImplicitCantDeclareInitBlock {\n+    int i;\n+    {\n+        i = 0;\n+    }\n+    public implicit ValueClassWithImplicitCantDeclareInitBlock();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCantDeclareInitBlock.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.instance.field.initializer\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+value class ValueClassWithImplicitCantHaveFieldInit {\n+    int i = 0;\n+    public implicit ValueClassWithImplicitCantHaveFieldInit ();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCantHaveFieldInit.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,689 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * NullabilityCompilationTests\n+ *\n+ * @test\n+ * @enablePreview\n+ * @summary compilation tests for bang types\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ *      jdk.jdeps\/com.sun.tools.classfile\n+ * @run testng\/othervm NullabilityCompilationTests\n+ * @ignore 8316628\n+ *\/\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.tools.Diagnostic;\n+\n+import org.testng.annotations.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class NullabilityCompilationTests extends CompilationTestCase {\n+    private static String[] EMPTY_OPTIONS = {};\n+    private static String[] LINT_OPTIONS = { \"-Xlint:null\" };\n+\n+    public NullabilityCompilationTests() {\n+        setDefaultFilename(\"Test.java\");\n+    }\n+\n+    enum TestResult {\n+        COMPILE_OK,\n+        COMPILE_WITH_WARNING,\n+        ERROR\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, null);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code, Consumer<Diagnostic<?>> diagConsumer) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, diagConsumer);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String diagsMessage, int diagsCount, TestResult testResult, String code,\n+                    Consumer<Diagnostic<?>> diagConsumer) {\n+        setCompileOptions(compilerOptions);\n+        try {\n+            if (testResult != TestResult.COMPILE_OK) {\n+                if (testResult == TestResult.COMPILE_WITH_WARNING) {\n+                    assertOKWithWarning(diagsMessage, diagsCount, code);\n+                } else {\n+                    assertFail(diagsMessage, code);\n+                }\n+            } else {\n+                if (diagConsumer == null) {\n+                    assertOK(code);\n+                } else {\n+                    assertOK(diagConsumer, code);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            System.err.println(\"error while compiling code:\\n\" + code);\n+            throw t;\n+        }\n+    }\n+\n+    void testList(List<DiagAndCode> testList) {\n+        for (DiagAndCode diagAndCode : testList) {\n+            if (diagAndCode.result == Result.Clean) {\n+                testHelper(LINT_OPTIONS, diagAndCode.code);\n+            } else if (diagAndCode.result == Result.Warning) {\n+                testHelper(LINT_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.COMPILE_WITH_WARNING, diagAndCode.code, null);\n+                testHelper(EMPTY_OPTIONS, diagAndCode.code,\n+                        d -> {\n+                            if (d.getKind() == Diagnostic.Kind.WARNING) {\n+                                \/\/ shouldn't issue any warnings if the -Xlint:null option is not passed\n+                                throw new AssertionError(\"unexpected warning for \" + diagAndCode.code);\n+                            }\n+                        });\n+            } else {\n+                testHelper(EMPTY_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n+            }\n+            if (diagAndCode.result != Result.Error) {\n+                testHelper(EMPTY_OPTIONS, diagAndCode.code);\n+            }\n+        }\n+    }\n+\n+    enum Result { Warning, Error, Clean}\n+\n+    record DiagAndCode(String code, Result result, String diag, int diagsCount) {\n+        DiagAndCode(String code, Result result, String diag) {\n+            this(code, result, diag, 1);\n+        }\n+    }\n+\n+    public void testErrorNonNullableCantBeAssignedNull() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        \/*new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T!> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),*\/\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class MyList<T> {\n+                                    void add(T e) {}\n+                                }\n+                                class Test {\n+                                    void m(MyList<? super Point!> ls) {\n+                                        ls.add(null);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\")\n+                )\n+        );\n+    }\n+\n+    public void testWarnUninitialized() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point![]![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[][][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.non.nullable.should.be.initialized\")\n+                )\n+        );\n+    }\n+\n+    public void testUncheckedNullnessConversions () {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void m(Point! s1, Point s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        \/*new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m(Object! s1, String s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),*\/\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void m(Point! s1, Point s3) {\n+                                        s3 = s1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        \/*\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends String!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends Object!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        *\/\n+\n+                        \/\/ wildcards\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void test(List<? extends Point!> ls1, List<? extends Point> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends Object!> ls1, List<? extends String> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static value class Atom {}\n+                                    static class Box<X> {}\n+                                    void test(Box<? extends Atom!> t1, Box<Atom> t2) {\n+                                        t1 = t2;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Wrapper<T> {}\n+                                class Test<T> {\n+                                    Wrapper<T> newWrapper() { return null; }\n+                                    void m() {\n+                                        Wrapper<T!> w = newWrapper();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String, String> f) {}\n+                                    void m(Function<String!, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String!, String> f) {}\n+                                    void m(Function<String, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T!> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T!>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(Consumer<? super T!> action) {\n+                                        action.accept(field);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T!>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    class Box<X> {}\n+                                    static value class Point { public implicit Point(); }\n+                                    @SafeVarargs\n+                                    private <Z> Z make_box_uni(Z... bs) {\n+                                        return bs[0];\n+                                    }\n+                                    void test(Box<Point!> bref, Box<Point> bval) {\n+                                        Box<? extends Point!> res = make_box_uni(bref, bval);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends String> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends Object> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    public void testNoWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape { public implicit Point(); }\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Point!> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? extends Shape> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape { public implicit Point(); }\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Shape> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? super Point!> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class C<T> {\n+                                    T x = null;\n+                                    void set(T arg) { x = arg; }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyList<T> {\n+                                    static <E> MyList<E> of(E e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class MyCollection<T> {}\n+                                class MyList<T> extends MyCollection<T!> {\n+                                    static <E> MyList<E> of(E e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyCollection<Point> mpc = MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(T t) {\n+                                        field = t;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        \/* we are testing that the compiler won't infer the arguments of\n+                                         * VarHandle::setVolatile as (Cell, String!)\n+                                         *\/\n+                                        VALUE.setVolatile(this, \"\");\n+                                    }\n+                                    final void reset(String identity) {\n+                                        \/* if that were the case, see comment above, then this invocation would generate\n+                                         * a warning, VarHandle::setVolatile is a polymorphic signature method\n+                                         *\/\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        VALUE.setVolatile(this, 0L);\n+                                    }\n+                                    final void reset(long identity) {\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Test {\n+                                    public implicit Test();\n+                                    void m(Test t1, Test[] t2, Test[][] t3, Test[][][] t4) {\n+                                        Test! l1 = (Test!) t1;\n+                                        Test![] l2 = (Test![]) t2;\n+                                        Test![][] l3 = (Test![][]) t3;\n+                                        Test![][][] l4 = (Test![][][]) t4;\n+\n+                                        Test[]! l5 = (Test[]!) t2;\n+                                        Test[][]! l6 = (Test[][]!) t3;\n+                                        Test[][][]! l7 = (Test[][][]!) t4;\n+\n+                                        Test[]![]! l8 = (Test[]![]!) t3;\n+                                        Test[]![]![]! l9 = (Test[]![]![]!) t4;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    public void testOverridingWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                abstract class A {\n+                                    abstract String! lookup(String arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String lookup(String arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.1\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                abstract class A {\n+                                    abstract String lookup(Point! arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String lookup(Point arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.2\")\n+                )\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":689,"deletions":0,"binary":false,"changes":689,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary Smoke test for parsing of bang types\n+ * @compile -XDenableNullRestrictedTypes NullabilityParsingTest.java\n+ *\/\n+\n+import java.util.function.*;\n+import java.util.*;\n+\n+class NullabilityParsingTest {\n+    static value class Point { public implicit Point(); }\n+    static value class Shape { public implicit Shape(); }\n+    \/\/ fields\n+    Point! o2;\n+\n+    \/\/ method parameters\n+    void m2(Point! o) { }\n+\n+    \/\/ method returns\n+    Point! m2() { return new Point(); }\n+\n+    \/\/ locals\n+    void testLocals() {\n+        Point! o2;\n+    }\n+\n+    \/\/ generics - field\n+    Consumer<Point!> co2;\n+\n+    \/\/ generics - method param\n+    void m4(Consumer<Point!> co) { }\n+\n+    \/\/ generics - method return\n+    Consumer<Point!> m4() { return null; }\n+\n+    \/\/ generics - local\n+    void testGenericLocals() {\n+        Consumer<Point!> co2;\n+    }\n+\n+    \/\/ lambdas\n+    void testLambdas() {\n+        Consumer<Point!> co2 = (Point! co) -> {};\n+    }\n+\n+    void testGenericLambdas() {\n+        Consumer<Consumer<Point!>> co2 = (Consumer<Point!> co) -> {};\n+        Consumer<Function<Point!, Point!>> co3 = (Function<Point!, Point!> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Point!>>>> co6 = (Consumer<Consumer<Consumer<Point!>>> co) -> {};\n+    }\n+\n+    \/\/ type test patterns\n+\n+    void testTypeTestPatterns(Object o) {\n+        switch (o) {\n+            case Point! i -> throw new AssertionError();\n+            case Shape! s -> throw new AssertionError();\n+            default -> throw new AssertionError();\n+        }\n+    }\n+\n+    sealed interface I<X> {}\n+    final class A implements I<Point> { }\n+\n+    void genericTypeTestPatterns(A o) {\n+        switch (o) {\n+            case I<Point!> i -> { }\n+        }\n+    }\n+\n+    sealed interface I2<X> {}\n+    final class A2 implements I2<I<Point>> { }\n+\n+    void genericTypeTestPatterns(A2 o) {\n+        switch (o) {\n+            case I2<I<Point!>> i -> { }\n+        }\n+    }\n+\n+    sealed interface I3<X> {}\n+    final class A3 implements I3<I2<I<Point>>> { }\n+\n+    void genericTypeTestPatterns(A3 o) {\n+        switch (o) {\n+            case I3<I2<I<Point!>>> i -> { }\n+        }\n+    }\n+\n+    \/\/ record patterns\n+\n+    record R(A a) { }\n+\n+    void genericRecordPatterns(R o) {\n+        switch (o) {\n+            case R!(I<Point!> i) -> { }\n+        }\n+    }\n+\n+    record R2(A2 a2) { }\n+\n+    void genericRecordPatterns(R2 o) {\n+        switch (o) {\n+            case R2!(I2<I<Point!>> i) -> { }\n+        }\n+    }\n+\n+    record R3(A3 a3) { }\n+\n+    void genericRecordPatterns(R3 o) {\n+        switch (o) {\n+            case R3!(I3<I2<I<Point!>>> i) -> { }\n+        }\n+    }\n+\n+    \/\/ instanceof\/cast\n+\n+    void testInstanceOf(Object o) {\n+        boolean r2 = o instanceof Point!;\n+    }\n+\n+    void testInstanceRecord(R r) {\n+        boolean r2 = r instanceof R(I<Point!> i);\n+    }\n+\n+    void testCast(Object o) {\n+        Point! s2 = (Point!)o;\n+    }\n+\n+    void testGenericCast(A a) {\n+        I<Point!> i2 = (I<Point!>)a;\n+    }\n+\/*\n+    void testGenericCast2(A a) {\n+        I<Point!> i2 = (I<Point!>)a;\n+    }\n+*\/\n+    \/\/ arrays\n+\n+    Point![]![]![]! oarr;\n+    Function<Point![]![]!, Function<Point![]![]!, Point![]![]!>>[][] garr;\n+\n+    void mBad1(Object o) {\n+        Point s1 = o instanceof Point ? (Point)o : null;\n+        Point s2 = o instanceof Point! ? (Point)o : null;\n+    }\n+\n+    void mBad2(Object o) {\n+        Point s1 = o instanceof Point ? null : null;\n+        Point s2 = o instanceof Point! ? null : null;\n+    }\n+\n+    void testPatternRule(Object o) {\n+        switch (o) {\n+            case Point! s -> { }\n+                default -> { }\n+        }\n+    }\n+\n+    void testPatternCol(Object o) {\n+        switch (o) {\n+            case Point! s: { }\n+            default: { }\n+        }\n+    }\n+\n+    void testInstanceOfAndInfix1(Object a, boolean b) {\n+        boolean x2 = a instanceof Point! && b;\n+    }\n+\n+    void testInstanceOfAndInfix2(Object a, boolean b) {\n+        boolean x2 = a instanceof Point! s && b;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test runtime null checks\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RuntimeNullChecks\n+ * @ignore 8316628\n+ *\/\n+\n+import java.util.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.IntStream;\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+\n+public class RuntimeNullChecks extends TestRunner {\n+    ToolBox tb;\n+\n+    RuntimeNullChecks() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RuntimeNullChecks t = new RuntimeNullChecks();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testRuntimeChecks(Path base) throws Exception {\n+        for (String code: new String[] {\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Point! o = s; \/\/ NPE at runtime, variable initialization\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Point! o;\n+                        o = s; \/\/ NPE at runtime, assignment, it doesn't stress the same code path as the case above\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Point![] sr = new Point![10];\n+                        sr[0] = s; \/\/ NPE at runtime, assignment\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    static Point id(Point! arg) { return arg; }\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Object o = id(s); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Point { public implicit Point(); }\n+                class Test {\n+                    public static void main(String... args) {\n+                        Point s = null;\n+                        Object o = (Point!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            testHelper(base, code, true, NullPointerException.class);\n+        }\n+    }\n+\n+    private void testHelper(Path base, String testCode, boolean shouldFail, Class<?> expectedError) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path testSrc = src.resolve(\"Test\");\n+\n+        tb.writeJavaFiles(testSrc, testCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's check that we get the expected error\n+            String output = new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDERR);\n+            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError.getName())) {\n+                throw new AssertionError(expectedError.getName() + \" expected\");\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -119,1 +119,1 @@\n-                \"- compiler.note.proc.messager: visiting: NonSealedClass1 Modifiers: [non-sealed]\",\n+                \"- compiler.note.proc.messager: visiting: NonSealedClass1 Modifiers: [non-sealed, identity]\",\n@@ -121,1 +121,1 @@\n-                \"- compiler.note.proc.messager: visiting: SealedClass Modifiers: [sealed]\",\n+                \"- compiler.note.proc.messager: visiting: SealedClass Modifiers: [sealed, identity]\",\n@@ -125,1 +125,1 @@\n-                \"- compiler.note.proc.messager: visiting: FinalClass Modifiers: [final]\",\n+                \"- compiler.note.proc.messager: visiting: FinalClass Modifiers: [identity, final]\",\n@@ -127,1 +127,1 @@\n-                \"- compiler.note.proc.messager: visiting: NonSealedClass2 Modifiers: [non-sealed]\",\n+                \"- compiler.note.proc.messager: visiting: NonSealedClass2 Modifiers: [non-sealed, identity]\",\n@@ -129,1 +129,1 @@\n-                \"- compiler.note.proc.messager: visiting: ClassOutOfSealedHierarchy Modifiers: []\",\n+                \"- compiler.note.proc.messager: visiting: ClassOutOfSealedHierarchy Modifiers: [identity]\",\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestSealed.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,14 +1,14 @@\n-CheckThisLeak.java:17:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:18:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:19:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:21:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:22:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:24:23: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:25:22: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:33:25: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:34:17: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:35:18: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:37:36: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:38:37: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:40:21: compiler.err.this.exposed.prematurely\n-CheckThisLeak.java:41:22: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:17:17: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:18:9: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:19:10: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:21:28: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:22:29: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:24:15: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:25:14: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:33:17: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:34:9: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:35:10: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:37:28: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:38:29: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:40:13: compiler.err.this.exposed.prematurely\n+CheckThisLeak.java:41:14: compiler.err.this.exposed.prematurely\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.out","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+ConsumeUnifiedClass.java:40:28: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, Point)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -82,1 +82,1 @@\n-                primitive class PC extends GoodSuper implements GoodSuperInterface {}\n+                value class PC extends GoodSuper implements GoodSuperInterface {}\n@@ -93,1 +93,1 @@\n-                primitive class PC extends Integer {}\n+                value class PC extends Integer {}\n@@ -98,1 +98,1 @@\n-                primitive class PC extends Number {\n+                value class PC extends Number {\n@@ -111,1 +111,1 @@\n-                primitive class PC extends SuperWithStaticField {}\n+                value class PC extends SuperWithStaticField {}\n@@ -129,1 +129,1 @@\n-                primitive class PC extends SuperWithEmptyNoArgCtor_02 {}\n+                value class PC extends SuperWithEmptyNoArgCtor_02 {}\n@@ -135,1 +135,1 @@\n-                primitive class PC extends BadSuper {}\n+                value class PC extends BadSuper {}\n@@ -144,1 +144,1 @@\n-                primitive class PC extends SuperWithInstanceField_01 {}\n+                value class PC extends SuperWithInstanceField_01 {}\n@@ -155,1 +155,1 @@\n-                primitive class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n+                value class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n@@ -166,1 +166,1 @@\n-                primitive class PC extends SuperWithArgedCtor_01 {}\n+                value class PC extends SuperWithArgedCtor_01 {}\n@@ -181,1 +181,1 @@\n-                primitive class PC extends SuperWithInstanceInit_01 {}\n+                value class PC extends SuperWithInstanceInit_01 {}\n@@ -190,1 +190,1 @@\n-                primitive class PC extends SuperWithSynchronizedMethod_1 {}\n+                value class PC extends SuperWithSynchronizedMethod_1 {}\n@@ -198,1 +198,1 @@\n-                primitive class PC extends Outer.InnerSuper {}\n+                value class PC extends Outer.InnerSuper {}\n@@ -205,1 +205,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -213,1 +213,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -227,1 +227,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -241,1 +241,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -243,1 +243,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -252,1 +252,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -254,1 +254,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -263,1 +263,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -265,1 +265,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -274,1 +274,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -290,1 +290,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -298,1 +298,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -306,1 +306,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -314,1 +314,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -328,1 +328,0 @@\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\", \"primitive interface I {}\");\n@@ -332,1 +331,1 @@\n-                    primitive public void m() {}\n+                    value public void m() {}\n@@ -339,1 +338,1 @@\n-                        int[] ia = new primitive int[10];\n+                        int[] ia = new value int[10];\n@@ -347,1 +346,1 @@\n-                        new primitive String(\"Hello\");\n+                        new value String(\"Hello\");\n@@ -358,1 +357,1 @@\n-                        new primitive I() {};\n+                        new value I() {};\n@@ -365,1 +364,1 @@\n-    public void testPrimitivesAsTypeParams() {\n+    public void testValueClassesAsTypeParams() {\n@@ -369,1 +368,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -375,1 +374,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -381,1 +380,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -389,1 +388,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -396,2 +395,2 @@\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n+                import java.io.Serializable;\n+                value class ValueOverGenericsTest {\n@@ -405,1 +404,1 @@\n-            assertFail(\"compiler.err.type.found.req\", source);\n+            assertOK(source);\n@@ -415,1 +414,1 @@\n-                        primitive class Value {}\n+                        value class Value {}\n@@ -425,2 +424,2 @@\n-                        primitive class Value {}\n-                        new primitive Value() {};\n+                        value class Value {}\n+                        new value Value() {};\n@@ -458,1 +457,1 @@\n-                    primitive class UncheckedDefault<E> {\n+                    value class UncheckedDefault<E> {\n@@ -469,74 +468,0 @@\n-    public void testRefProjection() {\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC x) {\n-                        PC.ref xq = null;\n-                        xq = x;\n-                        xq = (PC.ref) x;\n-                        xq = (PC) x;\n-                        x = xq;\n-                        x = (PC.ref) xq;\n-                        x = (PC) xq;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC[] xa = new PC[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref [] xqa = new PC.ref[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa) {\n-                        PC.ref[] xqa = xa;\n-                        xqa = (PC.ref[]) xa;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = xqa;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = (PC[]) xqa;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -554,49 +479,0 @@\n-    public void testProjectionInstantiation() {\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.ref();\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.val();\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.ref::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.val::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-    }\n-\n@@ -604,1 +480,1 @@\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -607,2 +483,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -611,1 +487,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -619,1 +495,1 @@\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -622,2 +498,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -626,1 +502,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -639,1 +515,1 @@\n-                primitive class Bar {\n+                value class Bar {\n@@ -648,1 +524,1 @@\n-                primitive class DualPathInnerType  {\n+                value class DualPathInnerType  {\n@@ -652,1 +528,1 @@\n-                    DualPathInnerType.ref.Inner xri = xi;\n+                    DualPathInnerType.Inner xri = xi;\n@@ -655,1 +531,1 @@\n-                    void f (DualPathInnerType.ref.Inner xri) {}\n+                    void f (DualPathInnerType.Inner xri) {}\n@@ -668,1 +544,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -679,1 +555,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -690,1 +566,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -701,1 +577,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -712,1 +588,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -723,1 +599,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -734,1 +610,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -754,1 +630,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -766,1 +642,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -778,1 +654,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -790,1 +666,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -802,1 +678,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -814,1 +690,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -826,1 +702,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -838,1 +714,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -851,1 +727,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -864,2 +740,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -876,2 +752,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -888,2 +764,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -901,2 +777,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -914,2 +790,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -923,58 +799,0 @@\n-    public void testValRefTokensNegative() {\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    ValRefTokensNegativeTest.ref aa = null;\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    static ValRefTokensNegativeTest.val bb = ValRefTokensNegativeTest.default;\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    EmptyValue empty = EmptyValue.default;\n-\n-                    static class ValRefTokensTestWrapper {\n-                        ValRefTokensNegativeTest val = ValRefTokensNegativeTest.default;\n-                        ValRefTokensNegativeTest ref = ValRefTokensNegativeTest.default;\n-                    }\n-\n-                    public EmptyValue test(int x) {\n-                        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-                        return x == 0 ? w.val.empty : w.ref.empty;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int valx() {\n-                        return EmptyValue.val.x;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int refx() {\n-                        return EmptyValue.ref.x;\n-                    }\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -986,1 +804,1 @@\n-            assertFail(\"compiler.err.primitive.classes.not.supported\",\n+            assertFail(\"compiler.err.feature.not.supported.in.source.plural\",\n@@ -988,4 +806,4 @@\n-                    class primitive {\n-                        primitive x;\n-                        primitive foo(int l) {}\n-                        Object o = new primitive primitive() {};\n+                    class value {\n+                        value x;\n+                        value foo(int l) {}\n+                        Object o = new value value() {};\n@@ -997,1 +815,1 @@\n-                    class primitive {}\n+                    class value {}\n@@ -1011,1 +829,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1027,1 +845,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1045,1 +863,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1064,1 +882,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1083,1 +901,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1101,1 +919,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1113,1 +931,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1125,1 +943,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1139,1 +957,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1154,1 +972,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1174,1 +992,1 @@\n-                    primitive static class Foo extends S implements I<Integer> {\n+                    value static class Foo extends S implements I<Integer> {\n@@ -1180,90 +998,0 @@\n-\n-    public void testClassLiteralTypingNegativeTest() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"};\n-            setCompileOptions(testOptions);\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = PrimitiveClass.asValueType(Foo.class);\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = new Foo().getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.ref.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.val.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.val xv = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xv.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.ref xr = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xr.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":97,"deletions":369,"binary":false,"changes":466,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    static primitive class V {\n+    static value class V {\n@@ -42,1 +42,3 @@\n-        V() {\n+        public implicit V();\n+\n+        V(boolean dummy) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8209400 8215246\n+ * @summary Allow anonymous classes to be value types\n+ * @ignore 8316628\n+ *\/\n+\n+public class AnonymousValueType {\n+    public static void main(String[] args) {\n+        Object o = new value Comparable<String>() {\n+            int x = 10;\n+            @Override\n+            public int compareTo(String o) {\n+                return 0;\n+            }\n+        };\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n+            throw new AssertionError(\"Broken\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValueType.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Check array creation with value classes\n+ * @summary Check array creation with V and V.ref\n@@ -43,0 +43,11 @@\n+        VT![] a3;\n+        VT![] a4;\n+\n+        public implicit VT();\n+\n+        VT(boolean non_implicit) {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+            a3 = new VT![42];\n+            a4 = new VT![42];\n+        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * @enablePreview\n- * @compile AsSuperTests.java\n+ * @compile -XDenableNullRestrictedTypes AsSuperTests.java\n@@ -49,1 +48,1 @@\n-abstract value class Base<T> {\n+abstract class Base<T> {\n@@ -53,1 +52,1 @@\n-       String m(Foo f);\n+        String m(Foo! f);\n@@ -62,1 +61,3 @@\n-    static value class Foo<X> extends Base {}\n+    static value class Foo<X> extends Base {\n+        public implicit Foo();\n+    }\n@@ -66,0 +67,1 @@\n+    public implicit X();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AsSuperTests.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    public implicit CanonicalCtorTest();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-        CheckSynchronized.ref csr = cs;\n+        CheckSynchronized csr = cs;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized.ref, (compiler.misc.type.req.identity)\n+CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized, (compiler.misc.type.req.identity)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import com.sun.tools.classfile.ImplicitCreation_attribute;\n+import com.sun.tools.classfile.NullRestricted_attribute;\n@@ -64,0 +66,1 @@\n+\n@@ -73,1 +76,0 @@\n-        setCompileOptions(PREVIEW_OPTIONS);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one ImplicitCreation attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile DuplicateImplicitCreationAttr.jcod\n+ * @compile\/fail\/ref=CheckImplicitCreationAttrIsUnique.out -XDrawDiagnostics CheckImplicitCreationAttrIsUnique.java\n+ *\/\n+\n+public class CheckImplicitCreationAttrIsUnique {\n+    void m() {\n+        DuplicateImplicitCreationAttr v = new DuplicateImplicitCreationAttr();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/implicit_creation_attr\/CheckImplicitCreationAttrIsUnique.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckImplicitCreationAttrIsUnique.java:13:9: compiler.err.cant.access: DuplicateImplicitCreationAttr, (compiler.misc.bad.class.file.header: DuplicateImplicitCreationAttr.class, (compiler.misc.attribute.must.be.unique: ImplicitCreation))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/implicit_creation_attr\/CheckImplicitCreationAttrIsUnique.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+class DuplicateImplicitCreationAttr {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"DuplicateImplicitCreationAttr\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LDuplicateImplicitCreationAttr;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"DuplicateImplicitCreationAttr.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class DuplicateImplicitCreationAttr\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/implicit_creation_attr\/DuplicateImplicitCreationAttr.jcod","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile ValueClass.jcod DuplicateNullRestrictedAttr.jcod\n+ * @compile\/fail\/ref=CheckNullRestrictedAttrIsUnique.out -XDrawDiagnostics CheckNullRestrictedAttrIsUnique.java\n+ *\/\n+\n+public class CheckNullRestrictedAttrIsUnique {\n+    void m() {\n+        DuplicateNullRestrictedAttr v = new DuplicateNullRestrictedAttr();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/CheckNullRestrictedAttrIsUnique.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckNullRestrictedAttrIsUnique.java:13:9: compiler.err.cant.access: DuplicateNullRestrictedAttr, (compiler.misc.bad.class.file.header: DuplicateNullRestrictedAttr.class, (compiler.misc.attribute.must.be.unique: NullRestricted))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/CheckNullRestrictedAttrIsUnique.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+class DuplicateNullRestrictedAttr {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"DuplicateNullRestrictedAttr\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"field\"; \/\/ #5\n+    Utf8 \"LValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LDuplicateNullRestrictedAttr;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"DuplicateNullRestrictedAttr.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+    Utf8 \"Preload\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"ValueClass\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+        ;\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+                4  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#15) { \/\/ Preload\n+      0x00010010;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class DuplicateNullRestrictedAttr\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/DuplicateNullRestrictedAttr.jcod","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"DuplicateNullRestrictedAttr.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/ValueClass.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile NullRestrictedOnPrimitive.jcod\n+ * @compile\/fail\/ref=CheckFieldTypeTest.out -XDrawDiagnostics CheckFieldTypeTest.java\n+ *\/\n+\n+public class CheckFieldTypeTest {\n+    void m() {\n+        NullRestrictedOnPrimitive v = new NullRestrictedOnPrimitive();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFieldTypeTest.java:13:9: compiler.err.cant.access: NullRestrictedOnPrimitive, (compiler.misc.bad.class.file.header: NullRestrictedOnPrimitive.class, (compiler.misc.attribute.not.applicable.to.field.type: NullRestricted, int))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile NullRestrictedOnArray.jcod\n+ * @compile\/fail\/ref=CheckFieldTypeTest2.out -XDrawDiagnostics CheckFieldTypeTest2.java\n+ *\/\n+\n+public class CheckFieldTypeTest2 {\n+    void m() {\n+        NullRestrictedOnArray v = new NullRestrictedOnArray();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest2.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFieldTypeTest2.java:13:9: compiler.err.cant.access: NullRestrictedOnArray, (compiler.misc.bad.class.file.header: NullRestrictedOnArray.class, (compiler.misc.attribute.not.applicable.to.field.type: NullRestricted, java.lang.String[]))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class NullRestrictedOnArray {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnArray\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"arr\"; \/\/ #5\n+    Utf8 \"[Ljava\/lang\/String;\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LNullRestrictedOnArray;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"NullRestrictedOnArray.java\"; \/\/ #12\n+    Utf8 \"ImplicitCreation\"; \/\/ #13\n+    Utf8 \"NullRestricted\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnArray\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/NullRestrictedOnArray.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class NullRestrictedOnPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnPrimitive\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LNullRestrictedOnPrimitive;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"NullRestrictedOnPrimitive.java\"; \/\/ #12\n+    Utf8 \"ImplicitCreation\"; \/\/ #13\n+    Utf8 \"NullRestricted\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                4  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnPrimitive\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/NullRestrictedOnPrimitive.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile NullRestrictedOnMethod.jcod\n+ * @compile\/fail\/ref=NullRestrictedAttrOnlyOnFields.out -XDrawDiagnostics NullRestrictedAttrOnlyOnFields.java\n+ *\/\n+\n+public class NullRestrictedAttrOnlyOnFields {\n+    void m() {\n+        NullRestrictedOnMethod v = new NullRestrictedOnMethod();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedAttrOnlyOnFields.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+NullRestrictedAttrOnlyOnFields.java:13:9: compiler.err.cant.access: NullRestrictedOnMethod, (compiler.misc.bad.class.file.header: NullRestrictedOnMethod.class, (compiler.misc.attribute.only.applicable.to.fields: NullRestricted))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedAttrOnlyOnFields.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+class NullRestrictedOnMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"NullRestrictedOnMethod\"; \/\/ #2     at 0x0D\n+    class #4; \/\/ #3     at 0x26\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x29\n+    Utf8 \"field\"; \/\/ #5     at 0x3C\n+    Utf8 \"LValueClass2;\"; \/\/ #6     at 0x44\n+    Utf8 \"NullRestricted\"; \/\/ #7     at 0x54\n+    Utf8 \"foo\"; \/\/ #8     at 0x65\n+    Utf8 \"()V\"; \/\/ #9     at 0x6B\n+    Utf8 \"Code\"; \/\/ #10     at 0x71\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x78\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x8A\n+    Utf8 \"()LNullRestrictedOnMethod;\"; \/\/ #13     at 0x93\n+    Utf8 \"SourceFile\"; \/\/ #14     at 0xB0\n+    Utf8 \"NullRestrictedOnMethod.java\"; \/\/ #15     at 0xBD\n+    Utf8 \"ImplicitCreation\"; \/\/ #16     at 0xDB\n+    Utf8 \"Preload\"; \/\/ #17     at 0xEE\n+    class #19; \/\/ #18     at 0xF8\n+    Utf8 \"ValueClass2\"; \/\/ #19     at 0xFB\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x0113\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : field\n+      #6; \/\/ descriptor_index : LValueClass2;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0123\n+      0x0000; \/\/ access\n+      #8; \/\/ name_index       : foo\n+      #9; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 25) { \/\/ Code at 0x012B\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[1]{\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0x013E\n+              [1] { \/\/ line_number_table\n+                0  9; \/\/  at 0x014A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x014A\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : <vnew>\n+      #13; \/\/ descriptor_index : ()LNullRestrictedOnMethod;\n+      [2] { \/\/ Attributes\n+        Attr(#10, 34) { \/\/ Code at 0x0152\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[6]{\n+            0xCB00014B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x016A\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x0176\n+                4  2; \/\/  at 0x017A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#7, 0) { \/\/ NullRestricted at 0x011B\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#14, 2) { \/\/ SourceFile at 0x017C\n+      #15;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#16, 2) { \/\/ ImplicitCreation at 0x0184\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#17, 4) { \/\/ Preload at 0x018C\n+      0x00010012;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnMethod\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedOnMethod.jcod","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [12] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueClass2\"; \/\/ #2     at 0x0D\n+    class #4; \/\/ #3     at 0x1B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x1E\n+    Utf8 \"<vnew>\"; \/\/ #5     at 0x31\n+    Utf8 \"()LValueClass2;\"; \/\/ #6     at 0x3A\n+    Utf8 \"Code\"; \/\/ #7     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #8     at 0x53\n+    Utf8 \"SourceFile\"; \/\/ #9     at 0x65\n+    Utf8 \"NullRestrictedOnMethod.java\"; \/\/ #10     at 0x72\n+    Utf8 \"ImplicitCreation\"; \/\/ #11     at 0x90\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xAF\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index       : <vnew>\n+      #6; \/\/ descriptor_index : ()LValueClass2;\n+      [1] { \/\/ Attributes\n+        Attr(#7, 34) { \/\/ Code at 0xB7\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[6]{\n+            0xCB00014B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#8, 10) { \/\/ LineNumberTable at 0xCF\n+              [2] { \/\/ line_number_table\n+                0  2; \/\/  at 0xDB\n+                4  1; \/\/  at 0xDF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#9, 2) { \/\/ SourceFile at 0xE1\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11, 2) { \/\/ ImplicitCreation at 0xE9\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass2\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/ValueClass2.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @ignore\n+ * @compile ValueClass.jcod NullRestrictedOnValueClass.jcod\n+ * @compile\/fail\/ref=NullRestrictedAttrOnValueClassNoImplicitConst.out -XDrawDiagnostics NullRestrictedAttrOnValueClassNoImplicitConst.java\n+ *\/\n+\n+ \/* testing if a value class has an implicit constructor or not would imply loading the class if it is not loaded, this could provoke\n+  * altering the class loading order, not sure if this is worthy. Basically the assertion in the JVMS is:\n+  * `The descriptor_index of the field should name a value class that has an ImplicitCreation attribute with its ACC_DEFAULT flag is set`\n+  *\/\n+public class NullRestrictedAttrOnValueClassNoImplicitConst {\n+    void m() {\n+        NullRestrictedOnValueClass v = new NullRestrictedOnValueClass();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedAttrOnValueClassNoImplicitConst.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedAttrOnValueClassNoImplicitConst.out","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/langtools\/test\/TEST.ROOT","status":"copied"},{"patch":"@@ -0,0 +1,85 @@\n+class NullRestrictedOnValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"field\"; \/\/ #5\n+    Utf8 \"LValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LNullRestrictedOnValueClass;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"NullRestrictedOnValueClass.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+    Utf8 \"Preload\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"ValueClass\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+                4  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#15) { \/\/ Preload\n+      0x00010010;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedOnValueClass.jcod","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"NullRestrictedOnValueClass.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/ValueClass.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8314165\n+ * @summary check for illegal circularity at class loading time\n+ * @build CyclicValueClass\n+ * @compile\/fail\/ref=CheckForCyclesAtClassLoadingTimeTest.out -XDrawDiagnostics CheckForCyclesAtClassLoadingTimeTest.java\n+ *\/\n+class CheckForCyclesAtClassLoadingTimeTest {\n+    CyclicValueClass cyclicValueClass;\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CyclicValueClass.class:-:-: compiler.err.cyclic.primitive.class.membership: CyclicValueClass\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class CyclicValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"CyclicValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"cyclicField\"; \/\/ #5\n+    Utf8 \"LCyclicValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LCyclicValueClass;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"CyclicValueClass.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class CyclicValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CyclicValueClass.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}