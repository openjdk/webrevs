{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -269,16 +268,2 @@\n-        String s = getName();\n-        if (isPrimitive()) {\n-            return s;\n-        }\n-        \/\/ Avoid invokedynamic based String concat, might be not available\n-        \/\/ Prepend type of class\n-        s = (isInterface() ? \"interface \" : \"class \").concat(s);\n-        if (isValue()) {\n-            \/\/ prepend value class type\n-            s = (isPrimitiveClass() ? \"primitive \" : \"value \").concat(s);\n-            if (isPrimitiveClass() && isPrimaryType()) {\n-                \/\/ Append .ref\n-                s = s.concat(\".ref\");\n-            }\n-        }\n-        return s;\n+        String kind = isInterface() ? \"interface \" : isPrimitive() ? \"\" : \"class \";\n+        return kind.concat(getName());\n@@ -348,1 +333,1 @@\n-                    sb.append(isPrimitiveClass() ? \"primitive \" : \"value \");\n+                    sb.append(\"value \");\n@@ -656,28 +641,0 @@\n-    \/\/ set by VM if this class is an exotic type such as primitive class\n-    \/\/ otherwise, these two fields are null\n-    private transient Class<T> primaryType;\n-    private transient Class<T> secondaryType;\n-\n-    \/**\n-     * Returns {@code true} if this class is a primitive class.\n-     * <p>\n-     * Each primitive class has a {@linkplain #isPrimaryType() primary type}\n-     * representing the <em>primitive reference type<\/em> and a\n-     * {@linkplain #isPrimitiveValueType() secondary type} representing\n-     * the <em>primitive value type<\/em>.  The primitive reference type\n-     * and primitive value type can be obtained by calling the\n-     * {@link #asPrimaryType()} and {@link #asValueType} method\n-     * of a primitive class respectively.\n-     * <p>\n-     * A primitive class is a {@linkplain #isValue() value class}.\n-     *\n-     * @return {@code true} if this class is a primitive class, otherwise {@code false}\n-     * @see #isValue()\n-     * @see #asPrimaryType()\n-     * @see #asValueType()\n-     * @since Valhalla\n-     *\/\n-    \/* package *\/ boolean isPrimitiveClass() {\n-        return (this.getModifiers() & PrimitiveClass.PRIMITIVE_CLASS) != 0;\n-    }\n-\n@@ -700,1 +657,1 @@\n-     * class or interface; otherwise {@code false}}\n+     * class; otherwise {@code false}}\n@@ -702,2 +659,2 @@\n-     * If this {@code Class} object represents an array type, a primitive type, or\n-     * {@code void}, then this method returns {@code false}.\n+     * If this {@code Class} object represents an array type, an interface,\n+     * a primitive type, or {@code void}, then this method returns {@code false}.\n@@ -709,45 +666,3 @@\n-        return (this.getModifiers() & Modifier.VALUE) != 0;\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the primary type\n-     * of this class or interface.\n-     * <p>\n-     * If this {@code Class} object represents a primitive type or an array type,\n-     * then this method returns this class.\n-     * <p>\n-     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n-     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n-     * type of this primitive class.\n-     * <p>\n-     * Otherwise, this {@code Class} object represents a non-primitive class or interface\n-     * and this method returns this class.\n-     *\n-     * @return the {@code Class} representing the primary type of\n-     *         this class or interface\n-     * @since Valhalla\n-     *\/\n-    @IntrinsicCandidate\n-    \/* package *\/ Class<?> asPrimaryType() {\n-        return isPrimitiveClass() ? primaryType : this;\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n-     * of this class if this class is a {@linkplain #isPrimitiveClass() primitive class}.\n-     *\n-     * @apiNote Alternatively, this method returns null if this class is not\n-     *          a primitive class rather than throwing UOE.\n-     *\n-     * @return the {@code Class} representing the {@linkplain #isPrimitiveValueType()\n-     * primitive value type} of this class if this class is a primitive class\n-     * @throws UnsupportedOperationException if this class or interface\n-     *         is not a primitive class\n-     * @since Valhalla\n-     *\/\n-    @IntrinsicCandidate\n-    \/* package *\/ Class<?> asValueType() {\n-        if (isPrimitiveClass())\n-            return secondaryType;\n-\n-        throw new UnsupportedOperationException(this.getName().concat(\" is not a primitive class\"));\n+         if (isPrimitive() || isArray() || isInterface())\n+             return false;\n+        return ((getModifiers() & Modifier.IDENTITY) == 0);\n@@ -768,38 +683,0 @@\n-    \/**\n-     * Returns {@code true} if this {@code Class} object represents the primary type\n-     * of this class or interface.\n-     * <p>\n-     * If this {@code Class} object represents a primitive type or an array type,\n-     * then this method returns {@code true}.\n-     * <p>\n-     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n-     * primitive}, then this method returns {@code true} if this {@code Class}\n-     * object represents a primitive reference type, or returns {@code false}\n-     * if this {@code Class} object represents a primitive value type.\n-     * <p>\n-     * If this {@code Class} object represents a non-primitive class or interface,\n-     * then this method returns {@code true}.\n-     *\n-     * @return {@code true} if this {@code Class} object represents\n-     * the primary type of this class or interface\n-     * @since Valhalla\n-     *\/\n-    \/* package *\/ boolean isPrimaryType() {\n-        if (isPrimitiveClass()) {\n-            return this == primaryType;\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@code Class} object represents\n-     * a {@linkplain #isPrimitiveClass() primitive} value type.\n-     *\n-     * @return {@code true} if this {@code Class} object represents\n-     * the value type of a primitive class\n-     * @since Valhalla\n-     *\/\n-    \/* package *\/ boolean isPrimitiveValueType() {\n-        return isPrimitiveClass() && this == secondaryType;\n-    }\n-\n@@ -1799,3 +1676,0 @@\n-        boolean isValueFactoryMethod() { return !isPartial() && ConstantDescs.VNEW_NAME.equals(name); }\n-\n-                                        && !isValueFactoryMethod()\n@@ -1860,1 +1734,1 @@\n-            if (!enclosingInfo.isObjectConstructor() && !enclosingInfo.isValueFactoryMethod())\n+            if (!enclosingInfo.isObjectConstructor())\n@@ -2043,1 +1917,1 @@\n-                return cl.getTypeName().concat(\"[]\".repeat(dimensions));\n+                return cl.getName().concat(\"[]\".repeat(dimensions));\n@@ -2046,6 +1920,1 @@\n-        if (isPrimitiveClass()) {\n-            \/\/ TODO: null-default\n-            return isPrimaryType() ? getName().concat(\".ref\") : getName();\n-        } else {\n-            return getName();\n-        }\n+        return getName();\n@@ -3991,1 +3860,1 @@\n-        throw new NoSuchMethodException(methodToString(isValue() ? \"<vnew>\" : \"<init>\", parameterTypes));\n+        throw new NoSuchMethodException(methodToString(\"<init>\", parameterTypes));\n@@ -4296,3 +4165,0 @@\n-        if (isPrimitiveValueType() && obj == null)\n-            throw new NullPointerException(getName() + \" is a primitive value type\");\n-\n@@ -4805,1 +4671,0 @@\n-        char typeDesc = isPrimitiveValueType() ? 'Q' : 'L';\n@@ -4810,1 +4675,1 @@\n-                    .append(typeDesc)\n+                    .append('L')\n@@ -4819,1 +4684,1 @@\n-                    .append(typeDesc)\n+                    .append('L')\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":16,"deletions":151,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n@@ -88,6 +87,0 @@\n-    \/**\n-     * The modifier {@code identity}\n-     * @since 18\n-     *\/\n-    IDENTITY,\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -102,7 +102,0 @@\n-    \/** Marks a type as a primitive class. We can't reuse the class file encoding (ACC_PRIMITIVE)\n-     * since the latter shares its value (0x800) with ACC_STRICT (javac speak: STRICT_FP) and while\n-     * STRICT_FP is not a valid flag for a class in the class file level, javac's ASTs flag a class\n-     * as being STRICT_FP so as to propagate the FP strictness to methods of the class thereby causing\n-     * a clash *\/\n-    public static final int PRIMITIVE_CLASS  = 1<<16;\n-\n@@ -115,1 +108,0 @@\n-    public static final int ACC_DEFAULT    = 0x0001;\n@@ -117,6 +109,5 @@\n-    public static final int ACC_IDENTITY   = 0x0020;\n-    public static final int ACC_VALUE      = 0x0040;\n-    public static final int ACC_BRIDGE     = 0x0040;\n-    public static final int ACC_VARARGS    = 0x0080;\n-    public static final int ACC_PRIMITIVE  = 0x0800;\n-    public static final int ACC_MODULE     = 0x8000;\n+    public static final int ACC_IDENTITY = 0x0020;\n+    public static final int ACC_BRIDGE   = 0x0040;\n+    public static final int ACC_VARARGS  = 0x0080;\n+    public static final int ACC_STRICT   = 0x0800;\n+    public static final int ACC_MODULE   = 0x8000;\n@@ -137,17 +128,3 @@\n-    \/** Flag is set for a class symbol if it defines one or more non-empty\n-     *  instance initializer block(s). This is relevenat only for class symbols\n-     *  that originate from source types. For binary types the instance initializer\n-     *  blocks are \"normalized\" into the constructors.\n-     *\/\n-    public static final int HASINITBLOCK         = 1<<18;\n-\n-    \/** Flag is set for a method symbol if it is an empty no-arg ctor.\n-     *  i.e. one that simply returns (jlO) or merely chains to a super's\n-     *  no-arg ctor\n-     *\/\n-    public static final int EMPTYNOARGCONSTR         = 1<<18;\n-\n-     * i.e. class\/interface declarations that are expressly declared with\n-     * the modifier `identity' or (b) any concrete class not declared with the\n-     * modifier `value' (c) abstract class not declared `value' but meets various\n-     * stipulations (d) older class files with ACC_SUPER bit set\n+     * i.e. any concrete class not declared with the modifier `value'\n+     * (a) abstract class not declared `value'\n+     * (b) older class files with ACC_SUPER bit set\n@@ -437,0 +414,5 @@\n+    \/**\n+     * Flag to indicate that a field is strict\n+     *\/\n+    public static final long STRICT = 1L<<51; \/\/ VarSymbols\n+\n@@ -456,1 +438,1 @@\n-        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | ACC_IDENTITY,\n+        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | IDENTITY_TYPE,\n@@ -470,2 +452,1 @@\n-                                            SYNCHRONIZED | FINAL | STRICTFP,\n-        AdjustedClassFlags                = ClassFlags | ACC_VALUE;\n+                                            SYNCHRONIZED | FINAL | STRICTFP;\n@@ -479,0 +460,1 @@\n+        ExtendedVarFlags                  = (long) VarFlags | STRICT,\n@@ -506,1 +488,0 @@\n-            if (0 != (flags & IDENTITY_TYPE))   modifiers.add(Modifier.IDENTITY);\n@@ -529,1 +510,0 @@\n-\n@@ -549,2 +529,0 @@\n-        HASINITBLOCK(Flags.HASINITBLOCK),\n-        EMPTYNOARGCONSTR(Flags.EMPTYNOARGCONSTR),\n@@ -557,0 +535,1 @@\n+        VALUE(Flags.VALUE_CLASS),\n@@ -559,2 +538,0 @@\n-        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n-        VALUE(Flags.VALUE_CLASS),\n@@ -611,1 +588,2 @@\n-        };\n+        },\n+        STRICT(Flags.STRICT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":19,"deletions":41,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-        if (isInit() && owner.hasOuterInstance()) {\n+        if (name == name.table.names.init && owner.hasOuterInstance()) {\n@@ -426,5 +426,1 @@\n-        return !isInterface() && (flags_field & VALUE_CLASS) != 0;\n-    }\n-\n-    public boolean isConcreteValueClass() {\n-        return isValueClass() && !isAbstract();\n+        return (flags_field & VALUE_CLASS) != 0;\n@@ -437,8 +433,0 @@\n-    public boolean isValueInterface() {\n-        return isInterface() && (flags_field & VALUE_CLASS) != 0;\n-    }\n-\n-    public boolean isIdentityInterface() {\n-        return isInterface() && (flags_field & IDENTITY_TYPE) != 0;\n-    }\n-\n@@ -486,7 +474,1 @@\n-        return name == name.table.names.init && (flags() & STATIC) == 0;\n-    }\n-\n-    \/** Is this symbol a value object factory?\n-     *\/\n-    public boolean isValueClassConst() {\n-        return name == name.table.names.init && this.owner.isValueClass();\n+        return name == name.table.names.init;\n@@ -498,7 +480,1 @@\n-        return isInit() && ((flags() & IMPLICIT) != 0);\n-    }\n-\n-    \/** Is this symbol a constructor or value factory?\n-     *\/\n-    public boolean isInit() {\n-        return name.table.names.isInit(name);\n+        return isConstructor() && ((flags() & IMPLICIT) != 0);\n@@ -1717,1 +1693,1 @@\n-                        if (s.isInit()) {\n+                        if (s.isConstructor()) {\n@@ -2051,1 +2027,1 @@\n-                String s = isInit()\n+                String s = (name == name.table.names.init)\n@@ -2113,1 +2089,1 @@\n-            if (isInit() || _other.kind != MTH) return false;\n+            if (isConstructor() || _other.kind != MTH) return false;\n@@ -2182,1 +2158,1 @@\n-            if (isInit() || _other.kind != MTH) return false;\n+            if (isConstructor() || _other.kind != MTH) return false;\n@@ -2306,1 +2282,1 @@\n-            if (isInit())\n+            if (name == name.table.names.init)\n@@ -2494,1 +2470,1 @@\n-                if (refSym.isInit()) {\n+                if (refSym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":10,"deletions":34,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-                Type arg;\n+                Type arg = null;\n@@ -690,0 +690,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Optional;\n@@ -238,8 +239,0 @@\n-    public boolean hasImplicitConstructor() {\n-        return false;\n-    }\n-\n-    public boolean isValueInterface() {\n-        return false;\n-    }\n-\n@@ -250,1 +243,1 @@\n-    public boolean isIdentityInterface() {\n+    public boolean hasImplicitConstructor() {\n@@ -1051,34 +1044,0 @@\n-    public static class ConstantPoolQType implements PoolConstant {\n-\n-        public final Type type;\n-        final Types types;\n-\n-        public ConstantPoolQType(Type type, Types types) {\n-            this.type = type;\n-            this.types = types;\n-        }\n-\n-        @Override\n-        public Object poolKey(Types types) {\n-            return this;\n-        }\n-\n-        @Override\n-        public int poolTag() {\n-            return ClassFile.CONSTANT_Class;\n-        }\n-\n-        public int hashCode() {\n-            return types.hashCode(type);\n-        }\n-\n-        public boolean equals(Object obj) {\n-            return (obj instanceof ConstantPoolQType) &&\n-                    types.isSameType(type, ((ConstantPoolQType)obj).type);\n-        }\n-\n-        public String toString() {\n-            return type.toString();\n-        }\n-    }\n-\n@@ -1087,0 +1046,1 @@\n+\n@@ -1115,4 +1075,0 @@\n-        \/*\n-         * Use of this constructor is kinda sorta deprecated, use the other constructor\n-         * that forces the call site to consider and include the class type flavor.\n-         *\/\n@@ -1278,0 +1234,5 @@\n+        @Override\n+        public boolean hasImplicitConstructor() {\n+            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).hasImplicitConstructor();\n+        }\n+\n@@ -1288,10 +1249,0 @@\n-        @Override\n-        public boolean hasImplicitConstructor() {\n-            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).hasImplicitConstructor();\n-        }\n-\n-        @Override\n-        public boolean isValueInterface() {\n-            return tsym != null && tsym.isValueInterface();\n-        }\n-\n@@ -1303,5 +1254,0 @@\n-        @Override\n-        public boolean isIdentityInterface() {\n-            return isInterface() && tsym.isIdentityInterface();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":8,"deletions":62,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -103,2 +103,0 @@\n-    private boolean emitQDesc;\n-\n@@ -133,1 +131,0 @@\n-        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -614,1 +611,0 @@\n-\n@@ -777,4 +773,2 @@\n-            }\n-            FunctionDescriptor descRes;\n-            if (abstracts.size() == 1) {\n-                descRes = new FunctionDescriptor(abstracts.first());\n+            } else if (abstracts.size() == 1) {\n+                return new FunctionDescriptor(abstracts.first());\n@@ -782,1 +776,1 @@\n-                descRes = mergeDescriptors(origin, abstracts.toList());\n+                FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());\n@@ -801,0 +795,1 @@\n+                return descRes;\n@@ -802,11 +797,0 @@\n-            \/\/ an interface must be neither an identity interface nor a value interface to be functional.\n-            List<Type> allInterfaces = closure(origin.type);\n-            for (Type iface : allInterfaces) {\n-                if (iface.isValueInterface()) {\n-                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.ValueInterfaceNonfunctional));\n-                }\n-                if (iface.isIdentityInterface()) {\n-                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.IdentityInterfaceNonfunctional));\n-                }\n-            }\n-            return descRes;\n@@ -981,1 +965,1 @@\n-                        !names.isInit(t.name) &&\n+                        t.name != names.init &&\n@@ -1048,5 +1032,15 @@\n-            try {\n-                warnStack = warnStack.prepend(warn);\n-                if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n-                    if (((ArrayType)t).elemtype.isPrimitive()) {\n-                        return isSameType(elemtype(t), elemtype(s));\n+            if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n+                if (((ArrayType)t).elemtype.isPrimitive()) {\n+                    return isSameType(elemtype(t), elemtype(s));\n+                } else {\n+                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                }\n+            } else if (isSubtype(t, s, capture)) {\n+                return true;\n+            } else if (t.hasTag(TYPEVAR)) {\n+                return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n+            } else if (!s.isRaw()) {\n+                Type t2 = asSuper(t, s.tsym);\n+                if (t2 != null && t2.isRaw()) {\n+                    if (isReifiable(s)) {\n+                        warn.silentWarn(LintCategory.UNCHECKED);\n@@ -1054,6 +1048,1 @@\n-                        \/\/ if T.ref <: S, then T[] <: S[]\n-                        Type es = elemtype(s);\n-                        Type et = elemtype(t);\n-                        if (!isSubtypeUncheckedInternal(et, es, false, warn))\n-                            return false;\n-                        return true;\n+                        warn.warn(LintCategory.UNCHECKED);\n@@ -1061,16 +1050,1 @@\n-                } else if (isSubtype(t, s, capture)) {\n-                } else if (t.hasTag(TYPEVAR)) {\n-                    return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n-                } else if (!s.isRaw()) {\n-                    Type t2 = asSuper(t, s.tsym);\n-                    if (t2 != null && t2.isRaw()) {\n-                        if (isReifiable(s)) {\n-                            warn.silentWarn(LintCategory.UNCHECKED);\n-                        } else {\n-                            warn.warn(LintCategory.UNCHECKED);\n-                        }\n-                        return true;\n-                    }\n-                return false;\n-            } finally {\n-                warnStack = warnStack.tail;\n+            return false;\n@@ -1249,6 +1223,2 @@\n-                    else {\n-                        \/\/ if T.ref <: S, then T[] <: S[]\n-                        Type es = elemtype(s);\n-                        Type et = elemtype(t);\n-                        return isSubtypeNoCapture(et, es);\n-                    }\n+                    else\n+                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n@@ -1686,9 +1656,0 @@\n-\n-                    \/\/ -----------------------------------  Unspecified behavior ----------------\n-\n-                    \/* If a primitive class V implements an interface I, then does \"? extends I\" contain V?\n-                       It seems widening must be applied here to answer yes to compile some common code\n-                       patterns.\n-                    *\/\n-\n-                    \/\/ ---------------------------------------------------------------------------\n@@ -2580,1 +2541,1 @@\n-                    erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n+                    erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,\n@@ -3845,1 +3806,1 @@\n-     * (that is, subclasses come first, arbitrary but fixed\n+     * (that is, subclasses come first, arbitrarily but fixed\n@@ -4416,6 +4377,4 @@\n-        try {\n-            warnStack = warnStack.prepend(warner);\n-            if (isSameType(r1.getReturnType(), r2res))\n-                return true;\n-            if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n-                return false;\n+        if (isSameType(r1.getReturnType(), r2res))\n+            return true;\n+        if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())\n+            return false;\n@@ -4423,7 +4382,3 @@\n-            if (hasSameArgs(r1, r2))\n-                return covariantReturnType(r1.getReturnType(), r2res, warner);\n-            if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n-                return true;\n-            if (!isSubtype(r1.getReturnType(), erasure(r2res), false))\n-                return false;\n-            warner.warn(LintCategory.UNCHECKED);\n+        if (hasSameArgs(r1, r2))\n+            return covariantReturnType(r1.getReturnType(), r2res, warner);\n+        if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))\n@@ -4431,3 +4386,4 @@\n-        } finally {\n-            warnStack = warnStack.tail;\n-        }\n+        if (!isSubtype(r1.getReturnType(), erasure(r2res)))\n+            return false;\n+        warner.warn(LintCategory.UNCHECKED);\n+        return true;\n@@ -5275,4 +5231,1 @@\n-                    if (types.emitQDesc && type.hasImplicitConstructor() && type.isNonNullable())\n-                        append('Q');\n-                    else\n-                        append('L');\n+                    append('L');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":38,"deletions":85,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    \/** Switch: allow primitive classes ?\n+    \/** Switch: allow value classes ?\n@@ -286,1 +286,1 @@\n-            ((names.isInit(owner.name) ||    \/\/ i.e. we are in a constructor\n+            ((owner.name == names.init ||    \/\/ i.e. we are in a constructor\n@@ -818,1 +818,1 @@\n-                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env)));\n+                List<Type> bounds = List.of(attribType(tvar.bounds.head, env));\n@@ -820,1 +820,1 @@\n-                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env)));\n+                    bounds = bounds.prepend(attribType(bound, env));\n@@ -956,0 +956,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -978,3 +980,2 @@\n-                \/\/ If this class appears as an anonymous class\n-                \/\/ in a superclass constructor call\n-                \/\/ disable implicit outer instance from being passed.\n+                \/\/ If this class appears as an anonymous class in a constructor\n+                \/\/ prologue, disable implicit outer instance from being passed.\n@@ -982,2 +983,1 @@\n-                if (env.info.isSelfCall &&\n-                        env.tree.hasTag(NEWCLASS)) {\n+                if (ctorProloguePrev && env.tree.hasTag(NEWCLASS)) {\n@@ -991,0 +991,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -1000,0 +1001,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -1063,0 +1066,3 @@\n+            \/\/ Is this method a constructor?\n+            boolean isConstructor = TreeInfo.isConstructor(tree);\n+\n@@ -1090,1 +1096,1 @@\n-                if (names.isInit(tree.name)) {\n+                if (isConstructor) {\n@@ -1093,5 +1099,2 @@\n-                        JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                        if (app == null ||\n-                                TreeInfo.name(app.meth) != names._this ||\n-                                !checkFirstConstructorStat(app, tree, false)) {\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n+                        if (!TreeInfo.hasConstructorCall(tree, names._this)) {\n+                            log.error(tree, Errors.NonCanonicalConstructorInvokeAnotherConstructor(env.enclClass.sym));\n@@ -1123,5 +1126,1 @@\n-                            JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                            if (app != null &&\n-                                    (TreeInfo.name(app.meth) == names._this ||\n-                                            TreeInfo.name(app.meth) == names._super) &&\n-                                    checkFirstConstructorStat(app, tree, false)) {\n+                            if (TreeInfo.hasAnyConstructorCall(tree)) {\n@@ -1213,5 +1212,3 @@\n-                if (names.isInit(tree.name) && owner.type != syms.objectType) {\n-                    JCBlock body = tree.body;\n-                    if (body.stats.isEmpty() ||\n-                            TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {\n-                        JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),\n+                if (isConstructor && owner.type != syms.objectType) {\n+                    if (!TreeInfo.hasAnyConstructorCall(tree)) {\n+                        JCStatement supCall = make.at(tree.body.pos).Exec(make.Apply(List.nil(),\n@@ -1219,1 +1216,5 @@\n-                        body.stats = body.stats.prepend(supCall);\n+                        if (owner.isValueClass()) {\n+                            tree.body.stats = tree.body.stats.append(supCall);\n+                        } else {\n+                            tree.body.stats = tree.body.stats.prepend(supCall);\n+                        }\n@@ -1222,1 +1223,1 @@\n-                            TreeInfo.isSuperCall(body.stats.head)) {\n+                            TreeInfo.hasConstructorCall(tree, names._super)) {\n@@ -1229,6 +1230,0 @@\n-                    } else if ((env.enclClass.sym.flags() & VALUE_CLASS) != 0 &&\n-                        (tree.mods.flags & GENERATEDCONSTR) == 0 &&\n-                        TreeInfo.isSuperCall(body.stats.head)) {\n-                        \/\/ value constructors are not allowed to call super directly,\n-                        \/\/ but tolerate compiler generated ones, these are ignored during code generation\n-                        log.error(tree.body.stats.head.pos(), Errors.CallToSuperNotAllowedInValueCtor);\n@@ -1258,0 +1253,3 @@\n+                \/\/ Start of constructor prologue\n+                localEnv.info.ctorPrologue = isConstructor;\n+\n@@ -1267,0 +1265,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -1322,4 +1321,1 @@\n-            \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n-               as these can undergo updates via copy on write.\n-            *\/\n-                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && v.owner.isValueClass()) ||\n+                if ((v.flags_field & FINAL) == 0 ||\n@@ -2568,7 +2564,0 @@\n-            \/\/ We are seeing a ...this(...) or ...super(...) call.\n-            \/\/ Check that this is the first statement in a constructor.\n-            checkFirstConstructorStat(tree, env.enclMethod, true);\n-\n-            \/\/ Record the fact\n-            \/\/ that this is a constructor call (using isSelfCall).\n-            localEnv.info.isSelfCall = true;\n@@ -2577,2 +2566,0 @@\n-            localEnv.info.constructorArgs = true;\n-            localEnv.info.constructorArgs = false;\n@@ -2583,0 +2570,3 @@\n+            \/\/ Done with this()\/super() parameters. End of constructor prologue.\n+            env.info.ctorPrologue = false;\n+\n@@ -2693,4 +2683,1 @@\n-                \/\/ Special treatment for primitive classes: Given an expression v of type V where\n-                \/\/ V is a primitive class, v.getClass() is typed to be Class<? extends |V.ref|>\n-                Type wcb = types.erasure(qualifierType.baseType());\n-                        List.of(new WildcardType(wcb,\n+                        List.of(new WildcardType(types.erasure(qualifierType.baseType()),\n@@ -2714,20 +2701,0 @@\n-        \/** Check that given application node appears as first statement\n-         *  in a constructor call.\n-         *  @param tree          The application node\n-         *  @param enclMethod    The enclosing method of the application.\n-         *  @param error         Should an error be issued?\n-         *\/\n-        boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {\n-            if (enclMethod != null && names.isInit(enclMethod.name)) {\n-                JCBlock body = enclMethod.body;\n-                if (body.stats.head.hasTag(EXEC) &&\n-                    ((JCExpressionStatement) body.stats.head).expr == tree)\n-                    return true;\n-            }\n-            if (error) {\n-                log.error(tree.pos(),\n-                        Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));\n-            }\n-            return false;\n-        }\n-\n@@ -3676,1 +3643,0 @@\n-            Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3683,0 +3649,1 @@\n+                Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3766,1 +3733,1 @@\n-            that.sym = refSym.isInit() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;\n@@ -4410,10 +4377,0 @@\n-        \/\/ In a constructor body,\n-        \/\/ if symbol is a field or instance method, check that it is\n-        \/\/ not accessed before the supertype constructor is called.\n-        if (symEnv.info.isSelfCall &&\n-            sym.kind.matches(KindSelector.VAL_MTH) &&\n-            sym.owner.kind == TYP &&\n-            (sym.flags() & STATIC) == 0) {\n-            chk.earlyRefError(tree.pos(), sym.kind == VAR ?\n-                                          sym : thisSym(tree.pos(), env));\n-        }\n@@ -4477,1 +4434,1 @@\n-                return;\n+                return ;\n@@ -4541,12 +4498,1 @@\n-            if (sym.name == names._this || sym.name == names._super) {\n-                \/\/ If `C' is the currently compiled class, check that\n-                \/\/ `C.this' does not appear in an explicit call to a constructor\n-                \/\/ also make sure that `super` is not used in constructor invocations\n-                if (env.info.isSelfCall &&\n-                        ((sym.name == names._this &&\n-                        site.tsym == env.enclClass.sym) ||\n-                        sym.name == names._super && env.info.constructorArgs &&\n-                        (sitesym.isInterface() || site.tsym == env.enclClass.sym))) {\n-                    chk.earlyRefError(tree.pos(), sym);\n-                }\n-            } else {\n+            if (sym.name != names._this && sym.name != names._super) {\n@@ -4727,1 +4673,1 @@\n-                \/\/ except for three situations:\n+                \/\/ except for two situations:\n@@ -4733,1 +4679,1 @@\n-                    \/\/ If the symbol's type is parameterized, erase it\n+                    \/\/ (a) If the symbol's type is parameterized, erase it\n@@ -4740,1 +4686,1 @@\n-                    \/\/ (c) If the symbol's type is an inner class, then\n+                    \/\/ (b) If the symbol's type is an inner class, then\n@@ -4829,1 +4775,1 @@\n-            if (!names.isInit(sym.name) || tree.hasTag(REFERENCE)) {\n+            if (sym.name != names.init || tree.hasTag(REFERENCE)) {\n@@ -5083,31 +5029,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        if (!allowValueClasses) {\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                    Feature.VALUE_CLASSES.error(sourceName));\n-        }\n-\n-        \/\/ Attribute the qualifier expression, and determine its symbol (if any).\n-        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n-        if (!pkind().contains(KindSelector.TYP_PCK))\n-            site = capture(site); \/\/ Capture field access\n-        if (!allowValueClasses) {\n-            result = types.createErrorType(names._default, site.tsym, site);\n-        } else {\n-            Symbol sym = switch (site.getTag()) {\n-                case WILDCARD -> throw new AssertionError(tree);\n-                case PACKAGE -> {\n-                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                    yield syms.errSymbol;\n-                }\n-                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n-            };\n-\n-            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-                site = types.skipTypeVars(site, true);\n-            }\n-            result = checkId(tree, site, sym, env, resultInfo);\n-        }\n-    }\n-\n@@ -5788,0 +5703,3 @@\n+        \/\/ Check for proper placement of super()\/this() calls.\n+        chk.checkSuperInitCalls(tree);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":48,"deletions":130,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Consumer;\n@@ -82,0 +83,1 @@\n+import javax.lang.model.element.ExecutableElement;\n@@ -84,0 +86,2 @@\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n@@ -378,9 +382,0 @@\n-    \/** Report an error that symbol cannot be referenced before super\n-     *  has been called.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param sym        The referenced symbol.\n-     *\/\n-    void earlyRefError(DiagnosticPosition pos, Symbol sym) {\n-        log.error(pos, Errors.CantRefBeforeCtorCalled(sym));\n-    }\n-\n@@ -815,15 +810,1 @@\n-            Fragment fragment = c.isAbstract() && c.isValueClass() && c == st.tsym ? Fragments.AbstractValueClass(c) : Fragments.SuperclassOfValueClass(c, st);\n-            if ((st.tsym.flags() & HASINITBLOCK) != 0) {\n-                log.error(pos, Errors.AbstractValueClassDeclaresInitBlock(fragment));\n-            }\n-            Type encl = st.getEnclosingType();\n-            if (encl != null && encl.hasTag(CLASS)) {\n-                log.error(pos, Errors.AbstractValueClassCannotBeInner(fragment));\n-            }\n-                switch (s.kind) {\n-                case VAR:\n-                    if ((s.flags() & STATIC) == 0) {\n-                        log.error(pos, Errors.InstanceFieldNotAllowed(s, fragment));\n-                    }\n-                    break;\n-                case MTH:\n+                if (s.kind == MTH) {\n@@ -833,13 +814,0 @@\n-                    } else if (s.isInit()) {\n-                        MethodSymbol m = (MethodSymbol)s;\n-                        if (m.getParameters().size() > 0) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorCannotTakeArguments(m, fragment));\n-                        } else if (m.getTypeParameters().size() > 0) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorCannotBeGeneric(m, fragment));\n-                        } else if (m.type.getThrownTypes().size() > 0) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorCannotThrow(m, fragment));\n-                        } else if (protection(m.flags()) > protection(m.owner.flags())) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorHasWeakerAccess(m, fragment));\n-                        } else if ((m.flags() & EMPTYNOARGCONSTR) == 0) {\n-                                log.error(pos, Errors.AbstractValueClassNoArgConstructorMustBeEmpty(m, fragment));\n-                        }\n@@ -861,1 +829,1 @@\n-                if ((c.flags() & HASINITBLOCK) != 0) {\n+                \/*if ((c.flags() & HASINITBLOCK) != 0) {\n@@ -863,1 +831,1 @@\n-                }\n+                }*\/\n@@ -879,2 +847,2 @@\n-    Type checkConstructorRefType(JCExpression expr, Type t) {\n-        t = checkClassOrArrayType(expr, t);\n+    Type checkConstructorRefType(DiagnosticPosition pos, Type t) {\n+        t = checkClassOrArrayType(pos, t);\n@@ -883,1 +851,1 @@\n-                log.error(expr, Errors.AbstractCantBeInstantiated(t.tsym));\n+                log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));\n@@ -886,1 +854,1 @@\n-                log.error(expr, Errors.EnumCantBeInstantiated);\n+                log.error(pos, Errors.EnumCantBeInstantiated);\n@@ -889,1 +857,1 @@\n-                t = checkClassType(expr, t, true);\n+                t = checkClassType(pos, t, true);\n@@ -893,1 +861,1 @@\n-                log.error(expr, Errors.GenericArrayCreation);\n+                log.error(pos, Errors.GenericArrayCreation);\n@@ -952,1 +920,1 @@\n-        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface())\n+        if (t.isPrimitive() || t.isValueClass())\n@@ -1132,1 +1100,1 @@\n-                (s.isInit() ||\n+                (s.isConstructor() ||\n@@ -1351,3 +1319,4 @@\n-                mask = VarFlags;\n-                if (sym.owner.type.isValueClass() && (flags & STATIC) == 0) {\n-                    implicit |= FINAL;\n+                boolean isInstanceFieldOfValueClass = sym.owner.type.isValueClass() && (flags & STATIC) == 0;\n+                mask = !isInstanceFieldOfValueClass ? VarFlags : ExtendedVarFlags;\n+                if (isInstanceFieldOfValueClass) {\n+                    implicit |= FINAL | STRICT;\n@@ -1358,1 +1327,1 @@\n-            if (names.isInit(sym.name)) {\n+            if (sym.name == names.init) {\n@@ -1431,0 +1400,4 @@\n+            if ((flags & (INTERFACE | VALUE_CLASS)) == 0) {\n+                implicit |= IDENTITY_TYPE;\n+            }\n+\n@@ -1450,5 +1423,0 @@\n-                if ((flags & NON_SEALED) != 0) {\n-                    \/\/ cant declare a final value class non-sealed\n-                    log.error(pos,\n-                            Errors.ModNotAllowedHere(asFlagSet(NON_SEALED)));\n-                }\n@@ -1490,1 +1458,1 @@\n-                        IDENTITY_TYPE,\n+                        INTERFACE,\n@@ -1518,2 +1486,2 @@\n-                 && checkDisjoint(pos, flags,\n-                                IDENTITY_TYPE,\n+                && checkDisjoint(pos, flags,\n+                                VALUE_CLASS,\n@@ -1523,1 +1491,4 @@\n-                                ANNOTATION) ) {\n+                                NON_SEALED)\n+                && checkDisjoint(pos, flags,\n+                                VALUE_CLASS,\n+                                INTERFACE) ) {\n@@ -1763,1 +1734,1 @@\n-                    env.enclMethod != null && names.isInit(env.enclMethod.name);\n+                    env.enclMethod != null && env.enclMethod.name == names.init;\n@@ -2373,1 +2344,1 @@\n-                (env.info.isAnonymousDiamond && !m.isInit() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isConstructor() && !m.isPrivate());\n@@ -2835,1 +2806,1 @@\n-                if ((t.tsym.flags() & IDENTITY_TYPE) != 0)\n+                if ((t.tsym.flags() & IDENTITY_TYPE) != 0 && (t.tsym.flags() & VALUE_BASED) == 0)\n@@ -2839,1 +2810,1 @@\n-                if (cIsValue &&  identitySuper != null) {\n+                if (cIsValue && identitySuper != null && identitySuper.tsym != syms.objectType.tsym) { \/\/ Object is special\n@@ -2842,6 +2813,0 @@\n-                } else if (cHasIdentity &&  valueSuper != null) {\n-                    log.error(pos, Errors.IdentityTypeHasValueSuperType(c, valueSuper));\n-                    break;\n-                } else if (identitySuper != null && valueSuper != null) {\n-                    log.error(pos, Errors.MutuallyIncompatibleSupers(c, identitySuper, valueSuper));\n-                    break;\n@@ -2946,1 +2911,1 @@\n-                     !s.isInit();\n+                     !s.isConstructor();\n@@ -3005,1 +2970,1 @@\n-                     !s.isInit();\n+                     !s.isConstructor();\n@@ -3888,1 +3853,1 @@\n-                if (s.kind == MTH && !s.isInit())\n+                if (s.kind == MTH && !s.isConstructor())\n@@ -3896,1 +3861,1 @@\n-                if (s.kind == MTH && s.isInit())\n+                if (s.kind == MTH && s.isConstructor())\n@@ -3915,1 +3880,1 @@\n-                        (s.kind == MTH && !s.isInit() &&\n+                        (s.kind == MTH && !s.isConstructor() &&\n@@ -3917,1 +3882,1 @@\n-                        (s.kind == MTH && s.isInit())) {\n+                        (s.kind == MTH && s.isConstructor())) {\n@@ -4191,4 +4156,5 @@\n-            JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);\n-            if (app == null) continue;\n-            JCMethodDecl meth = (JCMethodDecl) l.head;\n-            if (TreeInfo.name(app.meth) == names._this) {\n+            if (!TreeInfo.isConstructor(l.head))\n+                continue;\n+            JCMethodDecl meth = (JCMethodDecl)l.head;\n+            JCMethodInvocation app = TreeInfo.findConstructorCall(meth);\n+            if (app != null && TreeInfo.name(app.meth) == names._this) {\n@@ -4227,0 +4193,125 @@\n+\/* *************************************************************************\n+ * Verify the proper placement of super()\/this() calls.\n+ *\n+ *    - super()\/this() may only appear in constructors\n+ *    - There must be at most one super()\/this() call per constructor\n+ *    - The super()\/this() call, if any, must be a top-level statement in the\n+ *      constructor, i.e., not nested inside any other statement or block\n+ *    - There must be no return statements prior to the super()\/this() call\n+ **************************************************************************\/\n+\n+    void checkSuperInitCalls(JCClassDecl tree) {\n+        new SuperThisChecker().check(tree);\n+    }\n+\n+    private class SuperThisChecker extends TreeScanner {\n+\n+        \/\/ Match this scan stack: 1=JCMethodDecl, 2=JCExpressionStatement, 3=JCMethodInvocation\n+        private static final int MATCH_SCAN_DEPTH = 3;\n+\n+        private boolean constructor;        \/\/ is this method a constructor?\n+        private boolean firstStatement;     \/\/ at the first statement in method?\n+        private JCReturn earlyReturn;       \/\/ first return prior to the super()\/init(), if any\n+        private Name initCall;              \/\/ whichever of \"super\" or \"init\" we've seen already\n+        private int scanDepth;              \/\/ current scan recursion depth in method body\n+\n+        public void check(JCClassDecl classDef) {\n+            scan(classDef.defs);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            Assert.check(!constructor);\n+            Assert.check(earlyReturn == null);\n+            Assert.check(initCall == null);\n+            Assert.check(scanDepth == 1);\n+\n+            \/\/ Initialize state for this method\n+            constructor = TreeInfo.isConstructor(tree);\n+            try {\n+\n+                \/\/ Scan method body\n+                if (tree.body != null) {\n+                    firstStatement = true;\n+                    for (List<JCStatement> l = tree.body.stats; l.nonEmpty(); l = l.tail) {\n+                        scan(l.head);\n+                        firstStatement = false;\n+                    }\n+                }\n+\n+                \/\/ Verify no 'return' seen prior to an explicit super()\/this() call\n+                if (constructor && earlyReturn != null && initCall != null)\n+                    log.error(earlyReturn.pos(), Errors.ReturnBeforeSuperclassInitialized);\n+            } finally {\n+                firstStatement = false;\n+                constructor = false;\n+                earlyReturn = null;\n+                initCall = null;\n+            }\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            scanDepth++;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                scanDepth--;\n+            }\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation apply) {\n+            do {\n+\n+                \/\/ Is this a super() or this() call?\n+                Name methodName = TreeInfo.name(apply.meth);\n+                if (methodName != names._super && methodName != names._this)\n+                    break;\n+\n+                \/\/ super()\/this() calls must only appear in a constructor\n+                if (!constructor) {\n+                    log.error(apply.pos(), Errors.CallMustOnlyAppearInCtor);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must be a top level statement\n+                if (scanDepth != MATCH_SCAN_DEPTH) {\n+                    log.error(apply.pos(), Errors.CtorCallsNotAllowedHere);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must not appear more than once\n+                if (initCall != null) {\n+                    log.error(apply.pos(), Errors.RedundantSuperclassInit);\n+                    break;\n+                }\n+\n+                \/\/ valhalla is using this feature so commenting this code for now so that the\n+                \/\/ build doesn't depend on preview code\n+                \/\/ If super()\/this() isn't first, require \"statements before super()\" feature\n+                \/*if (!firstStatement) {\n+                    preview.checkSourceLevel(apply.pos(), Feature.SUPER_INIT);\n+                }*\/\n+\n+                \/\/ We found a legitimate super()\/this() call; remember it\n+                initCall = methodName;\n+            } while (false);\n+\n+            \/\/ Proceed\n+            super.visitApply(apply);\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            if (constructor && initCall == null && earlyReturn == null)\n+                earlyReturn = tree;             \/\/ we have seen a return but not (yet) a super()\/this()\n+            super.visitReturn(tree);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n@@ -5303,1 +5394,1 @@\n-                    if (sym.isInit() &&\n+                    if (sym.isConstructor() &&\n@@ -5331,1 +5422,1 @@\n-                        if (sym.isInit()) {\n+                        if (sym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":173,"deletions":82,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -58,2 +59,0 @@\n-import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;\n-import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;\n@@ -391,0 +390,7 @@\n+        \/** A class whose initializers we are scanning. Because initializer\n+         *  scans can be triggered out of sequence when visiting certain nodes\n+         *  (e.g., super()), we protect against infinite loops that could be\n+         *  triggered by incorrect code (e.g., super() inside initializer).\n+         *\/\n+        JCClassDecl initScanClass;\n+\n@@ -476,0 +482,18 @@\n+\n+        \/\/ Do something with all static or non-static field initializers and initialization blocks.\n+        \/\/ Note: This method also sends nested class definitions to the handler.\n+        protected void forEachInitializer(JCClassDecl classDef, boolean isStatic, Consumer<? super JCTree> handler) {\n+            if (classDef == initScanClass)          \/\/ avoid infinite loops\n+                return;\n+            JCClassDecl initScanClassPrev = initScanClass;\n+            initScanClass = classDef;\n+            try {\n+                for (List<JCTree> defs = classDef.defs; defs.nonEmpty(); defs = defs.tail) {\n+                    JCTree def = defs.head;\n+                    if (!def.hasTag(METHODDEF) && ((TreeInfo.flags(def) & STATIC) != 0) == isStatic)\n+                        handler.accept(def);\n+                }\n+            } finally {\n+                initScanClass = initScanClassPrev;\n+            }\n+        }\n@@ -541,7 +565,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -550,7 +571,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, false, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -1367,34 +1385,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n-\n-                \/\/ add intersection of all throws clauses of initial constructors\n-                \/\/ to set of caught exceptions, unless class is anonymous.\n-                if (!anonymousClass) {\n-                    boolean firstConstructor = true;\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (TreeInfo.isInitialConstructor(l.head)) {\n-                            List<Type> mthrown =\n-                                ((JCMethodDecl) l.head).sym.type.getThrownTypes();\n-                            if (firstConstructor) {\n-                                caught = mthrown;\n-                                firstConstructor = false;\n-                            } else {\n-                                caught = chk.intersect(mthrown, caught);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                \/\/ process all the instance initializers\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n@@ -1455,1 +1443,1 @@\n-                if (TreeInfo.isInitialConstructor(tree))\n+                if (TreeInfo.hasConstructorCall(tree, names._super))\n@@ -1756,0 +1744,2 @@\n+\n+            \/\/ Mark as thrown the exceptions thrown by the method being invoked\n@@ -1758,0 +1748,8 @@\n+\n+            \/\/ After super(), scan initializers to uncover any exceptions they throw\n+            if (TreeInfo.name(tree.meth) == names._super) {\n+                forEachInitializer(classDef, false, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n+            }\n@@ -2002,8 +2000,0 @@\n-    \/** Enum to model whether constructors allowed to \"leak\" this reference before\n-        all instance fields are DA.\n-     *\/\n-    enum ThisExposability {\n-        ALLOWED,     \/\/ identity Object classes - NOP\n-        BANNED,      \/\/ primitive\/value classes - Error\n-    }\n-\n@@ -2098,3 +2088,0 @@\n-        \/\/ Are constructors allowed to leak this reference ?\n-        ThisExposability thisExposability = ALLOWED;\n-\n@@ -2111,1 +2098,1 @@\n-        private boolean isInitialConstructor = false;\n+        private boolean isConstructor;\n@@ -2115,1 +2102,1 @@\n-            if (!isInitialConstructor) {\n+            if (!isConstructor) {\n@@ -2234,22 +2221,0 @@\n-        void checkEmbryonicThisExposure(JCTree node) {\n-            if (this.thisExposability == ALLOWED || classDef == null)\n-                return;\n-\n-            \/\/ Note: for non-initial constructors, firstadr is post all instance fields.\n-            for (int i = firstadr; i < nextadr; i++) {\n-                VarSymbol sym = vardecls[i].sym;\n-                if (sym.owner != classDef.sym)\n-                    continue;\n-                if ((sym.flags() & (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)\n-                    continue;\n-                if (sym.pos < startPos || sym.adr < firstadr)\n-                    continue;\n-                if (!inits.isMember(sym.adr)) {\n-                    if (this.thisExposability == BANNED) {\n-                        log.error(node, Errors.ThisExposedPrematurely);\n-                    }\n-                    return; \/\/ don't flog a dead horse.\n-                }\n-            }\n-        }\n-\n@@ -2402,7 +2367,4 @@\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n+                    forEachInitializer(tree, true, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n@@ -2432,9 +2394,0 @@\n-                    \/\/ process all the instance initializers\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n-\n@@ -2471,1 +2424,0 @@\n-            ThisExposability priorThisExposability = this.thisExposability;\n@@ -2480,1 +2432,1 @@\n-                boolean lastInitialConstructor = isInitialConstructor;\n+                boolean isConstructorPrev = isConstructor;\n@@ -2482,1 +2434,1 @@\n-                    isInitialConstructor = TreeInfo.isInitialConstructor(tree);\n+                    isConstructor = TreeInfo.isConstructor(tree);\n@@ -2484,1 +2436,2 @@\n-                    if (!isInitialConstructor) {\n+                    \/\/ We only track field initialization inside constructors\n+                    if (!isConstructor) {\n@@ -2486,6 +2439,2 @@\n-                        this.thisExposability = ALLOWED;\n-                    } else {\n-                        if (tree.sym.owner.type.isValueClass())\n-                            this.thisExposability = BANNED;\n-                        else\n-                            this.thisExposability = ALLOWED;\n+\n+                    \/\/ Mark all method parameters as DA\n@@ -2508,1 +2457,1 @@\n-                    if (isInitialConstructor) {\n+                    if (isConstructor) {\n@@ -2550,1 +2499,1 @@\n-                    isInitialConstructor = lastInitialConstructor;\n+                    isConstructor = isConstructorPrev;\n@@ -2554,1 +2503,0 @@\n-                this.thisExposability = priorThisExposability;\n@@ -2567,1 +2515,1 @@\n-                if (inMethod && isInitialConstructor) {\n+                if (inMethod && isConstructor) {\n@@ -3023,4 +2971,21 @@\n-            if (tree.meth.hasTag(IDENT)) {\n-                JCIdent ident = (JCIdent) tree.meth;\n-                if (ident.name != names._super && !ident.sym.isStatic())\n-                    checkEmbryonicThisExposure(tree);\n+\n+            \/\/ Handle superclass constructor invocations\n+            if (isConstructor) {\n+\n+                \/\/ If super(): at this point all initialization blocks will execute\n+                Name name = TreeInfo.name(tree.meth);\n+                if (name == names._super) {\n+                    forEachInitializer(classDef, false, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n+                }\n+\n+                \/\/ If this(): at this point all final uninitialized fields will get initialized\n+                else if (name == names._this) {\n+                    for (int address = firstadr; address < nextadr; address++) {\n+                        VarSymbol sym = vardecls[address].sym;\n+                        if (isFinalUninitializedField(sym) && !sym.isStatic())\n+                            letInit(tree.pos(), sym);\n+                    }\n+                }\n@@ -3034,6 +2999,0 @@\n-            if (classDef != null && tree.encl == null && tree.clazz.hasTag(IDENT)) {\n-                JCIdent clazz = (JCIdent) tree.clazz;\n-                if (!clazz.sym.isStatic() && clazz.type.getEnclosingType().tsym == classDef.sym) {\n-                    checkEmbryonicThisExposure(tree);\n-                }\n-            }\n@@ -3109,8 +3068,1 @@\n-            ThisExposability priorThisExposability = this.thisExposability;\n-            try {\n-                if (tree.name == names._this && classDef != null && tree.sym.owner == classDef.sym) {\n-                    checkEmbryonicThisExposure(tree);\n-                } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {\n-                    this.thisExposability = ALLOWED;\n-                }\n-                super.visitSelect(tree);\n+            super.visitSelect(tree);\n@@ -3119,4 +3071,1 @@\n-                    checkInit(tree.pos(), (VarSymbol)tree.sym);\n-                }\n-            } finally {\n-                 this.thisExposability = priorThisExposability;\n+                checkInit(tree.pos(), (VarSymbol)tree.sym);\n@@ -3186,3 +3135,0 @@\n-            if (tree.name == names._this) {\n-                checkEmbryonicThisExposure(tree);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":87,"deletions":141,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-    private final boolean emitQDesc;\n@@ -138,1 +137,0 @@\n-        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -1150,1 +1148,1 @@\n-        } else if (names.isInit(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n+        } else if (sym.name == names.init && sym.owner.isDirectlyOrIndirectlyLocal()) {\n@@ -1412,1 +1410,1 @@\n-        if (names.isInit(sym.name)) {\n+        if (sym.name == names.init) {\n@@ -1625,1 +1623,1 @@\n-            (owner.isInit() && owner.isAnonymous()) ||\n+            (owner.isConstructor() && owner.isAnonymous()) ||\n@@ -1627,1 +1625,1 @@\n-            (owner.isInit() && c.isInner() &&\n+            (owner.isConstructor() && c.isInner() &&\n@@ -1866,1 +1864,1 @@\n-                chk.earlyRefError(pos, c);\n+                log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n@@ -1906,1 +1904,0 @@\n-            Assert.error();\n@@ -1918,1 +1915,0 @@\n-                    Assert.error();\n@@ -2347,1 +2343,1 @@\n-        tree.mods.flags &= AdjustedClassFlags;\n+        tree.mods.flags &= ClassFlags;\n@@ -2358,2 +2354,2 @@\n-        \/\/ If this$n was accessed, add the field definition and\n-        \/\/ update initial constructors to initialize it\n+        \/\/ If this$n was accessed, add the field definition and prepend\n+        \/\/ initializer code to any super() invocation to initialize it\n@@ -2364,5 +2360,7 @@\n-           for (JCTree def : tree.defs) {\n-                if (TreeInfo.isInitialConstructor(def)) {\n-                  JCMethodDecl mdef = (JCMethodDecl) def;\n-                  mdef.body.stats = mdef.body.stats.prepend(\n-                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+            for (JCTree def : tree.defs) {\n+                if (TreeInfo.isConstructor(def)) {\n+                    JCMethodDecl mdef = (JCMethodDecl)def;\n+                    if (TreeInfo.hasConstructorCall(mdef, names._super)) {\n+                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                        TreeInfo.mapSuperCalls(mdef.body, supercall -> make.Block(0, initializer.append(supercall)));\n+                    }\n@@ -2757,1 +2755,0 @@\n-        \/\/ TODO - enum so is always <init>\n@@ -2799,1 +2796,1 @@\n-        if (names.isInit(tree.name) &&\n+        if (tree.name == names.init &&\n@@ -2834,4 +2831,2 @@\n-            \/\/ If this is an initial constructor, i.e., it does not start with\n-            \/\/ this(...), insert initializers for this$n and proxies\n-            \/\/ before (pre-1.4, after) the call to superclass constructor.\n-            JCStatement selfCall = translate(tree.body.stats.head);\n+            \/\/ Determine whether this constructor has a super() invocation\n+            boolean invokesSuper = TreeInfo.hasConstructorCall(tree, names._super);\n@@ -2839,1 +2834,2 @@\n-            List<JCStatement> added = List.nil();\n+            \/\/ Create initializers for this$n and proxies\n+            ListBuffer<JCStatement> added = new ListBuffer<>();\n@@ -2846,1 +2842,1 @@\n-                    if (TreeInfo.isInitialConstructor(tree)) {\n+                    if (invokesSuper) {\n@@ -2860,0 +2856,9 @@\n+            \/\/ Recursively translate existing local statements\n+            tree.body.stats = translate(tree.body.stats);\n+\n+            \/\/ Prepend initializers in front of super() call\n+            if (added.nonEmpty()) {\n+                List<JCStatement> initializers = added.toList();\n+                TreeInfo.mapSuperCalls(tree.body, supercall -> make.Block(0, initializers.append(supercall)));\n+            }\n+\n@@ -2863,4 +2868,0 @@\n-            \/\/ recursively translate following local statements and\n-            \/\/ combine with this- or super-call\n-            List<JCStatement> stats = translate(tree.body.stats.tail);\n-            tree.body.stats = stats.prepend(selfCall).prependList(added);\n@@ -2880,1 +2881,1 @@\n-        if (names.isInit(tree.name) && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+        if (tree.name == names.init && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n@@ -3122,2 +3123,1 @@\n-        \/\/ TODO - is enum so always <init>.\n-        if (names.isInit(meth.name) && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym)\n@@ -3128,1 +3128,1 @@\n-        if (names.isInit(meth.name)) {\n+        if (meth.name==names.init) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -42,0 +43,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -60,0 +62,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -572,1 +575,0 @@\n-            localEnv.info.isSelfCall = false;\n@@ -1070,1 +1072,0 @@\n-\n@@ -1144,9 +1145,2 @@\n-            if (tree.sym != syms.objectType.tsym && tree.sym != syms.recordType.tsym) {\n-                if ((tree.sym.flags() & (ABSTRACT | INTERFACE | VALUE_CLASS)) == 0) {\n-                    tree.sym.flags_field |= IDENTITY_TYPE;\n-                }\n-                if ((tree.sym.flags() & (ABSTRACT | IDENTITY_TYPE | INTERFACE)) == ABSTRACT) {\n-                    if (abstractClassHasImplicitIdentity(tree)) {\n-                        tree.sym.flags_field |= IDENTITY_TYPE;\n-                    }\n-                }\n+            if ((tree.sym.flags() & (INTERFACE | VALUE_CLASS)) == 0) {\n+                tree.sym.flags_field |= IDENTITY_TYPE;\n@@ -1156,44 +1150,0 @@\n-            \/\/ where\n-            private boolean abstractClassHasImplicitIdentity(JCClassDecl tree) {\n-\n-                Type t = tree.sym.type;\n-\n-                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n-                    return false;\n-\n-                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n-                    return true;\n-                }\n-\n-                \/\/ No instance fields and no arged constructors both mean inner classes cannot be value class supers.\n-                Type encl = t.getEnclosingType();\n-                if (encl != null && encl.hasTag(CLASS)) {\n-                    return true;\n-                }\n-                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n-                    switch (s.kind) {\n-                        case VAR:\n-                            if ((s.flags() & STATIC) == 0) {\n-                                return true;\n-                            }\n-                            break;\n-                        case MTH:\n-                            if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n-                                return true;\n-                            } else if (s.isInit()) {\n-                                MethodSymbol m = (MethodSymbol)s;\n-                                if (m.getParameters().size() > 0\n-                                        || m.getTypeParameters().size() > 0\n-                                        || m.type.getThrownTypes().nonEmpty()\n-                                        || (m.flags() & EMPTYNOARGCONSTR) == 0\n-                                        || (Check.protection(m.flags()) > Check.protection(m.owner.flags()))) {\n-                                    return true;\n-                                }\n-                            }\n-                            break;\n-                    }\n-                }\n-                return false;\n-            }\n-\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":5,"deletions":55,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -140,4 +140,0 @@\n-    \/** Switch: emit Q descriptors\n-     *\/\n-    private boolean emitQDesc;\n-\n@@ -298,1 +294,2 @@\n-        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n+        allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -311,2 +308,0 @@\n-        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n-\n@@ -519,1 +514,0 @@\n-        case 'Q':\n@@ -523,4 +517,0 @@\n-                if ((char) signature[sigp] == 'Q' && !emitQDesc) {\n-                    throw badClassFile(\"bad.class.signature\",\n-                                       quoteBadSignature());\n-                }\n@@ -584,2 +574,1 @@\n-        byte prefix = signature[sigp];\n-        if (prefix != 'L' && (!emitQDesc || prefix != 'Q'))\n+        if (signature[sigp] != 'L')\n@@ -601,1 +590,0 @@\n-                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n@@ -617,1 +605,0 @@\n-                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n@@ -681,1 +668,0 @@\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n@@ -874,13 +860,0 @@\n-                    if (sym.isInit() && sym.type.getParameterTypes().size() == 0) {\n-                        try {\n-                            int code_length = buf.getInt(bp + 4);\n-                            if ((code_length == 1 && buf.getByte(bp + 8) == (byte) ByteCodes.return_) ||\n-                                (code_length == 5 && buf.getByte(bp + 8) == ByteCodes.aload_0 &&\n-                                    buf.getByte(bp + 9) == (byte) ByteCodes.invokespecial &&\n-                                            buf.getByte(bp + 12) == (byte) ByteCodes.return_)) {\n-                                sym.flags_field |= EMPTYNOARGCONSTR;\n-                            }\n-                        } catch (UnderflowException e) {\n-                            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n-                        }\n-                    }\n@@ -1066,0 +1039,1 @@\n+\n@@ -1451,1 +1425,1 @@\n-        if (!names.isInit(nt.name))\n+        if (nt.name != names.init)\n@@ -2701,1 +2675,1 @@\n-        if (names.isInit(name) && currentOwner.hasOuterInstance()) {\n+        if (name == names.init && currentOwner.hasOuterInstance()) {\n@@ -2746,1 +2720,1 @@\n-            ((name == names.init) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            (name == names.init && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2810,1 +2784,1 @@\n-        if (names.isInit(sym.name) && currentOwner.hasOuterInstance()) {\n+        if (sym.name == names.init && currentOwner.hasOuterInstance()) {\n@@ -2974,8 +2948,0 @@\n-        if (c == syms.objectType.tsym) {\n-            flags &= ~IDENTITY_TYPE; \/\/ jlO lacks identity even while being a concrete class.\n-        }\n-        if ((flags & PRIMITIVE_CLASS) != 0) {\n-            if (!emitQDesc || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n-                throw badClassFile(\"bad.access.flags\", Flags.toString(flags));\n-            }\n-        }\n@@ -3041,3 +3007,1 @@\n-        for (int i = 0; i < fieldCount; i++) {\n-            enterMember(c, readField());\n-        }\n+        for (int i = 0; i < fieldCount; i++) enterMember(c, readField());\n@@ -3227,0 +3191,5 @@\n+        boolean previewClassFile = minorVersion == ClassFile.PREVIEW_MINOR_VERSION;\n+        if (allowValueClasses && previewClassFile && (flags & ACC_STRICT) != 0) {\n+            flags &= ~ACC_STRICT;\n+            flags |= STRICT;\n+        }\n@@ -3243,3 +3212,1 @@\n-        if ((flags & (ABSTRACT | INTERFACE | ACC_VALUE | ACC_MODULE)) == 0) {\n-            flags |= ACC_IDENTITY;\n-        }\n+        boolean previewClassFile = minorVersion == ClassFile.PREVIEW_MINOR_VERSION;\n@@ -3250,8 +3217,1 @@\n-        if ((flags & ACC_VALUE) != 0) {\n-            flags &= ~ACC_VALUE;\n-            if (allowValueClasses) {\n-                flags |= VALUE_CLASS;\n-            }\n-        }\n-        if ((flags & ACC_IDENTITY) != 0) {\n-            flags &= ~ACC_IDENTITY;\n+        if ((flags & ACC_IDENTITY) != 0 || (majorVersion < V66.major && (flags & INTERFACE) == 0)) {\n@@ -3259,0 +3219,2 @@\n+        } else if ((flags & INTERFACE) == 0 && allowValueClasses && previewClassFile && majorVersion >= V66.major) {\n+            flags |= VALUE_CLASS;\n@@ -3260,0 +3222,1 @@\n+        flags &= ~ACC_IDENTITY; \/\/ ACC_IDENTITY and SYNCHRONIZED bits overloaded\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":19,"deletions":56,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -84,4 +84,0 @@\n-    \/** Switch: emit Q descriptors\n-     *\/\n-    private boolean emitQDesc;\n-\n@@ -204,1 +200,0 @@\n-        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -238,1 +233,1 @@\n-            if ((f & 1) != 0) {\n+            if ((f & 1) != 0 && flagName[i] != \"\") {\n@@ -250,1 +245,2 @@\n-            \"IDENTITY\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n+            \/\/ the empty position should be for synchronized but right now we don't have any test checking it\n+            \"\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n@@ -1107,1 +1103,1 @@\n-        if (m.isInit() && (m.flags_field & RECORD) != 0)\n+        if (m.isConstructor() && (m.flags_field & RECORD) != 0)\n@@ -1334,1 +1330,1 @@\n-                databuf.appendChar(emitQDesc && t.hasImplicitConstructor() && t.isNonNullable() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n@@ -1647,1 +1643,2 @@\n-            flags = adjustFlags(c, c.flags() & ~(DEFAULT | STRICTFP));\n+            long originalFlags = c.flags();\n+            flags = adjustFlags(c.flags() & ~(DEFAULT | STRICTFP));\n@@ -1649,1 +1646,2 @@\n-            flags = flags & AdjustedClassFlags;\n+            flags = flags & ClassFlags;\n+            flags |= (originalFlags & IDENTITY_TYPE) != 0 ? ACC_IDENTITY : flags;\n@@ -1677,1 +1675,1 @@\n-            case TYP: poolWriter.enterInnerClass((ClassSymbol)sym); break;\n+            case TYP: poolWriter.enterInner((ClassSymbol)sym); break;\n@@ -1684,1 +1682,1 @@\n-                poolWriter.enterInnerClass(local);\n+                poolWriter.enterInner(local);\n@@ -1827,9 +1825,1 @@\n-        if (emitQDesc && sym.kind == TYP) {\n-            ClassSymbol csym = (ClassSymbol)sym;\n-            if (csym.isValueClass() && csym.hasImplicitConstructor()) {\n-                result |= ACC_PRIMITIVE;\n-            }\n-        }\n-        if ((flags & VALUE_CLASS) != 0)\n-            result |= ACC_VALUE;\n-        if ((flags & IDENTITY_TYPE) != 0)\n+        if ((flags & IDENTITY_TYPE) != 0) {\n@@ -1837,0 +1827,4 @@\n+        }\n+        if ((flags & STRICT) != 0) {\n+            result |= ACC_STRICT;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -136,1 +136,0 @@\n-        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n@@ -146,1 +145,0 @@\n-    private final boolean emitQDesc;\n@@ -276,10 +274,1 @@\n-        return makeRef(pos, type, false);\n-    }\n-\n-    int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {\n-        checkDimension(pos, type);\n-        if (emitQtype) {\n-            return poolWriter.putClass(new ConstantPoolQType(type, types));\n-        } else {\n-            return poolWriter.putClass(type);\n-        }\n+        return poolWriter.putClass(checkDimension(pos, type));\n@@ -339,1 +328,1 @@\n-        else items.makeMemberItem(msym, names.isInit(name)).invoke();\n+        else items.makeMemberItem(msym, name == names.init).invoke();\n@@ -439,0 +428,2 @@\n+        \/\/ only used for value classes\n+        ListBuffer<JCStatement> initBlocks = new ListBuffer<>();\n@@ -454,2 +445,7 @@\n-                else if ((block.flags & SYNTHETIC) == 0)\n-                    initCode.append(block);\n+                else if ((block.flags & SYNTHETIC) == 0) {\n+                    if (c.isValueClass()) {\n+                        initBlocks.append(block);\n+                    } else {\n+                        initCode.append(block);\n+                    }\n+                }\n@@ -494,2 +490,1 @@\n-        if (initCode.length() != 0) {\n-            List<JCStatement> inits = initCode.toList();\n+        if (initCode.length() != 0 || initBlocks.length() != 0) {\n@@ -499,1 +494,1 @@\n-                normalizeMethod((JCMethodDecl)t, inits, initTAlist);\n+                normalizeMethod((JCMethodDecl)t, initCode.toList(), initBlocks.toList(), initTAlist);\n@@ -556,1 +551,1 @@\n-    \/** Insert instance initializer code into initial constructor.\n+    \/** Insert instance initializer code into constructors prior to the super() call.\n@@ -562,30 +557,8 @@\n-    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<TypeCompound> initTAs) {\n-        if (names.isInit(md.name) && TreeInfo.isInitialConstructor(md)) {\n-            \/\/ We are seeing a constructor that does not call another\n-            \/\/ constructor of the same class.\n-            List<JCStatement> stats = md.body.stats;\n-            ListBuffer<JCStatement> newstats = new ListBuffer<>();\n-\n-            if (stats.nonEmpty()) {\n-                \/\/ Copy initializers of synthetic variables generated in\n-                \/\/ the translation of inner classes.\n-                while (TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Copy superclass constructor call\n-                newstats.append(stats.head);\n-                stats = stats.tail;\n-                \/\/ Copy remaining synthetic initializers.\n-                while (stats.nonEmpty() &&\n-                       TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Now insert the initializer code.\n-                newstats.appendList(initCode);\n-                \/\/ And copy all remaining statements.\n-                while (stats.nonEmpty()) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n+    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initBlocks,  List<TypeCompound> initTAs) {\n+        if (TreeInfo.isConstructor(md) && TreeInfo.hasConstructorCall(md, names._super)) {\n+            \/\/ We are seeing a constructor that has a super() call.\n+            \/\/ Find the super() invocation and append the given initializer code.\n+            if (md.sym.owner.isValueClass()) {\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.append(supercall).appendList(initBlocks)));\n+            } else {\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n@@ -593,1 +566,1 @@\n-            md.body.stats = newstats.toList();\n+\n@@ -970,1 +943,1 @@\n-            if (meth.isInit()) {\n+            if (meth.isConstructor()) {\n@@ -1010,3 +983,0 @@\n-                    } else if (env.enclMethod.sym.isValueClassConst()) {\n-                        items.makeLocalItem(env.enclMethod.factoryProduct).load();\n-                        code.emitop0(areturn);\n@@ -1079,1 +1049,1 @@\n-                if (meth.isInit() && selfType != syms.objectType)\n+                if (meth.isConstructor() && selfType != syms.objectType)\n@@ -1083,3 +1053,1 @@\n-                            new VarSymbol(FINAL, names._this,\n-                                    selfType,\n-                                    meth.owner)));\n+                            new VarSymbol(FINAL, names._this, selfType, meth.owner)));\n@@ -2101,1 +2069,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype, emitQDesc && elemtype.hasImplicitConstructor() && elemtype.isNonNullable()), type);\n+                code.emitAnewarray(makeRef(pos, elemtype), type);\n@@ -2338,6 +2306,1 @@\n-            checkDimension(tree.pos(), tree.clazz.type);\n-            if (emitQDesc && tree.clazz.type.hasImplicitConstructor() && tree.clazz.type.isNonNullable()) {\n-                code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);\n-            } else {\n-                code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n-            }\n+            code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);\n@@ -2406,1 +2369,1 @@\n-                    emitQDesc && tree.selected.type.hasImplicitConstructor() && tree.selected.type.isNonNullable()));\n+                    tree.selected.type.hasImplicitConstructor() && tree.selected.type.isNonNullable()));\n@@ -2465,13 +2428,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        if (tree.type.isValueClass()) {\n-            \/\/code.emitop2(aconst_init, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n-            code.emitop0(aconst_null);\n-        } else if (tree.type.isReference()) {\n-            code.emitop0(aconst_null);\n-        } else {\n-            code.emitop0(zero(Code.typecode(tree.type)));\n-        }\n-        result = items.makeStackItem(tree.type);\n-        return;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":29,"deletions":79,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -199,1 +199,2 @@\n-        this.allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n+        this.allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -536,16 +537,0 @@\n-    \/** If next input token matches one of the two given tokens, skip it, otherwise report\n-     *  an error.\n-     *\n-     * @return The actual token kind.\n-     *\/\n-    public TokenKind accept2(TokenKind tk1, TokenKind tk2) {\n-        TokenKind returnValue = token.kind;\n-        if (token.kind == tk1 || token.kind == tk2) {\n-            nextToken();\n-        } else {\n-            setErrorEndPos(token.pos);\n-            reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));\n-        }\n-        return returnValue;\n-    }\n-\n@@ -1569,6 +1554,0 @@\n-                            case DEFAULT:\n-                                if (typeArgs != null) return illegal();\n-                                selectExprMode();\n-                                t = to(F.at(pos).DefaultValue(t));\n-                                nextToken();\n-                                break loop;\n@@ -1640,2 +1619,1 @@\n-                            \/\/is a generic type i.e. A<S>::m or a default value creation of\n-                            \/\/the form ValueType<S>.default\n+                            \/\/is a generic type i.e. A<S>::m\n@@ -1654,6 +1632,0 @@\n-                                if (token.kind == DEFAULT) {\n-                                    t =  toP(F.at(token.pos).DefaultValue(t));\n-                                    nextToken();\n-                                    selectExprMode();\n-                                    return term3Rest(t, typeArgs);\n-                                }\n@@ -1922,2 +1894,1 @@\n-     * method reference or a default value creation that uses a parameterized type\n-     * or a binary expression. To disambiguate, look for a\n+     * method reference or a binary expression. To disambiguate, look for a\n@@ -2576,1 +2547,1 @@\n-            TokenKind selector = accept2(CLASS, DEFAULT);\n+            accept(CLASS);\n@@ -2594,5 +2565,1 @@\n-                if (selector == CLASS) {\n-                    t = toP(F.at(pos).Select(t, names._class));\n-                } else {\n-                    t = toP(F.at(pos).DefaultValue(t));\n-                }\n+                t = toP(F.at(pos).Select(t, names._class));\n@@ -2630,1 +2597,0 @@\n-            \/\/ TODO - will be converted in Attr\n@@ -2719,3 +2685,0 @@\n-            long badModifiers = mods.flags & ~(Flags.VALUE_CLASS | Flags.FINAL);\n-            if (badModifiers != 0)\n-                log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));\n@@ -2844,2 +2807,1 @@\n-        JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n-        return newClass;\n+        return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n@@ -3076,1 +3038,2 @@\n-        if ((isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+        if ((isValueModifier()) && allowValueClasses) {\n+            checkSourceLevel(Feature.VALUE_CLASSES);\n@@ -3689,0 +3652,1 @@\n+                    checkSourceLevel(Feature.VALUE_CLASSES);\n@@ -3692,4 +3656,0 @@\n-                if (isIdentityModifier()) {\n-                    flag = Flags.IDENTITY_TYPE;\n-                    break;\n-                }\n@@ -3968,1 +3928,1 @@\n-                return Source.JDK18;\n+                return Source.JDK22;\n@@ -3970,6 +3930,1 @@\n-                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n-            }\n-        }\n-        if (name == names.identity) {\n-            if (shouldWarn) {\n-                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK22));\n@@ -4511,2 +4466,1 @@\n-                \/\/ TODO - specifically for record.\n-                if (names.isInit(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                if (methDef.name == names.init && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -5065,2 +5019,2 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value identity || new value Comparable() {} ??\n-                    if (next.name() == names.record || next.name() == names.value || next.name() == names.identity\n+                case IDENTIFIER: \/\/ value record R || value value || new value Comparable() {} ??\n+                    if (next.name() == names.record || next.name() == names.value\n@@ -5079,45 +5033,0 @@\n-    protected boolean isIdentityModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.identity) {\n-            boolean isIdentityModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isIdentityModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ identity record R || identity primitive || || identity identity || identity value || new identity Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isIdentityModifier = true;\n-                    break;\n-            }\n-            if (isIdentityModifier) {\n-                checkSourceLevel(Feature.VALUE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    protected boolean isImplicitModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.implicit) {\n-            boolean isImplicitModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case MONKEYS_AT:\n-                case STATIC: case FINAL: case ABSTRACT: case NATIVE:\n-                case SYNCHRONIZED: case STRICTFP: case DEFAULT: case IDENTIFIER:\n-                    isImplicitModifier = true;\n-                    break;\n-            }\n-            if (isImplicitModifier) {\n-                checkSourceLevel(Feature.VALUE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -5153,2 +5062,1 @@\n-                        next.name() == names.value ||\n-                        next.name() == names.identity;\n+                        allowValueClasses && next.name() == names.value;\n@@ -5185,1 +5093,1 @@\n-            if (!isRecord || !names.isInit(name) || token.kind == LPAREN) {\n+            if (!isRecord || name != names.init || token.kind == LPAREN) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":17,"deletions":109,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -236,3 +236,11 @@\n-# 0: name\n-compiler.err.call.must.be.first.stmt.in.ctor=\\\n-    call to {0} must be first statement in constructor\n+compiler.err.call.must.only.appear.in.ctor=\\\n+    explicit constructor invocation may only appear within a constructor body\n+\n+compiler.err.redundant.superclass.init=\\\n+    redundant explicit constructor invocation\n+\n+compiler.err.ctor.calls.not.allowed.here=\\\n+    explicit constructor invocation not allowed here\n+\n+compiler.err.return.before.superclass.initialized=\\\n+    ''return'' not allowed before explicit constructor invocation\n@@ -282,6 +290,0 @@\n-compiler.misc.value.interface.nonfunctional=\\\n-    since it is a value interface\n-\n-compiler.misc.identity.interface.nonfunctional=\\\n-    since it is an identity interface\n-\n@@ -396,1 +398,1 @@\n-# 0: symbol or string\n+# 0: symbol or name\n@@ -3205,0 +3207,3 @@\n+compiler.misc.feature.super.init=\\\n+    statements before super()\n+\n@@ -3913,2 +3918,2 @@\n-compiler.err.first.statement.must.be.call.to.another.constructor=\\\n-    constructor is not canonical, so its first statement must invoke another constructor of class {0}\n+compiler.err.non.canonical.constructor.invoke.another.constructor=\\\n+    constructor is not canonical, so it must invoke another constructor of class {0}\n@@ -4051,3 +4056,0 @@\n-compiler.misc.feature.primitive.classes=\\\n-    primitive classes\n-\n@@ -4057,11 +4059,0 @@\n-# 0: symbol\n-compiler.err.cyclic.primitive.class.membership=\\\n-    cyclic value class membership involving {0}\n-\n-compiler.err.this.exposed.prematurely=\\\n-    value class instance should not be passed around before being fully initialized\n-\n-# 0: type\n-compiler.err.generic.parameterization.with.primitive.class=\\\n-    Inferred type {0} involves generic parameterization by a primitive class\n-\n@@ -4072,8 +4063,0 @@\n-# 0: type, 1: type\n-compiler.err.identity.type.has.value.super.type=\\\n-    The value type {1} cannot be a supertype of the identity type {0}\n-\n-# 0: type, 1: type, 2: type\n-compiler.err.mutually.incompatible.supers=\\\n-    The type {0} has mutually incompatible supertypes: the identity type {1} and the value type {2}\n-\n@@ -4088,32 +4071,0 @@\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.cannot.take.arguments=\\\n-    {1} defines a constructor {0} that takes arguments. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.cannot.be.generic=\\\n-    {1} defines a generic constructor {0}. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.cannot.throw=\\\n-    {1} defines a constructor {0} that throws an exception. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.has.weaker.access=\\\n-    {1} defines a constructor {0} with a weaker access privilege than the declaring class. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.instance.field.not.allowed=\\\n-    {1} defines an instance field {0}. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.no.arg.constructor.must.be.empty=\\\n-    {1} defines a nonempty no-arg constructor {0}. This is disallowed\n-\n-# 0: message segment\n-compiler.err.abstract.value.class.declares.init.block=\\\n-    {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n-\n-# 0: message segment\n-compiler.err.abstract.value.class.cannot.be.inner=\\\n-    {0} is an inner class. This is disallowed.\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":17,"deletions":66,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -260,4 +260,0 @@\n-        \/** Default values, of type DefaultValueTree.\n-         *\/\n-        DEFAULT_VALUE,\n-\n@@ -892,3 +888,0 @@\n-        \/** nascent value that evolves into the return value for a value factory *\/\n-        public VarSymbol factoryProduct;\n-\n@@ -962,4 +955,0 @@\n-\n-        public boolean isInitOrVNew() {\n-            return name.table.names.isInit(name);\n-        }\n@@ -1393,26 +1382,0 @@\n-    \/**\n-     * A \"Identifier<TA1, TA2>.default\" construction.\n-     *\/\n-    public static class JCDefaultValue extends JCPolyExpression implements DefaultValueTree {\n-        public JCExpression clazz;\n-\n-        protected JCDefaultValue(JCExpression clazz) {\n-            this.clazz = clazz;\n-        }\n-        @Override\n-        public void accept(Visitor v) { v.visitDefaultValue(this); }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() { return Kind.DEFAULT_VALUE; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getType() { return clazz; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n-            return v.visitDefaultValue(this, d);\n-        }\n-        @Override\n-        public Tag getTag() {\n-            return DEFAULT_VALUE;\n-        }\n-    }\n-\n@@ -3546,1 +3509,0 @@\n-        JCDefaultValue DefaultValue(JCExpression type);\n@@ -3627,1 +3589,0 @@\n-        public void visitDefaultValue(JCDefaultValue that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-            if (tree.isInitOrVNew() &&\n+            if (tree.name == tree.name.table.names.init &&\n@@ -615,1 +615,1 @@\n-            if (tree.isInitOrVNew()) {\n+            if (tree.name == tree.name.table.names.init) {\n@@ -755,9 +755,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        try {\n-            printExpr(tree.clazz, TreeInfo.postfixPrec);\n-            print(\".default\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.function.Function;\n@@ -122,22 +123,0 @@\n-    \/** Is there a constructor invocation in the given list of trees?\n-     *  Optionally, check only for no-arg ctor invocation\n-     *\/\n-    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names, boolean argsAllowed) {\n-        for (JCTree tree : trees) {\n-            if (tree.hasTag(EXEC)) {\n-                JCExpressionStatement stat = (JCExpressionStatement)tree;\n-                if (stat.expr.hasTag(APPLY)) {\n-                    JCMethodInvocation apply = (JCMethodInvocation)stat.expr;\n-                    if (argsAllowed || apply.args.size() == 0) {\n-                        Name methName = TreeInfo.name(apply.meth);\n-                        if (methName == names._this ||\n-                                methName == names._super) {\n-                            return methName;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return names.empty;\n-    }\n-\n@@ -182,12 +161,0 @@\n-    \/** Is this a call to this or super?\n-     *\/\n-    public static boolean isSelfCall(JCTree tree) {\n-        Name name = calledMethodName(tree);\n-        if (name != null) {\n-            Names names = name.table.names;\n-            return name==names._this || name==names._super;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n@@ -250,2 +217,26 @@\n-    \/** Is this a constructor whose first (non-synthetic) statement is not\n-     *  of the form this(...)?\n+    \/** Is the given method a constructor containing a super() or this() call?\n+      *\/\n+    public static boolean hasAnyConstructorCall(JCMethodDecl tree) {\n+        return hasConstructorCall(tree, null);\n+    }\n+\n+    \/** Is the given method a constructor containing a super() and\/or this() call?\n+      * The \"target\" is either names._this, names._super, or null for either\/both.\n+      *\/\n+    public static boolean hasConstructorCall(JCMethodDecl tree, Name target) {\n+        JCMethodInvocation app = findConstructorCall(tree);\n+        return app != null && (target == null || target == name(app.meth));\n+    }\n+\n+    \/** Find the first super() or init() call in the given constructor.\n+     *\/\n+    public static JCMethodInvocation findConstructorCall(JCMethodDecl md) {\n+        if (!TreeInfo.isConstructor(md) || md.body == null)\n+            return null;\n+        return new ConstructorCallFinder(md.name.table.names).find(md).head;\n+    }\n+\n+    \/** Finds all calls to this() and\/or super() in a given constructor.\n+     *  We can't assume they will be \"top level\" statements, because\n+     *  some synthetic calls to super() are added inside { } blocks.\n+     *  So we must recurse through the method's entire syntax tree.\n@@ -253,22 +244,70 @@\n-    public static boolean isInitialConstructor(JCTree tree) {\n-        JCMethodInvocation app = firstConstructorCall(tree);\n-        if (app == null) return false;\n-        Name meth = name(app.meth);\n-        return meth == null || meth != meth.table.names._this;\n-    }\n-\n-    \/** Return the first call in a constructor definition. *\/\n-    public static JCMethodInvocation firstConstructorCall(JCTree tree) {\n-        if (!tree.hasTag(METHODDEF)) return null;\n-        JCMethodDecl md = (JCMethodDecl) tree;\n-        if (!md.isInitOrVNew()) return null;\n-        if (md.body == null) return null;\n-        List<JCStatement> stats = md.body.stats;\n-        \/\/ Synthetic initializations can appear before the super call.\n-        while (stats.nonEmpty() && isSyntheticInit(stats.head))\n-            stats = stats.tail;\n-        if (stats.isEmpty()) return null;\n-        if (!stats.head.hasTag(EXEC)) return null;\n-        JCExpressionStatement exec = (JCExpressionStatement) stats.head;\n-        if (!exec.expr.hasTag(APPLY)) return null;\n-        return (JCMethodInvocation)exec.expr;\n+    private static class ConstructorCallFinder extends TreeScanner {\n+\n+        final ListBuffer<JCMethodInvocation> calls = new ListBuffer<>();\n+        final Names names;\n+\n+        ConstructorCallFinder(Names names) {\n+            this.names = names;\n+        }\n+\n+        List<JCMethodInvocation> find(JCMethodDecl meth) {\n+            scan(meth);\n+            return calls.toList();\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation invoke) {\n+            Name name = TreeInfo.name(invoke.meth);\n+            if ((name == names._this || name == names._super))\n+                calls.append(invoke);\n+            super.visitApply(invoke);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n+    \/** Finds super() invocations and translates them using the given mapping.\n+     *\/\n+    public static void mapSuperCalls(JCBlock block, Function<? super JCExpressionStatement, ? extends JCStatement> mapper) {\n+        block.stats = block.stats.map(new TreeInfo.SuperCallTranslator(mapper)::translate);\n+    }\n+\n+    \/** Finds all super() invocations and translates them somehow.\n+     *\/\n+    private static class SuperCallTranslator extends TreeTranslator {\n+\n+        final Function<? super JCExpressionStatement, ? extends JCStatement> translator;\n+\n+        \/** Constructor.\n+         *\n+         * @param translator translates super() invocations, returning replacement statement or null for no change\n+         *\/\n+        SuperCallTranslator(Function<? super JCExpressionStatement, ? extends JCStatement> translator) {\n+            this.translator = translator;\n+        }\n+\n+        \/\/ Because it returns void, anywhere super() can legally appear must be a location where a JCStatement\n+        \/\/ could also appear, so it's OK that we are replacing a JCExpressionStatement with a JCStatement here.\n+        @Override\n+        public void visitExec(JCExpressionStatement stat) {\n+            if (!TreeInfo.isSuperCall(stat) || (result = this.translator.apply(stat)) == null)\n+                super.visitExec(stat);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n@@ -500,2 +539,0 @@\n-            case DEFAULT_VALUE:\n-                return getStartPos(((JCDefaultValue) tree).clazz);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":97,"deletions":60,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    public final Name _default;\n@@ -107,1 +106,0 @@\n-    public final Name identity;\n@@ -271,1 +269,0 @@\n-        _default = fromString(\"default\");\n@@ -318,1 +315,0 @@\n-        identity = fromString(\"identity\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    public static final int ACC_STRICT        = 0x0800; \/\/                      method\n+    public static final int ACC_STRICT        = 0x0800; \/\/                      method, field\n@@ -133,1 +133,1 @@\n-        ACC_VOLATILE, ACC_TRANSIENT, ACC_SYNTHETIC, ACC_ENUM\n+        ACC_VOLATILE, ACC_TRANSIENT, ACC_SYNTHETIC, ACC_ENUM, ACC_STRICT\n@@ -215,2 +215,2 @@\n-            case 0x40:\n-                return (t == Kind.Class || t == Kind.InnerClass) ? \"value\" : \"volatile\";\n+            case ACC_VOLATILE:\n+                return \"volatile\";\n@@ -222,1 +222,1 @@\n-                return (t == Kind.Class || t == Kind.InnerClass) ? \"primitive\" : \"strictfp\";\n+                return (t == Kind.Field) ? \"strict\" : \"strictfp\";\n@@ -254,2 +254,2 @@\n-        case 0x800:\n-            return (t == Kind.Class || t == Kind.InnerClass) ? \"ACC_PRIMITIVE\" : \"ACC_STRICT\";\n+        case ACC_STRICT:\n+            return \"ACC_STRICT\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+                \"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature()),\n@@ -66,51 +67,0 @@\n-    @Test\n-    public void testIdentityClassModifiers(Path base) throws IOException {\n-        Path src = base.resolve(\"src\");\n-        tb.writeJavaFiles(src,\n-                \"package p; public identity class IdentityClass {}\");\n-\n-        javadoc(\"-d\", base.resolve(\"out\").toString(),\n-                \"-sourcepath\", src.toString(),\n-                \"p\");\n-        checkExit(Exit.OK);\n-\n-        checkOutput(\"p\/IdentityClass.html\", true,\n-                \"\"\"\n-                <div class=\"type-signature\"><span class=\"modifiers\">public identity class <\/span><span class=\"element-name type-name-label\">IdentityClass<\/span>\n-                \"\"\");\n-    }\n-\n-    @Test\n-    public void testValueInterfaceModifiers(Path base) throws IOException {\n-        Path src = base.resolve(\"src\");\n-        tb.writeJavaFiles(src,\n-                \"package p; public value interface ValueInterface {}\");\n-\n-        javadoc(\"-d\", base.resolve(\"out\").toString(),\n-                \"-sourcepath\", src.toString(),\n-                \"p\");\n-        checkExit(Exit.OK);\n-\n-        checkOutput(\"p\/ValueInterface.html\", true,\n-                \"\"\"\n-                <div class=\"type-signature\"><span class=\"modifiers\">public value interface <\/span><span class=\"element-name type-name-label\">ValueInterface<\/span><\/div>\n-                \"\"\");\n-    }\n-\n-    @Test\n-    public void testIdentityInterfaceModifiers(Path base) throws IOException {\n-        Path src = base.resolve(\"src\");\n-        tb.writeJavaFiles(src,\n-                \"package p; public identity interface IdentityInterface {}\");\n-\n-        javadoc(\"-d\", base.resolve(\"out\").toString(),\n-                \"-sourcepath\", src.toString(),\n-                \"p\");\n-        checkExit(Exit.OK);\n-\n-        checkOutput(\"p\/IdentityInterface.html\", true,\n-                \"\"\"\n-                <div class=\"type-signature\"><span class=\"modifiers\">public identity interface <\/span><span class=\"element-name type-name-label\">IdentityInterface<\/span><\/div>\n-                \"\"\");\n-    }\n-\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueClasses\/TestValueClasses.java","additions":1,"deletions":51,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-compiler.warn.preview.feature.use                       # preview feature support: not generated currently\n@@ -230,5 +229,2 @@\n-\n-# Primitive Classes\n-compiler.err.cyclic.primitive.class.membership\n-compiler.misc.feature.primitive.classes\n-compiler.err.generic.parameterization.with.primitive.class\n+compiler.misc.feature.super.init                            # temporary as we are using statements before super in value classes\n+compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n@@ -249,1 +245,1 @@\n-compiler.misc.attribute.only.applicable.to.fields                        # bad class file\n+compiler.misc.attribute.only.applicable.to.fields                        # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+<<<<<<<< HEAD:test\/langtools\/tools\/javac\/diags\/examples\/CantImplementInterface.java\n+\/\/ key: compiler.err.cant.implement.interface\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+class CantImplementInterface implements LooselyConsistentValue {\n+========\n+\/\/ key: compiler.err.call.must.only.appear.in.ctor\n+\n+class CallOnlyInConstructor {\n+    void foo() {\n+        super();\n+    }\n+>>>>>>>> lworld:test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.return.before.superclass.initialized\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class ReturnBeforeSuperclassInit {\n+    ReturnBeforeSuperclassInit(boolean maybe) {\n+        if (maybe)\n+            return;\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+ * @ignore\n@@ -67,1 +68,1 @@\n-    private static String[] DEFAULT_OPTIONS = {\"-XDenablePrimitiveClasses\"};\n+    private static String[] DEFAULT_OPTIONS = {};\n@@ -281,1 +282,1 @@\n-                value final class A {\n+                primitive final class A {\n@@ -452,1 +453,1 @@\n-            String[] testOptions = {\"-Xlint:all\", \"-XDenablePrimitiveClasses\"};\n+            String[] testOptions = {\"-Xlint:all\"};\n@@ -470,1 +471,1 @@\n-                value class PC {\n+                primitive class PC {\n@@ -538,1 +539,1 @@\n-            String[] testOptions = {\"-Xlint:all\", \"-XDenablePrimitiveClasses\"};\n+            String[] testOptions = {\"-Xlint:all\"};\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n- * @compile -XDenablePrimitiveClasses SideEffectTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses SideEffectTest\n- * @ignore 8316628\n+ * @compile SideEffectTest.java\n+ * @run main\/othervm -XX:+EnablePrimitiveClasses SideEffectTest\n+ * @ignore\n@@ -33,0 +33,1 @@\n+\n@@ -58,1 +59,1 @@\n-        V v = new V(false);\n+        V v = new V();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n- * @compile -XDenableNullRestrictedTypes ArrayCreationWithQuestion.java\n- * @run main ArrayCreationWithQuestion\n+ * @compile --enable-preview -source ${jdk.version} ArrayCreationWithQuestion.java\n+ * @run main\/othervm --enable-preview ArrayCreationWithQuestion\n@@ -54,0 +54,5 @@\n+\n+        VT() {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+        }\n@@ -65,4 +70,2 @@\n-                \"         7: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n-                \"        16: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n-                \"        30: invokestatic  #22                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n-                \"        47: invokestatic  #22                 \/\/ Method java\/lang\/reflect\/Array.newInstance:(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n+                \"         3: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        12: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDemitQDesc -XDenableNullRestrictedTypes AsSuperTests.java\n+ * @compile -XDenableNullRestrictedTypes AsSuperTests.java\n@@ -39,1 +39,1 @@\n-   work correctly with primitive types.\n+   work correctly with value classes.\n@@ -76,1 +76,1 @@\n-}\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AsSuperTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AsSuperTests.java","status":"renamed"},{"patch":"@@ -36,0 +36,2 @@\n+    public implicit CanonicalCtorTest();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Check behavior of synzhronized key word on value classes instances and methods.\n+ * @ignore\n+ * @compile\/fail\/ref=CheckSynchronized.out -XDrawDiagnostics CheckSynchronized.java\n+ *\/\n+\n+value final class CheckSynchronized implements java.io.Serializable {\n+    synchronized void foo() { \/\/ <<-- ERROR, no monitor associated with `this'\n+    }\n+    void goo() {\n+        synchronized(this) {} \/\/ <<-- ERROR, no monitor associated with `this'\n+    }\n+    synchronized static void zoo(CheckSynchronized cs) { \/\/ OK, static method.\n+        synchronized(cs) {    \/\/ <<-- ERROR, no monitor associated with value class instance.\n+        }\n+\n+        CheckSynchronized csr = cs;\n+        synchronized(csr) {\n+            \/\/ Error, no identity.\n+        }\n+\n+        synchronized(x) {\n+            \/\/ Error, no identity.\n+        }\n+\n+        Object o = cs;\n+        synchronized(o) {\n+            \/\/ Error BUT not discernible at compile time\n+        }\n+        java.io.Serializable jis = cs;\n+        synchronized(jis) {\n+            \/\/ Error BUT not discernible at compile time\n+        }\n+    }\n+    static int x = 10;\n+\n+    value record CheckSynchronizedRecord(int x, int y) {\n+        synchronized void foo() { \/\/ <<-- ERROR, no monitor associated with `this'\n+        }\n+        synchronized static void zoo() { \/\/ OK, static method.\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.out","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.out","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng ValueObjectCompilationTests\n+ * @run junit ValueObjectCompilationTests\n@@ -44,0 +44,1 @@\n+import java.util.Set;\n@@ -63,3 +64,1 @@\n-import static org.testng.Assert.assertTrue;\n-import org.testng.annotations.Test;\n-\n+import org.junit.jupiter.api.Test;\n@@ -70,2 +69,4 @@\n-@Test\n-public class ValueObjectCompilationTests extends CompilationTestCase {\n+class ValueObjectCompilationTests extends CompilationTestCase {\n+\n+    private static String[] PREVIEW_OPTIONS = {\"--enable-preview\", \"-source\",\n+            Integer.toString(Runtime.version().feature())};\n@@ -77,15 +78,2 @@\n-    public void testAbstractValueClassConstraints() {\n-        assertFail(\"compiler.err.instance.field.not.allowed\",\n-                \"\"\"\n-                abstract value class V {\n-                    int f;  \/\/ Error, abstract value class may not declare an instance field.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n-                \"\"\"\n-                class Outer {\n-                    abstract value class V {\n-                        \/\/ Error, an abstract value class cant be an inner class\n-                    }\n-                }\n-                \"\"\");\n+    @Test\n+    void testAbstractValueClassConstraints() {\n@@ -100,12 +88,0 @@\n-        assertFail(\"compiler.err.abstract.value.class.declares.init.block\",\n-                \"\"\"\n-                abstract value class V {\n-                    { int f = 42; } \/\/ Error, abstract value class may not declare an instance initializer.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n-                \"\"\"\n-                abstract value class V {\n-                    V(int x) {}  \/\/ Error, abstract value class may not declare a non-trivial constructor.\n-                }\n-                \"\"\");\n@@ -114,1 +90,2 @@\n-    public void testAnnotationsConstraints() {\n+    @Test\n+    void testValueModifierConstraints() {\n@@ -117,1 +94,1 @@\n-                identity @interface IA {}\n+                value @interface IA {}\n@@ -121,1 +98,1 @@\n-                value @interface IA {}\n+                value interface I {}\n@@ -123,5 +100,1 @@\n-    }\n-\n-    public void testCheckFeatureSourceLevel() {\n-        setCompileOptions(new String[]{\"--release\", \"13\"});\n-        assertFail(\"compiler.err.feature.not.supported.in.source.plural\",\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n@@ -129,2 +102,2 @@\n-                value class V {\n-                    public int v = 42;\n+                class Test {\n+                    value int x;\n@@ -133,5 +106,1 @@\n-        setCompileOptions(new String[]{});\n-    }\n-\n-    public void testSuperClassConstraints() {\n-        assertFail(\"compiler.err.instance.field.not.allowed\",\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n@@ -139,2 +108,2 @@\n-                abstract class I { \/\/ identity class since it declares an instance field.\n-                    int f;\n+                class Test {\n+                    value int foo();\n@@ -142,3 +111,1 @@\n-                value class V extends I {}\n-\n-        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n+        assertFail(\"compiler.err.mod.not.allowed.here\",\n@@ -147,4 +114,1 @@\n-                class Outer {\n-                    abstract class I {} \/\/ has identity since is an inner class\n-                    static value class V extends I\n-                }\n+                value enum Enum {}\n@@ -152,0 +116,1 @@\n+    }\n@@ -153,0 +118,2 @@\n+    @Test\n+    void testSuperClassConstraints() {\n@@ -155,1 +122,1 @@\n-                abstract class I { \/\/ has identity since it declared a synchronized instance method.\n+                abstract class I {\n@@ -160,16 +127,0 @@\n-\n-        assertFail(\"compiler.err.abstract.value.class.declares.init.block\",\n-                \"\"\"\n-                abstract class I { \/\/ has identity since it declares an instance initializer\n-                    { int f = 42; }\n-                }\n-                value class V extends I {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n-                \"\"\"\n-                abstract class I { \/\/ has identity since it declares a non-trivial constructor\n-                    I(int x) {}\n-                }\n-                value class V extends I {}\n-                \"\"\");\n@@ -182,4 +133,1 @@\n-    }\n-\n-    public void testSynchronizeOnValueInterfaceInstance() {\n-        assertFail(\"compiler.err.type.found.req\",\n+        assertOK(\n@@ -187,5 +135,1 @@\n-                value interface VI {\n-                    default void foo(VI vi) {\n-                        synchronized (vi) {} \/\/ Error\n-                    }\n-                }\n+                value record Point(int x, int y) {}\n@@ -195,9 +139,3 @@\n-    public void testRepeatedModifiers() {\n-        String[] sources = new String[] {\n-                \"static static class StaticTest {}\",\n-                \"native native class NativeTest {}\",\n-                \"value value class ValueTest {}\"\n-        };\n-        for (String source : sources) {\n-            assertFail(\"compiler.err.repeated.modifier\", source);\n-        }\n+    @Test\n+    void testRepeatedModifiers() {\n+        assertFail(\"compiler.err.repeated.modifier\", \"value value class ValueTest {}\");\n@@ -206,1 +144,2 @@\n-    public void testParserTest() {\n+    @Test\n+    void testParserTest() {\n@@ -248,1 +187,2 @@\n-    public void testSemanticsViolations() {\n+    @Test\n+    void testSemanticsViolations() {\n@@ -254,6 +194,0 @@\n-        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n-                \"\"\"\n-                class Outer {\n-                    abstract value class AbsValue {}\n-                }\n-                \"\"\");\n@@ -297,16 +231,0 @@\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                value identity class ValueIdentity {}\n-                \"\"\");\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                identity value class IdentityValue {}\n-                \"\"\");\n-        assertFail(\"compiler.err.call.to.super.not.allowed.in.value.ctor\",\n-                \"\"\"\n-                value class V {\n-                    V() {\n-                        super();\n-                    }\n-                }\n-                \"\"\");\n@@ -338,1 +256,1 @@\n-        assertFail(\"compiler.err.this.exposed.prematurely\",\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -349,1 +267,1 @@\n-        assertOK(\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n@@ -355,1 +273,1 @@\n-                        foo(this); \/\/ Ok.\n+                        foo(this); \/\/ error\n@@ -363,1 +281,1 @@\n-                value interface VI extends I {}\n+                interface VI extends I {}\n@@ -374,1 +292,1 @@\n-                value interface VI extends I {}\n+                interface VI extends I {}\n@@ -385,1 +303,1 @@\n-                value interface VI extends I {}\n+                abstract value class VI implements I {}\n@@ -389,71 +307,1 @@\n-                        synchronized ((I & VI)o) {} \/\/ error\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testNontrivialConstructor() {\n-        assertOK(\n-                \"\"\"\n-                abstract value class V {\n-                    public V() {} \/\/ trivial ctor\n-                }\n-                \"\"\"\n-        );\n-        assertFail(\"compiler.err.abstract.value.class.constructor.has.weaker.access\",\n-                \"\"\"\n-                abstract value class V {\n-                    private V() {} \/\/ non-trivial, more restrictive access than the class.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n-                \"\"\"\n-                abstract value class V {\n-                    public V(int x) {} \/\/ non-trivial ctor as it declares formal parameters.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.be.generic\",\n-                \"\"\"\n-                abstract value class V {\n-                    <T> V() {} \/\/ non trivial as it declares type parameters.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.throw\",\n-                \"\"\"\n-                abstract value class V {\n-                    V() throws Exception {} \/\/ non-trivial as it throws\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.no.arg.constructor.must.be.empty\",\n-                \"\"\"\n-                abstract value class V {\n-                    V() {\n-                        System.out.println(\"\");\n-                    } \/\/ non-trivial as it has a body.\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testFunctionalInterface() {\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                @FunctionalInterface\n-                identity interface I { \/\/ Error\n-                    void m();\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                @FunctionalInterface\n-                value interface K { \/\/ Error\n-                    void m();\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                identity interface L {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        var t = (L) () -> {}; \/\/ Error\n+                        synchronized ((VI & I)o) {} \/\/ error\n@@ -463,93 +311,0 @@\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                value interface M {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        var u = (M) () -> {}; \/\/ Error\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                identity interface I {\n-                    void m();\n-                }\n-\n-                @FunctionalInterface\n-                interface J extends I  {}\n-                \"\"\");\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                value interface I {\n-                    void m();\n-                }\n-\n-                @FunctionalInterface\n-                interface J extends I  {}\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                identity interface I {}\n-                interface K extends I {}\n-                interface J {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        J j = (J&K)() -> {};\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                value interface I {}\n-                interface K extends I {}\n-                interface J {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        J j = (J&K)() -> {};\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testSupers() {\n-        assertFail(\"compiler.err.mutually.incompatible.supers\",\n-                \"\"\"\n-                identity interface II {}\n-                value interface VI {}\n-                abstract class X implements II, VI {}\n-                \"\"\");\n-        assertFail(\"compiler.err.value.type.has.identity.super.type\",\n-                \"\"\"\n-                identity interface II {}\n-                interface GII extends II {} \/\/ OK.\n-                value interface BVI extends GII {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n-                \"\"\"\n-                value interface VI {}\n-                interface GVI extends VI {} \/\/ OK.\n-                identity interface BII extends GVI {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.value.type.has.identity.super.type\",\n-                \"\"\"\n-                identity interface II {}\n-                value class BVC implements II {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n-                \"\"\"\n-                value interface VI {}\n-                class BIC implements VI {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n-                \"\"\"\n-                value interface I {}\n-                class Test {\n-                    I i = new I() {};\n-                }\n-                \"\"\");\n@@ -558,1 +313,2 @@\n-    public void testInteractionWithSealedClasses() {\n+    @Test\n+    void testInteractionWithSealedClasses() {\n@@ -564,1 +320,2 @@\n-        );assertOK(\n+        );\n+        assertOK(\n@@ -566,1 +323,1 @@\n-                abstract sealed value interface SI {}\n+                abstract sealed interface SI {}\n@@ -572,4 +329,4 @@\n-                abstract sealed identity class SC {}\n-                final identity class IC extends SC {}\n-                non-sealed identity class IC2 extends SC {}\n-                final identity class IC3 extends IC2 {}\n+                abstract sealed class SC {}\n+                final class IC extends SC {}\n+                non-sealed class IC2 extends SC {}\n+                final class IC3 extends IC2 {}\n@@ -580,4 +337,4 @@\n-                abstract sealed identity interface SI {}\n-                final identity class IC implements SI {}\n-                non-sealed identity class IC2 implements SI {}\n-                final identity class IC3 extends IC2 {}\n+                abstract sealed interface SI {}\n+                final class IC implements SI {}\n+                non-sealed class IC2 implements SI {}\n+                final class IC3 extends IC2 {}\n@@ -586,1 +343,1 @@\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n@@ -592,1 +349,1 @@\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n+        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n@@ -594,2 +351,2 @@\n-                sealed value interface SI {}\n-                non-sealed value class VC implements SI {}\n+                sealed value class SI {}\n+                non-sealed value class VC extends SI {}\n@@ -600,1 +357,2 @@\n-    public void testCheckClassFileFlags() throws Exception {\n+    @Test\n+    void testCheckClassFileFlags() throws Exception {\n@@ -621,1 +379,0 @@\n-                    \/\/ abstract inner class is implicitly an `identity` class\n@@ -630,1 +387,1 @@\n-                    assertTrue((classFile.access_flags.flags & Flags.ACC_IDENTITY) != 0);\n+                    Assert.check((classFile.access_flags.flags & Flags.ACC_IDENTITY) != 0);\n@@ -637,2 +394,1 @@\n-                identity interface I {}\n-                class Sub implements I {}\n+                class C {}\n@@ -642,1 +398,0 @@\n-                    \/\/ declares a non-static field so it is implicitly an identity class\n@@ -648,1 +403,0 @@\n-                    \/\/ declares a synchronized method so it is implicitly an identity class\n@@ -654,1 +408,0 @@\n-                    \/\/ declares a synchronized method so it is implicitly an identity class\n@@ -661,1 +414,0 @@\n-                    \/\/ declares an instance initializer so it is implicitly an identity class\n@@ -667,1 +419,0 @@\n-                    \/\/ declares a non-trivial constructor\n@@ -674,3 +425,0 @@\n-                \"\"\"\n-                    identity enum E {}\n-                \"\"\",\n@@ -679,3 +427,0 @@\n-                \"\"\",\n-                \"\"\"\n-                   identity record R() {}\n@@ -687,2 +432,1 @@\n-                assertTrue(classFile.access_flags.is(Flags.ACC_IDENTITY));\n-                assertTrue(!classFile.access_flags.is(Flags.VALUE_CLASS));\n+                Assert.check(classFile.access_flags.is(Flags.ACC_IDENTITY));\n@@ -695,4 +439,3 @@\n-                            value interface I {}\n-                            abstract class A implements I {} \/\/ not a value class as it doens't have the value modifier\n-                            value class Sub extends A {} \/\/implicitly final\n-                            \"\"\";\n+                    abstract value class A {}\n+                    value class Sub extends A {} \/\/implicitly final\n+                    \"\"\";\n@@ -704,1 +447,1 @@\n-                        assertTrue((classFile.access_flags.flags & (Flags.VALUE_CLASS | Flags.FINAL)) != 0);\n+                        Assert.check((classFile.access_flags.flags & (Flags.FINAL)) != 0);\n@@ -707,4 +450,1 @@\n-                        assertTrue((classFile.access_flags.flags & (Flags.ABSTRACT)) != 0);\n-                        break;\n-                    case \"I\":\n-                        assertTrue((classFile.access_flags.flags & (Flags.INTERFACE | Flags.VALUE_CLASS)) != 0);\n+                        Assert.check((classFile.access_flags.flags & (Flags.ABSTRACT)) != 0);\n@@ -740,1 +480,2 @@\n-                        assertTrue(field.access_flags.is(Flags.FINAL));\n+                        Set<String> fieldFlags = field.access_flags.getFieldFlags();\n+                        Assert.check(fieldFlags.size() == 2 && fieldFlags.contains(\"ACC_FINAL\") && fieldFlags.contains(\"ACC_STRICT\"));\n@@ -747,1 +488,88 @@\n-    public void testSelectors() throws Exception {\n+    @Test\n+    void testConstruction() throws Exception {\n+        for (String source : List.of(\n+                \"\"\"\n+                value class Test {\n+                    int i = 100;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        i = 100;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        i = 100;\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                value class Test {\n+                    int i;\n+                    Test() {\n+                        this.i = 100;\n+                        super();\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,return,\";\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                for (Method method : classFile.methods) {\n+                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                        Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                        String foundCodeSequence = \"\";\n+                        for (Instruction inst: code.getInstructions()) {\n+                            foundCodeSequence += inst.getMnemonic() + \",\";\n+                        }\n+                        Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                    }\n+                }\n+            }\n+        }\n+\n+        String source =\n+                \"\"\"\n+                value class Test {\n+                    int i = 100;\n+                    int j;\n+                    {\n+                        j = 200;\n+                    }\n+                }\n+                \"\"\";\n+        String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,aload_0,sipush,putfield,return,\";\n+        File dir = assertOK(true, source);\n+        for (final File fileEntry : dir.listFiles()) {\n+            ClassFile classFile = ClassFile.read(fileEntry);\n+            for (Method method : classFile.methods) {\n+                if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                    String foundCodeSequence = \"\";\n+                    for (Instruction inst: code.getInstructions()) {\n+                        foundCodeSequence += inst.getMnemonic() + \",\";\n+                    }\n+                    Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                }\n+            }\n+        }\n+\n+        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+                \"\"\"\n+                value class Test {\n+                    Test() {\n+                        m();\n+                    }\n+                    void m() {}\n+                }\n+                \"\"\"\n+        );\n@@ -750,3 +578,8 @@\n-                value class V {\n-                    void selector() {\n-                        Class<?> c = int.class;\n+                class UnrelatedThisLeak {\n+                    value class V {\n+                        int f;\n+                        V() {\n+                            UnrelatedThisLeak x = UnrelatedThisLeak.this;\n+                            f = 10;\n+                            x = UnrelatedThisLeak.this;\n+                        }\n@@ -757,0 +590,4 @@\n+    }\n+\n+    @Test\n+    void testSelectors() throws Exception {\n@@ -761,1 +598,1 @@\n-                        int i = int.default;\n+                        Class<?> c = int.class;\n@@ -766,1 +603,1 @@\n-        assertFail(\"compiler.err.expected2\",\n+        assertFail(\"compiler.err.expected\",\n@@ -777,30 +614,12 @@\n-    public void testImplicitConstructor() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-XDenableNullRestrictedTypes\"};\n-            setCompileOptions(testOptions);\n-            assertOK(\n-                    \"\"\"\n-                    value class V {\n-                        public implicit V();\n-                    }\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.implicit.const.must.be.public\",\n-                    \"\"\"\n-                    value class V {\n-                        implicit V();\n-                    }\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.implicit.const.cant.have.body\",\n-                    \"\"\"\n-                    value class V {\n-                        public implicit V() {}\n-                    }\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.implicit.const.must.be.public\",\n-                    \"\"\"\n-                    value class V {\n-                        private implicit V();\n+    @Test\n+    void testAnonymousValue() throws Exception {\n+        assertOK(\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        Object o = new value Comparable<String>() {\n+                            @Override\n+                            public int compareTo(String o) {\n+                                return 0;\n+                            }\n+                        };\n@@ -808,6 +627,13 @@\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.implicit.const.must.be.public\",\n-                    \"\"\"\n-                    value class V {\n-                        protected implicit V();\n+                }\n+                \"\"\"\n+        );\n+        assertOK(\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        Object o = new value Comparable<>() {\n+                            @Override\n+                            public int compareTo(Object o) {\n+                                return 0;\n+                            }\n+                        };\n@@ -815,2 +641,4 @@\n-                    \"\"\"\n-            );\n+                }\n+                \"\"\"\n+        );\n+    }\n@@ -818,8 +646,6 @@\n-            assertFail(\"compiler.err.already.defined\",\n-                    \"\"\"\n-                    value class V {\n-                        public implicit V();\n-                        public V() {}\n-                    }\n-                    \"\"\"\n-            );\n+    @Test\n+    void testNullAssigment() throws Exception {\n+        assertOK(\n+                \"\"\"\n+                value final class V {\n+                    final int x = 10;\n@@ -827,12 +653,7 @@\n-            assertFail(\"compiler.err.implicit.const.must.be.declared.in.value.class\",\n-                    \"\"\"\n-                    class V {\n-                        public implicit V();\n-                    }\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.value.class.with.implicit.cannot.be.inner\",\n-                    \"\"\"\n-                    class Outer {\n-                        value class V {\n-                            public implicit V();\n+                    value final class X {\n+                        final V v;\n+                        final V v2;\n+\n+                        X() {\n+                            this.v = null;\n+                            this.v2 = null;\n@@ -840,19 +661,9 @@\n-                    }\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.value.class.with.implicit.cannot.be.inner\",\n-                    \"\"\"\n-                    class Outer {\n-                        new value class V() {\n-                            public implicit V();\n-                        };\n-                    }\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.value.class.with.implicit.cannot.be.inner\",\n-                    \"\"\"\n-                    class Outer {\n-                        void m() {\n-                            value class V {\n-                                public implicit V();\n-                            }\n+\n+                        X(V v) {\n+                            this.v = v;\n+                            this.v2 = v;\n+                        }\n+\n+                        V foo(X x) {\n+                            x = new X(null);  \/\/ OK\n+                            return x.v;\n@@ -861,15 +672,3 @@\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.cyclic.primitive.class.membership\",\n-                    \"\"\"\n-                    value class V {\n-                        V! v;\n-                        public implicit V();\n-                    }\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.value.class.with.implicit.instance.field.initializer\",\n-                    \"\"\"\n-                    value class V {\n-                        String s = \"\";\n-                        public implicit V();\n+                    V bar(X x) {\n+                        x = new X(null); \/\/ OK\n+                        return x.v;\n@@ -877,8 +676,10 @@\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.value.class.with.implicit.declares.init.block\",\n-                    \"\"\"\n-                    value class V {\n-                        String s;\n-                        {\n-                            s = \"\";\n+\n+                    class Y {\n+                        V v;\n+                        V [] va = { null }; \/\/ OK: array initialization\n+                        V [] va2 = new V[] { null }; \/\/ OK: array initialization\n+                        void ooo(X x) {\n+                            x = new X(null); \/\/ OK\n+                            v = null; \/\/ legal assignment.\n+                            va[0] = null; \/\/ legal.\n+                            va = new V[] { null }; \/\/ legal\n@@ -886,6 +687,3 @@\n-                        public implicit V();\n-                    \"\"\"\n-            );\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n+                }\n+                \"\"\"\n+        );\n@@ -927,85 +725,0 @@\n-\n-    public void testClassAttributes() throws Exception {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-XDenableNullRestrictedTypes\"};\n-            setCompileOptions(testOptions);\n-            String code =\n-                    \"\"\"\n-                    value class V0 {\n-                        public implicit V0();\n-                    }\n-\n-                    value class V1 {\n-                        V0! f1;\n-                        V0 f2;\n-                        V0[]! f3;\n-                        public implicit V1();\n-                    }\n-\n-                    value class V2 {\n-                        public V2() {}\n-                    }\n-                    \"\"\";\n-\n-            File dir = assertOK(true, code);\n-\n-            \/\/ test for V1\n-            ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"V1.class\"));\n-\n-            Field field1 = classFile.fields[0];\n-            findAttributeOrFail(field1.attributes, NullRestricted_attribute.class, 1);\n-            Field field2 = classFile.fields[1];\n-            try {\n-                findAttributeOrFail(field2.attributes, NullRestricted_attribute.class, 1);\n-                throw new AssertionError(\"NullRestricted attribute shouldn't be here\");\n-            } catch (Throwable t) {\n-                \/\/ good\n-            }\n-            Field field3 = classFile.fields[2];\n-            checkAttributeNotPresent(field3.attributes, NullRestricted_attribute.class);\n-            findAttributeOrFail(classFile.attributes, ImplicitCreation_attribute.class, 1);\n-\n-            classFile = ClassFile.read(findClassFileOrFail(dir, \"V2.class\"));\n-            try {\n-                findAttributeOrFail(classFile.attributes, ImplicitCreation_attribute.class, 1);\n-                throw new AssertionError(\"ImplicitCreation attribute shouldn't be here\");\n-            } catch (Throwable t) {\n-                \/\/ good\n-            }\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n-\n-    public void testImplementingLooselyConsistentValue() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-XDenableNullRestrictedTypes\"};\n-            setCompileOptions(testOptions);\n-            assertFail(\"compiler.err.cant.implement.interface\",\n-                    \"\"\"\n-                    class V implements LooselyConsistentValue {} \/\/ not a value class\n-                    \"\"\"\n-            );\n-            assertFail(\"compiler.err.cant.implement.interface\",\n-                    \"\"\"\n-                    value class V implements LooselyConsistentValue {} \/\/ no implicit constructor\n-                    \"\"\"\n-            );\n-            assertOK(\n-                    \"\"\"\n-                    abstract class V implements LooselyConsistentValue {}  \/\/ not concrete value class\n-                    \"\"\"\n-            );\n-            assertOK(\n-                    \"\"\"\n-                    value class V implements LooselyConsistentValue { \/\/ concrete value class with implicit constructor\n-                        public implicit V();\n-                    }\n-                    \"\"\"\n-            );\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":240,"deletions":527,"binary":false,"changes":767,"status":"modified"}]}