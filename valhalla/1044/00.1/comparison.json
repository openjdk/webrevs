{"files":[{"patch":"@@ -671,0 +671,12 @@\n+    \/**\n+     * Returns a {@code Class} object representing the null restricted type\n+     * of this class or interface.\n+     *\n+     * @return the {@code Class} representing the null restricted type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    public Class<?> asNullRestrictedType() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,0 +87,6 @@\n+    \/**\n+     * The modifier {@code implicit}\n+     * @since 21\n+     *\/\n+    IMPLICIT,\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    public static final int ACC_NON_ATOMIC = 0x0002;\n@@ -418,0 +419,5 @@\n+    \/**\n+     * Flag to indicate that a value class constructor is implicit\n+     *\/\n+    public static final int IMPLICIT    = 1<<59; \/\/ MethodSymbols\n+\n@@ -441,0 +447,1 @@\n+        ImplicitConstructorFlags          = PUBLIC | IMPLICIT,\n@@ -454,1 +461,1 @@\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS | IMPLICIT,\n@@ -481,0 +488,1 @@\n+            if (0 != (flags & IMPLICIT))        modifiers.add(Modifier.IMPLICIT);\n@@ -528,0 +536,1 @@\n+        IMPLICIT(Flags.IMPLICIT),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -358,0 +358,8 @@\n+        \/*if (isValueClassConst()) {\n+            \/\/ previously we had vnew methods which had a return type, not `void`, and we were attaching metadata to it\n+            \/\/ like nullness for example. Type `void` doesn't accept metadata so if we need to state that the result of\n+            \/\/ invoking a value class constructor is never null, we will need another way.\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }*\/\n@@ -469,0 +477,6 @@\n+    \/** Is this symbol an implicit constructor?\n+     *\/\n+    public boolean isImplicitConstructor() {\n+        return isConstructor() && ((flags() & IMPLICIT) != 0);\n+    }\n+\n@@ -1314,0 +1328,2 @@\n+        private boolean hasImplicitConstructor = false;\n+\n@@ -1657,0 +1673,29 @@\n+\n+        public boolean hasImplicitConstructor() {\n+            if (hasImplicitConstructor) {\n+                return true;\n+            } else {\n+                if (getImplicitConstructor() != null) {\n+                    hasImplicitConstructor = true;\n+                }\n+                return hasImplicitConstructor;\n+            }\n+        }\n+\n+        public void implicitConstructorFound() {\n+            hasImplicitConstructor = true;\n+        }\n+\n+        private MethodSymbol getImplicitConstructor() {\n+            for (Symbol s : members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case MTH:\n+                        if (s.isConstructor()) {\n+                            if (s.isImplicitConstructor()) {\n+                                return (MethodSymbol) s;\n+                            }\n+                        }\n+                }\n+            }\n+            return null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -250,0 +250,4 @@\n+    \/\/ for value objects\n+    public final Type looselyConsistentValueType;\n+    public final Type reflectArrayType;\n+\n@@ -648,0 +652,4 @@\n+        \/\/ for value objects\n+        looselyConsistentValueType = enterClass(\"java.lang.LooselyConsistentValue\");\n+        reflectArrayType = enterClass(\"java.lang.reflect.Array\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -242,0 +243,4 @@\n+    public boolean hasImplicitConstructor() {\n+        return false;\n+    }\n+\n@@ -538,0 +543,7 @@\n+        if (isNullable()) {\n+            sb.append(\"?\");\n+        } else if (isNonNullable()) {\n+            sb.append(\"!\");\n+        } else if (isParametric()) {\n+            sb.append(\"*\");\n+        }\n@@ -742,0 +754,31 @@\n+    \/\/ support for null-marked types\n+\n+    public Type asNullMarked(NullMarker nullMarker) {\n+        if (nullMarker == NullMarker.UNSPECIFIED) {\n+            return this;\n+        } else {\n+            return addMetadata(new TypeMetadata.NullMarker(nullMarker));\n+        }\n+    }\n+\n+    public boolean isNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NULLABLE;\n+    }\n+\n+    public boolean isNonNullable() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isParametric() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null && nm.nullMarker() == NullMarker.PARAMETRIC;\n+    }\n+\n+    public boolean isNullUnspecified() {\n+        return getMetadata(TypeMetadata.NullMarker.class) == null;\n+    }\n+\n+    \/\/ end of support for null-marked types\n+\n@@ -1103,0 +1146,8 @@\n+            if (isNullable()) {\n+                buf.append(\"?\");\n+            } else if (isNonNullable()) {\n+                buf.append(\"!\");\n+            } else if (isParametric()) {\n+                buf.append(\"*\");\n+            }\n+\n@@ -1183,0 +1234,5 @@\n+        @Override\n+        public boolean hasImplicitConstructor() {\n+            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).hasImplicitConstructor();\n+        }\n+\n@@ -1413,0 +1469,7 @@\n+                if (t.isNullable()) {\n+                    sb.append(\"?\");\n+                } else if (t.isNonNullable()) {\n+                    sb.append(\"!\");\n+                } else if (t.isParametric()) {\n+                    sb.append(\"*\");\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -128,0 +130,2 @@\n+        Options options = Options.instance(context);\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -1085,1 +1089,4 @@\n-        if (t.equalsIgnoreMetadata(s))\n+        if (t.equalsIgnoreMetadata(s)) {\n+            if (allowNullRestrictedTypes) {\n+                new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+            }\n@@ -1087,0 +1094,1 @@\n+        }\n@@ -1111,2 +1119,2 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n-        {\n+        private IsSubtype isSubtype = new IsSubtype();\n+        class IsSubtype extends TypeRelation {\n@@ -1127,1 +1135,4 @@\n-                 case BOT:\n+                 case BOT: {\n+                     if (s.isNonNullable()) {\n+                         return false;\n+                     }\n@@ -1129,2 +1140,3 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1195,1 +1207,1 @@\n-                return sup.tsym == s.tsym\n+                boolean result = sup.tsym == s.tsym\n@@ -1200,0 +1212,4 @@\n+                if (result && allowNullRestrictedTypes) {\n+                    new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+                }\n+                return result;\n@@ -1240,1 +1256,47 @@\n-        };\n+        }\n+\n+        public class NullabilityComparator extends TypeRelation {\n+            BiFunction<Type, Type, Boolean> differentNullability;\n+\n+            NullabilityComparator(BiFunction<Type, Type, Boolean> differentNullability) {\n+                this.differentNullability = differentNullability;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return s != null && (!s.isParameterized() || compareTypeArgsRecursive(t, s))\n+                            && visit(t.getEnclosingType(), s.getEnclosingType());\n+                }\n+            }\n+            \/\/ where\n+            boolean compareTypeArgsRecursive(Type t, Type s) {\n+                return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    if (visit(ts.head, ss.head)) {\n+                        return true;\n+                    }\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return false;\n+            }\n+        }\n@@ -1427,3 +1489,7 @@\n-                return t.tsym == s.tsym\n-                    && visit(t.getEnclosingType(), s.getEnclosingType())\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                boolean equal = t.tsym == s.tsym\n+                        && visit(t.getEnclosingType(), s.getEnclosingType())\n+                        && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                if (equal && allowNullRestrictedTypes) {\n+                    new NullabilityComparator((t1, t2) -> !hasSameNullability(t1, t2)).visit(s, t);\n+                }\n+                return equal;\n@@ -1746,1 +1812,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT) && (!t.hasImplicitConstructor() || !t.isNonNullable()))\n@@ -2156,0 +2222,10 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n+    }\n+    \/\/ <\/editor-fold>\n+\n@@ -2821,1 +2897,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -5292,0 +5377,28 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null) {\n+            return t.isNullUnspecified();\n+        }\n+        if (t.isNullUnspecified()) {\n+            return s.isNullUnspecified();\n+        }\n+        if (t.isNonNullable()) {\n+            return s.isNonNullable();\n+        }\n+        throw new AssertionError(\"shouldn't get here\");\n+    }\n+\n+    \/**\n+     * Does t has narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (t.isNonNullable()) {\n+            return s != null && !s.isNonNullable();\n+        }\n+        return false;\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":126,"deletions":13,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -186,0 +187,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -219,0 +221,4 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n@@ -734,0 +740,5 @@\n+        if (allowNullRestrictedTypes &&\n+                tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -1169,0 +1180,8 @@\n+            if (allowNullRestrictedTypes && tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1331,0 +1350,13 @@\n+            if (allowNullRestrictedTypes) {\n+                Type elemOrType = result;\n+                while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                    elemOrType = types.elemtype(elemOrType);\n+                }\n+                if ((result.isNonNullable() || elemOrType.isNonNullable()) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor())) {\n+                    log.error(tree.pos(),\n+                            types.elemtype(result) == null?\n+                                    Errors.TypeCantBeNullRestricted(result) :\n+                                    Errors.TypeCantBeNullRestricted2(result)\n+                    );\n+                }\n+            }\n@@ -2890,1 +2922,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -2892,0 +2924,4 @@\n+                if (allowNullRestrictedTypes && owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -4380,0 +4416,9 @@\n+        \/\/ check nullness of site\n+        if (site.isNullable()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (site.isParametric()) {\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -4692,0 +4737,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5339,0 +5389,6 @@\n+            if (c.type.isValueClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (allowNullRestrictedTypes &&\n+                        env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -188,0 +189,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -235,0 +237,3 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n@@ -309,0 +314,10 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnNullableTypes(DiagnosticPosition pos, Warning warnKey) {\n+        if (allowNullRestrictedTypes && lint.isEnabled(LintCategory.NULL)) {\n+            log.warning(LintCategory.NULL, pos, warnKey);\n+        }\n+    }\n+\n@@ -681,3 +696,6 @@\n-                if (lint.isEnabled(LintCategory.CAST))\n-                    log.warning(LintCategory.CAST,\n-                            tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                if (lint.isEnabled(LintCategory.CAST)) {\n+                    if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n+                        log.warning(LintCategory.CAST,\n+                                tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                    }\n+                }\n@@ -710,1 +728,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -715,1 +733,11 @@\n-             return types.isSubtype(a, bound);\n+             try {\n+                 if (pos != null) {\n+                     types.pushWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.popWarner();\n+                 }\n+             }\n+\n@@ -769,0 +797,1 @@\n+        checkConstraintsOfValueClassesWithImplicitConst(tree, c);\n@@ -792,0 +821,24 @@\n+    void checkConstraintsOfValueClassesWithImplicitConst(JCClassDecl classDecl, ClassSymbol c) {\n+        if (allowNullRestrictedTypes) {\n+            JCMethodDecl implicitConstructor = TreeInfo.getImplicitConstructor(classDecl.defs);\n+            if (implicitConstructor != null) {\n+                Type encl = c.type.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitCannotBeInner(c));\n+                }\n+                \/*if ((c.flags() & HASINITBLOCK) != 0) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitDeclaresInitBlock(c));\n+                }*\/\n+                for (Symbol s : c.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0 & (s.flags() & HASINIT) != 0) {\n+                                log.error(classDecl.pos(), Errors.ValueClassWithImplicitInstanceFieldInitializer(c));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1153,1 +1206,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1156,1 +1213,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1193,1 +1250,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1277,1 +1334,9 @@\n-                } else\n+                } else if ((flags & IMPLICIT) != 0) {\n+                    if ((flags & PUBLIC) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBePublic);\n+                    }\n+                    if ((sym.owner.flags_field & VALUE_CLASS) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBeDeclaredInValueClass);\n+                    }\n+                    mask = ImplicitConstructorFlags;\n+                } else {\n@@ -1279,0 +1344,1 @@\n+                }\n@@ -1542,1 +1608,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1949,0 +2015,9 @@\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+        }\n+        overrideWarner.remove(LintCategory.NULL);\n+        \/\/ at this point we know this will be true but to gather the warnings\n+        types.isSubSignature(mt, ot, overrideWarner);\n+        if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+        }\n@@ -2425,0 +2500,41 @@\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n+    \/\/ TODO, update this method once we have null restricted types\n+    void checkNonCyclicMembership(JCClassDecl tree) {\n+        if (!tree.sym.type.hasImplicitConstructor()) {\n+            return;\n+        }\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                    }\n+                }\n+            }\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n+            return;\n+        }\n+        try {\n+            c.flags_field |= LOCKED;\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+        \/\/ where\n+        private boolean cyclePossible(VarSymbol symbol) {\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n+        }\n+\n@@ -2674,0 +2790,6 @@\n+        boolean implementsLooselyConsistentValue = false;\n+        try {\n+            implementsLooselyConsistentValue = allowValueClasses && allowNullRestrictedTypes ? types.asSuper(c, syms.looselyConsistentValueType.tsym) != null : false;\n+        } catch (CompletionFailure cf) {\n+            \/\/ ignore\n+        }\n@@ -2675,0 +2797,6 @@\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        if (c.getKind() == TypeKind.DECLARED && implementsLooselyConsistentValue && !c.tsym.isAbstract()) {\n+            if (!cIsValue || !((ClassSymbol)c.tsym).hasImplicitConstructor()) {\n+                log.error(pos, Errors.CantImplementInterface(c.tsym));\n+            }\n+        }\n@@ -4439,0 +4567,22 @@\n+    private class NullnessWarner extends Warner {\n+        public NullnessWarner(DiagnosticPosition pos) {\n+            super(pos);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (allowNullRestrictedTypes) {\n+                boolean warned = this.warned;\n+                super.warn(lint);\n+                if (warned) return; \/\/ suppress redundant diagnostics\n+                switch (lint) {\n+                    case NULL:\n+                        Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                        break;\n+                    default:\n+                        throw new AssertionError(\"Unexpected lint: \" + lint);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -4467,0 +4617,3 @@\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    break;\n@@ -4470,0 +4623,21 @@\n+            this.warned = true;\n+        }\n+    }\n+\n+    private class CastWarner extends ConversionWarner {\n+        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n+            super(pos, key, found, expected);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (lint != LintCategory.NULL) {\n+                super.warn(lint);\n+            } else {\n+                boolean warned = this.warned;\n+                if (warned) return;\n+                if (expected.isParametric()) {\n+                    \/\/ not sure this is the right warning\n+                    Check.this.warnNullableTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                }\n+            }\n@@ -4474,1 +4648,1 @@\n-        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":185,"deletions":11,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2123,1 +2123,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedNonNullableOrParametricField(sym));\n@@ -2136,0 +2137,7 @@\n+        boolean isUninitializedNonNullableOrParametricField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            (sym.type.isNonNullable() || sym.type.isParametric()));\n+        }\n+\n@@ -2224,0 +2232,9 @@\n+                if (isUninitializedNonNullableOrParametricField(sym)) {\n+                    if (lint.isEnabled(Lint.LintCategory.NULL)) {\n+                        if (sym.type.isNonNullable()) {\n+                            log.warning(pos, Warnings.NonNullableShouldBeInitialized);\n+                        } else {\n+                            log.warning(pos, Warnings.ParametricShouldBeInitialized);\n+                        }\n+                    }\n+                } else {\n@@ -2225,0 +2242,1 @@\n+                }\n@@ -2468,1 +2486,1 @@\n-                                } else {\n+                                } else if (!tree.sym.isImplicitConstructor()) { \/\/ implicit constructors are special, ignore them\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final boolean allowNullRestrictedTypes;\n@@ -136,0 +137,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -4202,0 +4204,2 @@\n+        \/\/ nullness info could be lost in the translation process, let's keep the original element type\n+        JCExpression originalElemType = tree.elemtype;\n@@ -4203,1 +4207,2 @@\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n+        int noOfDims = 0;\n+        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail) {\n@@ -4205,0 +4210,2 @@\n+            noOfDims++;\n+        }\n@@ -4206,1 +4213,26 @@\n-        result = tree;\n+        if (emitQDesc || !allowNullRestrictedTypes || tree.elemtype == null || !originalElemType.type.isNonNullable()) {\n+            result = tree;\n+        } else {\n+            Symbol elemClass = syms.getClassField(tree.elemtype.type, types);\n+            JCFieldAccess elemClassExpr = make.Select(make.Ident(tree.elemtype.type.tsym).setType(tree.elemtype.type), elemClass);\n+            MethodSymbol asNullRestrictedTypeMeth = lookupMethod(tree.pos(), names.asNullRestrictedType, syms.classType, List.nil());\n+            JCExpression asNullRestrictedTypeCall = make.Apply(\n+                        null,\n+                        make.Select(elemClassExpr, asNullRestrictedTypeMeth).setType(syms.classType), List.nil()).setType(syms.classType);\n+            List<JCExpression> dimsExp = tree.dims;\n+            if (noOfDims > 1) {\n+                JCNewArray dimsArr = make.NewArray(make.Type(syms.intType), List.nil(), tree.dims);\n+                dimsArr.type = types.makeArrayType(syms.intType);\n+                dimsExp = List.of(dimsArr);\n+            }\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.newInstance,\n+                syms.reflectArrayType, List.of(syms.classType, noOfDims == 1 ? syms.intType : types.makeArrayType(syms.intType)));\n+            JCExpression call =\n+                    make.Apply(\n+                            null,\n+                            make.Select(make.Ident(syms.reflectArrayType.tsym).setType(syms.reflectArrayType), appyMeth).setType(syms.objectType),\n+                            dimsExp.prepend(asNullRestrictedTypeCall))\n+                            .setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(types.makeArrayType(tree.elemtype.type, noOfDims), call);\n+            result = cast;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -42,0 +43,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -60,0 +62,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1317,0 +1317,33 @@\n+            new AttributeReader(names.ImplicitCreation, V66, CLASS_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (((ClassSymbol)sym).hasImplicitConstructor()) { \/\/ there can only be one per class\n+                        throw badClassFile(\"attribute.must.be.unique\", names.ImplicitCreation);\n+                    }\n+                    if (sym.kind == TYP) {\n+                        nextChar();\n+                        ((ClassSymbol)sym).implicitConstructorFound();\n+                    }\n+                }\n+            },\n+            new AttributeReader(names.NullRestricted, V66, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind != VAR) {\n+                        throw badClassFile(\"attribute.only.applicable.to.fields\", names.NullRestricted);\n+                    }\n+                    if (sym.type.isPrimitive() || sym.type.hasTag(TypeTag.ARRAY)) {\n+                        throw badClassFile(\"attribute.not.applicable.to.field.type\", names.NullRestricted, sym.type);\n+                    }\n+                    if (sym.type.isNonNullable()) {\n+                        throw badClassFile(\"attribute.must.be.unique\", names.NullRestricted);\n+                    }\n+                    sym.type = sym.type.asNullMarked(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL);\n+                }\n+            },\n@@ -2630,0 +2663,11 @@\n+        if (names.isInit(name) && ((flags & STATIC) != 0)) {\n+            flags &= ~STATIC;\n+            type = new MethodType(type.getParameterTypes(),\n+                    syms.voidType,\n+                    type.getThrownTypes(),\n+                    syms.methodClass);\n+            if (((ClassSymbol)currentOwner).hasImplicitConstructor() && type.getParameterTypes().size() == 0) {\n+                \/\/ this has to be the implicit constructor\n+                flags |= IMPLICIT;\n+            }\n+        }\n@@ -3132,0 +3176,2 @@\n+        \/\/ we need to do some checks now that the class has been loaded\n+        checkNonCyclicMembership(c);\n@@ -3407,0 +3453,51 @@\n+\n+    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n+    void checkNonCyclicMembership(ClassSymbol csym) {\n+        if (!allowValueClasses || !csym.type.hasImplicitConstructor()) {\n+            \/\/ nothing to see here\n+            return;\n+        }\n+        Assert.check((csym.flags_field & LOCKED) == 0);\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(field);\n+            }\n+            csym.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            csym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            JavaFileObject prevSource = log.useSource(currentClassFile);\n+            try {\n+                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n+                return;\n+            } finally {\n+                log.useSource(prevSource);\n+            }\n+        }\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(fld);\n+            }\n+            c.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private boolean cyclePossible(VarSymbol symbol) {\n+        return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+    \/** Switch: are null-restricted types allowed\n+     *\/\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -144,0 +148,2 @@\n+    private final Symtab syms;\n+\n@@ -178,0 +184,1 @@\n+        syms = Symtab.instance(context);\n@@ -193,0 +200,1 @@\n+        allowNullRestrictedTypes = options.isSet(\"enableNullRestrictedTypes\");\n@@ -377,0 +385,3 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeNullRestrictedIfNeeded(sym);\n+        }\n@@ -838,1 +849,1 @@\n-            int flags = adjustFlags(inner.flags_field);\n+            int flags = adjustFlags(inner, inner.flags_field);\n@@ -948,0 +959,24 @@\n+    \/** Write \"ImplicitCreation\" attribute.\n+     *\/\n+    int writeImplicitCreationIfNeeded(ClassSymbol csym) {\n+        if (allowNullRestrictedTypes && csym.isValueClass() && csym.hasImplicitConstructor()) {\n+            int alenIdx = writeAttr(names.ImplicitCreation);\n+            int flags = ACC_DEFAULT | (csym.isSubClass(syms.looselyConsistentValueType.tsym, types) ? ACC_NON_ATOMIC : 0);\n+            databuf.appendChar(flags);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/** Write \"NullRestricted\" attribute.\n+     *\/\n+    int writeNullRestrictedIfNeeded(Symbol sym) {\n+        if (allowNullRestrictedTypes && sym.kind == VAR && sym.type.isNonNullable() && !sym.type.hasTag(ARRAY)) {\n+            int alenIdx = writeAttr(names.NullRestricted);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n@@ -979,1 +1014,1 @@\n-        int flags = adjustFlags(v.flags());\n+        int flags = adjustFlags(v, v.flags());\n@@ -1008,1 +1043,1 @@\n-        int flags = adjustFlags(m.flags());\n+        int flags = adjustFlags(m, m.flags());\n@@ -1293,0 +1328,4 @@\n+                if (debugstackmap) System.out.print(\"object(\" + types.erasure(t).tsym + \")\");\n+                databuf.appendByte(7);\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n+                break;\n@@ -1724,0 +1763,4 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeImplicitCreationIfNeeded(c);\n+        }\n+\n@@ -1769,1 +1812,1 @@\n-    int adjustFlags(final long flags) {\n+    int adjustFlags(Symbol sym, final long flags) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":47,"deletions":4,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private static final Object[] NO_STATIC_ARGS = new Object[0];\n@@ -895,0 +896,4 @@\n+            if (pts.head.isNonNullable() && !l.head.type.isNonNullable()) {\n+                code.emitop0(dup);\n+                genNullCheck(l.head);\n+            }\n@@ -1042,0 +1047,2 @@\n+                selfType = selfType.hasImplicitConstructor() ?\n+                        selfType.addMetadata(new TypeMetadata.NullMarker(JCNullableTypeExpression.NullMarker.NOT_NULL)) : selfType;\n@@ -1074,0 +1081,4 @@\n+                if (tree.type.isNonNullable() && !tree.init.type.isNonNullable()) {\n+                    code.emitop0(dup);\n+                    genNullCheck(tree.init);\n+                }\n@@ -2074,0 +2085,4 @@\n+        if (tree.lhs.type.isNonNullable() && !tree.rhs.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.rhs);\n+        }\n@@ -2279,0 +2294,4 @@\n+        if (tree.clazz.type.isNonNullable() && !tree.expr.type.isNonNullable()) {\n+            code.emitop0(dup);\n+            genNullCheck(tree.expr);\n+        }\n@@ -2349,1 +2368,2 @@\n-            code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));\n+            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type,\n+                    tree.selected.type.hasImplicitConstructor() && tree.selected.type.isNonNullable()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -200,0 +201,1 @@\n+        this.allowNullRestrictedTypes = fac.options.isSet(\"enableNullRestrictedTypes\");\n@@ -224,0 +226,1 @@\n+        this.allowNullRestrictedTypes = parser.allowNullRestrictedTypes;\n@@ -269,0 +272,4 @@\n+    \/** Switch: are null-restricted types allowed?\n+     *\/\n+    boolean allowNullRestrictedTypes;\n+\n@@ -279,0 +286,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -286,0 +294,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -304,1 +313,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -308,1 +317,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -703,0 +712,4 @@\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            setNullMarker(t);\n+            nextToken();\n+        }\n@@ -1140,1 +1153,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (allowNullRestrictedTypes && token.kind == QUES && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1321,0 +1345,1 @@\n+        boolean emotionalMarkersOK = false;\n@@ -1470,0 +1495,6 @@\n+                if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    emotionalMarkersOK = true;\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1489,0 +1520,4 @@\n+                            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                setNullMarker(t);\n+                                nextToken();\n+                            }\n@@ -1616,0 +1651,10 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (token.kind == QUES || token.kind == BANG || (token.kind == STAR))) {\n+                if (peekToken(LBRACKET) || peekToken(LT) || emotionalMarkersOK) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                } else {\n+                    \/\/ not a type\n+                    break;\n+                }\n+            }\n@@ -1732,1 +1777,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (allowNullRestrictedTypes && isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1741,0 +1791,4 @@\n+                        if (allowNullRestrictedTypes && isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1825,0 +1879,13 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        ((JCNullableTypeExpression)exp).setNullMarker(\n+                tk.kind == QUES ?\n+                        NullMarker.NULLABLE :\n+                        token.kind == BANG ?\n+                                NullMarker.NOT_NULL :\n+                                NullMarker.PARAMETRIC);\n+    }\n+\n@@ -1889,1 +1956,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -1957,0 +2024,15 @@\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW))) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET)) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -1979,0 +2061,1 @@\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -1981,0 +2064,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -1983,0 +2067,6 @@\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2001,0 +2091,1 @@\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2060,0 +2151,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -2399,0 +2494,6 @@\n+        } else if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && peekToken(LBRACKET)) {\n+            Token nullMarker = token;\n+            nextToken();\n+            int pos = token.pos;\n+            nextToken();\n+            t = bracketsOptCont(t, pos, nextLevelAnnotations, nullMarker);\n@@ -2421,0 +2522,5 @@\n+        return bracketsOptCont(t, pos, annotations, null);\n+    }\n+\n+    private JCExpression bracketsOptCont(JCExpression t, int pos,\n+                                         List<JCAnnotation> annotations, Token nullMarker) {\n@@ -2424,0 +2530,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -3339,0 +3448,13 @@\n+                    } \/*else if (typeDepth == 0 && allowNullRestrictedTypes &&\n+                            ((peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) ) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } *\/else if ( allowNullRestrictedTypes &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) ) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3353,0 +3475,2 @@\n+                case BANG:\n+                    if (allowNullRestrictedTypes && !peekToken(lookahead, LPAREN)) break;\n@@ -3532,0 +3656,4 @@\n+                if (allowNullRestrictedTypes && isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3805,0 +3933,7 @@\n+        if (name == names.implicit) {\n+            if (allowNullRestrictedTypes && allowValueClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":140,"deletions":5,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -3210,0 +3210,3 @@\n+compiler.misc.feature.bang.types=\\\n+    bang types\n+\n@@ -4068,0 +4071,39 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n+# 0: symbol, 1: type\n+compiler.misc.superclass.of.value.class=\\\n+    The super class {1} of the value class {0}\n+\n+# 0: symbol\n+compiler.misc.abstract.value.class=\\\n+    The abstract value class {0}\n+\n+compiler.err.call.to.super.not.allowed.in.value.ctor=\\\n+    call to super not allowed in value class constructor\n+\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n+compiler.err.implicit.const.must.be.public=\\\n+    implicit constructors must be public\n+\n+compiler.err.implicit.const.must.be.declared.in.value.class=\\\n+    only value classes can declare implicit constructors\n+\n+# 0: symbol\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n+     be value classes and declare an implicit constructor.\n+\n@@ -4092,0 +4134,51 @@\n+\n+### null-restricted types\n+\n+compiler.err.non.nullable.cannot.be.assigned.null=\\\n+    non-nullable type cannot be assigned null\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    it must be a value class with an implicit constructor\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted.2=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    its element type must be a value class with an implicit constructor\n+\n+# 0: name\n+compiler.misc.attribute.must.be.unique=\\\n+    attribute {0} must be unique\n+\n+# 0: name\n+compiler.misc.attribute.only.applicable.to.fields=\\\n+    attribute {0} is only applicable to fields\n+\n+# 0: name, 1: type\n+compiler.misc.attribute.not.applicable.to.field.type=\\\n+    attribute {0} is not applicable to {1}\n+\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+compiler.warn.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2569,1 +2569,1 @@\n-    public static class JCFieldAccess extends JCExpression implements MemberSelectTree {\n+    public static class JCFieldAccess extends JCNullableTypeExpression implements MemberSelectTree {\n@@ -2706,1 +2706,1 @@\n-    public static class JCIdent extends JCExpression implements IdentifierTree {\n+    public static class JCIdent extends JCNullableTypeExpression implements IdentifierTree {\n@@ -2815,1 +2815,1 @@\n-    public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {\n+    public static class JCArrayTypeTree extends JCNullableTypeExpression implements ArrayTypeTree {\n@@ -2840,1 +2840,1 @@\n-    public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {\n+    public static class JCTypeApply extends JCNullableTypeExpression implements ParameterizedTypeTree {\n@@ -2898,0 +2898,34 @@\n+    \/**\n+     * A nullable type expression. Supported nullable expression types are: simple type names,\n+     * qualified type names, parameterized types and array types.\n+     *\/\n+\n+    public static abstract class JCNullableTypeExpression extends JCExpression {\n+        private NullMarker nullMarker = NullMarker.UNSPECIFIED;\n+\n+        public NullMarker getNullMarker() {\n+            return nullMarker;\n+        }\n+\n+        public void setNullMarker(NullMarker nullMarker) {\n+            this.nullMarker = nullMarker;\n+        }\n+\n+        public enum NullMarker {\n+            NOT_NULL(\"!\"),\n+            NULLABLE(\"?\"),\n+            PARAMETRIC(\"*\"),\n+            UNSPECIFIED(\"\");\n+\n+            private final String typeSuffix;\n+\n+            NullMarker(String typeSuffix) {\n+                this.typeSuffix = typeSuffix;\n+            }\n+\n+            public String typeSuffix() {\n+                return typeSuffix;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+                if (tree instanceof JCNullableTypeExpression nullableType) {\n+                    print(nullableType.getNullMarker().typeSuffix());\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -117,0 +117,6 @@\n+    public static JCMethodDecl getImplicitConstructor(List<JCTree> trees) {\n+        for (List<JCTree> l = trees; l.nonEmpty(); l = l.tail)\n+            if (isConstructor(l.head) && (((JCMethodDecl)l.head).mods.flags & IMPLICIT) != 0) return (JCMethodDecl) l.head;\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+    public final Name ImplicitCreation;\n+    public final Name NullRestricted;\n@@ -245,0 +247,5 @@\n+    \/\/ value classes\n+    public final Name implicit;\n+    public final Name newInstance;\n+    public final Name asNullRestrictedType;\n+\n@@ -376,0 +383,2 @@\n+        ImplicitCreation = fromString(\"ImplicitCreation\");\n+        NullRestricted = fromString(\"NullRestricted\");\n@@ -440,0 +449,5 @@\n+\n+        \/\/value classes\n+        implicit = fromString(\"implicit\");\n+        newInstance = fromString(\"newInstance\");\n+        asNullRestrictedType = fromString(\"asNullRestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -64,1 +64,4 @@\n-    public static enum Kind { Class, InnerClass, Field, Method}\n+    public static final int ACC_DEFAULT       = 0x0001; \/\/ ImplicitCreation attribute\n+    public static final int ACC_NON_ATOMIC    = 0x0002; \/\/ ImplicitCreation attribute\n+\n+    public static enum Kind { Class, InnerClass, Field, Method, ImplicitCreationAttr}\n@@ -160,0 +163,6 @@\n+    private static final int[] implicitCreationAttrFlags = { ACC_DEFAULT, ACC_NON_ATOMIC };\n+\n+    public Set<String> getImplicitCreationAttrFlags() {\n+        return getFlags(implicitCreationAttrFlags, Kind.ImplicitCreationAttr);\n+    }\n+\n@@ -224,1 +233,1 @@\n-            return \"ACC_PUBLIC\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_DEFAULT\" : \"ACC_PUBLIC\";\n@@ -226,1 +235,1 @@\n-            return \"ACC_PRIVATE\";\n+            return t == Kind.ImplicitCreationAttr ? \"ACC_NON_ATOMIC\" : \"ACC_PRIVATE\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -66,0 +66,24 @@\n+\n+    @Test\n+    public void testImplicitConstModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+\n+                public value class ValueClassWithImplicitConst {\n+                    public implicit ValueClassWithImplicitConst();\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"-XDenableNullRestrictedTypes\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueClassWithImplicitConst.html\", true,\n+                \"\"\"\n+                <div class=\"member-signature\"><span class=\"modifiers\">public implicit<\/span>&nbsp;<span class=\"element-name\">ValueClassWithImplicitConst<\/span>()<\/div>\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueClasses\/TestValueClasses.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -230,1 +230,16 @@\n-compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n+compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n+\n+#nullable types\n+compiler.misc.feature.bang.types\n+compiler.warn.accessing.member.of.nullable\n+compiler.warn.narrowing.nullness.conversion\n+compiler.warn.non.nullable.should.be.initialized\n+compiler.warn.accessing.member.of.parametric\n+compiler.warn.parametric.should.be.initialized\n+compiler.err.non.nullable.cannot.be.assigned.null\n+compiler.warn.unchecked.nullness.conversion\n+compiler.warn.overrides.with.different.nullness.1\n+compiler.warn.overrides.with.different.nullness.2\n+compiler.misc.attribute.must.be.unique                                   # bad class file\n+compiler.misc.attribute.not.applicable.to.field.type                     # bad class file\n+compiler.misc.attribute.only.applicable.to.fields                        # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+<<<<<<<< HEAD:test\/langtools\/tools\/javac\/diags\/examples\/CantImplementInterface.java\n+\/\/ key: compiler.err.cant.implement.interface\n+\/\/ options: -XDenableNullRestrictedTypes\n+\n+class CantImplementInterface implements LooselyConsistentValue {\n+========\n@@ -30,0 +36,1 @@\n+>>>>>>>> lworld:test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-                primitive class PC extends GoodSuper implements GoodSuperInterface {}\n+                value class PC extends GoodSuper implements GoodSuperInterface {}\n@@ -93,1 +93,1 @@\n-                primitive class PC extends Integer {}\n+                value class PC extends Integer {}\n@@ -98,1 +98,1 @@\n-                primitive class PC extends Number {\n+                value class PC extends Number {\n@@ -111,1 +111,1 @@\n-                primitive class PC extends SuperWithStaticField {}\n+                value class PC extends SuperWithStaticField {}\n@@ -129,1 +129,1 @@\n-                primitive class PC extends SuperWithEmptyNoArgCtor_02 {}\n+                value class PC extends SuperWithEmptyNoArgCtor_02 {}\n@@ -135,1 +135,1 @@\n-                primitive class PC extends BadSuper {}\n+                value class PC extends BadSuper {}\n@@ -144,1 +144,1 @@\n-                primitive class PC extends SuperWithInstanceField_01 {}\n+                value class PC extends SuperWithInstanceField_01 {}\n@@ -155,1 +155,1 @@\n-                primitive class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n+                value class PC extends SuperWithNonEmptyNoArgCtor_01 {}\n@@ -166,1 +166,1 @@\n-                primitive class PC extends SuperWithArgedCtor_01 {}\n+                value class PC extends SuperWithArgedCtor_01 {}\n@@ -181,1 +181,1 @@\n-                primitive class PC extends SuperWithInstanceInit_01 {}\n+                value class PC extends SuperWithInstanceInit_01 {}\n@@ -190,1 +190,1 @@\n-                primitive class PC extends SuperWithSynchronizedMethod_1 {}\n+                value class PC extends SuperWithSynchronizedMethod_1 {}\n@@ -198,1 +198,1 @@\n-                primitive class PC extends Outer.InnerSuper {}\n+                value class PC extends Outer.InnerSuper {}\n@@ -205,1 +205,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -213,1 +213,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -227,1 +227,1 @@\n-                primitive class Test {\n+                value class Test {\n@@ -241,1 +241,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -243,1 +243,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -252,1 +252,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -254,1 +254,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -263,1 +263,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -265,1 +265,1 @@\n-                    primitive final class B {\n+                    value final class B {\n@@ -274,1 +274,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -290,1 +290,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -298,1 +298,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -306,1 +306,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -314,1 +314,1 @@\n-                primitive final class A {\n+                value final class A {\n@@ -328,1 +328,0 @@\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\", \"primitive interface I {}\");\n@@ -332,1 +331,1 @@\n-                    primitive public void m() {}\n+                    value public void m() {}\n@@ -339,1 +338,1 @@\n-                        int[] ia = new primitive int[10];\n+                        int[] ia = new value int[10];\n@@ -347,1 +346,1 @@\n-                        new primitive String(\"Hello\");\n+                        new value String(\"Hello\");\n@@ -358,1 +357,1 @@\n-                        new primitive I() {};\n+                        new value I() {};\n@@ -365,1 +364,1 @@\n-    public void testPrimitivesAsTypeParams() {\n+    public void testValueClassesAsTypeParams() {\n@@ -369,1 +368,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -375,1 +374,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -381,1 +380,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -389,1 +388,1 @@\n-                primitive class ValueOverGenericsTest {\n+                value class ValueOverGenericsTest {\n@@ -396,2 +395,2 @@\n-                import java.util.ArrayList;\n-                primitive class ValueOverGenericsTest {\n+                import java.io.Serializable;\n+                value class ValueOverGenericsTest {\n@@ -405,1 +404,1 @@\n-            assertFail(\"compiler.err.type.found.req\", source);\n+            assertOK(source);\n@@ -415,1 +414,1 @@\n-                        primitive class Value {}\n+                        value class Value {}\n@@ -425,2 +424,2 @@\n-                        primitive class Value {}\n-                        new primitive Value() {};\n+                        value class Value {}\n+                        new value Value() {};\n@@ -458,1 +457,1 @@\n-                    primitive class UncheckedDefault<E> {\n+                    value class UncheckedDefault<E> {\n@@ -469,74 +468,0 @@\n-    public void testRefProjection() {\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref x = null;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC x) {\n-                        PC.ref xq = null;\n-                        xq = x;\n-                        xq = (PC.ref) x;\n-                        xq = (PC) x;\n-                        x = xq;\n-                        x = (PC.ref) xq;\n-                        x = (PC) xq;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC[] xa = new PC[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo() {\n-                        PC.ref [] xqa = new PC.ref[] { null };\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa) {\n-                        PC.ref[] xqa = xa;\n-                        xqa = (PC.ref[]) xa;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = xqa;\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                primitive class PC {\n-                    void foo(PC[] xa, PC.ref[] xqa) {\n-                        xa = (PC[]) xqa;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -554,50 +479,1 @@\n-    public void testProjectionInstantiation() {\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.ref();\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                primitive class PC {\n-                    void m() {\n-                        new PC.val();\n-                    }\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.ref::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.projection.cant.be.instantiated\",\n-                \"\"\"\n-                import java.util.function.Supplier;\n-                primitive class PC {\n-                    void m() {\n-                        foo(PC.val::new);\n-                    }\n-                    static void foo(Supplier<PC.ref> sx) {}\n-                }\n-                \"\"\");\n-    }\n-\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -607,2 +483,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -611,1 +487,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -619,1 +495,1 @@\n-        assertFail(\"compiler.err.ref.ambiguous\",\n+        assertOK(\n@@ -622,2 +498,2 @@\n-                    static primitive class V {}\n-                    static String roo(V.ref v, int i) {\n+                    static value class V {}\n+                    static String roo(V v, int i) {\n@@ -626,1 +502,1 @@\n-                    static String roo(V.ref v, Integer i) {\n+                    static String roo(V v, Integer i) {\n@@ -639,1 +515,1 @@\n-                primitive class Bar {\n+                value class Bar {\n@@ -648,1 +524,1 @@\n-                primitive class DualPathInnerType  {\n+                value class DualPathInnerType  {\n@@ -652,1 +528,1 @@\n-                    DualPathInnerType.ref.Inner xri = xi;\n+                    DualPathInnerType.Inner xri = xi;\n@@ -655,1 +531,1 @@\n-                    void f (DualPathInnerType.ref.Inner xri) {}\n+                    void f (DualPathInnerType.Inner xri) {}\n@@ -668,1 +544,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -679,1 +555,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -690,1 +566,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -701,1 +577,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -712,1 +588,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -723,1 +599,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -734,1 +610,1 @@\n-                        primitive class Value<T> {\n+                        value class Value<T> {\n@@ -754,1 +630,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -766,1 +642,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -778,1 +654,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -790,1 +666,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -802,1 +678,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -814,1 +690,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -826,1 +702,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -838,1 +714,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -851,1 +727,1 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n@@ -864,2 +740,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -876,2 +752,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -888,2 +764,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<String, Integer> r1) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<String, Integer> r1) {\n@@ -901,2 +777,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -914,2 +790,2 @@\n-                primitive class GenericInlineTest<T, U> extends High<U, T> {\n-                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest.ref<Integer, String> r2) {\n+                value class GenericInlineTest<T, U> extends High<U, T> {\n+                    void foo(GenericInlineTest<String, Integer> g, GenericInlineTest<Integer, String> r2) {\n@@ -923,58 +799,0 @@\n-    public void testValRefTokensNegative() {\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    ValRefTokensNegativeTest.ref aa = null;\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    static ValRefTokensNegativeTest.val bb = ValRefTokensNegativeTest.default;\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    EmptyValue empty = EmptyValue.default;\n-\n-                    static class ValRefTokensTestWrapper {\n-                        ValRefTokensNegativeTest val = ValRefTokensNegativeTest.default;\n-                        ValRefTokensNegativeTest ref = ValRefTokensNegativeTest.default;\n-                    }\n-\n-                    public EmptyValue test(int x) {\n-                        ValRefTokensTestWrapper w = new ValRefTokensTestWrapper();\n-                        return x == 0 ? w.val.empty : w.ref.empty;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int valx() {\n-                        return EmptyValue.val.x;\n-                    }\n-\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.resolve.location\",\n-                \"\"\"\n-                class ValRefTokensNegativeTest {\n-                    int refx() {\n-                        return EmptyValue.ref.x;\n-                    }\n-                    static class EmptyValue {\n-                        static int x = 42;\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n@@ -986,1 +804,1 @@\n-            assertFail(\"compiler.err.primitive.classes.not.supported\",\n+            assertFail(\"compiler.err.feature.not.supported.in.source.plural\",\n@@ -988,4 +806,4 @@\n-                    class primitive {\n-                        primitive x;\n-                        primitive foo(int l) {}\n-                        Object o = new primitive primitive() {};\n+                    class value {\n+                        value x;\n+                        value foo(int l) {}\n+                        Object o = new value value() {};\n@@ -997,1 +815,1 @@\n-                    class primitive {}\n+                    class value {}\n@@ -1011,1 +829,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1027,1 +845,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1045,1 +863,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1064,1 +882,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1083,1 +901,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1101,1 +919,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1113,1 +931,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1125,1 +943,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1139,1 +957,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1154,1 +972,1 @@\n-                    primitive class V {\n+                    value class V {\n@@ -1174,1 +992,1 @@\n-                    primitive static class Foo extends S implements I<Integer> {\n+                    value static class Foo extends S implements I<Integer> {\n@@ -1180,90 +998,0 @@\n-\n-    public void testClassLiteralTypingNegativeTest() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\"};\n-            setCompileOptions(testOptions);\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = PrimitiveClass.asValueType(Foo.class);\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = new Foo().getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.ref.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertFail(\"compiler.err.prob.found.req\",\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Class<? extends Foo.ref> cFooRef = Foo.val.class;\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.val xv = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xv.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-            assertOK(\n-                    \"\"\"\n-                    import jdk.internal.value.PrimitiveClass;\n-                    class ClassLiteralTypingNegativeTest {\n-                        interface I {}\n-                        static primitive class Foo implements I {\n-                            final int value = 0;\n-                            void m() {\n-                                Foo.ref xr = new Foo();\n-                                Class<? extends Foo.ref> cFooRef = xr.getClass();\n-                            }\n-                        }\n-                    }\n-                    \"\"\");\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":97,"deletions":369,"binary":false,"changes":466,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    static primitive class V {\n+    static value class V {\n@@ -42,1 +42,3 @@\n-        V() {\n+        public implicit V();\n+\n+        V(boolean dummy) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Check array creation with value classes\n+ * @summary Check array creation with V and V.ref\n@@ -43,0 +43,11 @@\n+        VT![] a3;\n+        VT![] a4;\n+\n+        public implicit VT();\n+\n+        VT(boolean non_implicit) {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+            a3 = new VT![42];\n+            a4 = new VT![42];\n+        }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * @enablePreview\n- * @compile AsSuperTests.java\n+ * @compile -XDenableNullRestrictedTypes AsSuperTests.java\n@@ -49,1 +48,1 @@\n-abstract value class Base<T> {\n+abstract class Base<T> {\n@@ -53,1 +52,1 @@\n-       String m(Foo f);\n+        String m(Foo! f);\n@@ -62,1 +61,3 @@\n-    static value class Foo<X> extends Base {}\n+    static value class Foo<X> extends Base {\n+        public implicit Foo();\n+    }\n@@ -66,0 +67,1 @@\n+    public implicit X();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AsSuperTests.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    public implicit CanonicalCtorTest();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-        CheckSynchronized.ref csr = cs;\n+        CheckSynchronized csr = cs;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized.ref, (compiler.misc.type.req.identity)\n+CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized, (compiler.misc.type.req.identity)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+import com.sun.tools.classfile.ImplicitCreation_attribute;\n+import com.sun.tools.classfile.NullRestricted_attribute;\n@@ -64,0 +66,1 @@\n+\n@@ -73,1 +76,0 @@\n-        setCompileOptions(PREVIEW_OPTIONS);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}