{"files":[{"patch":"@@ -67,5 +67,6 @@\n-\/** This phase adds local variable proxies to value classes constructors.\n- *  Assignments to instance fields in a constructor will be rewritten as assignments\n- *  to the corresponding local proxy variable. Fields will be assigned with its\n- *  corresponding local variable proxy just before the super invocation and after\n- *  the arguments for the super invocation, if any, have been evaluated.\n+\/** This phase adds local variable proxies for strict fields that are read during the\n+ *  early construction phase (prologue)\n+ *\n+ *  Assignments to the affected instance fields will be rewritten as assignments to a\n+ *  local proxy variable. Fields will be assigned to with its corresponding local variable\n+ *  proxy just before the super invocation and after its arguments, if any, have been evaluated.\n@@ -153,16 +154,4 @@\n-            if (!strictInstanceFields.isEmpty()) {\n-                \/\/ ignore telescopic and generated constructors\n-                if (TreeInfo.isConstructor(tree) &&\n-                        TreeInfo.hasConstructorCall(tree, names._super) &&\n-                        (tree.sym.flags_field & Flags.GENERATEDCONSTR) == 0) {\n-                    \/\/ now we need to analyze the constructor's body, it could be that it is empty or that\n-                    \/\/ no assignment to strict fields is done\n-                    java.util.List<JCVariableDecl> strictFieldsRead = new ArrayList<>();\n-                    for (JCVariableDecl sfield : strictInstanceFields) {\n-                        if (fieldSet.contains(sfield.sym)) {\n-                            strictFieldsRead.add(sfield);\n-                        }\n-                    }\n-                    if (!strictFieldsRead.isEmpty()) {\n-                        addLocalProxiesFor(tree, strictFieldsRead);\n-                    }\n+            java.util.List<JCVariableDecl> strictFieldsRead = new ArrayList<>();\n+            for (JCVariableDecl sfield : strictInstanceFields) {\n+                if (fieldSet.contains(sfield.sym)) {\n+                    strictFieldsRead.add(sfield);\n@@ -171,0 +160,2 @@\n+            addLocalProxiesFor(tree, strictFieldsRead);\n+            strictFieldsReadInPrologue.remove(tree);\n@@ -188,1 +179,1 @@\n-        FieldRewriter fr = new FieldRewriter(constructor, fieldToLocalMap);\n+        FieldRewriter fieldRewriter = new FieldRewriter(constructor, fieldToLocalMap);\n@@ -191,1 +182,1 @@\n-            newBody = newBody.append(fr.translate(st));\n+            newBody = newBody.append(fieldRewriter.translate(st));\n@@ -200,26 +191,16 @@\n-        if (!assigmentsBeforeSuper.isEmpty()) {\n-            JCTree.JCMethodInvocation constructorCall = TreeInfo.findConstructorCall(constructor);\n-            if (constructorCall.args.isEmpty()) {\n-                \/\/ this is just a super invocation with no arguments we can set the fields just before the invocation\n-                \/\/ and let Gen do the rest\n-                TreeInfo.mapSuperCalls(constructor.body, supercall -> make.Block(0, assigmentsBeforeSuper.toList().append(supercall)));\n-            } else {\n-                \/\/ we need to generate fresh local variables to catch the values of the arguments, then\n-                \/\/ assign the proxy locals to the fields and finally invoke the super with the fresh local variables\n-                int argPosition = 0;\n-                ListBuffer<JCStatement> superArgsProxies = new ListBuffer<>();\n-                for (JCExpression arg : constructorCall.args) {\n-                    long flags = SYNTHETIC | FINAL;\n-                    VarSymbol proxyForArgSym = new VarSymbol(flags, newLocalName(\"\" + argPosition), types.erasure(arg.type), constructor.sym);\n-                    JCVariableDecl proxyForArgDecl = make.at(constructor.pos).VarDef(proxyForArgSym, arg);\n-                    superArgsProxies = superArgsProxies.append(proxyForArgDecl);\n-                    argPosition++;\n-                }\n-                List<JCStatement> superArgsProxiesList = superArgsProxies.toList();\n-                ListBuffer<JCExpression> newArgs = new ListBuffer<>();\n-                for (JCStatement argProxy : superArgsProxies) {\n-                    newArgs.add(make.at(argProxy.pos).Ident((JCVariableDecl) argProxy));\n-                }\n-                constructorCall.args = newArgs.toList();\n-                TreeInfo.mapSuperCalls(constructor.body,\n-                        supercall -> make.Block(0, superArgsProxiesList.appendList(assigmentsBeforeSuper.toList()).append(supercall)));\n+        JCTree.JCMethodInvocation constructorCall = TreeInfo.findConstructorCall(constructor);\n+        if (constructorCall.args.isEmpty()) {\n+            \/\/ this is just a super invocation with no arguments we can set the fields just before the invocation\n+            \/\/ and let Gen do the rest\n+            TreeInfo.mapSuperCalls(constructor.body, supercall -> make.Block(0, assigmentsBeforeSuper.toList().append(supercall)));\n+        } else {\n+            \/\/ we need to generate fresh local variables to catch the values of the arguments, then\n+            \/\/ assign the proxy locals to the fields and finally invoke the super with the fresh local variables\n+            int argPosition = 0;\n+            ListBuffer<JCStatement> superArgsProxies = new ListBuffer<>();\n+            for (JCExpression arg : constructorCall.args) {\n+                long flags = SYNTHETIC | FINAL;\n+                VarSymbol proxyForArgSym = new VarSymbol(flags, newLocalName(\"\" + argPosition), types.erasure(arg.type), constructor.sym);\n+                JCVariableDecl proxyForArgDecl = make.at(constructor.pos).VarDef(proxyForArgSym, arg);\n+                superArgsProxies = superArgsProxies.append(proxyForArgDecl);\n+                argPosition++;\n@@ -227,0 +208,8 @@\n+            List<JCStatement> superArgsProxiesList = superArgsProxies.toList();\n+            ListBuffer<JCExpression> newArgs = new ListBuffer<>();\n+            for (JCStatement argProxy : superArgsProxies) {\n+                newArgs.add(make.at(argProxy.pos).Ident((JCVariableDecl) argProxy));\n+            }\n+            constructorCall.args = newArgs.toList();\n+            TreeInfo.mapSuperCalls(constructor.body,\n+                    supercall -> make.Block(0, superArgsProxiesList.appendList(assigmentsBeforeSuper.toList()).append(supercall)));\n@@ -237,0 +226,1 @@\n+        boolean ctorPrologue = true;\n@@ -245,1 +235,1 @@\n-            if (fieldToLocalMap.get(tree.sym) != null) {\n+            if (ctorPrologue && fieldToLocalMap.get(tree.sym) != null) {\n@@ -255,1 +245,1 @@\n-            if (fieldToLocalMap.get(tree.sym) != null) {\n+            if (ctorPrologue && fieldToLocalMap.get(tree.sym) != null) {\n@@ -266,1 +256,1 @@\n-            if (previousLHS != tree.lhs) {\n+            if (ctorPrologue && previousLHS != tree.lhs) {\n@@ -270,0 +260,10 @@\n+\n+        @Override\n+        public void visitApply(JCTree.JCMethodInvocation tree) {\n+            Name methName = TreeInfo.name(tree.meth);\n+            boolean isConstructorCall = methName == names._this || methName == names._super;\n+            super.visitApply(tree);\n+            if (isConstructorCall) {\n+                ctorPrologue = false;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"}]}