{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import com.sun.tools.javac.code.Flags;\n@@ -42,1 +41,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCLambda;\n@@ -46,1 +44,0 @@\n-import com.sun.tools.javac.tree.TreeScanner;\n@@ -53,2 +50,0 @@\n-import com.sun.tools.javac.code.Symbol.MethodSymbol;\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1581,0 +1581,61 @@\n+\n+    @Test\n+    void testLocalProxyVars() throws Exception {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\n+                    \"--enable-preview\",\n+                    \"-source\", Integer.toString(Runtime.version().feature()),\n+                    \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+            };\n+            setCompileOptions(testOptions);\n+            String[] sources = new String[] {\n+                    \"\"\"\n+                    value class Test {\n+                        int i;\n+                        int j;\n+                        Test() {\/\/ javac should generate a proxy local var for `i`\n+                            i = 1;\n+                            j = i; \/\/ as here `i` is being read during the early construction phase, use the local var instead\n+                            super();\n+                            System.err.println(i);\n+                        }\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import jdk.internal.vm.annotation.Strict;\n+                    class Test {\n+                        @Strict\n+                        int i;\n+                        @Strict\n+                        int j;\n+                        Test() {\n+                            i = 1;\n+                            j = i;\n+                            super();\n+                            System.err.println(i);\n+                        }\n+                    }\n+                    \"\"\"\n+            };\n+            for (String source : sources) {\n+                File dir = assertOK(true, source);\n+                File fileEntry = dir.listFiles()[0];\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                String expectedCodeSequence = \"iconst_1,istore_1,aload_0,iload_1,putfield,aload_0,iload_1,putfield,\" +\n+                        \"aload_0,invokespecial,getstatic,aload_0,getfield,invokevirtual,return,\";\n+                for (Method method : classFile.methods) {\n+                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                        Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                        String foundCodeSequence = \"\";\n+                        for (Instruction inst: code.getInstructions()) {\n+                            foundCodeSequence += inst.getMnemonic() + \",\";\n+                        }\n+                        Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n+                    }\n+                }\n+            }\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"}]}