{"files":[{"patch":"@@ -66,1 +66,2 @@\n-        GENERATE(11);\n+        STRICT_FIELDS_PROXIES(11),\n+        GENERATE(12);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.tree.JCTree.JCAssign;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+\n+import static com.sun.tools.javac.code.Flags.FINAL;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.tree.JCTree.Tag.VARDEF;\n+\n+import com.sun.tools.javac.jvm.Target;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCStatement;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Options;\n+\n+\/** This phase adds local variable proxies to value classes constructors.\n+ *  Assignments to instance fields in a constructor will be rewritten as assignments\n+ *  to the corresponding local proxy variable. Fields will be assigned with its\n+ *  corresponding local variable proxy just before the super invocation and after\n+ *  the arguments for the super invocation, if any, have been evaluated.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class LocalProxyVarsGen extends TreeTranslator {\n+\n+    protected static final Context.Key<LocalProxyVarsGen> valueInitializersKey = new Context.Key<>();\n+\n+    public static LocalProxyVarsGen instance(Context context) {\n+        LocalProxyVarsGen instance = context.get(valueInitializersKey);\n+        if (instance == null)\n+            instance = new LocalProxyVarsGen(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private final Names names;\n+    private final Target target;\n+    private TreeMaker make;\n+    private final UnsetFieldsInfo unsetFieldsInfo;\n+    private ClassSymbol currentClass = null;\n+    private java.util.List<JCVariableDecl> strictInstanceFields;\n+\n+    private final boolean noLocalProxyVars;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected LocalProxyVarsGen(Context context) {\n+        context.put(valueInitializersKey, this);\n+        make = TreeMaker.instance(context);\n+        types = Types.instance(context);\n+        names = Names.instance(context);\n+        target = Target.instance(context);\n+        unsetFieldsInfo = UnsetFieldsInfo.instance(context);\n+        Options options = Options.instance(context);\n+        noLocalProxyVars = options.isSet(\"noLocalProxyVars\");\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        if (!noLocalProxyVars) {\n+            try {\n+                this.make = make;\n+                return translate(cdef);\n+            } finally {\n+                \/\/ note that recursive invocations of this method fail hard\n+                this.make = null;\n+            }\n+        } else {\n+            return cdef;\n+        }\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        java.util.List<JCVariableDecl> prevStrictInstanceFields = strictInstanceFields;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+            strictInstanceFields = tree.defs.stream()\n+                    .filter(t -> t.hasTag(VARDEF))\n+                    .map(t -> (JCVariableDecl)t)\n+                    .filter(vd -> vd.sym.isStrict() && !vd.sym.isStatic())\n+                    .collect(List.collector());\n+            if (!strictInstanceFields.isEmpty()) {\n+                for (JCTree t : tree.defs) {\n+                    if (t.hasTag(JCTree.Tag.METHODDEF)) {\n+                        JCMethodDecl md = (JCMethodDecl) t;\n+                        \/\/ ignore telescopic and generated constructors\n+                        if (TreeInfo.isConstructor(md) &&\n+                                TreeInfo.hasConstructorCall(md, names._super) &&\n+                                (md.sym.flags_field & Flags.GENERATEDCONSTR) == 0) {\n+                            \/\/ now we need to analyze the constructor's body, it could be that it is empty or that\n+                            \/\/ no assignment to strict fields is done\n+                            ConstructorScanner cs = new ConstructorScanner();\n+                            cs.scan(md);\n+                            java.util.List<JCVariableDecl> multiAssignedStrictFields = new ArrayList<>();\n+                            for (Symbol sym : cs.strictFieldsAssignedTo.keySet()) {\n+                                JCVariableDecl keep = null;\n+                                \/\/ if there is only one assignment there is no point in creating proxy locals, the code\n+                                \/\/ is good as it is\n+                                if (cs.strictFieldsAssignedTo.get(sym) > 1) {\n+                                    for (JCVariableDecl strictField : strictInstanceFields) {\n+                                        if (strictField.sym == sym) {\n+                                            keep = strictField;\n+                                            break;\n+                                        }\n+                                    }\n+                                    if (keep != null) {\n+                                        multiAssignedStrictFields.add(keep);\n+                                    }\n+                                }\n+                            }\n+                            if (!multiAssignedStrictFields.isEmpty()) {\n+                                addLocalProxiesFor(md, multiAssignedStrictFields);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        } finally {\n+            currentClass = prevCurrentClass;\n+            strictInstanceFields = prevStrictInstanceFields;\n+        }\n+    }\n+\n+    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> multiAssignedStrictFields) {\n+        ListBuffer<JCStatement> localDeclarations = new ListBuffer<>();\n+        Map<Symbol, Symbol> fieldToLocalMap = new LinkedHashMap<>();\n+\n+        for (JCVariableDecl fieldDecl : multiAssignedStrictFields) {\n+            long flags = SYNTHETIC;\n+            VarSymbol proxy = new VarSymbol(flags, newLocalName(fieldDecl.name.toString()), fieldDecl.sym.erasure(types), constructor.sym);\n+            fieldToLocalMap.put(fieldDecl.sym, proxy);\n+            JCVariableDecl localDecl = make.at(constructor.pos).VarDef(proxy, fieldDecl.init);\n+            localDecl.vartype = fieldDecl.vartype;\n+            localDeclarations = localDeclarations.append(localDecl);\n+        }\n+\n+        FieldRewriter fr = new FieldRewriter(constructor, fieldToLocalMap);\n+        ListBuffer<JCStatement> newBody = new ListBuffer<>();\n+        for (JCStatement st : constructor.body.stats) {\n+            newBody = newBody.append(fr.translate(st));\n+        }\n+        localDeclarations.addAll(newBody);\n+        ListBuffer<JCStatement> assigmentsBeforeSuper = new ListBuffer<>();\n+        for (Symbol vsym : fieldToLocalMap.keySet()) {\n+            Symbol local = fieldToLocalMap.get(vsym);\n+            assigmentsBeforeSuper.append(make.at(constructor.pos()).Assignment(vsym, make.at(constructor.pos()).Ident(local)));\n+        }\n+        constructor.body.stats = localDeclarations.toList();\n+        if (!assigmentsBeforeSuper.isEmpty()) {\n+            JCTree.JCMethodInvocation constructorCall = TreeInfo.findConstructorCall(constructor);\n+            if (constructorCall.args.isEmpty()) {\n+                \/\/ this is just a super invocation with no arguments we can set the fields just before the invocation\n+                \/\/ and let Gen do the rest\n+                TreeInfo.mapSuperCalls(constructor.body, supercall -> make.Block(0, assigmentsBeforeSuper.toList().append(supercall)));\n+            } else {\n+                \/\/ we need to generate fresh local variables to catch the values of the arguments, then\n+                \/\/ assign the proxy locals to the fields and finally invoke the super with the fresh local variables\n+                int argPosition = 0;\n+                ListBuffer<JCStatement> superArgsProxies = new ListBuffer<>();\n+                for (JCExpression arg : constructorCall.args) {\n+                    long flags = SYNTHETIC | FINAL;\n+                    VarSymbol proxyForArgSym = new VarSymbol(flags, newLocalName(\"\" + argPosition), types.erasure(arg.type), constructor.sym);\n+                    JCVariableDecl proxyForArgDecl = make.at(constructor.pos).VarDef(proxyForArgSym, arg);\n+                    superArgsProxies = superArgsProxies.append(proxyForArgDecl);\n+                    argPosition++;\n+                }\n+                List<JCStatement> superArgsProxiesList = superArgsProxies.toList();\n+                ListBuffer<JCExpression> newArgs = new ListBuffer<>();\n+                for (JCStatement argProxy : superArgsProxies) {\n+                    newArgs.add(make.at(argProxy.pos).Ident((JCVariableDecl) argProxy));\n+                }\n+                constructorCall.args = newArgs.toList();\n+                TreeInfo.mapSuperCalls(constructor.body, supercall -> make.Block(0, superArgsProxiesList.appendList(assigmentsBeforeSuper.toList()).append(supercall)));\n+            }\n+        }\n+    }\n+\n+    Name newLocalName(String name) {\n+        return names.fromString(\"local\" + target.syntheticNameChar() + name);\n+    }\n+\n+    class FieldRewriter extends TreeTranslator {\n+        JCMethodDecl md;\n+        Map<Symbol, Symbol> fieldToLocalMap;\n+\n+        public FieldRewriter(JCMethodDecl md, Map<Symbol, Symbol> fieldToLocalMap) {\n+            this.md = md;\n+            this.fieldToLocalMap = fieldToLocalMap;\n+        }\n+\n+        @Override\n+        public void visitIdent(JCTree.JCIdent tree) {\n+            if (fieldToLocalMap.get(tree.sym) != null) {\n+                result = make.at(md).Ident(fieldToLocalMap.get(tree.sym));\n+            } else {\n+                result = tree;\n+            }\n+        }\n+\n+        @Override\n+        public void visitSelect(JCTree.JCFieldAccess tree) {\n+            super.visitSelect(tree);\n+            if (fieldToLocalMap.get(tree.sym) != null) {\n+                result = make.at(md).Ident(fieldToLocalMap.get(tree.sym));\n+            } else {\n+                result = tree;\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            JCExpression previousLHS = tree.lhs;\n+            super.visitAssign(tree);\n+            if (previousLHS != tree.lhs) {\n+                unsetFieldsInfo.removeUnsetFieldInfo(currentClass, tree);\n+            }\n+        }\n+    }\n+\n+    \/* the idea of this scanner is to find how many assignments to strict fields occur inside a constructor's\n+     * body\n+     *\/\n+    private class ConstructorScanner extends TreeScanner {\n+        Map<Symbol, Integer> strictFieldsAssignedTo = new HashMap<>();\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            Symbol lhsSym = TreeInfo.symbol(tree.lhs);\n+            if (lhsSym != null && lhsSym instanceof VarSymbol vs && vs.isStrict()) {\n+                Integer noOfAssignments = strictFieldsAssignedTo.get(lhsSym);\n+                if (noOfAssignments == null) {\n+                    noOfAssignments = 0;\n+                }\n+                noOfAssignments++;\n+                strictFieldsAssignedTo.put(vs, noOfAssignments);\n+            }\n+            super.visitAssign(tree);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -91,0 +91,7 @@\n+\n+    public void removeUnsetFieldInfo(ClassSymbol csym, JCTree tree) {\n+        Map<JCTree, Set<VarSymbol>> treeToFieldsMap = unsetFieldsMap.get(csym);\n+        if (treeToFieldsMap != null) {\n+            treeToFieldsMap.remove(tree);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/UnsetFieldsInfo.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -193,0 +193,2 @@\n+    public Set<VarSymbol> initialUnsetFields;\n+\n@@ -1358,1 +1360,1 @@\n-        boolean generateAssertUnsetFieldsEntry = unsetFieldsAtPC != null && generateAssertUnsetFieldsFrame;\n+        boolean generateAssertUnsetFieldsEntry = unsetFieldsAtPC != null && generateAssertUnsetFieldsFrame && !lastFrame.unsetFields.equals(unsetFieldsAtPC) ;\n@@ -1369,4 +1371,4 @@\n-            if (lastFrame.unsetFields == null || !lastFrame.unsetFields.equals(unsetFieldsAtPC)) {\n-                stackMapTableBuffer[stackMapBufferSize++] = new StackMapTableEntry.AssertUnsetFields(pc, unsetFieldsAtPC);\n-                frame.unsetFields = unsetFieldsAtPC;\n-            }\n+            stackMapTableBuffer[stackMapBufferSize++] = new StackMapTableEntry.AssertUnsetFields(pc, unsetFieldsAtPC);\n+            frame.unsetFields = unsetFieldsAtPC;\n+        } else {\n+            frame.unsetFields = lastFrame.unsetFields;\n@@ -1406,0 +1408,1 @@\n+        frame.unsetFields = initialUnsetFields;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    private final LocalProxyVarsGen localProxyVarsGen;\n@@ -119,0 +120,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -589,1 +591,1 @@\n-    class InitializerVisitor extends TreeScanner {\n+    public static class InitializerVisitor extends TreeScanner {\n@@ -593,1 +595,1 @@\n-        InitializerVisitor(JCMethodDecl md, Set<JCExpression> exprSet) {\n+        public InitializerVisitor(JCMethodDecl md, Set<JCExpression> exprSet) {\n@@ -1001,0 +1003,1 @@\n+                    code.initialUnsetFields = unsetFieldsInfo.getUnsetFields(env.enclClass.sym, tree.body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,2 +88,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -1566,0 +1564,2 @@\n+            protected boolean hasValueClasses;\n+            protected boolean hasStrictFields;\n@@ -1577,0 +1577,1 @@\n+                            boolean prevHasStrictFields = hasStrictFields;\n@@ -1589,0 +1590,1 @@\n+                                hasStrictFields = prevHasStrictFields;\n@@ -1595,0 +1597,1 @@\n+                hasValueClasses = node.sym.isValueClass();\n@@ -1634,0 +1637,6 @@\n+\n+            @Override\n+            public void visitVarDef(JCVariableDecl tree) {\n+                hasStrictFields |= tree.sym.isStrict();\n+                super.visitVarDef(tree);\n+            }\n@@ -1638,2 +1647,2 @@\n-        if (!compileStates.isDone(dep, CompileState.WARN))\n-            desugaredEnvs.put(dep, desugar(warn(flow(attribute(dep)))));\n+            if (!compileStates.isDone(dep, CompileState.WARN))\n+                desugaredEnvs.put(dep, desugar(warn(flow(attribute(dep)))));\n@@ -1718,0 +1727,9 @@\n+\n+            if (scanner.hasValueClasses || scanner.hasStrictFields) {\n+                if (shouldStop(CompileState.STRICT_FIELDS_PROXIES))\n+                    return;\n+                for (JCTree def : cdefs) {\n+                    LocalProxyVarsGen.instance(context).translateTopLevelClass(def, localMake);\n+                }\n+                compileStates.put(env, CompileState.STRICT_FIELDS_PROXIES);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateAssertUnsetFieldsFrame StrictFinalInstanceFieldsTest.java\n+ * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateAssertUnsetFieldsFrame -XDnoLocalProxyVars StrictFinalInstanceFieldsTest.java\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFinalInstanceFieldsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1454,0 +1454,1 @@\n+                    \"-XDnoLocalProxyVars\",\n@@ -1526,1 +1527,1 @@\n-                                Assert.check(data.expectedFrameTypes()[entryIndex++] == entry.entry_type);\n+                                Assert.check(data.expectedFrameTypes()[entryIndex++] == entry.entry_type, \"expected \" + data.expectedFrameTypes()[entryIndex - 1] + \" found \" + entry.entry_type);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}