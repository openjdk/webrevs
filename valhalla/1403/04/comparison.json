{"files":[{"patch":"@@ -410,0 +410,4 @@\n+    public boolean isStrictInstance() {\n+        return (flags() & STRICT) != 0 && (flags() & STATIC) == 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-        GENERATE(11);\n+        STRICT_FIELDS_PROXIES(11),\n+        GENERATE(12);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.tree.JCTree.JCAssign;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+\n+import static com.sun.tools.javac.code.Flags.FINAL;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.tree.JCTree.Tag.VARDEF;\n+\n+import com.sun.tools.javac.jvm.Target;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCStatement;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Options;\n+\n+\/** This phase adds local variable proxies for strict fields that are read during the\n+ *  early construction phase (prologue)\n+ *\n+ *  Assignments to the affected instance fields will be rewritten as assignments to a\n+ *  local proxy variable. Fields will be assigned to with its corresponding local variable\n+ *  proxy just before the super invocation and after its arguments, if any, have been evaluated.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class LocalProxyVarsGen extends TreeTranslator {\n+\n+    protected static final Context.Key<LocalProxyVarsGen> valueInitializersKey = new Context.Key<>();\n+\n+    public static LocalProxyVarsGen instance(Context context) {\n+        LocalProxyVarsGen instance = context.get(valueInitializersKey);\n+        if (instance == null)\n+            instance = new LocalProxyVarsGen(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private final Names names;\n+    private final Target target;\n+    private TreeMaker make;\n+    private final UnsetFieldsInfo unsetFieldsInfo;\n+    private ClassSymbol currentClass = null;\n+    private java.util.List<JCVariableDecl> strictInstanceFields;\n+    private Map<JCMethodDecl, Set<Symbol>> strictFieldsReadInPrologue = new HashMap<>();\n+\n+    private final boolean noLocalProxyVars;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected LocalProxyVarsGen(Context context) {\n+        context.put(valueInitializersKey, this);\n+        make = TreeMaker.instance(context);\n+        types = Types.instance(context);\n+        names = Names.instance(context);\n+        target = Target.instance(context);\n+        unsetFieldsInfo = UnsetFieldsInfo.instance(context);\n+        Options options = Options.instance(context);\n+        noLocalProxyVars = options.isSet(\"noLocalProxyVars\");\n+    }\n+\n+    public void addStrictFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n+        Set<Symbol> fieldSet = strictFieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n+        fieldSet.add(sym);\n+        strictFieldsReadInPrologue.put(constructor, fieldSet);\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        if (!noLocalProxyVars) {\n+            try {\n+                this.make = make;\n+                return translate(cdef);\n+            } finally {\n+                \/\/ note that recursive invocations of this method fail hard\n+                this.make = null;\n+            }\n+        } else {\n+            return cdef;\n+        }\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        java.util.List<JCVariableDecl> prevStrictInstanceFields = strictInstanceFields;\n+        try {\n+            currentClass = tree.sym;\n+            strictInstanceFields = tree.defs.stream()\n+                    .filter(t -> t.hasTag(VARDEF))\n+                    .map(t -> (JCVariableDecl)t)\n+                    .filter(vd -> vd.sym.isStrict() && !vd.sym.isStatic())\n+                    .collect(List.collector());\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n+            strictInstanceFields = prevStrictInstanceFields;\n+        }\n+    }\n+\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        if (strictFieldsReadInPrologue.get(tree) != null) {\n+            Set<Symbol> fieldSet = strictFieldsReadInPrologue.get(tree);\n+            java.util.List<JCVariableDecl> strictFieldsRead = new ArrayList<>();\n+            for (JCVariableDecl sfield : strictInstanceFields) {\n+                if (fieldSet.contains(sfield.sym)) {\n+                    strictFieldsRead.add(sfield);\n+                }\n+            }\n+            addLocalProxiesFor(tree, strictFieldsRead);\n+            strictFieldsReadInPrologue.remove(tree);\n+        }\n+        super.visitMethodDef(tree);\n+    }\n+\n+    void addLocalProxiesFor(JCMethodDecl constructor, java.util.List<JCVariableDecl> multiAssignedStrictFields) {\n+        ListBuffer<JCStatement> localDeclarations = new ListBuffer<>();\n+        Map<Symbol, Symbol> fieldToLocalMap = new LinkedHashMap<>();\n+\n+        for (JCVariableDecl fieldDecl : multiAssignedStrictFields) {\n+            long flags = SYNTHETIC;\n+            VarSymbol proxy = new VarSymbol(flags, newLocalName(fieldDecl.name.toString()), fieldDecl.sym.erasure(types), constructor.sym);\n+            fieldToLocalMap.put(fieldDecl.sym, proxy);\n+            JCVariableDecl localDecl = make.at(constructor.pos).VarDef(proxy, fieldDecl.init);\n+            localDecl.vartype = fieldDecl.vartype;\n+            localDeclarations = localDeclarations.append(localDecl);\n+        }\n+\n+        FieldRewriter fieldRewriter = new FieldRewriter(constructor, fieldToLocalMap);\n+        ListBuffer<JCStatement> newBody = new ListBuffer<>();\n+        for (JCStatement st : constructor.body.stats) {\n+            newBody = newBody.append(fieldRewriter.translate(st));\n+        }\n+        localDeclarations.addAll(newBody);\n+        ListBuffer<JCStatement> assigmentsBeforeSuper = new ListBuffer<>();\n+        for (Symbol vsym : fieldToLocalMap.keySet()) {\n+            Symbol local = fieldToLocalMap.get(vsym);\n+            assigmentsBeforeSuper.append(make.at(constructor.pos()).Assignment(vsym, make.at(constructor.pos()).Ident(local)));\n+        }\n+        constructor.body.stats = localDeclarations.toList();\n+        JCTree.JCMethodInvocation constructorCall = TreeInfo.findConstructorCall(constructor);\n+        if (constructorCall.args.isEmpty()) {\n+            \/\/ this is just a super invocation with no arguments we can set the fields just before the invocation\n+            \/\/ and let Gen do the rest\n+            TreeInfo.mapSuperCalls(constructor.body, supercall -> make.Block(0, assigmentsBeforeSuper.toList().append(supercall)));\n+        } else {\n+            \/\/ we need to generate fresh local variables to catch the values of the arguments, then\n+            \/\/ assign the proxy locals to the fields and finally invoke the super with the fresh local variables\n+            int argPosition = 0;\n+            ListBuffer<JCStatement> superArgsProxies = new ListBuffer<>();\n+            for (JCExpression arg : constructorCall.args) {\n+                long flags = SYNTHETIC | FINAL;\n+                VarSymbol proxyForArgSym = new VarSymbol(flags, newLocalName(\"\" + argPosition), types.erasure(arg.type), constructor.sym);\n+                JCVariableDecl proxyForArgDecl = make.at(constructor.pos).VarDef(proxyForArgSym, arg);\n+                superArgsProxies = superArgsProxies.append(proxyForArgDecl);\n+                argPosition++;\n+            }\n+            List<JCStatement> superArgsProxiesList = superArgsProxies.toList();\n+            ListBuffer<JCExpression> newArgs = new ListBuffer<>();\n+            for (JCStatement argProxy : superArgsProxies) {\n+                newArgs.add(make.at(argProxy.pos).Ident((JCVariableDecl) argProxy));\n+            }\n+            constructorCall.args = newArgs.toList();\n+            TreeInfo.mapSuperCalls(constructor.body,\n+                    supercall -> make.Block(0, superArgsProxiesList.appendList(assigmentsBeforeSuper.toList()).append(supercall)));\n+        }\n+    }\n+\n+    Name newLocalName(String name) {\n+        return names.fromString(\"local\" + target.syntheticNameChar() + name);\n+    }\n+\n+    class FieldRewriter extends TreeTranslator {\n+        JCMethodDecl md;\n+        Map<Symbol, Symbol> fieldToLocalMap;\n+        boolean ctorPrologue = true;\n+\n+        public FieldRewriter(JCMethodDecl md, Map<Symbol, Symbol> fieldToLocalMap) {\n+            this.md = md;\n+            this.fieldToLocalMap = fieldToLocalMap;\n+        }\n+\n+        @Override\n+        public void visitIdent(JCTree.JCIdent tree) {\n+            if (ctorPrologue && fieldToLocalMap.get(tree.sym) != null) {\n+                result = make.at(md).Ident(fieldToLocalMap.get(tree.sym));\n+            } else {\n+                result = tree;\n+            }\n+        }\n+\n+        @Override\n+        public void visitSelect(JCTree.JCFieldAccess tree) {\n+            super.visitSelect(tree);\n+            if (ctorPrologue && fieldToLocalMap.get(tree.sym) != null) {\n+                result = make.at(md).Ident(fieldToLocalMap.get(tree.sym));\n+            } else {\n+                result = tree;\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            JCExpression previousLHS = tree.lhs;\n+            super.visitAssign(tree);\n+            if (ctorPrologue && previousLHS != tree.lhs) {\n+                unsetFieldsInfo.removeUnsetFieldInfo(currentClass, tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitApply(JCTree.JCMethodInvocation tree) {\n+            Name methName = TreeInfo.name(tree.meth);\n+            boolean isConstructorCall = methName == names._this || methName == names._super;\n+            super.visitApply(tree);\n+            if (isConstructorCall) {\n+                ctorPrologue = false;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"},{"patch":"@@ -118,0 +118,1 @@\n+    private final LocalProxyVarsGen localProxyVarsGen;\n@@ -157,0 +158,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -1540,1 +1542,6 @@\n-                            return new RefBeforeCtorCalledError(sym);\n+                            if (!sym.isStrictInstance()) {\n+                                return new RefBeforeCtorCalledError(sym);\n+                            } else {\n+                                localProxyVarsGen.addStrictFieldReadInPrologue(env.enclMethod, sym);\n+                                return sym;\n+                            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -91,0 +91,7 @@\n+\n+    public void removeUnsetFieldInfo(ClassSymbol csym, JCTree tree) {\n+        Map<JCTree, Set<VarSymbol>> treeToFieldsMap = unsetFieldsMap.get(csym);\n+        if (treeToFieldsMap != null) {\n+            treeToFieldsMap.remove(tree);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/UnsetFieldsInfo.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -193,0 +193,2 @@\n+    public Set<VarSymbol> initialUnsetFields;\n+\n@@ -1358,1 +1360,1 @@\n-        boolean generateAssertUnsetFieldsEntry = unsetFieldsAtPC != null && generateAssertUnsetFieldsFrame;\n+        boolean generateAssertUnsetFieldsEntry = unsetFieldsAtPC != null && generateAssertUnsetFieldsFrame && !lastFrame.unsetFields.equals(unsetFieldsAtPC) ;\n@@ -1369,4 +1371,4 @@\n-            if (lastFrame.unsetFields == null || !lastFrame.unsetFields.equals(unsetFieldsAtPC)) {\n-                stackMapTableBuffer[stackMapBufferSize++] = new StackMapTableEntry.AssertUnsetFields(pc, unsetFieldsAtPC);\n-                frame.unsetFields = unsetFieldsAtPC;\n-            }\n+            stackMapTableBuffer[stackMapBufferSize++] = new StackMapTableEntry.AssertUnsetFields(pc, unsetFieldsAtPC);\n+            frame.unsetFields = unsetFieldsAtPC;\n+        } else {\n+            frame.unsetFields = lastFrame.unsetFields;\n@@ -1406,0 +1408,1 @@\n+        frame.unsetFields = initialUnsetFields;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -589,1 +589,1 @@\n-    class InitializerVisitor extends TreeScanner {\n+    public static class InitializerVisitor extends TreeScanner {\n@@ -593,1 +593,1 @@\n-        InitializerVisitor(JCMethodDecl md, Set<JCExpression> exprSet) {\n+        public InitializerVisitor(JCMethodDecl md, Set<JCExpression> exprSet) {\n@@ -1001,0 +1001,1 @@\n+                    code.initialUnsetFields = unsetFieldsInfo.getUnsetFields(env.enclClass.sym, tree.body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,2 +88,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -1566,0 +1564,2 @@\n+            protected boolean hasValueClasses;\n+            protected boolean hasStrictFields;\n@@ -1577,0 +1577,1 @@\n+                            boolean prevHasStrictFields = hasStrictFields;\n@@ -1589,0 +1590,1 @@\n+                                hasStrictFields = prevHasStrictFields;\n@@ -1595,0 +1597,1 @@\n+                hasValueClasses = node.sym.isValueClass();\n@@ -1634,0 +1637,6 @@\n+\n+            @Override\n+            public void visitVarDef(JCVariableDecl tree) {\n+                hasStrictFields |= tree.sym.isStrict();\n+                super.visitVarDef(tree);\n+            }\n@@ -1638,2 +1647,2 @@\n-        if (!compileStates.isDone(dep, CompileState.WARN))\n-            desugaredEnvs.put(dep, desugar(warn(flow(attribute(dep)))));\n+            if (!compileStates.isDone(dep, CompileState.WARN))\n+                desugaredEnvs.put(dep, desugar(warn(flow(attribute(dep)))));\n@@ -1718,0 +1727,9 @@\n+\n+            if (scanner.hasValueClasses || scanner.hasStrictFields) {\n+                if (shouldStop(CompileState.STRICT_FIELDS_PROXIES))\n+                    return;\n+                for (JCTree def : cdefs) {\n+                    LocalProxyVarsGen.instance(context).translateTopLevelClass(def, localMake);\n+                }\n+                compileStates.put(env, CompileState.STRICT_FIELDS_PROXIES);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateAssertUnsetFieldsFrame StrictFinalInstanceFieldsTest.java\n+ * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateAssertUnsetFieldsFrame -XDnoLocalProxyVars StrictFinalInstanceFieldsTest.java\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFinalInstanceFieldsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-\n+import java.util.function.Function;\n@@ -175,1 +175,1 @@\n-        super((Runnable)() -> x);       \/\/ this should FAIL\n+        super((Function<Integer, Integer>) f -> x);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -15,1 +15,0 @@\n-ValueClassSuperInitFails.java:175:31: compiler.err.cant.ref.before.ctor.called: x\n@@ -28,1 +27,1 @@\n-25 errors\n+24 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *      8329345 8341061 8340984\n+ *      8329345 8341061 8340984 8334484\n@@ -919,1 +919,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n@@ -923,1 +923,1 @@\n-                    Runnable r = () -> { System.err.println(t); };\n+                    Runnable r = () -> { System.err.println(t); }; \/\/ compiler will generate a local proxy for `t`\n@@ -937,1 +937,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n@@ -942,1 +942,1 @@\n-                    V1() {\n+                    V() {\n@@ -971,1 +971,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n@@ -1001,1 +1001,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n@@ -1454,0 +1454,1 @@\n+                    \"-XDnoLocalProxyVars\",\n@@ -1526,1 +1527,1 @@\n-                                Assert.check(data.expectedFrameTypes()[entryIndex++] == entry.entry_type);\n+                                Assert.check(data.expectedFrameTypes()[entryIndex++] == entry.entry_type, \"expected \" + data.expectedFrameTypes()[entryIndex - 1] + \" found \" + entry.entry_type);\n@@ -1580,0 +1581,61 @@\n+\n+    @Test\n+    void testLocalProxyVars() throws Exception {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\n+                    \"--enable-preview\",\n+                    \"-source\", Integer.toString(Runtime.version().feature()),\n+                    \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+            };\n+            setCompileOptions(testOptions);\n+            String[] sources = new String[] {\n+                    \"\"\"\n+                    value class Test {\n+                        int i;\n+                        int j;\n+                        Test() {\/\/ javac should generate a proxy local var for `i`\n+                            i = 1;\n+                            j = i; \/\/ as here `i` is being read during the early construction phase, use the local var instead\n+                            super();\n+                            System.err.println(i);\n+                        }\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import jdk.internal.vm.annotation.Strict;\n+                    class Test {\n+                        @Strict\n+                        int i;\n+                        @Strict\n+                        int j;\n+                        Test() {\n+                            i = 1;\n+                            j = i;\n+                            super();\n+                            System.err.println(i);\n+                        }\n+                    }\n+                    \"\"\"\n+            };\n+            for (String source : sources) {\n+                File dir = assertOK(true, source);\n+                File fileEntry = dir.listFiles()[0];\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                String expectedCodeSequence = \"iconst_1,istore_1,aload_0,iload_1,putfield,aload_0,iload_1,putfield,\" +\n+                        \"aload_0,invokespecial,getstatic,aload_0,getfield,invokevirtual,return,\";\n+                for (Method method : classFile.methods) {\n+                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                        Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                        String foundCodeSequence = \"\";\n+                        for (Instruction inst: code.getInstructions()) {\n+                            foundCodeSequence += inst.getMnemonic() + \",\";\n+                        }\n+                        Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n+                    }\n+                }\n+            }\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":70,"deletions":8,"binary":false,"changes":78,"status":"modified"}]}