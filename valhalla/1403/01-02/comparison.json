{"files":[{"patch":"@@ -410,0 +410,4 @@\n+    public boolean isStrictInstance() {\n+        return (flags() & STRICT) != 0 && (flags() & STATIC) == 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.HashSet;\n@@ -32,0 +33,1 @@\n+import java.util.Set;\n@@ -94,0 +96,1 @@\n+    private Map<JCMethodDecl, Set<Symbol>> strictFieldsReadInPrologue = new HashMap<>();\n@@ -109,0 +112,6 @@\n+    public void addStrictFieldReadInPrologue(JCMethodDecl constructor, Symbol sym) {\n+        Set<Symbol> fieldSet = strictFieldsReadInPrologue.getOrDefault(constructor, new HashSet<>());\n+        fieldSet.add(sym);\n+        strictFieldsReadInPrologue.put(constructor, fieldSet);\n+    }\n+\n@@ -129,1 +138,0 @@\n-            super.visitClassDef(tree);\n@@ -135,0 +143,10 @@\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n+            strictInstanceFields = prevStrictInstanceFields;\n+        }\n+    }\n+\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        if (strictFieldsReadInPrologue.get(tree) != null) {\n+            Set<Symbol> fieldSet = strictFieldsReadInPrologue.get(tree);\n@@ -136,31 +154,10 @@\n-                for (JCTree t : tree.defs) {\n-                    if (t.hasTag(JCTree.Tag.METHODDEF)) {\n-                        JCMethodDecl md = (JCMethodDecl) t;\n-                        \/\/ ignore telescopic and generated constructors\n-                        if (TreeInfo.isConstructor(md) &&\n-                                TreeInfo.hasConstructorCall(md, names._super) &&\n-                                (md.sym.flags_field & Flags.GENERATEDCONSTR) == 0) {\n-                            \/\/ now we need to analyze the constructor's body, it could be that it is empty or that\n-                            \/\/ no assignment to strict fields is done\n-                            ConstructorScanner cs = new ConstructorScanner();\n-                            cs.scan(md);\n-                            java.util.List<JCVariableDecl> multiAssignedStrictFields = new ArrayList<>();\n-                            for (Symbol sym : cs.strictFieldsAssignedTo.keySet()) {\n-                                JCVariableDecl keep = null;\n-                                \/\/ if there is only one assignment there is no point in creating proxy locals, the code\n-                                \/\/ is good as it is\n-                                if (cs.strictFieldsAssignedTo.get(sym) > 1) {\n-                                    for (JCVariableDecl strictField : strictInstanceFields) {\n-                                        if (strictField.sym == sym) {\n-                                            keep = strictField;\n-                                            break;\n-                                        }\n-                                    }\n-                                    if (keep != null) {\n-                                        multiAssignedStrictFields.add(keep);\n-                                    }\n-                                }\n-                            }\n-                            if (!multiAssignedStrictFields.isEmpty()) {\n-                                addLocalProxiesFor(md, multiAssignedStrictFields);\n-                            }\n+                \/\/ ignore telescopic and generated constructors\n+                if (TreeInfo.isConstructor(tree) &&\n+                        TreeInfo.hasConstructorCall(tree, names._super) &&\n+                        (tree.sym.flags_field & Flags.GENERATEDCONSTR) == 0) {\n+                    \/\/ now we need to analyze the constructor's body, it could be that it is empty or that\n+                    \/\/ no assignment to strict fields is done\n+                    java.util.List<JCVariableDecl> strictFieldsRead = new ArrayList<>();\n+                    for (JCVariableDecl sfield : strictInstanceFields) {\n+                        if (fieldSet.contains(sfield.sym)) {\n+                            strictFieldsRead.add(sfield);\n@@ -169,0 +166,3 @@\n+                    if (!strictFieldsRead.isEmpty()) {\n+                        addLocalProxiesFor(tree, strictFieldsRead);\n+                    }\n@@ -171,3 +171,0 @@\n-        } finally {\n-            currentClass = prevCurrentClass;\n-            strictInstanceFields = prevStrictInstanceFields;\n@@ -175,0 +172,1 @@\n+        super.visitMethodDef(tree);\n@@ -226,1 +224,2 @@\n-                TreeInfo.mapSuperCalls(constructor.body, supercall -> make.Block(0, superArgsProxiesList.appendList(assigmentsBeforeSuper.toList()).append(supercall)));\n+                TreeInfo.mapSuperCalls(constructor.body,\n+                        supercall -> make.Block(0, superArgsProxiesList.appendList(assigmentsBeforeSuper.toList()).append(supercall)));\n@@ -272,31 +271,0 @@\n-\n-    \/* the idea of this scanner is to find how many assignments to strict fields occur inside a constructor's\n-     * body\n-     *\/\n-    private class ConstructorScanner extends TreeScanner {\n-        Map<Symbol, Integer> strictFieldsAssignedTo = new HashMap<>();\n-\n-        @Override\n-        public void visitAssign(JCAssign tree) {\n-            Symbol lhsSym = TreeInfo.symbol(tree.lhs);\n-            if (lhsSym != null && lhsSym instanceof VarSymbol vs && vs.isStrict()) {\n-                Integer noOfAssignments = strictFieldsAssignedTo.get(lhsSym);\n-                if (noOfAssignments == null) {\n-                    noOfAssignments = 0;\n-                }\n-                noOfAssignments++;\n-                strictFieldsAssignedTo.put(vs, noOfAssignments);\n-            }\n-            super.visitAssign(tree);\n-        }\n-\n-        @Override\n-        public void visitClassDef(JCClassDecl tree) {\n-            \/\/ don't descend any further\n-        }\n-\n-        @Override\n-        public void visitLambda(JCLambda tree) {\n-            \/\/ don't descend any further\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":35,"deletions":67,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+    private final LocalProxyVarsGen localProxyVarsGen;\n@@ -157,0 +158,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -1540,1 +1542,6 @@\n-                            return new RefBeforeCtorCalledError(sym);\n+                            if (!sym.isStrictInstance()) {\n+                                return new RefBeforeCtorCalledError(sym);\n+                            } else {\n+                                localProxyVarsGen.addStrictFieldReadInPrologue(env.enclMethod, sym);\n+                                return sym;\n+                            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-    private final LocalProxyVarsGen localProxyVarsGen;\n@@ -120,1 +119,0 @@\n-        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-\n+import java.util.function.Function;\n@@ -175,1 +175,1 @@\n-        super((Runnable)() -> x);       \/\/ this should FAIL\n+        super((Function<Integer, Integer>) f -> x);\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -15,1 +15,0 @@\n-ValueClassSuperInitFails.java:175:31: compiler.err.cant.ref.before.ctor.called: x\n@@ -28,1 +27,1 @@\n-25 errors\n+24 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/ValueClassSuperInitFails.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *      8329345 8341061 8340984\n+ *      8329345 8341061 8340984 8334484\n@@ -919,1 +919,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n@@ -923,1 +923,1 @@\n-                    Runnable r = () -> { System.err.println(t); };\n+                    Runnable r = () -> { System.err.println(t); }; \/\/ compiler will generate a local proxy for `t`\n@@ -937,1 +937,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n@@ -942,1 +942,1 @@\n-                    V1() {\n+                    V() {\n@@ -971,1 +971,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n@@ -1001,1 +1001,1 @@\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n+        assertOK(\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}