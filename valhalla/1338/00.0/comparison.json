{"files":[{"patch":"@@ -256,0 +256,1 @@\n+            \"--disable-cds-archive-coh\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1910,0 +1910,5 @@\n+                if (ed.packageName.equals(\"jdk\/internal\/javac\")) {\n+                    \/\/keep jdk\/internal\/javac untouched. It is used to determine participates in preview:\n+                    continue;\n+                }\n+\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+include JarArchive.gmk\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2627,0 +2627,17 @@\n+\n+  \/\/ Loads and stores with indirect memory input (e.g., volatile loads and\n+  \/\/ stores) do not subsume the input into complex addressing expressions. If\n+  \/\/ the addressing expression is input to at least one such load or store, do\n+  \/\/ not clone the addressing expression. Query needs_acquiring_load and\n+  \/\/ needs_releasing_store as a proxy for indirect memory input, as it is not\n+  \/\/ possible to directly query for indirect memory input at this stage.\n+  for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+    Node* n = m->fast_out(i);\n+    if (n->is_Load() && needs_acquiring_load(n)) {\n+      return false;\n+    }\n+    if (n->is_Store() && needs_releasing_store(n)) {\n+      return false;\n+    }\n+  }\n+\n@@ -5781,4 +5798,0 @@\n-opclass memory_noindex(indirect,\n-                       indOffI1, indOffL1,indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n-                       indirectN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n@@ -6721,1 +6734,1 @@\n-instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory_noindex mem)\n+instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory4 mem)\n@@ -6727,1 +6740,4 @@\n-  format %{ \"load_narrow_klass_compact  $dst, $mem\\t# compressed class ptr\" %}\n+  format %{\n+    \"ldrw  $dst, $mem\\t# compressed class ptr, shifted\\n\\t\"\n+    \"lsrw  $dst, $dst, markWord::klass_shift_at_offset\"\n+  %}\n@@ -6729,2 +6745,4 @@\n-    assert($mem$$index$$Register == noreg, \"must not have indexed address\");\n-    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$base$$Register, $mem$$disp);\n+    \/\/ inlined aarch64_enc_ldrw\n+    loadStore(masm, &MacroAssembler::ldrw, $dst$$Register, $mem->opcode(),\n+              as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n+    __ lsrw($dst$$Register, $dst$$Register, markWord::klass_shift_at_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2721,9 +2721,0 @@\n-\n-void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Register obj, int disp) {\n-  \/\/ Note: Don't clobber obj anywhere in that method!\n-\n-  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n-  \/\/ obj-start, so that we can load from the object's mark-word instead.\n-  ldr(dst, Address(obj, disp - oopDesc::klass_offset_in_bytes()));\n-  lsr(dst, dst, markWord::klass_shift);\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -191,2 +191,0 @@\n-  void load_narrow_klass_compact_c2(Register dst, Register obj, int disp);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -460,1 +460,7 @@\n-    Unimplemented();\n+    Label L;\n+    sub(rscratch2, rfp, esp);\n+    int min_frame_size = (frame::link_offset - frame::interpreter_frame_initial_sp_offset) * wordSize;\n+    subs(rscratch2, rscratch2, min_frame_size);\n+    br(Assembler::GE, L);\n+    stop(\"broken stack frame\");\n+    bind(L);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7105,10 +7105,0 @@\n-\n-#ifdef _LP64\n-void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Address src) {\n-  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n-  \/\/ obj-start, so that we can load from the object's mark-word instead. Usually the address\n-  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp.\n-  movq(dst, src.plus_disp(-oopDesc::klass_offset_in_bytes()));\n-  shrq(dst, markWord::klass_shift);\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -587,4 +587,0 @@\n-#ifdef _LP64\n-  void load_narrow_klass_compact_c2(Register dst, Address src);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4396,1 +4396,4 @@\n-  format %{ \"load_narrow_klass_compact    $dst, $mem\\t# compressed klass ptr\" %}\n+  format %{\n+    \"movl    $dst, $mem\\t# compressed klass ptr, shifted\\n\\t\"\n+    \"shrl    $dst, markWord::klass_shift_at_offset\"\n+  %}\n@@ -4398,1 +4401,2 @@\n-    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$Address);\n+    __ movl($dst$$Register, $mem$$Address);\n+    __ shrl($dst$$Register, markWord::klass_shift_at_offset);\n@@ -4400,1 +4404,1 @@\n-  ins_pipe(pipe_slow); \/\/ XXX\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -36,1 +37,1 @@\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -538,1 +539,8 @@\n-  if (!CompressedOops::is_null(source_referent)) {\n+  if (source_referent != nullptr) {\n+    if (java_lang_Class::is_instance(source_referent)) {\n+      \/\/ When the source object points to a \"real\" mirror, the buffered object should point\n+      \/\/ to the \"scratch\" mirror, which has all unarchivable fields scrubbed (to be reinstated\n+      \/\/ at run time).\n+      source_referent = HeapShared::scratch_java_mirror(source_referent);\n+      assert(source_referent != nullptr, \"must be\");\n+    }\n@@ -736,1 +744,3 @@\n-    assert(native_ptr != nullptr, \"sanity\");\n+    guarantee(native_ptr != nullptr, \"sanity\");\n+    guarantee(ArchiveBuilder::current()->has_been_buffered((address)native_ptr),\n+              \"Metadata %p should have been archived\", native_ptr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -45,0 +48,3 @@\n+bool CDSConfig::_has_aot_linked_classes = false;\n+bool CDSConfig::_has_archived_invokedynamic = false;\n+bool CDSConfig::_old_cds_flags_used = false;\n@@ -58,0 +64,2 @@\n+JavaThread* CDSConfig::_dumper_thread = nullptr;\n+\n@@ -66,1 +74,0 @@\n-\n@@ -363,0 +370,78 @@\n+#define CHECK_ALIAS(f) check_flag_alias(FLAG_IS_DEFAULT(f), #f)\n+\n+void CDSConfig::check_flag_alias(bool alias_is_default, const char* alias_name) {\n+  if (_old_cds_flags_used && !alias_is_default) {\n+    vm_exit_during_initialization(err_msg(\"Option %s cannot be used at the same time with \"\n+                                          \"-Xshare:on, -Xshare:auto, -Xshare:off, -Xshare:dump, \"\n+                                          \"DumpLoadedClassList, SharedClassListFile, or SharedArchiveFile\",\n+                                          alias_name));\n+  }\n+}\n+\n+void CDSConfig::check_flag_aliases() {\n+  if (!FLAG_IS_DEFAULT(DumpLoadedClassList) ||\n+      !FLAG_IS_DEFAULT(SharedClassListFile) ||\n+      !FLAG_IS_DEFAULT(SharedArchiveFile)) {\n+    _old_cds_flags_used = true;\n+  }\n+\n+  CHECK_ALIAS(AOTCache);\n+  CHECK_ALIAS(AOTConfiguration);\n+  CHECK_ALIAS(AOTMode);\n+\n+  if (FLAG_IS_DEFAULT(AOTCache) && FLAG_IS_DEFAULT(AOTConfiguration) && FLAG_IS_DEFAULT(AOTMode)) {\n+    \/\/ Aliases not used.\n+    return;\n+  }\n+\n+  if (FLAG_IS_DEFAULT(AOTMode) || strcmp(AOTMode, \"auto\") == 0 || strcmp(AOTMode, \"on\") == 0) {\n+    if (!FLAG_IS_DEFAULT(AOTConfiguration)) {\n+      vm_exit_during_initialization(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n+    }\n+\n+    if (!FLAG_IS_DEFAULT(AOTCache)) {\n+      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+    }\n+\n+    UseSharedSpaces = true;\n+    if (FLAG_IS_DEFAULT(AOTMode) || (strcmp(AOTMode, \"auto\") == 0)) {\n+      RequireSharedSpaces = false;\n+    } else {\n+      assert(strcmp(AOTMode, \"on\") == 0, \"already checked\");\n+      RequireSharedSpaces = true;\n+    }\n+  } else if (strcmp(AOTMode, \"off\") == 0) {\n+    UseSharedSpaces = false;\n+    RequireSharedSpaces = false;\n+  } else {\n+    \/\/ AOTMode is record or create\n+    if (FLAG_IS_DEFAULT(AOTConfiguration)) {\n+      vm_exit_during_initialization(err_msg(\"-XX:AOTMode=%s cannot be used without setting AOTConfiguration\", AOTMode));\n+    }\n+\n+    if (strcmp(AOTMode, \"record\") == 0) {\n+      if (!FLAG_IS_DEFAULT(AOTCache)) {\n+        vm_exit_during_initialization(\"AOTCache must not be specified when using -XX:AOTMode=record\");\n+      }\n+\n+      assert(FLAG_IS_DEFAULT(DumpLoadedClassList), \"already checked\");\n+      FLAG_SET_ERGO(DumpLoadedClassList, AOTConfiguration);\n+      UseSharedSpaces = false;\n+      RequireSharedSpaces = false;\n+    } else {\n+      assert(strcmp(AOTMode, \"create\") == 0, \"checked by AOTModeConstraintFunc\");\n+      if (FLAG_IS_DEFAULT(AOTCache)) {\n+        vm_exit_during_initialization(\"AOTCache must be specified when using -XX:AOTMode=create\");\n+      }\n+\n+      assert(FLAG_IS_DEFAULT(SharedClassListFile), \"already checked\");\n+      FLAG_SET_ERGO(SharedClassListFile, AOTConfiguration);\n+      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+\n+      CDSConfig::enable_dumping_static_archive();\n+    }\n+  }\n+}\n+\n@@ -364,0 +449,10 @@\n+  check_flag_aliases();\n+\n+  if (AOTClassLinking) {\n+    \/\/ If AOTClassLinking is specified, enable all AOT optimizations by default.\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTInvokeDynamicLinking, true);\n+  } else {\n+    \/\/ AOTInvokeDynamicLinking depends on AOTClassLinking.\n+    FLAG_SET_ERGO(AOTInvokeDynamicLinking, false);\n+  }\n+\n@@ -382,0 +477,3 @@\n+\n+    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n+    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n@@ -426,0 +524,5 @@\n+bool CDSConfig::allow_only_single_java_thread() {\n+  \/\/ See comments in JVM_StartThread()\n+  return is_dumping_static_archive();\n+}\n+\n@@ -440,0 +543,16 @@\n+\n+CDSConfig::DumperThreadMark::DumperThreadMark(JavaThread* current) {\n+  assert(_dumper_thread == nullptr, \"sanity\");\n+  _dumper_thread = current;\n+}\n+\n+CDSConfig::DumperThreadMark::~DumperThreadMark() {\n+  assert(_dumper_thread != nullptr, \"sanity\");\n+  _dumper_thread = nullptr;\n+}\n+\n+bool CDSConfig::current_thread_is_vm_or_dumper() {\n+  Thread* t = Thread::current();\n+  return t != nullptr && (t->is_VM_thread() || t == _dumper_thread);\n+}\n+\n@@ -450,0 +569,4 @@\n+bool CDSConfig::is_loading_heap() {\n+  return ArchiveHeapLoader::is_in_use();\n+}\n+\n@@ -488,0 +611,35 @@\n+\n+bool CDSConfig::is_dumping_aot_linked_classes() {\n+  if (is_dumping_dynamic_archive()) {\n+    return is_using_full_module_graph() && AOTClassLinking;\n+  } else if (is_dumping_static_archive()) {\n+    return is_dumping_full_module_graph() && AOTClassLinking;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool CDSConfig::is_using_aot_linked_classes() {\n+  \/\/ Make sure we have the exact same module graph as in the assembly phase, or else\n+  \/\/ some aot-linked classes may not be visible so cannot be loaded.\n+  return is_using_full_module_graph() && _has_aot_linked_classes;\n+}\n+\n+void CDSConfig::set_has_aot_linked_classes(bool has_aot_linked_classes) {\n+  _has_aot_linked_classes |= has_aot_linked_classes;\n+}\n+\n+bool CDSConfig::is_initing_classes_at_dump_time() {\n+  return is_dumping_heap() && is_dumping_aot_linked_classes();\n+}\n+\n+bool CDSConfig::is_dumping_invokedynamic() {\n+  \/\/ Requires is_dumping_aot_linked_classes(). Otherwise the classes of some archived heap\n+  \/\/ objects used by the archive indy callsites may be replaced at runtime.\n+  return AOTInvokeDynamicLinking && is_dumping_aot_linked_classes() && is_dumping_heap();\n+}\n+\n+bool CDSConfig::is_loading_invokedynamic() {\n+  return UseSharedSpaces && is_using_full_module_graph() && _has_archived_invokedynamic;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":159,"deletions":1,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class JavaThread;\n+\n@@ -39,0 +41,2 @@\n+  static bool _has_aot_linked_classes;\n+  static bool _has_archived_invokedynamic;\n@@ -46,0 +50,4 @@\n+\n+  static bool  _old_cds_flags_used;\n+\n+  static JavaThread* _dumper_thread;\n@@ -53,0 +61,3 @@\n+  static void check_flag_alias(bool alias_is_default, const char* alias_name);\n+  static void check_flag_aliases();\n+\n@@ -63,0 +74,2 @@\n+  static void set_old_cds_flags_used()                       { CDS_ONLY(_old_cds_flags_used = true); }\n+  static bool old_cds_flags_used()                           { return CDS_ONLY(_old_cds_flags_used) NOT_CDS(false); }\n@@ -90,0 +103,3 @@\n+  \/\/ Misc CDS features\n+  static bool allow_only_single_java_thread()                NOT_CDS_RETURN_(false);\n+\n@@ -96,0 +112,4 @@\n+  static bool is_dumping_aot_linked_classes()                NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_using_aot_linked_classes()                  NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_aot_linked_classes(bool has_aot_linked_classes) NOT_CDS_JAVA_HEAP_RETURN;\n+\n@@ -107,1 +127,7 @@\n-  static bool   is_dumping_heap()                            NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_dumping_heap()                              NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_loading_heap()                              NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_initing_classes_at_dump_time()              NOT_CDS_JAVA_HEAP_RETURN_(false);\n+\n+  static bool is_dumping_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_loading_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_archived_invokedynamic()               { CDS_JAVA_HEAP_ONLY(_has_archived_invokedynamic = true); }\n@@ -117,0 +143,15 @@\n+\n+\n+  \/\/ Some CDS functions assume that they are called only within a single-threaded context. I.e.,\n+  \/\/ they are called from:\n+  \/\/    - The VM thread (e.g., inside VM_PopulateDumpSharedSpace)\n+  \/\/    - The thread that performs prepatory steps before switching to the VM thread\n+  \/\/ Since these two threads never execute concurrently, we can avoid using locks in these CDS\n+  \/\/ function. For safety, these functions should assert with CDSConfig::current_thread_is_vm_or_dumper().\n+  class DumperThreadMark {\n+  public:\n+    DumperThreadMark(JavaThread* current);\n+    ~DumperThreadMark();\n+  };\n+\n+  static bool current_thread_is_vm_or_dumper() NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -49,0 +49,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -72,3 +73,7 @@\n-    char errmsg[JVM_MAXPATHLEN];\n-    os::lasterror(errmsg, JVM_MAXPATHLEN);\n-    vm_exit_during_initialization(\"Loading classlist failed\", errmsg);\n+    char reason[JVM_MAXPATHLEN];\n+    os::lasterror(reason, JVM_MAXPATHLEN);\n+    vm_exit_during_initialization(err_msg(\"Loading %s %s failed\",\n+                                          FLAG_IS_DEFAULT(AOTConfiguration) ?\n+                                          \"classlist\" : \"AOTConfiguration file\",\n+                                          file),\n+                                  reason);\n@@ -601,0 +606,12 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ The CP entry for the invokedynamic instruction will be resolved.\n+    \/\/ No need to do the following.\n+    return;\n+  }\n+\n+  \/\/ This is an older CDS optimization:\n+  \/\/ We store a pre-generated version of the lambda proxy class in the AOT cache,\n+  \/\/ which will be loaded via JVM_LookupLambdaProxyClassFromArchive().\n+  \/\/ This eliminate dynamic class generation of the proxy class, but we still need to\n+  \/\/ resolve the CP entry for the invokedynamic instruction, which may result in\n+  \/\/ generation of LambdaForm classes.\n@@ -602,2 +619,1 @@\n-  Handle protection_domain;\n-  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, CHECK);\n+  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, true, CHECK);\n@@ -771,2 +787,1 @@\n-  Handle protection_domain;\n-  return SystemDictionary::find_instance_klass(current, class_name_symbol, class_loader, protection_domain);\n+  return SystemDictionary::find_instance_klass(current, class_name_symbol, class_loader);\n@@ -843,0 +858,2 @@\n+    case JVM_CONSTANT_InvokeDynamic:\n+      preresolve_indy = true;\n@@ -852,1 +869,1 @@\n-    ClassPrelinker::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n+    AOTConstantPoolResolver::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n@@ -855,1 +872,4 @@\n-    ClassPrelinker::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n+    AOTConstantPoolResolver::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n+  if (preresolve_indy) {\n+    AOTConstantPoolResolver::preresolve_indy_cp_entries(THREAD, ik, &preresolve_list);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+  _has_aot_linked_classes = CDSConfig::is_dumping_aot_linked_classes();\n@@ -293,0 +294,2 @@\n+  _has_archived_invokedynamic = CDSConfig::is_dumping_invokedynamic();\n+\n@@ -384,0 +387,2 @@\n+  st->print_cr(\"- has_aot_linked_classes          %d\", _has_aot_linked_classes);\n+  st->print_cr(\"- has_archived_invokedynamic      %d\", _has_archived_invokedynamic);\n@@ -1131,1 +1136,3 @@\n-  validate_non_existent_class_paths();\n+  if (!validate_non_existent_class_paths()) {\n+    return false;\n+  }\n@@ -1147,1 +1154,1 @@\n-void FileMapInfo::validate_non_existent_class_paths() {\n+bool FileMapInfo::validate_non_existent_class_paths() {\n@@ -1160,3 +1167,9 @@\n-      log_warning(cds)(\"Archived non-system classes are disabled because the \"\n-              \"file %s exists\", ent->name());\n-      header()->set_has_platform_or_app_classes(false);\n+      if (header()->has_aot_linked_classes()) {\n+        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n+                       \"file %s exists\", ent->name());\n+        return false;\n+      } else {\n+        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n+                         \"file %s exists\", ent->name());\n+        header()->set_has_platform_or_app_classes(false);\n+      }\n@@ -1165,0 +1178,2 @@\n+\n+  return true;\n@@ -2033,0 +2048,26 @@\n+class SharedDataRelocationTask : public ArchiveWorkerTask {\n+private:\n+  BitMapView* const _rw_bm;\n+  BitMapView* const _ro_bm;\n+  SharedDataRelocator* const _rw_reloc;\n+  SharedDataRelocator* const _ro_reloc;\n+\n+public:\n+  SharedDataRelocationTask(BitMapView* rw_bm, BitMapView* ro_bm, SharedDataRelocator* rw_reloc, SharedDataRelocator* ro_reloc) :\n+                           ArchiveWorkerTask(\"Shared Data Relocation\"),\n+                           _rw_bm(rw_bm), _ro_bm(ro_bm), _rw_reloc(rw_reloc), _ro_reloc(ro_reloc) {}\n+\n+  void work(int chunk, int max_chunks) override {\n+    work_on(chunk, max_chunks, _rw_bm, _rw_reloc);\n+    work_on(chunk, max_chunks, _ro_bm, _ro_reloc);\n+  }\n+\n+  void work_on(int chunk, int max_chunks, BitMapView* bm, SharedDataRelocator* reloc) {\n+    BitMap::idx_t size  = bm->size();\n+    BitMap::idx_t start = MIN2(size, size * chunk \/ max_chunks);\n+    BitMap::idx_t end   = MIN2(size, size * (chunk + 1) \/ max_chunks);\n+    assert(end > start, \"Sanity: no empty slices\");\n+    bm->iterate(reloc, start, end);\n+  }\n+};\n+\n@@ -2071,2 +2112,8 @@\n-    rw_ptrmap.iterate(&rw_patcher);\n-    ro_ptrmap.iterate(&ro_patcher);\n+\n+    if (AOTCacheParallelRelocation) {\n+      SharedDataRelocationTask task(&rw_ptrmap, &ro_ptrmap, &rw_patcher, &ro_patcher);\n+      ArchiveWorkers::workers()->run_task(&task);\n+    } else {\n+      rw_ptrmap.iterate(&rw_patcher);\n+      ro_ptrmap.iterate(&ro_patcher);\n+    }\n@@ -2149,1 +2196,10 @@\n-    CDSConfig::stop_using_full_module_graph();\n+    if (CDSConfig::is_using_aot_linked_classes()) {\n+      \/\/ It's too late to recover -- we have already committed to use the archived metaspace objects, but\n+      \/\/ the archived heap objects cannot be loaded, so we don't have the archived FMG to guarantee that\n+      \/\/ all AOT-linked classes are visible.\n+      \/\/\n+      \/\/ We get here because the heap is too small. The app will fail anyway. So let's quit.\n+      MetaspaceShared::unrecoverable_loading_error(\"CDS archive has aot-linked classes but the archived \"\n+                                                   \"heap objects cannot be loaded. Try increasing your heap size.\");\n+    }\n+    CDSConfig::stop_using_full_module_graph(\"archive heap loading failed\");\n@@ -2504,0 +2560,28 @@\n+bool FileMapInfo::validate_aot_class_linking() {\n+  \/\/ These checks need to be done after FileMapInfo::initialize(), which gets called before Universe::heap()\n+  \/\/ is available.\n+  if (header()->has_aot_linked_classes()) {\n+    CDSConfig::set_has_aot_linked_classes(true);\n+    if (JvmtiExport::should_post_class_file_load_hook()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\");\n+      return false;\n+    }\n+    if (JvmtiExport::has_early_vmstart_env()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\");\n+      return false;\n+    }\n+    if (!CDSConfig::is_using_full_module_graph()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when archived full module graph is not used.\");\n+      return false;\n+    }\n+\n+    const char* prop = Arguments::get_property(\"java.security.manager\");\n+    if (prop != nullptr && strcmp(prop, \"disallow\") != 0) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\", prop);\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -2553,0 +2637,5 @@\n+    if (has_aot_linked_classes()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when the \"\n+                     \"java.system.class.loader property is specified.\");\n+      return false;\n+    }\n@@ -2635,1 +2724,1 @@\n-  if (is_static() && !_has_full_module_graph) {\n+  if (is_static()) {\n@@ -2637,1 +2726,7 @@\n-    CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    if (!_has_full_module_graph) {\n+      CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    }\n+\n+    if (_has_archived_invokedynamic) {\n+      CDSConfig::set_has_archived_invokedynamic();\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":105,"deletions":10,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -262,0 +262,1 @@\n+  bool   _has_aot_linked_classes;       \/\/ Was the CDS archive created with -XX:+AOTClassLinking\n@@ -265,0 +266,1 @@\n+  bool   _has_archived_invokedynamic;   \/\/ Does the archive have aot-linked invokedynamic CP entries?\n@@ -309,0 +311,1 @@\n+  bool has_aot_linked_classes()            const { return _has_aot_linked_classes; }\n@@ -532,1 +535,2 @@\n-  void validate_non_existent_class_paths();\n+  bool validate_non_existent_class_paths();\n+  bool validate_aot_class_linking();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -100,1 +101,1 @@\n-static const Klass* _test_class = nullptr;\n+static Klass* _test_class = nullptr;\n@@ -122,0 +123,1 @@\n+\n@@ -136,1 +138,2 @@\n-KlassSubGraphInfo* HeapShared::_default_subgraph_info;\n+KlassSubGraphInfo* HeapShared::_dump_time_special_subgraph;\n+ArchivedKlassSubGraphInfoRecord* HeapShared::_run_time_special_subgraph;\n@@ -301,0 +304,1 @@\n+    debug_trace();\n@@ -312,2 +316,13 @@\n-      log_debug(cds, heap)(\"Archived heap object \" PTR_FORMAT \" : %s\",\n-                           p2i(obj), obj->klass()->external_name());\n+      LogTarget(Debug, cds, heap) log;\n+      LogStream out(log);\n+      out.print(\"Archived heap object \" PTR_FORMAT \" : %s \",\n+                p2i(obj), obj->klass()->external_name());\n+      if (java_lang_Class::is_instance(obj)) {\n+        Klass* k = java_lang_Class::as_Klass(obj);\n+        if (k != nullptr) {\n+          out.print(\"%s\", k->external_name());\n+        } else {\n+          out.print(\"primitive\");\n+        }\n+      }\n+      out.cr();\n@@ -374,0 +389,25 @@\n+\/\/ Given java_mirror that represents a (primitive or reference) type T,\n+\/\/ return the \"scratch\" version that represents the same type T.\n+\/\/ Note that if java_mirror will be returned if it's already a\n+\/\/ scratch mirror.\n+\/\/\n+\/\/ See java_lang_Class::create_scratch_mirror() for more info.\n+oop HeapShared::scratch_java_mirror(oop java_mirror) {\n+  assert(java_lang_Class::is_instance(java_mirror), \"must be\");\n+\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      if (_scratch_basic_type_mirrors[i].resolve() == java_mirror) {\n+        return java_mirror;\n+      }\n+    }\n+  }\n+\n+  if (java_lang_Class::is_primitive(java_mirror)) {\n+    return scratch_java_mirror(java_lang_Class::as_BasicType(java_mirror));\n+  } else {\n+    return scratch_java_mirror(java_lang_Class::as_Klass(java_mirror));\n+  }\n+}\n+\n@@ -402,0 +442,119 @@\n+\/\/TODO: we eventually want a more direct test for these kinds of things.\n+\/\/For example the JVM could record some bit of context from the creation\n+\/\/of the klass, such as who called the hidden class factory.  Using\n+\/\/string compares on names is fragile and will break as soon as somebody\n+\/\/changes the names in the JDK code.  See discussion in JDK-8342481 for\n+\/\/related ideas about marking AOT-related classes.\n+bool HeapShared::is_lambda_form_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() &&\n+    (ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$MH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$DMH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$BMH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$VH+\"));\n+}\n+\n+bool HeapShared::is_lambda_proxy_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() && (ik->name()->index_of_at(0, \"$$Lambda+\", 9) > 0);\n+}\n+\n+bool HeapShared::is_string_concat_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() && ik->name()->starts_with(\"java\/lang\/String$$StringConcat\");\n+}\n+\n+bool HeapShared::is_archivable_hidden_klass(InstanceKlass* ik) {\n+  return CDSConfig::is_dumping_invokedynamic() &&\n+    (is_lambda_form_klass(ik) || is_lambda_proxy_klass(ik) || is_string_concat_klass(ik));\n+}\n+\n+void HeapShared::copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m) {\n+  assert(orig_k->is_instance_klass(), \"sanity\");\n+  InstanceKlass* ik = InstanceKlass::cast(orig_k);\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n+\n+  assert(ik->is_initialized(), \"must be\");\n+\n+  int nfields = 0;\n+  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      int offset = fd.offset();\n+      switch (fd.field_type()) {\n+      case T_OBJECT:\n+      case T_ARRAY:\n+        m->obj_field_put(offset, orig_mirror->obj_field(offset));\n+        break;\n+      case T_BOOLEAN:\n+        m->bool_field_put(offset, orig_mirror->bool_field(offset));\n+        break;\n+      case T_BYTE:\n+        m->byte_field_put(offset, orig_mirror->byte_field(offset));\n+        break;\n+      case T_SHORT:\n+        m->short_field_put(offset, orig_mirror->short_field(offset));\n+        break;\n+      case T_CHAR:\n+        m->char_field_put(offset, orig_mirror->char_field(offset));\n+        break;\n+      case T_INT:\n+        m->int_field_put(offset, orig_mirror->int_field(offset));\n+        break;\n+      case T_LONG:\n+        m->long_field_put(offset, orig_mirror->long_field(offset));\n+        break;\n+      case T_FLOAT:\n+        m->float_field_put(offset, orig_mirror->float_field(offset));\n+        break;\n+      case T_DOUBLE:\n+        m->double_field_put(offset, orig_mirror->double_field(offset));\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      }\n+      nfields ++;\n+    }\n+  }\n+\n+  java_lang_Class::set_class_data(m, java_lang_Class::class_data(orig_mirror));\n+\n+  \/\/ Class::reflectData use SoftReference, which cannot be archived. Set it\n+  \/\/ to null and it will be recreated at runtime.\n+  java_lang_Class::set_reflection_data(m, nullptr);\n+\n+  if (log_is_enabled(Info, cds, init)) {\n+    ResourceMark rm;\n+    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s\", nfields, ik->external_name(),\n+                         ik->is_hidden() ? \" (hidden)\" : \"\");\n+  }\n+}\n+\n+static void copy_java_mirror_hashcode(oop orig_mirror, oop scratch_m) {\n+  \/\/ We need to retain the identity_hash, because it may have been used by some hashtables\n+  \/\/ in the shared heap.\n+  if (!orig_mirror->fast_no_hash_check()) {\n+    intptr_t src_hash = orig_mirror->identity_hash();\n+    if (UseCompactObjectHeaders) {\n+      narrowKlass nk = CompressedKlassPointers::encode(orig_mirror->klass());\n+      scratch_m->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+    } else {\n+      scratch_m->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+    }\n+    assert(scratch_m->mark().is_unlocked(), \"sanity\");\n+\n+    DEBUG_ONLY(intptr_t archived_hash = scratch_m->identity_hash());\n+    assert(src_hash == archived_hash, \"Different hash codes: original \" INTPTR_FORMAT \", archived \" INTPTR_FORMAT, src_hash, archived_hash);\n+  }\n+}\n+\n+static objArrayOop get_archived_resolved_references(InstanceKlass* src_ik) {\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+  if (buffered_ik->is_shared_boot_class() ||\n+      buffered_ik->is_shared_platform_class() ||\n+      buffered_ik->is_shared_app_class()) {\n+    objArrayOop rr = src_ik->constants()->resolved_references_or_null();\n+    if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+      return HeapShared::scratch_resolved_references(src_ik->constants());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -406,0 +565,1 @@\n+      oop orig_mirror = Universe::java_mirror(bt);\n@@ -408,1 +568,2 @@\n-      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m);\n+      copy_java_mirror_hashcode(orig_mirror, m);\n+      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n@@ -421,0 +582,1 @@\n+\n@@ -423,0 +585,10 @@\n+    oop orig_mirror = orig_k->java_mirror();\n+    oop m = scratch_java_mirror(orig_k);\n+    if (m != nullptr) {\n+      copy_java_mirror_hashcode(orig_mirror, m);\n+    }\n+  }\n+\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* orig_k = klasses->at(i);\n+    oop orig_mirror = orig_k->java_mirror();\n@@ -426,1 +598,1 @@\n-      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m);\n+      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n@@ -437,3 +609,3 @@\n-        oop rr = ik->constants()->prepare_resolved_references_for_archiving();\n-        if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n-          bool success = HeapShared::archive_reachable_objects_from(1, _default_subgraph_info, rr);\n+        objArrayOop rr = get_archived_resolved_references(InstanceKlass::cast(orig_k));\n+        if (rr != nullptr) {\n+          bool success = HeapShared::archive_reachable_objects_from(1, _dump_time_special_subgraph, rr);\n@@ -451,1 +623,1 @@\n-  bool success = archive_reachable_objects_from(1, _default_subgraph_info, shared_strings_array);\n+  bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, shared_strings_array);\n@@ -460,1 +632,1 @@\n-  bool success = archive_reachable_objects_from(1, _default_subgraph_info, exception);\n+  bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, exception);\n@@ -469,0 +641,2 @@\n+  } else if (java_lang_invoke_ResolvedMethodName::is_instance(orig_obj)) {\n+    ArchiveHeapWriter::mark_native_pointer(orig_obj, java_lang_invoke_ResolvedMethodName::vmtarget_offset());\n@@ -485,0 +659,108 @@\n+void HeapShared::start_finding_required_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  init_seen_objects_table();\n+\n+  \/\/ We first scan the objects that are known to be archived (from the archive_subgraph\n+  \/\/ tables)\n+  find_required_hidden_classes_helper(archive_subgraph_entry_fields);\n+  if (CDSConfig::is_dumping_full_module_graph()) {\n+    find_required_hidden_classes_helper(fmg_archive_subgraph_entry_fields);\n+  }\n+\n+  \/\/ Later, SystemDictionaryShared::find_all_archivable_classes_impl() will start\n+  \/\/ scanning the constant pools of all classes that it decides to archive.\n+}\n+\n+void HeapShared::end_finding_required_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  delete_seen_objects_table();\n+}\n+\n+void HeapShared::find_required_hidden_classes_helper(ArchivableStaticFieldInfo fields[]) {\n+  if (!CDSConfig::is_dumping_heap()) {\n+    return;\n+  }\n+  for (int i = 0; fields[i].valid(); i++) {\n+    ArchivableStaticFieldInfo* f = &fields[i];\n+    InstanceKlass* k = f->klass;\n+    oop m = k->java_mirror();\n+    oop o = m->obj_field(f->offset);\n+    if (o != nullptr) {\n+      find_required_hidden_classes_in_object(o);\n+    }\n+  }\n+}\n+\n+class HeapShared::FindRequiredHiddenClassesOopClosure: public BasicOopIterateClosure {\n+  GrowableArray<oop> _stack;\n+  template <class T> void do_oop_work(T *p) {\n+    \/\/ Recurse on a GrowableArray to avoid overflowing the C stack.\n+    oop o = RawAccess<>::oop_load(p);\n+    if (o != nullptr) {\n+      _stack.append(o);\n+    }\n+  }\n+\n+ public:\n+\n+  void do_oop(narrowOop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n+  void do_oop(      oop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n+\n+  FindRequiredHiddenClassesOopClosure(oop o) {\n+    _stack.append(o);\n+  }\n+  oop pop() {\n+    if (_stack.length() == 0) {\n+      return nullptr;\n+    } else {\n+      return _stack.pop();\n+    }\n+  }\n+};\n+\n+static void mark_required_if_hidden_class(Klass* k) {\n+  if (k != nullptr && k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_hidden()) {\n+      SystemDictionaryShared::mark_required_hidden_class(ik);\n+    }\n+  }\n+}\n+\n+\n+void HeapShared::find_required_hidden_classes_in_object(oop root) {\n+  ResourceMark rm;\n+  FindRequiredHiddenClassesOopClosure c(root);\n+  oop o;\n+  while ((o = c.pop()) != nullptr) {\n+    if (!has_been_seen_during_subgraph_recording(o)) {\n+      set_has_been_seen_during_subgraph_recording(o);\n+\n+      \/\/ Mark the klass of this object\n+      mark_required_if_hidden_class(o->klass());\n+\n+      \/\/ For special objects, mark the klass that they contain information about.\n+      \/\/ - a Class that refers to an hidden class\n+      \/\/ - a ResolvedMethodName that refers to a method declared in a hidden class\n+      if (java_lang_Class::is_instance(o)) {\n+        mark_required_if_hidden_class(java_lang_Class::as_Klass(o));\n+      } else if (java_lang_invoke_ResolvedMethodName::is_instance(o)) {\n+        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(o);\n+        if (m != nullptr) {\n+          mark_required_if_hidden_class(m->method_holder());\n+        }\n+      }\n+\n+      o->oop_iterate(&c);\n+    }\n+  }\n+}\n+\n@@ -489,1 +771,3 @@\n-    _default_subgraph_info = init_subgraph_info(vmClasses::Object_klass(), false);\n+    \/\/ The special subgraph doesn't belong to any class. We use Object_klass() here just\n+    \/\/ for convenience.\n+    _dump_time_special_subgraph = init_subgraph_info(vmClasses::Object_klass(), false);\n@@ -504,1 +788,1 @@\n-    check_default_subgraph_classes();\n+    check_special_subgraph_classes();\n@@ -516,1 +800,1 @@\n-    bool success = archive_reachable_objects_from(1, _default_subgraph_info, s);\n+    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, s);\n@@ -527,2 +811,3 @@\n-void HeapShared::copy_special_objects() {\n-  \/\/ Archive special objects that do not belong to any subgraphs\n+void HeapShared::copy_special_subgraph() {\n+  copy_interned_strings();\n+\n@@ -530,3 +815,5 @@\n-  archive_java_mirrors();\n-  archive_strings();\n-  Universe::archive_exception_instances();\n+  {\n+    archive_java_mirrors();\n+    archive_strings();\n+    Universe::archive_exception_instances();\n+  }\n@@ -536,0 +823,11 @@\n+void HeapShared::prepare_resolved_references() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_k));\n+      buffered_ik->constants()->prepare_resolved_references_for_archiving();\n+    }\n+  }\n+}\n+\n@@ -539,2 +837,3 @@\n-  copy_interned_strings();\n-  copy_special_objects();\n+  prepare_resolved_references();\n+  find_all_aot_initialized_classes();\n+  copy_special_subgraph();\n@@ -552,0 +851,192 @@\n+\/\/ Closure used by HeapShared::scan_for_aot_initialized_classes() to look for all objects\n+\/\/ that are reachable from a given root.\n+class HeapShared::AOTInitializedClassScanner : public BasicOopIterateClosure {\n+  bool _made_progress;\n+\n+  template <class T> void check(T *p) {\n+    oop obj = HeapAccess<>::oop_load(p);\n+    if (!java_lang_Class::is_instance(obj)) {\n+      \/\/ Don't scan the mirrors, as we may see an orig_mirror while scanning\n+      \/\/ the object graph, .... TODO more info\n+      _made_progress |= HeapShared::scan_for_aot_initialized_classes(obj);\n+    }\n+  }\n+\n+public:\n+  AOTInitializedClassScanner() : _made_progress(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool made_progress() { return _made_progress; }\n+};\n+\n+\/\/ If <buffered_ik> has been initialized during the assembly phase, mark its\n+\/\/ has_aot_initialized_mirror bit. And then do the same for all supertypes of\n+\/\/ <buffered_ik>.\n+\/\/\n+\/\/ Note: a super interface <intf> of <buffered_ik> may not have been initialized, if\n+\/\/ <intf> has not declared any default methods.\n+\/\/\n+\/\/ Note: this function doesn not call InstanceKlass::initialize() -- we are inside\n+\/\/ a safepoint.\n+\/\/\n+\/\/ Returns true if one or more classes have been newly marked.\n+static bool mark_for_aot_initialization(InstanceKlass* buffered_ik) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n+\n+  if (buffered_ik->has_aot_initialized_mirror()) { \/\/ already marked\n+    return false;\n+  }\n+\n+  bool made_progress = false;\n+  if (buffered_ik->is_initialized()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"Mark class for aot-init: %s\", buffered_ik->external_name());\n+    }\n+\n+    InstanceKlass* src_ik = ArchiveBuilder::current()->get_source_addr(buffered_ik);\n+\n+    \/\/ If we get here with a \"wild\" user class, which may have\n+    \/\/ uncontrolled <clinit> code, exit with an error.  Obviously\n+    \/\/ filtering logic upstream needs to detect APP classes and not mark\n+    \/\/ them for aot-init in the first place, but this will be the final\n+    \/\/ firewall.\n+\n+#ifndef PRODUCT\n+    \/\/ ArchiveHeapTestClass is used for a very small number of internal regression\n+    \/\/ tests (non-product builds only). It may initialize some unexpected classes.\n+    if (ArchiveHeapTestClass == nullptr)\n+#endif\n+    {\n+      if (!src_ik->in_javabase_module()) {\n+        \/\/ Class\/interface types in the boot loader may have been initialized as side effects\n+        \/\/ of JVM bootstrap code, so they are fine. But we need to check all other classes.\n+        if (buffered_ik->is_interface()) {\n+          \/\/ This probably means a bug in AOTConstantPoolResolver.::is_indy_resolution_deterministic()\n+          guarantee(!buffered_ik->interface_needs_clinit_execution_as_super(),\n+                    \"should not have initialized an interface whose <clinit> might have unpredictable side effects\");\n+        } else {\n+          \/\/ \"normal\" classes\n+          guarantee(HeapShared::is_archivable_hidden_klass(buffered_ik),\n+                    \"should not have initialized any non-interface, non-hidden classes outside of java.base\");\n+        }\n+      }\n+    }\n+\n+    buffered_ik->set_has_aot_initialized_mirror();\n+    if (AOTClassInitializer::is_runtime_setup_required(src_ik)) {\n+      buffered_ik->set_is_runtime_setup_required();\n+    }\n+    made_progress = true;\n+\n+    InstanceKlass* super = buffered_ik->java_super();\n+    if (super != nullptr) {\n+      mark_for_aot_initialization(super);\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = buffered_ik->transitive_interfaces();\n+    for (int i = 0; i < interfaces->length(); i++) {\n+      InstanceKlass* intf = interfaces->at(i);\n+      mark_for_aot_initialization(intf);\n+      if (!intf->is_initialized()) {\n+        assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false), \"sanity\");\n+        assert(!intf->has_aot_initialized_mirror(), \"must not be marked\");\n+      }\n+    }\n+  }\n+\n+  return made_progress;\n+}\n+\n+void HeapShared::find_all_aot_initialized_classes() {\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    return;\n+  }\n+\n+  init_seen_objects_table();\n+  find_all_aot_initialized_classes_helper();\n+  delete_seen_objects_table();\n+}\n+\n+\/\/ Recursively find all class that should be aot-initialized:\n+\/\/ - the class has at least one instance that can be reachable from the special subgraph; or\n+\/\/ - the class is hard-coded in AOTClassInitializer::can_archive_initialized_mirror()\n+void HeapShared::find_all_aot_initialized_classes_helper() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  assert(klasses != nullptr, \"sanity\");\n+\n+  \/\/ First scan all resolved constant pools references.\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+      objArrayOop rr = get_archived_resolved_references(src_ik);\n+      if (rr != nullptr) {\n+        objArrayOop scratch_rr = scratch_resolved_references(src_ik->constants());\n+        for (int i = 0; i < scratch_rr->length(); i++) {\n+          scan_for_aot_initialized_classes(scratch_rr->obj_at(i));\n+        }\n+      }\n+\n+      \/\/ If a class is hard-coded to be aot-initialize, mark it as such.\n+      if (AOTClassInitializer::can_archive_initialized_mirror(src_ik)) {\n+        mark_for_aot_initialization(buffered_ik);\n+      }\n+    }\n+  }\n+\n+  \/\/ These objects also belong to the special subgraph\n+  scan_for_aot_initialized_classes(Universe::null_ptr_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::arithmetic_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::internal_error_instance());\n+  scan_for_aot_initialized_classes(Universe::array_index_out_of_bounds_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::array_store_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::class_cast_exception_instance());\n+\n+  bool made_progress;\n+  do {\n+    \/\/ In each pass, we copy the scratch mirrors of the classes that were marked\n+    \/\/ as aot-init in the previous pass. We then scan these mirrors, which may\n+    \/\/ mark more classes. Keep iterating until no more progress can be made.\n+    made_progress = false;\n+    for (int i = 0; i < klasses->length(); i++) {\n+      Klass* orig_k = klasses->at(i);\n+      if (orig_k->is_instance_klass()) {\n+        InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n+        if (ArchiveBuilder::current()->get_buffered_addr(orig_ik)->has_aot_initialized_mirror()) {\n+          oop orig_mirror = orig_ik->java_mirror();\n+          oop scratch_mirror = scratch_java_mirror(orig_k);\n+          if (!has_been_seen_during_subgraph_recording(scratch_mirror)) {\n+            \/\/ Scan scratch_mirror instead of orig_mirror (which has fields like ClassLoader that\n+            \/\/ are not archived).\n+            copy_aot_initialized_mirror(orig_k, orig_mirror, scratch_mirror);\n+            made_progress |= scan_for_aot_initialized_classes(scratch_mirror);\n+          }\n+        }\n+      }\n+    }\n+  } while (made_progress);\n+}\n+\n+bool HeapShared::scan_for_aot_initialized_classes(oop obj) {\n+  if (obj == nullptr || has_been_seen_during_subgraph_recording(obj)) {\n+    return false;\n+  }\n+  set_has_been_seen_during_subgraph_recording(obj);\n+\n+  bool made_progress = false;\n+  Klass* k = obj->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* orig_ik = InstanceKlass::cast(k);\n+    InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(orig_ik);\n+    made_progress = mark_for_aot_initialization(buffered_ik);\n+  }\n+\n+  AOTInitializedClassScanner scanner;\n+  obj->oop_iterate(&scanner);\n+  made_progress |= scanner.made_progress();\n+  return made_progress;\n+}\n+\n@@ -610,2 +1101,8 @@\n-    assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n-          \"must be boot class\");\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class() ||\n+             HeapShared::is_lambda_proxy_klass(InstanceKlass::cast(buffered_k)),\n+            \"we can archive only instances of boot classes or lambda proxy classes\");\n+    } else {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n+             \"must be boot class\");\n+    }\n@@ -620,0 +1117,4 @@\n+    if (buffered_k->has_aot_initialized_mirror()) {\n+      \/\/ No need to add to the runtime-init list.\n+      return;\n+    }\n@@ -656,0 +1157,11 @@\n+  const char* lambda_msg = \"\";\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    lambda_msg = \", or a lambda proxy class\";\n+    if (HeapShared::is_lambda_proxy_klass(ik) &&\n+        (ik->class_loader() == nullptr ||\n+         ik->class_loader() == SystemDictionary::java_platform_loader() ||\n+         ik->class_loader() == SystemDictionary::java_system_loader())) {\n+      return;\n+    }\n+  }\n+\n@@ -657,1 +1169,1 @@\n-  if (!ik->module()->is_named() && ik->package() == nullptr) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr && ArchiveHeapTestClass != nullptr) {\n@@ -661,1 +1173,1 @@\n-  const char* extra_msg = \", or in an unnamed package of an unnamed module\";\n+  const char* testcls_msg = \", or a test class in an unnamed package of an unnamed module\";\n@@ -663,1 +1175,1 @@\n-  const char* extra_msg = \"\";\n+  const char* testcls_msg = \"\";\n@@ -667,2 +1179,2 @@\n-  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s\",\n-                       ik->external_name(), extra_msg);\n+  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n+                       ik->external_name(), lambda_msg, testcls_msg);\n@@ -730,0 +1242,1 @@\n+    bool is_special = (_k == ArchiveBuilder::get_buffered_klass(vmClasses::Object_klass()));\n@@ -734,0 +1247,4 @@\n+        const char* owner_name =  is_special ? \"<special>\" : _k->external_name();\n+        if (subgraph_k->is_instance_klass()) {\n+          InstanceKlass* src_ik = InstanceKlass::cast(ArchiveBuilder::current()->get_source_addr(subgraph_k));\n+        }\n@@ -736,1 +1253,1 @@\n-          _k->external_name(), i, subgraph_k->external_name());\n+          owner_name, i, subgraph_k->external_name());\n@@ -748,1 +1265,1 @@\n-struct CopyKlassSubGraphInfoToArchive : StackObj {\n+class HeapShared::CopyKlassSubGraphInfoToArchive : StackObj {\n@@ -750,0 +1267,1 @@\n+public:\n@@ -754,4 +1272,1 @@\n-      ArchivedKlassSubGraphInfoRecord* record =\n-        (ArchivedKlassSubGraphInfoRecord*)ArchiveBuilder::ro_region_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n-      record->init(&info);\n-\n+      ArchivedKlassSubGraphInfoRecord* record = HeapShared::archive_subgraph_info(&info);\n@@ -767,0 +1282,10 @@\n+ArchivedKlassSubGraphInfoRecord* HeapShared::archive_subgraph_info(KlassSubGraphInfo* info) {\n+  ArchivedKlassSubGraphInfoRecord* record =\n+      (ArchivedKlassSubGraphInfoRecord*)ArchiveBuilder::ro_region_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n+  record->init(info);\n+  if (info ==  _dump_time_special_subgraph) {\n+    _run_time_special_subgraph = record;\n+  }\n+  return record;\n+}\n+\n@@ -823,0 +1348,1 @@\n+  soc->do_ptr(&_run_time_special_subgraph);\n@@ -890,0 +1416,59 @@\n+void HeapShared::initialize_java_lang_invoke(TRAPS) {\n+  if (CDSConfig::is_loading_invokedynamic() || CDSConfig::is_dumping_invokedynamic()) {\n+    resolve_or_init(\"java\/lang\/invoke\/Invokers$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandle\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandleNatives\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DirectMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/LambdaForm$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/BoundMethodHandle$Species_L\", true, CHECK);\n+  }\n+}\n+\n+\/\/ Initialize the InstanceKlasses of objects that are reachable from the following roots:\n+\/\/   - interned strings\n+\/\/   - Klass::java_mirror() -- including aot-initialized mirrors such as those of Enum klasses.\n+\/\/   - ConstantPool::resolved_references()\n+\/\/   - Universe::<xxx>_exception_instance()\n+\/\/\n+\/\/ For example, if this enum class is initialized at AOT cache assembly time:\n+\/\/\n+\/\/    enum Fruit {\n+\/\/       APPLE, ORANGE, BANANA;\n+\/\/       static final Set<Fruit> HAVE_SEEDS = new HashSet<>(Arrays.asList(APPLE, ORANGE));\n+\/\/   }\n+\/\/\n+\/\/ the aot-initialized mirror of Fruit has a static field that references HashSet, which\n+\/\/ should be initialized before any Java code can access the Fruit class. Note that\n+\/\/ HashSet itself doesn't necessary need to be an aot-initialized class.\n+void HeapShared::init_classes_for_special_subgraph(Handle class_loader, TRAPS) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n+    return;\n+  }\n+\n+  assert( _run_time_special_subgraph != nullptr, \"must be\");\n+  Array<Klass*>* klasses = _run_time_special_subgraph->subgraph_object_klasses();\n+  if (klasses != nullptr) {\n+    for (int pass = 0; pass < 2; pass ++) {\n+      for (int i = 0; i < klasses->length(); i++) {\n+        Klass* k = klasses->at(i);\n+        if (k->class_loader_data() == nullptr) {\n+          \/\/ This class is not yet loaded. We will initialize it in a later phase.\n+          \/\/ For example, we have loaded only AOTLinkedClassCategory::BOOT1 classes\n+          \/\/ but k is part of AOTLinkedClassCategory::BOOT2.\n+          continue;\n+        }\n+        if (k->class_loader() == class_loader()) {\n+          if (pass == 0) {\n+            if (k->is_instance_klass()) {\n+              InstanceKlass::cast(k)->link_class(CHECK);\n+            }\n+          } else {\n+            resolve_or_init(k, \/*do_init*\/true, CHECK);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -993,0 +1578,13 @@\n+void HeapShared::resolve_or_init(const char* klass_name, bool do_init, TRAPS) {\n+  TempNewSymbol klass_name_sym =  SymbolTable::new_symbol(klass_name);\n+  InstanceKlass* k = SystemDictionaryShared::find_builtin_class(klass_name_sym);\n+  if (k == nullptr) {\n+    return;\n+  }\n+  assert(k->is_shared_boot_class(), \"sanity\");\n+  resolve_or_init(k, false, CHECK);\n+  if (do_init) {\n+    resolve_or_init(k, true, CHECK);\n+  }\n+}\n+\n@@ -1025,1 +1623,5 @@\n-      m->obj_field_put(field_offset, v);\n+      if (k->has_aot_initialized_mirror()) {\n+        assert(v == m->obj_field(field_offset), \"must be aot-initialized\");\n+      } else {\n+        m->obj_field_put(field_offset, v);\n+      }\n@@ -1033,2 +1635,3 @@\n-      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s\",\n-                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\");\n+      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n+                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\",\n+                          k->has_aot_initialized_mirror() ? \" (aot-inited)\" : \"\");\n@@ -1140,0 +1743,14 @@\n+void HeapShared::init_box_classes(TRAPS) {\n+  if (ArchiveHeapLoader::is_in_use()) {\n+    vmClasses::Boolean_klass()->initialize(CHECK);\n+    vmClasses::Character_klass()->initialize(CHECK);\n+    vmClasses::Float_klass()->initialize(CHECK);\n+    vmClasses::Double_klass()->initialize(CHECK);\n+    vmClasses::Byte_klass()->initialize(CHECK);\n+    vmClasses::Short_klass()->initialize(CHECK);\n+    vmClasses::Integer_klass()->initialize(CHECK);\n+    vmClasses::Long_klass()->initialize(CHECK);\n+    vmClasses::Void_klass()->initialize(CHECK);\n+  }\n+}\n+\n@@ -1154,8 +1771,2 @@\n-    log_error(cds, heap)(\"Cannot archive object of class %s\", orig_obj->klass()->external_name());\n-    if (log_is_enabled(Trace, cds, heap)) {\n-      WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n-      if (walker != nullptr) {\n-        LogStream ls(Log(cds, heap)::trace());\n-        CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n-      }\n-    }\n+    log_error(cds, heap)(\"Cannot archive object \" PTR_FORMAT \" of class %s\", p2i(orig_obj), orig_obj->klass()->external_name());\n+    debug_trace();\n@@ -1165,8 +1776,45 @@\n-  \/\/ java.lang.Class instances cannot be included in an archived object sub-graph. We only support\n-  \/\/ them as Klass::_archived_mirror because they need to be specially restored at run time.\n-  \/\/\n-  \/\/ If you get an error here, you probably made a change in the JDK library that has added a Class\n-  \/\/ object that is referenced (directly or indirectly) by static fields.\n-  if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _default_subgraph_info) {\n-    log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n-    MetaspaceShared::unrecoverable_writing_error();\n+  if (log_is_enabled(Debug, cds, heap) && java_lang_Class::is_instance(orig_obj)) {\n+    ResourceMark rm;\n+    LogTarget(Debug, cds, heap) log;\n+    LogStream out(log);\n+    out.print(\"Found java mirror \" PTR_FORMAT \" \", p2i(orig_obj));\n+    Klass* k = java_lang_Class::as_Klass(orig_obj);\n+    if (k != nullptr) {\n+      out.print(\"%s\", k->external_name());\n+    } else {\n+      out.print(\"primitive\");\n+    }\n+    out.print_cr(\"; scratch mirror = \"  PTR_FORMAT,\n+                 p2i(scratch_java_mirror(orig_obj)));\n+  }\n+\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    if (java_lang_Class::is_instance(orig_obj)) {\n+      orig_obj = scratch_java_mirror(orig_obj);\n+      assert(orig_obj != nullptr, \"must be archived\");\n+    }\n+  } else if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _dump_time_special_subgraph) {\n+    \/\/ Without CDSConfig::is_initing_classes_at_dump_time(), we only allow archived objects to\n+    \/\/ point to the mirrors of (1) j.l.Object, (2) primitive classes, and (3) box classes. These are initialized\n+    \/\/ very early by HeapShared::init_box_classes().\n+    if (orig_obj == vmClasses::Object_klass()->java_mirror()\n+        || java_lang_Class::is_primitive(orig_obj)\n+        || orig_obj == vmClasses::Boolean_klass()->java_mirror()\n+        || orig_obj == vmClasses::Character_klass()->java_mirror()\n+        || orig_obj == vmClasses::Float_klass()->java_mirror()\n+        || orig_obj == vmClasses::Double_klass()->java_mirror()\n+        || orig_obj == vmClasses::Byte_klass()->java_mirror()\n+        || orig_obj == vmClasses::Short_klass()->java_mirror()\n+        || orig_obj == vmClasses::Integer_klass()->java_mirror()\n+        || orig_obj == vmClasses::Long_klass()->java_mirror()\n+        || orig_obj == vmClasses::Void_klass()->java_mirror()) {\n+      orig_obj = scratch_java_mirror(orig_obj);\n+      assert(orig_obj != nullptr, \"must be archived\");\n+    } else {\n+      \/\/ If you get an error here, you probably made a change in the JDK library that has added a Class\n+      \/\/ object that is referenced (directly or indirectly) by an ArchivableStaticFieldInfo\n+      \/\/ defined at the top of this file.\n+      log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n+      debug_trace();\n+      MetaspaceShared::unrecoverable_writing_error();\n+    }\n@@ -1212,2 +1860,7 @@\n-  if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n-    CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ The enum klasses are archived with aot-initialized mirror.\n+    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n+  } else {\n+    if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n+      CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+    }\n@@ -1215,0 +1868,1 @@\n+\n@@ -1332,0 +1986,4 @@\n+  if (java_lang_Class::is_instance(obj)) {\n+    obj = scratch_java_mirror(obj);\n+    assert(obj != nullptr, \"must be\");\n+  }\n@@ -1341,14 +1999,28 @@\n-\/\/ The \"default subgraph\" contains special objects (see heapShared.hpp) that\n-\/\/ can be accessed before we load any Java classes (including java\/lang\/Class).\n-\/\/ Make sure that these are only instances of the very few specific types\n-\/\/ that we can handle.\n-void HeapShared::check_default_subgraph_classes() {\n-  GrowableArray<Klass*>* klasses = _default_subgraph_info->subgraph_object_klasses();\n-  int num = klasses->length();\n-  for (int i = 0; i < num; i++) {\n-    Klass* subgraph_k = klasses->at(i);\n-    if (log_is_enabled(Info, cds, heap)) {\n-      ResourceMark rm;\n-      log_info(cds, heap)(\n-          \"Archived object klass (default subgraph %d) => %s\",\n-          i, subgraph_k->external_name());\n+void HeapShared::check_special_subgraph_classes() {\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ We can have aot-initialized classes (such as Enums) that can reference objects\n+    \/\/ of arbitrary types. Currently, we trust the JEP 483 implementation to only\n+    \/\/ aot-initialize classes that are \"safe\".\n+    \/\/\n+    \/\/ TODO: we need an automatic tool that checks the safety of aot-initialized\n+    \/\/ classes (when we extend the set of aot-initialized classes beyond JEP 483)\n+    return;\n+  } else {\n+    \/\/ In this case, the special subgraph should contain a few specific types\n+    GrowableArray<Klass*>* klasses = _dump_time_special_subgraph->subgraph_object_klasses();\n+    int num = klasses->length();\n+    for (int i = 0; i < num; i++) {\n+      Klass* subgraph_k = klasses->at(i);\n+      Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+      if (subgraph_k->is_instance_klass() &&\n+          name != vmSymbols::java_lang_Class() &&\n+          name != vmSymbols::java_lang_String() &&\n+          name != vmSymbols::java_lang_ArithmeticException() &&\n+          name != vmSymbols::java_lang_ArrayIndexOutOfBoundsException() &&\n+          name != vmSymbols::java_lang_ArrayStoreException() &&\n+          name != vmSymbols::java_lang_ClassCastException() &&\n+          name != vmSymbols::java_lang_InternalError() &&\n+          name != vmSymbols::java_lang_NullPointerException()) {\n+        ResourceMark rm;\n+        fatal(\"special subgraph cannot have objects of type %s\", subgraph_k->external_name());\n+      }\n@@ -1356,14 +2028,0 @@\n-\n-    Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n-    guarantee(name == vmSymbols::java_lang_Class() ||\n-              name == vmSymbols::java_lang_String() ||\n-              name == vmSymbols::java_lang_ArithmeticException() ||\n-              name == vmSymbols::java_lang_NullPointerException() ||\n-              name == vmSymbols::java_lang_InternalError() ||\n-              name == vmSymbols::java_lang_ArrayIndexOutOfBoundsException() ||\n-              name == vmSymbols::java_lang_ArrayStoreException() ||\n-              name == vmSymbols::java_lang_ClassCastException() ||\n-              name == vmSymbols::object_array_signature() ||\n-              name == vmSymbols::byte_array_signature() ||\n-              name == vmSymbols::char_array_signature(),\n-              \"default subgraph can have only these objects\");\n@@ -1575,2 +2233,2 @@\n-        \/\/ See KlassSubGraphInfo::check_allowed_klass() - only two types of\n-        \/\/ classes are allowed:\n+        \/\/ See KlassSubGraphInfo::check_allowed_klass() - we only allow test classes\n+        \/\/ to be:\n@@ -1592,0 +2250,19 @@\n+\n+void HeapShared::initialize_test_class_from_archive(JavaThread* current) {\n+  Klass* k = _test_class;\n+  if (k != nullptr && ArchiveHeapLoader::is_in_use()) {\n+    JavaThread* THREAD = current;\n+    ExceptionMark em(THREAD);\n+    const ArchivedKlassSubGraphInfoRecord* record =\n+      resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/false, THREAD);\n+\n+    \/\/ The _test_class is in the unnamed module, so it can't call CDS.initializeFromArchive()\n+    \/\/ from its <clinit> method. So we set up its \"archivedObjects\" field first, before\n+    \/\/ calling its <clinit>. This is not strictly clean, but it's a convenient way to write unit\n+    \/\/ test cases (see test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java).\n+    if (record != nullptr) {\n+      init_archived_fields_for(k, record);\n+    }\n+    resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/true, THREAD);\n+  }\n+}\n@@ -1674,0 +2351,9 @@\n+void HeapShared::debug_trace() {\n+  ResourceMark rm;\n+  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+  if (walker != nullptr) {\n+    LogStream ls(Log(cds, heap)::error());\n+    CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+  }\n+}\n+\n@@ -1760,1 +2446,1 @@\n-  InstanceKlass* k = SystemDictionary::find_instance_klass(current, klass_name, Handle(), Handle());\n+  InstanceKlass* k = SystemDictionary::find_instance_klass(current, klass_name, Handle());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":772,"deletions":86,"binary":false,"changes":858,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -32,1 +35,0 @@\n-#include \"cds\/cds_globals.hpp\"\n@@ -35,1 +37,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -103,0 +104,1 @@\n+Array<Method*>* MetaspaceShared::_archived_method_handle_intrinsics = nullptr;\n@@ -313,0 +315,1 @@\n+\/\/ Extra java.lang.Strings to be added to the archive\n@@ -314,0 +317,1 @@\n+\/\/ Extra Symbols to be added to the archive\n@@ -315,0 +319,2 @@\n+\/\/ Methods managed by SystemDictionary::find_method_handle_intrinsic() to be added to the archive\n+static GrowableArray<Method*>* _pending_method_handle_intrinsics = NULL;\n@@ -365,0 +371,24 @@\n+void MetaspaceShared::make_method_handle_intrinsics_shareable() {\n+  for (int i = 0; i < _pending_method_handle_intrinsics->length(); i++) {\n+    Method* m = ArchiveBuilder::current()->get_buffered_addr(_pending_method_handle_intrinsics->at(i));\n+    m->remove_unshareable_info();\n+    \/\/ Each method has its own constant pool (which is distinct from m->method_holder()->constants());\n+    m->constants()->remove_unshareable_info();\n+  }\n+}\n+\n+void MetaspaceShared::write_method_handle_intrinsics() {\n+  int len = _pending_method_handle_intrinsics->length();\n+  _archived_method_handle_intrinsics = ArchiveBuilder::new_ro_array<Method*>(len);\n+  int word_size = _archived_method_handle_intrinsics->size();\n+  for (int i = 0; i < len; i++) {\n+    Method* m = _pending_method_handle_intrinsics->at(i);\n+    ArchiveBuilder::current()->write_pointer_in_buffer(_archived_method_handle_intrinsics->adr_at(i), m);\n+    word_size += m->size() + m->constMethod()->size() + m->constants()->size();\n+    if (m->constants()->cache() != nullptr) {\n+      word_size += m->constants()->cache()->size();\n+    }\n+  }\n+  log_info(cds)(\"Archived %d method handle intrinsics (%d bytes)\", len, word_size * BytesPerWord);\n+}\n+\n@@ -436,1 +466,1 @@\n-\n+  AOTLinkedClassBulkLoader::serialize(soc, true);\n@@ -444,0 +474,1 @@\n+  soc->do_ptr((void**)&_archived_method_handle_intrinsics);\n@@ -531,0 +562,4 @@\n+\n+    for (int i = 0; i < _pending_method_handle_intrinsics->length(); i++) {\n+      it->push(_pending_method_handle_intrinsics->adr_at(i));\n+    }\n@@ -553,0 +588,2 @@\n+  AOTClassLinker::write_to_archive();\n+  MetaspaceShared::write_method_handle_intrinsics();\n@@ -571,0 +608,7 @@\n+  _pending_method_handle_intrinsics = new (mtClassShared) GrowableArray<Method*>(256, mtClassShared);\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ When dumping AOT-linked classes, some classes may have direct references to a method handle\n+    \/\/ intrinsic. The easiest thing is to save all of them into the AOT cache.\n+    SystemDictionary::get_all_method_handle_intrinsics(_pending_method_handle_intrinsics);\n+  }\n+\n@@ -577,1 +621,1 @@\n-  SystemDictionaryShared::check_excluded_classes();\n+  SystemDictionaryShared::find_all_archivable_classes();\n@@ -594,0 +638,1 @@\n+  MetaspaceShared::make_method_handle_intrinsics_shareable();\n@@ -661,1 +706,1 @@\n-  ClassPrelinker::dumptime_resolve_constants(ik, CHECK_(false));\n+  AOTConstantPoolResolver::dumptime_resolve_constants(ik, CHECK_(false));\n@@ -666,1 +711,1 @@\n-  ClassPrelinker::initialize();\n+  AOTClassLinker::initialize();\n@@ -714,0 +759,1 @@\n+  CDSConfig::DumperThreadMark dumper_thread_mark(THREAD);\n@@ -728,0 +774,9 @@\n+\n+  if (!CDSConfig::old_cds_flags_used()) {\n+    \/\/ The JLI launcher only recognizes the \"old\" -Xshare:dump flag.\n+    \/\/ When the new -XX:AOTMode=create flag is used, we can't return\n+    \/\/ to the JLI launcher, as the launcher will fail when trying to\n+    \/\/ run the main class, which is not what we want.\n+    tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n+    vm_exit(0);\n+  }\n@@ -856,0 +911,23 @@\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n+      \/\/ updated concurrently when we are saving their contents into a side table.\n+      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+                             vmSymbols::createArchivedObjects(),\n+                             vmSymbols::void_method_signature(),\n+                             CHECK);\n+\n+      \/\/ java.lang.Class::reflectionFactory cannot be archived yet. We set this field\n+      \/\/ to null, and it will be initialized again at runtime.\n+      log_debug(cds)(\"Resetting Class::reflectionFactory\");\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"resetArchivedStates\");\n+      Symbol* method_sig = vmSymbols::void_method_signature();\n+      JavaCalls::call_static(&result, vmClasses::Class_klass(),\n+                             method_name, method_sig, CHECK);\n+\n+      \/\/ Perhaps there is a way to avoid hard-coding these names here.\n+      \/\/ See discussion in JDK-8342481.\n+    }\n+\n@@ -1019,0 +1097,3 @@\n+  \/\/ We are about to open the archives. Initialize workers now.\n+  ArchiveWorkers::workers()->initialize();\n+\n@@ -1545,0 +1626,5 @@\n+  if (!mapinfo->validate_aot_class_linking()) {\n+    unmap_archive(mapinfo);\n+    return MAP_ARCHIVE_OTHER_FAILURE;\n+  }\n+\n@@ -1605,0 +1691,15 @@\n+  \/\/ Archive was fully read. Workers are no longer needed.\n+  ArchiveWorkers::workers()->shutdown();\n+\n+  LogStreamHandle(Info, cds) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Using AOT-linked classes: %s (static archive: %s aot-linked classes\",\n+              BOOL_TO_STR(CDSConfig::is_using_aot_linked_classes()),\n+              static_mapinfo->header()->has_aot_linked_classes() ? \"has\" : \"no\");\n+    if (dynamic_mapinfo != nullptr) {\n+      lsh.print(\", dynamic archive: %s aot-linked classes\",\n+                dynamic_mapinfo->header()->has_aot_linked_classes() ? \"has\" : \"no\");\n+    }\n+    lsh.print_cr(\")\");\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":107,"deletions":6,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class Method;\n@@ -41,0 +42,1 @@\n+template<class E> class Array;\n@@ -59,0 +61,1 @@\n+  static Array<Method*>* _archived_method_handle_intrinsics;\n@@ -114,0 +117,3 @@\n+  static void make_method_handle_intrinsics_shareable() NOT_CDS_RETURN;\n+  static void write_method_handle_intrinsics() NOT_CDS_RETURN;\n+  static Array<Method*>* archived_method_handle_intrinsics() { return _archived_method_handle_intrinsics; }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -466,1 +466,0 @@\n-  Handle domain;\n@@ -469,1 +468,0 @@\n-    domain = Handle(current, accessing_klass->protection_domain());\n@@ -473,1 +471,1 @@\n-                         SystemDictionary::find_instance_or_array_klass(current, sym, loader, domain) :\n+                         SystemDictionary::find_instance_or_array_klass(current, sym, loader) :\n@@ -1620,2 +1618,1 @@\n-  \/\/ The very first entry is the InstanceKlass of the root method of the current compilation in order to get the right\n-  \/\/ protection domain to load subsequent classes during replay compilation.\n+  \/\/ The very first entry is the InstanceKlass of the root method of the current compilation.\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -813,2 +813,1 @@\n-                                                                 Handle(THREAD, holder->class_loader()),\n-                                                                 Handle(THREAD, holder->protection_domain()));\n+                                                                 Handle(THREAD, holder->class_loader()));\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,2 +118,0 @@\n-  Handle  _protection_domain;\n-  bool    _protection_domain_initialized;\n@@ -148,2 +146,0 @@\n-    _protection_domain = Handle();\n-    _protection_domain_initialized = false;\n@@ -562,1 +558,1 @@\n-        k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);\n+        k = SystemDictionary::resolve_or_fail(klass_name, _loader, true, THREAD);\n@@ -583,1 +579,1 @@\n-    return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);\n+    return SystemDictionary::resolve_or_fail(klass_name, _loader, true, THREAD);\n@@ -900,12 +896,0 @@\n-    if (_version >= 1) {\n-      if (!_protection_domain_initialized && k != nullptr) {\n-        assert(_protection_domain() == nullptr, \"must be uninitialized\");\n-        \/\/ The first entry is the holder class of the method for which a replay compilation is requested.\n-        \/\/ Use the same protection domain to load all subsequent classes in order to resolve all classes\n-        \/\/ in signatures of inlinees. This ensures that inlining can be done as stated in the replay file.\n-        _protection_domain = Handle(_thread, k->protection_domain());\n-      }\n-\n-      _protection_domain_initialized = true;\n-    }\n-\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4914,1 +4914,1 @@\n-  if (!_need_verify || _relax_verify) { return; }\n+  if (!_need_verify) { return; }\n@@ -4958,1 +4958,1 @@\n-  if (!_need_verify || _relax_verify) { return; }\n+  if (!_need_verify) { return; }\n@@ -4991,1 +4991,1 @@\n-  if (!_need_verify || _relax_verify) { return; }\n+  if (!_need_verify) { return; }\n@@ -5538,11 +5538,0 @@\n-static bool relax_format_check_for(ClassLoaderData* loader_data) {\n-  bool trusted = loader_data->is_boot_class_loader_data() ||\n-                 loader_data->is_platform_class_loader_data();\n-  bool need_verify =\n-    \/\/ verifyAll\n-    (BytecodeVerificationLocal && BytecodeVerificationRemote) ||\n-    \/\/ verifyRemote\n-    (!BytecodeVerificationLocal && BytecodeVerificationRemote && !trusted);\n-  return !need_verify;\n-}\n-\n@@ -5608,1 +5597,0 @@\n-  _relax_verify(false),\n@@ -5635,14 +5623,1 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    \/\/ verify == true means it's a 'remote' class (i.e., non-boot class)\n-    \/\/ Verification decision is based on BytecodeVerificationRemote flag\n-    \/\/ for those classes.\n-    _need_verify = (stream->need_verify()) ? BytecodeVerificationRemote :\n-                                              BytecodeVerificationLocal;\n-  }\n-  else {\n-    _need_verify = Verifier::should_verify_for(_loader_data->class_loader(),\n-                                               stream->need_verify());\n-  }\n-\n-  \/\/ synch back verification state to stream\n-  stream->set_verify(_need_verify);\n+  _need_verify = Verifier::should_verify_for(_loader_data->class_loader());\n@@ -5650,3 +5625,2 @@\n-  \/\/ Check if verification needs to be relaxed for this class file\n-  \/\/ Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)\n-  _relax_verify = relax_format_check_for(_loader_data);\n+  \/\/ synch back verification state to stream to check for truncation.\n+  stream->set_need_verify(_need_verify);\n@@ -6050,1 +6024,0 @@\n-                                                               _protection_domain,\n@@ -6134,1 +6107,0 @@\n-                                                  _protection_domain,\n@@ -6207,1 +6179,1 @@\n-        Klass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, s, Handle(THREAD, _loader_data->class_loader()), _protection_domain, false, THREAD);\n+        Klass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, s, Handle(THREAD, _loader_data->class_loader()), false, THREAD);\n@@ -6245,1 +6217,1 @@\n-          Klass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, name, Handle(THREAD, loader), _protection_domain, false, THREAD);\n+          Klass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, name, Handle(THREAD, loader), false, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":36,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-  bool _relax_verify;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"classfile\/klassFactory.hpp\"\n@@ -38,1 +40,0 @@\n-#include \"classfile\/klassFactory.hpp\"\n@@ -143,14 +144,10 @@\n-  \/\/ The counters are only active if the logging is enabled, but\n-  \/\/ we print to the passed in outputStream as requested.\n-  if (log_is_enabled(Info, perf, class, link)) {\n-    st->print_cr(\"ClassLoader:\");\n-    st->print_cr(\"  clinit:               \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", ClassLoader::class_init_time_ms(), ClassLoader::class_init_count());\n-    st->print_cr(\"  link methods:         \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_ik_link_methods_time->get_value())   , _perf_ik_link_methods_count->get_value());\n-    st->print_cr(\"  method adapters:      \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_method_adapters_time->get_value())   , _perf_method_adapters_count->get_value());\n-    st->print_cr(\"  resolve...\");\n-    st->print_cr(\"    invokedynamic:   \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_indy_time->get_value())         , _perf_resolve_indy_count->get_value());\n-    st->print_cr(\"    invokehandle:    \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_invokehandle_time->get_value()) , _perf_resolve_invokehandle_count->get_value());\n-    st->print_cr(\"    CP_MethodHandle: \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_mh_time->get_value())           , _perf_resolve_mh_count->get_value());\n-    st->print_cr(\"    CP_MethodType:   \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_mt_time->get_value())           , _perf_resolve_mt_count->get_value());\n-    st->cr();\n-  }\n+  st->print_cr(\"ClassLoader:\");\n+  st->print_cr(\"  clinit:               \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", ClassLoader::class_init_time_ms(), ClassLoader::class_init_count());\n+  st->print_cr(\"  link methods:         \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_ik_link_methods_time->get_value())   , _perf_ik_link_methods_count->get_value());\n+  st->print_cr(\"  method adapters:      \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_method_adapters_time->get_value())   , _perf_method_adapters_count->get_value());\n+  st->print_cr(\"  resolve...\");\n+  st->print_cr(\"    invokedynamic:   \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_indy_time->get_value())         , _perf_resolve_indy_count->get_value());\n+  st->print_cr(\"    invokehandle:    \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_invokehandle_time->get_value()) , _perf_resolve_invokehandle_count->get_value());\n+  st->print_cr(\"    CP_MethodHandle: \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_mh_time->get_value())           , _perf_resolve_mh_count->get_value());\n+  st->print_cr(\"    CP_MethodType:   \" JLONG_FORMAT \"ms \/ \" JLONG_FORMAT \" events\", Management::ticks_to_ms(_perf_resolve_mt_time->get_value())           , _perf_resolve_mt_count->get_value());\n+  st->cr();\n@@ -300,2 +297,1 @@\n-                                   _dir,\n-                                   ClassFileStream::verify);\n+                                   _dir);\n@@ -369,2 +365,1 @@\n-                             _zip_name,\n-                             ClassFileStream::verify);\n+                             _zip_name);\n@@ -452,1 +447,0 @@\n-                               ClassFileStream::verify,\n@@ -1216,2 +1210,0 @@\n-  stream->set_verify(ClassLoaderExt::should_verify(classpath_index));\n-\n@@ -1304,1 +1296,1 @@\n-    \/\/ We do not archive hidden classes.\n+    record_hidden_class(ik);\n@@ -1412,0 +1404,38 @@\n+\n+void ClassLoader::record_hidden_class(InstanceKlass* ik) {\n+  assert(ik->is_hidden(), \"must be\");\n+\n+  s2 classloader_type;\n+  if (HeapShared::is_lambda_form_klass(ik)) {\n+    classloader_type = ClassLoader::BOOT_LOADER;\n+  } else {\n+    oop loader = ik->class_loader();\n+\n+    if (loader == nullptr) {\n+      classloader_type = ClassLoader::BOOT_LOADER;\n+    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+      classloader_type = ClassLoader::PLATFORM_LOADER;\n+    } else if (SystemDictionary::is_system_class_loader(loader)) {\n+      classloader_type = ClassLoader::APP_LOADER;\n+    } else {\n+      \/\/ This class won't be archived, so no need to update its\n+      \/\/ classloader_type\/classpath_index.\n+      return;\n+    }\n+  }\n+  ik->set_shared_class_loader_type(classloader_type);\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    ik->set_shared_classpath_index(nest_host->shared_classpath_index());\n+  } else if (HeapShared::is_lambda_form_klass(ik)) {\n+    ik->set_shared_classpath_index(0);\n+  } else {\n+    \/\/ Generated invoker classes.\n+    if (classloader_type == ClassLoader::APP_LOADER) {\n+      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n+    } else {\n+      ik->set_shared_classpath_index(0);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":53,"deletions":23,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, strlen(utf8_str), false)) {\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, strlen(utf8_str), \/*version_leq_47*\/false)) {\n@@ -370,1 +370,1 @@\n-Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {\n+Handle java_lang_String::create_from_symbol(const Symbol* symbol, TRAPS) {\n@@ -394,0 +394,2 @@\n+  \/\/ This check is too strict on older classfile versions\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, utf8_len, \/*version_leq_47*\/false))\n@@ -760,0 +762,29 @@\n+bool java_lang_String::equals(oop java_string, const char* utf8_string, size_t utf8_len) {\n+  assert(java_string->klass() == vmClasses::String_klass(),\n+         \"must be java_string\");\n+  typeArrayOop value = java_lang_String::value_no_keepalive(java_string);\n+  int length = java_lang_String::length(java_string, value);\n+  int unicode_length = UTF8::unicode_length(utf8_string, utf8_len);\n+  if (length != unicode_length) {\n+    return false;\n+  }\n+  bool is_latin1 = java_lang_String::is_latin1(java_string);\n+  jchar c;\n+  if (!is_latin1) {\n+    for (int i = 0; i < unicode_length; i++) {\n+      utf8_string = UTF8::next(utf8_string, &c);\n+      if (value->char_at(i) != c) {\n+        return false;\n+      }\n+    }\n+  } else {\n+    for (int i = 0; i < unicode_length; i++) {\n+      utf8_string = UTF8::next(utf8_string, &c);\n+      if ((((jchar) value->byte_at(i)) & 0xff) != c) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -841,0 +872,1 @@\n+int java_lang_Class::_reflectionData_offset;\n@@ -1287,0 +1319,5 @@\n+void java_lang_Class::set_reflection_data(oop java_class, oop reflection_data) {\n+  assert(_reflectionData_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_reflectionData_offset, reflection_data);\n+}\n+\n@@ -1483,0 +1520,1 @@\n+  macro(_reflectionData_offset,      k, \"reflectionData\",      java_lang_ref_SoftReference_signature, false); \\\n@@ -1629,1 +1667,1 @@\n-  macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \\\n+  macro(_contextClassLoader_offset, k, \"contextClassLoader\", classloader_signature, false); \\\n@@ -2035,0 +2073,1 @@\n+int java_lang_VirtualThread::_objectWaiter_offset;\n@@ -2050,0 +2089,1 @@\n+  VTHREAD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n@@ -2165,0 +2205,16 @@\n+ObjectMonitor* java_lang_VirtualThread::current_pending_monitor(oop vthread) {\n+  ObjectWaiter* waiter = objectWaiter(vthread);\n+  if (waiter != nullptr && waiter->at_monitorenter()) {\n+    return waiter->monitor();\n+  }\n+  return nullptr;\n+}\n+\n+ObjectMonitor* java_lang_VirtualThread::current_waiting_monitor(oop vthread) {\n+  ObjectWaiter* waiter = objectWaiter(vthread);\n+  if (waiter != nullptr && waiter->is_wait()) {\n+    return waiter->monitor();\n+  }\n+  return nullptr;\n+}\n+\n@@ -2175,0 +2231,1 @@\n+   VTHREAD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n@@ -4704,41 +4761,0 @@\n-\/\/ Support for java_security_AccessControlContext\n-\n-int java_security_AccessControlContext::_context_offset;\n-int java_security_AccessControlContext::_privilegedContext_offset;\n-int java_security_AccessControlContext::_isPrivileged_offset;\n-int java_security_AccessControlContext::_isAuthorized_offset;\n-\n-#define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \\\n-  macro(_context_offset,           k, \"context\",      protectiondomain_signature, false); \\\n-  macro(_privilegedContext_offset, k, \"privilegedContext\", accesscontrolcontext_signature, false); \\\n-  macro(_isPrivileged_offset,      k, \"isPrivileged\", bool_signature, false); \\\n-  macro(_isAuthorized_offset,      k, \"isAuthorized\", bool_signature, false)\n-\n-void java_security_AccessControlContext::compute_offsets() {\n-  assert(_isPrivileged_offset == 0, \"offsets should be initialized only once\");\n-  InstanceKlass* k = vmClasses::AccessControlContext_klass();\n-  ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {\n-  ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {\n-  assert(_isPrivileged_offset != 0, \"offsets should have been initialized\");\n-  assert(_isAuthorized_offset != 0, \"offsets should have been initialized\");\n-  \/\/ Ensure klass is initialized\n-  vmClasses::AccessControlContext_klass()->initialize(CHECK_NULL);\n-  \/\/ Allocate result\n-  oop result = vmClasses::AccessControlContext_klass()->allocate_instance(CHECK_NULL);\n-  \/\/ Fill in values\n-  result->obj_field_put(_context_offset, context());\n-  result->obj_field_put(_privilegedContext_offset, privileged_context());\n-  result->bool_field_put(_isPrivileged_offset, isPrivileged);\n-  result->bool_field_put(_isAuthorized_offset, true);\n-  return result;\n-}\n-\n-\n@@ -4881,11 +4897,0 @@\n-\/\/ This field tells us that a security manager can never be installed so we\n-\/\/ can completely skip populating the ProtectionDomainCacheTable.\n-bool java_lang_System::allow_security_manager() {\n-  return false;\n-}\n-\n-\/\/ This field tells us that a security manager is installed.\n-bool java_lang_System::has_security_manager() {\n-  return false;\n-}\n-\n@@ -5406,1 +5411,0 @@\n-  f(java_security_AccessControlContext) \\\n@@ -5469,14 +5473,12 @@\n-  if (klass == vmClasses::ClassLoader_klass() ||  \/\/ ClassLoader::loader_data is malloc'ed.\n-      \/\/ The next 3 classes are used to implement java.lang.invoke, and are not used directly in\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated hidden classes\n-      \/\/ (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.\n-      \/\/ So for now we cannot not support these classes for archiving.\n-      \/\/\n-      \/\/ These objects typically are not referenced by static fields, but rather by resolved\n-      \/\/ constant pool entries, so excluding them shouldn't affect the archiving of static fields.\n-      klass == vmClasses::ResolvedMethodName_klass() ||\n-      klass == vmClasses::MemberName_klass() ||\n-      klass == vmClasses::Context_klass() ||\n-      \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-      \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n-      klass->is_subclass_of(vmClasses::Reference_klass())) {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ These are supported by CDS only when CDSConfig::is_dumping_invokedynamic() is enabled.\n+    if (klass == vmClasses::ResolvedMethodName_klass() ||\n+        klass == vmClasses::MemberName_klass() ||\n+        klass == vmClasses::Context_klass()) {\n+      return false;\n+    }\n+  }\n+\n+  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n+    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n+    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":72,"deletions":70,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -40,0 +41,2 @@\n+class ObjectWaiter;\n+class ObjectMonitor;\n@@ -102,1 +105,1 @@\n-  static Handle create_from_symbol(Symbol* symbol, TRAPS);\n+  static Handle create_from_symbol(const Symbol* symbol, TRAPS);\n@@ -183,0 +186,12 @@\n+  static unsigned int hash_code(const char* utf8_str, size_t utf8_len) {\n+    unsigned int h = 0;\n+    int unicode_length = UTF8::unicode_length(utf8_str, utf8_len);\n+\n+    jchar c;\n+    while (unicode_length-- > 0) {\n+      utf8_str = UTF8::next(utf8_str, &c);\n+      h = 31 * h + ((unsigned int)c);\n+    }\n+    return h;\n+  }\n+\n@@ -186,0 +201,1 @@\n+  \/\/ Compare strings (of different types\/encodings), length is the string (array) length\n@@ -187,0 +203,1 @@\n+  static bool equals(oop java_string, const char* utf8_str, size_t utf8_len);\n@@ -243,0 +260,1 @@\n+  static int _reflectionData_offset;\n@@ -313,0 +331,1 @@\n+  static void set_reflection_data(oop java_class, oop reflection_data);\n@@ -525,0 +544,2 @@\n+#define VTHREAD_INJECTED_FIELDS(macro)                                           \\\n+  macro(java_lang_VirtualThread,   objectWaiter,  intptr_signature,       false)\n@@ -537,0 +558,1 @@\n+  static int _objectWaiter_offset;\n@@ -588,0 +610,5 @@\n+\n+  static inline ObjectWaiter* objectWaiter(oop vthread);\n+  static inline void set_objectWaiter(oop vthread, ObjectWaiter* waiter);\n+  static ObjectMonitor* current_pending_monitor(oop vthread);\n+  static ObjectMonitor* current_waiting_monitor(oop vthread);\n@@ -1470,21 +1497,0 @@\n-\/\/ Interface to java.security.AccessControlContext objects\n-\n-class java_security_AccessControlContext: AllStatic {\n- private:\n-  \/\/ Note that for this class the layout changed between JDK1.2 and JDK1.3,\n-  \/\/ so we compute the offsets at startup rather than hard-wiring them.\n-  static int _context_offset;\n-  static int _privilegedContext_offset;\n-  static int _isPrivileged_offset;\n-  static int _isAuthorized_offset;\n-\n-  static void compute_offsets();\n- public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-  static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);\n-\n-  \/\/ Debugging\/initialization\n-  friend class JavaClasses;\n-};\n-\n-\n@@ -1547,3 +1553,0 @@\n-  static int _static_security_offset;\n-  static int _static_allow_security_offset;\n-  static int _static_never_offset;\n@@ -1555,2 +1558,0 @@\n-  static bool allow_security_manager();\n-  static bool has_security_manager();\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"classfile\/protectionDomainCache.hpp\"\n@@ -88,0 +87,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -140,3 +140,3 @@\n-  if (_java_system_loader.is_empty()) {\n-    oop system_loader = get_system_class_loader_impl(CHECK);\n-    _java_system_loader = OopHandle(Universe::vm_global(), system_loader);\n+  if (_java_platform_loader.is_empty()) {\n+    oop platform_loader = get_platform_class_loader_impl(CHECK);\n+    _java_platform_loader = OopHandle(Universe::vm_global(), platform_loader);\n@@ -148,2 +148,2 @@\n-      oop system_loader = get_system_class_loader_impl(CHECK);\n-      assert(_java_system_loader.resolve() == system_loader, \"must be\");\n+      oop platform_loader = get_platform_class_loader_impl(CHECK);\n+      assert(_java_platform_loader.resolve() == platform_loader, \"must be\");\n@@ -153,3 +153,3 @@\n-  if (_java_platform_loader.is_empty()) {\n-    oop platform_loader = get_platform_class_loader_impl(CHECK);\n-    _java_platform_loader = OopHandle(Universe::vm_global(), platform_loader);\n+  if (_java_system_loader.is_empty()) {\n+    oop system_loader = get_system_class_loader_impl(CHECK);\n+    _java_system_loader = OopHandle(Universe::vm_global(), system_loader);\n@@ -161,2 +161,2 @@\n-      oop platform_loader = get_platform_class_loader_impl(CHECK);\n-      assert(_java_platform_loader.resolve() == platform_loader, \"must be\");\n+      oop system_loader = get_system_class_loader_impl(CHECK);\n+      assert(_java_system_loader.resolve() == system_loader, \"must be\");\n@@ -336,1 +336,1 @@\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain,\n+Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader,\n@@ -338,1 +338,1 @@\n-  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n+  Klass* klass = resolve_or_null(class_name, class_loader, THREAD);\n@@ -348,1 +348,1 @@\n-Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {\n+Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, TRAPS) {\n@@ -350,1 +350,1 @@\n-    return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);\n+    return resolve_array_class_or_null(class_name, class_loader, THREAD);\n@@ -358,1 +358,1 @@\n-      return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);\n+      return resolve_instance_class_or_null(name, class_loader, THREAD);\n@@ -360,1 +360,1 @@\n-      return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);\n+      return resolve_instance_class_or_null(class_name, class_loader, THREAD);\n@@ -369,1 +369,0 @@\n-                                                     Handle protection_domain,\n@@ -381,1 +380,0 @@\n-                                                         protection_domain,\n@@ -427,1 +425,0 @@\n-                                                                    Handle protection_domain,\n@@ -493,1 +490,0 @@\n-                                                     protection_domain,\n@@ -520,1 +516,1 @@\n-                                       Handle protection_domain, TRAPS) {\n+                                       TRAPS) {\n@@ -528,1 +524,0 @@\n-                                                                       protection_domain,\n@@ -594,1 +589,0 @@\n-                                                                Handle protection_domain,\n@@ -608,6 +602,2 @@\n-  \/\/ Do lookup to see if class already exists and the protection domain\n-  \/\/ has the right access.\n-  \/\/ This call uses find which checks protection domain already matches\n-  \/\/ All subsequent calls use find_class, and set loaded_class so that\n-  \/\/ before we return a result, we call out to java to check for valid protection domain.\n-  InstanceKlass* probe = dictionary->find(THREAD, name, protection_domain);\n+  \/\/ Do lookup to see if class already exists.\n+  InstanceKlass* probe = dictionary->find_class(THREAD, name);\n@@ -659,1 +649,0 @@\n-                               protection_domain,\n@@ -744,6 +733,0 @@\n-  if (protection_domain() != nullptr) {\n-    \/\/ A SecurityManager (if installed) may prevent this protection_domain from accessing loaded_class\n-    \/\/ by throwing a SecurityException.\n-    dictionary->check_package_access(loaded_class, class_loader, protection_domain, CHECK_NULL);\n-  }\n-\n@@ -767,2 +750,1 @@\n-                                                     Handle class_loader,\n-                                                     Handle protection_domain) {\n+                                                     Handle class_loader) {\n@@ -778,1 +760,1 @@\n-  return dictionary->find(current, class_name, protection_domain);\n+  return dictionary->find_class(current, class_name);\n@@ -785,2 +767,1 @@\n-                                                      Handle class_loader,\n-                                                      Handle protection_domain) {\n+                                                      Handle class_loader) {\n@@ -800,1 +781,1 @@\n-      k = SystemDictionary::find_instance_klass(current, ss.as_symbol(), class_loader, protection_domain);\n+      k = SystemDictionary::find_instance_klass(current, ss.as_symbol(), class_loader);\n@@ -806,1 +787,1 @@\n-    k = find_instance_klass(current, class_name, class_loader, protection_domain);\n+    k = find_instance_klass(current, class_name, class_loader);\n@@ -832,1 +813,0 @@\n-  assert(st->need_verify(), \"invariant\");\n@@ -1050,2 +1030,1 @@\n-                                                     Handle class_loader,  Handle protection_domain,\n-                                                     bool is_superclass, TRAPS) {\n+                                                     Handle class_loader, bool is_superclass, TRAPS) {\n@@ -1061,1 +1040,1 @@\n-    InstanceKlass* check = find_instance_klass(THREAD, name, class_loader, protection_domain);\n+    InstanceKlass* check = find_instance_klass(THREAD, name, class_loader);\n@@ -1068,1 +1047,1 @@\n-                                                    class_loader, protection_domain, is_superclass, CHECK_false);\n+                                                    class_loader, is_superclass, CHECK_false);\n@@ -1078,2 +1057,1 @@\n-bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,\n-                                                      Handle protection_domain, TRAPS) {\n+bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader, TRAPS) {\n@@ -1089,1 +1067,1 @@\n-                                                     class_loader, protection_domain, true,\n+                                                     class_loader, true,\n@@ -1099,1 +1077,1 @@\n-    bool check_interface = check_shared_class_super_type(ik, interfaces->at(index), class_loader, protection_domain, false,\n+    bool check_interface = check_shared_class_super_type(ik, interfaces->at(index), class_loader, false,\n@@ -1117,1 +1095,1 @@\n-  Klass *s = resolve_or_fail(cn, class_loader, protection_domain, true, CHECK_NULL);\n+  Klass *s = resolve_or_fail(cn, class_loader, true, CHECK_NULL);\n@@ -1157,1 +1135,1 @@\n-  bool check = check_shared_class_super_types(ik, class_loader, protection_domain, CHECK_NULL);\n+  bool check = check_shared_class_super_types(ik, class_loader, CHECK_NULL);\n@@ -1171,1 +1149,1 @@\n-          class_loader, protection_domain, false, CHECK_NULL);\n+          class_loader, false, CHECK_NULL);\n@@ -1181,1 +1159,1 @@\n-            class_loader, protection_domain, false, THREAD);\n+            class_loader, false, THREAD);\n@@ -1618,11 +1596,0 @@\n-    if (java_lang_System::allow_security_manager()) {\n-      \/\/ Oops referenced by the protection domain cache table may get unreachable independently\n-      \/\/ of the class loader (eg. cached protection domain oops). So we need to\n-      \/\/ explicitly unlink them here.\n-      \/\/ All protection domain oops are linked to the caller class, so if nothing\n-      \/\/ unloads, this is not needed.\n-      ProtectionDomainCacheTable::trigger_cleanup();\n-    } else {\n-      assert(ProtectionDomainCacheTable::number_of_entries() == 0, \"should be empty\");\n-    }\n-\n@@ -1666,1 +1633,0 @@\n-  ProtectionDomainCacheTable::initialize();\n@@ -1758,0 +1724,17 @@\n+#if INCLUDE_CDS\n+\/\/ Indicate that loader_data has initiated the loading of class k, which\n+\/\/ has already been defined by a parent loader.\n+\/\/ This API should be used only by AOTLinkedClassBulkLoader\n+void SystemDictionary::add_to_initiating_loader(JavaThread* current,\n+                                                InstanceKlass* k,\n+                                                ClassLoaderData* loader_data) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  Symbol* name  = k->name();\n+  Dictionary* dictionary = loader_data->dictionary();\n+  assert(k->is_loaded(), \"must be\");\n+  assert(k->class_loader_data() != loader_data, \"only for classes defined by a parent loader\");\n+  assert(dictionary->find_class(current, name) == nullptr, \"sanity\");\n+  dictionary->add_klass(current, name, k);\n+}\n+#endif\n@@ -1766,4 +1749,1 @@\n-  \/\/ Force the protection domain to be null.  (This removes protection checks.)\n-  Handle no_protection_domain;\n-  Klass* klass = find_instance_or_array_klass(current, class_name, class_loader,\n-                                              no_protection_domain);\n+  Klass* klass = find_instance_or_array_klass(current, class_name, class_loader);\n@@ -2073,0 +2053,46 @@\n+#if INCLUDE_CDS\n+void SystemDictionary::get_all_method_handle_intrinsics(GrowableArray<Method*>* methods) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be\");\n+  auto do_method = [&] (InvokeMethodKey& key, Method*& m) {\n+    methods->append(m);\n+  };\n+  _invoke_method_intrinsic_table->iterate_all(do_method);\n+}\n+\n+void SystemDictionary::restore_archived_method_handle_intrinsics() {\n+  if (UseSharedSpaces) {\n+    EXCEPTION_MARK;\n+    restore_archived_method_handle_intrinsics_impl(THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ This is probably caused by OOM -- other parts of the CDS archive have direct pointers to\n+      \/\/ the archived method handle intrinsics, so we can't really recover from this failure.\n+      vm_exit_during_initialization(err_msg(\"Failed to restore archived method handle intrinsics. Try to increase heap size.\"));\n+    }\n+  }\n+}\n+\n+void SystemDictionary::restore_archived_method_handle_intrinsics_impl(TRAPS) {\n+  Array<Method*>* list = MetaspaceShared::archived_method_handle_intrinsics();\n+  for (int i = 0; i < list->length(); i++) {\n+    methodHandle m(THREAD, list->at(i));\n+    Method::restore_archived_method_handle_intrinsic(m, CHECK);\n+    m->constants()->restore_unshareable_info(CHECK);\n+    if (!Arguments::is_interpreter_only() || m->intrinsic_id() == vmIntrinsics::_linkToNative) {\n+      AdapterHandlerLibrary::create_native_wrapper(m);\n+      if (!m->has_compiled_code()) {\n+        ResourceMark rm(THREAD);\n+        vm_exit_during_initialization(err_msg(\"Failed to initialize method %s\", m->external_name()));\n+      }\n+    }\n+\n+    \/\/ There's no need to grab the InvokeMethodIntrinsicTable_lock, as we are still very early in\n+    \/\/ VM start-up -- in init_globals2() -- so we are still running a single Java thread. It's not\n+    \/\/ possible to have a contention.\n+    const int iid_as_int = vmIntrinsics::as_int(m->intrinsic_id());\n+    InvokeMethodKey key(m->signature(), iid_as_int);\n+    bool created = _invoke_method_intrinsic_table->put(key, m());\n+    assert(created, \"unexpected contention\");\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -2171,2 +2197,0 @@\n-                                                   Handle class_loader,\n-                                                   Handle protection_domain,\n@@ -2175,2 +2199,2 @@\n-  assert(accessing_klass == nullptr || (class_loader.is_null() && protection_domain.is_null()),\n-         \"one or the other, or perhaps neither\");\n+\n+  Handle class_loader;\n@@ -2183,2 +2207,1 @@\n-    protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n-  ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);\n+  ResolvingSignatureStream ss(signature, class_loader, false);\n@@ -2226,1 +2249,1 @@\n-  Handle class_loader, protection_domain;\n+  Handle class_loader;\n@@ -2229,1 +2252,0 @@\n-    protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n@@ -2241,2 +2263,1 @@\n-      mirror = ss.as_java_mirror(Handle(), Handle(),\n-                                 SignatureStream::ReturnNull, CHECK_(empty));\n+      mirror = ss.as_java_mirror(Handle(), SignatureStream::ReturnNull, CHECK_(empty));\n@@ -2250,2 +2271,1 @@\n-      mirror = ss.as_java_mirror(class_loader, protection_domain,\n-                                 SignatureStream::NCDFError, CHECK_(empty));\n+      mirror = ss.as_java_mirror(class_loader, SignatureStream::NCDFError, CHECK_(empty));\n@@ -2304,1 +2324,1 @@\n-    Handle class_loader, protection_domain;\n+    Handle class_loader;\n@@ -2307,2 +2327,1 @@\n-      protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n-    oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));\n+    oop mirror = ss.as_java_mirror(class_loader, SignatureStream::NCDFError, CHECK_(empty));\n@@ -2447,3 +2466,0 @@\n-\n-  ProtectionDomainCacheTable::print_on(st);\n-  st->cr();\n@@ -2463,3 +2479,0 @@\n-\n-  \/\/ Verify protection domain table\n-  ProtectionDomainCacheTable::verify();\n@@ -2476,1 +2489,0 @@\n-    ProtectionDomainCacheTable::print_table_statistics(st);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":107,"deletions":95,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/   class loader -> ClassLoaderData -> [class, protection domain set]\n+\/\/   class loader -> ClassLoaderData -> Loaded and initiated loaded classes\n@@ -41,1 +41,1 @@\n-\/\/ The underlying data structure is an open hash table (Dictionary) per\n+\/\/ The underlying data structure is a concurrent hash table (Dictionary) per\n@@ -52,3 +52,1 @@\n-\/\/ of the class loader and the placeholder is removed. Note that the protection\n-\/\/ domain field of the dictionary entry has not yet been filled in when\n-\/\/ the \"real\" dictionary entry is created.\n+\/\/ of the class loader and the placeholder is removed.\n@@ -79,0 +77,2 @@\n+template <class E> class GrowableArray;\n+\n@@ -80,0 +80,1 @@\n+  friend class AOTLinkedClassBulkLoader;\n@@ -92,1 +93,1 @@\n-  static Klass* resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS);\n+  static Klass* resolve_or_fail(Symbol* class_name, Handle class_loader, bool throw_error, TRAPS);\n@@ -95,1 +96,1 @@\n-    return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+    return resolve_or_fail(class_name, Handle(), throw_error, THREAD);\n@@ -100,1 +101,1 @@\n-  static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n+  static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, TRAPS);\n@@ -103,1 +104,1 @@\n-    return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n+    return resolve_or_null(class_name, Handle(), THREAD);\n@@ -109,1 +110,0 @@\n-                                                           Handle protection_domain,\n@@ -119,3 +119,2 @@\n-                                              Handle protection_domain, bool is_superclass, TRAPS) {\n-    return resolve_with_circularity_detection(class_name, super_name, class_loader, protection_domain,\n-                                              is_superclass, THREAD);\n+                                              bool is_superclass, TRAPS) {\n+    return resolve_with_circularity_detection(class_name, super_name, class_loader, is_superclass, THREAD);\n@@ -155,1 +154,1 @@\n-                                            Handle class_loader, Handle protection_domain);\n+                                            Handle class_loader);\n@@ -161,2 +160,1 @@\n-                                             Handle class_loader,\n-                                             Handle protection_domain);\n+                                             Handle class_loader);\n@@ -245,0 +243,3 @@\n+  static void get_all_method_handle_intrinsics(GrowableArray<Method*>* methods) NOT_CDS_RETURN;\n+  static void restore_archived_method_handle_intrinsics() NOT_CDS_RETURN;\n+\n@@ -246,1 +247,0 @@\n-  \/\/ Either the accessing_klass or the CL\/PD can be non-null, but not both.\n@@ -249,2 +249,0 @@\n-                                             Handle class_loader,\n-                                             Handle protection_domain,\n@@ -253,8 +251,0 @@\n-  static Handle    find_java_mirror_for_type(Symbol* signature,\n-                                             Klass* accessing_klass,\n-                                             SignatureStream::FailureMode failure_mode,\n-                                             TRAPS) {\n-    \/\/ callee will fill in CL\/PD from AK, if they are needed\n-    return find_java_mirror_for_type(signature, accessing_klass, Handle(), Handle(),\n-                                     failure_mode, THREAD);\n-  }\n@@ -299,0 +289,3 @@\n+  static void add_to_initiating_loader(JavaThread* current, InstanceKlass* k,\n+                                       ClassLoaderData* loader_data) NOT_CDS_RETURN;\n+\n@@ -306,1 +299,1 @@\n-                                                       Handle protection_domain, TRAPS);\n+                                                       TRAPS);\n@@ -309,1 +302,1 @@\n-                                            Handle protection_domain, TRAPS);\n+                                            TRAPS);\n@@ -331,1 +324,1 @@\n-                                            Handle class_loader,  Handle protection_domain,\n+                                            Handle class_loader,\n@@ -333,2 +326,1 @@\n-  static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,\n-                                               Handle protection_domain, TRAPS);\n+  static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader, TRAPS);\n@@ -337,0 +329,1 @@\n+  static void restore_archived_method_handle_intrinsics_impl(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-      name, Handle(THREAD, klass->class_loader()),\n-      Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n+      name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n@@ -89,2 +88,1 @@\n-        from_name, Handle(THREAD, klass->class_loader()),\n-        Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n+        from_name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n-bool Verifier::should_verify_for(oop class_loader, bool should_verify_class) {\n-  return (class_loader == nullptr || !should_verify_class) ?\n+bool Verifier::should_verify_for(oop class_loader) {\n+  return class_loader == nullptr ?\n@@ -280,1 +280,1 @@\n-  return (should_verify_for(klass->class_loader(), should_verify_class) &&\n+  return (should_verify_class &&\n@@ -2106,1 +2106,1 @@\n-  \/\/ Get current loader and protection domain first.\n+  \/\/ Get current loader first.\n@@ -2108,1 +2108,0 @@\n-  oop protection_domain = current_class()->protection_domain();\n@@ -2113,2 +2112,1 @@\n-    name, Handle(THREAD, loader), Handle(THREAD, protection_domain),\n-    true, THREAD);\n+    name, Handle(THREAD, loader), true, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  static bool should_verify_for(oop class_loader, bool should_verify_class);\n+  static bool should_verify_for(oop class_loader);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,3 +63,0 @@\n-  do_klass(SecurityManager_klass,                       java_lang_SecurityManager                             ) \\\n-  do_klass(AccessControlContext_klass,                  java_security_AccessControlContext                    ) \\\n-  do_klass(AccessController_klass,                      java_security_AccessController                        ) \\\n@@ -179,0 +176,1 @@\n+  do_klass(Void_klass,                                  java_lang_Void                                        ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  template(java_lang_Void,                            \"java\/lang\/Void\")                           \\\n@@ -120,1 +121,0 @@\n-  template(java_lang_SecurityManager,                 \"java\/lang\/SecurityManager\")                \\\n@@ -123,3 +123,0 @@\n-  template(java_security_AccessControlContext,        \"java\/security\/AccessControlContext\")       \\\n-  template(java_security_AccessController,            \"java\/security\/AccessController\")           \\\n-  template(executePrivileged_name,                    \"executePrivileged\")                        \\\n@@ -316,0 +313,2 @@\n+  template(java_lang_ref_SoftReference_signature,         \"Ljava\/lang\/ref\/SoftReference;\")        \\\n+                                                                                                  \\\n@@ -444,3 +443,0 @@\n-  template(context_name,                              \"context\")                                  \\\n-  template(contextClassLoader_name,                   \"contextClassLoader\")                       \\\n-  template(getClassContext_name,                      \"getClassContext\")                          \\\n@@ -494,1 +490,0 @@\n-  template(security_manager_signature,                \"Ljava\/lang\/SecurityManager;\")              \\\n@@ -613,3 +608,0 @@\n-  template(protectiondomain_signature,                \"[Ljava\/security\/ProtectionDomain;\")                        \\\n-  template(accesscontrolcontext_signature,            \"Ljava\/security\/AccessControlContext;\")                     \\\n-  template(class_protectiondomain_signature,          \"(Ljava\/lang\/Class;Ljava\/security\/ProtectionDomain;)V\")     \\\n@@ -740,0 +732,1 @@\n+  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n@@ -753,0 +746,1 @@\n+  template(runtimeSetup,                                    \"runtimeSetup\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -332,6 +332,0 @@\n-\/*\n- * java.lang.SecurityManager\n- *\/\n-JNIEXPORT jobjectArray JNICALL\n-JVM_GetClassContext(JNIEnv *env);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -259,1 +259,0 @@\n-          Handle(THREAD, klass->protection_domain()),\n@@ -1131,0 +1130,9 @@\n+void InterpreterRuntime::cds_resolve_invokehandle(int raw_index,\n+                                                  constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokehandle;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+\n+  pool->cache()->set_method_handle(raw_index, info);\n+}\n+\n@@ -1150,0 +1158,8 @@\n+void InterpreterRuntime::cds_resolve_invokedynamic(int raw_index,\n+                                                   constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokedynamic;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+  pool->cache()->set_dynamic_call(info, raw_index);\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  \/\/ Used by ClassPrelinker\n+  \/\/ Used by AOTConstantPoolResolver\n@@ -111,1 +111,4 @@\n-\n+  static void cds_resolve_invokehandle(int raw_index,\n+                                       constantPoolHandle& pool, TRAPS);\n+  static void cds_resolve_invokedynamic(int raw_index,\n+                                        constantPoolHandle& pool, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,1 +499,0 @@\n-                                            Handle(),\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -616,1 +616,0 @@\n-  Handle protection_domain;\n@@ -619,1 +618,0 @@\n-    protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n@@ -632,1 +630,1 @@\n-    resolved_klass = SystemDictionary::resolve_or_fail(class_name, class_loader, protection_domain, true, CHECK_NULL);\n+    resolved_klass = SystemDictionary::resolve_or_fail(class_name, class_loader, true, CHECK_NULL);\n@@ -639,2 +637,1 @@\n-                                                             class_loader,\n-                                                             protection_domain);\n+                                                             class_loader);\n@@ -647,2 +644,1 @@\n-                                                               class_loader,\n-                                                               protection_domain);\n+                                                               class_loader);\n@@ -657,2 +653,1 @@\n-                                                             class_loader,\n-                                                             protection_domain);\n+                                                             class_loader);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  LOG_TAG(aot) \\\n@@ -164,1 +165,0 @@\n-  LOG_TAG(protectiondomain) \/* \"Trace protection domain verification\" *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  void operator delete(void* p) { ShouldNotCallThis(); }\n+  void operator delete(void* p) = delete;\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -55,1 +56,5 @@\n-  ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n+  if (cld != nullptr) {\n+    ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n+  } else {\n+    assert(AOTLinkedClassBulkLoader::is_pending_aot_linked_class(k), \"sanity\");\n+  }\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-#include \"cds\/archiveHeapWriter.hpp\"\n-#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -38,0 +38,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -287,0 +288,38 @@\n+template <typename Function>\n+void ConstantPool::iterate_archivable_resolved_references(Function function) {\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr && cache() != nullptr && CDSConfig::is_dumping_invokedynamic()) {\n+    Array<ResolvedIndyEntry>* indy_entries = cache()->resolved_indy_entries();\n+    if (indy_entries != nullptr) {\n+      for (int i = 0; i < indy_entries->length(); i++) {\n+        ResolvedIndyEntry *rie = indy_entries->adr_at(i);\n+        if (rie->is_resolved() && AOTConstantPoolResolver::is_resolution_deterministic(this, rie->constant_pool_index())) {\n+          int rr_index = rie->resolved_references_index();\n+          assert(resolved_reference_at(rr_index) != nullptr, \"must exist\");\n+          function(rr_index);\n+\n+          \/\/ Save the BSM as well (sometimes the JIT looks up the BSM it for replay)\n+          int indy_cp_index = rie->constant_pool_index();\n+          int bsm_mh_cp_index = bootstrap_method_ref_index_at(indy_cp_index);\n+          int bsm_rr_index = cp_to_object_index(bsm_mh_cp_index);\n+          assert(resolved_reference_at(bsm_rr_index) != nullptr, \"must exist\");\n+          function(bsm_rr_index);\n+        }\n+      }\n+    }\n+\n+    Array<ResolvedMethodEntry>* method_entries = cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokehandle) && rme->has_appendix() &&\n+            cache()->can_archive_resolved_method(this, rme)) {\n+          int rr_index = rme->resolved_references_index();\n+          assert(resolved_reference_at(rr_index) != nullptr, \"must exist\");\n+          function(rr_index);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -304,0 +343,1 @@\n+    ResourceMark rm;\n@@ -305,0 +345,2 @@\n+    GrowableArray<bool> keep_resolved_refs(rr_len, rr_len, false);\n+\n@@ -306,0 +348,4 @@\n+    src_cp->iterate_archivable_resolved_references([&](int rr_index) {\n+      keep_resolved_refs.at_put(rr_index, true);\n+    });\n+\n@@ -320,0 +366,1 @@\n+            continue;\n@@ -322,0 +369,4 @@\n+\n+        if (keep_resolved_refs.at(i)) {\n+          scratch_rr->obj_at_put(i, obj);\n+        }\n@@ -329,0 +380,26 @@\n+void ConstantPool::find_required_hidden_classes() {\n+  if (_cache == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n+  if (loader_data == nullptr) {\n+    \/\/ These are custom loader classes from the preimage\n+    return;\n+  }\n+\n+  if (!SystemDictionaryShared::is_builtin_loader(loader_data)) {\n+    \/\/ Archiving resolved references for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return;\n+  }\n+\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr) {\n+    iterate_archivable_resolved_references([&](int rr_index) {\n+      oop obj = rr->obj_at(rr_index);\n+      HeapShared::find_required_hidden_classes_in_object(obj);\n+    });\n+  }\n+}\n+\n@@ -353,0 +430,5 @@\n+  if (is_for_method_handle_intrinsic()) {\n+    \/\/ See the same check in remove_unshareable_info() below.\n+    assert(cache() == NULL, \"must not have cpCache\");\n+    return;\n+  }\n@@ -392,0 +474,8 @@\n+  if (is_for_method_handle_intrinsic()) {\n+    \/\/ This CP was created by Method::make_method_handle_intrinsic() and has nothing\n+    \/\/ that need to be removed\/restored. It has no cpCache since the intrinsic methods\n+    \/\/ don't have any bytecodes.\n+    assert(cache() == NULL, \"must not have cpCache\");\n+    return;\n+  }\n+\n@@ -486,1 +576,1 @@\n-    can_archive = ClassPrelinker::is_resolution_deterministic(src_cp, cp_index);\n+    can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n@@ -506,1 +596,1 @@\n-      log.print(\"    %s\", name->as_C_string());\n+      log.print(\" => %s\", name->as_C_string());\n@@ -601,1 +691,0 @@\n-  Handle protection_domain (THREAD, this_cp->pool_holder()->protection_domain());\n@@ -607,1 +696,1 @@\n-    k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);\n+    k = SystemDictionary::resolve_or_fail(name, loader, true, THREAD);\n@@ -696,3 +785,1 @@\n-    oop protection_domain = this_cp->pool_holder()->protection_domain();\n-    Handle h_prot (current, protection_domain);\n-    Klass* k = SystemDictionary::find_instance_klass(current, name, h_loader, h_prot);\n+    Klass* k = SystemDictionary::find_instance_klass(current, name, h_loader);\n@@ -778,3 +865,1 @@\n-      tty->print_cr(\"Unexpected bytecode: %d\", code);\n-      ShouldNotReachHere(); \/\/ All cases should have been handled\n-      return -1;\n+      fatal(\"Unexpected bytecode: %s\", Bytecodes::name(code));\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":98,"deletions":13,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  friend class ClassPrelinker;       \/\/ CDS\n+  friend class AOTConstantPoolResolver;\n@@ -112,1 +112,2 @@\n-    _has_dynamic_constant = 8\n+    _has_dynamic_constant = 8,\n+    _is_for_method_handle_intrinsic = 16\n@@ -219,0 +220,3 @@\n+  bool is_for_method_handle_intrinsic() const  { return (_flags & _is_for_method_handle_intrinsic) != 0; }\n+  void set_is_for_method_handle_intrinsic()    { _flags |= _is_for_method_handle_intrinsic; }\n+\n@@ -682,0 +686,1 @@\n+  void find_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -688,0 +693,1 @@\n+  template <typename Function> void iterate_archivable_resolved_references(Function function);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -405,3 +405,1 @@\n-    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n-      resolved_indy_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_indy_entries_if_non_deterministic();\n@@ -426,1 +424,1 @@\n-    if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -440,1 +438,1 @@\n-        log.print(\"%s field  CP entry [%3d]: %s %s %s.%s:%s\",\n+        log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n@@ -444,1 +442,0 @@\n-                  (archived ? \"=>\" : \"  \"),\n@@ -461,1 +458,2 @@\n-                    rme->is_resolved(Bytecodes::_invokeinterface);\n+                    rme->is_resolved(Bytecodes::_invokeinterface) ||\n+                    rme->is_resolved(Bytecodes::_invokehandle);\n@@ -464,2 +462,1 @@\n-    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n-                  rme->is_resolved(Bytecodes::_invokestatic));\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokestatic));\n@@ -467,1 +464,1 @@\n-    if (resolved && can_archive_resolved_method(rme)) {\n+    if (resolved && can_archive_resolved_method(src_cp, rme)) {\n@@ -499,1 +496,35 @@\n-bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+void ConstantPoolCache::remove_resolved_indy_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+    ResolvedIndyEntry* rei = _resolved_indy_entries->adr_at(i);\n+    int cp_index = rei->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rei->is_resolved();\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+      rei->mark_and_relocate();\n+      archived = true;\n+    } else {\n+      rei->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+        int bsm_ref = cp->method_handle_index_at(bsm);\n+        Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+        Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+        Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+        log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index, cp->pool_holder()->name()->as_C_string(), i);\n+        log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n+                  bsm_name->as_C_string(), bsm_signature->as_C_string());\n+      }\n+      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ConstantPool* src_cp, ResolvedMethodEntry* method_entry) {\n@@ -524,1 +555,0 @@\n-  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n@@ -527,1 +557,1 @@\n-  if (!ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+  if (!AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -535,0 +565,7 @@\n+  } else if (method_entry->is_resolved(Bytecodes::_invokehandle)) {\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ invokehandle depends on archived MethodType and LambdaForms.\n+      return true;\n+    } else {\n+      return false;\n+    }\n@@ -536,1 +573,0 @@\n-    \/\/ invokestatic and invokehandle are not supported yet.\n@@ -539,1 +575,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":51,"deletions":16,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -807,0 +808,12 @@\n+\/\/ JLS 8.9: An enum class is either implicitly final and derives\n+\/\/ from java.lang.Enum, or else is implicitly sealed to its\n+\/\/ anonymous subclasses. This query detects both kinds.\n+\/\/ It does not validate the finality or\n+\/\/ sealing conditions: it merely checks for a super of Enum.\n+\/\/ This is sufficient for recognizing well-formed enums.\n+bool InstanceKlass::is_enum_subclass() const {\n+  InstanceKlass* s = java_super();\n+  return (s == vmClasses::Enum_klass() ||\n+          (s != nullptr && s->java_super() == vmClasses::Enum_klass()));\n+}\n+\n@@ -864,0 +877,62 @@\n+#ifdef ASSERT\n+void InstanceKlass::assert_no_clinit_will_run_for_aot_initialized_class() const {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n+\n+  InstanceKlass* s = java_super();\n+  if (s != nullptr) {\n+    DEBUG_ONLY(ResourceMark rm);\n+    assert(s->is_initialized(), \"super class %s of aot-inited class %s must have been initialized\",\n+           s->external_name(), external_name());\n+    s->assert_no_clinit_will_run_for_aot_initialized_class();\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (!intf->is_initialized()) {\n+      ResourceMark rm;\n+      \/\/ Note: an interface needs to be marked as is_initialized() only if\n+      \/\/ - it has a <clinit>\n+      \/\/ - it has declared a default method.\n+      assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false),\n+             \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n+             intf->external_name(), external_name());\n+    }\n+  }\n+}\n+#endif\n+\n+#if INCLUDE_CDS\n+void InstanceKlass::initialize_with_aot_initialized_mirror(TRAPS) {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n+  assert(CDSConfig::is_loading_heap(), \"must be\");\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n+  assert_no_clinit_will_run_for_aot_initialized_class();\n+\n+  if (is_initialized()) {\n+    return;\n+  }\n+\n+  if (log_is_enabled(Info, cds, init)) {\n+    ResourceMark rm;\n+    log_info(cds, init)(\"%s (aot-inited)\", external_name());\n+  }\n+\n+  link_class(CHECK);\n+\n+#ifdef ASSERT\n+  {\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    assert(!is_initialized(), \"sanity\");\n+    assert(!is_being_initialized(), \"sanity\");\n+    assert(!is_in_error_state(), \"sanity\");\n+  }\n+#endif\n+\n+  set_init_thread(THREAD);\n+  AOTClassInitializer::call_runtime_setup(THREAD, this);\n+  set_initialization_state_and_notify(fully_initialized, CHECK);\n+}\n+#endif\n@@ -971,1 +1046,1 @@\n-                                                          Handle(THREAD, class_loader()), Handle(THREAD, protection_domain()), true,\n+                                                          Handle(THREAD, class_loader()), true,\n@@ -1026,1 +1101,0 @@\n-        oop protection_domain = this->protection_domain();\n@@ -1028,1 +1102,1 @@\n-                                                         Handle(THREAD, loader), Handle(THREAD, protection_domain), THREAD);\n+                                                         Handle(THREAD, loader), THREAD);\n@@ -1824,1 +1898,4 @@\n-  if (has_archived_enum_objs()) {\n+  if (has_aot_initialized_mirror() && CDSConfig::is_loading_heap()) {\n+    AOTClassInitializer::call_runtime_setup(THREAD, this);\n+    return;\n+  } else if (has_archived_enum_objs()) {\n@@ -1853,0 +1930,41 @@\n+\/\/ If a class that implements this interface is initialized, is the JVM required\n+\/\/ to first execute a <clinit> method declared in this interface,\n+\/\/ or (if also_check_supers==true) any of the super types of this interface?\n+\/\/\n+\/\/ JVMS 5.5. Initialization, step 7: Next, if C is a class rather than\n+\/\/ an interface, then let SC be its superclass and let SI1, ..., SIn\n+\/\/ be all superinterfaces of C (whether direct or indirect) that\n+\/\/ declare at least one non-abstract, non-static method.\n+\/\/\n+\/\/ So when an interface is initialized, it does not look at its\n+\/\/ supers. But a proper class will ensure that all of its supers have\n+\/\/ run their <clinit> methods, except that it disregards interfaces\n+\/\/ that lack a non-static concrete method (i.e., a default method).\n+\/\/ Therefore, you should probably call this method only when the\n+\/\/ current class is a super of some proper class, not an interface.\n+bool InstanceKlass::interface_needs_clinit_execution_as_super(bool also_check_supers) const {\n+  assert(is_interface(), \"must be\");\n+\n+  if (!has_nonstatic_concrete_methods()) {\n+    \/\/ quick check: no nonstatic concrete methods are declared by this or any super interfaces\n+    return false;\n+  }\n+\n+  \/\/ JVMS 5.5. Initialization\n+  \/\/ ...If C is an interface that declares a non-abstract,\n+  \/\/ non-static method, the initialization of a class that\n+  \/\/ implements C directly or indirectly.\n+  if (declares_nonstatic_concrete_methods() && class_initializer() != nullptr) {\n+    return true;\n+  }\n+  if (also_check_supers) {\n+    Array<InstanceKlass*>* all_ifs = transitive_interfaces();\n+    for (int i = 0; i < all_ifs->length(); ++i) {\n+      InstanceKlass* super_intf = all_ifs->at(i);\n+      if (super_intf->declares_nonstatic_concrete_methods() && super_intf->class_initializer() != nullptr) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -2751,0 +2869,1 @@\n+  it->push(&_nest_host);\n@@ -2816,2 +2935,6 @@\n-  \/\/ clear _nest_host to ensure re-load at runtime\n-  _nest_host = nullptr;\n+  if (CDSConfig::is_dumping_invokedynamic() && HeapShared::is_lambda_proxy_klass(this)) {\n+    \/\/ keep _nest_host\n+  } else {\n+    \/\/ clear _nest_host to ensure re-load at runtime\n+    _nest_host = nullptr;\n+  }\n@@ -2960,0 +3083,12 @@\n+\n+int InstanceKlass::shared_class_loader_type() const {\n+  if (is_shared_boot_class()) {\n+    return ClassLoader::BOOT_LOADER;\n+  } else if (is_shared_platform_class()) {\n+    return ClassLoader::PLATFORM_LOADER;\n+  } else if (is_shared_app_class()) {\n+    return ClassLoader::APP_LOADER;\n+  } else {\n+    return ClassLoader::OTHER;\n+  }\n+}\n@@ -3170,0 +3305,4 @@\n+bool InstanceKlass::in_javabase_module() const {\n+  return module()->name() == vmSymbols::java_base();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":145,"deletions":6,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class Monitor;\n@@ -73,1 +72,0 @@\n-class jniIdMapBase;\n@@ -396,0 +394,1 @@\n+  int  shared_class_loader_type() const;\n@@ -532,0 +531,3 @@\n+  \/\/ test for enum class (or possibly an anonymous subclass within a sealed enum)\n+  bool is_enum_subclass() const;\n+\n@@ -578,0 +580,1 @@\n+  bool in_javabase_module() const;\n@@ -637,0 +640,2 @@\n+  void initialize_with_aot_initialized_mirror(TRAPS);\n+  void assert_no_clinit_will_run_for_aot_initialized_class() const NOT_DEBUG_RETURN;\n@@ -643,0 +648,1 @@\n+  bool interface_needs_clinit_execution_as_super(bool also_check_supers=true) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/memRegion.hpp\"\n@@ -63,2 +61,0 @@\n-class ParCompactionManager;\n-class PSPromotionManager;\n@@ -200,1 +196,6 @@\n-    _is_generated_shared_class             = 1 << 5\n+    _is_generated_shared_class             = 1 << 5,\n+    \/\/ archived mirror already initialized by AOT-cache assembly: no further need to call <clinit>\n+    _has_aot_initialized_mirror            = 1 << 6,\n+    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n+    \/\/ method during the production run?\n+    _is_runtime_setup_required             = 1 << 7,\n@@ -382,0 +383,17 @@\n+  void set_has_aot_initialized_mirror() {\n+    CDS_ONLY(_shared_class_flags |= _has_aot_initialized_mirror;)\n+  }\n+  bool has_aot_initialized_mirror() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_aot_initialized_mirror) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+  void set_is_runtime_setup_required() {\n+    assert(has_aot_initialized_mirror(), \"sanity\");\n+    CDS_ONLY(_shared_class_flags |= _is_runtime_setup_required;)\n+  }\n+  bool is_runtime_setup_required() const {\n+    CDS_ONLY(return (_shared_class_flags & _is_runtime_setup_required) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -233,0 +233,1 @@\n+  static constexpr int klass_offset_in_bytes      = 4;\n@@ -234,0 +235,1 @@\n+  static constexpr int klass_shift_at_offset      = klass_shift - klass_offset_in_bytes * BitsPerByte;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -964,2 +964,1 @@\n-    Handle prot  (thread, method_holder()->protection_domain());\n-    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != nullptr;\n+    return SystemDictionary::find_instance_klass(thread, klass_name, loader) != nullptr;\n@@ -1498,0 +1497,1 @@\n+  cp->set_is_for_method_handle_intrinsic();\n@@ -1546,0 +1546,10 @@\n+#if INCLUDE_CDS\n+void Method::restore_archived_method_handle_intrinsic(methodHandle m, TRAPS) {\n+  m->link_method(m, CHECK);\n+\n+  if (m->intrinsic_id() == vmIntrinsics::_linkToNative) {\n+    m->set_interpreter_entry(m->adapter()->get_i2c_entry());\n+  }\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"oops\/typeArrayOop.hpp\"\n@@ -127,0 +126,1 @@\n+  static void restore_archived_method_handle_intrinsic(methodHandle m, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1628,0 +1628,2 @@\n+  ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self(),\n+                            Mutex::_no_safepoint_check_flag);\n@@ -1638,0 +1640,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2746,1 +2746,1 @@\n-  Mutex* extra_data_lock() { return &_extra_data_lock; }\n+  Mutex* extra_data_lock() const { return const_cast<Mutex*>(&_extra_data_lock); }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,4 +157,0 @@\n-bool oopDesc::has_klass_gap() {\n-  return UseCompressedClassPointers && !UseCompactObjectHeaders;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/objLayout.hpp\"\n@@ -342,1 +343,3 @@\n-  static bool has_klass_gap();\n+  inline static bool has_klass_gap() {\n+    return ObjLayout::oop_has_klass_gap();\n+  }\n@@ -350,6 +353,2 @@\n-      \/\/ compiler and JVMCI, and even there we don't use it to access the (narrow)Klass*\n-      \/\/ directly. It is used only as a placeholder to identify the special memory slice\n-      \/\/ containing Klass* info. This value could be any value that is not a valid\n-      \/\/ field offset. Use an offset halfway into the markWord, as the markWord is never\n-      \/\/ partially loaded from C2 and JVMCI.\n-      return mark_offset_in_bytes() + 4;\n+      \/\/ compiler and JVMCI.\n+      return mark_offset_in_bytes() + markWord::klass_offset_in_bytes;\n@@ -368,9 +367,1 @@\n-    if (UseCompactObjectHeaders) {\n-      \/\/ With compact headers, the Klass* field is not used for the Klass*\n-      \/\/ and is used for the object fields instead.\n-      return sizeof(markWord);\n-    } else if (UseCompressedClassPointers) {\n-      return sizeof(markWord) + sizeof(narrowKlass);\n-    } else {\n-      return sizeof(markWord) + sizeof(Klass*);\n-    }\n+    return ObjLayout::oop_base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/objLayout.inline.hpp\"\n@@ -98,6 +99,7 @@\n-  if (UseCompactObjectHeaders) {\n-    return mark().klass();\n-  } else if (UseCompressedClassPointers) {\n-     return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n+  switch (ObjLayout::klass_mode()) {\n+    case ObjLayout::Compact:\n+      return mark().klass();\n+    case ObjLayout::Compressed:\n+      return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n+    default:\n+      return _metadata._klass;\n@@ -108,6 +110,7 @@\n-  if (UseCompactObjectHeaders) {\n-    return mark().klass_or_null();\n-  } else if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n+  switch (ObjLayout::klass_mode()) {\n+    case ObjLayout::Compact:\n+      return mark().klass_or_null();\n+    case ObjLayout::Compressed:\n+      return CompressedKlassPointers::decode(_metadata._compressed_klass);\n+    default:\n+      return _metadata._klass;\n@@ -118,7 +121,9 @@\n-  if (UseCompactObjectHeaders) {\n-    return mark_acquire().klass();\n-  } else if (UseCompressedClassPointers) {\n-    narrowKlass narrow_klass = Atomic::load_acquire(&_metadata._compressed_klass);\n-    return CompressedKlassPointers::decode(narrow_klass);\n-  } else {\n-    return Atomic::load_acquire(&_metadata._klass);\n+  switch (ObjLayout::klass_mode()) {\n+    case ObjLayout::Compact:\n+      return mark_acquire().klass();\n+    case ObjLayout::Compressed: {\n+      narrowKlass narrow_klass = Atomic::load_acquire(&_metadata._compressed_klass);\n+      return CompressedKlassPointers::decode(narrow_klass);\n+    }\n+    default:\n+      return Atomic::load_acquire(&_metadata._klass);\n@@ -129,6 +134,7 @@\n-  if (UseCompactObjectHeaders) {\n-    return mark().klass_without_asserts();\n-  } else if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode_without_asserts(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n+  switch (ObjLayout::klass_mode()) {\n+    case ObjLayout::Compact:\n+      return mark().klass_without_asserts();\n+    case ObjLayout::Compressed:\n+      return CompressedKlassPointers::decode_without_asserts(_metadata._compressed_klass);\n+    default:\n+      return _metadata._klass;\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -358,0 +358,6 @@\n+  product_pd(uint, SuperWordStoreToLoadForwardingFailureDetection, DIAGNOSTIC, \\\n+          \"if >0, auto-vectorization detects possible store-to-load \"       \\\n+          \"forwarding failures. The number specifies over how many \"        \\\n+          \"loop iterations this detection spans.\")                          \\\n+          range(0, 4096)                                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -427,0 +427,3 @@\n+\n+  C->print_method(PHASE_INITIAL_LIVENESS, 4);\n+\n@@ -467,0 +470,2 @@\n+  C->print_method(PHASE_AGGRESSIVE_COALESCING, 4);\n+\n@@ -507,0 +512,3 @@\n+\n+    C->print_method(PHASE_INITIAL_SPILLING, 4);\n+\n@@ -521,0 +529,4 @@\n+    if (OptoCoalesce) {\n+      C->print_method(PHASE_CONSERVATIVE_COALESCING, 4);\n+    }\n+\n@@ -583,0 +595,3 @@\n+\n+    C->print_method(PHASE_ITERATIVE_SPILLING, 4);\n+\n@@ -596,0 +611,5 @@\n+\n+    if (OptoCoalesce) {\n+      C->print_method(PHASE_CONSERVATIVE_COALESCING, 4);\n+    }\n+\n@@ -610,0 +630,2 @@\n+  C->print_method(PHASE_AFTER_ITERATIVE_SPILLING, 4);\n+\n@@ -617,0 +639,2 @@\n+  C->print_method(PHASE_POST_ALLOCATION_COPY_REMOVAL, 4);\n+\n@@ -620,0 +644,2 @@\n+  C->print_method(PHASE_MERGE_MULTI_DEFS, 4);\n+\n@@ -648,0 +674,2 @@\n+  C->print_method(PHASE_FIX_UP_SPILLS, 4);\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -5680,1 +5680,1 @@\n-    _igv_printer->print_method(name, level);\n+    _igv_printer->print_graph(name);\n@@ -5722,0 +5722,9 @@\n+#ifndef PRODUCT\n+void Compile::init_igv() {\n+  if (_igv_printer == nullptr) {\n+    _igv_printer = IdealGraphPrinter::printer();\n+    _igv_printer->set_compile(this);\n+  }\n+}\n+#endif\n+\n@@ -5729,3 +5738,2 @@\n-  if (need && !_igv_printer) {\n-    _igv_printer = IdealGraphPrinter::printer();\n-    _igv_printer->set_compile(this);\n+  if (need) {\n+    Compile::init_igv();\n@@ -5799,1 +5807,1 @@\n-  _debug_file_printer->print(phase_name, (Node*)C->root());\n+  _debug_file_printer->print_graph(phase_name);\n@@ -5803,0 +5811,6 @@\n+  ResourceMark rm;\n+  GrowableArray<const Node*> empty_list;\n+  igv_print_graph_to_network(phase_name, (Node*) C->root(), empty_list);\n+}\n+\n+void Compile::igv_print_graph_to_network(const char* name, Node* node, GrowableArray<const Node*>& visible_nodes) {\n@@ -5809,1 +5823,1 @@\n-  _debug_network_printer->print(phase_name, (Node*)C->root());\n+  _debug_network_printer->print(name, C->root(), visible_nodes);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -733,0 +733,1 @@\n+  void init_igv();\n@@ -735,1 +736,1 @@\n-      _igv_printer->print_method(graph_name, level);\n+      _igv_printer->print_graph(graph_name);\n@@ -741,0 +742,1 @@\n+  void igv_print_graph_to_network(const char* name, Node* node, GrowableArray<const Node*>& visible_nodes);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3463,1 +3463,4 @@\n-  Node* excluded_mask = _gvn.intcon(32768);\n+  \/\/ The most significant bit of the u2 is used to denote thread exclusion\n+  Node* excluded_shift = _gvn.intcon(15);\n+  Node* excluded_mask = _gvn.intcon(1 << 15);\n+  \/\/ The epoch generation is the range [1-32767]\n@@ -3617,1 +3620,1 @@\n-  PhiNode* exclusion = new PhiNode(vthread_compare_rgn, TypeInt::BOOL);\n+  PhiNode* exclusion = new PhiNode(vthread_compare_rgn, TypeInt::CHAR);\n@@ -3682,1 +3685,2 @@\n-  store_to_memory(tid_is_not_equal, event_writer_excluded_field, _gvn.transform(exclusion), T_BOOLEAN, MemNode::unordered);\n+  Node* excluded_bool = _gvn.transform(new URShiftINode(_gvn.transform(exclusion), excluded_shift));\n+  store_to_memory(tid_is_not_equal, event_writer_excluded_field, excluded_bool, T_BOOLEAN, MemNode::unordered);\n@@ -3749,1 +3753,3 @@\n-  Node* excluded_mask = _gvn.intcon(32768);\n+  \/\/ The most significant bit of the u2 is used to denote thread exclusion\n+  Node* excluded_mask = _gvn.intcon(1 << 15);\n+  \/\/ The epoch generation is the range [1-32767]\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -955,1 +955,1 @@\n-  static void get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n+  static void get_template_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n@@ -1397,4 +1397,2 @@\n-  IfTrueNode* create_template_assertion_predicate(int if_opcode, CountedLoopNode* loop_head,\n-                                                  ParsePredicateSuccessProj* parse_predicate_proj,\n-                                                  IfProjNode* new_control, int scale, Node* offset,\n-                                                  Node* range, Deoptimization::DeoptReason deopt_reason);\n+  IfTrueNode* create_template_assertion_predicate(CountedLoopNode* loop_head, ParsePredicateNode* parse_predicate,\n+                                                  IfProjNode* new_control, int scale, Node* offset, Node* range);\n@@ -1673,1 +1671,2 @@\n-                                                               IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred);\n+                                                               IfProjNode*& true_path_loop_entry,\n+                                                               IfProjNode*& false_path_loop_entry);\n@@ -1677,2 +1676,3 @@\n-                                                            Deoptimization::DeoptReason reason, IfProjNode*& iffast_pred,\n-                                                            IfProjNode*& ifslow_pred);\n+                                                            Deoptimization::DeoptReason reason,\n+                                                            IfProjNode*& true_path_loop_entry,\n+                                                            IfProjNode*& false_path_loop_entry);\n@@ -1684,6 +1684,5 @@\n-                                                     Deoptimization::DeoptReason reason, ParsePredicateSuccessProj* old_parse_predicate_proj,\n-                                                     ParsePredicateSuccessProj* fast_loop_parse_predicate_proj,\n-                                                     ParsePredicateSuccessProj* slow_loop_parse_predicate_proj);\n-  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate, IfProjNode* predicate,\n-                                                             Deoptimization::DeoptReason reason,\n-                                                             ParsePredicateSuccessProj* parse_predicate_proj);\n+                                                     ParsePredicateSuccessProj* old_parse_predicate_proj,\n+                                                     ParsePredicateNode* true_path_loop_parse_predicate,\n+                                                     ParsePredicateNode* false_path_loop_parse_predicate);\n+  IfTrueNode* clone_assertion_predicate_for_unswitched_loops(IfTrueNode* template_assertion_predicate_success_proj,\n+                                                             ParsePredicateNode* unswitched_loop_parse_predicate);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -138,0 +138,8 @@\n+#if defined(S390)\n+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {\n+    return ::as_VectorRegister(reg(ra_, node));\n+  }\n+  VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {\n+    return ::as_VectorRegister(reg(ra_, node, idx));\n+ }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -548,0 +548,6 @@\n+\/\/ With compact headers, the input address (adr) does not point at the exact\n+\/\/ header position where the (narrow) class pointer is located, but into the\n+\/\/ middle of the mark word (see oopDesc::klass_offset_in_bytes()). This node\n+\/\/ implicitly shifts the loaded value (markWord::klass_shift_at_offset bits) to\n+\/\/ extract the actual class pointer. C2's type system is agnostic on whether the\n+\/\/ input address directly points into the class pointer.\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1840,0 +1840,2 @@\n+  bool _print_igv = false;\n+\n@@ -2057,0 +2059,5 @@\n+    if (_print_igv) {\n+      Compile* C = Compile::current();\n+      C->init_igv();\n+      C->igv_print_graph_to_network(\"PrintBFS\", (Node*) C->root(), _print_list);\n+    }\n@@ -2099,0 +2106,1 @@\n+  _output->print_cr(\"      !: show nodes on IGV (sent over network stream)\");\n@@ -2212,0 +2220,3 @@\n+      case '!':\n+        _print_igv = true;\n+        break;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3682,1 +3682,1 @@\n-    printer->print_method(buffer, perBytecode);\n+    printer->print_graph(buffer);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,0 +96,9 @@\n+  flags(INITIAL_LIVENESS,               \"Initial liveness\") \\\n+  flags(AGGRESSIVE_COALESCING,          \"Aggressive coalescing\") \\\n+  flags(INITIAL_SPILLING,               \"Initial spilling\") \\\n+  flags(CONSERVATIVE_COALESCING,        \"Conservative coalescing\") \\\n+  flags(ITERATIVE_SPILLING,             \"Iterative spilling\") \\\n+  flags(AFTER_ITERATIVE_SPILLING,       \"After iterative spilling\") \\\n+  flags(POST_ALLOCATION_COPY_REMOVAL,   \"Post-allocation copy removal\") \\\n+  flags(MERGE_MULTI_DEFS,               \"Merge multiple definitions\") \\\n+  flags(FIX_UP_SPILLS,                  \"Fix up spills\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  { Bad,             T_ILLEGAL,    \"vectorx:\",      false, 0,                    relocInfo::none          },  \/\/ VectorX\n+  { Bad,             T_ILLEGAL,    \"vectorx:\",      false, Op_VecX,              relocInfo::none          },  \/\/ VectorX\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  ClassFileStream st((u1*)buf, bufLen, nullptr, ClassFileStream::verify);\n+  ClassFileStream st((u1*)buf, bufLen, nullptr);\n@@ -326,2 +326,0 @@\n-  \/\/%note jni_3\n-  Handle protection_domain;\n@@ -349,1 +347,0 @@\n-        protection_domain = Handle(THREAD, fromClass->protection_domain());\n@@ -356,2 +353,1 @@\n-  result = find_class_from_class_loader(env, class_name, true, loader,\n-                                        protection_domain, true, thread);\n+  result = find_class_from_class_loader(env, class_name, true, loader, true, thread);\n@@ -543,2 +539,1 @@\n-  Handle protection_domain (THREAD, k->protection_domain());\n-  THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);\n+  THROW_MSG_LOADER_(name, (char *)message, class_loader, JNI_OK);\n@@ -3027,1 +3022,0 @@\n-  Handle protection_domain; \/\/ null protection domain\n@@ -3030,1 +3024,1 @@\n-  jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);\n+  jclass result =  find_class_from_class_loader(env, sym, true, loader, true, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-static void trace_class_resolution_impl(Klass* to_class, TRAPS) {\n+extern void trace_class_resolution(Klass* to_class) {\n@@ -161,1 +161,1 @@\n-  JavaThread* jthread = THREAD;\n+  JavaThread* jthread = JavaThread::current();\n@@ -165,6 +165,1 @@\n-    \/\/ scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames\n-    TempNewSymbol access_controller = SymbolTable::new_symbol(\"java\/security\/AccessController\");\n-    Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);\n-    TempNewSymbol privileged_action = SymbolTable::new_symbol(\"java\/security\/PrivilegedAction\");\n-    Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);\n-\n+    \/\/ Scan up the stack skipping ClassLoader frames.\n@@ -175,3 +170,1 @@\n-      if (!vfst.method()->method_holder()->is_subclass_of(vmClasses::ClassLoader_klass())&&\n-          !vfst.method()->method_holder()->is_subclass_of(access_controller_klass) &&\n-          !vfst.method()->method_holder()->is_subclass_of(privileged_action_klass)) {\n+      if (!vfst.method()->method_holder()->is_subclass_of(vmClasses::ClassLoader_klass())) {\n@@ -236,8 +229,0 @@\n-void trace_class_resolution(Klass* to_class) {\n-  EXCEPTION_MARK;\n-  trace_class_resolution_impl(to_class, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-}\n-\n@@ -938,11 +923,1 @@\n-  oop protection_domain = nullptr;\n-  \/\/ If loader is null, shouldn't call ClassLoader.checkPackageAccess; otherwise get\n-  \/\/ NPE. Put it in another way, the bootstrap class loader has all permission and\n-  \/\/ thus no checkPackageAccess equivalence in the VM class loader.\n-  \/\/ The caller is also passed as null by the java code if there is no security\n-  \/\/ manager to avoid the performance cost of getting the calling class.\n-  if (from_class != nullptr && loader_oop != nullptr) {\n-    protection_domain = java_lang_Class::as_Klass(from_class)->protection_domain();\n-  }\n-\n-  Handle h_prot(THREAD, protection_domain);\n+\n@@ -951,1 +926,1 @@\n-                                               h_prot, false, THREAD);\n+                                               false, THREAD);\n@@ -970,1 +945,0 @@\n-  oop protection_domain = nullptr;\n@@ -973,1 +947,0 @@\n-    protection_domain = from_class->protection_domain();\n@@ -976,3 +949,1 @@\n-  Handle h_prot  (THREAD, protection_domain);\n-  jclass result = find_class_from_class_loader(env, h_name, init, h_loader,\n-                                               h_prot, true, thread);\n+  jclass result = find_class_from_class_loader(env, h_name, init, h_loader, true, thread);\n@@ -1022,1 +993,1 @@\n-  ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);\n+  ClassFileStream st((u1*)buf, len, source);\n@@ -1108,1 +1079,1 @@\n-  ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);\n+  ClassFileStream st((u1*)buf, len, source);\n@@ -1226,3 +1197,1 @@\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, klass_name,\n-                                                            h_loader,\n-                                                            Handle());\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, klass_name, h_loader);\n@@ -3001,1 +2970,1 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n+  if (CDSConfig::allow_only_single_java_thread()) {\n@@ -3114,1 +3083,0 @@\n-  if (os::dont_yield()) return;\n@@ -3233,39 +3201,0 @@\n-\/\/ java.lang.SecurityManager \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))\n-  ResourceMark rm(THREAD);\n-  JvmtiVMObjectAllocEventCollector oam;\n-  vframeStream vfst(thread);\n-\n-  if (vmClasses::reflect_CallerSensitive_klass() != nullptr) {\n-    \/\/ This must only be called from SecurityManager.getClassContext\n-    Method* m = vfst.method();\n-    if (!(m->method_holder() == vmClasses::SecurityManager_klass() &&\n-          m->name()          == vmSymbols::getClassContext_name() &&\n-          m->signature()     == vmSymbols::void_class_array_signature())) {\n-      THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"JVM_GetClassContext must only be called from SecurityManager.getClassContext\");\n-    }\n-  }\n-\n-  \/\/ Collect method holders\n-  GrowableArray<Klass*>* klass_array = new GrowableArray<Klass*>();\n-  for (; !vfst.at_end(); vfst.security_next()) {\n-    Method* m = vfst.method();\n-    \/\/ Native frames are not returned\n-    if (!m->is_ignored_by_security_stack_walk() && !m->is_native()) {\n-      Klass* holder = m->method_holder();\n-      assert(holder->is_klass(), \"just checking\");\n-      klass_array->append(holder);\n-    }\n-  }\n-\n-  \/\/ Create result array of type [Ljava\/lang\/Class;\n-  objArrayOop result = oopFactory::new_objArray(vmClasses::Class_klass(), klass_array->length(), CHECK_NULL);\n-  \/\/ Fill in mirrors corresponding to method holders\n-  for (int i = 0; i < klass_array->length(); i++) {\n-    result->obj_at_put(i, klass_array->at(i)->java_mirror());\n-  }\n-\n-  return (jobjectArray) JNIHandles::make_local(THREAD, result);\n-JVM_END\n-\n@@ -3589,9 +3518,2 @@\n-                                    Handle loader, Handle protection_domain,\n-                                    jboolean throwError, TRAPS) {\n-  \/\/ Security Note:\n-  \/\/   The Java level wrapper will perform the necessary security check allowing\n-  \/\/   us to pass the null as the initiating class loader.  The VM is responsible for\n-  \/\/   the checkPackageAccess relative to the initiating class loader via the\n-  \/\/   protection_domain. The protection_domain is passed as null by the java code\n-  \/\/   if there is no security manager in 3-arg Class.forName().\n-  Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);\n+                                    Handle loader, jboolean throwError, TRAPS) {\n+  Klass* klass = SystemDictionary::resolve_or_fail(name, loader, throwError != 0, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":13,"deletions":91,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -1364,2 +1364,1 @@\n-                       \"__VM_RedefineClasses__\",\n-                       ClassFileStream::verify);\n+                       \"__VM_RedefineClasses__\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"classfile\/protectionDomainCache.hpp\"\n@@ -2647,4 +2646,0 @@\n-WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))\n-  return (jint) ProtectionDomainCacheTable::removed_entries_count();\n-WB_END\n-\n@@ -3083,1 +3078,0 @@\n-  {CC\"protectionDomainRemovedCount\",   CC\"()I\",       (void*)&WB_ProtectionDomainRemovedCount },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/objLayout.hpp\"\n@@ -2599,0 +2600,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n@@ -2603,0 +2605,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n@@ -2608,0 +2611,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n@@ -2612,0 +2616,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1095,1 +1095,1 @@\n-    InstanceKlass* ik = SystemDictionary::find_instance_klass(thread, klass_name, Handle(), Handle());\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(thread, klass_name, Handle());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -700,3 +700,0 @@\n-  product_pd(bool, DontYieldALot,                                           \\\n-             \"(Deprecated) Throw away obvious excess yield calls\")          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -511,2 +511,1 @@\n-  Handle protection_domain(THREAD, holder->protection_domain());\n-  Klass* k = as_klass(class_loader, protection_domain, SignatureStream::CachedOrNull, THREAD);\n+  Klass* k = as_klass(class_loader, SignatureStream::CachedOrNull, THREAD);\n@@ -521,2 +520,1 @@\n-Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,\n-                                 FailureMode failure_mode, TRAPS) {\n+Klass* SignatureStream::as_klass(Handle class_loader, FailureMode failure_mode, TRAPS) {\n@@ -531,1 +529,1 @@\n-    k = SystemDictionary::resolve_or_null(name, class_loader, protection_domain, CHECK_NULL);\n+    k = SystemDictionary::resolve_or_null(name, class_loader, CHECK_NULL);\n@@ -535,1 +533,1 @@\n-    k = SystemDictionary::find_instance_klass(THREAD, name, class_loader, protection_domain);\n+    k = SystemDictionary::find_instance_klass(THREAD, name, class_loader);\n@@ -545,1 +543,1 @@\n-    k = SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, CHECK_NULL);\n+    k = SystemDictionary::resolve_or_fail(name, class_loader, throw_error, CHECK_NULL);\n@@ -551,2 +549,1 @@\n-oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,\n-                                    FailureMode failure_mode, TRAPS) {\n+oop SignatureStream::as_java_mirror(Handle class_loader, FailureMode failure_mode, TRAPS) {\n@@ -556,1 +553,1 @@\n-  Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);\n+  Klass* klass = as_klass(class_loader, failure_mode, CHECK_NULL);\n@@ -571,3 +568,1 @@\n-                                                   Handle protection_domain,\n-  : SignatureStream(signature, is_method),\n-    _class_loader(class_loader), _protection_domain(protection_domain)\n+  : SignatureStream(signature, is_method), _class_loader(class_loader)\n@@ -596,1 +591,0 @@\n-  _protection_domain = Handle(current, _load_origin->protection_domain());\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -567,1 +567,1 @@\n-  Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);\n+  Klass* as_klass(Handle class_loader, FailureMode failure_mode, TRAPS);\n@@ -569,1 +569,1 @@\n-  oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);\n+  oop as_java_mirror(Handle class_loader, FailureMode failure_mode, TRAPS);\n@@ -630,1 +630,0 @@\n-  Handle       _protection_domain;  \/\/ cached when needed\n@@ -646,1 +645,1 @@\n-  ResolvingSignatureStream(Symbol* signature, Handle class_loader, Handle protection_domain, bool is_method = true);\n+  ResolvingSignatureStream(Symbol* signature, Handle class_loader, bool is_method = true);\n@@ -651,2 +650,1 @@\n-    return SignatureStream::as_klass(_class_loader, _protection_domain,\n-                                     failure_mode, THREAD);\n+    return SignatureStream::as_klass(_class_loader, failure_mode, THREAD);\n@@ -658,2 +656,1 @@\n-    return SignatureStream::as_java_mirror(_class_loader, _protection_domain,\n-                                           failure_mode, THREAD);\n+    return SignatureStream::as_java_mirror(_class_loader, failure_mode, THREAD);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -353,0 +356,1 @@\n+\n@@ -359,0 +363,2 @@\n+  HeapShared::init_box_classes(CHECK);\n+\n@@ -382,1 +388,1 @@\n-                                                            Handle(), Handle());\n+                                                            Handle());\n@@ -407,0 +413,1 @@\n+  initialize_class(vmSymbols::java_lang_InternalError(), CHECK);\n@@ -416,0 +423,4 @@\n+\n+  if (UseSharedSpaces) {\n+    HeapShared::initialize_java_lang_invoke(CHECK);\n+  }\n@@ -490,0 +501,3 @@\n+  \/\/ Initialize object layout after parsing the args\n+  ObjLayout::initialize();\n+\n@@ -741,0 +755,5 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n+    SystemDictionary::restore_archived_method_handle_intrinsics();\n+  }\n+\n@@ -756,0 +775,7 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::load_non_javabase_classes(THREAD);\n+  }\n+#ifndef PRODUCT\n+  HeapShared::initialize_test_class_from_archive(THREAD);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1938,1 +1938,0 @@\n-  declare_toplevel_type(jniIdMapBase*)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -699,1 +699,1 @@\n-    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n@@ -772,1 +772,1 @@\n-    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n@@ -789,1 +789,1 @@\n-    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+    Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n@@ -810,1 +810,1 @@\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, true, CHECK);\n@@ -888,1 +888,1 @@\n-  _max(\"max\", \"Maximum number of events to be printed (newest first). If omitted, all events are printed.\", \"STRING\", false, nullptr)\n+  _max(\"max\", \"Maximum number of events to be printed (newest first). If omitted or zero, all events are printed.\", \"INT\", false, \"0\")\n@@ -895,8 +895,4 @@\n-  const char* max_value = _max.value();\n-  int max = -1;\n-  if (max_value != nullptr) {\n-    char* endptr = nullptr;\n-    if (!parse_integer(max_value, &max)) {\n-      output()->print_cr(\"Invalid max option: \\\"%s\\\".\", max_value);\n-      return;\n-    }\n+  int max = (int)_max.value();\n+  if (max < 0) {\n+    output()->print_cr(\"Invalid max option: \\\"%d\\\".\", max);\n+    return;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -917,1 +917,1 @@\n-  DCmdArgument<char*> _max;\n+  DCmdArgument<jlong> _max;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-                         Handle loader, Handle protection_domain);\n+                         Handle loader);\n@@ -135,1 +135,1 @@\n-                               Handle h_loader, Handle h_protection_domain);\n+                               Handle h_loader);\n@@ -139,1 +139,1 @@\n-                           Handle h_loader, Handle h_protection_domain);\n+                           Handle h_loader);\n@@ -153,1 +153,1 @@\n-                              Handle loader, Handle protection_domain);\n+                              Handle loader);\n@@ -158,1 +158,1 @@\n-                              Handle loader, Handle protection_domain);\n+                              Handle loader);\n@@ -162,1 +162,1 @@\n-                              Handle loader, Handle protection_domain,\n+                              Handle loader,\n@@ -167,1 +167,1 @@\n-                              Handle loader, Handle protection_domain,\n+                              Handle loader,\n@@ -273,2 +273,2 @@\n-#define THROW_MSG_LOADER(name, message, loader, protection_domain) \\\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader, protection_domain); return;  }\n+#define THROW_MSG_LOADER(name, message, loader) \\\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader); return;  }\n@@ -291,2 +291,2 @@\n-#define THROW_MSG_LOADER_(name, message, loader, protection_domain, result) \\\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader, protection_domain); return result; }\n+#define THROW_MSG_LOADER_(name, message, loader, result) \\\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader); return result; }\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -55,2 +50,0 @@\n-import sun.security.action.GetBooleanAction;\n-import sun.security.action.GetIntegerAction;\n@@ -301,2 +294,2 @@\n-        static final boolean SET_FILTER_AFTER_READ = GetBooleanAction\n-                .privilegedGetProperty(\"jdk.serialSetFilterAfterRead\");\n+        static final boolean SET_FILTER_AFTER_READ =\n+                Boolean.getBoolean(\"jdk.serialSetFilterAfterRead\");\n@@ -310,2 +303,2 @@\n-        private static final boolean GETFIELD_CNFE_RETURNS_NULL = GetBooleanAction\n-                .privilegedGetProperty(\"jdk.serialGetFieldCnfeReturnsNull\");\n+        private static final boolean GETFIELD_CNFE_RETURNS_NULL =\n+                Boolean.getBoolean(\"jdk.serialGetFieldCnfeReturnsNull\");\n@@ -319,2 +312,2 @@\n-        static final int PROXY_INTERFACE_LIMIT = Math.clamp(GetIntegerAction\n-                .privilegedGetProperty(\"jdk.serialProxyInterfaceLimit\", 65535), 0, 65535);\n+        static final int PROXY_INTERFACE_LIMIT =\n+                Math.clamp(Integer.getInteger(\"jdk.serialProxyInterfaceLimit\", 65535), 0, 65535);\n@@ -409,1 +402,0 @@\n-        verifySubclass();\n@@ -439,5 +431,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n-        }\n@@ -938,7 +925,0 @@\n-        if (enable) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(SUBSTITUTION_PERMISSION);\n-            }\n-        }\n@@ -1340,5 +1320,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);\n-        }\n@@ -1602,22 +1577,0 @@\n-    \/**\n-     * Verifies that this (possibly subclass) instance can be constructed\n-     * without violating security constraints: the subclass must not override\n-     * security-sensitive non-final methods, or else the\n-     * \"enableSubclassImplementation\" SerializablePermission is checked.\n-     *\/\n-    private void verifySubclass() {\n-        Class<?> cl = getClass();\n-        if (cl == ObjectInputStream.class) {\n-            return;\n-        }\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            return;\n-        }\n-        boolean result = Caches.subclassAudits.get(cl);\n-        if (!result) {\n-            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n-        }\n-    }\n-\n@@ -1629,22 +1582,9 @@\n-    @SuppressWarnings(\"removal\")\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<Boolean>() {\n-                public Boolean run() {\n-                    for (Class<?> cl = subcl;\n-                         cl != ObjectInputStream.class;\n-                         cl = cl.getSuperclass())\n-                    {\n-                        try {\n-                            cl.getDeclaredMethod(\n-                                \"readUnshared\", (Class[]) null);\n-                            return Boolean.FALSE;\n-                        } catch (NoSuchMethodException ex) {\n-                        }\n-                        try {\n-                            cl.getDeclaredMethod(\"readFields\", (Class[]) null);\n-                            return Boolean.FALSE;\n-                        } catch (NoSuchMethodException ex) {\n-                        }\n-                    }\n-                    return Boolean.TRUE;\n-                }\n+        for (Class<?> cl = subcl;\n+             cl != ObjectInputStream.class;\n+             cl = cl.getSuperclass())\n+        {\n+            try {\n+                cl.getDeclaredMethod(\n+                    \"readUnshared\", (Class[]) null);\n+                return Boolean.FALSE;\n+            } catch (NoSuchMethodException ex) {\n@@ -1653,1 +1593,7 @@\n-        );\n+            try {\n+                cl.getDeclaredMethod(\"readFields\", (Class[]) null);\n+                return Boolean.FALSE;\n+            } catch (NoSuchMethodException ex) {\n+            }\n+        }\n+        return Boolean.TRUE;\n@@ -2900,5 +2846,1 @@\n-            @SuppressWarnings(\"removal\")\n-            final AccessControlContext acc;\n-            Callback(ObjectInputValidation obj, int priority, Callback next,\n-                @SuppressWarnings(\"removal\") AccessControlContext acc)\n-            {\n+            Callback(ObjectInputValidation obj, int priority, Callback next) {\n@@ -2909,1 +2851,0 @@\n-                this.acc = acc;\n@@ -2938,3 +2879,1 @@\n-            @SuppressWarnings(\"removal\")\n-            AccessControlContext acc = AccessController.getContext();\n-                prev.next = new Callback(obj, priority, cur, acc);\n+                prev.next = new Callback(obj, priority, cur);\n@@ -2943,1 +2882,1 @@\n-                list = new Callback(obj, priority, list, acc);\n+                list = new Callback(obj, priority, list);\n@@ -2954,1 +2893,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -2958,8 +2896,1 @@\n-                    AccessController.doPrivileged(\n-                        new PrivilegedExceptionAction<Void>()\n-                    {\n-                        public Void run() throws InvalidObjectException {\n-                            list.obj.validateObject();\n-                            return null;\n-                        }\n-                    }, list.acc);\n+                    list.obj.validateObject();\n@@ -2968,1 +2899,1 @@\n-            } catch (PrivilegedActionException ex) {\n+            } catch (InvalidObjectException ex) {\n@@ -2970,1 +2901,1 @@\n-                throw (InvalidObjectException) ex.getException();\n+                throw ex;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":28,"deletions":97,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -262,4 +260,1 @@\n-    @SuppressWarnings(\"removal\")\n-        java.security.AccessController.doPrivileged(\n-            new sun.security.action.GetBooleanAction(\n-                \"sun.io.serialization.extendedDebugInfo\")).booleanValue();\n+            Boolean.getBoolean(\"sun.io.serialization.extendedDebugInfo\");\n@@ -285,1 +280,0 @@\n-        verifySubclass();\n@@ -307,5 +301,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n-        }\n@@ -636,7 +625,0 @@\n-        if (enable) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(SUBSTITUTION_PERMISSION);\n-            }\n-        }\n@@ -666,2 +648,2 @@\n-     * {@link ObjectInputStream#readClassDescriptor readClassDescriptor}, should then be overridden to\n-     * reconstitute the class descriptor from its custom stream representation.\n+     * {@link ObjectInputStream#readClassDescriptor readClassDescriptor}, should then be\n+     * overridden to reconstitute the class descriptor from its custom stream representation.\n@@ -1063,22 +1045,0 @@\n-    \/**\n-     * Verifies that this (possibly subclass) instance can be constructed\n-     * without violating security constraints: the subclass must not override\n-     * security-sensitive non-final methods, or else the\n-     * \"enableSubclassImplementation\" SerializablePermission is checked.\n-     *\/\n-    private void verifySubclass() {\n-        Class<?> cl = getClass();\n-        if (cl == ObjectOutputStream.class) {\n-            return;\n-        }\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm == null) {\n-            return;\n-        }\n-        boolean result = Caches.subclassAudits.get(cl);\n-        if (!result) {\n-            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n-        }\n-    }\n-\n@@ -1090,22 +1050,14 @@\n-    @SuppressWarnings(\"removal\")\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<>() {\n-                public Boolean run() {\n-                    for (Class<?> cl = subcl;\n-                         cl != ObjectOutputStream.class;\n-                         cl = cl.getSuperclass())\n-                    {\n-                        try {\n-                            cl.getDeclaredMethod(\n-                                \"writeUnshared\", new Class<?>[] { Object.class });\n-                            return Boolean.FALSE;\n-                        } catch (NoSuchMethodException ex) {\n-                        }\n-                        try {\n-                            cl.getDeclaredMethod(\"putFields\", (Class<?>[]) null);\n-                            return Boolean.FALSE;\n-                        } catch (NoSuchMethodException ex) {\n-                        }\n-                    }\n-                    return Boolean.TRUE;\n-                }\n+        for (Class<?> cl = subcl;\n+             cl != ObjectOutputStream.class;\n+             cl = cl.getSuperclass())\n+        {\n+            try {\n+                cl.getDeclaredMethod(\n+                    \"writeUnshared\", new Class<?>[] { Object.class });\n+                return Boolean.FALSE;\n+            } catch (NoSuchMethodException ex) {\n+            }\n+            try {\n+                cl.getDeclaredMethod(\"putFields\", (Class<?>[]) null);\n+                return Boolean.FALSE;\n+            } catch (NoSuchMethodException ex) {\n@@ -1114,1 +1066,2 @@\n-        );\n+        }\n+        return Boolean.TRUE;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":19,"deletions":66,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.reflect.UndeclaredThrowableException;\n@@ -41,2 +40,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -45,6 +42,0 @@\n-import java.security.PermissionCollection;\n-import java.security.Permissions;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.ProtectionDomain;\n@@ -65,4 +56,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.JavaSecurityAccess;\n@@ -70,1 +57,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -108,6 +94,0 @@\n-    \/** reflection factory for obtaining serialization constructors *\/\n-    @SuppressWarnings(\"removal\")\n-    private static final ReflectionFactory reflFactory =\n-        AccessController.doPrivileged(\n-            new ReflectionFactory.GetReflectionFactoryAction());\n-\n@@ -285,2 +265,0 @@\n-    \/** protection domains that need to be checked when calling the constructor *\/\n-    private ProtectionDomain[] domains;\n@@ -359,1 +337,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -366,7 +343,1 @@\n-            suid = AccessController.doPrivileged(\n-                new PrivilegedAction<Long>() {\n-                    public Long run() {\n-                        return computeDefaultSUID(cl);\n-                    }\n-                }\n-            );\n+            suid = computeDefaultSUID(cl);\n@@ -383,2 +354,0 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n@@ -390,6 +359,0 @@\n-        if (System.getSecurityManager() != null) {\n-            Class<?> caller = Reflection.getCallerClass();\n-            if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), cl.getClassLoader())) {\n-                ReflectUtil.checkPackageAccess(cl);\n-            }\n-        }\n@@ -448,1 +411,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -464,18 +426,12 @@\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Void run() {\n-                    if (isEnum) {\n-                        suid = 0L;\n-                        fields = NO_FIELDS;\n-                        return null;\n-                    }\n-                    if (cl.isArray()) {\n-                        fields = NO_FIELDS;\n-                        return null;\n-                    }\n-\n-                    suid = getDeclaredSUID(cl);\n-                    try {\n-                        fields = getSerialFields(cl);\n-                        computeFieldOffsets();\n-                    } catch (InvalidClassException e) {\n-                        serializeEx = deserializeEx =\n+            if (isEnum) {\n+                suid = 0L;\n+                fields = NO_FIELDS;\n+            } else if (cl.isArray()) {\n+                fields = NO_FIELDS;\n+            } else {\n+                suid = getDeclaredSUID(cl);\n+                try {\n+                    fields = getSerialFields(cl);\n+                    computeFieldOffsets();\n+                } catch (InvalidClassException e) {\n+                    serializeEx = deserializeEx =\n@@ -483,2 +439,2 @@\n-                        fields = NO_FIELDS;\n-                    }\n+                    fields = NO_FIELDS;\n+                }\n@@ -486,18 +442,25 @@\n-                    if (isRecord) {\n-                        factoryMode = DeserializationMode.READ_RECORD;\n-                        canonicalCtr = canonicalRecordCtr(cl);\n-                        deserializationCtrs = new DeserializationConstructorsCache();\n-                    } else if (externalizable) {\n-                        factoryMode = DeserializationMode.READ_EXTERNALIZABLE;\n-                        if (cl.isIdentity()) {\n-                            cons = getExternalizableConstructor(cl);\n-                        } else {\n-                            serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n-                                    \"Externalizable not valid for value class\");\n-                        }\n-                    } else if (cl.isValue()) {\n-                        factoryMode = DeserializationMode.READ_OBJECT_VALUE;\n-                        if (!cl.isAnnotationPresent(MigratedValueClass.class)) {\n-                            serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n-                                    \"Value class serialization is only supported with `writeReplace`\");\n-                        } else if (Modifier.isAbstract(cl.getModifiers())) {\n+                if (isRecord) {\n+                    factoryMode = DeserializationMode.READ_RECORD;\n+                    canonicalCtr = canonicalRecordCtr(cl);\n+                    deserializationCtrs = new DeserializationConstructorsCache();\n+                } else if (externalizable) {\n+                    factoryMode = DeserializationMode.READ_EXTERNALIZABLE;\n+                    if (cl.isIdentity()) {\n+                        cons = getExternalizableConstructor(cl);\n+                    } else {\n+                        serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n+                                \"Externalizable not valid for value class\");\n+                    }\n+                } else if (cl.isValue()) {\n+                    factoryMode = DeserializationMode.READ_OBJECT_VALUE;\n+                    if (!cl.isAnnotationPresent(MigratedValueClass.class)) {\n+                        serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n+                                                                        \"Value class serialization is only supported with `writeReplace`\");\n+                    } else if (Modifier.isAbstract(cl.getModifiers())) {\n+                        serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n+                                                                        \"value class is abstract\");\n+                    } else {\n+                        \/\/ Value classes should have constructor(s) annotated with {@link DeserializeConstructor}\n+                        canonicalCtr = getDeserializingValueCons(cl, fields);\n+                        deserializationCtrs = new DeserializationConstructorsCache();                            factoryMode = DeserializationMode.READ_OBJECT_VALUE;\n+                        if (canonicalCtr == null) {\n@@ -505,9 +468,1 @@\n-                                    \"value class is abstract\");\n-                        } else {\n-                            \/\/ Value classes should have constructor(s) annotated with {@link DeserializeConstructor}\n-                            canonicalCtr = getDeserializingValueCons(cl, fields);\n-                            deserializationCtrs = new DeserializationConstructorsCache();                            factoryMode = DeserializationMode.READ_OBJECT_VALUE;\n-                            if (canonicalCtr == null) {\n-                                serializeEx = deserializeEx = new ExceptionInfo(cl.getName(),\n-                                        \"no constructor or factory found for migrated value class\");\n-                            }\n+                                                                            \"no constructor or factory found for migrated value class\");\n@@ -515,4 +470,5 @@\n-                    } else {\n-                        cons = getSerializableConstructor(cl);\n-                        writeObjectMethod = getPrivateMethod(cl, \"writeObject\",\n-                            new Class<?>[] { ObjectOutputStream.class },\n+                    }\n+                } else {\n+                    cons = getSerializableConstructor(cl);\n+                    writeObjectMethod = getPrivateMethod(cl, \"writeObject\",\n+                            new Class<?>[]{ObjectOutputStream.class},\n@@ -520,2 +476,2 @@\n-                        readObjectMethod = getPrivateMethod(cl, \"readObject\",\n-                            new Class<?>[] { ObjectInputStream.class },\n+                    readObjectMethod = getPrivateMethod(cl, \"readObject\",\n+                            new Class<?>[]{ObjectInputStream.class},\n@@ -523,1 +479,1 @@\n-                        readObjectNoDataMethod = getPrivateMethod(\n+                    readObjectNoDataMethod = getPrivateMethod(\n@@ -525,8 +481,7 @@\n-                        hasWriteObjectData = (writeObjectMethod != null);\n-                        factoryMode = ((superDesc == null || superDesc.factoryMode() == DeserializationMode.READ_OBJECT_DEFAULT)\n-                                && readObjectMethod == null && readObjectNoDataMethod == null)\n-                                ? DeserializationMode.READ_OBJECT_DEFAULT\n-                                : DeserializationMode.READ_OBJECT_CUSTOM;\n-                    }\n-                    domains = getProtectionDomains(cons, cl);\n-                    writeReplaceMethod = getInheritableMethod(\n+                    hasWriteObjectData = (writeObjectMethod != null);\n+                    factoryMode = ((superDesc == null || superDesc.factoryMode() == DeserializationMode.READ_OBJECT_DEFAULT)\n+                                   && readObjectMethod == null && readObjectNoDataMethod == null)\n+                        ? DeserializationMode.READ_OBJECT_DEFAULT\n+                        : DeserializationMode.READ_OBJECT_CUSTOM;\n+                }\n+                writeReplaceMethod = getInheritableMethod(\n@@ -534,1 +489,1 @@\n-                    readResolveMethod = getInheritableMethod(\n+                readResolveMethod = getInheritableMethod(\n@@ -536,3 +491,1 @@\n-                    return null;\n-                }\n-            });\n+            }\n@@ -582,60 +535,0 @@\n-    \/**\n-     * Creates a PermissionDomain that grants no permission.\n-     *\/\n-    private ProtectionDomain noPermissionsDomain() {\n-        PermissionCollection perms = new Permissions();\n-        perms.setReadOnly();\n-        return new ProtectionDomain(null, perms);\n-    }\n-\n-    \/**\n-     * Aggregate the ProtectionDomains of all the classes that separate\n-     * a concrete class {@code cl} from its ancestor's class declaring\n-     * a constructor {@code cons}.\n-     *\n-     * If {@code cl} is defined by the boot loader, or the constructor\n-     * {@code cons} is declared by {@code cl}, or if there is no security\n-     * manager, then this method does nothing and {@code null} is returned.\n-     *\n-     * @param cons A constructor declared by {@code cl} or one of its\n-     *             ancestors.\n-     * @param cl A concrete class, which is either the class declaring\n-     *           the constructor {@code cons}, or a serializable subclass\n-     *           of that class.\n-     * @return An array of ProtectionDomain representing the set of\n-     *         ProtectionDomain that separate the concrete class {@code cl}\n-     *         from its ancestor's declaring {@code cons}, or {@code null}.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private ProtectionDomain[] getProtectionDomains(Constructor<?> cons,\n-                                                    Class<?> cl) {\n-        ProtectionDomain[] domains = null;\n-        if (cons != null && cl.getClassLoader() != null\n-                && System.getSecurityManager() != null) {\n-            Class<?> cls = cl;\n-            Class<?> fnscl = cons.getDeclaringClass();\n-            Set<ProtectionDomain> pds = null;\n-            while (cls != fnscl) {\n-                ProtectionDomain pd = cls.getProtectionDomain();\n-                if (pd != null) {\n-                    if (pds == null) pds = new HashSet<>();\n-                    pds.add(pd);\n-                }\n-                cls = cls.getSuperclass();\n-                if (cls == null) {\n-                    \/\/ that's not supposed to happen\n-                    \/\/ make a ProtectionDomain with no permission.\n-                    \/\/ should we throw instead?\n-                    if (pds == null) pds = new HashSet<>();\n-                    else pds.clear();\n-                    pds.add(noPermissionsDomain());\n-                    break;\n-                }\n-            }\n-            if (pds != null) {\n-                domains = pds.toArray(new ProtectionDomain[0]);\n-            }\n-        }\n-        return domains;\n-    }\n-\n@@ -672,1 +565,0 @@\n-            domains = localDesc.domains;\n@@ -768,1 +660,0 @@\n-            domains = localDesc.domains;\n@@ -1149,1 +1040,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1157,29 +1047,1 @@\n-                if (domains == null || domains.length == 0) {\n-                    return cons.newInstance();\n-                } else {\n-                    JavaSecurityAccess jsa = SharedSecrets.getJavaSecurityAccess();\n-                    PrivilegedAction<?> pea = () -> {\n-                        try {\n-                            return cons.newInstance();\n-                        } catch (InstantiationException\n-                                 | InvocationTargetException\n-                                 | IllegalAccessException x) {\n-                            throw new UndeclaredThrowableException(x);\n-                        }\n-                    }; \/\/ Can't use PrivilegedExceptionAction with jsa\n-                    try {\n-                        return jsa.doIntersectionPrivilege(pea,\n-                                   AccessController.getContext(),\n-                                   new AccessControlContext(domains));\n-                    } catch (UndeclaredThrowableException x) {\n-                        Throwable cause = x.getCause();\n-                        if (cause instanceof InstantiationException ie)\n-                            throw ie;\n-                        if (cause instanceof InvocationTargetException ite)\n-                            throw ite;\n-                        if (cause instanceof IllegalAccessException iae)\n-                            throw iae;\n-                        \/\/ not supposed to happen\n-                        throw x;\n-                    }\n-                }\n+                return cons.newInstance();\n@@ -1646,1 +1508,1 @@\n-        return reflFactory.newConstructorForSerialization(cl);\n+        return ReflectionFactory.getReflectionFactory().newConstructorForSerialization(cl);\n@@ -1654,1 +1516,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1657,13 +1518,10 @@\n-        PrivilegedAction<MethodHandle> pa = () -> {\n-            Class<?>[] paramTypes = Arrays.stream(cls.getRecordComponents())\n-                                          .map(RecordComponent::getType)\n-                                          .toArray(Class<?>[]::new);\n-            try {\n-                Constructor<?> ctr = cls.getDeclaredConstructor(paramTypes);\n-                ctr.setAccessible(true);\n-                return MethodHandles.lookup().unreflectConstructor(ctr);\n-            } catch (IllegalAccessException | NoSuchMethodException e) {\n-                return null;\n-            }\n-        };\n-        return AccessController.doPrivileged(pa);\n+        Class<?>[] paramTypes = Arrays.stream(cls.getRecordComponents())\n+                                      .map(RecordComponent::getType)\n+                                      .toArray(Class<?>[]::new);\n+        try {\n+            Constructor<?> ctr = cls.getDeclaredConstructor(paramTypes);\n+            ctr.setAccessible(true);\n+            return MethodHandles.lookup().unreflectConstructor(ctr);\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            return null;\n+        }\n@@ -2557,1 +2415,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -2566,8 +2423,1 @@\n-            RecordComponent[] recordComponents;\n-            try {\n-                Class<?> cls = desc.forClass();\n-                PrivilegedExceptionAction<RecordComponent[]> pa = cls::getRecordComponents;\n-                recordComponents = AccessController.doPrivileged(pa);\n-            } catch (PrivilegedActionException e) {\n-                throw new InternalError(e.getCause());\n-            }\n+            RecordComponent[] recordComponents = desc.forClass().getRecordComponents();\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":71,"deletions":221,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-import sun.reflect.misc.ReflectUtil;\n@@ -174,8 +171,0 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n-        if (System.getSecurityManager() != null) {\n-            Class<?> caller = Reflection.getCallerClass();\n-            if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), type.getClassLoader())) {\n-                ReflectUtil.checkPackageAccess(type);\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamField.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.module.ModuleReader;\n@@ -58,2 +57,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -88,1 +85,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -235,0 +231,5 @@\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache\n+    private static void runtimeSetup() {\n@@ -549,3 +550,1 @@\n-    @CallerSensitive\n-    public static Class<?> forName(String name, boolean initialize,\n-                                   ClassLoader loader)\n+    public static Class<?> forName(String name, boolean initialize, ClassLoader loader)\n@@ -554,30 +553,1 @@\n-        Class<?> caller = null;\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ Reflective call to get caller class is only needed if a security manager\n-            \/\/ is present.  Avoid the overhead of making this call otherwise.\n-            caller = Reflection.getCallerClass();\n-        }\n-        return forName(name, initialize, loader, caller);\n-    }\n-\n-    \/\/ Caller-sensitive adapter method for reflective invocation\n-    @CallerSensitiveAdapter\n-    private static Class<?> forName(String name, boolean initialize, ClassLoader loader, Class<?> caller)\n-            throws ClassNotFoundException\n-    {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ Reflective call to get caller class is only needed if a security manager\n-            \/\/ is present.  Avoid the overhead of making this call otherwise.\n-            if (loader == null) {\n-                ClassLoader ccl = ClassLoader.getClassLoader(caller);\n-                if (ccl != null) {\n-                    sm.checkPermission(\n-                            SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-                }\n-            }\n-        }\n-        return forName0(name, initialize, loader, caller);\n+        return forName0(name, initialize, loader, null);\n@@ -629,14 +599,0 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n-        Class<?> caller = null;\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            caller = Reflection.getCallerClass();\n-        }\n-        return forName(module, name, caller);\n-    }\n-\n-    \/\/ Caller-sensitive adapter method for reflective invocation\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitiveAdapter\n-    private static Class<?> forName(Module module, String name, Class<?> caller) {\n@@ -647,14 +603,1 @@\n-        ClassLoader cl;\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            if (caller != null && caller.getModule() != module) {\n-                \/\/ if caller is null, Class.forName is the last java frame on the stack.\n-                \/\/ java.base has all permissions\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-            }\n-            PrivilegedAction<ClassLoader> pa = module::getClassLoader;\n-            cl = AccessController.doPrivileged(pa);\n-        } else {\n-            cl = module.getClassLoader();\n-        }\n-\n+        ClassLoader cl = module.getClassLoader();\n@@ -782,1 +725,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -788,5 +730,0 @@\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);\n-        }\n-\n@@ -807,7 +744,1 @@\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<>() {\n-                        public Void run() {\n-                                c.setAccessible(true);\n-                                return null;\n-                            }\n-                        });\n+                c.setAccessible(true);\n@@ -1077,11 +1008,1 @@\n-    @CallerSensitive\n-    @ForceInline \/\/ to ensure Reflection.getCallerClass optimization\n-        ClassLoader cl = classLoader;\n-        if (cl == null)\n-            return null;\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());\n-        }\n-        return cl;\n+        return classLoader;\n@@ -1564,1 +1485,0 @@\n-    @CallerSensitive\n@@ -1586,7 +1506,0 @@\n-            \/\/ Perform access check\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,\n-                                                     Reflection.getCallerClass(), true);\n-            }\n@@ -1701,1 +1614,0 @@\n-    @CallerSensitive\n@@ -1719,1 +1631,1 @@\n-            for(int i = 0; i < parameterClasses.length; i++)\n+            for (int i = 0; i < parameterClasses.length; i++)\n@@ -1722,8 +1634,1 @@\n-            \/\/ Perform access check\n-            final Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,\n-                                                     Reflection.getCallerClass(), true);\n-            }\n+            final Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();\n@@ -1761,12 +1666,1 @@\n-    @CallerSensitive\n-        final Class<?> candidate = getDeclaringClass0();\n-\n-        if (candidate != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                candidate.checkPackageAccess(sm,\n-                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-            }\n-        }\n-        return candidate;\n+        return getDeclaringClass0();\n@@ -1786,1 +1680,0 @@\n-    @CallerSensitive\n@@ -1813,9 +1706,0 @@\n-\n-        if (enclosingCandidate != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                enclosingCandidate.checkPackageAccess(sm,\n-                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-            }\n-        }\n@@ -2044,27 +1928,6 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);\n-        }\n-\n-        \/\/ Privileged so this implementation can look at DECLARED classes,\n-        \/\/ something the caller might not have privilege to do.  The code here\n-        \/\/ is allowed to look at DECLARED classes because (1) it does not hand\n-        \/\/ out anything other than public members and (2) public member access\n-        \/\/ has already been ok'd by the SecurityManager.\n-\n-        return java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public Class<?>[] run() {\n-                    List<Class<?>> list = new ArrayList<>();\n-                    Class<?> currentClass = Class.this;\n-                    while (currentClass != null) {\n-                        for (Class<?> m : currentClass.getDeclaredClasses()) {\n-                            if (Modifier.isPublic(m.getModifiers())) {\n-                                list.add(m);\n-                            }\n-                        }\n-                        currentClass = currentClass.getSuperclass();\n-                    }\n-                    return list.toArray(new Class<?>[0]);\n+        List<Class<?>> list = new ArrayList<>();\n+        Class<?> currentClass = Class.this;\n+        while (currentClass != null) {\n+            for (Class<?> m : currentClass.getDeclaredClasses()) {\n+                if (Modifier.isPublic(m.getModifiers())) {\n+                    list.add(m);\n@@ -2073,1 +1936,4 @@\n-            });\n+            }\n+            currentClass = currentClass.getSuperclass();\n+        }\n+        return list.toArray(new Class<?>[0]);\n@@ -2107,6 +1973,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2191,6 +2051,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2226,6 +2080,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2272,1 +2120,0 @@\n-    @CallerSensitive\n@@ -2275,5 +2122,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2375,1 +2217,0 @@\n-    @CallerSensitive\n@@ -2379,5 +2220,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2416,1 +2252,0 @@\n-    @CallerSensitive\n@@ -2419,5 +2254,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2445,6 +2275,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);\n-        }\n@@ -2478,6 +2302,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2520,6 +2338,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2572,6 +2384,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2603,6 +2409,0 @@\n-    @CallerSensitive\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2634,1 +2434,0 @@\n-    @CallerSensitive\n@@ -2637,5 +2436,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2679,1 +2473,0 @@\n-    @CallerSensitive\n@@ -2683,5 +2476,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2756,1 +2544,0 @@\n-    @CallerSensitive\n@@ -2759,6 +2546,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n-\n@@ -2986,5 +2767,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);\n-        }\n@@ -3025,85 +2801,0 @@\n-    \/*\n-     * Check if client is allowed to access members.  If access is denied,\n-     * throw a SecurityException.\n-     *\n-     * This method also enforces package access.\n-     *\n-     * <p> Default policy: allow all clients access with normal Java access\n-     * control.\n-     *\n-     * <p> NOTE: should only be called if a SecurityManager is installed\n-     *\/\n-    private void checkMemberAccess(@SuppressWarnings(\"removal\") SecurityManager sm, int which,\n-                                   Class<?> caller, boolean checkProxyInterfaces) {\n-        \/* Default policy allows access to all {@link Member#PUBLIC} members,\n-         * as well as access to classes that have the same class loader as the caller.\n-         * In all other cases, it requires RuntimePermission(\"accessDeclaredMembers\")\n-         * permission.\n-         *\/\n-        final ClassLoader ccl = ClassLoader.getClassLoader(caller);\n-        if (which != Member.PUBLIC) {\n-            final ClassLoader cl = classLoader;\n-            if (ccl != cl) {\n-                sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);\n-            }\n-        }\n-        this.checkPackageAccess(sm, ccl, checkProxyInterfaces);\n-    }\n-\n-    \/*\n-     * Checks if a client loaded in ClassLoader ccl is allowed to access this\n-     * class under the current package access policy. If access is denied,\n-     * throw a SecurityException.\n-     *\n-     * NOTE: this method should only be called if a SecurityManager is active\n-     *\/\n-    private void checkPackageAccess(@SuppressWarnings(\"removal\") SecurityManager sm, final ClassLoader ccl,\n-                                    boolean checkProxyInterfaces) {\n-        final ClassLoader cl = classLoader;\n-\n-        if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {\n-            String pkg = this.getPackageName();\n-            if (!pkg.isEmpty()) {\n-                \/\/ skip the package access check on a proxy class in default proxy package\n-                if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {\n-                    sm.checkPackageAccess(pkg);\n-                }\n-            }\n-        }\n-        \/\/ check package access on the proxy interfaces\n-        if (checkProxyInterfaces && Proxy.isProxyClass(this)) {\n-            ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces(\/* cloneArray *\/ false));\n-        }\n-    }\n-\n-    \/*\n-     * Checks if a client loaded in ClassLoader ccl is allowed to access the provided\n-     * classes under the current package access policy. If access is denied,\n-     * throw a SecurityException.\n-     *\n-     * NOTE: this method should only be called if a SecurityManager is active\n-     *       classes must be non-empty\n-     *       all classes provided must be loaded by the same ClassLoader\n-     * NOTE: this method does not support Proxy classes\n-     *\/\n-    private static void checkPackageAccessForPermittedSubclasses(@SuppressWarnings(\"removal\") SecurityManager sm,\n-                                    final ClassLoader ccl, Class<?>[] subClasses) {\n-        final ClassLoader cl = subClasses[0].classLoader;\n-\n-        if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {\n-            Set<String> packages = new HashSet<>();\n-\n-            for (Class<?> c : subClasses) {\n-                if (Proxy.isProxyClass(c))\n-                    throw new InternalError(\"a permitted subclass should not be a proxy class: \" + c);\n-                String pkg = c.getPackageName();\n-                if (!pkg.isEmpty()) {\n-                    packages.add(pkg);\n-                }\n-            }\n-            for (String pkg : packages) {\n-                sm.checkPackageAccess(pkg);\n-            }\n-        }\n-    }\n-\n@@ -3785,1 +3476,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3791,3 +3481,1 @@\n-        return reflectionFactory =\n-                java.security.AccessController.doPrivileged\n-                        (new ReflectionFactory.GetReflectionFactoryAction());\n+        return reflectionFactory = ReflectionFactory.getReflectionFactory();\n@@ -3797,0 +3485,9 @@\n+    \/**\n+     * When CDS is enabled, the Class class may be aot-initialized. However,\n+     * we can't archive reflectionFactory, so we reset it to null, so it\n+     * will be allocated again at runtime.\n+     *\/\n+    private static void resetArchivedStates() {\n+        reflectionFactory = null;\n+    }\n+\n@@ -3819,1 +3516,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3826,7 +3522,1 @@\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<>() {\n-                        public Void run() {\n-                                values.setAccessible(true);\n-                                return null;\n-                            }\n-                        });\n+                values.setAccessible(true);\n@@ -4213,1 +3903,0 @@\n-    @CallerSensitive\n@@ -4218,13 +3907,1 @@\n-\n-        Class<?> host = getNestHost0();\n-        if (host == this) {\n-            return this;\n-        }\n-        \/\/ returning a different class requires a security check\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkPackageAccess(sm,\n-                               ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-        }\n-        return host;\n+        return getNestHost0();\n@@ -4297,1 +3974,0 @@\n-    @CallerSensitive\n@@ -4305,11 +3981,0 @@\n-\n-        if (members.length > 1) {\n-            \/\/ If we return anything other than the current class we need\n-            \/\/ a security check\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                checkPackageAccess(sm,\n-                                   ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-            }\n-        }\n@@ -4485,1 +4150,0 @@\n-    @CallerSensitive\n@@ -4498,10 +4162,0 @@\n-        if (subClasses.length > 0) {\n-            \/\/ If we return some classes we need a security check:\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                checkPackageAccessForPermittedSubclasses(sm,\n-                                             ClassLoader.getClassLoader(Reflection.getCallerClass()),\n-                                             subClasses);\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":35,"deletions":381,"binary":false,"changes":416,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -31,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -44,1 +44,1 @@\n- * @since 22\n+ * @since 24\n@@ -46,1 +46,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -68,1 +67,1 @@\n-    String attributeName();\n+    Utf8Entry attributeName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -93,1 +92,1 @@\n- * @since 22\n+ * @since 24\n@@ -95,1 +94,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -214,1 +212,0 @@\n-     * @since 23\n@@ -222,1 +219,0 @@\n-     * @since 23\n@@ -231,1 +227,0 @@\n-     * @since 23\n@@ -239,1 +234,0 @@\n-     * @since 23\n@@ -247,1 +241,0 @@\n-     * @since 23\n@@ -255,1 +248,0 @@\n-     * @since 23\n@@ -264,1 +256,0 @@\n-     * @since 23\n@@ -272,1 +263,0 @@\n-     * @since 23\n@@ -280,1 +270,0 @@\n-     * @since 23\n@@ -288,1 +277,0 @@\n-     * @since 23\n@@ -297,1 +285,0 @@\n-     * @since 23\n@@ -314,1 +301,0 @@\n-     * @since 23\n@@ -323,1 +309,0 @@\n-     * @since 23\n@@ -331,1 +316,0 @@\n-     * @since 23\n@@ -339,1 +323,0 @@\n-     * @since 23\n@@ -347,1 +330,0 @@\n-     * @since 23\n@@ -355,1 +337,0 @@\n-     * @since 23\n@@ -363,1 +344,0 @@\n-     * @since 23\n@@ -371,1 +351,0 @@\n-     * @since 23\n@@ -379,1 +358,0 @@\n-     * @since 23\n@@ -387,1 +365,0 @@\n-     * @since 23\n@@ -395,1 +372,0 @@\n-     * @since 23\n@@ -403,1 +379,0 @@\n-     * @since 23\n@@ -411,1 +386,0 @@\n-     * @since 23\n@@ -419,1 +393,0 @@\n-     * @since 23\n@@ -427,1 +400,0 @@\n-     * @since 23\n@@ -435,1 +407,0 @@\n-     * @since 23\n@@ -443,1 +414,0 @@\n-     * @since 23\n@@ -451,1 +421,0 @@\n-     * @since 23\n@@ -459,1 +428,0 @@\n-     * @since 23\n@@ -467,1 +435,0 @@\n-     * @since 23\n@@ -475,1 +442,0 @@\n-     * @since 23\n@@ -483,1 +449,0 @@\n-     * @since 23\n@@ -491,1 +456,0 @@\n-     * @since 23\n@@ -499,1 +463,0 @@\n-     * @since 23\n@@ -508,1 +471,0 @@\n-     * @since 23\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attributes.java","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n@@ -36,1 +34,1 @@\n- * @since 22\n+ * @since 24\n@@ -38,1 +36,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassElement.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -56,1 +55,1 @@\n- * @since 22\n+ * @since 24\n@@ -58,1 +57,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -87,1 +85,1 @@\n-     * @since 22\n+     * @since 24\n@@ -89,1 +87,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -97,1 +94,1 @@\n-     * @since 22\n+     * @since 24\n@@ -99,1 +96,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -122,1 +118,1 @@\n-     * @since 22\n+     * @since 24\n@@ -124,1 +120,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -153,1 +148,1 @@\n-     * @since 22\n+     * @since 24\n@@ -155,1 +150,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -170,1 +164,1 @@\n-     * @since 22\n+     * @since 24\n@@ -172,1 +166,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -191,1 +184,1 @@\n-     * @since 22\n+     * @since 24\n@@ -193,1 +186,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -210,1 +202,1 @@\n-     * @since 22\n+     * @since 24\n@@ -212,1 +204,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -228,1 +219,1 @@\n-     * @since 22\n+     * @since 24\n@@ -230,1 +221,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -246,1 +236,1 @@\n-     * @since 22\n+     * @since 24\n@@ -248,1 +238,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -265,1 +254,1 @@\n-     * @since 22\n+     * @since 24\n@@ -267,1 +256,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -287,1 +275,1 @@\n-     * @since 22\n+     * @since 24\n@@ -289,1 +277,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -654,4 +641,1 @@\n-    \/**\n-     * The class major version of JAVA_23.\n-     * @since 23\n-     *\/\n+    \/** The class major version of JAVA_23. *\/\n@@ -660,4 +644,1 @@\n-    \/**\n-     * The class major version of JAVA_24.\n-     * @since 24\n-     *\/\n+    \/** The class major version of JAVA_24. *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -550,1 +550,1 @@\n- * @since 22\n+ * @since 24\n@@ -552,3 +552,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n-\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -110,3 +110,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -141,1 +138,1 @@\n-            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+            this.implInfo = caller.revealDirect(implementation);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -95,1 +94,1 @@\n-        disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);\n+        disableEagerInitialization = Boolean.getBoolean(disableEagerInitializationKey);\n@@ -146,3 +145,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -201,1 +197,1 @@\n-    private static String lambdaClassName(Class<?> targetClass) {\n+    private static String sanitizedTargetClassName(Class<?> targetClass) {\n@@ -207,1 +203,5 @@\n-        return name.replace('.', '\/').concat(\"$$Lambda\");\n+        return name.replace('.', '\/');\n+    }\n+\n+    private static String lambdaClassName(Class<?> targetClass) {\n+        return sanitizedTargetClassName(targetClass).concat(\"$$Lambda\");\n@@ -453,1 +453,1 @@\n-                           .ldc(classDesc(targetClass))\n+                           .ldc(ClassDesc.ofInternalName(sanitizedTargetClassName(targetClass)))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1211,5 +1211,1 @@\n-            try {\n-                assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+\" (PD)\";\n-            } catch (SecurityException ex) {\n-                \/\/ Self-check was blocked by security manager. This is OK.\n-            }\n+            assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+\" (PD)\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -34,0 +35,1 @@\n+import java.util.Properties;\n@@ -695,0 +697,19 @@\n+\n+    \/\/--- AOTCache support\n+\n+    \/**\n+     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n+     * use soft references to allow class unloading.\n+     *\n+     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n+     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n+     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n+     * Such classes will never be unloaded, so it's OK to use hard references.\n+     *\/\n+    static final boolean USE_SOFT_CACHE;\n+\n+    static {\n+        Properties props = GetPropertyAction.privilegedGetProperties();\n+        USE_SOFT_CACHE = Boolean.parseBoolean(\n+                props.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -60,3 +58,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-import sun.reflect.misc.ReflectUtil;\n@@ -163,1 +158,0 @@\n-    @CallerSensitive\n@@ -172,11 +166,1 @@\n-        final MethodHandle mh;\n-        @SuppressWarnings(\"removal\")\n-        var sm = System.getSecurityManager();\n-        if (sm != null) {\n-            final Class<?> caller = Reflection.getCallerClass();\n-            final ClassLoader ccl = caller != null ? caller.getClassLoader() : null;\n-            ReflectUtil.checkProxyPackageAccess(ccl, intfc);\n-            mh = ccl != null ? bindCaller(target, caller) : target;\n-        } else {\n-            mh = target;\n-        }\n+        final MethodHandle mh = target;\n@@ -287,11 +271,1 @@\n-        @SuppressWarnings(\"removal\")\n-        var sm = System.getSecurityManager();\n-        Lookup lookup;\n-        if (sm != null) {\n-            @SuppressWarnings(\"removal\")\n-            var l = AccessController.doPrivileged((PrivilegedAction<Lookup>) () ->\n-                    definer.defineClassAsLookup(true));\n-            lookup = l;\n-        } else {\n-            lookup = definer.defineClassAsLookup(true);\n-        }\n+        Lookup lookup = definer.defineClassAsLookup(true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-import sun.security.util.SecurityConstants;\n@@ -246,3 +244,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n@@ -466,3 +461,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager smgr = System.getSecurityManager();\n-        if (smgr != null)  smgr.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n@@ -744,2 +736,0 @@\n-     * <li>avoid <a href=\"MethodHandles.Lookup.html#secmgr\">package access checks<\/a>\n-     *     for classes accessible to the lookup class\n@@ -1762,1 +1752,0 @@\n-            ensureDefineClassPermission();\n@@ -1768,11 +1757,0 @@\n-        private void ensureDefineClassPermission() {\n-            if (allowedModes == TRUSTED)  return;\n-\n-            if (!hasFullPrivilegeAccess()) {\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sm = System.getSecurityManager();\n-                if (sm != null)\n-                    sm.checkPermission(new RuntimePermission(\"defineClass\"));\n-            }\n-        }\n-\n@@ -2045,1 +2023,0 @@\n-            ensureDefineClassPermission();\n@@ -2131,1 +2108,0 @@\n-            ensureDefineClassPermission();\n@@ -2776,1 +2752,0 @@\n-            checkSecurityManager(targetClass);\n@@ -2880,1 +2855,0 @@\n-            checkSecurityManager(targetClass);\n@@ -3300,1 +3274,1 @@\n-            return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n+            return lookup.getDirectMethod(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n@@ -3351,1 +3325,1 @@\n-            return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n+            return specialLookup.getDirectMethod(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n@@ -3383,1 +3357,1 @@\n-            return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+            return lookup.getDirectConstructor(ctor.getDeclaringClass(), ctor);\n@@ -3388,1 +3362,1 @@\n-         * and instantiated by the given constructor.  No security manager check.\n+         * and instantiated by the given constructor.\n@@ -3481,1 +3455,1 @@\n-            return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);\n+            return lookup.getDirectField(field.getReferenceKind(), f.getDeclaringClass(), field);\n@@ -3558,2 +3532,2 @@\n-            return getFieldVarHandleNoSecurityManager(getField.getReferenceKind(), putField.getReferenceKind(),\n-                                                      f.getDeclaringClass(), getField, putField);\n+            return getFieldVarHandle(getField.getReferenceKind(), putField.getReferenceKind(),\n+                                     f.getDeclaringClass(), getField, putField);\n@@ -3594,1 +3568,1 @@\n-            \/\/ Check SM permissions and member access before cracking.\n+            \/\/ Check member access before cracking.\n@@ -3597,1 +3571,0 @@\n-                checkSecurityManager(defc, member);\n@@ -3724,63 +3697,0 @@\n-        \/**\n-         * Perform steps 1 and 2b <a href=\"MethodHandles.Lookup.html#secmgr\">access checks<\/a>\n-         * for ensureInitialized, findClass or accessClass.\n-         *\/\n-        void checkSecurityManager(Class<?> refc) {\n-            if (allowedModes == TRUSTED)  return;\n-\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager smgr = System.getSecurityManager();\n-            if (smgr == null)  return;\n-\n-            \/\/ Step 1:\n-            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n-            if (!fullPrivilegeLookup ||\n-                !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {\n-                ReflectUtil.checkPackageAccess(refc);\n-            }\n-\n-            \/\/ Step 2b:\n-            if (!fullPrivilegeLookup) {\n-                smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-            }\n-        }\n-\n-        \/**\n-         * Perform steps 1, 2a and 3 <a href=\"MethodHandles.Lookup.html#secmgr\">access checks<\/a>.\n-         * Determines a trustable caller class to compare with refc, the symbolic reference class.\n-         * If this lookup object has full privilege access except original access,\n-         * then the caller class is the lookupClass.\n-         *\n-         * Lookup object created by {@link MethodHandles#privateLookupIn(Class, Lookup)}\n-         * from the same module skips the security permission check.\n-         *\/\n-        void checkSecurityManager(Class<?> refc, MemberName m) {\n-            Objects.requireNonNull(refc);\n-            Objects.requireNonNull(m);\n-\n-            if (allowedModes == TRUSTED)  return;\n-\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager smgr = System.getSecurityManager();\n-            if (smgr == null)  return;\n-\n-            \/\/ Step 1:\n-            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n-            if (!fullPrivilegeLookup ||\n-                !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {\n-                ReflectUtil.checkPackageAccess(refc);\n-            }\n-\n-            \/\/ Step 2a:\n-            if (m.isPublic()) return;\n-            if (!fullPrivilegeLookup) {\n-                smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);\n-            }\n-\n-            \/\/ Step 3:\n-            Class<?> defc = m.getDeclaringClass();\n-            if (!fullPrivilegeLookup && defc != refc) {\n-                ReflectUtil.checkPackageAccess(defc);\n-            }\n-        }\n-\n@@ -3926,2 +3836,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);\n+            return getDirectMethodCommon(refKind, refc, method, doRestrict, callerLookup);\n@@ -3932,8 +3841,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, callerLookup);\n-        }\n-        \/** Check access and get the requested method, eliding security manager checks. *\/\n-        private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class<?> refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {\n-            final boolean doRestrict    = true;\n-            final boolean checkSecurity = false;  \/\/ not needed for reflection or for linking CONSTANT_MH constants\n-            return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);\n+            return getDirectMethodCommon(REF_invokeSpecial, refc, method, doRestrict, callerLookup);\n@@ -3943,1 +3845,0 @@\n-                                                   boolean checkSecurity,\n@@ -3947,3 +3848,0 @@\n-            \/\/ Optionally check with the security manager; this isn't needed for unreflect* calls.\n-            if (checkSecurity)\n-                checkSecurityManager(refc, method);\n@@ -4017,7 +3915,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectFieldCommon(refKind, refc, field, checkSecurity);\n-        }\n-        \/** Check access and get the requested field, eliding security manager checks. *\/\n-        private MethodHandle getDirectFieldNoSecurityManager(byte refKind, Class<?> refc, MemberName field) throws IllegalAccessException {\n-            final boolean checkSecurity = false;  \/\/ not needed for reflection or for linking CONSTANT_MH constants\n-            return getDirectFieldCommon(refKind, refc, field, checkSecurity);\n+            return getDirectFieldCommon(refKind, refc, field);\n@@ -4026,2 +3918,1 @@\n-        private MethodHandle getDirectFieldCommon(byte refKind, Class<?> refc, MemberName field,\n-                                                  boolean checkSecurity) throws IllegalAccessException {\n+        private MethodHandle getDirectFieldCommon(byte refKind, Class<?> refc, MemberName field) throws IllegalAccessException {\n@@ -4029,3 +3920,0 @@\n-            \/\/ Optionally check with the security manager; this isn't needed for unreflect* calls.\n-            if (checkSecurity)\n-                checkSecurityManager(refc, field);\n@@ -4042,8 +3930,1 @@\n-            final boolean checkSecurity = true;\n-            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);\n-        }\n-        private VarHandle getFieldVarHandleNoSecurityManager(byte getRefKind, byte putRefKind,\n-                                                             Class<?> refc, MemberName getField, MemberName putField)\n-                throws IllegalAccessException {\n-            final boolean checkSecurity = false;\n-            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);\n+            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField);\n@@ -4052,2 +3933,2 @@\n-                                                  Class<?> refc, MemberName getField, MemberName putField,\n-                                                  boolean checkSecurity) throws IllegalAccessException {\n+                                                  Class<?> refc, MemberName getField,\n+                                                  MemberName putField) throws IllegalAccessException {\n@@ -4060,2 +3941,0 @@\n-            if (checkSecurity)\n-                checkSecurityManager(refc, getField);\n@@ -4069,2 +3948,0 @@\n-                if (checkSecurity)\n-                    checkSecurityManager(refc, putField);\n@@ -4088,7 +3965,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectConstructorCommon(refc, ctor, checkSecurity);\n-        }\n-        \/** Check access and get the requested constructor, eliding security manager checks. *\/\n-        private MethodHandle getDirectConstructorNoSecurityManager(Class<?> refc, MemberName ctor) throws IllegalAccessException {\n-            final boolean checkSecurity = false;  \/\/ not needed for reflection or for linking CONSTANT_MH constants\n-            return getDirectConstructorCommon(refc, ctor, checkSecurity);\n+            return getDirectConstructorCommon(refc, ctor);\n@@ -4097,2 +3968,1 @@\n-        private MethodHandle getDirectConstructorCommon(Class<?> refc, MemberName ctor,\n-                                                  boolean checkSecurity) throws IllegalAccessException {\n+        private MethodHandle getDirectConstructorCommon(Class<?> refc, MemberName ctor) throws IllegalAccessException {\n@@ -4101,3 +3971,0 @@\n-            \/\/ Optionally check with the security manager; this isn't needed for unreflect* calls.\n-            if (checkSecurity)\n-                checkSecurityManager(refc, ctor);\n@@ -4170,2 +4037,1 @@\n-            try {\n-                MemberName resolved2 = publicLookup().resolveOrNull(refKind,\n+            MemberName resolved2 = publicLookup().resolveOrNull(refKind,\n@@ -4173,5 +4039,1 @@\n-                if (resolved2 == null) {\n-                    return false;\n-                }\n-                checkSecurityManager(defc, resolved2);\n-            } catch (SecurityException ex) {\n+            if (resolved2 == null) {\n@@ -4185,1 +4047,1 @@\n-                return getDirectFieldNoSecurityManager(refKind, defc, member);\n+                return getDirectField(refKind, defc, member);\n@@ -4187,1 +4049,1 @@\n-                return getDirectMethodNoSecurityManager(refKind, defc, member, findBoundCallerLookup(member));\n+                return getDirectMethod(refKind, defc, member, findBoundCallerLookup(member));\n@@ -4189,1 +4051,1 @@\n-                return getDirectConstructorNoSecurityManager(defc, member);\n+                return getDirectConstructor(defc, member);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":22,"deletions":160,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.security.AccessController;\n@@ -38,2 +37,0 @@\n-import sun.security.action.GetPropertyAction;\n-import sun.security.util.SecurityConstants;\n@@ -84,11 +81,0 @@\n-    static void checkPermission() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ SecurityConstants.ACCESS_PERMISSION is used to check\n-            \/\/ whether a client has sufficient privilege to defeat Java\n-            \/\/ language access control checks.\n-            sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n-        }\n-    }\n-\n@@ -117,1 +103,0 @@\n-        checkPermission();\n@@ -200,1 +185,0 @@\n-        AccessibleObject.checkPermission();\n@@ -261,2 +245,0 @@\n-        AccessibleObject.checkPermission();\n-\n@@ -506,4 +488,1 @@\n-    @SuppressWarnings(\"removal\")\n-    static final ReflectionFactory reflectionFactory =\n-        AccessController.doPrivileged(\n-            new ReflectionFactory.GetReflectionFactoryAction());\n+    static final ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();\n@@ -627,2 +606,1 @@\n-    \/\/ always succeed (it is not affected by the granting or revoking\n-    \/\/ of permissions); we speed up the check in the common case by\n+    \/\/ always succeed; we speed up the check in the common case by\n@@ -760,2 +738,1 @@\n-            String s = GetPropertyAction.privilegedGetProperty(\n-                    \"sun.reflect.debugModuleAccessChecks\");\n+            String s = System.getProperty(\"sun.reflect.debugModuleAccessChecks\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -173,1 +173,0 @@\n-        AccessibleObject.checkPermission();\n@@ -1164,1 +1163,0 @@\n-    \/\/ security check is done before calling this method\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -55,2 +53,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n@@ -60,2 +56,0 @@\n-import sun.security.action.GetPropertyAction;\n-import sun.security.util.SecurityConstants;\n@@ -369,1 +363,0 @@\n-    @CallerSensitive\n@@ -374,6 +367,1 @@\n-        @SuppressWarnings(\"removal\")\n-        Class<?> caller = System.getSecurityManager() == null\n-                              ? null\n-                              : Reflection.getCallerClass();\n-\n-        return getProxyConstructor(caller, loader, interfaces)\n+        return getProxyConstructor(loader, interfaces)\n@@ -389,3 +377,0 @@\n-     * @param   caller passed from a public-facing @CallerSensitive method if\n-     *                 SecurityManager is set or {@code null} if there's no\n-     *                 SecurityManager\n@@ -398,2 +383,1 @@\n-    private static Constructor<?> getProxyConstructor(Class<?> caller,\n-                                                      ClassLoader loader,\n+    private static Constructor<?> getProxyConstructor(ClassLoader loader,\n@@ -405,3 +389,0 @@\n-            if (caller != null) {\n-                checkProxyAccess(caller, loader, intf);\n-            }\n@@ -415,3 +396,0 @@\n-            if (caller != null) {\n-                checkProxyAccess(caller, loader, intfsArray);\n-            }\n@@ -426,33 +404,0 @@\n-    \/*\n-     * Check permissions required to create a Proxy class.\n-     *\n-     * To define a proxy class, it performs the access checks as in\n-     * Class.forName (VM will invoke ClassLoader.checkPackageAccess):\n-     * 1. \"getClassLoader\" permission check if loader == null\n-     * 2. checkPackageAccess on the interfaces it implements\n-     *\n-     * To get a constructor and new instance of a proxy class, it performs\n-     * the package access check on the interfaces it implements\n-     * as in Class.getConstructor.\n-     *\n-     * If an interface is non-public, the proxy class must be defined by\n-     * the defining loader of the interface.  If the caller's class loader\n-     * is not the same as the defining loader of the interface, the VM\n-     * will throw IllegalAccessError when the generated proxy class is\n-     * being defined.\n-     *\/\n-    private static void checkProxyAccess(Class<?> caller,\n-                                         ClassLoader loader,\n-                                         Class<?> ... interfaces)\n-    {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            ClassLoader ccl = caller.getClassLoader();\n-            if (loader == null && ccl != null) {\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-            }\n-            ReflectUtil.checkProxyPackageAccess(ccl, interfaces);\n-        }\n-    }\n-\n@@ -519,1 +464,1 @@\n-            ClassLoader loader = getLoader(context.module());\n+            ClassLoader loader = context.module().getClassLoader();\n@@ -589,2 +534,1 @@\n-        private static final String DEBUG =\n-            GetPropertyAction.privilegedGetProperty(\"jdk.proxy.debug\", \"\");\n+        private static final String DEBUG = System.getProperty(\"jdk.proxy.debug\", \"\");\n@@ -621,1 +565,1 @@\n-            assert getLoader(context.module()) == loader;\n+            assert context.module().getClassLoader() == loader;\n@@ -633,4 +577,0 @@\n-         *\n-         * Must call the checkProxyAccess method to perform permission checks\n-         * before calling this.\n-        @SuppressWarnings(\"removal\")\n@@ -647,6 +587,1 @@\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    cons.setAccessible(true);\n-                    return null;\n-                }\n-            });\n+            cons.setAccessible(true);\n@@ -791,1 +726,1 @@\n-                    if (getLoader(m) != loader) {\n+                    if (m.getClassLoader() != loader) {\n@@ -982,1 +917,0 @@\n-    @CallerSensitive\n@@ -988,5 +922,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final Class<?> caller = System.getSecurityManager() == null\n-                                    ? null\n-                                    : Reflection.getCallerClass();\n-\n@@ -996,1 +925,1 @@\n-        Constructor<?> cons = getProxyConstructor(caller, loader, interfaces);\n+        Constructor<?> cons = getProxyConstructor(loader, interfaces);\n@@ -998,1 +927,1 @@\n-        return newProxyInstance(caller, cons, h);\n+        return newProxyInstance(cons, h);\n@@ -1001,3 +930,1 @@\n-    private static Object newProxyInstance(Class<?> caller, \/\/ null if no SecurityManager\n-                                           Constructor<?> cons,\n-                                           InvocationHandler h) {\n+    private static Object newProxyInstance(Constructor<?> cons, InvocationHandler h) {\n@@ -1008,4 +935,0 @@\n-            if (caller != null) {\n-                checkNewProxyPermission(caller, cons.getDeclaringClass());\n-            }\n-\n@@ -1025,29 +948,0 @@\n-    private static void checkNewProxyPermission(Class<?> caller, Class<?> proxyClass) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            if (ReflectUtil.isNonPublicProxyClass(proxyClass)) {\n-                ClassLoader ccl = caller.getClassLoader();\n-                ClassLoader pcl = proxyClass.getClassLoader();\n-\n-                \/\/ do permission check if the caller is in a different runtime package\n-                \/\/ of the proxy class\n-                String pkg = proxyClass.getPackageName();\n-                String callerPkg = caller.getPackageName();\n-\n-                if (pcl != ccl || !pkg.equals(callerPkg)) {\n-                    sm.checkPermission(new ReflectPermission(\"newProxyInPackage.\" + pkg));\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Returns the class loader for the given module.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static ClassLoader getLoader(Module m) {\n-        PrivilegedAction<ClassLoader> pa = m::getClassLoader;\n-        return AccessController.doPrivileged(pa);\n-    }\n-\n@@ -1078,2 +972,0 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n@@ -1092,10 +984,0 @@\n-        if (System.getSecurityManager() != null) {\n-            Class<?> ihClass = ih.getClass();\n-            Class<?> caller = Reflection.getCallerClass();\n-            if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),\n-                                                    ihClass.getClassLoader()))\n-            {\n-                ReflectUtil.checkPackageAccess(ihClass);\n-            }\n-        }\n-\n@@ -1252,13 +1134,7 @@\n-    @SuppressWarnings(\"removal\")\n-        return AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public MethodHandles.Lookup run() {\n-                try {\n-                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n-                    m.setAccessible(true);\n-                    return (MethodHandles.Lookup) m.invoke(null, caller);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new InternalError(e);\n-                }\n-            }\n-        });\n+        try {\n+            Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n+            m.setAccessible(true);\n+            return (MethodHandles.Lookup) m.invoke(null, caller);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":17,"deletions":141,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -109,3 +108,2 @@\n-            java.security.AccessController.doPrivileged(\n-                    new GetBooleanAction(\n-                            \"jdk.proxy.ProxyGenerator.saveGeneratedFiles\"));\n+            Boolean.getBoolean(\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\");\n+\n@@ -218,21 +216,15 @@\n-            java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<Void>() {\n-                        public Void run() {\n-                            try {\n-                                int i = name.lastIndexOf('.');\n-                                Path path;\n-                                if (i > 0) {\n-                                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n-                                    Files.createDirectories(dir);\n-                                    path = dir.resolve(name.substring(i + 1) + \".class\");\n-                                } else {\n-                                    path = Path.of(name + \".class\");\n-                                }\n-                                Files.write(path, classFile);\n-                                return null;\n-                            } catch (IOException e) {\n-                                throw new InternalError(\n-                                        \"I\/O exception saving generated file: \" + e);\n-                            }\n-                        }\n-                    });\n+            try {\n+                int i = name.lastIndexOf('.');\n+                Path path;\n+                if (i > 0) {\n+                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n+                    Files.createDirectories(dir);\n+                    path = dir.resolve(name.substring(i + 1) + \".class\");\n+                } else {\n+                    path = Path.of(name + \".class\");\n+                }\n+                Files.write(path, classFile);\n+                return null;\n+            } catch (IOException e) {\n+                throw new InternalError(\"I\/O exception saving generated file: \" + e);\n+            }\n@@ -574,5 +566,0 @@\n-     * Discussion: Currently, for Proxy to work with SecurityManager,\n-     * we rely on the parameter classes of the methods to be computed\n-     * from Proxy instead of via user code paths like bootstrap method\n-     * lazy evaluation. That might change if we can pass in the live\n-     * Method objects directly..\n@@ -795,3 +782,0 @@\n-         * The generated code must be run in an AccessController.doPrivileged\n-         * block if a SecurityManager is present, as otherwise the code\n-         * cannot pass {@code null} ClassLoader to forName.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -989,4 +989,1 @@\n-        @SuppressWarnings(\"removal\")\n-            java.security.AccessController.doPrivileged(\n-                new sun.security.action.GetBooleanAction(\n-                    \"java.util.Arrays.useLegacyMergeSort\")).booleanValue();\n+                Boolean.getBoolean(\"java.util.Arrays.useLegacyMergeSort\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.security.AccessControlContext;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        buf.writeIndex(buf.constantPool().utf8Entry(name));\n+        buf.writeIndex(attr.attributeName());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    Utf8Entry name;\n@@ -62,2 +63,5 @@\n-    public String attributeName() {\n-        return mapper.name();\n+    public Utf8Entry attributeName() {\n+        if (name == null) {\n+            name = classReader.readEntry(payloadStart - 6, Utf8Entry.class);\n+        }\n+        return name;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-                      list(\"attributes\", \"attribute\", clm.attributes().stream().map(Attribute::attributeName)))\n+                      list(\"attributes\", \"attribute\", clm.attributes().stream().map(Attribute::attributeName).map(Utf8Entry::stringValue)))\n@@ -675,1 +675,1 @@\n-                                          \"attribute\", f.attributes().stream().map(Attribute::attributeName)))\n+                                          \"attribute\", f.attributes().stream().map(Attribute::attributeName).map(Utf8Entry::stringValue)))\n@@ -686,1 +686,1 @@\n-                              \"attribute\", m.attributes().stream().map(Attribute::attributeName)))\n+                              \"attribute\", m.attributes().stream().map(Attribute::attributeName).map(Utf8Entry::stringValue)))\n@@ -697,1 +697,1 @@\n-                    \"attribute\", com.attributes().stream().map(Attribute::attributeName)));\n+                    \"attribute\", com.attributes().stream().map(Attribute::attributeName).map(Utf8Entry::stringValue)));\n@@ -1002,1 +1002,1 @@\n-                                            .map(Attribute::attributeName)))\n+                                            .map(Attribute::attributeName).map(Utf8Entry::stringValue)))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,5 +57,0 @@\n-    @Override\n-    public String attributeName() {\n-        return mapper.name();\n-    }\n-\n@@ -96,0 +91,2 @@\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_CONSTANT_VALUE);\n+\n@@ -108,0 +105,4 @@\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -113,0 +114,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_DEPRECATED);\n+\n@@ -116,0 +120,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -121,0 +130,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_SYNTHETIC);\n+\n@@ -124,0 +136,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -129,0 +146,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_SIGNATURE);\n+\n@@ -140,0 +160,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -145,0 +170,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_EXCEPTIONS);\n+\n@@ -156,0 +184,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -161,0 +194,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_ANNOTATION_DEFAULT);\n+\n@@ -172,0 +208,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -176,0 +217,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_SOURCE_FILE);\n+\n@@ -188,0 +232,4 @@\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -192,0 +240,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_STACK_MAP_TABLE);\n+\n@@ -203,0 +254,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -208,0 +264,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_INNER_CLASSES);\n+\n@@ -219,0 +278,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -224,0 +288,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_RECORD);\n+\n@@ -235,0 +302,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -240,0 +312,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_ENCLOSING_METHOD);\n+\n@@ -258,0 +333,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -263,0 +343,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_METHOD_PARAMETERS);\n+\n@@ -274,0 +357,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -279,0 +367,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_MODULE_TARGET);\n+\n@@ -290,0 +381,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -295,0 +391,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_MODULE_MAIN_CLASS);\n+\n@@ -306,0 +405,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -311,0 +415,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_MODULE_HASHES);\n+\n@@ -329,0 +436,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -334,0 +446,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_MODULE_PACKAGES);\n+\n@@ -345,0 +460,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -350,0 +470,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_MODULE_RESOLUTION);\n+\n@@ -361,0 +484,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -366,0 +494,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_PERMITTED_SUBCLASSES);\n+\n@@ -377,0 +508,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -382,0 +518,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_LOADABLE_DESCRIPTORS);\n+\n@@ -393,0 +532,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -398,0 +542,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_NEST_MEMBERS);\n+\n@@ -409,0 +556,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -414,0 +566,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_NEST_HOST);\n+\n@@ -425,0 +580,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -430,0 +590,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_COMPILATION_ID);\n+\n@@ -441,0 +604,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -446,0 +614,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_SOURCE_ID);\n+\n@@ -457,0 +628,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -462,0 +638,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_SOURCE_DEBUG_EXTENSION);\n+\n@@ -473,0 +652,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -478,0 +662,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_CHARACTER_RANGE_TABLE);\n+\n@@ -489,0 +676,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -494,0 +686,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_LINE_NUMBER_TABLE);\n+\n@@ -505,0 +700,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -510,0 +710,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_LOCAL_VARIABLE_TABLE);\n+\n@@ -521,0 +724,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -526,0 +734,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_LOCAL_VARIABLE_TYPE_TABLE);\n+\n@@ -537,0 +748,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -542,0 +758,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_RUNTIME_VISIBLE_ANNOTATIONS);\n+\n@@ -553,0 +772,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -558,0 +782,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_RUNTIME_INVISIBLE_ANNOTATIONS);\n+\n@@ -569,0 +796,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -574,0 +806,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);\n+\n@@ -591,0 +826,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -596,0 +836,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);\n+\n@@ -613,0 +856,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -618,0 +866,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+\n@@ -629,0 +880,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -634,0 +890,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+\n@@ -645,0 +904,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -768,0 +1032,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_MODULE);\n+\n@@ -836,0 +1103,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n@@ -860,0 +1132,3 @@\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_BOOTSTRAP_METHODS);\n+\n@@ -873,0 +1148,5 @@\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":285,"deletions":5,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -179,2 +179,2 @@\n-                if (!a.attributeMapper().allowMultiple() && !attrNames.add(a.attributeName())) {\n-                    errors.add(new VerifyError(\"Multiple %s attributes in %s\".formatted(a.attributeName(), toString(ae))));\n+                if (!a.attributeMapper().allowMultiple() && !attrNames.add(a.attributeName().stringValue())) {\n+                    errors.add(new VerifyError(\"Multiple %s attributes in %s\".formatted(a.attributeName().stringValue(), toString(ae))));\n@@ -336,1 +336,1 @@\n-            errors.add(new VerifyError(\"Wrong %s attribute length in %s\".formatted(a.attributeName(), toString(ae))));\n+            errors.add(new VerifyError(\"Wrong %s attribute length in %s\".formatted(a.attributeName().stringValue(), toString(ae))));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        @JEP(number=477, title=\"Implicitly Declared Classes and Instance Main Methods\", status=\"Third Preview\")\n+        @JEP(number=495, title=\"Simple Source Files and Instance Main Methods\", status=\"Fourth Preview\")\n@@ -79,1 +79,0 @@\n-        @JEP(number=466, title=\"ClassFile API\", status=\"Second Preview\")\n@@ -82,1 +81,1 @@\n-        @JEP(number=476, title=\"Module Import Declarations\", status=\"Preview\")\n+        @JEP(number=494, title=\"Module Import Declarations\", status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.io.ObjectStreamField;\n@@ -42,0 +43,1 @@\n+import java.lang.reflect.Proxy;\n@@ -43,1 +45,2 @@\n-import java.util.Properties;\n+import java.util.Set;\n+\n@@ -48,2 +51,0 @@\n-import sun.security.action.GetPropertyAction;\n-import sun.security.util.SecurityConstants;\n@@ -72,0 +73,1 @@\n+\n@@ -96,6 +98,0 @@\n-     * <p> First, if there is a security manager, its\n-     * <code>checkPermission<\/code> method is called with a {@link\n-     * java.lang.RuntimePermission} with target\n-     * <code>\"reflectionFactoryAccess\"<\/code>.  This may result in a\n-     * security exception.\n-     *\n@@ -106,4 +102,1 @@\n-     *\n-     * @exception SecurityException if a security manager exists and its\n-     *             <code>checkPermission<\/code> method doesn't allow\n-     *             access to the RuntimePermission \"reflectionFactoryAccess\".  *\/\n+     *\/\n@@ -111,6 +104,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(\n-                SecurityConstants.REFLECTION_FACTORY_ACCESS_PERMISSION);\n-        }\n@@ -394,0 +381,40 @@\n+    public final MethodHandle defaultReadObjectForSerialization(Class<?> cl) {\n+        if (hasDefaultOrNoSerialization(cl)) {\n+            return null;\n+        }\n+\n+        return SharedSecrets.getJavaObjectStreamReflectionAccess().defaultReadObject(cl);\n+    }\n+\n+    public final MethodHandle defaultWriteObjectForSerialization(Class<?> cl) {\n+        if (hasDefaultOrNoSerialization(cl)) {\n+            return null;\n+        }\n+\n+        return SharedSecrets.getJavaObjectStreamReflectionAccess().defaultWriteObject(cl);\n+    }\n+\n+    \/**\n+     * These are specific leaf classes which appear to be Serializable, but which\n+     * have special semantics according to the serialization specification. We\n+     * could theoretically include array classes here, but it is easier and clearer\n+     * to just use `Class#isArray` instead.\n+     *\/\n+    private static final Set<Class<?>> nonSerializableLeafClasses = Set.of(\n+        Class.class,\n+        String.class,\n+        ObjectStreamClass.class\n+    );\n+\n+    private static boolean hasDefaultOrNoSerialization(Class<?> cl) {\n+        return ! Serializable.class.isAssignableFrom(cl)\n+            || cl.isInterface()\n+            || cl.isArray()\n+            || Proxy.isProxyClass(cl)\n+            || Externalizable.class.isAssignableFrom(cl)\n+            || cl.isEnum()\n+            || cl.isRecord()\n+            || cl.isHidden()\n+            || nonSerializableLeafClasses.contains(cl);\n+    }\n+\n@@ -499,0 +526,22 @@\n+    public final ObjectStreamField[] serialPersistentFields(Class<?> cl) {\n+        if (! Serializable.class.isAssignableFrom(cl) || cl.isInterface() || cl.isEnum()) {\n+            return null;\n+        }\n+\n+        try {\n+            Field field = cl.getDeclaredField(\"serialPersistentFields\");\n+            int mods = field.getModifiers();\n+            if (! (Modifier.isStatic(mods) && Modifier.isPrivate(mods) && Modifier.isFinal(mods))) {\n+                return null;\n+            }\n+            if (field.getType() != ObjectStreamField[].class) {\n+                return null;\n+            }\n+            field.setAccessible(true);\n+            ObjectStreamField[] array = (ObjectStreamField[]) field.get(null);\n+            return array != null && array.length > 0 ? array.clone() : array;\n+        } catch (ReflectiveOperationException e) {\n+            return null;\n+        }\n+    }\n+\n@@ -562,2 +611,1 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-            \"true\".equals(props.getProperty(\"jdk.reflect.useNativeAccessorOnly\"));\n+            \"true\".equals(System.getProperty(\"jdk.reflect.useNativeAccessorOnly\"));\n@@ -566,1 +614,1 @@\n-            \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+            \"true\".equals(System.getProperty(\"jdk.disableSerialConstructorChecks\"));\n@@ -588,1 +636,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":70,"deletions":23,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -148,0 +148,2 @@\n+    exports jdk.internal to\n+        jdk.incubator.vector;\n@@ -156,0 +158,1 @@\n+        java.se, \/\/ for ParticipatesInPreview\n@@ -316,1 +319,0 @@\n-        java.datatransfer,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -315,2 +315,0 @@\n-        \/\/ We use doPrivileged in order to allow an unprivileged caller to ask an arbitrary\n-        \/\/ class loader about the binding of the proposed name (type.getName()).\n@@ -324,11 +322,6 @@\n-        @SuppressWarnings(\"removal\")\n-        Class<?> res = java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<>() {\n-                    public Class<?> run() {\n-                        try {\n-                            return Class.forName(name, false, refcLoader);\n-                        } catch (ClassNotFoundException | LinkageError e) {\n-                            return null; \/\/ Assume the class is not found\n-                        }\n-                    }\n-            });\n+        Class<?> res = null;\n+        try {\n+            res = Class.forName(name, false, refcLoader);\n+        } catch (ClassNotFoundException | LinkageError e) {\n+            \/\/ Assume the class is not found\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-         * Warn about\"dangling\" documentation comments,\n+         * Warn about \"dangling\" documentation comments,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n@@ -136,0 +137,12 @@\n+        return participatesInPreview(syms, s.packge().modle);\n+    }\n+\n+    \/**\n+     * Returns true if module {@code m} is deemed to participate in the preview, and\n+     * therefore no warnings or errors will be produced.\n+     *\n+     * @param syms the symbol table\n+     * @param m the module to check\n+     * @return true if {@code m} is participating in the preview of {@code previewSymbol}\n+     *\/\n+    public boolean participatesInPreview(Symtab syms, ModuleSymbol m) {\n@@ -140,1 +153,1 @@\n-                .anyMatch(ed -> ed.modules.contains(s.packge().modle));\n+                .anyMatch(ed -> ed.modules.contains(m));\n@@ -215,0 +228,1 @@\n+            case JAVA_BASE_TRANSITIVE -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+        JAVA_BASE_TRANSITIVE(JDK24, Fragments.FeatureJavaBaseTransitive, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2621,2 +2621,1 @@\n-                        rs.resolveImplicitThis(tree.meth.pos(),\n-                                               localEnv, site, true);\n+                        checkNewInnerClass(tree.meth.pos(), localEnv, site, true);\n@@ -2829,3 +2828,1 @@\n-        } else if (!clazztype.tsym.isInterface() &&\n-                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n-                   clazztype.getEnclosingType().hasTag(CLASS)) {\n+        } else {\n@@ -2833,1 +2830,1 @@\n-            rs.resolveImplicitThis(tree.pos(), env, clazztype);\n+            checkNewInnerClass(tree.pos(), env, clazztype, false);\n@@ -3098,0 +3095,18 @@\n+        void checkNewInnerClass(DiagnosticPosition pos, Env<AttrContext> env, Type type, boolean isSuper) {\n+            boolean isLocal = type.tsym.owner.kind == MTH;\n+            if ((type.tsym.flags() & (INTERFACE | ENUM | RECORD)) != 0 ||\n+                    (!isLocal && !type.tsym.isInner()) ||\n+                    (isSuper && env.enclClass.sym.isAnonymous())) {\n+                \/\/ nothing to check\n+                return;\n+            }\n+            Symbol res = isLocal ?\n+                    rs.findLocalClassOwner(env, type.tsym) :\n+                    rs.findSelfContaining(pos, env, type.getEnclosingType().tsym, isSuper);\n+            if (res.exists()) {\n+                rs.accessBase(res, pos, env.enclClass.sym.type, names._this, true);\n+            } else {\n+                log.error(pos, Errors.EnclClassRequired(type.tsym));\n+            }\n+        }\n+\n@@ -3670,1 +3685,0 @@\n-                    case MISSING_ENCL:\n@@ -3721,5 +3735,1 @@\n-                Type enclosingType = exprType.getEnclosingType();\n-                if (enclosingType != null && enclosingType.hasTag(CLASS)) {\n-                    \/\/ Check for the existence of an appropriate outer instance\n-                    rs.resolveImplicitThis(that.pos(), env, exprType);\n-                }\n+                checkNewInnerClass(that.pos(), env, exprType, false);\n@@ -4219,0 +4229,1 @@\n+        chk.validate(tree.var.vartype, env, true);\n@@ -4228,1 +4239,0 @@\n-        chk.validate(tree.var.vartype, env, true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -933,1 +933,1 @@\n-                        ClassSymbol clazz = (ClassSymbol) sup.tsym;\n+                        ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2160,4 +2160,2 @@\n-    private final RecoveryLoadClass starImportScopeRecovery = (env, name) -> {\n-        Scope importScope = env.toplevel.starImportScope;\n-        Symbol existing = importScope.findFirst(Convert.shortName(name),\n-                                                sym -> sym.kind == TYP && sym.flatName() == name);\n+    private final RecoveryLoadClass starImportScopeRecovery =\n+            onDemandImportScopeRecovery(false);\n@@ -2165,3 +2163,13 @@\n-        if (existing != null) {\n-            try {\n-                existing = finder.loadClass(existing.packge().modle, name);\n+    private final RecoveryLoadClass moduleImportScopeRecovery =\n+            onDemandImportScopeRecovery(true);\n+\n+    private RecoveryLoadClass onDemandImportScopeRecovery(boolean moduleImportScope) {\n+        return (env, name) -> {\n+            Scope importScope = moduleImportScope ? env.toplevel.moduleImportScope\n+                                                  : env.toplevel.starImportScope;\n+            Symbol existing = importScope.findFirst(Convert.shortName(name),\n+                                                    sym -> sym.kind == TYP && sym.flatName() == name);\n+\n+            if (existing != null) {\n+                try {\n+                    existing = finder.loadClass(existing.packge().modle, name);\n@@ -2169,3 +2177,4 @@\n-                return new InvisibleSymbolError(env, true, existing);\n-            } catch (CompletionFailure cf) {\n-                \/\/ignore\n+                    return new InvisibleSymbolError(env, true, existing);\n+                } catch (CompletionFailure cf) {\n+                    \/\/ignore\n+                }\n@@ -2173,3 +2182,3 @@\n-        }\n-        return null;\n-    };\n+            return null;\n+        };\n+    }\n@@ -2444,0 +2453,5 @@\n+\n+            sym = findGlobalType(env, env.toplevel.moduleImportScope, name, moduleImportScopeRecovery);\n+            if (sym.exists()) return sym;\n+\n+            else bestSoFar = bestOf(bestSoFar, sym);\n@@ -3741,1 +3755,1 @@\n-            Symbol sym = needsInference ?\n+            return needsInference ?\n@@ -3745,1 +3759,0 @@\n-            return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;\n@@ -3790,0 +3803,57 @@\n+    \/**\n+     * Find a \"valid\" reference to an enclosing 'A.this' such that A is a subclass of the provided class symbol.\n+     * A reference to an enclosing 'A.this' is \"valid\" if (a) we're not in the early-construction context for A\n+     * and (b) if the current class is not an inner class of A.\n+     *\/\n+    Symbol findSelfContaining(DiagnosticPosition pos,\n+                    Env<AttrContext> env,\n+                    TypeSymbol c,\n+                    boolean isSuper) {\n+        Env<AttrContext> env1 = isSuper ? env.outer : env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (isStatic(env1)) staticOnly = true;\n+            if (env1.enclClass.sym.isSubClass(c, types)) {\n+                Symbol sym = env1.info.scope.findFirst(names._this);\n+                if (sym != null) {\n+                    if (staticOnly) {\n+                        \/\/ current class is not an inner class, stop search\n+                        return new StaticError(sym);\n+                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n+                        \/\/ early construction context, stop search\n+                        return new RefBeforeCtorCalledError(sym);\n+                    } else {\n+                        \/\/ found it\n+                        return sym;\n+                    }\n+                }\n+            }\n+            if ((env1.enclClass.sym.flags() & STATIC) != 0) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return varNotFound;\n+    }\n+\n+    \/**\n+     * Resolve the (method) owner of a local class. This can fail if the local class\n+     * is referenced from a static context nested inside the local class. Effectively,\n+     * this lookup succeeds if we can access a local variable declared inside the owner\n+     * method from the provided env.\n+     *\/\n+    Symbol findLocalClassOwner(Env<AttrContext> env, TypeSymbol c) {\n+        Symbol owner = c.owner;\n+        Assert.check(owner.kind == MTH);\n+        Env<AttrContext> env1 = env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (env1.info.scope.owner == owner) {\n+                return (staticOnly) ?\n+                    new BadLocalClassCreation(c) :\n+                    owner;\n+            }\n+            if (isStatic(env1)) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return methodNotFound;\n+    }\n+\n@@ -3814,1 +3884,1 @@\n-                                  name, true);\n+                            name, true);\n@@ -3821,2 +3891,2 @@\n-            name == names._super && !isStatic(env) &&\n-            types.isDirectSuperInterface(c, env.enclClass.sym)) {\n+                name == names._super && !isStatic(env) &&\n+                types.isDirectSuperInterface(c, env.enclClass.sym)) {\n@@ -3837,2 +3907,2 @@\n-                              Errors.IllegalDefaultSuperCall(c,\n-                                                             Fragments.RedundantSupertype(c, i)));\n+                            Errors.IllegalDefaultSuperCall(c,\n+                                    Fragments.RedundantSupertype(c, i)));\n@@ -3945,70 +4015,0 @@\n-    \/**\n-     * Resolve `c.this' for an enclosing class c that contains the\n-     * named member.\n-     * @param pos           The position to use for error reporting.\n-     * @param env           The environment current at the expression.\n-     * @param member        The member that must be contained in the result.\n-     *\/\n-    Symbol resolveSelfContaining(DiagnosticPosition pos,\n-                                 Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);\n-        if (sym == null) {\n-            log.error(pos, Errors.EnclClassRequired(member));\n-            return syms.errSymbol;\n-        } else {\n-            return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);\n-        }\n-    }\n-\n-    boolean enclosingInstanceMissing(Env<AttrContext> env, Type type) {\n-        if (type.hasTag(CLASS) && type.getEnclosingType().hasTag(CLASS)) {\n-            Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);\n-            return encl == null || encl.kind.isResolutionError();\n-        }\n-        return false;\n-    }\n-\n-    private Symbol resolveSelfContainingInternal(Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Name name = names._this;\n-        Env<AttrContext> env1 = isSuperCall ? env.outer : env;\n-        boolean staticOnly = false;\n-        if (env1 != null) {\n-            while (env1 != null && env1.outer != null) {\n-                if (isStatic(env1)) staticOnly = true;\n-                if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {\n-                    Symbol sym = env1.info.scope.findFirst(name);\n-                    if (sym != null) {\n-                        if (staticOnly) sym = new StaticError(sym);\n-                        return sym;\n-                    }\n-                }\n-                if ((env1.enclClass.sym.flags() & STATIC) != 0)\n-                    staticOnly = true;\n-                env1 = env1.outer;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Resolve an appropriate implicit this instance for t's container.\n-     * JLS 8.8.5.1 and 15.9.2\n-     *\/\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n-        return resolveImplicitThis(pos, env, t, false);\n-    }\n-\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n-        Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)\n-                         ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)\n-                         : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;\n-        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n-        }\n-        return thisType;\n-    }\n-\n@@ -4737,0 +4737,22 @@\n+    \/**\n+     * Specialization of {@link StaticError} for illegal\n+     * creation of local class instances from a static context.\n+     *\/\n+    class BadLocalClassCreation extends StaticError {\n+        BadLocalClassCreation(Symbol sym) {\n+            super(sym, \"bad local class creation\");\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,\n+                                   DiagnosticPosition pos,\n+                                   Symbol location,\n+                                   Type site,\n+                                   Name name,\n+                                   List<Type> argtypes,\n+                                   List<Type> typeargtypes) {\n+            return diags.create(dkind, log.currentSource(), pos,\n+                    \"local.cant.be.inst.static\", kindName(sym), sym);\n+        }\n+    }\n+\n@@ -4896,17 +4918,0 @@\n-    \/**\n-     * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,\n-     * but pointing to a class for which an enclosing instance is not available.\n-     *\/\n-    class BadConstructorReferenceError extends InvalidSymbolError {\n-\n-        public BadConstructorReferenceError(Symbol sym) {\n-            super(MISSING_ENCL, sym, \"BadConstructorReferenceError\");\n-        }\n-\n-        @Override\n-        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {\n-           return diags.create(dkind, log.currentSource(), pos,\n-                \"cant.access.inner.cls.constr\", site.tsym.name, argtypes, site.getEnclosingType());\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":112,"deletions":107,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+            toplevel.moduleImportScope.finalizeScope();\n@@ -335,1 +336,1 @@\n-                javaLang, env);\n+                javaLang, env, false);\n@@ -345,1 +346,1 @@\n-                            names.asterisk), true));\n+                            names.asterisk), true), false);\n@@ -417,1 +418,1 @@\n-                    doImport((JCImport) imp);\n+                    doImport((JCImport) imp, false);\n@@ -442,1 +443,1 @@\n-        private void doImport(JCImport tree) {\n+        private void doImport(JCImport tree, boolean fromModuleImport) {\n@@ -454,1 +455,2 @@\n-                if (tree.staticImport)\n+                if (tree.staticImport) {\n+                    Assert.check(!fromModuleImport);\n@@ -456,2 +458,3 @@\n-                else\n-                    importAll(tree, p, env);\n+                } else {\n+                    importAll(tree, p, env, fromModuleImport);\n+                }\n@@ -461,0 +464,1 @@\n+                    Assert.check(!fromModuleImport);\n@@ -464,0 +468,1 @@\n+                    Assert.check(!fromModuleImport);\n@@ -510,1 +515,1 @@\n-                        doImport(nestedImport);\n+                        doImport(nestedImport, true);\n@@ -546,2 +551,7 @@\n-                               Env<AttrContext> env) {\n-            env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);\n+                               Env<AttrContext> env,\n+                               boolean fromModuleImport) {\n+            StarImportScope targetScope =\n+                    fromModuleImport ? env.toplevel.moduleImportScope\n+                                     : env.toplevel.starImportScope;\n+\n+            targetScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -209,0 +209,3 @@\n+    \/** true if the class file being read is a preview class file. *\/\n+    boolean previewClassFile;\n+\n@@ -1214,1 +1217,3 @@\n-                                if (flags.contains(RequiresFlag.TRANSITIVE)) {\n+                                if (flags.contains(RequiresFlag.TRANSITIVE) &&\n+                                    (majorVersion != Version.MAX().major || !previewClassFile) &&\n+                                    !preview.participatesInPreview(syms, msym)) {\n@@ -3212,1 +3217,1 @@\n-        boolean previewClassFile =\n+        previewClassFile =\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -682,1 +682,2 @@\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS)) {\n+                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n+                        !shebang(c, pos)) {\n@@ -690,0 +691,8 @@\n+    \/** Returns true for a comment that acts similarly to shebang in UNIX *\/\n+    private boolean shebang(Comment c, JCDiagnostic.DiagnosticPosition pos) {\n+        var src = log.currentSource();\n+        return c.getStyle() == Comment.CommentStyle.JAVADOC_LINE &&\n+                c.getPos().getStartPosition() == 0 &&\n+                src.getLineNumber(pos.getEndPosition(src.getEndPosTable())) == 1;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -924,4 +924,0 @@\n-# 0: name\n-compiler.err.modifier.not.allowed.here=\\\n-    modifier {0} not allowed here\n-\n@@ -1102,5 +1098,0 @@\n-# 0: symbol, 1: list of type, 2: type\n-compiler.misc.cant.access.inner.cls.constr=\\\n-    cannot access constructor {0}({1})\\n\\\n-    an enclosing instance of type {2} is not in scope\n-\n@@ -2899,0 +2890,5 @@\n+## The first argument ({0}) is a \"kindname\".\n+# 0: symbol kind, 1: symbol\n+compiler.err.local.cant.be.inst.static=\\\n+    local {0} {1} cannot be instantiated from a static context\n+\n@@ -3264,0 +3260,3 @@\n+compiler.misc.feature.java.base.transitive=\\\n+    transitive modifier for java.base\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                print(attr.attributeName());\n+                print(attr.attributeName().stringValue());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-compiler\/vectorapi\/VectorRebracket128Test.java#Z 8330538 generic-all\n+compiler\/vectorapi\/VectorRebracket128Test.java 8330538 generic-all\n@@ -105,0 +105,11 @@\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id0 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id1 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id2 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id3 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id4 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id5 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id6 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id7 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id8 8344583 macosx-aarch64\n+runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id9 8344583 macosx-aarch64\n+\n@@ -118,3 +129,1 @@\n-runtime\/Dictionary\/CleanProtectionDomain.java 8341916 generic-all\n-runtime\/Dictionary\/ProtectionDomainCacheTest.java 8341916 generic-all\n-runtime\/logging\/ProtectionDomainVerificationTest.java 8341916 generic-all\n+runtime\/NMT\/VirtualAllocCommitMerge.java 8309698 linux-s390x\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  -runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java \\\n@@ -453,0 +454,1 @@\n+ -runtime\/cds\/appcds\/applications \\\n@@ -470,0 +472,1 @@\n+ -runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java \\\n@@ -474,0 +477,1 @@\n+ -runtime\/cds\/appcds\/CommandLineFlagCombo.java \\\n@@ -541,0 +545,55 @@\n+# Run CDS tests with -XX:+AOTClassLinking. This should include most CDS tests, except for\n+# those that rely on redefining classes that are already archived.\n+hotspot_aot_classlinking = \\\n+  runtime\/cds \\\n+ -runtime\/cds\/appcds\/aotClassLinking \\\n+ -runtime\/cds\/appcds\/BadBSM.java \\\n+ -runtime\/cds\/appcds\/cacheObject\/ArchivedIntegerCacheTest.java \\\n+ -runtime\/cds\/appcds\/cacheObject\/ArchivedModuleCompareTest.java \\\n+ -runtime\/cds\/appcds\/CDSandJFR.java \\\n+ -runtime\/cds\/appcds\/customLoader\/HelloCustom_JFR.java \\\n+ -runtime\/cds\/appcds\/customLoader\/ParallelTestMultiFP.java \\\n+ -runtime\/cds\/appcds\/customLoader\/ParallelTestSingleFP.java \\\n+ -runtime\/cds\/appcds\/customLoader\/SameNameInTwoLoadersTest.java \\\n+ -runtime\/cds\/appcds\/DumpClassListWithLF.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/ModulePath.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdasInTwoArchives.java \\\n+ -runtime\/cds\/appcds\/HelloExtTest.java \\\n+ -runtime\/cds\/appcds\/javaldr\/AnonVmClassesDuringDump.java \\\n+ -runtime\/cds\/appcds\/javaldr\/GCDuringDump.java \\\n+ -runtime\/cds\/appcds\/javaldr\/LockDuringDump.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/classpathtests\/EmptyClassInBootClassPath.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/JigsawOptionsCombo.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/AddOpens.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/AddModules.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/JvmtiAddPath.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndCP.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndCP_JFR.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/overridetests\/OverrideTests.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/RedefineClassesInModuleGraph.java \\\n+ -runtime\/cds\/appcds\/JvmtiAddPath.java \\\n+ -runtime\/cds\/appcds\/jvmti \\\n+ -runtime\/cds\/appcds\/LambdaProxyClasslist.java \\\n+ -runtime\/cds\/appcds\/loaderConstraints\/LoaderConstraintsTest.java \\\n+ -runtime\/cds\/appcds\/redefineClass \\\n+ -runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedLambdas.java \\\n+ -runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedVarHandles.java \\\n+ -runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java \\\n+ -runtime\/cds\/appcds\/RewriteBytecodesTest.java \\\n+ -runtime\/cds\/appcds\/SpecifySysLoaderProp.java \\\n+ -runtime\/cds\/appcds\/StaticArchiveWithLambda.java \\\n+ -runtime\/cds\/appcds\/TestEpsilonGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestParallelGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestSerialGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestZGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestWithProfiler.java \\\n+ -runtime\/cds\/serviceability\/ReplaceCriticalClassesForSubgraphs.java \\\n+ -runtime\/cds\/serviceability\/ReplaceCriticalClasses.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformInterfaceAndImplementor.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformSuperAndSubClasses.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformSuperSubTwoPckgs.java\n+\n@@ -560,0 +619,4 @@\n+tier1_runtime_no_cds = \\\n+   :tier1_runtime \\\n+   -runtime\/cds\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -713,1 +713,0 @@\n-javax\/swing\/JMenuItem\/ActionListenerCalledTwice\/ActionListenerCalledTwiceTest.java 8316151 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -37,0 +38,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -48,0 +51,2 @@\n+    private static final int PREVIEW_MINOR_VERSION =\n+            ClassFile.PREVIEW_MINOR_VERSION;\n@@ -58,1 +63,1 @@\n-         * There are four test cases for JDK 9 and then one test case\n+         * There are four test cases for JDK 9, one test case\n@@ -60,2 +65,3 @@\n-         * feature release for a total of (4 + (FEATURE - 9) ) =>\n-         * (feature - 5) rows.\n+         * feature release, and two tests for the current release with\n+         * a preview flag set, for a total of (4 + (FEATURE - 9) + 2)\n+         * rows.\n@@ -63,1 +69,1 @@\n-        Object[][] result = new Object[(FEATURE - 5)][];\n+        List<Object[]> result = new ArrayList<>(4 + (FEATURE - 9) + 2);\n@@ -66,4 +72,4 @@\n-        result[0] = new Object[]{ 53, 0, Set.of()};\n-        result[1] = new Object[]{ 53, 0, Set.of(STATIC) };\n-        result[2] = new Object[]{ 53, 0, Set.of(TRANSITIVE) };\n-        result[3] = new Object[]{ 53, 0, Set.of(STATIC, TRANSITIVE) };\n+        result.add(new Object[]{ 53, 0, Set.of()});\n+        result.add(new Object[]{ 53, 0, Set.of(STATIC) });\n+        result.add(new Object[]{ 53, 0, Set.of(TRANSITIVE) });\n+        result.add(new Object[]{ 53, 0, Set.of(STATIC, TRANSITIVE) });\n@@ -73,2 +79,2 @@\n-        for (int i = 4; i < (FEATURE - 5) ; i++) {\n-            result[i] = new Object[]{i + 50, 0, Set.of()};\n+        for (int i = 10; i <= FEATURE; i++) {\n+            result.add(new Object[]{ 44 + i, 0, Set.of()});\n@@ -77,1 +83,8 @@\n-        return result;\n+        result.add(new Object[]{ 44 + FEATURE,\n+                                 PREVIEW_MINOR_VERSION,\n+                                 Set.of()});\n+        result.add(new Object[]{ 44 + FEATURE,\n+                                 PREVIEW_MINOR_VERSION,\n+                                 Set.of(TRANSITIVE) });\n+\n+        return result.toArray(s -> new Object[s][]);\n@@ -86,2 +99,3 @@\n-         * current feature release, plus one addition test case for\n-         * the next release for a total of (3 + (FEATURE - 9) * 3 + 1)\n+         * current feature release, two tests for the current release with\n+         * the preview flag set, plus one addition test case for\n+         * the next release for a total of (3 + (FEATURE - 9) * 3 + 2 + 1)\n@@ -90,2 +104,1 @@\n-        int unsupportedCount = 3 + (FEATURE - 9)*3 + 1;\n-        Object[][] result = new Object[unsupportedCount][];\n+        List<Object[]> result = new ArrayList<>(3 + (FEATURE - 9) * 3 + 2 + 1);\n@@ -93,3 +106,3 @@\n-        result[0] = new Object[]{50, 0, Set.of()}; \/\/ JDK 6\n-        result[1] = new Object[]{51, 0, Set.of()}; \/\/ JDK 7\n-        result[2] = new Object[]{52, 0, Set.of()}; \/\/ JDK 8\n+        result.add(new Object[]{50, 0, Set.of()}); \/\/ JDK 6\n+        result.add(new Object[]{51, 0, Set.of()}); \/\/ JDK 7\n+        result.add(new Object[]{52, 0, Set.of()}); \/\/ JDK 8\n@@ -98,4 +111,3 @@\n-            int base = 3 + (i-10)*3;\n-            result[base]     = new Object[]{i + 44, 0, Set.of(STATIC)};\n-            result[base + 1] = new Object[]{i + 44, 0, Set.of(TRANSITIVE)};\n-            result[base + 2] = new Object[]{i + 44, 0, Set.of(STATIC, TRANSITIVE)};\n+            result.add(new Object[]{i + 44, 0, Set.of(STATIC)});\n+            result.add(new Object[]{i + 44, 0, Set.of(TRANSITIVE)});\n+            result.add(new Object[]{i + 44, 0, Set.of(STATIC, TRANSITIVE)});\n@@ -105,2 +117,10 @@\n-        result[unsupportedCount - 1] = new Object[]{FEATURE+1+44, 0, Set.of()};\n-        return result;\n+        result.add(new Object[]{FEATURE + 44,\n+                                PREVIEW_MINOR_VERSION,\n+                                Set.of(STATIC)});\n+        result.add(new Object[]{FEATURE + 44,\n+                                PREVIEW_MINOR_VERSION,\n+                                Set.of(STATIC, TRANSITIVE)});\n+\n+        result.add(new Object[]{FEATURE+1+44, 0, Set.of()});\n+\n+        return result.toArray(s -> new Object[s][]);\n","filename":"test\/jdk\/java\/lang\/module\/ClassFileVersionsTest.java","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+import java.lang.classfile.ClassFileVersion;\n+import java.lang.classfile.ClassTransform;\n@@ -1524,0 +1526,64 @@\n+    @Test(expectedExceptions = InvalidModuleDescriptorException.class)\n+    public void testRequiresTransitiveJavaBaseNotPermitted1() throws Exception {\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"foo\")\n+                .requires(Set.of(Modifier.TRANSITIVE), \"java.base\")\n+                .build();\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ModuleInfoWriter.write(descriptor, baos);\n+        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n+\n+        ModuleDescriptor.read(bb, () -> Set.of(\"p\", \"q\"));\n+    }\n+\n+    @Test(expectedExceptions = InvalidModuleDescriptorException.class)\n+    public void testRequiresTransitiveJavaBaseNotPermitted2() throws Exception {\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"foo\")\n+                .requires(Set.of(Modifier.TRANSITIVE), \"java.base\")\n+                .build();\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ModuleInfoWriter.write(descriptor, baos);\n+        byte[] bytecode = baos.toByteArray();\n+        ByteBuffer bb = ByteBuffer.wrap(bytecode);\n+        setClassFileVersion(bb, ClassFile.JAVA_21_VERSION, -1);\n+\n+        ModuleDescriptor.read(bb, () -> Set.of(\"p\", \"q\"));\n+    }\n+\n+    public void testRequiresTransitiveJavaBasePermitted() throws Exception {\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"foo\")\n+                .requires(Set.of(Modifier.TRANSITIVE), \"java.base\")\n+                .build();\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ModuleInfoWriter.write(descriptor, baos);\n+        byte[] bytecode = baos.toByteArray();\n+        ByteBuffer bb = ByteBuffer.wrap(bytecode);\n+        setClassFileVersion(bb, -1, ClassFile.PREVIEW_MINOR_VERSION);\n+\n+        descriptor = ModuleDescriptor.read(bb, () -> Set.of(\"p\", \"q\"));\n+\n+        assertEquals(descriptor.requires().size(), 1);\n+        Requires javaBase = descriptor.requires().iterator().next();\n+        assertEquals(javaBase.name(), \"java.base\");\n+        assertEquals(javaBase.modifiers(), Set.of(Modifier.TRANSITIVE));\n+    }\n+\n+    \/**Change the classfile versions of the provided classfile to the provided\n+     * values.\n+     *\n+     * @param bytecode the classfile content to modify\n+     * @param major the major classfile version to set,\n+     *              -1 if the existing version should be kept\n+     * @param minor the minor classfile version to set,\n+     *              -1 if the existing version should be kept\n+     *\/\n+    private void setClassFileVersion(ByteBuffer bb, int major, int minor) {\n+        if (minor != (-1)) {\n+            bb.putShort(4, (short) minor);\n+        }\n+        if (major != (-1)) {\n+            bb.putShort(6, (short) major);\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-                                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n-                                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName());\n+                                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName().stringValue());\n+                                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName().stringValue());\n@@ -94,2 +94,2 @@\n-                                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n-                                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName());\n+                                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName().stringValue());\n+                                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName().stringValue());\n@@ -135,1 +135,1 @@\n-                                        default -> throw new AssertionError(\"Unexpected record component attribute: \" + rca.attributeName());\n+                                        default -> throw new AssertionError(\"Unexpected record component attribute: \" + rca.attributeName().stringValue());\n@@ -146,2 +146,2 @@\n-                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n-                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName());\n+                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName().stringValue());\n+                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName().stringValue());\n@@ -599,1 +599,1 @@\n-                    throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n+                    throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName().stringValue());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+        map.put(\"vm.cds.supports.aot.class.linking\", this::vmCDSSupportsAOTClassLinking);\n@@ -461,0 +462,8 @@\n+    \/**\n+     * @return true if this VM can support the -XX:AOTClassLinking option\n+     *\/\n+    protected String vmCDSSupportsAOTClassLinking() {\n+      \/\/ Currently, the VM supports AOTClassLinking as long as it's able to write archived java heap.\n+      return vmCDSCanWriteArchivedJavaHeap();\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-            checkEquals(innerClasses.attributeName(), \"InnerClasses\",\n+            checkEquals(innerClasses.attributeName().stringValue(), \"InnerClasses\",\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -793,3 +793,0 @@\n-  \/\/ Protection Domain Table\n-  public native int protectionDomainRemovedCount();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}