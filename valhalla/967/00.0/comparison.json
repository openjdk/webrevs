{"files":[{"patch":"@@ -38,0 +38,1 @@\n+include gensrc\/GensrcRegex.gmk\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,0 +109,1 @@\n+        --add-exports java.base\/jdk.internal.event=ALL-UNNAMED \\\n@@ -160,1 +161,1 @@\n-    SRC := $(MICROBENCHMARK_NATIVE_OUTPUT), \\\n+    SRC := $(MICROBENCHMARK_NATIVE_OUTPUT)\/lib, \\\n@@ -162,2 +163,2 @@\n-    FILES := $(BUILD_MICROBENCHMARK_LIBRARIES), \\\n-    FLATTEN := true, \\\n+    FILES := $(filter $(MICROBENCHMARK_NATIVE_OUTPUT)\/lib\/%, \\\n+        $(BUILD_MICROBENCHMARK_LIBRARIES)), \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3853,201 +3853,0 @@\n-  enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(tmp, oop);\n-      __ ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      __ tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n-      __ br(Assembler::NE, cont);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      if (EnableValhalla) {\n-        \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n-        __ andr(tmp, tmp, ~((int) markWord::inline_type_bit_in_place));\n-      }\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-      __ br(Assembler::EQ, cont);\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ mov(rscratch1, sp);\n-      __ sub(disp_hdr, disp_hdr, rscratch1);\n-      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-      \/\/ If condition is true we are cont and hence we can store 0 as the\n-      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n-      __ b(count);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-\n-    \/\/ The object's monitor m is unlocked iff m->owner == nullptr,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from nullptr to current thread.\n-    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n-    __ cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-      __ mov(tmp, (address)markWord::unused_mark().value());\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n-    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n-  enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ cmp(disp_hdr, zr);\n-      __ br(Assembler::EQ, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-                 \/*release*\/ true, \/*weak*\/ false, tmp);\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_unlock(oop, tmp, box, disp_hdr, no_count);\n-      __ b(count);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-      \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-      \/\/ be encoded.\n-      __ tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ br(Assembler::NE, stub->entry());\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-    Label notRecursive;\n-    __ cbz(disp_hdr, notRecursive);\n-\n-    \/\/ Recursive lock\n-    __ sub(disp_hdr, disp_hdr, 1u);\n-    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-    __ b(cont);\n-\n-    __ bind(notRecursive);\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n-    __ cbnz(rscratch1, cont);\n-    \/\/ need a release store here\n-    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-    __ stlr(zr, tmp); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n@@ -16700,1 +16499,3 @@\n-  ins_encode(aarch64_enc_fast_lock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n@@ -16713,1 +16514,3 @@\n-  ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":203,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n@@ -160,1 +160,1 @@\n-    fast_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,201 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n+                                  Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp, oop);\n+    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    br(Assembler::NE, cont);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    if (EnableValhalla) {\n+      \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+      andr(tmp, tmp, ~((int) markWord::inline_type_bit_in_place));\n+    }\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+    br(Assembler::EQ, cont);\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    mov(rscratch1, sp);\n+    sub(disp_hdr, disp_hdr, rscratch1);\n+    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    \/\/ If condition is true we are cont and hence we can store 0 as the\n+    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n+    b(count);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n+  cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n+    mov(tmp, (address)markWord::unused_mark().value());\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+  cmp(rscratch1, rthread);\n+  br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n+  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n+                                    Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    cmp(disp_hdr, zr);\n+    br(Assembler::EQ, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+            \/*release*\/ true, \/*weak*\/ false, tmp);\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_unlock(oop, tmp, box, disp_hdr, no_count);\n+    b(count);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n+    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n+    \/\/ be encoded.\n+    tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    br(Assembler::NE, stub->entry());\n+    bind(stub->continuation());\n+  }\n+\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+\n+  Label notRecursive;\n+  cbz(disp_hdr, notRecursive);\n+\n+  \/\/ Recursive lock\n+  sub(disp_hdr, disp_hdr, 1u);\n+  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n+  b(cont);\n+\n+  bind(notRecursive);\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n+  cmp(rscratch1, zr); \/\/ Sets flags for result\n+  cbnz(rscratch1, cont);\n+  \/\/ need a release store here\n+  lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  stlr(zr, tmp); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":201,"deletions":0,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_aarch64.cpp.\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2);\n+  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -870,1 +870,1 @@\n-      fast_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n+      lightweight_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n@@ -1005,1 +1005,1 @@\n-      fast_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n+      lightweight_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7132,1 +7132,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -7139,1 +7139,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -7164,1 +7164,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -7171,1 +7171,1 @@\n-void MacroAssembler::fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1676,2 +1676,2 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n-  void fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2108,1 +2108,1 @@\n-      __ fast_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n@@ -2250,1 +2250,1 @@\n-      __ fast_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -990,1 +990,1 @@\n-      fast_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+      lightweight_lock(object, \/* mark word *\/ header, tmp, slow_case);\n@@ -1140,1 +1140,1 @@\n-      fast_unlock(object, header, slow_case);\n+      lightweight_unlock(object, header, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    fast_lock_impl(obj, hdr, thread, tmp, slow_case);\n+    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -144,1 +144,1 @@\n-    fast_unlock_impl(obj, disp_hdr, hdr, slow_case);\n+    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-    fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT);\n+    lightweight_lock(objReg, tmpReg, thread, scrReg, NO_COUNT);\n@@ -958,1 +958,1 @@\n-      fast_unlock_impl(objReg, boxReg, tmpReg, NO_COUNT);\n+      lightweight_unlock(objReg, boxReg, tmpReg, NO_COUNT);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1388,1 +1388,1 @@\n-      fast_lock_impl(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n+      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1522,1 +1522,1 @@\n-      fast_unlock_impl(obj_reg, swap_reg, header_reg, slow_case);\n+      lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10566,1 +10566,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -10574,1 +10574,1 @@\n-void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n@@ -10602,1 +10602,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -10609,1 +10609,1 @@\n-void MacroAssembler::fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2101,2 +2101,2 @@\n-  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n-  void fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1738,1 +1738,1 @@\n-      __ fast_lock_impl(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n@@ -1898,1 +1898,1 @@\n-      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2474,1 +2474,1 @@\n-      __ fast_lock_impl(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -2619,1 +2619,1 @@\n-      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2068,1 +2068,1 @@\n-  switch (state) {\n+  switch (state & ~SUSPENDED) {\n@@ -2074,1 +2074,0 @@\n-    case RUNNABLE_SUSPENDED :\n@@ -2077,0 +2076,1 @@\n+    case TIMED_PARKING:\n@@ -2081,1 +2081,0 @@\n-    case PARKED_SUSPENDED :\n@@ -2085,0 +2084,4 @@\n+    case TIMED_PARKED:\n+    case TIMED_PINNED:\n+      status = JavaThreadStatus::PARKED_TIMED;\n+      break;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -537,14 +537,15 @@\n-    NEW          = 0,\n-    STARTED      = 1,\n-    RUNNABLE     = 2,\n-    RUNNING      = 3,\n-    PARKING      = 4,\n-    PARKED       = 5,\n-    PINNED       = 6,\n-    YIELDING     = 7,\n-    TERMINATED   = 99,\n-\n-    \/\/ can be suspended from scheduling when unmounted\n-    SUSPENDED    = 1 << 8,\n-    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n-    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n+    NEW           = 0,\n+    STARTED       = 1,\n+    RUNNABLE      = 2,\n+    RUNNING       = 3,\n+    PARKING       = 4,\n+    PARKED        = 5,\n+    PINNED        = 6,\n+    TIMED_PARKING = 7,\n+    TIMED_PARKED  = 8,\n+    TIMED_PINNED  = 9,\n+    YIELDING      = 10,\n+    TERMINATED    = 99,\n+\n+    \/\/ additional state bits\n+    SUSPENDED    = 1 << 8,   \/\/ suspended when unmounted\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -207,1 +207,2 @@\n-      tty->print_cr(\"Decoding %s \" INTPTR_FORMAT, stub_id, (intptr_t) stub);\n+      tty->print_cr(\"Decoding %s \" PTR_FORMAT \" [\" PTR_FORMAT \", \" PTR_FORMAT \"] (%d bytes)\",\n+                    stub_id, p2i(stub), p2i(stub->code_begin()), p2i(stub->code_end()), stub->code_size());\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -594,1 +594,1 @@\n-void CompileBroker::compilation_init_phase1(JavaThread* THREAD) {\n+void CompileBroker::compilation_init(JavaThread* THREAD) {\n@@ -753,4 +753,0 @@\n-}\n-\/\/ Completes compiler initialization. Compilation requests submitted\n-\/\/ prior to this will be silently ignored.\n-void CompileBroker::compilation_init_phase2() {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  \/\/ that of GenCollectedHeap::ensure_parsability().\n+  \/\/ that of ParallelScavengeHeap::ensure_parsability().\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-#include \"oops\/arrayKlass.hpp\"\n-#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/arrayKlass.inline.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -144,0 +144,58 @@\n+ArrayKlass* ArrayKlass::array_klass(int n, TRAPS) {\n+\n+  assert(dimension() <= n, \"check order of chain\");\n+  int dim = dimension();\n+  if (dim == n) return this;\n+\n+  \/\/ lock-free read needs acquire semantics\n+  if (higher_dimension_acquire() == nullptr) {\n+\n+    ResourceMark rm(THREAD);\n+    {\n+      \/\/ Ensure atomic creation of higher dimensions\n+      MutexLocker mu(THREAD, MultiArray_lock);\n+\n+      \/\/ Check if another thread beat us\n+      if (higher_dimension() == nullptr) {\n+\n+        \/\/ Create multi-dim klass object and link them together\n+        ObjArrayKlass* ak =\n+          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n+                                                 false, name()->is_Q_array_signature(), CHECK_NULL);\n+        ak->set_lower_dimension(this);\n+        \/\/ use 'release' to pair with lock-free load\n+        release_set_higher_dimension(ak);\n+        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n+      }\n+    }\n+  }\n+\n+  ObjArrayKlass *ak = higher_dimension();\n+  THREAD->check_possible_safepoint();\n+  return ak->array_klass(n, THREAD);\n+}\n+\n+ArrayKlass* ArrayKlass::array_klass_or_null(int n) {\n+\n+  assert(dimension() <= n, \"check order of chain\");\n+  int dim = dimension();\n+  if (dim == n) return this;\n+\n+  \/\/ lock-free read needs acquire semantics\n+  if (higher_dimension_acquire() == nullptr) {\n+    return nullptr;\n+  }\n+\n+  ObjArrayKlass *ak = higher_dimension();\n+  return ak->array_klass_or_null(n);\n+}\n+\n+ArrayKlass* ArrayKlass::array_klass(TRAPS) {\n+  return array_klass(dimension() +  1, THREAD);\n+}\n+\n+ArrayKlass* ArrayKlass::array_klass_or_null() {\n+  return array_klass_or_null(dimension() +  1);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":60,"deletions":2,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -77,0 +77,8 @@\n+  \/\/ Returns the ObjArrayKlass for n'th dimension.\n+  ArrayKlass* array_klass(int n, TRAPS);\n+  ArrayKlass* array_klass_or_null(int n);\n+\n+  \/\/ Returns the array class with this class as element type.\n+  ArrayKlass* array_klass(TRAPS);\n+  ArrayKlass* array_klass_or_null();\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"oops\/arrayKlass.inline.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n@@ -350,57 +350,0 @@\n-\n-ArrayKlass* ObjArrayKlass::array_klass(int n, TRAPS) {\n-\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-\n-    ResourceMark rm(THREAD);\n-    {\n-      \/\/ Ensure atomic creation of higher dimensions\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if another thread beat us\n-      if (higher_dimension() == nullptr) {\n-\n-        \/\/ Create multi-dim klass object and link them together\n-        ObjArrayKlass* ak = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n-                                                          false, this->name()->is_Q_array_signature(), CHECK_NULL);\n-        ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(ak);\n-        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n-    }\n-  }\n-\n-  ObjArrayKlass *ak = higher_dimension();\n-  THREAD->check_possible_safepoint();\n-  return ak->array_klass(n, THREAD);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass_or_null(int n) {\n-\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  ObjArrayKlass *ak = higher_dimension();\n-  return ak->array_klass_or_null(n);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass(TRAPS) {\n-  return array_klass(dimension() +  1, THREAD);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass_or_null() {\n-  return array_klass_or_null(dimension() +  1);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -91,8 +91,0 @@\n-  \/\/ Returns the ObjArrayKlass for n'th dimension.\n-  virtual ArrayKlass* array_klass(int n, TRAPS);\n-  virtual ArrayKlass* array_klass_or_null(int n);\n-\n-  \/\/ Returns the array class with this class as element type.\n-  virtual ArrayKlass* array_klass(TRAPS);\n-  virtual ArrayKlass* array_klass_or_null();\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/arrayKlass.inline.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n@@ -172,57 +172,0 @@\n-\/\/ create a klass of array holding typeArrays\n-ArrayKlass* TypeArrayKlass::array_klass(int n, TRAPS) {\n-  int dim = dimension();\n-  assert(dim <= n, \"check order of chain\");\n-    if (dim == n)\n-      return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-\n-    ResourceMark rm;\n-    JavaThread *jt = THREAD;\n-    {\n-      \/\/ Atomic create higher dimension and link into list\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      if (higher_dimension() == nullptr) {\n-        Klass* oak = ObjArrayKlass::allocate_objArray_klass(\n-              class_loader_data(), dim + 1, this, false, false, CHECK_NULL);\n-        ObjArrayKlass* h_ak = ObjArrayKlass::cast(oak);\n-        h_ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(h_ak);\n-        assert(h_ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n-    }\n-  }\n-\n-  ObjArrayKlass* h_ak = higher_dimension();\n-  THREAD->check_possible_safepoint();\n-  return h_ak->array_klass(n, THREAD);\n-}\n-\n-\/\/ return existing klass of array holding typeArrays\n-ArrayKlass* TypeArrayKlass::array_klass_or_null(int n) {\n-  int dim = dimension();\n-  assert(dim <= n, \"check order of chain\");\n-    if (dim == n)\n-      return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  ObjArrayKlass* h_ak = higher_dimension();\n-  return h_ak->array_klass_or_null(n);\n-}\n-\n-ArrayKlass* TypeArrayKlass::array_klass(TRAPS) {\n-  return array_klass(dimension() +  1, THREAD);\n-}\n-\n-ArrayKlass* TypeArrayKlass::array_klass_or_null() {\n-  return array_klass_or_null(dimension() +  1);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-  \/\/ The eventual count of vectorizable packs in slp\n-  int _slp_vector_pack_count;\n+  \/\/ Cached CountedLoopEndNode of pre loop for main loops\n+  CountedLoopEndNode* _pre_loop_end;\n@@ -245,1 +245,1 @@\n-      _slp_maximum_unroll_factor(0), _slp_vector_pack_count(0) {\n+      _slp_maximum_unroll_factor(0), _pre_loop_end(nullptr) {\n@@ -336,0 +336,4 @@\n+  CountedLoopEndNode* find_pre_loop_end();\n+  CountedLoopNode* pre_loop_head() const;\n+  CountedLoopEndNode* pre_loop_end();\n+  void set_pre_loop_end(CountedLoopEndNode* pre_loop_end);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1236,0 +1236,3 @@\n+  \/\/ Whether this is a memory phi node\n+  bool is_memory_phi() const { return is_Phi() && bottom_type() == Type::MEMORY; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1880,0 +1880,6 @@\n+WB_ENTRY(jobjectArray, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass klass))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  objArrayOop resolved_refs= ik->constants()->resolved_references();\n+  return (jobjectArray)JNIHandles::make_local(THREAD, resolved_refs);\n+WB_END\n+\n@@ -2894,0 +2900,1 @@\n+  {CC\"getResolvedReferences0\", CC\"(Ljava\/lang\/Class;)[Ljava\/lang\/Object;\", (void*)&WB_GetResolvedReferences},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1924,9 +1924,0 @@\n-  if (UseHeavyMonitors) {\n-    if (FLAG_IS_CMDLINE(LockingMode) && LockingMode != LM_MONITOR) {\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"Conflicting -XX:+UseHeavyMonitors and -XX:LockingMode=%d flags\\n\", LockingMode);\n-      return false;\n-    }\n-    FLAG_SET_CMDLINE(LockingMode, LM_MONITOR);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1080,4 +1080,0 @@\n-  develop(bool, UseHeavyMonitors, false,                                    \\\n-          \"(Deprecated) Use heavyweight instead of lightweight Java \"       \\\n-          \"monitors\")                                                       \\\n-                                                                            \\\n@@ -1086,1 +1082,1 @@\n-          \"+UseHeavyMonitors\")                                              \\\n+          \"-XX:LockingMode=0 (LM_MONITOR)\")                                 \\\n@@ -2030,1 +2026,1 @@\n-  product(int, LockingMode, LM_LEGACY,                                      \\\n+  product(int, LockingMode, LM_LIGHTWEIGHT,                                 \\\n@@ -2033,2 +2029,2 @@\n-          \"1: monitors & legacy stack-locking (LM_LEGACY, default), \"       \\\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT)\")         \\\n+          \"1: monitors & legacy stack-locking (LM_LEGACY), \"                \\\n+          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT, default)\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -1680,2 +1680,2 @@\n-    SuspendibleThreadSet::synchronize();\n-    SuspendibleThreadSet::desynchronize();\n+    Universe::heap()->safepoint_synchronize_begin();\n+    Universe::heap()->safepoint_synchronize_end();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+#ifdef LINUX\n+#include \"os_linux.hpp\"\n+#endif\n@@ -730,0 +733,1 @@\n+  int get_fd() const                           { return _writer->get_fd(); }\n@@ -2024,0 +2028,1 @@\n+  void set_error(const char* msg);\n@@ -2047,0 +2052,49 @@\n+void DumpMerger::set_error(const char* msg) {\n+  assert(msg != nullptr, \"sanity check\");\n+  log_error(heapdump)(\"%s (file: %s)\", msg, _path);\n+  _writer->set_error(msg);\n+  _has_error = true;\n+}\n+\n+#ifdef LINUX\n+\/\/ Merge segmented heap files via sendfile, it's more efficient than the\n+\/\/ read+write combination, which would require transferring data to and from\n+\/\/ user space.\n+void DumpMerger::merge_file(char* path) {\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"merging happens outside safepoint\");\n+  TraceTime timer(\"Merge segmented heap file directly\", TRACETIME_LOG(Info, heapdump));\n+\n+  int segment_fd = os::open(path, O_RDONLY, 0);\n+  if (segment_fd == -1) {\n+    set_error(\"Can not open segmented heap file during merging\");\n+    return;\n+  }\n+\n+  struct stat st;\n+  if (os::stat(path, &st) != 0) {\n+    ::close(segment_fd);\n+    set_error(\"Can not get segmented heap file size during merging\");\n+    return;\n+  }\n+\n+  \/\/ A successful call to sendfile may write fewer bytes than requested; the\n+  \/\/ caller should be prepared to retry the call if there were unsent bytes.\n+  jlong offset = 0;\n+  while (offset < st.st_size) {\n+    int ret = os::Linux::sendfile(_writer->get_fd(), segment_fd, &offset, st.st_size);\n+    if (ret == -1) {\n+      ::close(segment_fd);\n+      set_error(\"Failed to merge segmented heap file\");\n+      return;\n+    }\n+  }\n+\n+  \/\/ As sendfile variant does not call the write method of the global writer,\n+  \/\/ bytes_written is also incorrect for this variant, we need to explicitly\n+  \/\/ accumulate bytes_written for the global writer in this case\n+  julong accum = _writer->bytes_written() + st.st_size;\n+  _writer->set_bytes_written(accum);\n+  ::close(segment_fd);\n+}\n+#else\n+\/\/ Generic implementation using read+write\n@@ -2053,3 +2107,1 @@\n-    log_error(heapdump)(\"Can not open segmented heap file %s during merging\", path);\n-    _writer->set_error(\"Can not open segmented heap file during merging\");\n-    _has_error = true;\n+    set_error(\"Can not open segmented heap file during merging\");\n@@ -2069,4 +2121,1 @@\n-    log_error(heapdump)(\"Merged heap dump %s is incomplete, expect %ld but read \" JLONG_FORMAT \" bytes\",\n-                        path, segment_fs.fileSize(), total);\n-    _writer->set_error(\"Merged heap dump is incomplete\");\n-    _has_error = true;\n+    set_error(\"Merged heap dump is incomplete\");\n@@ -2075,0 +2124,1 @@\n+#endif\n@@ -2085,1 +2135,2 @@\n-  \/\/ merge segmented heap file and remove it anyway\n+  \/\/ Merge the content of the remaining files into base file. Regardless of whether\n+  \/\/ the merge process is successful or not, these segmented files will be deleted.\n@@ -2093,0 +2144,1 @@\n+    \/\/ Delete selected segmented heap file nevertheless\n@@ -2512,0 +2564,1 @@\n+  \/\/ share global compressor, local DumpWriter is not responsible for its life cycle\n@@ -2765,0 +2818,3 @@\n+  if (compressor != nullptr) {\n+    delete compressor;\n+  }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":64,"deletions":8,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1055,6 +1055,6 @@\n-                        if (cause instanceof InstantiationException)\n-                            throw (InstantiationException) cause;\n-                        if (cause instanceof InvocationTargetException)\n-                            throw (InvocationTargetException) cause;\n-                        if (cause instanceof IllegalAccessException)\n-                            throw (IllegalAccessException) cause;\n+                        if (cause instanceof InstantiationException ie)\n+                            throw ie;\n+                        if (cause instanceof InvocationTargetException ite)\n+                            throw ite;\n+                        if (cause instanceof IllegalAccessException iae)\n+                            throw iae;\n@@ -1068,0 +1068,6 @@\n+            } catch (InvocationTargetException ex) {\n+                Throwable cause = ex.getCause();\n+                if (cause instanceof Error err)\n+                    throw err;\n+                else\n+                    throw ex;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-            return makeAllocator(member);\n+            return makeAllocator(member.getDeclaringClass(), member);\n@@ -136,1 +136,1 @@\n-    private static DirectMethodHandle makeAllocator(MemberName ctor) {\n+    static DirectMethodHandle makeAllocator(Class<?> instanceClass, MemberName ctor) {\n@@ -138,2 +138,0 @@\n-\n-        Class<?> instanceClass = ctor.getDeclaringClass();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1656,0 +1656,6 @@\n+\n+            @Override\n+            public MethodHandle serializableConstructor(Class<?> decl, Constructor<?> ctorToCall) throws IllegalAccessException {\n+                return IMPL_LOOKUP.serializableConstructor(decl, ctorToCall);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3545,0 +3545,27 @@\n+        \/*\n+         * Produces a method handle that is capable of creating instances of the given class\n+         * and instantiated by the given constructor.  No security manager check.\n+         *\n+         * This method should only be used by ReflectionFactory::newConstructorForSerialization.\n+         *\/\n+        \/* package-private *\/ MethodHandle serializableConstructor(Class<?> decl, Constructor<?> c) throws IllegalAccessException {\n+            MemberName ctor = new MemberName(c);\n+            assert(ctor.isObjectConstructor() && constructorInSuperclass(decl, c));\n+            checkAccess(REF_newInvokeSpecial, decl, ctor);\n+            assert(!MethodHandleNatives.isCallerSensitive(ctor));  \/\/ maybeBindCaller not relevant here\n+            return DirectMethodHandle.makeAllocator(decl, ctor).setVarargs(ctor);\n+        }\n+\n+        private static boolean constructorInSuperclass(Class<?> decl, Constructor<?> ctor) {\n+            if (decl == ctor.getDeclaringClass())\n+                return true;\n+\n+            Class<?> cl = decl;\n+            while ((cl = cl.getSuperclass()) != null) {\n+                if (cl == ctor.getDeclaringClass()) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -171,0 +171,8 @@\n+\n+    \/**\n+     * Returns a method handle that allocates an instance of the given class\n+     * and then invoke the given constructor of one of its superclasses.\n+     *\n+     * This method should only be used by ReflectionFactory::newConstructorForSerialization.\n+     *\/\n+    MethodHandle serializableConstructor(Class<?> decl, Constructor<?> ctorToCall) throws IllegalAccessException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.internal.classfile.attribute.PreloadAttribute;\n@@ -87,1 +88,1 @@\n-                PermittedSubclassesAttribute,\n+                PermittedSubclassesAttribute, PreloadAttribute,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Attribute.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import jdk.internal.classfile.attribute.PreloadAttribute;\n@@ -164,0 +165,3 @@\n+    \/** Preload *\/\n+    public static final String NAME_PRELOAD = \"Preload\";\n+\n@@ -218,0 +222,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -232,0 +241,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -254,0 +268,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.LABELS;\n+                }\n@@ -268,0 +287,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -283,0 +307,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -297,0 +326,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -311,0 +345,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.STATELESS;\n+                }\n@@ -326,0 +365,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -340,0 +384,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -361,0 +410,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -380,0 +434,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.LABELS;\n+                }\n@@ -402,0 +461,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.LABELS;\n+                }\n@@ -424,0 +488,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.LABELS;\n+                }\n@@ -443,0 +512,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -448,4 +522,4 @@\n-        @Override\n-        public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n-            return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n-        }\n+                @Override\n+                public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundModuleAttribute(cf, this, p);\n+                }\n@@ -453,31 +527,36 @@\n-        @Override\n-        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n-            buf.writeIndex(attr.moduleName());\n-            buf.writeU2(attr.moduleFlagsMask());\n-            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n-            buf.writeU2(attr.requires().size());\n-            for (ModuleRequireInfo require : attr.requires()) {\n-                buf.writeIndex(require.requires());\n-                buf.writeU2(require.requiresFlagsMask());\n-                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n-            }\n-            buf.writeU2(attr.exports().size());\n-            for (ModuleExportInfo export : attr.exports()) {\n-                buf.writeIndex(export.exportedPackage());\n-                buf.writeU2(export.exportsFlagsMask());\n-                buf.writeListIndices(export.exportsTo());\n-            }\n-            buf.writeU2(attr.opens().size());\n-            for (ModuleOpenInfo open : attr.opens()) {\n-                buf.writeIndex(open.openedPackage());\n-                buf.writeU2(open.opensFlagsMask());\n-                buf.writeListIndices(open.opensTo());\n-            }\n-            buf.writeListIndices(attr.uses());\n-            buf.writeU2(attr.provides().size());\n-            for (ModuleProvideInfo provide : attr.provides()) {\n-                buf.writeIndex(provide.provides());\n-                buf.writeListIndices(provide.providesWith());\n-            }\n-        }\n-    };\n+                @Override\n+                protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n+                    buf.writeIndex(attr.moduleName());\n+                    buf.writeU2(attr.moduleFlagsMask());\n+                    buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+                    buf.writeU2(attr.requires().size());\n+                    for (ModuleRequireInfo require : attr.requires()) {\n+                        buf.writeIndex(require.requires());\n+                        buf.writeU2(require.requiresFlagsMask());\n+                        buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+                    }\n+                    buf.writeU2(attr.exports().size());\n+                    for (ModuleExportInfo export : attr.exports()) {\n+                        buf.writeIndex(export.exportedPackage());\n+                        buf.writeU2(export.exportsFlagsMask());\n+                        buf.writeListIndices(export.exportsTo());\n+                    }\n+                    buf.writeU2(attr.opens().size());\n+                    for (ModuleOpenInfo open : attr.opens()) {\n+                        buf.writeIndex(open.openedPackage());\n+                        buf.writeU2(open.opensFlagsMask());\n+                        buf.writeListIndices(open.opensTo());\n+                    }\n+                    buf.writeListIndices(attr.uses());\n+                    buf.writeU2(attr.provides().size());\n+                    for (ModuleProvideInfo provide : attr.provides()) {\n+                        buf.writeIndex(provide.provides());\n+                        buf.writeListIndices(provide.providesWith());\n+                    }\n+                }\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n+            };\n@@ -504,0 +583,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -518,0 +602,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -532,0 +621,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -546,0 +640,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.STATELESS;\n+                }\n@@ -560,0 +659,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -574,0 +678,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -588,0 +697,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -602,0 +716,24 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code Preload} attribute *\/\n+    public static final AttributeMapper<PreloadAttribute>\n+            PRELOAD = new AbstractAttributeMapper<>(NAME_PRELOAD, Classfile.JAVA_21_VERSION) {\n+                @Override\n+                public PreloadAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundPreloadAttribute(cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, PreloadAttribute attr) {\n+                    buf.writeListIndices(attr.preloads());\n+                }\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -622,0 +760,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -636,1 +779,6 @@\n-    };\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n+            };\n@@ -653,0 +801,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -667,0 +820,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.UNSTABLE;\n+                }\n@@ -672,4 +830,4 @@\n-        @Override\n-        public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n-            return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n-        }\n+                @Override\n+                public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+                    return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n+                }\n@@ -677,5 +835,10 @@\n-        @Override\n-        protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n-            buf.writeList(attr.annotations());\n-        }\n-    };\n+                @Override\n+                protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n+                    buf.writeList(attr.annotations());\n+                }\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n+            };\n@@ -698,0 +861,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -712,0 +880,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.UNSTABLE;\n+                }\n@@ -726,0 +899,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -740,0 +918,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.STATELESS;\n+                }\n@@ -754,0 +937,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -768,0 +956,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.CP_REFS;\n+                }\n@@ -782,0 +975,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.LABELS;\n+                }\n@@ -797,0 +995,5 @@\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return AttributeStability.STATELESS;\n+                }\n@@ -835,0 +1038,1 @@\n+            PRELOAD,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Attributes.java","additions":249,"deletions":45,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.classfile.attribute.PreloadAttribute;\n@@ -63,1 +64,1 @@\n-                NestHostAttribute, NestMembersAttribute, PermittedSubclassesAttribute,\n+                NestHostAttribute, NestMembersAttribute, PermittedSubclassesAttribute, PreloadAttribute,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassElement.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -244,3 +244,5 @@\n-     * Option describing whether to process or discard unrecognized attributes.\n-     * Default is {@code PASS_UNKNOWN_ATTRIBUTES} to process unrecognized\n-     * attributes, and deliver as instances of {@link UnknownAttribute}.\n+     * Option describing whether to process or discard unrecognized or problematic\n+     * original attributes when a class, record component, field, method or code is\n+     * transformed in its exploded form.\n+     * Default is {@code PASS_ALL_ATTRIBUTES} to process all original attributes.\n+     * @see AttributeMapper.AttributeStability\n@@ -248,1 +250,1 @@\n-    enum UnknownAttributesOption implements Option {\n+    enum AttributesProcessingOption implements Option {\n@@ -250,2 +252,2 @@\n-        \/** Process unknown attributes *\/\n-        PASS_UNKNOWN_ATTRIBUTES,\n+        \/** Process all original attributes during transformation *\/\n+        PASS_ALL_ATTRIBUTES,\n@@ -253,2 +255,5 @@\n-        \/** Drop unknown attributes *\/\n-        DROP_UNKNOWN_ATTRIBUTES\n+        \/** Drop unknown attributes during transformation *\/\n+        DROP_UNKNOWN_ATTRIBUTES,\n+\n+        \/** Drop unknown and unstable original attributes during transformation *\/\n+        DROP_UNSTABLE_ATRIBUTES;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public sealed interface PreloadAttribute\n+        extends Attribute<PreloadAttribute>, ClassElement\n+        permits BoundAttribute.BoundPreloadAttribute, UnboundAttribute.UnboundPreloadAttribute {\n+\n+    \/**\n+     * {@return the list of preload classes}\n+     *\/\n+    List<ClassEntry> preloads();\n+\n+    \/**\n+     * {@return a {@code Preload} attribute}\n+     * @param preloads the preload classes\n+     *\/\n+    static PreloadAttribute of(List<ClassEntry> preloads) {\n+        return new UnboundAttribute.UnboundPreloadAttribute(preloads);\n+    }\n+\n+    \/**\n+     * {@return a {@code Preload} attribute}\n+     * @param preloads the preload classes\n+     *\/\n+    static PreloadAttribute of(ClassEntry... preloads) {\n+        return of(List.of(preloads));\n+    }\n+\n+    \/**\n+     * {@return a {@code Preload} attribute}\n+     * @param preloads the preload classes\n+     *\/\n+    static PreloadAttribute ofSymbols(List<ClassDesc> preloads) {\n+        return of(Util.entryList(preloads));\n+    }\n+\n+    \/**\n+     * {@return a {@code Preload} attribute}\n+     * @param preloads the preload classes\n+     *\/\n+    static PreloadAttribute ofSymbols(ClassDesc... preloads) {\n+        return ofSymbols(Arrays.asList(preloads));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/PreloadAttribute.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Collections;\n@@ -124,1 +125,1 @@\n-        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(entries);\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(entries);\n@@ -130,1 +131,1 @@\n-        var filled = new Object[size];\n+        var filled = new ArrayList<Attribute<?>>(size);\n@@ -133,0 +134,1 @@\n+        var apo = ((ClassReaderImpl)reader).context().attributesProcessingOption();\n@@ -146,2 +148,2 @@\n-                filled[i] = mapper.readAttribute(enclosing, reader, p);\n-            } else if (((ClassReaderImpl)reader).context().unknownAttributesOption() == Classfile.UnknownAttributesOption.PASS_UNKNOWN_ATTRIBUTES) {\n+                filled.add((Attribute)mapper.readAttribute(enclosing, reader, p));\n+            } else {\n@@ -162,1 +164,4 @@\n-                        throw new UnsupportedOperationException(\"Write of unknown attribute \" + name() + \" not supported\");\n+                        buf.writeIndex(name);\n+                        var cont = attr.contents();\n+                        buf.writeInt(cont.length);\n+                        buf.writeBytes(cont);\n@@ -169,0 +174,5 @@\n+\n+                    @Override\n+                    public AttributeMapper.AttributeStability stability() {\n+                        return AttributeStability.UNKNOWN;\n+                    }\n@@ -170,1 +180,1 @@\n-                filled[i] = new BoundUnknownAttribute(reader, fakeMapper, p);\n+                filled.add(new BoundUnknownAttribute(reader, fakeMapper, p));\n@@ -174,1 +184,1 @@\n-        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(filled);\n+        return Collections.unmodifiableList(filled);\n@@ -182,29 +192,0 @@\n-\n-        @Override\n-        public void writeTo(DirectClassBuilder builder) {\n-            checkWriteSupported(builder::canWriteDirect);\n-            super.writeTo(builder);\n-        }\n-\n-        @Override\n-        public void writeTo(DirectMethodBuilder builder) {\n-            checkWriteSupported(builder::canWriteDirect);\n-            super.writeTo(builder);\n-        }\n-\n-        @Override\n-        public void writeTo(DirectFieldBuilder builder) {\n-            checkWriteSupported(builder::canWriteDirect);\n-            super.writeTo(builder);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriter buf) {\n-            checkWriteSupported(buf::canWriteDirect);\n-            super.writeTo(buf);\n-        }\n-\n-        private void checkWriteSupported(Function<ConstantPool, Boolean> condition) {\n-            if (!condition.apply(classReader))\n-                throw new UnsupportedOperationException(\"Write of unknown attribute \" + attributeName() + \" not supported to alien constant pool\");\n-        }\n@@ -505,1 +486,1 @@\n-            return (ConstantValueEntry) classReader.readEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ConstantValueEntry.class);\n@@ -957,0 +938,17 @@\n+    public static final class BoundPreloadAttribute extends BoundAttribute<PreloadAttribute>\n+            implements PreloadAttribute {\n+        private List<ClassEntry> preloads = null;\n+\n+        public BoundPreloadAttribute(ClassReader cf, AttributeMapper<PreloadAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> preloads() {\n+            if (preloads == null) {\n+                preloads = readEntryList(payloadStart);\n+            }\n+            return preloads;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":35,"deletions":37,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -573,3 +573,2 @@\n-            for (int i = 1; i < cp.entryCount();) {\n-                var e = cp.entryByIndex(i);\n-                cpNode.with(new MapNodeImpl(FLOW, i)\n+            for (PoolEntry e : cp) {\n+                cpNode.with(new MapNodeImpl(FLOW, e.index())\n@@ -640,1 +639,0 @@\n-                i += e.width();\n@@ -906,0 +904,3 @@\n+                case PreloadAttribute pa ->\n+                    nodes.add(list(\"preload classes\", \"class\", pa.preloads().stream()\n+                            .map(e -> e.name().stringValue())));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.classfile.attribute.PreloadAttribute;\n@@ -145,0 +146,4 @@\n+            case PreloadAttribute pa ->\n+                clb.with(PreloadAttribute.ofSymbols(\n+                        pa.preloads().stream().map(pc ->\n+                                map(pc.asSymbol())).toList()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+import jdk.internal.classfile.attribute.PreloadAttribute;\n@@ -432,0 +433,16 @@\n+    public static final class UnboundPreloadAttribute\n+            extends UnboundAttribute<PreloadAttribute>\n+            implements PreloadAttribute {\n+        private final List<ClassEntry> preloads;\n+\n+        public UnboundPreloadAttribute(List<ClassEntry> preloads) {\n+            super(Attributes.PRELOAD);\n+            this.preloads = List.copyOf(preloads);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> preloads() {\n+            return preloads;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -408,0 +408,1 @@\n+ *     | PreloadAttribute?(List<ClassEntry> preloads)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/package-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -383,3 +383,1 @@\n-\n-        ConstructorAccessor acc = new SerializationConstructorAccessorGenerator().\n-            generateSerializationConstructor(cl,\n+        Constructor<?> ctor = newConstructor(constructorToCall.getDeclaringClass(),\n@@ -387,0 +385,1 @@\n+                                             constructorToCall.getExceptionTypes(),\n@@ -388,16 +387,17 @@\n-                                             constructorToCall.getDeclaringClass());\n-        Constructor<?> c = newConstructor(constructorToCall.getDeclaringClass(),\n-                                          constructorToCall.getParameterTypes(),\n-                                          constructorToCall.getExceptionTypes(),\n-                                          constructorToCall.getModifiers(),\n-                                          langReflectAccess.\n-                                          getConstructorSlot(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorSignature(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorAnnotations(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorParameterAnnotations(constructorToCall));\n-        setConstructorAccessor(c, acc);\n-        c.setAccessible(true);\n-        return c;\n+                                             langReflectAccess.getConstructorSlot(constructorToCall),\n+                                             langReflectAccess.getConstructorSignature(constructorToCall),\n+                                             langReflectAccess.getConstructorAnnotations(constructorToCall),\n+                                             langReflectAccess.getConstructorParameterAnnotations(constructorToCall));\n+        ConstructorAccessor acc;\n+        if (useOldSerializableConstructor()) {\n+            acc = new SerializationConstructorAccessorGenerator().\n+                                generateSerializationConstructor(cl,\n+                                                                 constructorToCall.getParameterTypes(),\n+                                                                 constructorToCall.getModifiers(),\n+                                                                 constructorToCall.getDeclaringClass());\n+        } else {\n+            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, ctor);\n+        }\n+        setConstructorAccessor(ctor, acc);\n+        ctor.setAccessible(true);\n+        return ctor;\n@@ -561,0 +561,4 @@\n+    static boolean useOldSerializableConstructor() {\n+        return config().useOldSerializableConstructor;\n+    }\n+\n@@ -577,0 +581,1 @@\n+                                                            false,  \/\/ useOldSerializeableConstructor\n@@ -591,0 +596,1 @@\n+                          boolean useOldSerializableConstructor,\n@@ -614,0 +620,2 @@\n+        boolean useOldSerializableConstructor =\n+            \"true\".equals(props.getProperty(\"jdk.reflect.useOldSerializableConstructor\"));\n@@ -617,1 +625,1 @@\n-        return new Config(useNativeAccessorOnly, disableSerialConstructorChecks);\n+        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+        jdk.jdeps,\n@@ -192,0 +193,1 @@\n+        jdk.jdeps,\n@@ -195,0 +197,1 @@\n+        jdk.jdeps,\n@@ -197,0 +200,1 @@\n+        jdk.jdeps,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,10 @@\n-import java.util.Collection;\n+import java.lang.reflect.Modifier;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Locale;\n+import jdk.internal.classfile.*;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.attribute.*;\n+import static jdk.internal.classfile.Classfile.*;\n+import static jdk.internal.classfile.attribute.StackMapFrameInfo.*;\n@@ -30,54 +39,0 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.AnnotationDefault_attribute;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.CharacterRangeTable_attribute;\n-import com.sun.tools.classfile.CharacterRangeTable_attribute.Entry;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.CompilationID_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantValue_attribute;\n-import com.sun.tools.classfile.DefaultAttribute;\n-import com.sun.tools.classfile.Deprecated_attribute;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.EnclosingMethod_attribute;\n-import com.sun.tools.classfile.Exceptions_attribute;\n-import com.sun.tools.classfile.InnerClasses_attribute;\n-import com.sun.tools.classfile.InnerClasses_attribute.Info;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.LocalVariableTable_attribute;\n-import com.sun.tools.classfile.LocalVariableTypeTable_attribute;\n-import com.sun.tools.classfile.MethodParameters_attribute;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.ModuleHashes_attribute;\n-import com.sun.tools.classfile.ModuleMainClass_attribute;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n-import com.sun.tools.classfile.ModuleResolution_attribute;\n-import com.sun.tools.classfile.ModuleTarget_attribute;\n-import com.sun.tools.classfile.NestHost_attribute;\n-import com.sun.tools.classfile.NestMembers_attribute;\n-import com.sun.tools.classfile.Record_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.PermittedSubclasses_attribute;\n-import com.sun.tools.classfile.Signature_attribute;\n-import com.sun.tools.classfile.SourceDebugExtension_attribute;\n-import com.sun.tools.classfile.SourceFile_attribute;\n-import com.sun.tools.classfile.SourceID_attribute;\n-import com.sun.tools.classfile.StackMapTable_attribute;\n-import com.sun.tools.classfile.StackMap_attribute;\n-import com.sun.tools.classfile.Synthetic_attribute;\n-import com.sun.tools.classfile.Type;\n-\n-import static com.sun.tools.classfile.AccessFlags.*;\n-\n-import com.sun.tools.classfile.Preload_attribute;\n@@ -95,3 +50,2 @@\n-public class AttributeWriter extends BasicWriter\n-        implements Attribute.Visitor<Void,Void>\n-{\n+public class AttributeWriter extends BasicWriter {\n+\n@@ -114,8 +68,2 @@\n-    public void write(Object owner, Attribute attr, ConstantPool constant_pool) {\n-        if (attr != null) {\n-            Assert.checkNonNull(constant_pool);\n-            Assert.checkNonNull(owner);\n-            this.constant_pool = constant_pool;\n-            this.owner = owner;\n-            attr.accept(this, null);\n-        }\n+    public void write(List<Attribute<?>> attrs) {\n+        write(attrs, null);\n@@ -124,1 +72,1 @@\n-    public void write(Object owner, Attributes attrs, ConstantPool constant_pool) {\n+    public void write(List<Attribute<?>> attrs, CodeAttribute lr) {\n@@ -126,6 +74,5 @@\n-            Assert.checkNonNull(constant_pool);\n-            Assert.checkNonNull(owner);\n-            this.constant_pool = constant_pool;\n-            this.owner = owner;\n-            for (Attribute attr: attrs)\n-                attr.accept(this, null);\n+            for (var attr : attrs) try {\n+                write(attr, lr);\n+            } catch (IllegalArgumentException e) {\n+                report(e);\n+            }\n@@ -135,26 +82,11 @@\n-    @Override\n-    public Void visitDefault(DefaultAttribute attr, Void ignore) {\n-        byte[] data = attr.info;\n-        int i = 0;\n-        int j = 0;\n-        print(\"  \");\n-        try {\n-            print(attr.getName(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            report(e);\n-            print(\"attribute name = #\" + attr.attribute_name_index);\n-        }\n-        print(\": \");\n-        print(\"length = 0x\" + toHex(attr.info.length));\n-        if (attr.reason != null) {\n-            print(\" (\" + attr.reason + \")\");\n-        }\n-        println();\n-\n-        print(\"   \");\n-\n-        while (i < data.length) {\n-            print(toHex(data[i], 2));\n-\n-            j++;\n-            if (j == 16) {\n+    public void write(Attribute<?> a, CodeAttribute lr) {\n+        switch (a) {\n+            case UnknownAttribute attr -> {\n+                byte[] data = attr.contents();\n+                int i = 0;\n+                int j = 0;\n+                print(\"  \");\n+                print(attr.attributeName());\n+                print(\": \");\n+                print(\"length = 0x\" + toHex(data.length));\n+                print(\" (unknown attribute)\");\n@@ -163,3 +95,14 @@\n-                j = 0;\n-            } else {\n-                print(\" \");\n+                while (i < data.length) {\n+                    print(toHex(data[i], 2));\n+\n+                    j++;\n+                    if (j == 16) {\n+                        println();\n+                        print(\"   \");\n+                        j = 0;\n+                    } else {\n+                        print(\" \");\n+                    }\n+                    i++;\n+                }\n+                println();\n@@ -167,31 +110,7 @@\n-            i++;\n-        }\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitAnnotationDefault(AnnotationDefault_attribute attr, Void ignore) {\n-        println(\"AnnotationDefault:\");\n-        indent(+1);\n-        print(\"default_value: \");\n-        annotationWriter.write(attr.default_value);\n-        indent(-1);\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitBootstrapMethods(BootstrapMethods_attribute attr, Void p) {\n-        println(Attribute.BootstrapMethods + \":\");\n-        for (int i = 0; i < attr.bootstrap_method_specifiers.length ; i++) {\n-            BootstrapMethods_attribute.BootstrapMethodSpecifier bsm = attr.bootstrap_method_specifiers[i];\n-            indent(+1);\n-            print(i + \": #\" + bsm.bootstrap_method_ref + \" \");\n-            println(constantWriter.stringValue(bsm.bootstrap_method_ref));\n-            indent(+1);\n-            println(\"Method arguments:\");\n-            indent(+1);\n-            for (int j = 0; j < bsm.bootstrap_arguments.length; j++) {\n-                print(\"#\" + bsm.bootstrap_arguments[j] + \" \");\n-                println(constantWriter.stringValue(bsm.bootstrap_arguments[j]));\n+            case AnnotationDefaultAttribute attr -> {\n+                println(\"AnnotationDefault:\");\n+                indent(+1);\n+                print(\"default_value: \");\n+                annotationWriter.write(attr.defaultValue());\n+                indent(-1);\n+                println();\n@@ -199,119 +118,183 @@\n-            indent(-3);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitCharacterRangeTable(CharacterRangeTable_attribute attr, Void ignore) {\n-        println(\"CharacterRangeTable:\");\n-        indent(+1);\n-        for (Entry e : attr.character_range_table) {\n-            print(String.format(\"    %2d, %2d, %6x, %6x, %4x\",\n-                    e.start_pc, e.end_pc,\n-                    e.character_range_start, e.character_range_end,\n-                    e.flags));\n-            tab();\n-            print(String.format(\"\/\/ %2d, %2d, %4d:%02d, %4d:%02d\",\n-                    e.start_pc, e.end_pc,\n-                    (e.character_range_start >> 10), (e.character_range_start & 0x3ff),\n-                    (e.character_range_end >> 10), (e.character_range_end & 0x3ff)));\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_STATEMENT) != 0)\n-                print(\", statement\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_BLOCK) != 0)\n-                print(\", block\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_ASSIGNMENT) != 0)\n-                print(\", assignment\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_FLOW_CONTROLLER) != 0)\n-                print(\", flow-controller\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_FLOW_TARGET) != 0)\n-                print(\", flow-target\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_INVOKE) != 0)\n-                print(\", invoke\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_CREATE) != 0)\n-                print(\", create\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_BRANCH_TRUE) != 0)\n-                print(\", branch-true\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_BRANCH_FALSE) != 0)\n-                print(\", branch-false\");\n-            println();\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitCode(Code_attribute attr, Void ignore) {\n-        codeWriter.write(attr, constant_pool);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitCompilationID(CompilationID_attribute attr, Void ignore) {\n-        constantWriter.write(attr.compilationID_index);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitConstantValue(ConstantValue_attribute attr, Void ignore) {\n-        print(\"ConstantValue: \");\n-        constantWriter.write(attr.constantvalue_index);\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitDeprecated(Deprecated_attribute attr, Void ignore) {\n-        println(\"Deprecated: true\");\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitEnclosingMethod(EnclosingMethod_attribute attr, Void ignore) {\n-        print(\"EnclosingMethod: #\" + attr.class_index + \".#\" + attr.method_index);\n-        tab();\n-        print(\"\/\/ \" + getJavaClassName(attr));\n-        if (attr.method_index != 0)\n-            print(\".\" + getMethodName(attr));\n-        println();\n-        return null;\n-    }\n-\n-    private String getJavaClassName(EnclosingMethod_attribute a) {\n-        try {\n-            return getJavaName(a.getClassName(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private String getMethodName(EnclosingMethod_attribute a) {\n-        try {\n-            return a.getMethodName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitExceptions(Exceptions_attribute attr, Void ignore) {\n-        println(\"Exceptions:\");\n-        indent(+1);\n-        print(\"throws \");\n-        for (int i = 0; i < attr.number_of_exceptions; i++) {\n-            if (i > 0)\n-                print(\", \");\n-            print(getJavaException(attr, i));\n-        }\n-        println();\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getJavaException(Exceptions_attribute attr, int index) {\n-        try {\n-            return getJavaName(attr.getException(index, constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n+            case BootstrapMethodsAttribute attr -> {\n+                println(\"BootstrapMethods:\");\n+                for (int i = 0; i < attr.bootstrapMethodsSize() ; i++) {\n+                    var bsm = attr.bootstrapMethods().get(i);\n+                    indent(+1);\n+                    print(i + \": #\" + bsm.bootstrapMethod().index() + \" \");\n+                    println(constantWriter.stringValue(bsm.bootstrapMethod()));\n+                    indent(+1);\n+                    println(\"Method arguments:\");\n+                    indent(+1);\n+                    for (var arg : bsm.arguments()) {\n+                        print(\"#\" + arg.index() + \" \");\n+                        println(constantWriter.stringValue(arg));\n+                    }\n+                    indent(-3);\n+                }\n+            }\n+            case CharacterRangeTableAttribute attr -> {\n+                println(\"CharacterRangeTable:\");\n+                indent(+1);\n+                for (var e : attr.characterRangeTable()) {\n+                    print(String.format(\"    %2d, %2d, %6x, %6x, %4x\",\n+                            e.startPc(), e.endPc(),\n+                            e.characterRangeStart(), e.characterRangeEnd(),\n+                            e.flags()));\n+                    tab();\n+                    print(String.format(\"\/\/ %2d, %2d, %4d:%02d, %4d:%02d\",\n+                            e.startPc(), e.endPc(),\n+                            (e.characterRangeStart() >> 10),\n+                            (e.characterRangeStart() & 0x3ff),\n+                            (e.characterRangeEnd() >> 10),\n+                            (e.characterRangeEnd() & 0x3ff)));\n+                    if ((e.flags() & CRT_STATEMENT) != 0)\n+                        print(\", statement\");\n+                    if ((e.flags() & CRT_BLOCK) != 0)\n+                        print(\", block\");\n+                    if ((e.flags() & CRT_ASSIGNMENT) != 0)\n+                        print(\", assignment\");\n+                    if ((e.flags() & CRT_FLOW_CONTROLLER) != 0)\n+                        print(\", flow-controller\");\n+                    if ((e.flags() & CRT_FLOW_TARGET) != 0)\n+                        print(\", flow-target\");\n+                    if ((e.flags() & CRT_INVOKE) != 0)\n+                        print(\", invoke\");\n+                    if ((e.flags() & CRT_CREATE) != 0)\n+                        print(\", create\");\n+                    if ((e.flags() & CRT_BRANCH_TRUE) != 0)\n+                        print(\", branch-true\");\n+                    if ((e.flags() & CRT_BRANCH_FALSE) != 0)\n+                        print(\", branch-false\");\n+                    println();\n+                }\n+                indent(-1);\n+            }\n+            case CodeAttribute attr -> codeWriter.write(attr);\n+            case CompilationIDAttribute attr ->\n+                constantWriter.write(attr.compilationId().index());\n+            case ConstantValueAttribute attr -> {\n+                print(\"ConstantValue: \");\n+                constantWriter.write(attr.constant().index());\n+                println();\n+            }\n+            case DeprecatedAttribute attr -> println(\"Deprecated: true\");\n+            case EnclosingMethodAttribute attr -> {\n+                print(\"EnclosingMethod: #\" + attr.enclosingClass().index() + \".#\"\n+                        +  attr.enclosingMethod().map(PoolEntry::index).orElse(0));\n+                tab();\n+                print(\"\/\/ \" + getJavaName(attr.enclosingClass().asInternalName()));\n+                if (attr.enclosingMethod().isPresent())\n+                    print(\".\" + attr.enclosingMethod().get().name().stringValue());\n+                println();\n+            }\n+            case ExceptionsAttribute attr -> {\n+                println(\"Exceptions:\");\n+                indent(+1);\n+                print(\"throws \");\n+                var exc = attr.exceptions();\n+                for (int i = 0; i < exc.size(); i++) {\n+                    if (i > 0)\n+                        print(\", \");\n+                    print(getJavaName(exc.get(i).asInternalName()));\n+                }\n+                println();\n+                indent(-1);\n+            }\n+            case InnerClassesAttribute attr -> {\n+                boolean first = true;\n+                for (var info : attr.classes()) {\n+                    \/\/access\n+                    int access_flags = info.flagsMask();\n+                    if (options.checkAccess(access_flags)) {\n+                        if (first) {\n+                            println(\"InnerClasses:\");\n+                            indent(+1);\n+                            first = false;\n+                        }\n+                        for (var flag : info.flags()) {\n+                            if (flag.sourceModifier() && (flag != AccessFlag.ABSTRACT\n+                                    || !info.has(AccessFlag.INTERFACE))) {\n+                                print(Modifier.toString(flag.mask()) + \" \");\n+                            }\n+                        }\n+                        if (info.innerName().isPresent()) {\n+                            print(\"#\" + info.innerName().get().index() + \"= \");\n+                        }\n+                        print(\"#\" + info.innerClass().index());\n+                        if (info.outerClass().isPresent()) {\n+                            print(\" of #\" + info.outerClass().get().index());\n+                        }\n+                        print(\";\");\n+                        tab();\n+                        print(\"\/\/ \");\n+                        if (info.innerName().isPresent()) {\n+                            print(info.innerName().get().stringValue() + \"=\");\n+                        }\n+                        constantWriter.write(info.innerClass().index());\n+                        if (info.outerClass().isPresent()) {\n+                            print(\" of \");\n+                            constantWriter.write(info.outerClass().get().index());\n+                        }\n+                        println();\n+                    }\n+                }\n+                if (!first)\n+                    indent(-1);\n+            }\n+            case LineNumberTableAttribute attr -> {\n+                println(\"LineNumberTable:\");\n+                indent(+1);\n+                for (var entry: attr.lineNumbers()) {\n+                    println(\"line \" + entry.lineNumber() + \": \" + entry.startPc());\n+                }\n+                indent(-1);\n+            }\n+            case LocalVariableTableAttribute attr -> {\n+                println(\"LocalVariableTable:\");\n+                indent(+1);\n+                println(\"Start  Length  Slot  Name   Signature\");\n+                for (var entry : attr.localVariables()) {\n+                    println(String.format(\"%5d %7d %5d %5s   %s\",\n+                            entry.startPc(), entry.length(), entry.slot(),\n+                            constantWriter.stringValue(entry.name()),\n+                            constantWriter.stringValue(entry.type())));\n+                }\n+                indent(-1);\n+            }\n+            case LocalVariableTypeTableAttribute attr -> {\n+                println(\"LocalVariableTypeTable:\");\n+                indent(+1);\n+                println(\"Start  Length  Slot  Name   Signature\");\n+                for (var entry : attr.localVariableTypes()) {\n+                    println(String.format(\"%5d %7d %5d %5s   %s\",\n+                            entry.startPc(), entry.length(), entry.slot(),\n+                            constantWriter.stringValue(entry.name()),\n+                            constantWriter.stringValue(entry.signature())));\n+                }\n+                indent(-1);\n+            }\n+            case NestHostAttribute attr -> {\n+                print(\"NestHost: \");\n+                constantWriter.write(attr.nestHost().index());\n+                println();\n+            }\n+            case MethodParametersAttribute attr -> {\n+                final String header = String.format(format, \"Name\", \"Flags\");\n+                println(\"MethodParameters:\");\n+                indent(+1);\n+                println(header);\n+                for (var entry : attr.parameters()) {\n+                    String namestr =\n+                        entry.name().isPresent() ?\n+                        constantWriter.stringValue(entry.name().get()) : \"<no name>\";\n+                    String flagstr =\n+                        (entry.has(AccessFlag.FINAL) ? \"final \" : \"\") +\n+                        (entry.has(AccessFlag.MANDATED) ? \"mandated \" : \"\") +\n+                        (entry.has(AccessFlag.SYNTHETIC) ? \"synthetic\" : \"\");\n+                    println(String.format(format, namestr, flagstr));\n+                }\n+                indent(-1);\n+            }\n+            case ModuleAttribute attr -> {\n+                println(\"Module:\");\n+                indent(+1);\n@@ -319,10 +302,48 @@\n-    @Override\n-    public Void visitInnerClasses(InnerClasses_attribute attr, Void ignore) {\n-        boolean first = true;\n-        for (Info info : attr.classes) {\n-            \/\/access\n-            AccessFlags access_flags = info.inner_class_access_flags;\n-            if (options.checkAccess(access_flags)) {\n-                if (first) {\n-                    writeInnerClassHeader();\n-                    first = false;\n+                print(\"#\" + attr.moduleName().index());\n+                print(\",\");\n+                print(String.format(\"%x\", attr.moduleFlagsMask()));\n+                tab();\n+                print(\"\/\/ \" + constantWriter.stringValue(attr.moduleName()));\n+                if (attr.has(AccessFlag.OPEN))\n+                    print(\" ACC_OPEN\");\n+                if (attr.has(AccessFlag.MANDATED))\n+                    print(\" ACC_MANDATED\");\n+                if (attr.has(AccessFlag.SYNTHETIC))\n+                    print(\" ACC_SYNTHETIC\");\n+                println();\n+                var ver = attr.moduleVersion();\n+                print(\"#\" + ver.map(Utf8Entry::index).orElse(0));\n+                if (ver.isPresent()) {\n+                    tab();\n+                    print(\"\/\/ \" + constantWriter.stringValue(ver.get()));\n+                }\n+                println();\n+                {\n+                    var entries = attr.requires();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ \" + \"requires\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        print(\"#\" + e.requires().index() + \",\"\n+                                + String.format(\"%x\", e.requiresFlagsMask()));\n+                        tab();\n+                        print(\"\/\/ \" + constantWriter.stringValue(e.requires()));\n+                        if (e.has(AccessFlag.TRANSITIVE))\n+                            print(\" ACC_TRANSITIVE\");\n+                        if (e.has(AccessFlag.STATIC_PHASE))\n+                            print(\" ACC_STATIC_PHASE\");\n+                        if (e.has(AccessFlag.SYNTHETIC))\n+                            print(\" ACC_SYNTHETIC\");\n+                        if (e.has(AccessFlag.MANDATED))\n+                            print(\" ACC_MANDATED\");\n+                        println();\n+                        var reqVer = e.requiresVersion();\n+                        print(\"#\" + reqVer.map(Utf8Entry::index).orElse(0));\n+                        if (reqVer.isPresent()) {\n+                            tab();\n+                            print(\"\/\/ \" + constantWriter.stringValue(reqVer.get()));\n+                        }\n+                        println();\n+                    }\n+                    indent(-1);\n@@ -330,4 +351,11 @@\n-                for (String name: access_flags.getInnerClassModifiers())\n-                    print(name + \" \");\n-                if (info.inner_name_index != 0) {\n-                    print(\"#\" + info.inner_name_index + \"= \");\n+                {\n+                    var entries = attr.exports();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ exports\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        printExportOpenEntry(e.exportedPackage().index(),\n+                                e.exportsFlagsMask(), e.exportsTo());\n+                    }\n+                    indent(-1);\n@@ -335,3 +363,11 @@\n-                print(\"#\" + info.inner_class_info_index);\n-                if (info.outer_class_info_index != 0) {\n-                    print(\" of #\" + info.outer_class_info_index);\n+                {\n+                    var entries = attr.opens();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ opens\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        printExportOpenEntry(e.openedPackage().index(),\n+                                e.opensFlagsMask(), e.opensTo());\n+                    }\n+                    indent(-1);\n@@ -339,1 +375,41 @@\n-                print(\";\");\n+                {\n+                    var entries = attr.uses();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ \" + \"uses\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        print(\"#\" + e.index());\n+                        tab();\n+                        println(\"\/\/ \" + constantWriter.stringValue(e));\n+                    }\n+                    indent(-1);\n+                }\n+                {\n+                    var entries = attr.provides();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ \" + \"provides\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        print(\"#\" + e.provides().index());\n+                        tab();\n+                        print(\"\/\/ \");\n+                        print(constantWriter.stringValue(e.provides()));\n+                        println(\" with ... \" + e.providesWith().size());\n+                        indent(+1);\n+                        for (var with : e.providesWith()) {\n+                            print(\"#\" + with.index());\n+                            tab();\n+                            println(\"\/\/ ... with \" + constantWriter.stringValue(with));\n+                        }\n+                        indent(-1);\n+                    }\n+                    indent(-1);\n+                }\n+                indent(-1);\n+            }\n+            case ModuleHashesAttribute attr -> {\n+                println(\"ModuleHashes:\");\n+                indent(+1);\n+                print(\"algorithm: #\" + attr.algorithm().index());\n@@ -341,3 +417,10 @@\n-                print(\"\/\/ \");\n-                if (info.inner_name_index != 0) {\n-                    print(getInnerName(constant_pool, info) + \"=\");\n+                println(\"\/\/ \" + attr.algorithm().stringValue());\n+                print(attr.hashes().size());\n+                tab();\n+                println(\"\/\/ hashes\");\n+                for (var e : attr.hashes()) {\n+                    print(\"#\" + e.moduleName().index());\n+                    tab();\n+                    println(\"\/\/ \" + e.moduleName().name().stringValue());\n+                    println(\"hash_length: \" + e.hash().length);\n+                    println(\"hash: [\" + toHex(e.hash()) + \"]\");\n@@ -345,4 +428,15 @@\n-                constantWriter.write(info.inner_class_info_index);\n-                if (info.outer_class_info_index != 0) {\n-                    print(\" of \");\n-                    constantWriter.write(info.outer_class_info_index);\n+                indent(-1);\n+            }\n+            case ModuleMainClassAttribute attr -> {\n+                print(\"ModuleMainClass: #\" + attr.mainClass().index());\n+                tab();\n+                print(\"\/\/ \" + getJavaName(attr.mainClass().asInternalName()));\n+                println();\n+            }\n+            case ModulePackagesAttribute attr -> {\n+                println(\"ModulePackages: \");\n+                indent(+1);\n+                for (var p : attr.packages()) {\n+                    print(\"#\" + p.index());\n+                    tab();\n+                    println(\"\/\/ \" + getJavaName(p.name().stringValue()));\n@@ -350,0 +444,17 @@\n+                indent(-1);\n+            }\n+            case ModuleResolutionAttribute attr -> {\n+                println(\"ModuleResolution:\");\n+                indent(+1);\n+                print(String.format(\"%x\", attr.resolutionFlags()));\n+                tab();\n+                print(\"\/\/ \");\n+                int flags = attr.resolutionFlags();\n+                if ((flags & DO_NOT_RESOLVE_BY_DEFAULT) != 0)\n+                    print(\" DO_NOT_RESOLVE_BY_DEFAULT\");\n+                if ((flags & WARN_DEPRECATED) != 0)\n+                    print(\" WARN_DEPRECATED\");\n+                if ((flags & WARN_DEPRECATED_FOR_REMOVAL) != 0)\n+                    print(\" WARN_DEPRECATED_FOR_REMOVAL\");\n+                if ((flags & WARN_INCUBATING) != 0)\n+                    print(\" WARN_INCUBATING\");\n@@ -351,0 +462,1 @@\n+                indent(-1);\n@@ -352,154 +464,4 @@\n-        }\n-        if (!first)\n-            indent(-1);\n-        return null;\n-    }\n-\n-    String getInnerName(ConstantPool constant_pool, InnerClasses_attribute.Info info) {\n-        try {\n-            return info.getInnerName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private void writeInnerClassHeader() {\n-        println(\"InnerClasses:\");\n-        indent(+1);\n-    }\n-\n-    @Override\n-    public Void visitLineNumberTable(LineNumberTable_attribute attr, Void ignore) {\n-        println(\"LineNumberTable:\");\n-        indent(+1);\n-        for (LineNumberTable_attribute.Entry entry: attr.line_number_table) {\n-            println(\"line \" + entry.line_number + \": \" + entry.start_pc);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitLocalVariableTable(LocalVariableTable_attribute attr, Void ignore) {\n-        println(\"LocalVariableTable:\");\n-        indent(+1);\n-        println(\"Start  Length  Slot  Name   Signature\");\n-        for (LocalVariableTable_attribute.Entry entry : attr.local_variable_table) {\n-            println(String.format(\"%5d %7d %5d %5s   %s\",\n-                    entry.start_pc, entry.length, entry.index,\n-                    constantWriter.stringValue(entry.name_index),\n-                    constantWriter.stringValue(entry.descriptor_index)));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitLocalVariableTypeTable(LocalVariableTypeTable_attribute attr, Void ignore) {\n-        println(\"LocalVariableTypeTable:\");\n-        indent(+1);\n-        println(\"Start  Length  Slot  Name   Signature\");\n-        for (LocalVariableTypeTable_attribute.Entry entry : attr.local_variable_table) {\n-            println(String.format(\"%5d %7d %5d %5s   %s\",\n-                    entry.start_pc, entry.length, entry.index,\n-                    constantWriter.stringValue(entry.name_index),\n-                    constantWriter.stringValue(entry.signature_index)));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitNestHost(NestHost_attribute attr, Void aVoid) {\n-        print(\"NestHost: \");\n-        constantWriter.write(attr.top_index);\n-        println();\n-        return null;\n-    }\n-\n-    private String getJavaClassName(ModuleMainClass_attribute a) {\n-        try {\n-            return getJavaName(a.getMainClassName(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private static final String format = \"%-31s%s\";\n-\n-    @Override\n-    public Void visitMethodParameters(MethodParameters_attribute attr,\n-                                      Void ignore) {\n-        final String header = String.format(format, \"Name\", \"Flags\");\n-        println(\"MethodParameters:\");\n-        indent(+1);\n-        println(header);\n-        for (MethodParameters_attribute.Entry entry :\n-                 attr.method_parameter_table) {\n-            String namestr =\n-                entry.name_index != 0 ?\n-                constantWriter.stringValue(entry.name_index) : \"<no name>\";\n-            String flagstr =\n-                (0 != (entry.flags & ACC_FINAL) ? \"final \" : \"\") +\n-                (0 != (entry.flags & ACC_MANDATED) ? \"mandated \" : \"\") +\n-                (0 != (entry.flags & ACC_SYNTHETIC) ? \"synthetic\" : \"\");\n-            println(String.format(format, namestr, flagstr));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModule(Module_attribute attr, Void ignore) {\n-        println(\"Module:\");\n-        indent(+1);\n-\n-        print(\"#\" + attr.module_name);\n-        print(\",\");\n-        print(String.format(\"%x\", attr.module_flags));\n-        tab();\n-        print(\"\/\/ \" + constantWriter.stringValue(attr.module_name));\n-        if ((attr.module_flags & Module_attribute.ACC_OPEN) != 0)\n-            print(\" ACC_OPEN\");\n-        if ((attr.module_flags & Module_attribute.ACC_MANDATED) != 0)\n-            print(\" ACC_MANDATED\");\n-        if ((attr.module_flags & Module_attribute.ACC_SYNTHETIC) != 0)\n-            print(\" ACC_SYNTHETIC\");\n-        println();\n-        print(\"#\" + attr.module_version_index);\n-        if (attr.module_version_index != 0) {\n-            tab();\n-            print(\"\/\/ \" + constantWriter.stringValue(attr.module_version_index));\n-        }\n-        println();\n-\n-        printRequiresTable(attr);\n-        printExportsTable(attr);\n-        printOpensTable(attr);\n-        printUsesTable(attr);\n-        printProvidesTable(attr);\n-        indent(-1);\n-        return null;\n-    }\n-\n-    protected void printRequiresTable(Module_attribute attr) {\n-        Module_attribute.RequiresEntry[] entries = attr.requires;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ \" + \"requires\");\n-        indent(+1);\n-        for (Module_attribute.RequiresEntry e: entries) {\n-            print(\"#\" + e.requires_index + \",\" + String.format(\"%x\", e.requires_flags));\n-            tab();\n-            print(\"\/\/ \" + constantWriter.stringValue(e.requires_index));\n-            if ((e.requires_flags & Module_attribute.ACC_TRANSITIVE) != 0)\n-                print(\" ACC_TRANSITIVE\");\n-            if ((e.requires_flags & Module_attribute.ACC_STATIC_PHASE) != 0)\n-                print(\" ACC_STATIC_PHASE\");\n-            if ((e.requires_flags & Module_attribute.ACC_SYNTHETIC) != 0)\n-                print(\" ACC_SYNTHETIC\");\n-            if ((e.requires_flags & Module_attribute.ACC_MANDATED) != 0)\n-                print(\" ACC_MANDATED\");\n-            println();\n-            print(\"#\" + e.requires_version_index);\n-            if (e.requires_version_index != 0) {\n+            case ModuleTargetAttribute attr -> {\n+                println(\"ModuleTarget:\");\n+                indent(+1);\n+                print(\"target_platform: #\" + attr.targetPlatform().index());\n@@ -507,1 +469,2 @@\n-                print(\"\/\/ \" + constantWriter.stringValue(e.requires_version_index));\n+                println(\"\/\/ \" + attr.targetPlatform().stringValue());\n+                indent(-1);\n@@ -509,1 +472,146 @@\n-            println();\n+            case NestMembersAttribute attr -> {\n+                println(\"NestMembers:\");\n+                indent(+1);\n+                for (var m : attr.nestMembers()) {\n+                    println(constantWriter.stringValue(m));\n+                }\n+                indent(-1);\n+            }\n+            case RecordAttribute attr -> {\n+                println(\"Record:\");\n+                indent(+1);\n+                for (var componentInfo : attr.components()) {\n+                    var sigAttr = componentInfo.findAttribute(Attributes.SIGNATURE);\n+                    print(getJavaName(\n+                            new ClassWriter.SignaturePrinter(options.verbose).print(\n+                                    sigAttr.map(SignatureAttribute::asTypeSignature)\n+                                            .orElse(Signature.of(\n+                                                    componentInfo.descriptorSymbol())))));\n+                    print(\" \");\n+                    print(componentInfo.name().stringValue());\n+                    print(\";\");\n+                    println();\n+                    indent(+1);\n+                    if (options.showDescriptors) {\n+                        println(\"descriptor: \" + componentInfo.descriptor().stringValue());\n+                    }\n+                    if (options.showAllAttrs) {\n+                        write(componentInfo.attributes());\n+                        println();\n+                    }\n+                    indent(-1);\n+                }\n+                indent(-1);\n+            }\n+            case RuntimeVisibleAnnotationsAttribute attr ->\n+                printAnnotations(\"RuntimeVisibleAnnotations:\", attr.annotations());\n+            case RuntimeInvisibleAnnotationsAttribute attr ->\n+                printAnnotations(\"RuntimeInvisibleAnnotations:\", attr.annotations());\n+            case RuntimeVisibleTypeAnnotationsAttribute attr ->\n+                printTypeAnnotations(\"RuntimeVisibleTypeAnnotations:\",\n+                        attr.annotations(), lr);\n+            case RuntimeInvisibleTypeAnnotationsAttribute attr ->\n+                printTypeAnnotations(\"RuntimeInvisibleTypeAnnotations:\",\n+                        attr.annotations(), lr);\n+            case RuntimeVisibleParameterAnnotationsAttribute attr ->\n+                printParameterAnnotations(\"RuntimeVisibleParameterAnnotations:\",\n+                        attr.parameterAnnotations());\n+            case RuntimeInvisibleParameterAnnotationsAttribute attr ->\n+                printParameterAnnotations(\"RuntimeInvisibleParameterAnnotations:\",\n+                        attr.parameterAnnotations());\n+            case PermittedSubclassesAttribute attr -> {\n+                println(\"PermittedSubclasses:\");\n+                indent(+1);\n+                for (var sc : attr.permittedSubclasses()) {\n+                    println(constantWriter.stringValue(sc));\n+                }\n+                indent(-1);\n+            }\n+            case PreloadAttribute attr -> {\n+                println(\"Preload:\");\n+                indent(+1);\n+                for (var sc : attr.preloads()) {\n+                    println(constantWriter.stringValue(sc));\n+                }\n+                indent(-1);\n+            }\n+            case SignatureAttribute attr -> {\n+                print(\"Signature: #\" + attr.signature().index());\n+                tab();\n+                println(\"\/\/ \" + attr.signature().stringValue());\n+            }\n+            case SourceDebugExtensionAttribute attr -> {\n+                println(\"SourceDebugExtension:\");\n+                indent(+1);\n+                for (String s: new String(attr.contents(), StandardCharsets.UTF_8)\n+                        .split(\"[\\r\\n]+\")) {\n+                    println(s);\n+                }\n+                indent(-1);\n+            }\n+            case SourceFileAttribute attr ->\n+                println(\"SourceFile: \\\"\" + attr.sourceFile().stringValue() + \"\\\"\");\n+            case SourceIDAttribute attr ->\n+                constantWriter.write(attr.sourceId().index());\n+            case StackMapTableAttribute attr -> {\n+                var entries = attr.entries();\n+                println(\"StackMapTable: number_of_entries = \" + entries.size());\n+                indent(+1);\n+                int lastOffset = -1;\n+                for (var frame : entries) {\n+                    int frameType = frame.frameType();\n+                    if (frameType < 64) {\n+                        printHeader(frameType, \"\/* same *\/\");\n+                    } else if (frameType < 128) {\n+                        printHeader(frameType, \"\/* same_locals_1_stack_item *\/\");\n+                        indent(+1);\n+                        printMap(\"stack\", frame.stack(), lr);\n+                        indent(-1);\n+                    } else {\n+                        int offsetDelta = lr.labelToBci(frame.target()) - lastOffset - 1;\n+                        switch (frameType) {\n+                            case 247 -> {\n+                                printHeader(frameType, \"\/* same_locals_1_stack_item_frame_extended *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                printMap(\"stack\", frame.stack(), lr);\n+                                indent(-1);\n+                            }\n+                            case 248, 249, 250 -> {\n+                                printHeader(frameType, \"\/* chop *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                indent(-1);\n+                            }\n+                            case 251 -> {\n+                                printHeader(frameType, \"\/* same_frame_extended *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                indent(-1);\n+                            }\n+                            case 252, 253, 254 -> {\n+                                printHeader(frameType, \"\/* append *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                var locals = frame.locals();\n+                                printMap(\"locals\", locals.subList(locals.size()\n+                                        - frameType + 251, locals.size()), lr);\n+                                indent(-1);\n+                            }\n+                            case 255 -> {\n+                                printHeader(frameType, \"\/* full_frame *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                printMap(\"locals\", frame.locals(), lr);\n+                                printMap(\"stack\", frame.stack(), lr);\n+                                indent(-1);\n+                            }\n+                        }\n+                    }\n+                    lastOffset = lr.labelToBci(frame.target());\n+                }\n+                indent(-1);\n+            }\n+            case SyntheticAttribute attr ->\n+                println(\"Synthetic: true\");\n+            default -> {}\n@@ -511,1 +619,0 @@\n-        indent(-1);\n@@ -514,11 +621,5 @@\n-    protected void printExportsTable(Module_attribute attr) {\n-        Module_attribute.ExportsEntry[] entries = attr.exports;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ exports\");\n-        indent(+1);\n-        for (Module_attribute.ExportsEntry e: entries) {\n-            printExportOpenEntry(e.exports_index, e.exports_flags, e.exports_to_index);\n-        }\n-        indent(-1);\n-    }\n+    \/\/ToDo move somewhere to Bytecode API\n+    public static final int DO_NOT_RESOLVE_BY_DEFAULT   = 0x0001;\n+    public static final int WARN_DEPRECATED             = 0x0002;\n+    public static final int WARN_DEPRECATED_FOR_REMOVAL = 0x0004;\n+    public static final int WARN_INCUBATING             = 0x0008;\n@@ -526,11 +627,1 @@\n-    protected void printOpensTable(Module_attribute attr) {\n-        Module_attribute.OpensEntry[] entries = attr.opens;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ opens\");\n-        indent(+1);\n-        for (Module_attribute.OpensEntry e: entries) {\n-            printExportOpenEntry(e.opens_index, e.opens_flags, e.opens_to_index);\n-        }\n-        indent(-1);\n-    }\n+    private static final String format = \"%-31s%s\";\n@@ -538,1 +629,1 @@\n-    protected void printExportOpenEntry(int index, int flags, int[] to_index) {\n+    protected void printExportOpenEntry(int index, int flags, List<ModuleEntry> to_index) {\n@@ -543,1 +634,1 @@\n-        if ((flags & Module_attribute.ACC_MANDATED) != 0)\n+        if ((flags & ACC_MANDATED) != 0)\n@@ -545,1 +636,1 @@\n-        if ((flags & Module_attribute.ACC_SYNTHETIC) != 0)\n+        if ((flags & ACC_SYNTHETIC) != 0)\n@@ -547,1 +638,1 @@\n-        if (to_index.length == 0) {\n+        if (to_index.size() == 0) {\n@@ -550,1 +641,1 @@\n-            println(\" to ... \" + to_index.length);\n+            println(\" to ... \" + to_index.size());\n@@ -552,2 +643,2 @@\n-            for (int to: to_index) {\n-                print(\"#\" + to);\n+            for (var to: to_index) {\n+                print(\"#\" + to.index());\n@@ -561,273 +652,2 @@\n-    protected void printUsesTable(Module_attribute attr) {\n-        int[] entries = attr.uses_index;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ \" + \"uses\");\n-        indent(+1);\n-        for (int e: entries) {\n-            print(\"#\" + e);\n-            tab();\n-            println(\"\/\/ \" + constantWriter.stringValue(e));\n-        }\n-        indent(-1);\n-    }\n-\n-    protected void printProvidesTable(Module_attribute attr) {\n-        Module_attribute.ProvidesEntry[] entries = attr.provides;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ \" + \"provides\");\n-        indent(+1);\n-        for (Module_attribute.ProvidesEntry e: entries) {\n-            print(\"#\" + e.provides_index);\n-            tab();\n-            print(\"\/\/ \");\n-            print(constantWriter.stringValue(e.provides_index));\n-            println(\" with ... \" + e.with_count);\n-            indent(+1);\n-            for (int with : e.with_index) {\n-                print(\"#\" + with);\n-                tab();\n-                println(\"\/\/ ... with \" + constantWriter.stringValue(with));\n-            }\n-            indent(-1);\n-        }\n-        indent(-1);\n-    }\n-\n-    @Override\n-    public Void visitModuleHashes(ModuleHashes_attribute attr, Void ignore) {\n-        println(\"ModuleHashes:\");\n-        indent(+1);\n-        print(\"algorithm: #\" + attr.algorithm_index);\n-        tab();\n-        println(\"\/\/ \" + getAlgorithm(attr));\n-        print(attr.hashes_table_length);\n-        tab();\n-        println(\"\/\/ hashes\");\n-        for (ModuleHashes_attribute.Entry e : attr.hashes_table) {\n-            print(\"#\" + e.module_name_index);\n-            tab();\n-            println(\"\/\/ \" + getModuleName(e));\n-            println(\"hash_length: \" + e.hash.length);\n-            println(\"hash: [\" + toHex(e.hash) + \"]\");\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getAlgorithm(ModuleHashes_attribute attr) {\n-        try {\n-            return constant_pool.getUTF8Value(attr.algorithm_index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private String getModuleName(ModuleHashes_attribute.Entry entry) {\n-        try {\n-            int utf8Index = constant_pool.getModuleInfo(entry.module_name_index).name_index;\n-            return constant_pool.getUTF8Value(utf8Index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitModuleMainClass(ModuleMainClass_attribute attr, Void ignore) {\n-        print(\"ModuleMainClass: #\" + attr.main_class_index);\n-        tab();\n-        print(\"\/\/ \" + getJavaClassName(attr));\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModulePackages(ModulePackages_attribute attr, Void ignore) {\n-        println(\"ModulePackages: \");\n-        indent(+1);\n-        for (int i = 0; i < attr.packages_count; i++) {\n-            print(\"#\" + attr.packages_index[i]);\n-            tab();\n-            println(\"\/\/ \" + getJavaPackage(attr, i));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getJavaPackage(ModulePackages_attribute attr, int index) {\n-        try {\n-            return getJavaName(attr.getPackage(index, constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitModuleResolution(ModuleResolution_attribute attr, Void ignore) {\n-        println(\"ModuleResolution:\");\n-        indent(+1);\n-        print(String.format(\"%x\", attr.resolution_flags));\n-        tab();\n-        print(\"\/\/ \");\n-        int flags = attr.resolution_flags;\n-        if ((flags & ModuleResolution_attribute.DO_NOT_RESOLVE_BY_DEFAULT) != 0)\n-            print(\" DO_NOT_RESOLVE_BY_DEFAULT\");\n-        if ((flags & ModuleResolution_attribute.WARN_DEPRECATED) != 0)\n-            print(\" WARN_DEPRECATED\");\n-        if ((flags & ModuleResolution_attribute.WARN_DEPRECATED_FOR_REMOVAL) != 0)\n-            print(\" WARN_DEPRECATED_FOR_REMOVAL\");\n-        if ((flags & ModuleResolution_attribute.WARN_INCUBATING) != 0)\n-            print(\" WARN_INCUBATING\");\n-        println();\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModuleTarget(ModuleTarget_attribute attr, Void ignore) {\n-        println(\"ModuleTarget:\");\n-        indent(+1);\n-        print(\"target_platform: #\" + attr.target_platform_index);\n-        if (attr.target_platform_index != 0) {\n-            tab();\n-            print(\"\/\/ \" + getTargetPlatform(attr));\n-        }\n-        println();\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getTargetPlatform(ModuleTarget_attribute attr) {\n-        try {\n-            return constant_pool.getUTF8Value(attr.target_platform_index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitNestMembers(NestMembers_attribute attr, Void aVoid) {\n-        println(\"NestMembers:\");\n-        indent(+1);\n-        try {\n-            CONSTANT_Class_info[] children = attr.getChildren(constant_pool);\n-            for (int i = 0; i < attr.members_indexes.length; i++) {\n-                println(constantWriter.stringValue(children[i]));\n-            }\n-            indent(-1);\n-        } catch (ConstantPoolException ex) {\n-            throw new AssertionError(ex);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitRecord(Record_attribute attr, Void p) {\n-        println(\"Record:\");\n-        indent(+1);\n-        for (Record_attribute.ComponentInfo componentInfo : attr.component_info_arr) {\n-            Signature_attribute sigAttr = (Signature_attribute) componentInfo.attributes.get(Attribute.Signature);\n-\n-            if (sigAttr == null)\n-                print(getJavaFieldType(componentInfo.descriptor));\n-            else {\n-                try {\n-                    Type t = sigAttr.getParsedSignature().getType(constant_pool);\n-                    print(getJavaName(t.toString()));\n-                } catch (ConstantPoolException e) {\n-                    \/\/ report error?\n-                    \/\/ fall back on non-generic descriptor\n-                    print(getJavaFieldType(componentInfo.descriptor));\n-                }\n-            }\n-\n-            print(\" \");\n-            try {\n-                print(componentInfo.getName(constant_pool));\n-            } catch (ConstantPoolException e) {\n-                report(e);\n-                return null;\n-            }\n-            print(\";\");\n-            println();\n-            indent(+1);\n-            if (options.showDescriptors) {\n-                println(\"descriptor: \" + getValue(componentInfo.descriptor));\n-            }\n-            if (options.showAllAttrs) {\n-                for (Attribute componentAttr: componentInfo.attributes)\n-                    write(componentInfo, componentAttr, constant_pool);\n-                println();\n-            }\n-            indent(-1);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    String getValue(Descriptor d) {\n-        try {\n-            return d.getValue(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    void writeList(String prefix, Collection<?> items, String suffix) {\n-        print(prefix);\n-        String sep = \"\";\n-        for (Object item: items) {\n-            print(sep);\n-            print(item);\n-            sep = \", \";\n-        }\n-        print(suffix);\n-    }\n-\n-    String getJavaFieldType(Descriptor d) {\n-        try {\n-            return getJavaName(d.getFieldType(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    void writeModifiers(Collection<String> items) {\n-        for (Object item: items) {\n-            print(item);\n-            print(\" \");\n-        }\n-    }\n-\n-    @Override\n-    public Void visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeVisibleAnnotations:\");\n-        indent(+1);\n-        for (int i = 0; i < attr.annotations.length; i++) {\n-            print(i + \": \");\n-            annotationWriter.write(attr.annotations[i]);\n-            println();\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeInvisibleAnnotations:\");\n-        indent(+1);\n-        for (int i = 0; i < attr.annotations.length; i++) {\n-            print(i + \": \");\n-            annotationWriter.write(attr.annotations[i]);\n-            println();\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeVisibleTypeAnnotations:\");\n+    private void printAnnotations(String message, List<? extends Annotation> anno) {\n+        println(message);\n@@ -835,1 +655,1 @@\n-        for (int i = 0; i < attr.annotations.length; i++) {\n+        for (int i = 0; i < anno.size(); i++) {\n@@ -837,1 +657,1 @@\n-            annotationWriter.write(attr.annotations[i]);\n+            annotationWriter.write(anno.get(i));\n@@ -841,1 +661,0 @@\n-        return null;\n@@ -844,3 +663,3 @@\n-    @Override\n-    public Void visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeInvisibleTypeAnnotations:\");\n+    private void printTypeAnnotations(String message,\n+            List<? extends TypeAnnotation> anno, CodeAttribute lr) {\n+        println(message);\n@@ -848,1 +667,1 @@\n-        for (int i = 0; i < attr.annotations.length; i++) {\n+        for (int i = 0; i < anno.size(); i++) {\n@@ -850,1 +669,1 @@\n-            annotationWriter.write(attr.annotations[i]);\n+            annotationWriter.write(anno.get(i), lr);\n@@ -854,1 +673,0 @@\n-        return null;\n@@ -857,1 +675,1 @@\n-    private void visitParameterAnnotations(String message, RuntimeParameterAnnotations_attribute attr) {\n+    private void printParameterAnnotations(String message, List<List<Annotation>> paramsAnno) {\n@@ -860,1 +678,1 @@\n-        for (int param = 0; param < attr.parameter_annotations.length; param++) {\n+        for (int param = 0; param < paramsAnno.size(); param++) {\n@@ -863,1 +681,2 @@\n-            for (int i = 0; i < attr.parameter_annotations[param].length; i++) {\n+            var annos = paramsAnno.get(param);\n+            for (int i = 0; i < annos.size(); i++) {\n@@ -865,1 +684,1 @@\n-                annotationWriter.write(attr.parameter_annotations[param][i]);\n+                annotationWriter.write(annos.get(i));\n@@ -873,4 +692,3 @@\n-    @Override\n-    public Void visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute attr, Void ignore) {\n-        visitParameterAnnotations(\"RuntimeVisibleParameterAnnotations:\", (RuntimeParameterAnnotations_attribute) attr);\n-        return null;\n+    void printHeader(int frameType, String extra) {\n+        print(\"frame_type = \" + frameType + \" \");\n+        println(extra);\n@@ -879,189 +697,8 @@\n-    @Override\n-    public Void visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute attr, Void ignore) {\n-        visitParameterAnnotations(\"RuntimeInvisibleParameterAnnotations:\", (RuntimeParameterAnnotations_attribute) attr);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitPermittedSubclasses(PermittedSubclasses_attribute attr, Void ignore) {\n-        println(\"PermittedSubclasses:\");\n-        indent(+1);\n-        try {\n-            CONSTANT_Class_info[] subtypes = attr.getSubtypes(constant_pool);\n-            for (int i = 0; i < subtypes.length; i++) {\n-                println(constantWriter.stringValue(subtypes[i]));\n-            }\n-            indent(-1);\n-        } catch (ConstantPoolException ex) {\n-            throw new AssertionError(ex);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitSignature(Signature_attribute attr, Void ignore) {\n-        print(\"Signature: #\" + attr.signature_index);\n-        tab();\n-        println(\"\/\/ \" + getSignature(attr));\n-        return null;\n-    }\n-\n-    String getSignature(Signature_attribute info) {\n-        try {\n-            return info.getSignature(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitSourceDebugExtension(SourceDebugExtension_attribute attr, Void ignore) {\n-        println(\"SourceDebugExtension:\");\n-        indent(+1);\n-        for (String s: attr.getValue().split(\"[\\r\\n]+\")) {\n-            println(s);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitSourceFile(SourceFile_attribute attr, Void ignore) {\n-        println(\"SourceFile: \\\"\" + getSourceFile(attr) + \"\\\"\");\n-        return null;\n-    }\n-\n-    private String getSourceFile(SourceFile_attribute attr) {\n-        try {\n-            return attr.getSourceFile(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitSourceID(SourceID_attribute attr, Void ignore) {\n-        constantWriter.write(attr.sourceID_index);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitStackMap(StackMap_attribute attr, Void ignore) {\n-        println(\"StackMap: number_of_entries = \" + attr.number_of_entries);\n-        indent(+1);\n-        StackMapTableWriter w = new StackMapTableWriter();\n-        for (StackMapTable_attribute.stack_map_frame entry : attr.entries) {\n-            w.write(entry);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitStackMapTable(StackMapTable_attribute attr, Void ignore) {\n-        println(\"StackMapTable: number_of_entries = \" + attr.number_of_entries);\n-        indent(+1);\n-        StackMapTableWriter w = new StackMapTableWriter();\n-        for (StackMapTable_attribute.stack_map_frame entry : attr.entries) {\n-            w.write(entry);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    class StackMapTableWriter \/\/ also handles CLDC StackMap attributes\n-            implements StackMapTable_attribute.stack_map_frame.Visitor<Void,Void> {\n-        public void write(StackMapTable_attribute.stack_map_frame frame) {\n-            frame.accept(this, null);\n-        }\n-\n-        @Override\n-        public Void visit_same_frame(StackMapTable_attribute.same_frame frame, Void p) {\n-            printHeader(frame, \"\/* same *\/\");\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_locals_1_stack_item_frame(StackMapTable_attribute.same_locals_1_stack_item_frame frame, Void p) {\n-            printHeader(frame, \"\/* same_locals_1_stack_item *\/\");\n-            indent(+1);\n-            printMap(\"stack\", frame.stack);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_locals_1_stack_item_frame_extended(StackMapTable_attribute.same_locals_1_stack_item_frame_extended frame, Void p) {\n-            printHeader(frame, \"\/* same_locals_1_stack_item_frame_extended *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            printMap(\"stack\", frame.stack);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_chop_frame(StackMapTable_attribute.chop_frame frame, Void p) {\n-            printHeader(frame, \"\/* chop *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_frame_extended(StackMapTable_attribute.same_frame_extended frame, Void p) {\n-            printHeader(frame, \"\/* same_frame_extended *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_append_frame(StackMapTable_attribute.append_frame frame, Void p) {\n-            printHeader(frame, \"\/* append *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            printMap(\"locals\", frame.locals);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_full_frame(StackMapTable_attribute.full_frame frame, Void p) {\n-            if (frame instanceof StackMap_attribute.stack_map_frame) {\n-                printHeader(frame, \"offset = \" + frame.offset_delta);\n-                indent(+1);\n-            } else {\n-                printHeader(frame, \"\/* full_frame *\/\");\n-                indent(+1);\n-                println(\"offset_delta = \" + frame.offset_delta);\n-            }\n-            printMap(\"locals\", frame.locals);\n-            printMap(\"stack\", frame.stack);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        void printHeader(StackMapTable_attribute.stack_map_frame frame, String extra) {\n-            print(\"frame_type = \" + frame.frame_type + \" \");\n-            println(extra);\n-        }\n-\n-        void printMap(String name, StackMapTable_attribute.verification_type_info[] map) {\n-            print(name + \" = [\");\n-            for (int i = 0; i < map.length; i++) {\n-                StackMapTable_attribute.verification_type_info info = map[i];\n-                int tag = info.tag;\n-                switch (tag) {\n-                    case StackMapTable_attribute.verification_type_info.ITEM_Object:\n-                        print(\" \");\n-                        constantWriter.write(((StackMapTable_attribute.Object_variable_info) info).cpool_index);\n-                        break;\n-                    case StackMapTable_attribute.verification_type_info.ITEM_Uninitialized:\n-                        print(\" \" + mapTypeName(tag));\n-                        print(\" \" + ((StackMapTable_attribute.Uninitialized_variable_info) info).offset);\n-                        break;\n-                    default:\n-                        print(\" \" + mapTypeName(tag));\n+    void printMap(String name, List<VerificationTypeInfo> map, CodeAttribute lr) {\n+        print(name + \" = [\");\n+        for (int i = 0; i < map.size(); i++) {\n+            var info = map.get(i);\n+            switch (info) {\n+                case ObjectVerificationTypeInfo obj -> {\n+                    print(\" \");\n+                    constantWriter.write(obj.className().index());\n@@ -1069,37 +706,5 @@\n-                print(i == (map.length - 1) ? \" \" : \",\");\n-            }\n-            println(\"]\");\n-        }\n-\n-        String mapTypeName(int tag) {\n-            switch (tag) {\n-            case StackMapTable_attribute.verification_type_info.ITEM_Top:\n-                return \"top\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Integer:\n-                return \"int\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Float:\n-                return \"float\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Long:\n-                return \"long\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Double:\n-                return \"double\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Null:\n-                return \"null\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_UninitializedThis:\n-                return \"this\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Object:\n-                return \"CP\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Uninitialized:\n-                return \"uninitialized\";\n-\n-            default:\n-                report(\"unrecognized verification_type_info tag: \" + tag);\n-                return \"[tag:\" + tag + \"]\";\n+                case UninitializedVerificationTypeInfo u -> {\n+                    print(\" uninitialized \" + lr.labelToBci(u.newTarget()));\n+                }\n+                case SimpleVerificationTypeInfo s ->\n+                    print(\" \" + mapTypeName(s));\n@@ -1107,0 +712,1 @@\n+            print(i == (map.size() - 1) ? \" \" : \",\");\n@@ -1108,0 +714,1 @@\n+        println(\"]\");\n@@ -1110,25 +717,10 @@\n-    @Override\n-    public Void visitSynthetic(Synthetic_attribute attr, Void ignore) {\n-        println(\"Synthetic: true\");\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitPreload(Preload_attribute attr, Void ignore) {\n-        boolean first = true;\n-        for (int index : attr.value_class_info_index) {\n-            if (first) {\n-                println(\"Classes to be preloaded:\");\n-                indent(+1);\n-                first = false;\n-            }\n-            print(\"#\" + index);\n-            print(\";\");\n-            tab();\n-            print(\"\/\/ value \");\n-            constantWriter.write(index);\n-            println();\n-        }\n-        if (!first)\n-            indent(-1);\n-        return null;\n+    String mapTypeName(SimpleVerificationTypeInfo type) {\n+        return switch (type) {\n+            case ITEM_TOP -> \"top\";\n+            case ITEM_INTEGER -> \"int\";\n+            case ITEM_FLOAT -> \"float\";\n+            case ITEM_LONG -> \"long\";\n+            case ITEM_DOUBLE -> \"double\";\n+            case ITEM_NULL -> \"null\";\n+            case ITEM_UNINITIALIZED_THIS -> \"this\";\n+        };\n@@ -1146,1 +738,1 @@\n-        return StringUtils.toUpperCase(Integer.toString(i, 16));\n+        return Integer.toString(i, 16).toUpperCase(Locale.US);\n@@ -1150,1 +742,1 @@\n-        String s = StringUtils.toUpperCase(Integer.toHexString(i));\n+        String s = Integer.toHexString(i).toUpperCase(Locale.US);\n@@ -1153,1 +745,1 @@\n-        return StringUtils.toUpperCase(s);\n+        return s;\n@@ -1168,3 +760,0 @@\n-\n-    private ConstantPool constant_pool;\n-    private Object owner;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":599,"deletions":1010,"binary":false,"changes":1609,"status":"modified"},{"patch":"@@ -35,29 +35,17 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantValue_attribute;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Exceptions_attribute;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.Signature;\n-import com.sun.tools.classfile.Signature_attribute;\n-import com.sun.tools.classfile.SourceFile_attribute;\n-import com.sun.tools.classfile.Type;\n-import com.sun.tools.classfile.Type.ArrayType;\n-import com.sun.tools.classfile.Type.ClassSigType;\n-import com.sun.tools.classfile.Type.ClassType;\n-import com.sun.tools.classfile.Type.MethodType;\n-import com.sun.tools.classfile.Type.SimpleType;\n-import com.sun.tools.classfile.Type.TypeParamType;\n-import com.sun.tools.classfile.Type.WildcardType;\n-\n-import static com.sun.tools.classfile.AccessFlags.*;\n-import static com.sun.tools.classfile.ConstantPool.CONSTANT_Module;\n-import static com.sun.tools.classfile.ConstantPool.CONSTANT_Package;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.Classfile;\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n@@ -88,0 +76,1 @@\n+        sigPrinter = new SignaturePrinter(options.verbose);\n@@ -107,2 +96,2 @@\n-    protected ClassFile getClassFile() {\n-        return classFile;\n+    protected ClassModel getClassModel() {\n+        return classModel;\n@@ -111,3 +100,2 @@\n-    protected void setClassFile(ClassFile cf) {\n-        classFile = cf;\n-        constant_pool = classFile.constant_pool;\n+    protected void setClassFile(ClassModel cm) {\n+        classModel = cm;\n@@ -116,1 +104,1 @@\n-    protected Method getMethod() {\n+    protected MethodModel getMethod() {\n@@ -120,1 +108,1 @@\n-    protected void setMethod(Method m) {\n+    protected void setMethod(MethodModel m) {\n@@ -124,2 +112,3 @@\n-    public void write(ClassFile cf) {\n-        setClassFile(cf);\n+    public boolean write(ClassModel cm) {\n+        errorReported = false;\n+        setClassFile(cm);\n@@ -139,1 +128,2 @@\n-                    println(\"Last modified \" + df.format(lm) + \"; size \" + size + \" bytes\");\n+                    println(\"Last modified \" + df.format(lm) + \"; size \" + size\n+                            + \" bytes\");\n@@ -154,4 +144,2 @@\n-        Attribute sfa = cf.getAttribute(Attribute.SourceFile);\n-        if (sfa instanceof SourceFile_attribute) {\n-            println(\"Compiled from \\\"\" + getSourceFile((SourceFile_attribute) sfa) + \"\\\"\");\n-        }\n+        cm.findAttribute(Attributes.SOURCE_FILE).ifPresent(sfa ->\n+            println(\"Compiled from \\\"\" + sfa.sourceFile().stringValue() + \"\\\"\"));\n@@ -163,19 +151,7 @@\n-        AccessFlags flags = cf.access_flags;\n-        writeModifiers(flags.getClassModifiers());\n-\n-        if (classFile.access_flags.is(AccessFlags.ACC_MODULE)) {\n-            Attribute attr = classFile.attributes.get(Attribute.Module);\n-            if (attr instanceof Module_attribute) {\n-                Module_attribute modAttr = (Module_attribute) attr;\n-                String name;\n-                try {\n-                    \/\/ FIXME: compatibility code\n-                    if (constant_pool.get(modAttr.module_name).getTag() == CONSTANT_Module) {\n-                        name = getJavaName(constant_pool.getModuleInfo(modAttr.module_name).getName());\n-                    } else {\n-                        name = getJavaName(constant_pool.getUTF8Value(modAttr.module_name));\n-                    }\n-                } catch (ConstantPoolException e) {\n-                    name = report(e);\n-                }\n-                if ((modAttr.module_flags & Module_attribute.ACC_OPEN) != 0) {\n+        writeModifiers(getClassModifiers(cm.flags().flagsMask()));\n+\n+        if ((classModel.flags().flagsMask() & ACC_MODULE) != 0) {\n+            var attr = classModel.findAttribute(Attributes.MODULE);\n+            if (attr.isPresent()) {\n+                var modAttr = attr.get();\n+                if ((modAttr.moduleFlagsMask() & ACC_OPEN) != 0) {\n@@ -185,2 +161,2 @@\n-                print(name);\n-                if (modAttr.module_version_index != 0) {\n+                print(() -> modAttr.moduleName().name().stringValue());\n+                if (modAttr.moduleVersion().isPresent()) {\n@@ -188,1 +164,1 @@\n-                    print(getUTF8Value(modAttr.module_version_index));\n+                    print(() -> modAttr.moduleVersion().get().stringValue());\n@@ -193,1 +169,1 @@\n-                print(getJavaName(classFile));\n+                print(() -> getJavaName(classModel.thisClass().asInternalName()));\n@@ -196,1 +172,1 @@\n-            if (classFile.isClass())\n+            if ((classModel.flags().flagsMask() & ACC_INTERFACE) == 0)\n@@ -198,1 +174,1 @@\n-            else if (classFile.isInterface())\n+            else\n@@ -201,1 +177,1 @@\n-            print(getJavaName(classFile));\n+            print(() -> getJavaName(classModel.thisClass().asInternalName()));\n@@ -204,8 +180,11 @@\n-        Signature_attribute sigAttr = getSignature(cf.attributes);\n-        if (sigAttr == null) {\n-            \/\/ use info from class file header\n-            if (classFile.isClass() && classFile.super_class != 0 ) {\n-                String sn = getJavaSuperclassName(cf);\n-                if (!sn.equals(\"java.lang.Object\")) {\n-                    print(\" extends \");\n-                    print(sn);\n+        try {\n+            var sigAttr = classModel.findAttribute(Attributes.SIGNATURE).orElse(null);\n+            if (sigAttr == null) {\n+                \/\/ use info from class file header\n+                if ((classModel.flags().flagsMask() & ACC_INTERFACE) == 0\n+                        && classModel.superclass().isPresent()) {\n+                    String sn = getJavaName(classModel.superclass().get().asInternalName());\n+                    if (!sn.equals(\"java.lang.Object\")) {\n+                        print(\" extends \");\n+                        print(sn);\n+                    }\n@@ -213,16 +192,5 @@\n-            }\n-            for (int i = 0; i < classFile.interfaces.length; i++) {\n-                print(i == 0 ? (classFile.isClass() ? \" implements \" : \" extends \") : \",\");\n-                print(getJavaInterfaceName(classFile, i));\n-            }\n-        } else {\n-            try {\n-                Type t = sigAttr.getParsedSignature().getType(constant_pool);\n-                JavaTypePrinter p = new JavaTypePrinter(classFile.isInterface());\n-                \/\/ The signature parser cannot disambiguate between a\n-                \/\/ FieldType and a ClassSignatureType that only contains a superclass type.\n-                if (t instanceof Type.ClassSigType) {\n-                    print(p.print(t));\n-                } else if (options.verbose || !t.isObject()) {\n-                    print(\" extends \");\n-                    print(p.print(t));\n+                var interfaces = classModel.interfaces();\n+                for (int i = 0; i < interfaces.size(); i++) {\n+                    print(i == 0 ? ((classModel.flags().flagsMask() & ACC_INTERFACE) == 0\n+                            ? \" implements \" : \" extends \") : \",\");\n+                    print(getJavaName(interfaces.get(i).asInternalName()));\n@@ -230,4 +198,3 @@\n-            } catch (ConstantPoolException e) {\n-                print(report(e));\n-            } catch (IllegalStateException e) {\n-                report(\"Invalid value for Signature attribute: \" + e.getMessage());\n+            } else {\n+                var t = sigAttr.asClassSignature();\n+                print(sigPrinter.print(t, (classModel.flags().flagsMask() & ACC_INTERFACE) != 0));\n@@ -235,0 +202,2 @@\n+        } catch (IllegalArgumentException e) {\n+            report(e);\n@@ -240,8 +209,7 @@\n-            println(\"minor version: \" + cf.minor_version);\n-            println(\"major version: \" + cf.major_version);\n-            writeList(String.format(\"flags: (0x%04x) \", flags.flags), flags.getClassFlags(), \"\\n\");\n-            print(\"this_class: #\" + cf.this_class);\n-            if (cf.this_class != 0) {\n-                tab();\n-                print(\"\/\/ \" + constantWriter.stringValue(cf.this_class));\n-            }\n+            println(\"minor version: \" + classModel.minorVersion());\n+            println(\"major version: \" + classModel.majorVersion());\n+            writeList(String.format(\"flags: (0x%04x) \", cm.flags().flagsMask()),\n+                    getClassFlags(cm.flags().flagsMask()), \"\\n\");\n+            print(\"this_class: #\");print(() -> classModel.thisClass().index());\n+            tab();\n+            print(() -> \"\/\/ \" + classModel.thisClass().asInternalName());\n@@ -249,4 +217,9 @@\n-            print(\"super_class: #\" + cf.super_class);\n-            if (cf.super_class != 0) {\n-                tab();\n-                print(\"\/\/ \" + constantWriter.stringValue(cf.super_class));\n+            print(\"super_class: #\");print(() -> classModel.superclass()\n+                    .map(ClassEntry::index).orElse(0));\n+            try {\n+                if (classModel.superclass().isPresent()) {\n+                    tab();\n+                    print(() -> \"\/\/ \" + classModel.superclass().get().asInternalName());\n+                }\n+            } catch (IllegalArgumentException e) {\n+                report(e);\n@@ -255,4 +228,4 @@\n-            print(\"interfaces: \" + cf.interfaces.length);\n-            print(\", fields: \" + cf.fields.length);\n-            print(\", methods: \" + cf.methods.length);\n-            println(\", attributes: \" + cf.attributes.attrs.length);\n+            print(\"interfaces: \");print(() -> classModel.interfaces().size());\n+            print(\", fields: \" + classModel.fields().size());\n+            print(\", methods: \" + classModel.methods().size());\n+            println(\", attributes: \" + classModel.attributes().size());\n@@ -267,1 +240,1 @@\n-        if (flags.is(AccessFlags.ACC_MODULE) && !options.verbose) {\n+        if ((cm.flags().flagsMask() & ACC_MODULE) != 0 && !options.verbose) {\n@@ -276,1 +249,1 @@\n-            attrWriter.write(cf, cf.attributes, constant_pool);\n+            attrWriter.write(classModel.attributes());\n@@ -278,0 +251,1 @@\n+        return !errorReported;\n@@ -280,5 +254,1 @@\n-        class JavaTypePrinter implements Type.Visitor<StringBuilder,StringBuilder> {\n-            boolean isInterface;\n-            JavaTypePrinter(boolean isInterface) {\n-                this.isInterface = isInterface;\n-            }\n+    final SignaturePrinter sigPrinter;\n@@ -287,3 +257,1 @@\n-            String print(Type t) {\n-                return t.accept(this, new StringBuilder()).toString();\n-            }\n+    public static record SignaturePrinter(boolean verbose) {\n@@ -291,4 +259,22 @@\n-            String printTypeArgs(List<? extends TypeParamType> typeParamTypes) {\n-                StringBuilder builder = new StringBuilder();\n-                appendIfNotEmpty(builder, \"<\", typeParamTypes, \"> \");\n-                return builder.toString();\n+        public String print(ClassSignature cs, boolean isInterface) {\n+            var sb = new StringBuilder();\n+            print(sb, cs.typeParameters());\n+            if (isInterface) {\n+                String sep = \" extends \";\n+                for (var is : cs.superinterfaceSignatures()) {\n+                    sb.append(sep);\n+                    print(sb, is);\n+                    sep = \", \";\n+                }\n+            } else {\n+                if (cs.superclassSignature() != null\n+                        && (verbose || !isObject(cs.superclassSignature()))) {\n+                    sb.append(\" extends \");\n+                    print(sb, cs.superclassSignature());\n+                }\n+                String sep = \" implements \";\n+                for (var is : cs.superinterfaceSignatures()) {\n+                    sb.append(sep);\n+                    print(sb, is);\n+                    sep = \", \";\n+                }\n@@ -296,0 +282,2 @@\n+            return sb.toString();\n+        }\n@@ -297,5 +285,5 @@\n-            @Override\n-            public StringBuilder visitSimpleType(SimpleType type, StringBuilder sb) {\n-                sb.append(getJavaName(type.name));\n-                return sb;\n-            }\n+        public String print(Signature sig) {\n+            var sb = new StringBuilder();\n+            print(sb, sig);\n+            return sb.toString();\n+        }\n@@ -303,6 +291,5 @@\n-            @Override\n-            public StringBuilder visitArrayType(ArrayType type, StringBuilder sb) {\n-                append(sb, type.elemType);\n-                sb.append(\"[]\");\n-                return sb;\n-            }\n+        public String printTypeParams(List<Signature.TypeParam> tps) {\n+            var sb = new StringBuilder();\n+            print(sb, tps);\n+            return sb.toString();\n+        }\n@@ -310,7 +297,9 @@\n-            @Override\n-            public StringBuilder visitMethodType(MethodType type, StringBuilder sb) {\n-                appendIfNotEmpty(sb, \"<\", type.typeParamTypes, \"> \");\n-                append(sb, type.returnType);\n-                append(sb, \" (\", type.paramTypes, \")\");\n-                appendIfNotEmpty(sb, \" throws \", type.throwsTypes, \"\");\n-                return sb;\n+        public String printList(String prefix, List<? extends Signature> args,\n+                String postfix) {\n+            var sb = new StringBuilder();\n+            sb.append(prefix);\n+            String sep = \"\";\n+            for (var arg : args) {\n+                sb.append(sep);\n+                print(sb, arg);\n+                sep = \", \";\n@@ -318,0 +307,2 @@\n+            return sb.append(postfix).toString();\n+        }\n@@ -319,10 +310,24 @@\n-            @Override\n-            public StringBuilder visitClassSigType(ClassSigType type, StringBuilder sb) {\n-                appendIfNotEmpty(sb, \"<\", type.typeParamTypes, \">\");\n-                if (isInterface) {\n-                    appendIfNotEmpty(sb, \" extends \", type.superinterfaceTypes, \"\");\n-                } else {\n-                    if (type.superclassType != null\n-                            && (options.verbose || !type.superclassType.isObject())) {\n-                        sb.append(\" extends \");\n-                        append(sb, type.superclassType);\n+        private boolean isObject(Signature sig) {\n+            return (sig instanceof Signature.ClassTypeSig cts)\n+                    && cts.outerType().isEmpty()\n+                    && cts.className().equals(\"java\/lang\/Object\")\n+                    && (cts.typeArgs().isEmpty());\n+        }\n+\n+        private void print(StringBuilder sb, List<Signature.TypeParam> tps) {\n+            if (!tps.isEmpty()) {\n+                sb.append('<');\n+                String sep = \"\";\n+                for (var tp : tps) {\n+                    sb.append(sep).append(tp.identifier());\n+                    sep = \" extends \";\n+                    if (tp.classBound().isPresent()\n+                            && (verbose || !isObject(tp.classBound().get()))) {\n+                        sb.append(sep);\n+                        print(sb, tp.classBound().get());\n+                        sep = \" & \";\n+                    }\n+                    for (var bound: tp.interfaceBounds()) {\n+                        sb.append(sep);\n+                        print(sb, bound);\n+                        sep = \" & \";\n@@ -330,1 +335,1 @@\n-                    appendIfNotEmpty(sb, \" implements \", type.superinterfaceTypes, \"\");\n+                    sep = \", \";\n@@ -332,1 +337,1 @@\n-                return sb;\n+                sb.append('>');\n@@ -334,0 +339,1 @@\n+        }\n@@ -335,4 +341,6 @@\n-            @Override\n-            public StringBuilder visitClassType(ClassType type, StringBuilder sb) {\n-                if (type.outerType != null) {\n-                    append(sb, type.outerType);\n+        private void print(StringBuilder sb, Signature sig) {\n+            if (sig instanceof Signature.BaseTypeSig bts) {\n+                    sb.append(ClassDesc.ofDescriptor(\"\" + bts.baseType()).displayName());\n+            } else if (sig instanceof Signature.ClassTypeSig cts) {\n+                if (cts.outerType().isPresent()) {\n+                    print(sb, cts.outerType().get());\n@@ -341,17 +349,5 @@\n-                sb.append(getJavaName(type.name));\n-                appendIfNotEmpty(sb, \"<\", type.typeArgs, \">\");\n-                return sb;\n-            }\n-\n-            @Override\n-            public StringBuilder visitTypeParamType(TypeParamType type, StringBuilder sb) {\n-                sb.append(type.name);\n-                String sep = \" extends \";\n-                if (type.classBound != null\n-                        && (options.verbose || !type.classBound.isObject())) {\n-                    sb.append(sep);\n-                    append(sb, type.classBound);\n-                    sep = \" & \";\n-                }\n-                if (type.interfaceBounds != null) {\n-                    for (Type bound: type.interfaceBounds) {\n+                sb.append(getJavaName(cts.className()));\n+                if (!cts.typeArgs().isEmpty()) {\n+                    String sep = \"\";\n+                    sb.append('<');\n+                    for (var ta : cts.typeArgs()) {\n@@ -359,2 +355,2 @@\n-                        append(sb, bound);\n-                        sep = \" & \";\n+                        print(sb, ta);\n+                        sep = \", \";\n@@ -362,0 +358,1 @@\n+                    sb.append('>');\n@@ -363,1 +360,5 @@\n-                return sb;\n+            } else if (sig instanceof Signature.TypeVarSig tvs) {\n+                sb.append(tvs.identifier());\n+            } else if (sig instanceof Signature.ArrayTypeSig ats) {\n+                print(sb, ats.componentSignature());\n+                sb.append(\"[]\");\n@@ -365,0 +366,1 @@\n+        }\n@@ -366,16 +368,7 @@\n-            @Override\n-            public StringBuilder visitWildcardType(WildcardType type, StringBuilder sb) {\n-                switch (type.kind) {\n-                    case UNBOUNDED:\n-                        sb.append(\"?\");\n-                        break;\n-                    case EXTENDS:\n-                        sb.append(\"? extends \");\n-                        append(sb, type.boundType);\n-                        break;\n-                    case SUPER:\n-                        sb.append(\"? super \");\n-                        append(sb, type.boundType);\n-                        break;\n-                    default:\n-                        throw new AssertionError();\n+        private void print(StringBuilder sb, Signature.TypeArg ta) {\n+            switch (ta.wildcardIndicator()) {\n+                case DEFAULT -> print(sb, ta.boundType().get());\n+                case UNBOUNDED -> sb.append('?');\n+                case EXTENDS -> {\n+                    sb.append(\"? extends \");\n+                    print(sb, ta.boundType().get());\n@@ -383,14 +376,3 @@\n-                return sb;\n-            }\n-\n-            private void append(StringBuilder sb, Type t) {\n-                t.accept(this, sb);\n-            }\n-\n-            private void append(StringBuilder sb, String prefix, List<? extends Type> list, String suffix) {\n-                sb.append(prefix);\n-                String sep = \"\";\n-                for (Type t: list) {\n-                    sb.append(sep);\n-                    append(sb, t);\n-                    sep = \", \";\n+                case SUPER -> {\n+                    sb.append(\"? super \");\n+                    print(sb, ta.boundType().get());\n@@ -398,10 +380,0 @@\n-                sb.append(suffix);\n-            }\n-\n-            private void appendIfNotEmpty(StringBuilder sb, String prefix, List<? extends Type> list, String suffix) {\n-                if (!isEmpty(list))\n-                    append(sb, prefix, list, suffix);\n-            }\n-\n-            private boolean isEmpty(List<? extends Type> list) {\n-                return (list == null || list.isEmpty());\n@@ -410,0 +382,1 @@\n+    }\n@@ -412,1 +385,1 @@\n-        for (Field f: classFile.fields) {\n+        for (var f: classModel.fields()) {\n@@ -417,2 +390,2 @@\n-    protected void writeField(Field f) {\n-        if (!options.checkAccess(f.access_flags))\n+    protected void writeField(FieldModel f) {\n+        if (!options.checkAccess(f.flags().flagsMask()))\n@@ -421,15 +394,7 @@\n-        AccessFlags flags = f.access_flags;\n-        writeModifiers(flags.getFieldModifiers());\n-        Signature_attribute sigAttr = getSignature(f.attributes);\n-        if (sigAttr == null)\n-            print(getJavaFieldType(f.descriptor));\n-        else {\n-            try {\n-                Type t = sigAttr.getParsedSignature().getType(constant_pool);\n-                print(getJavaName(t.toString()));\n-            } catch (ConstantPoolException e) {\n-                \/\/ report error?\n-                \/\/ fall back on non-generic descriptor\n-                print(getJavaFieldType(f.descriptor));\n-            }\n-        }\n+        var flags = AccessFlags.ofField(f.flags().flagsMask());\n+        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+                .map(fl -> Modifier.toString(fl.mask())).toList());\n+        print(() -> sigPrinter.print(\n+                f.findAttribute(Attributes.SIGNATURE)\n+                        .map(SignatureAttribute::asTypeSignature)\n+                        .orElseGet(() -> Signature.of(f.fieldTypeSymbol()))));\n@@ -437,1 +402,1 @@\n-        print(getFieldName(f));\n+        print(() -> f.fieldName().stringValue());\n@@ -439,2 +404,2 @@\n-            Attribute a = f.attributes.get(Attribute.ConstantValue);\n-            if (a instanceof ConstantValue_attribute) {\n+            var a = f.findAttribute(Attributes.CONSTANT_VALUE);\n+            if (a.isPresent()) {\n@@ -442,2 +407,2 @@\n-                ConstantValue_attribute cv = (ConstantValue_attribute) a;\n-                print(getConstantValue(f.descriptor, cv.constantvalue_index));\n+                var cv = a.get();\n+                print(() -> getConstantValue(f.fieldTypeSymbol(), cv.constant()));\n@@ -453,2 +418,3 @@\n-        if (options.showDescriptors)\n-            println(\"descriptor: \" + getValue(f.descriptor));\n+        if (options.showDescriptors) {\n+            print(\"descriptor: \");println(() -> f.fieldType().stringValue());\n+        }\n@@ -457,1 +423,3 @@\n-            writeList(String.format(\"flags: (0x%04x) \", flags.flags), flags.getFieldFlags(), \"\\n\");\n+            writeList(String.format(\"flags: (0x%04x) \", flags.flagsMask()),\n+                    flags.flags().stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    \"\\n\");\n@@ -460,2 +428,1 @@\n-            for (Attribute attr: f.attributes)\n-                attrWriter.write(f, attr, constant_pool);\n+            attrWriter.write(f.attributes());\n@@ -472,1 +439,1 @@\n-        for (Method m: classFile.methods)\n+        for (MethodModel m: classModel.methods())\n@@ -480,2 +447,2 @@\n-    protected void writeMethod(Method m) {\n-        if (!options.checkAccess(m.access_flags))\n+    protected void writeMethod(MethodModel m) {\n+        if (!options.checkAccess(m.flags().flagsMask()))\n@@ -486,1 +453,1 @@\n-        AccessFlags flags = m.access_flags;\n+        int flags = m.flags().flagsMask();\n@@ -488,3 +455,3 @@\n-        Descriptor d;\n-        Type.MethodType methodType;\n-        List<? extends Type> methodExceptions;\n+        var modifiers = new ArrayList<String>();\n+        for (var f : AccessFlags.ofMethod(flags).flags())\n+            if (f.sourceModifier()) modifiers.add(Modifier.toString(f.mask()));\n@@ -492,19 +459,5 @@\n-        Signature_attribute sigAttr = getSignature(m.attributes);\n-        if (sigAttr == null) {\n-            d = m.descriptor;\n-            methodType = null;\n-            methodExceptions = null;\n-        } else {\n-            Signature methodSig = sigAttr.getParsedSignature();\n-            d = methodSig;\n-            try {\n-                methodType = (Type.MethodType) methodSig.getType(constant_pool);\n-                methodExceptions = methodType.throwsTypes;\n-                if (methodExceptions != null && methodExceptions.isEmpty())\n-                    methodExceptions = null;\n-            } catch (ConstantPoolException | IllegalStateException e) {\n-                \/\/ report error?\n-                \/\/ fall back on standard descriptor\n-                methodType = null;\n-                methodExceptions = null;\n-            }\n+        String name = \"???\";\n+        try {\n+            name = m.methodName().stringValue();\n+        } catch (IllegalArgumentException e) {\n+            report(e);\n@@ -513,8 +466,6 @@\n-        Set<String> modifiers = flags.getMethodModifiers();\n-\n-        String name = getName(m);\n-        if (classFile.isInterface() &&\n-                (!flags.is(AccessFlags.ACC_ABSTRACT)) && !name.equals(\"<clinit>\")) {\n-            if (classFile.major_version > DEFAULT_ALLOWED_MAJOR_VERSION ||\n-                    (classFile.major_version == DEFAULT_ALLOWED_MAJOR_VERSION && classFile.minor_version >= DEFAULT_ALLOWED_MINOR_VERSION)) {\n-                if (!flags.is(AccessFlags.ACC_STATIC | AccessFlags.ACC_PRIVATE)) {\n+        if ((classModel.flags().flagsMask() & ACC_INTERFACE) != 0 &&\n+                ((flags & ACC_ABSTRACT) == 0) && !name.equals(\"<clinit>\")) {\n+            if (classModel.majorVersion() > DEFAULT_ALLOWED_MAJOR_VERSION ||\n+                    (classModel.majorVersion() == DEFAULT_ALLOWED_MAJOR_VERSION\n+                    && classModel.minorVersion() >= DEFAULT_ALLOWED_MINOR_VERSION)) {\n+                if ((flags & (ACC_STATIC | ACC_PRIVATE)) == 0) {\n@@ -525,10 +476,29 @@\n-\n-        if (methodType != null) {\n-            print(new JavaTypePrinter(false).printTypeArgs(methodType.typeParamTypes));\n-        }\n-        switch (name) {\n-            case \"<init>\":\n-            case \"<vnew>\":\n-                String returnType = getJavaReturnType(d);\n-                if (!returnType.equals(\"void\")) { \/\/ static factories for primitive classes\n-                    print(returnType);\n+\n+        try {\n+            var sigAttr = m.findAttribute(Attributes.SIGNATURE);\n+            MethodSignature d;\n+            if (sigAttr.isEmpty()) {\n+                d = MethodSignature.parseFrom(m.methodType().stringValue());\n+            } else {\n+                d = sigAttr.get().asMethodSignature();\n+            }\n+\n+            if (!d.typeParameters().isEmpty()) {\n+                print(sigPrinter.printTypeParams(d.typeParameters()) + \" \");\n+            }\n+            switch (name) {\n+                case \"<init>\":\n+                case \"<vnew>\":\n+                    String returnType = getJavaName(sigPrinter.print(d.result()));\n+                    if (!returnType.equals(\"void\")) { \/\/ static factories for primitive classes\n+                        print(returnType);\n+                        print(\" \");\n+                    }\n+                    print(getJavaName(classModel.thisClass().asInternalName()));\n+                    print(getJavaParameterTypes(d, flags));\n+                    break;\n+                case \"<clinit>\":\n+                    print(\"{}\");\n+                    break;\n+                default:\n+                    print(getJavaName(sigPrinter.print(d.result())));\n@@ -537,14 +507,4 @@\n-                }\n-                print(getJavaName(classFile));\n-                print(getJavaParameterTypes(d, flags));\n-                break;\n-            case \"<clinit>\":\n-                print(\"{}\");\n-                break;\n-            default:\n-                print(getJavaReturnType(d));\n-                print(\" \");\n-                print(name);\n-                print(getJavaParameterTypes(d, flags));\n-                break;\n-        }\n+                    print(name);\n+                    print(getJavaParameterTypes(d, flags));\n+                    break;\n+            }\n@@ -552,4 +512,4 @@\n-        Attribute e_attr = m.attributes.get(Attribute.Exceptions);\n-        if (e_attr != null) { \/\/ if there are generic exceptions, there must be erased exceptions\n-            if (e_attr instanceof Exceptions_attribute) {\n-                Exceptions_attribute exceptions = (Exceptions_attribute) e_attr;\n+            var e_attr = m.findAttribute(Attributes.EXCEPTIONS);\n+            \/\/ if there are generic exceptions, there must be erased exceptions\n+            if (e_attr.isPresent()) {\n+                var exceptions = e_attr.get();\n@@ -557,2 +517,2 @@\n-                if (methodExceptions != null) { \/\/ use generic list if available\n-                    writeList(\"\", methodExceptions, \"\");\n+                if (d != null && !d.throwableSignatures().isEmpty()) { \/\/ use generic list if available\n+                    print(() -> sigPrinter.printList(\"\", d.throwableSignatures(), \"\"));\n@@ -560,1 +520,2 @@\n-                    for (int i = 0; i < exceptions.number_of_exceptions; i++) {\n+                    var exNames = exceptions.exceptions();\n+                    for (int i = 0; i < exNames.size(); i++) {\n@@ -563,1 +524,2 @@\n-                        print(getJavaException(exceptions, i));\n+                        int ii = i;\n+                        print(() -> getJavaName(exNames.get(ii).asInternalName()));\n@@ -566,2 +528,2 @@\n-            } else {\n-                report(\"Unexpected or invalid value for Exceptions attribute\");\n+        } catch (IllegalArgumentException e) {\n+            report(e);\n@@ -576,1 +538,1 @@\n-            println(\"descriptor: \" + getValue(m.descriptor));\n+            print(\"descriptor: \");println(() -> m.methodType().stringValue());\n@@ -580,1 +542,8 @@\n-            writeList(String.format(\"flags: (0x%04x) \", flags.flags), flags.getMethodFlags(), \"\\n\");\n+            StringBuilder sb = new StringBuilder();\n+            String sep = \"\";\n+            sb.append(String.format(\"flags: (0x%04x) \", flags));\n+            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+                sb.append(sep).append(\"ACC_\").append(f.name());\n+                sep = \", \";\n+            }\n+            println(sb.toString());\n@@ -583,8 +552,1 @@\n-        Code_attribute code = null;\n-        Attribute c_attr = m.attributes.get(Attribute.Code);\n-        if (c_attr != null) {\n-            if (c_attr instanceof Code_attribute)\n-                code = (Code_attribute) c_attr;\n-            else\n-                report(\"Unexpected or invalid value for Code attribute\");\n-        }\n+        var code = (CodeAttribute)m.code().orElse(null);\n@@ -593,3 +555,1 @@\n-            Attribute[] attrs = m.attributes.attrs;\n-            for (Attribute attr: attrs)\n-                attrWriter.write(m, attr, constant_pool);\n+            attrWriter.write(m.attributes());\n@@ -604,2 +564,4 @@\n-                attrWriter.write(code, code.attributes.get(Attribute.LineNumberTable), constant_pool);\n-                attrWriter.write(code, code.attributes.get(Attribute.LocalVariableTable), constant_pool);\n+                code.findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                        .ifPresent(a -> attrWriter.write(a, code));\n+                code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE)\n+                        .ifPresent(a -> attrWriter.write(a, code));\n@@ -628,0 +590,3 @@\n+    public static final int ACC_TRANSITIVE = 0x0020;\n+    public static final int ACC_STATIC_PHASE = 0x0040;\n+\n@@ -629,2 +594,2 @@\n-        Attribute attr = classFile.attributes.get(Attribute.Module);\n-        if (!(attr instanceof Module_attribute))\n+        var attr = classModel.findAttribute(Attributes.MODULE);\n+        if (attr.isEmpty())\n@@ -633,2 +598,2 @@\n-        Module_attribute m = (Module_attribute) attr;\n-        for (Module_attribute.RequiresEntry entry: m.requires) {\n+        var m = attr.get();\n+        for (var entry: m.requires()) {\n@@ -636,1 +601,1 @@\n-            if ((entry.requires_flags & Module_attribute.ACC_STATIC_PHASE) != 0)\n+            if ((entry.requiresFlagsMask() & ACC_STATIC_PHASE) != 0)\n@@ -638,1 +603,1 @@\n-            if ((entry.requires_flags & Module_attribute.ACC_TRANSITIVE) != 0)\n+            if ((entry.requiresFlagsMask() & ACC_TRANSITIVE) != 0)\n@@ -642,6 +607,1 @@\n-            try {\n-                mname = getModuleName(entry.requires_index);\n-            } catch (ConstantPoolException e) {\n-                mname = report(e);\n-            }\n-            print(mname);\n+            print(entry.requires().name().stringValue());\n@@ -651,1 +611,1 @@\n-        for (Module_attribute.ExportsEntry entry: m.exports) {\n+        for (var entry: m.exports()) {\n@@ -654,7 +614,1 @@\n-            String pname;\n-            try {\n-                pname = getPackageName(entry.exports_index).replace('\/', '.');\n-            } catch (ConstantPoolException e) {\n-                pname = report(e);\n-            }\n-            print(pname);\n+            print(entry.exportedPackage().name().stringValue().replace('\/', '.'));\n@@ -662,7 +616,1 @@\n-            for (int i: entry.exports_to_index) {\n-                String mname;\n-                try {\n-                    mname = getModuleName(i);\n-                } catch (ConstantPoolException e) {\n-                    mname = report(e);\n-                }\n+            for (var mod: entry.exportsTo()) {\n@@ -676,1 +624,1 @@\n-                print(mname);\n+                print(mod.name().stringValue());\n@@ -683,1 +631,1 @@\n-        for (Module_attribute.OpensEntry entry: m.opens) {\n+        for (var entry: m.opens()) {\n@@ -686,7 +634,1 @@\n-            String pname;\n-            try {\n-                pname = getPackageName(entry.opens_index).replace('\/', '.');\n-            } catch (ConstantPoolException e) {\n-                pname = report(e);\n-            }\n-            print(pname);\n+            print(entry.openedPackage().name().stringValue().replace('\/', '.'));\n@@ -694,7 +636,1 @@\n-            for (int i: entry.opens_to_index) {\n-                String mname;\n-                try {\n-                    mname = getModuleName(i);\n-                } catch (ConstantPoolException e) {\n-                    mname = report(e);\n-                }\n+            for (var mod: entry.opensTo()) {\n@@ -708,1 +644,1 @@\n-                print(mname);\n+                print(mod.name().stringValue());\n@@ -715,1 +651,1 @@\n-        for (int entry: m.uses_index) {\n+        for (var entry: m.uses()) {\n@@ -717,1 +653,1 @@\n-            print(getClassName(entry).replace('\/', '.'));\n+            print(entry.asInternalName().replace('\/', '.'));\n@@ -721,1 +657,1 @@\n-        for (Module_attribute.ProvidesEntry entry: m.provides) {\n+        for (var entry: m.provides()) {\n@@ -723,1 +659,1 @@\n-            print(getClassName(entry.provides_index).replace('\/', '.'));\n+            print(entry.provides().asInternalName().replace('\/', '.'));\n@@ -725,1 +661,1 @@\n-            for (int i: entry.with_index) {\n+            for (var ce: entry.providesWith()) {\n@@ -733,1 +669,1 @@\n-                print(getClassName(i).replace('\/', '.'));\n+                print(ce.asInternalName().replace('\/', '.'));\n@@ -741,32 +677,0 @@\n-    String getModuleName(int index) throws ConstantPoolException {\n-        if (constant_pool.get(index).getTag() == CONSTANT_Module) {\n-            return constant_pool.getModuleInfo(index).getName();\n-        } else {\n-            return constant_pool.getUTF8Value(index);\n-        }\n-    }\n-\n-    String getPackageName(int index) throws ConstantPoolException {\n-        if (constant_pool.get(index).getTag() == CONSTANT_Package) {\n-            return constant_pool.getPackageInfo(index).getName();\n-        } else {\n-            return constant_pool.getUTF8Value(index);\n-        }\n-    }\n-\n-    String getUTF8Value(int index) {\n-        try {\n-            return classFile.constant_pool.getUTF8Value(index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getClassName(int index) {\n-        try {\n-            return classFile.constant_pool.getClassInfo(index).getName();\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n@@ -789,6 +693,2 @@\n-    Signature_attribute getSignature(Attributes attributes) {\n-        return (Signature_attribute) attributes.get(Attribute.Signature);\n-    }\n-\n-    String adjustVarargs(AccessFlags flags, String params) {\n-        if (flags.is(ACC_VARARGS)) {\n+    String adjustVarargs(int flags, String params) {\n+        if ((flags & ACC_VARARGS) != 0) {\n@@ -803,84 +703,3 @@\n-    String getJavaName(ClassFile cf) {\n-        try {\n-            return getJavaName(cf.getName());\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaSuperclassName(ClassFile cf) {\n-        try {\n-            return getJavaName(cf.getSuperclassName());\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaInterfaceName(ClassFile cf, int index) {\n-        try {\n-            return getJavaName(cf.getInterfaceName(index));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaFieldType(Descriptor d) {\n-        try {\n-            return getJavaName(d.getFieldType(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaReturnType(Descriptor d) {\n-        try {\n-            return getJavaName(d.getReturnType(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaParameterTypes(Descriptor d, AccessFlags flags) {\n-        try {\n-            return getJavaName(adjustVarargs(flags, d.getParameterTypes(constant_pool)));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaException(Exceptions_attribute attr, int index) {\n-        try {\n-            return getJavaName(attr.getException(index, constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getValue(Descriptor d) {\n-        try {\n-            return d.getValue(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getFieldName(Field f) {\n-        try {\n-            return f.getName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getName(Method m) {\n-        try {\n-            return m.getName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n+    String getJavaParameterTypes(MethodSignature d, int flags) {\n+        return getJavaName(adjustVarargs(flags,\n+                sigPrinter.printList(\"(\", d.arguments(), \")\")));\n@@ -893,8 +712,0 @@\n-    String getSourceFile(SourceFile_attribute attr) {\n-        try {\n-            return attr.getSourceFile(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n@@ -910,26 +721,14 @@\n-    String getConstantValue(Descriptor d, int index) {\n-        try {\n-            ConstantPool.CPInfo cpInfo = constant_pool.get(index);\n-\n-            switch (cpInfo.getTag()) {\n-                case ConstantPool.CONSTANT_Integer: {\n-                    ConstantPool.CONSTANT_Integer_info info =\n-                            (ConstantPool.CONSTANT_Integer_info) cpInfo;\n-                    String t = d.getValue(constant_pool);\n-                    switch (t) {\n-                        case \"C\":\n-                            \/\/ character\n-                            return getConstantCharValue((char) info.value);\n-                        case \"Z\":\n-                            \/\/ boolean\n-                            return String.valueOf(info.value == 1);\n-                        default:\n-                            \/\/ other: assume integer\n-                            return String.valueOf(info.value);\n-                    }\n-                }\n-\n-                case ConstantPool.CONSTANT_String: {\n-                    ConstantPool.CONSTANT_String_info info =\n-                            (ConstantPool.CONSTANT_String_info) cpInfo;\n-                    return getConstantStringValue(info.getString());\n+    String getConstantValue(ClassDesc d, ConstantValueEntry cpInfo) {\n+        switch (cpInfo.tag()) {\n+            case Classfile.TAG_INTEGER: {\n+                var val = (Integer)cpInfo.constantValue();\n+                switch (d.descriptorString()) {\n+                    case \"C\":\n+                        \/\/ character\n+                        return getConstantCharValue((char)val.intValue());\n+                    case \"Z\":\n+                        \/\/ boolean\n+                        return String.valueOf(val == 1);\n+                    default:\n+                        \/\/ other: assume integer\n+                        return String.valueOf(val);\n@@ -937,5 +736,4 @@\n-\n-                default:\n-                    return constantWriter.stringValue(cpInfo);\n-        } catch (ConstantPoolException e) {\n-            return \"#\" + index;\n+            case Classfile.TAG_STRING:\n+                return getConstantStringValue(cpInfo.constantValue().toString());\n+            default:\n+                return constantWriter.stringValue(cpInfo);\n@@ -980,0 +778,82 @@\n+    private static Set<String> getClassModifiers(int mask) {\n+        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask).flags());\n+    }\n+\n+    private static Set<String> getMethodModifiers(int mask) {\n+        return getModifiers(AccessFlags.ofMethod(mask).flags());\n+    }\n+\n+    private static Set<String> getFieldModifiers(int mask) {\n+        return getModifiers(AccessFlags.ofField(mask).flags());\n+    }\n+\n+    private static Set<String> getModifiers(Set<java.lang.reflect.AccessFlag> flags) {\n+        Set<String> s = new LinkedHashSet<>();\n+        for (var f : flags)\n+            if (f.sourceModifier()) s.add(Modifier.toString(f.mask()));\n+        return s;\n+    }\n+\n+    private static Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+    }\n+\n+    private static Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+    }\n+\n+    private static Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+    }\n+\n+    private static Set<String> getFlags(int mask, Set<java.lang.reflect.AccessFlag> flags) {\n+        Set<String> s = new LinkedHashSet<>();\n+        for (var f: flags) {\n+            s.add(\"ACC_\" + f.name());\n+            mask = mask & ~f.mask();\n+        }\n+        while (mask != 0) {\n+            int bit = Integer.highestOneBit(mask);\n+            s.add(\"0x\" + Integer.toHexString(bit));\n+            mask = mask & ~bit;\n+        }\n+        return s;\n+    }\n+\n+    public static enum AccessFlag {\n+        ACC_PUBLIC      (Classfile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n+        ACC_PRIVATE     (Classfile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n+        ACC_PROTECTED   (Classfile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n+        ACC_STATIC      (Classfile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n+        ACC_FINAL       (Classfile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n+        ACC_SUPER       (Classfile.ACC_SUPER,        null,           true,  false, false, false),\n+        ACC_SYNCHRONIZED(Classfile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n+        ACC_VOLATILE    (Classfile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n+        ACC_BRIDGE      (Classfile.ACC_BRIDGE,       null,           false, false, false, true ),\n+        ACC_TRANSIENT   (Classfile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n+        ACC_VARARGS     (Classfile.ACC_VARARGS,      null,           false, false, false, true ),\n+        ACC_NATIVE      (Classfile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n+        ACC_INTERFACE   (Classfile.ACC_INTERFACE,    null,           true,   true, false, false),\n+        ACC_ABSTRACT    (Classfile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n+        ACC_STRICT      (Classfile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n+        ACC_SYNTHETIC   (Classfile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n+        ACC_ANNOTATION  (Classfile.ACC_ANNOTATION,   null,           true,   true, false, false),\n+        ACC_ENUM        (Classfile.ACC_ENUM,         null,           true,   true, true,  false),\n+        ACC_MODULE      (Classfile.ACC_MODULE,       null,           true,  false, false, false);\n+\n+        public final int flag;\n+        public final String modifier;\n+        public final boolean isClass, isInnerClass, isField, isMethod;\n+\n+        AccessFlag(int flag, String modifier, boolean isClass,\n+                boolean isInnerClass, boolean isField, boolean isMethod) {\n+            this.flag = flag;\n+            this.modifier = modifier;\n+            this.isClass = isClass;\n+            this.isInnerClass = isInnerClass;\n+            this.isField = isField;\n+            this.isMethod = isMethod;\n+        }\n+    }\n+\n@@ -984,1 +864,1 @@\n-    private ClassFile classFile;\n+    private ClassModel classModel;\n@@ -990,2 +870,1 @@\n-    private ConstantPool constant_pool;\n-    private Method method;\n+    private MethodModel method;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":425,"deletions":546,"binary":false,"changes":971,"status":"modified"},{"patch":"@@ -739,36 +739,0 @@\n-    \/**\n-     * Detects if the given class may need to be initialized. This is often\n-     * needed in conjunction with obtaining the static field base of a\n-     * class.\n-     *\n-     * @deprecated No replacement API for this method.  As multiple threads\n-     * may be trying to initialize the same class or interface at the same time.\n-     * The only reliable result returned by this method is {@code false}\n-     * indicating that the given class has been initialized.  Instead, simply\n-     * call {@link java.lang.invoke.MethodHandles.Lookup#ensureInitialized(Class)}\n-     * that does nothing if the given class has already been initialized.\n-     * This method is subject to removal in a future version of JDK.\n-     *\n-     * @return false only if a call to {@code ensureClassInitialized} would have no effect\n-     *\n-     *\/\n-    @Deprecated(since = \"15\", forRemoval = true)\n-    @ForceInline\n-    public boolean shouldBeInitialized(Class<?> c) {\n-        return theInternalUnsafe.shouldBeInitialized(c);\n-    }\n-\n-    \/**\n-     * Ensures the given class has been initialized. This is often\n-     * needed in conjunction with obtaining the static field base of a\n-     * class.\n-     *\n-     * @deprecated Use the {@link java.lang.invoke.MethodHandles.Lookup#ensureInitialized(Class)}\n-     * method instead.  This method is subject to removal in a future version of JDK.\n-     *\/\n-    @Deprecated(since = \"15\", forRemoval = true)\n-    @ForceInline\n-    public void ensureClassInitialized(Class<?> c) {\n-        theInternalUnsafe.ensureClassInitialized(c);\n-    }\n-\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-containers\/docker\/TestMemoryAwareness.java 8303470 linux-x64\n+containers\/docker\/TestMemoryAwareness.java 8303470 linux-all\n@@ -139,0 +139,1 @@\n+serviceability\/sa\/ClhsdbDumpclass.java 8316342 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+java\/awt\/Mouse\/EnterExitEvents\/DragWindowTest.java 8298823 macosx-all\n@@ -537,0 +538,7 @@\n+java\/net\/DatagramSocket\/DatagramSocketExample.java              8308807 aix-ppc64\n+java\/net\/DatagramSocket\/DatagramSocketMulticasting.java         8308807 aix-ppc64\n+\n+java\/net\/MulticastSocket\/B6427403.java                          8308807 aix-ppc64\n+java\/net\/MulticastSocket\/IPMulticastIF.java                     8308807 aix-ppc64\n+java\/net\/MulticastSocket\/JoinLeave.java                         8308807 aix-ppc64\n+java\/net\/MulticastSocket\/MulticastAddresses.java                8308807 aix-ppc64\n@@ -538,0 +546,3 @@\n+java\/net\/MulticastSocket\/NoSetNetworkInterface.java             8308807 aix-ppc64\n+java\/net\/MulticastSocket\/Promiscuous.java                       8308807 aix-ppc64\n+java\/net\/MulticastSocket\/SetGetNetworkInterfaceTest.java        8308807 aix-ppc64\n@@ -539,1 +550,1 @@\n-\n+java\/net\/MulticastSocket\/SetOutgoingIf.java                     8308807 aix-ppc64\n@@ -544,3 +555,0 @@\n-java\/net\/MulticastSocket\/B6427403.java                          8308807 aix-ppc64\n-java\/net\/MulticastSocket\/SetOutgoingIf.java                     8308807 aix-ppc64\n-\n@@ -553,0 +561,1 @@\n+java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java      8308807 aix-ppc64\n@@ -554,2 +563,0 @@\n-\n-\n@@ -729,2 +736,0 @@\n-sun\/tools\/jstatd\/TestJstatdDefaults.java                        8081569 windows-all\n-sun\/tools\/jstatd\/TestJstatdServer.java                          8081569 windows-all\n@@ -738,2 +743,0 @@\n-sun\/tools\/jhsdb\/JStackStressTest.java                           8276210 linux-aarch64\n-\n@@ -752,0 +755,1 @@\n+jdk\/jfr\/event\/runtime\/TestResidentSetSizeEvent.java             8309846 aix-ppc64\n","filename":"test\/jdk\/ProblemList.txt","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -505,0 +505,1 @@\n+                    case PreloadAttribute a -> clb.with(PreloadAttribute.ofSymbols(a.preloads().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new)));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -500,2 +500,2 @@\n-            for (int i = 1; i < cm.constantPool().entryCount(); ++i) {\n-                if (cm.constantPool().entryByIndex(i) instanceof Utf8Entry entry) {\n+            for (PoolEntry pe : cm.constantPool()) {\n+                if (pe instanceof Utf8Entry entry) {\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1279,2 +1279,2 @@\n-                    for (int i = 1; i < classFile.constantPool().entryCount(); ++i) {\n-                        if (classFile.constantPool().entryByIndex(i) instanceof FieldRefEntry fieldRefEntry) {\n+                    for (PoolEntry pe : classFile.constantPool()) {\n+                        if (pe instanceof FieldRefEntry fieldRefEntry) {\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,0 +143,6 @@\n+  private native Object[] getResolvedReferences0(Class<?> aClass);\n+  public         Object[] getResolvedReferences(Class<?> aClass) {\n+    Objects.requireNonNull(aClass);\n+    return getResolvedReferences0(aClass);\n+  }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}