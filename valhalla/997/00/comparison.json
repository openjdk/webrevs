{"files":[{"patch":"@@ -1093,0 +1093,1 @@\n+  bool deoptimize_for_null_free = false;\n@@ -1137,0 +1138,5 @@\n+    \/\/ The field we are patching is null-free. Deoptimize and regenerate\n+    \/\/ the compiled code if we patch a putfield\/putstatic because it\n+    \/\/ does not contain the required null check.\n+    deoptimize_for_null_free = result.is_null_free_inline_type() && (field_access.is_putfield() || field_access.is_putstatic());\n+\n@@ -1227,1 +1233,1 @@\n-  if (deoptimize_for_volatile || deoptimize_for_atomic || deoptimize_for_flat) {\n+  if (deoptimize_for_volatile || deoptimize_for_atomic || deoptimize_for_null_free || deoptimize_for_flat) {\n@@ -1238,0 +1244,3 @@\n+      if (deoptimize_for_null_free) {\n+        tty->print_cr(\"Deoptimizing for patching null-free field reference\");\n+      }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1059,0 +1059,24 @@\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue28 {\n+        @NullRestricted\n+        static MyValue28 field1;\n+    }\n+\n+    \/\/ Test null store to null restricted field with unloaded holder\n+    @Test\n+    public static void test28() {\n+        MyValue28.field1 = null;\n+    }\n+\n+    @Run(test = \"test28\")\n+    @Warmup(0) \/\/ Make sure that MyValue28 is not loaded\n+    public void test28_verifier() {\n+        try {\n+            test28();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}