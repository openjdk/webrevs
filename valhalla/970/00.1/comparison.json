{"files":[{"patch":"@@ -108,1 +108,1 @@\n-    -XDenableValueTypes \\\n+    -XDenableValueTypes -XDenablePrimitiveClasses \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2352,7 +2352,1 @@\n-  \/\/ The MaxVectorSize should have been set by detecting SVE max vector register size.\n-  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n-  \/\/ Minimum 2 values in vector\n-  if (size < 2*type2aelembytes(bt)) size = 0;\n-  \/\/ But never < 4\n-  if (size < 4) size = 0;\n-  return size;\n+  return max_vector_size(bt) * type2aelembytes(bt);\n@@ -2363,1 +2357,1 @@\n-  return vector_width_in_bytes(bt)\/type2aelembytes(bt);\n+  return VM_Version::max_vector_size(bt);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -650,0 +650,14 @@\n+\n+int VM_Version::max_vector_size(BasicType bt) {\n+  \/\/ The MaxVectorSize should have been set by detecting SVE max vector register size.\n+#ifdef COMPILER2\n+  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n+  \/\/ Minimum 2 values in vector\n+  if (size < 2*type2aelembytes(bt)) size = 0;\n+  \/\/ But never < 4\n+  if (size < 4) size = 0;\n+  return size \/ type2aelembytes(bt);\n+#else\n+  return -1;\n+#endif\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -111,0 +111,3 @@\n+  \/\/ Max supported vector lane count for a particular lane type.\n+  static int max_vector_size(BasicType bt);\n+\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2215,7 +2215,1 @@\n-  if (SuperwordUseVSX) {\n-    assert(MaxVectorSize == 16, \"\");\n-    return 16;\n-  } else {\n-    assert(MaxVectorSize == 8, \"\");\n-    return 8;\n-  }\n+  return max_vector_size(bt) * type2aelembytes(bt);\n@@ -2238,1 +2232,1 @@\n-  return vector_width_in_bytes(bt)\/type2aelembytes(bt);\n+  return VM_Version::max_vector_size(bt);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -705,0 +705,16 @@\n+\n+int VM_Version::max_vector_size(BasicType bt) {\n+#ifdef COMPILER2\n+  int size = 0;\n+  if (SuperwordUseVSX) {\n+    assert(MaxVectorSize == 16, \"\");\n+    size = 16;\n+  } else {\n+    assert(MaxVectorSize == 8, \"\");\n+    size = 8;\n+  }\n+  return size \/ type2aelembytes(bt);\n+#else\n+  return -1;\n+#endif\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1963,11 +1963,1 @@\n-  if (UseRVV) {\n-    \/\/ The MaxVectorSize should have been set by detecting RVV max vector register size when check UseRVV.\n-    \/\/ MaxVectorSize == VM_Version::_initial_vector_length\n-    int size = MaxVectorSize;\n-    \/\/ Minimum 2 values in vector\n-    if (size < 2 * type2aelembytes(bt)) size = 0;\n-    \/\/ But never < 4\n-    if (size < 4) size = 0;\n-    return size;\n-  }\n-  return 0;\n+  return max_vector_size(bt) * type2aelembytes(bt);\n@@ -1978,1 +1968,1 @@\n-  return vector_width_in_bytes(bt) \/ type2aelembytes(bt);\n+  return VM_Version::max_vector_size(bt);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -370,0 +370,18 @@\n+\n+int VM_Version::max_vector_size(BasicType bt) {\n+#ifdef COMPILER2\n+  if (UseRVV) {\n+    \/\/ The MaxVectorSize should have been set by detecting RVV max vector register size when check UseRVV.\n+    \/\/ MaxVectorSize == VM_Version::_initial_vector_length\n+    int size = MaxVectorSize;\n+    \/\/ Minimum 2 values in vector\n+    if (size < 2 * type2aelembytes(bt)) size = 0;\n+    \/\/ But never < 4\n+    if (size < 4) size = 0;\n+    return size \/ type2aelembytes(bt);\n+  }\n+  return 0;\n+#else\n+  return -1;\n+#endif\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -211,0 +211,3 @@\n+\n+  \/\/ Max supported vector lane count for a particular lane type.\n+  static int max_vector_size(BasicType bt);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1557,2 +1557,1 @@\n-  assert(MaxVectorSize == 8, \"\");\n-  return 8;\n+  return max_vector_size(bt) * type2aelembytes(bt);\n@@ -1570,1 +1569,1 @@\n-  return vector_width_in_bytes(bt)\/type2aelembytes(bt);\n+  return VM_Version::max_vector_size(bt);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1517,0 +1517,9 @@\n+\n+int VM_Version::max_vector_size(BasicType bt) {\n+#ifdef COMPILER2\n+  assert(MaxVectorSize == 8, \"\");\n+  return MaxVectorSize \/ type2aelembytes(bt);\n+#else\n+  return -1;\n+#endif\n+}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -570,0 +570,4 @@\n+\n+  \/\/ Max supported vector lane count for a particular lane type.\n+  static int max_vector_size(BasicType bt);\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1187,0 +1187,8 @@\n+    \/\/ Skip scalarization for vector value objects (concrete vectors and payloads).\n+    load_klass(rdi, rax, rscratch1);\n+    movptr(rscratch1, rax);\n+    super_call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::skip_value_scalarization), rdi);\n+    testptr(rax, rax);\n+    movptr(rax, rscratch1);\n+    jcc(Assembler::notZero, skip);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3219,0 +3219,48 @@\n+\/\/ Max vector size in bytes. 0 if not supported.\n+int VM_Version::max_vector_size(BasicType bt) {\n+#ifdef COMPILER2_OR_JVMCI\n+  assert(is_java_primitive(bt), \"only primitive type vectors\");\n+  if (UseSSE < 2) return 0;\n+  \/\/ SSE2 supports 128bit vectors for all types.\n+  \/\/ AVX2 supports 256bit vectors for all types.\n+  \/\/ AVX2\/EVEX supports 512bit vectors for all types.\n+  int size = (UseAVX > 1) ? (1 << UseAVX) * 8 : 16;\n+  \/\/ AVX1 supports 256bit vectors only for FLOAT and DOUBLE.\n+  if (UseAVX > 0 && (bt == T_FLOAT || bt == T_DOUBLE))\n+    size = (UseAVX > 2) ? 64 : 32;\n+  if (UseAVX > 2 && (bt == T_BYTE || bt == T_SHORT || bt == T_CHAR))\n+    size = (VM_Version::supports_avx512bw()) ? 64 : 32;\n+  \/\/ Use flag to limit vector size.\n+  size = MIN2(size,(int)MaxVectorSize);\n+  \/\/ Minimum 2 values in vector (or 4 for bytes).\n+  switch (bt) {\n+  case T_DOUBLE:\n+  case T_LONG:\n+    if (size < 16) return 0;\n+    break;\n+  case T_FLOAT:\n+  case T_INT:\n+    if (size < 8) return 0;\n+    break;\n+  case T_BOOLEAN:\n+    if (size < 4) return 0;\n+    break;\n+  case T_CHAR:\n+    if (size < 4) return 0;\n+    break;\n+  case T_BYTE:\n+    if (size < 4) return 0;\n+    break;\n+  case T_SHORT:\n+    if (size < 4) return 0;\n+    break;\n+  default:\n+    assert(false, \"Unexpected basic type\");\n+  }\n+  return size \/ type2aelembytes(bt);\n+#else\n+  return -1;\n+#endif\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -777,0 +777,3 @@\n+  \/\/ Max supported vector lane count for a particular lane type.\n+  static int max_vector_size(BasicType bt);\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2235,39 +2235,1 @@\n-  assert(is_java_primitive(bt), \"only primitive type vectors\");\n-  if (UseSSE < 2) return 0;\n-  \/\/ SSE2 supports 128bit vectors for all types.\n-  \/\/ AVX2 supports 256bit vectors for all types.\n-  \/\/ AVX2\/EVEX supports 512bit vectors for all types.\n-  int size = (UseAVX > 1) ? (1 << UseAVX) * 8 : 16;\n-  \/\/ AVX1 supports 256bit vectors only for FLOAT and DOUBLE.\n-  if (UseAVX > 0 && (bt == T_FLOAT || bt == T_DOUBLE))\n-    size = (UseAVX > 2) ? 64 : 32;\n-  if (UseAVX > 2 && (bt == T_BYTE || bt == T_SHORT || bt == T_CHAR))\n-    size = (VM_Version::supports_avx512bw()) ? 64 : 32;\n-  \/\/ Use flag to limit vector size.\n-  size = MIN2(size,(int)MaxVectorSize);\n-  \/\/ Minimum 2 values in vector (or 4 for bytes).\n-  switch (bt) {\n-  case T_DOUBLE:\n-  case T_LONG:\n-    if (size < 16) return 0;\n-    break;\n-  case T_FLOAT:\n-  case T_INT:\n-    if (size < 8) return 0;\n-    break;\n-  case T_BOOLEAN:\n-    if (size < 4) return 0;\n-    break;\n-  case T_CHAR:\n-    if (size < 4) return 0;\n-    break;\n-  case T_BYTE:\n-    if (size < 4) return 0;\n-    break;\n-  case T_SHORT:\n-    if (size < 4) return 0;\n-    break;\n-  default:\n-    ShouldNotReachHere();\n-  }\n-  return size;\n+  return max_vector_size(bt) * type2aelembytes(bt);\n@@ -2278,1 +2240,1 @@\n-  return vector_width_in_bytes(bt)\/type2aelembytes(bt);\n+  return VM_Version::max_vector_size(bt);\n@@ -2280,0 +2242,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+\n+  static int max_vector_size(BasicType bt) { return -1;}\n+\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1867,7 +1867,10 @@\n-    assert(!inner_field->is_flat(), \"the iteration over nested fields is handled by the loop itself\");\n-    int off = inner_field->offset_in_bytes() - vk->first_field_offset();\n-    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n-    Value replacement = append(load);\n-    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n-    store->set_enclosing_field(enclosing_field);\n-    append(store);\n+    for (int j = 0, sec_offset = 0; j < inner_field->secondary_fields_count(); j++) {\n+      assert(!inner_field->is_flat(), \"the iteration over nested fields is handled by the loop itself\");\n+      int off = inner_field->offset_in_bytes() + sec_offset - vk->first_field_offset();\n+      LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n+      Value replacement = append(load);\n+      StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n+      store->set_enclosing_field(enclosing_field);\n+      append(store);\n+      sec_offset += type2aelembytes(inner_field->type()->basic_type());\n+    }\n@@ -2198,4 +2201,8 @@\n-          LoadField* load = new LoadField(obj, offset, field, false, state_before, false);\n-          Value replacement = append(load);\n-          StoreField* store = new StoreField(new_instance, offset, field, replacement, false, state_before, false);\n-          append(store);\n+          for (int i = 0, sec_offset = 0; i < field->secondary_fields_count(); i++) {\n+            ciField* temp = i > 0 ? static_cast<ciMultiField*>(field)->secondary_field_at(i-1) : field;\n+            LoadField* load = new LoadField(obj, offset + sec_offset, temp, false, state_before, false);\n+            Value replacement = append(load);\n+            StoreField* store = new StoreField(new_instance, offset + sec_offset, temp, replacement, false, state_before, false);\n+            append(store);\n+            sec_offset += type2aelembytes(as_BasicType(load->type()));\n+          }\n@@ -2219,2 +2226,6 @@\n-    StoreField* store = new StoreField(new_instance, offset_modify, field_modify, val, false, state_before, needs_patching);\n-    append(store);\n+    int sec_field_size = type2aelembytes(field_type);\n+    for (int i = 0; i < field_modify->secondary_fields_count(); i++) {\n+      ciField* temp = i > 0 ? static_cast<ciMultiField*>(field_modify)->secondary_field_at(i-1) : field_modify;\n+      StoreField* store = new StoreField(new_instance, offset_modify + i * sec_field_size, temp, val, false, state_before, needs_patching);\n+      append(store);\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1775,0 +1776,8 @@\n+bool ciEnv::is_multifield_scalarized(BasicType bt, int vec_length) {\n+#ifdef COMPILER2\n+  return InlineTypeNode::is_multifield_scalarized(bt, vec_length);\n+#else\n+  return true;\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"ci\/ciEnv.hpp\"\n@@ -55,0 +56,2 @@\n+  \/\/ TODO: Add special handling for the secondary_fields of multifields. This is\n+  \/\/ needed once this method is used by other compilers besides C2.\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"ci\/ciField.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -324,0 +324,3 @@\n+  if (f && f->is_multifield_base()) {\n+    GUARDED_VM_ENTRY(f = _holder->populate_synthetic_multifields(f);)\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-ciType::ciType(BasicType basic_type) : ciMetadata() {\n+ciType::ciType(BasicType basic_type, int bundle_size) : ciMetadata() {\n@@ -45,0 +45,1 @@\n+  _bundle_size = bundle_size;\n@@ -49,0 +50,1 @@\n+  _bundle_size = 1;\n@@ -109,7 +111,11 @@\n-ciType* ciType::make(BasicType t) {\n-  \/\/ short, etc.\n-  \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n-  assert((uint)t < T_CONFLICT+1, \"range check\");\n-  if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n-  assert(_basic_types[t] != nullptr, \"domain check\");\n-  return _basic_types[t];\n+ciType* ciType::make(BasicType t, int bundle_size) {\n+  if (bundle_size == 1) {\n+    \/\/ short, etc.\n+    \/\/ Note: Bare T_ADDRESS means a raw pointer type, not a return_address.\n+    assert((uint)t < T_CONFLICT+1, \"range check\");\n+    if (t == T_OBJECT)  return ciEnv::_Object_klass;  \/\/ java\/lang\/Object\n+    assert(_basic_types[t] != NULL, \"domain check\");\n+    return _basic_types[t];\n+  } else {\n+    return new (CURRENT_ENV->arena()) ciType(t, bundle_size);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -991,0 +991,1 @@\n+    _jdk_internal_vm_annotation_MultiField,\n@@ -1000,0 +1001,1 @@\n+  jbyte _multifield_arg;\n@@ -1026,0 +1028,3 @@\n+  void set_multifield_arg(jbyte arg) { _multifield_arg = arg; }\n+  jbyte multifield_arg() const { return _multifield_arg; }\n+\n@@ -1027,0 +1032,1 @@\n+  bool is_multifield_base() const { return has_annotation(_jdk_internal_vm_annotation_MultiField); }\n@@ -1166,0 +1172,3 @@\n+    b_tag_val = 'B',\n+    b_con_off = 7,\n+    b_size = 9,\n@@ -1212,0 +1221,9 @@\n+    } else if (AnnotationCollector::_jdk_internal_vm_annotation_MultiField == id) {\n+      \/\/ TODO: change those assertion into a conditional statement to process the value\n+      assert(count == 1, \"MultiField annotation must have at least one argument\");  \/\/ Is it true?\n+      assert(member == vmSymbols::value_name(), \"Must be\");\n+      assert(b_tag_val == *(abase + tag_off), \"Must be a byte value\");\n+      int arg_index = Bytes::get_Java_u2((address)abase + b_con_off);\n+      int multifield_arg = const_cast<ConstantPool*>(cp)->int_at(arg_index);\n+      assert(((jbyte)multifield_arg) == multifield_arg, \"Must be\");\n+      coll->set_multifield_arg(multifield_arg);\n@@ -1514,1 +1532,7 @@\n-  ResourceMark rm(THREAD);\n+  \/\/ ResourceMark rm(THREAD);\n+  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0); \/\/ could be allocated lazily\n+  GrowableArray<AnnotationArray*>* fields_annotations = nullptr;\n+  GrowableArray<AnnotationArray*>* fields_type_annotations = nullptr;\n+\n+  int field_index = -1;\n+  int inj_multifields = 0;\n@@ -1516,0 +1540,1 @@\n+    field_index++;\n@@ -1563,4 +1588,2 @@\n-        if (_fields_annotations == nullptr) {\n-          _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n-                                             _loader_data, length, nullptr,\n-                                             CHECK);\n+        if (fields_annotations == nullptr) {\n+          fields_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -1568,1 +1591,1 @@\n-        _fields_annotations->at_put(n, parsed_annotations.field_annotations());\n+        fields_annotations->at_put_grow(n, parsed_annotations.field_annotations(), nullptr);\n@@ -1581,0 +1604,1 @@\n+\n@@ -1582,6 +1606,2 @@\n-        if (_fields_type_annotations == nullptr) {\n-          _fields_type_annotations =\n-            MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n-                                                         length,\n-                                                         nullptr,\n-                                                         CHECK);\n+        if (fields_type_annotations == nullptr) {\n+          fields_type_annotations = new GrowableArray<AnnotationArray*>(length);\n@@ -1589,1 +1609,1 @@\n-        _fields_type_annotations->at_put(n, parsed_annotations.field_type_annotations());\n+        fields_type_annotations->at_put_grow(field_index, parsed_annotations.field_type_annotations(), nullptr);\n@@ -1613,1 +1633,1 @@\n-    fi.set_index(n);\n+    fi.set_index(field_index);\n@@ -1621,1 +1641,47 @@\n-    _temp_field_info->append(fi);\n+\n+    int base_idx = _temp_field_info->append(fi);\n+    assert(base_idx == field_index, \"Must be\");\n+    FieldInfo* const field = _temp_field_info->adr_at(field_index);\n+\n+    if (parsed_annotations.is_multifield_base() && is_java_primitive(cp->basic_type_for_signature_at(signature_index))) {\n+      field->field_flags_addr()->update_multifield_base(true);\n+      char* base_name = cp->symbol_at(name_index)->as_C_string();\n+      int bundle_size = parsed_annotations.multifield_arg();\n+      if (bundle_size < 0) {\n+        bundle_size = VectorSupport::get_max_multifield_count(_class_name);\n+      }\n+      for (int i = 1; i < bundle_size; i++) {\n+        field_index++;\n+        stringStream st;\n+        st.print(\"%s\", base_name);\n+        st.print(\"#\");\n+        st.print(\"%d\", i);\n+        Symbol* inj_name = SymbolTable::new_symbol(st.as_string());\n+        MultiFieldInfo mfi(inj_name, base_idx, i);\n+        int mfi_idx = temp_multifield_info->append(mfi);\n+\n+        const BasicType type = cp->basic_type_for_signature_at(signature_index);\n+        \/\/ Update FieldAllocationCount for this kind of field\n+        fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n+\n+        FieldInfo::FieldFlags fflags(0);\n+        \/\/ fflags.update_injected(true);\n+        AccessFlags aflags;\n+        aflags.set_flags(flags);\n+        FieldInfo fi(aflags, (u2)(mfi_idx), (u2)signature_index, 0, fflags);\n+        fi.set_index(field_index);\n+\n+        int inj_idx = _temp_field_info->append(fi);\n+        assert(inj_idx == field_index, \"Must be\");\n+        FieldInfo* const field = _temp_field_info->adr_at(inj_idx);\n+\n+        field->field_flags_addr()->update_multifield(true);\n+        if (fields_annotations != nullptr && fields_annotations->at(base_idx) != nullptr) {\n+          fields_annotations->at_put_grow(field_index, fields_annotations->at(base_idx));\n+        }\n+        if (fields_type_annotations != nullptr && fields_type_annotations->at(base_idx) != nullptr) {\n+          fields_type_annotations->at_put_grow(field_index, fields_type_annotations->at(base_idx));\n+        }\n+        inj_multifields++;\n+      }\n+    }\n@@ -1623,1 +1689,1 @@\n-  assert(_temp_field_info->length() == length, \"Must be\");\n+  assert(_temp_field_info->length() == (length + inj_multifields), \"Must be\");\n@@ -1625,1 +1691,2 @@\n-  int index = length;\n+  *java_fields_count_ptr = *java_fields_count_ptr + inj_multifields;\n+  int index = length + inj_multifields;\n@@ -1653,2 +1720,5 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n+      fi.set_index(field_index);\n+\n+      field_index++;\n+      int inj_idx = _temp_field_info->append(fi);\n+      assert(inj_idx == field_index, \"Must be\");\n@@ -1673,2 +1743,5 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n+    fi.set_index(index);\n+\n+    field_index++;\n+    int inj_idx = _temp_field_info->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1694,1 +1767,4 @@\n-    _temp_field_info->append(fi);\n+\n+    field_index++;\n+    int inj_idx = _temp_field_info->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1707,0 +1783,29 @@\n+  if (temp_multifield_info->length() > 0) {\n+    _multifield_info = MetadataFactory::new_array<MultiFieldInfo>(_loader_data,\n+                                                                  temp_multifield_info->length(),\n+                                                                  CHECK);\n+    for (int i = 0; i < temp_multifield_info->length(); i++) {\n+      _multifield_info->at_put(i, temp_multifield_info->at(i));\n+    }\n+  }\n+\n+  if (fields_annotations != nullptr) {\n+    _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n+                                                                       _temp_field_info->length(),\n+                                                                       nullptr,\n+                                                                       CHECK);\n+    for (int i = 0; i < fields_annotations->length(); i++) {\n+      _fields_annotations->at_put(i, fields_annotations->at(i));\n+    }\n+  }\n+\n+  if (fields_type_annotations != nullptr) {\n+     _fields_type_annotations = MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n+                                                                             _temp_field_info->length(),\n+                                                                             nullptr,\n+                                                                             CHECK);\n+    for (int i = 0; i < fields_type_annotations->length(); i++) {\n+      _fields_type_annotations->at_put(i, fields_type_annotations->at(i));\n+    }\n+  }\n+\n@@ -1713,1 +1818,1 @@\n-      NameSigHash name_and_sig(_temp_field_info->adr_at(i)->name(_cp),\n+      NameSigHash name_and_sig(_temp_field_info->adr_at(i)->name(_multifield_info, _cp),\n@@ -2079,0 +2184,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_MultiField_signature): {\n+      if (_location != _in_field) break;  \/\/ only allow for fields\n+      if (!privileged)            break;  \/\/ honor privileges\n+      return _jdk_internal_vm_annotation_MultiField;\n+    }\n@@ -3257,0 +3367,1 @@\n+    const Symbol* outer_class_name = nullptr;\n@@ -3258,1 +3369,1 @@\n-      const Symbol* const outer_class_name = cp->klass_name_at(outer_class_info_index);\n+      outer_class_name = cp->klass_name_at(outer_class_info_index);\n@@ -3302,1 +3413,1 @@\n-    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n+    verify_legal_class_modifiers(flags, name, outer_class_name, false, CHECK_0);\n@@ -4145,0 +4256,1 @@\n+  this_klass->set_multifield_info(_multifield_info);\n@@ -4731,0 +4843,14 @@\n+\/\/ utility function to skip over internal jdk primitive classes used to override the need for passing\n+\/\/ an explict JVM flag EnablePrimitiveClasses.\n+bool ClassFileParser::is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const {\n+  if (outer_class &&\n+      inner_class &&\n+      (vmSymbols::jdk_internal_vm_vector_VectorSupport() == outer_class ||\n+       vmSymbols::jdk_internal_vm_vector_VectorPayloadMF() == outer_class)) {\n+    if (strstr(inner_class, \"VectorPayloadMF\")) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -4733,1 +4859,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, const Symbol* outer_class, bool is_Object, TRAPS) const {\n@@ -4761,1 +4887,1 @@\n-  if (is_primitive_class && !EnablePrimitiveClasses) {\n+  if (is_primitive_class && !is_jdk_internal_class(outer_class, name) && !EnablePrimitiveClasses) {\n@@ -5666,0 +5792,1 @@\n+  assert(nullptr == _multifield_info, \"invariant\");\n@@ -5950,0 +6077,1 @@\n+  _multifield_info(nullptr),\n@@ -6040,0 +6168,1 @@\n+  _multifield_info = nullptr;\n@@ -6058,0 +6187,4 @@\n+  if (_multifield_info != nullptr) {\n+    MetadataFactory::free_array<MultiFieldInfo>(_loader_data, _multifield_info);\n+  }\n+\n@@ -6203,2 +6336,0 @@\n-  verify_legal_class_modifiers(flags, nullptr, is_java_lang_Object, CHECK);\n-\n@@ -6304,0 +6435,3 @@\n+  const Symbol* super_klass_name = _super_class_index ? cp->klass_name_at(_super_class_index) : nullptr;\n+  verify_legal_class_modifiers(flags, _class_name->as_C_string(), super_klass_name, is_java_lang_Object, CHECK);\n+\n@@ -6398,0 +6532,12 @@\n+bool ClassFileParser::is_jdk_internal_class(const Klass* cls) {\n+  while(cls) {\n+    const Symbol* cls_name = cls->name();\n+    if(cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayload() ||\n+       cls_name == vmSymbols::jdk_internal_vm_vector_VectorPayloadMF()) {\n+      return true;\n+    }\n+    cls = cls->super();\n+   }\n+   return false;\n+}\n+\n@@ -6581,1 +6727,1 @@\n-  if (EnableValhalla) {\n+  if (EnableValhalla || is_jdk_internal_class(_super_klass)) {\n@@ -6630,1 +6776,1 @@\n-      _field_info, _inline_type_field_klasses);\n+      _field_info, _inline_type_field_klasses, _multifield_info);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":177,"deletions":31,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -506,1 +507,1 @@\n-  void verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const;\n+  void verify_legal_class_modifiers(jint flags, const char* name, const Symbol* out_class, bool is_Object, TRAPS) const;\n@@ -526,0 +527,3 @@\n+  bool is_jdk_internal_class(const Symbol* outer_class, const char * inner_class) const;\n+  bool is_jdk_internal_class(const Klass* cls);\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  _is_reference(false) {\n+  _is_reference(false),\n+  _multifield_index(-1) {\n@@ -56,1 +57,1 @@\n-LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :\n+LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index) :\n@@ -65,2 +66,3 @@\n- _is_reference(is_reference) {\n-  assert(kind == REGULAR || kind == FLAT || kind == INHERITED,\n+ _is_reference(is_reference),\n+ _multifield_index(multifield_index) {\n+  assert(kind == REGULAR || kind == FLAT || kind == INHERITED || kind == MULTIFIELD,\n@@ -85,0 +87,1 @@\n+  _multifields(nullptr),\n@@ -90,1 +93,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false, -1);\n@@ -100,1 +103,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true, -1);\n@@ -109,1 +112,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_exact_size_in_bytes(), vk->get_alignment(), false, -1);\n@@ -118,0 +121,24 @@\n+void FieldGroup::add_multifield(ConstantPool* cp, FieldInfo* field, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk) {\n+  assert(field->is_multifield() || field->is_multifield_base(), \"Must be\");\n+  u2 base = field->multifield_base(multifield_info);\n+  BasicType type = Signature::basic_type(field->signature(cp));\n+  MultiFieldGroup* mfg = NULL;\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      if (base == _multifields->at(i)->multifield_base()) {\n+        mfg = _multifields->at(i);\n+        break;\n+      }\n+    }\n+  } else {\n+    _multifields = new GrowableArray<MultiFieldGroup*>(INITIAL_LIST_SIZE);\n+  }\n+  if (mfg == NULL) {\n+    mfg = new MultiFieldGroup(base, field->signature(cp));\n+    mfg->add_field(cp, field, vk, multifield_info);\n+    _multifields->append(mfg);\n+  } else {\n+    mfg->add_field(cp, field, vk, multifield_info);\n+  }\n+}\n+\n@@ -125,0 +152,16 @@\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      int size = _multifields->at(i)->fields()->at(0)->size();\n+      int alignment =  _multifields->at(i)->fields()->at(0)->alignment();\n+      int multialignment = size\/alignment;\n+      if (size % multialignment != 0) multialignment+= alignment;\n+      \/\/ Problem: at this point, multialignment can be a weird number, for instance not a power of two\n+      int multisize = multialignment * alignment * _multifields->at(i)->fields()->length();  \/\/ should be stored\n+      \/\/ True alignment should be adjusted to increase chances to be on a single cache line\n+      int multifield_group_alignment = MIN2(round_up_power_of_2(multisize), HeapWordSize);\n+      _multifields->at(i)->set_group_size(multisize);\n+      _multifields->at(i)->set_group_alignment(multifield_group_alignment);\n+      _multifields->at(i)->fields()->sort(MultiFieldGroup::compare_multifield_index);\n+    }\n+    _multifields->sort(MultiFieldGroup::compare_multifield_groups_inverted);\n+  }\n@@ -141,1 +184,28 @@\n-FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp) :\n+MultiFieldGroup::MultiFieldGroup(u2 base, Symbol* signature) :  _multifield_base(base), _signature(signature), _fields(NULL) { }\n+\n+void MultiFieldGroup::add_field(ConstantPool* cp, FieldInfo* field, InlineKlass* vk, Array<MultiFieldInfo>* multifield_info) {\n+  assert(field->is_multifield() || field->is_multifield_base(), \"Must be\");\n+  assert(field->multifield_base(multifield_info) == multifield_base(), \"multifield base mismatch\");\n+  if (_fields == NULL) {\n+    _fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  } else {\n+    guarantee(field->signature(cp) == signature(), \"multifield signature mismatch\");\n+  }\n+  BasicType type = Signature::basic_type(field->signature(cp));\n+  LayoutRawBlock* block = NULL;\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    block = new LayoutRawBlock(field->index(), LayoutRawBlock::MULTIFIELD, vk->get_exact_size_in_bytes(),\n+                               vk->get_alignment(), false, field->multifield_index(multifield_info));\n+  } else {\n+    int size = type2aelembytes(type);\n+    block = new LayoutRawBlock(field->index(), LayoutRawBlock::MULTIFIELD, size, size, false, field->multifield_index(multifield_info));\n+  }\n+  int cursor = 0;\n+  for (; cursor < _fields->length(); cursor++) {\n+    assert(_fields->at(cursor)->multifield_index() != field->multifield_index(multifield_info), \"multifield index duplicate found\");\n+    if (_fields->at(cursor)->multifield_index() > field->multifield_index(multifield_info)) break;\n+  }\n+  _fields->insert_before(cursor, block);\n+}\n+\n+FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp, Array<MultiFieldInfo>* multifields) :\n@@ -144,0 +214,1 @@\n+  _multifield_info(multifields),\n@@ -187,0 +258,1 @@\n+         && block->kind() != LayoutRawBlock::MULTIFIELD\n@@ -316,0 +388,31 @@\n+void FieldLayout::add_multifield(MultiFieldGroup* multifield_group, LayoutRawBlock* start) {\n+  if (start == NULL) {\n+    start = _start;\n+  }\n+  LayoutRawBlock* candidate = NULL;\n+  if (start == last_block()) {\n+    candidate = last_block();\n+  } else {\n+    candidate = last_block()->prev_block();\n+    while (candidate->kind() != LayoutRawBlock::EMPTY || !candidate->fit(multifield_group->group_size(), multifield_group->group_alignment())) {\n+      if (candidate == start) {\n+        candidate = last_block();\n+        break;\n+      }\n+      candidate = candidate->prev_block();\n+    }\n+    assert(candidate != NULL, \"Candidate must not be null\");\n+    assert(candidate->kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n+  }\n+  if ((candidate->offset() % multifield_group->group_alignment()) != 0) {\n+    int adjustment = multifield_group->group_alignment() - (candidate->offset() % multifield_group->group_alignment());\n+    LayoutRawBlock* adj = new LayoutRawBlock(LayoutRawBlock::EMPTY, adjustment);\n+    insert(candidate, adj);\n+  }\n+  assert(candidate->fit(multifield_group->group_size(), multifield_group->group_alignment()), \"Candidate must be able to store the whole contiguous block\");\n+  for (int i = 0; i < multifield_group->fields()->length(); i++) {\n+    LayoutRawBlock* b = multifield_group->fields()->at(i);\n+    insert_field_block(candidate, b);\n+  }\n+}\n+\n@@ -335,1 +438,1 @@\n-    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -344,1 +447,1 @@\n-                                   vk->get_alignment(), false);\n+                                   vk->get_alignment(), false, -1);\n@@ -349,1 +452,1 @@\n-        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false, -1);\n@@ -473,1 +576,1 @@\n-                         fi->name(_cp)->as_C_string(),\n+                         fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -484,1 +587,1 @@\n-                         fi->name(_cp)->as_C_string(),\n+                         fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -504,1 +607,1 @@\n-          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -516,0 +619,1 @@\n+          }\n@@ -518,0 +622,1 @@\n+        break;\n@@ -519,14 +624,22 @@\n-      break;\n-    }\n-    case LayoutRawBlock::EMPTY:\n-      output->print_cr(\" @%d %d\/1 %s\",\n-                       b->offset(),\n-                       b->size(),\n-                       \"EMPTY\");\n-      break;\n-    case LayoutRawBlock::PADDING:\n-      output->print_cr(\" @%d %d\/1 %s\",\n-                       b->offset(),\n-                       b->size(),\n-                       \"PADDING\");\n-      break;\n+      case LayoutRawBlock::EMPTY:\n+        output->print_cr(\" @%d %d\/1 %s\",\n+                         b->offset(),\n+                         b->size(),\n+                         \"EMPTY\");\n+        break;\n+      case LayoutRawBlock::PADDING:\n+        output->print_cr(\" @%d %d\/1 %s\",\n+                         b->offset(),\n+                         b->size(),\n+                         \"PADDING\");\n+        break;\n+      case LayoutRawBlock::MULTIFIELD:\n+        FieldInfo* fi = _field_info->adr_at(b->field_index());\n+        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                         b->offset(),\n+                         fi->name(_multifield_info, _cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string(),\n+                         b->size(),\n+                         b->alignment(),\n+                         \"MULTIFIELD\");\n+        break;\n@@ -540,1 +653,2 @@\n-                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses) :\n+                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses,\n+                                       Array<MultiFieldInfo>* multifields) :\n@@ -547,0 +661,1 @@\n+  _multifield_info(multifields),\n@@ -580,1 +695,1 @@\n-  _layout = new FieldLayout(_field_info, _constant_pool);\n+  _layout = new FieldLayout(_field_info, _constant_pool, _multifield_info);\n@@ -586,1 +701,1 @@\n-  _static_layout = new FieldLayout(_field_info, _constant_pool);\n+  _static_layout = new FieldLayout(_field_info, _constant_pool, _multifield_info);\n@@ -622,22 +737,21 @@\n-    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      group->add_primitive_field(idx, type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-    case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n-      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n-        if (group != _static_fields) _nonstatic_oopmap_count++;\n-        group->add_oop_field(idx);\n-      } else {\n-        _has_inline_type_fields = true;\n-        if (group == _static_fields) {\n-          \/\/ static fields are never flat\n+    bool has_multifield_annotation = false;\n+    if (fieldinfo.is_multifield() || fieldinfo.is_multifield_base()) {\n+      group->add_multifield(_constant_pool, &fieldinfo, _multifield_info);\n+    } else {\n+      BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n+      switch(type) {\n+      case T_BYTE:\n+      case T_CHAR:\n+      case T_DOUBLE:\n+      case T_FLOAT:\n+      case T_INT:\n+      case T_LONG:\n+      case T_SHORT:\n+      case T_BOOLEAN:\n+        group->add_primitive_field(idx, type);\n+        break;\n+      case T_OBJECT:\n+      case T_ARRAY:\n+      case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n+        if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+          if (group != _static_fields) _nonstatic_oopmap_count++;\n@@ -646,32 +760,3 @@\n-          \/\/ Check below is performed for non-static fields, it should be performed for static fields too but at this stage,\n-          \/\/ it is not guaranteed that the klass of the static field has been loaded, so the test for static fields is delayed\n-          \/\/ until the linking phase\n-          Klass* klass =  _inline_type_field_klasses->at(idx);\n-          assert(klass != nullptr, \"Sanity check\");\n-          InlineKlass* vk = InlineKlass::cast(klass);\n-          if (!vk->is_implicitly_constructible()) {\n-            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n-          }\n-          _has_flattening_information = true;\n-          \/\/ Flattening decision to be taken here\n-          \/\/ This code assumes all verification already have been performed\n-          \/\/ (field's type has been loaded and it is an inline klass)\n-          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                    (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-          bool too_atomic_to_flatten = vk->must_be_atomic() || AlwaysAtomicAccesses;\n-          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-          if (vk->is_naturally_atomic()) {\n-            too_atomic_to_flatten = false;\n-            \/\/too_volatile_to_flatten = false; \/\/FIXME\n-            \/\/ Currently, volatile fields are never flat, this could change in the future\n-          }\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n-            group->add_flat_field(idx, vk);\n-            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-            _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n-            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-              _has_nonatomic_values = true;\n-              _atomic_field_count--;  \/\/ every other field is atomic but this one\n-            }\n-          } else {\n-            _nonstatic_oopmap_count++;\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never flat\n@@ -679,0 +764,35 @@\n+          } else {\n+            \/\/ Check below is performed for non-static fields, it should be performed for static fields too but at this stage,\n+            \/\/ it is not guaranteed that the klass of the static field has been loaded, so the test for static fields is delayed\n+            \/\/ until the linking phase\n+            Klass* klass =  _inline_type_field_klasses->at(idx);\n+            assert(klass != nullptr, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            if (!vk->is_implicitly_constructible()) {\n+              THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n+            }\n+            _has_flattening_information = true;\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verification already have been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->must_be_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ Currently, volatile fields are never flat, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n+              group->add_flat_field(idx, vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              group->add_oop_field(idx);\n+            }\n@@ -680,0 +800,3 @@\n+        break;\n+      default:\n+        fatal(\"Something wrong?\");\n@@ -682,3 +805,0 @@\n-      break;\n-    default:\n-      fatal(\"Something wrong?\");\n@@ -721,20 +841,14 @@\n-    assert(group != nullptr, \"invariant\");\n-    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      if (group != _static_fields) {\n-        field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n-      }\n-      group->add_primitive_field(fieldinfo.index(), type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-    case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n-      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+    bool has_multifield_annotation = false;\n+    if (fieldinfo.is_multifield() || fieldinfo.is_multifield_base()) {\n+      group->add_multifield(_constant_pool, &fieldinfo, _multifield_info);\n+    } else {\n+      BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n+      switch(type) {\n+      case T_BYTE:\n+      case T_CHAR:\n+      case T_DOUBLE:\n+      case T_FLOAT:\n+      case T_INT:\n+      case T_LONG:\n+      case T_SHORT:\n+      case T_BOOLEAN:\n@@ -742,2 +856,1 @@\n-          _nonstatic_oopmap_count++;\n-          field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+          field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n@@ -745,5 +858,10 @@\n-        group->add_oop_field(fieldinfo.index());\n-      } else {\n-        _has_inline_type_fields = true;\n-        if (group == _static_fields) {\n-          \/\/ static fields are never flat\n+        group->add_primitive_field(fieldinfo.index(), type);\n+        break;\n+      case T_OBJECT:\n+      case T_ARRAY:\n+      case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n+        if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+          if (group != _static_fields) {\n+            _nonstatic_oopmap_count++;\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+          }\n@@ -752,33 +870,3 @@\n-          \/\/ Check below is performed for non-static fields, it should be performed for static fields too but at this stage,\n-          \/\/ it is not guaranteed that the klass of the static field has been loaded, so the test for static fields is delayed\n-          \/\/ until the linking phase\n-          Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n-          assert(klass != nullptr, \"Sanity check\");\n-          InlineKlass* vk = InlineKlass::cast(klass);\n-          if (!vk->is_implicitly_constructible()) {\n-            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n-          }\n-          \/\/ Flattening decision to be taken here\n-          \/\/ This code assumes all verifications have already been performed\n-          \/\/ (field's type has been loaded and it is an inline klass)\n-          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                    (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-          bool too_atomic_to_flatten = vk->must_be_atomic() || AlwaysAtomicAccesses;\n-          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-          if (vk->is_naturally_atomic()) {\n-            too_atomic_to_flatten = false;\n-            \/\/too_volatile_to_flatten = false; \/\/FIXME\n-            \/\/ Currently, volatile fields are never flat, this could change in the future\n-          }\n-          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n-            group->add_flat_field(fieldinfo.index(), vk);\n-            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-            field_alignment = vk->get_alignment();\n-            _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_flat(true);\n-            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-              _has_nonatomic_values = true;\n-              _atomic_field_count--;  \/\/ every other field is atomic but this one\n-            }\n-          } else {\n-            _nonstatic_oopmap_count++;\n-            field_alignment = type2aelembytes(T_OBJECT);\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never flat\n@@ -786,0 +874,36 @@\n+          } else {\n+            \/\/ Check below is performed for non-static fields, it should be performed for static fields too but at this stage,\n+            \/\/ it is not guaranteed that the klass of the static field has been loaded, so the test for static fields is delayed\n+            \/\/ until the linking phase\n+            Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n+            assert(klass != nullptr, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            if (!vk->is_implicitly_constructible()) {\n+              THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n+            }\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verifications have already been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->must_be_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ Currently, volatile fields are never flat, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {\n+              group->add_flat_field(fieldinfo.index(), vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              field_alignment = vk->get_alignment();\n+              _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_flat(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              field_alignment = type2aelembytes(T_OBJECT);\n+              group->add_oop_field(fieldinfo.index());\n+            }\n@@ -788,0 +912,12 @@\n+        break;\n+      default:\n+        fatal(\"Unexpected BasicType\");\n+      }\n+      if (!fieldinfo.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n+    }\n+  }\n+  _root_group->sort_by_size();\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      if (_root_group->multifields()->at(i)->group_alignment() > alignment) {\n+        alignment = _root_group->multifields()->at(i)->group_alignment();\n@@ -789,4 +925,0 @@\n-      break;\n-    default:\n-      fatal(\"Unexpected BasicType\");\n-    if (!fieldinfo.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n@@ -830,0 +962,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -839,1 +976,6 @@\n-      _layout->add(cg->big_primitive_fields());\n+      if (cg->multifields() != NULL) {\n+        for (int i = 0; i < cg->multifields()->length(); i++) {\n+          _layout->add_multifield(cg->multifields()->at(i), start);\n+        }\n+      }\n+      _layout->add(cg->big_primitive_fields(), start);\n@@ -851,0 +993,5 @@\n+  if (_static_fields->multifields() != NULL) {\n+    for (int i = 0; i < _static_fields->multifields()->length(); i++) {\n+      _layout->add_multifield(_static_fields->multifields()->at(i));\n+    }\n+  }\n@@ -884,0 +1031,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -897,1 +1049,0 @@\n-  _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":305,"deletions":154,"binary":false,"changes":459,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-    INHERITED         \/\/ field(s) inherited from super classes\n+    INHERITED,         \/\/ field(s) inherited from super classes\n+    MULTIFIELD        \/\/ fields part of a multi-field\n@@ -74,0 +75,1 @@\n+  jbyte _multifield_index;\n@@ -77,1 +79,1 @@\n-  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference = false);\n+  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index);\n@@ -96,0 +98,1 @@\n+  jbyte multifield_index() const { return _multifield_index; }\n@@ -123,1 +126,34 @@\n-\/\/ A Field group represents a set of fields that have to be allocated together,\n+class MultiFieldGroup : public ResourceObj {\n+ private:\n+  u2 _multifield_base;\n+  Symbol* _signature;\n+  int _group_size;\n+  int _group_alignment;\n+  GrowableArray<LayoutRawBlock*>* _fields;\n+  \/\/ total size and alignment?\n+\n+  static const int INITIAL_LIST_SIZE = 16;\n+ public:\n+  MultiFieldGroup(u2 base, Symbol* signature);\n+\n+  u2 multifield_base() const { return _multifield_base; }\n+  Symbol* signature() const { return _signature; }\n+  int group_size() const { return _group_size; }\n+  void set_group_size(int size) { _group_size = size; }\n+  int group_alignment() const { return _group_alignment; }\n+  void set_group_alignment(int alignment) { _group_alignment = alignment; }\n+  GrowableArray<LayoutRawBlock*>* fields() const { return _fields; }\n+  void add_field(ConstantPool* cp, FieldInfo* field, InlineKlass* vk, Array<MultiFieldInfo>* multifield_info);\n+  static int compare_multifield_index(LayoutRawBlock** x, LayoutRawBlock** y) {\n+    return (*x)->multifield_index() - (*y)->multifield_index();\n+  }\n+  static int compare_multifield_groups_inverted(MultiFieldGroup** x, MultiFieldGroup** y) {\n+    int diff = (*y)->group_size() - (*x)->group_size();\n+    if (diff == 0) {\n+      diff = (*y)->group_alignment() - (*x)->group_alignment();\n+    }\n+    return diff;\n+  }\n+};\n+\n+\/\/ A FieldGroup represents a set of fields that have to be allocated together,\n@@ -136,0 +172,1 @@\n+  GrowableArray<MultiFieldGroup*>* _multifields;\n@@ -148,0 +185,1 @@\n+  GrowableArray<MultiFieldGroup*>* multifields() const { return _multifields; }\n@@ -154,0 +192,1 @@\n+  void add_multifield(ConstantPool* cp, FieldInfo* field, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk = NULL);\n@@ -181,0 +220,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -186,1 +226,1 @@\n-  FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp);\n+  FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp, Array<MultiFieldInfo>* multifields);\n@@ -208,0 +248,1 @@\n+  void add_multifield(MultiFieldGroup* multifield, LayoutRawBlock* start = nullptr);\n@@ -248,0 +289,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -268,0 +310,1 @@\n+  MultiFieldGroup* get_or_create_multifield_group(int base);\n@@ -272,1 +315,1 @@\n-                     Array<InlineKlass*>* inline_type_field_klasses);\n+                     Array<InlineKlass*>* inline_type_field_klasses, Array<MultiFieldInfo>* multifields);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -5042,20 +5042,0 @@\n-int vector_VectorPayload::_payload_offset;\n-\n-#define VECTORPAYLOAD_FIELDS_DO(macro) \\\n-  macro(_payload_offset, k, \"payload\", object_signature, false)\n-\n-void vector_VectorPayload::compute_offsets() {\n-  InstanceKlass* k = vmClasses::vector_VectorPayload_klass();\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void vector_VectorPayload::serialize_offsets(SerializeClosure* f) {\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-void vector_VectorPayload::set_payload(oop o, oop val) {\n-  o->obj_field_put(_payload_offset, val);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1766,7 +1766,2 @@\n- private:\n-  static int _payload_offset;\n-  static void set_payload(oop o, oop val);\n-\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-\n+  static void compute_offsets() { }\n+  static void serialize_offsets(SerializeClosure* f) { }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+  \/* support multi-field based vectors *\/                                                                       \\\n+  do_klass(vector_VectorPayloadMF_klass,                jdk_internal_vm_vector_VectorPayloadMF                ) \\\n+                                                                                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -188,1 +188,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-\/\/ Mapping function names to values. New entries should be added below.\n+\/\/ Mapping function names to values. New entries should be added below.\n@@ -94,8 +94,58 @@\n-  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n-  template(jdk_internal_vm_vector_VectorPayload,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\") \\\n-  template(jdk_internal_vm_vector_Vector,             \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")        \\\n-  template(jdk_internal_vm_vector_VectorMask,         \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")    \\\n-  template(jdk_internal_vm_vector_VectorShuffle,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\") \\\n-  template(payload_name,                              \"payload\")                                            \\\n-  template(ETYPE_name,                                \"ETYPE\")                                              \\\n-  template(VLENGTH_name,                              \"VLENGTH\")                                            \\\n+  template(jdk_internal_vm_vector_VectorSupport,       \"jdk\/internal\/vm\/vector\/VectorSupport\")                     \\\n+  template(jdk_internal_vm_vector_Vector,              \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")              \\\n+  template(jdk_internal_vm_vector_VectorMask,          \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")          \\\n+  template(jdk_internal_vm_vector_VectorShuffle,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\")       \\\n+  template(jdk_internal_vm_vector_VectorPayload,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\")       \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF,     \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF\")     \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF8Z,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF8B,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512B, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64S,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512S, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64I,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512I, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64L,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512L, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64F,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512F, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64D,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512D, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxS, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxS\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxI, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxI\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxL, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxL\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxF, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxF\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxD, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxD\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxBZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxBZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxSZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxSZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxIZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxIZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxLZ, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxLZ\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxBB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxBB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxSB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxSB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxIB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxIB\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMFMaxLB, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMFMaxLB\") \\\n+  template(payload_name,                               \"payload\")                                                  \\\n+  template(mfield_name,                                \"mfield\")                                                   \\\n+  template(ETYPE_name,                                 \"ETYPE\")                                                    \\\n+  template(VLENGTH_name,                               \"VLENGTH\")                                                  \\\n@@ -269,0 +319,1 @@\n+  template(jdk_internal_vm_annotation_MultiField_signature,                  \"Ljdk\/internal\/vm\/annotation\/MultiField;\") \\\n@@ -274,0 +325,36 @@\n+  \/* VectorAPI support *\/                                                                         \\\n+  template(vector_VectorPayloadMF8Z_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z;\")   \\\n+  template(vector_VectorPayloadMF16Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z;\")  \\\n+  template(vector_VectorPayloadMF32Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z;\")  \\\n+  template(vector_VectorPayloadMF64Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z;\")  \\\n+  template(vector_VectorPayloadMF128Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z;\") \\\n+  template(vector_VectorPayloadMF256Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z;\") \\\n+  template(vector_VectorPayloadMF512Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z;\") \\\n+  template(vector_VectorPayloadMF8B_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B;\")   \\\n+  template(vector_VectorPayloadMF16B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B;\")  \\\n+  template(vector_VectorPayloadMF32B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B;\")  \\\n+  template(vector_VectorPayloadMF64B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64B;\")  \\\n+  template(vector_VectorPayloadMF128B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128B;\") \\\n+  template(vector_VectorPayloadMF256B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256B;\") \\\n+  template(vector_VectorPayloadMF512B_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512B;\") \\\n+  template(vector_VectorPayloadMF64S_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64S;\")  \\\n+  template(vector_VectorPayloadMF128S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128S;\") \\\n+  template(vector_VectorPayloadMF256S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256S;\") \\\n+  template(vector_VectorPayloadMF512S_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512S;\") \\\n+  template(vector_VectorPayloadMF64I_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64I;\")  \\\n+  template(vector_VectorPayloadMF128I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128I;\") \\\n+  template(vector_VectorPayloadMF256I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256I;\") \\\n+  template(vector_VectorPayloadMF512I_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512I;\") \\\n+  template(vector_VectorPayloadMF64L_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64L;\")  \\\n+  template(vector_VectorPayloadMF128L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128L;\") \\\n+  template(vector_VectorPayloadMF256L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256L;\") \\\n+  template(vector_VectorPayloadMF512L_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512L;\") \\\n+  template(vector_VectorPayloadMF64F_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64F;\")  \\\n+  template(vector_VectorPayloadMF128F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128F;\") \\\n+  template(vector_VectorPayloadMF256F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256F;\") \\\n+  template(vector_VectorPayloadMF512F_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512F;\") \\\n+  template(vector_VectorPayloadMF64D_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64D;\")  \\\n+  template(vector_VectorPayloadMF128D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128D;\") \\\n+  template(vector_VectorPayloadMF256D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256D;\") \\\n+  template(vector_VectorPayloadMF512D_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512D;\") \\\n+                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":96,"deletions":9,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+  _is_larval = read_from(stream);\n@@ -195,0 +196,4 @@\n+    if (_is_larval == nullptr) {\n+      _is_larval = new MarkerValue();\n+    }\n+    _is_larval->write_on(stream);\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -374,1 +374,3 @@\n-  f(RecordComponent)\n+  f(RecordComponent) \\\n+  f(MultiFieldInfo) \\\n+  f(InlineKlassFixedBlock)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,4 @@\n-inline Symbol* FieldInfo::name(ConstantPool* cp) const {\n+inline Symbol* FieldInfo::name(Array<MultiFieldInfo>* multifield_info, ConstantPool* cp) const {\n+  if (multifield_info && is_multifield()) {\n+    return get_multifield_name(multifield_info);\n+  }\n@@ -70,0 +73,15 @@\n+inline Symbol* FieldInfo::get_multifield_name(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield(), \"Sanity check\");\n+  return multifield_info->at(secondary_index()).name();\n+}\n+\n+inline u2 FieldInfo::multifield_base(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield() || is_multifield_base(), \"Must be\");\n+  return is_multifield() ? multifield_info->at(secondary_index()).base_index() : index();\n+}\n+\n+inline jbyte FieldInfo::multifield_index(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield() || is_multifield_base(), \"Sanity check\");\n+  return is_multifield() ? multifield_info->at(secondary_index()).multifield_index() : (jbyte)-1;\n+}\n+\n@@ -73,1 +91,1 @@\n-  _consumer->accept_uint(fi.name_index());\n+  _consumer->accept_uint(!fi.is_multifield() ? fi.name_index() : fi.secondary_index());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -155,0 +156,3 @@\n+  if (VectorSupport::is_vector_payload_mf(this) || VectorSupport::is_vector(this)) {\n+    return false;\n+  }\n@@ -244,0 +248,1 @@\n+    if (fs.is_multifield()) continue;\n@@ -338,1 +343,2 @@\n-  return InlineTypePassFieldsAsArgs;\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&\n+         InlineTypePassFieldsAsArgs;\n@@ -343,1 +349,3 @@\n-  return InlineTypeReturnedAsFields && (init || return_regs() != nullptr);\n+  return !VectorSupport::skip_value_scalarization(const_cast<InlineKlass*>(this)) &&\n+         InlineTypeReturnedAsFields &&\n+         (init || return_regs() != nullptr);\n@@ -508,0 +516,1 @@\n+#if INCLUDE_CDS\n@@ -546,0 +555,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,3 @@\n+\/\/ CDS support\n+\n+#if INCLUDE_CDS\n@@ -140,0 +143,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -170,0 +170,8 @@\n+FieldInfo MultiFieldInfo::base_field_info(InstanceKlass* ik) {\n+  return ik->field(_base_index);\n+}\n+\n+void MultiFieldInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n+  it->push(&_name);\n+}\n+\n@@ -548,0 +556,1 @@\n+  _multifield_info(nullptr),\n@@ -757,0 +766,4 @@\n+  if (_multifield_info != NULL && !_multifield_info->is_shared()) {\n+    MetadataFactory::free_array<MultiFieldInfo>(loader_data, _multifield_info);\n+  }\n+\n@@ -2837,0 +2850,3 @@\n+  if(_multifield_info != NULL) {\n+    it->push(&_multifield_info);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -141,13 +141,12 @@\n-class InlineKlassFixedBlock {\n-  Array<SigEntry>** _extended_sig;\n-  Array<VMRegPair>** _return_regs;\n-  address* _pack_handler;\n-  address* _pack_handler_jobject;\n-  address* _unpack_handler;\n-  int* _default_value_offset;\n-  ArrayKlass** _null_free_inline_array_klasses;\n-  int _alignment;\n-  int _first_field_offset;\n-  int _exact_size_in_bytes;\n-\n-  friend class InlineKlass;\n+class InlineKlassFixedBlock : public MetaspaceObj {\n+   Array<SigEntry>** _extended_sig;\n+   Array<VMRegPair>** _return_regs;\n+   address* _pack_handler;\n+   address* _pack_handler_jobject;\n+   address* _unpack_handler;\n+   int* _default_value_offset;\n+   ArrayKlass** _null_free_inline_array_klasses;\n+   int _alignment;\n+   int _first_field_offset;\n+   int _exact_size_in_bytes;\n+   friend class InlineKlass;\n@@ -231,0 +230,3 @@\n+  \/\/ Array containing meta-data generated for multifields\n+  Array<MultiFieldInfo>* _multifield_info;\n+\n@@ -303,1 +305,1 @@\n-  const InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n+  InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n@@ -444,0 +446,1 @@\n+  friend class MultiFieldInfo;\n@@ -466,0 +469,11 @@\n+  Array<MultiFieldInfo>* multifield_info() const { return _multifield_info; }\n+\n+  MultiFieldInfo multifield_info(int i) const {\n+    guarantee(_multifield_info != NULL, \"Just checking\");\n+    return _multifield_info->at(i);\n+  }\n+  void set_multifield_info(Array<MultiFieldInfo>* array) {\n+    assert(_multifield_info == NULL, \"Must be initialized only once\");\n+    _multifield_info = array;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1272,1 +1272,4 @@\n-  if (InlineTypeReturnedAsFields && returns_inline_type(THREAD) && !has_scalarized_return()) {\n+  if (InlineTypeReturnedAsFields &&\n+      returns_inline_type(THREAD) &&\n+      !has_scalarized_return() &&\n+      returns_inline_type(THREAD)->can_be_returned_as_fields()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -797,1 +797,3 @@\n-    if (vt != nullptr) {\n+    \/\/ Upfront buffering for VectorBox may cause problems in sweeping allocation\n+    \/\/ graph pallets if boxes are removed during unbox-box optimization.\n+    if (vt != nullptr && !result->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  if (vt != nullptr && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n+  if (vt != nullptr && !vt->is_VectorBox() && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2669,0 +2669,14 @@\n+        \/\/ FIXME: Skipping pushing VectorBox across Phi\n+        \/\/ since they are special type of InlineTypeNode\n+        \/\/ carrying VBA as oop fields.\n+        \/\/ We have a seperate handling for pushing VectorBoxes\n+        \/\/ across PhiNodes in merge_through_phi.\n+        \/\/ In long run we should eliminate VectorBox which is\n+        \/\/ just a light weight wrapper of InlineTypeNode.\n+        \/\/ Only reason to keep VectorBox was to defer buffering\n+        \/\/ to a later stage and associate VBA which carry\n+        \/\/ JVM state to reinitialize GraphKit before buffering.\n+        if (n->is_VectorBox()) {\n+          can_optimize = false;\n+          break;\n+        }\n@@ -2693,1 +2707,1 @@\n-    progress = merge_through_phi(this, phase->is_IterGVN());\n+    progress = merge_through_phi(this, phase);\n@@ -2773,1 +2787,1 @@\n-      } else if (def->Opcode() == Op_VectorBox) { \/\/ leaf\n+      } else if (def->is_InlineType()) { \/\/ leaf\n@@ -2790,1 +2804,2 @@\n-Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {\n+Node* PhiNode::merge_through_phi(Node* root_phi, PhaseGVN *phase) {\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -2836,3 +2851,7 @@\n-  Node* new_vbox_phi = clone_through_phi(root_phi, btype, VectorBoxNode::Box,   igvn);\n-  Node* new_vect_phi = clone_through_phi(root_phi, vtype, VectorBoxNode::Value, igvn);\n-  return new VectorBoxNode(igvn->C, new_vbox_phi, new_vect_phi, btype, vtype);\n+  const Type*        ptype = cached_vbox->field_value(0)->bottom_type();\n+\n+  Node* new_payload_phi = clone_through_phi(root_phi, ptype, InlineTypeNode::get_Values_idx(), igvn);\n+  Node* new_vector_phi = clone_through_phi(new_payload_phi, vtype, InlineTypeNode::get_Values_idx(), igvn);\n+  Node* new_vbox_phi = clone_through_phi(root_phi, btype, InlineTypeNode::get_Oop_idx(), igvn);\n+\n+  return VectorBoxNode::make_box_node(*igvn, phase->C, new_vbox_phi, new_vector_phi, btype, vtype);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  static Node* merge_through_phi(Node* root_phi, PhaseIterGVN* igvn);\n+  static Node* merge_through_phi(Node* root_phi, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2763,10 +2763,0 @@\n-  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n-  if (EnableVectorSupport && has_vbox_nodes()) {\n-    TracePhase tp(\"\", &timers[_t_vector]);\n-    PhaseVector pv(igvn);\n-    pv.optimize_vector_boxes();\n-\n-    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n-  }\n-  assert(!has_vbox_nodes(), \"sanity\");\n-\n@@ -2784,0 +2774,13 @@\n+  \/\/ Process inline type nodes now that all inlining is over\n+  process_inline_types(igvn);\n+\n+  assert(EnableVectorSupport || !has_vbox_nodes(), \"sanity\");\n+  if (EnableVectorSupport && has_vbox_nodes()) {\n+    TracePhase tp(\"\", &timers[_t_vector]);\n+    PhaseVector pv(igvn);\n+    pv.optimize_vector_boxes();\n+\n+    print_method(PHASE_ITER_GVN_AFTER_VECTOR, 2);\n+  }\n+  assert(!has_vbox_nodes(), \"sanity\");\n+\n@@ -2788,3 +2791,0 @@\n-  \/\/ Process inline type nodes now that all inlining is over\n-  process_inline_types(igvn);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -1093,1 +1094,1 @@\n-      int      size  = field->type()->size();\n+      int size = InlineTypeNode::stack_size_for_field(field);\n@@ -1135,1 +1136,1 @@\n-    int      size  = field->type()->size();\n+    int size = InlineTypeNode::stack_size_for_field(field);\n@@ -1864,1 +1865,0 @@\n-        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n@@ -1957,0 +1957,9 @@\n+      Node* receiver = !call->method()->is_static() ? call->in(TypeFunc::Parms) : nullptr;\n+      if (ret->is_InlineType() &&\n+          receiver && receiver->bottom_type()->isa_instptr() &&\n+          receiver->bottom_type()->is_instptr()->instance_klass()->name()->get_symbol() == vmSymbols::jdk_internal_misc_Unsafe() &&\n+          call->method()->name()->get_symbol() == vmSymbols::makePrivateBuffer_name()) {\n+        \/\/ Re-buffer scalarized InlineTypeNodes returned from makePrivateBuffer\n+        \/\/ and transition the allocation into larval state.\n+        ret = ret->as_InlineType()->make_larval(this);\n+      }\n@@ -3458,1 +3467,1 @@\n-        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType() || obj->bottom_type()->is_inlinetypeptr(), \"should have been scalarized\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,26 @@\n+#include \"opto\/vectornode.hpp\"\n+\n+int  InlineTypeNode::stack_size_for_field(ciField* field) {\n+  return field->is_multifield_base()\n+             ? field->type()->elem_word_count()\n+             : field->type()->size();\n+}\n+\n+bool InlineTypeNode::is_multifield_scalarized(BasicType bt, int vec_len) {\n+  if (!is_java_primitive(bt) ||\n+      !Matcher::match_rule_supported_vector(Op_LoadVector, vec_len, bt)  ||\n+      !Matcher::match_rule_supported_vector(Op_StoreVector, vec_len, bt) ||\n+      !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool InlineTypeNode::is_multifield_scalarized(ciField* field) {\n+  if (!field->is_multifield_base()) {\n+    return true;\n+  }\n+  int field_count = field->secondary_fields_count();\n+  BasicType bt = field->type()->basic_type();\n+  return is_multifield_scalarized(bt, field_count);\n+}\n@@ -82,0 +108,4 @@\n+      if (vt->is_multifield_base(i) &&\n+          Matcher::vector_size_supported(type->basic_type(), vt->secondary_fields_count(i))) {\n+        t = TypeVect::make(t, vt->secondary_fields_count(i));\n+      }\n@@ -115,0 +145,1 @@\n+  assert(this->Opcode() == other->Opcode(), \"\");\n@@ -244,0 +275,15 @@\n+int InlineTypeNode::secondary_fields_count(uint index) const {\n+  assert(is_multifield_base(index), \"non-multifield field at index\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->secondary_fields_count();\n+}\n+\n+bool InlineTypeNode::is_multifield(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield();\n+}\n+\n+bool InlineTypeNode::is_multifield_base(uint index) const {\n+  assert(index < field_count(), \"index out of bounds\");\n+  return inline_klass()->declared_nonstatic_field_at(index)->is_multifield_base();\n+}\n+\n@@ -258,0 +304,8 @@\n+static bool is_vector_payload(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+}\n+\n+static bool is_vector_payload_mf(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayloadMF_klass());\n+}\n+\n@@ -261,0 +315,5 @@\n+  if (is_vector_payload_mf(vk)) {\n+     assert(field_count() == nfields, \"\");\n+  } else if (is_vector_payload(vk)) {\n+     assert(field_value(0)->as_InlineType()->field_count() == nfields, \"\");\n+  }\n@@ -276,0 +335,4 @@\n+\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(get_oop());\n+  sfpt->add_req(igvn->intcon(alloc && alloc->_larval ? 1 : 0));\n+\n@@ -425,1 +488,1 @@\n-      if (base->is_Con() && !is_array && !mismatched) {\n+      if (base->is_Con() && !is_array && !mismatched && !is_multifield_base(i)) {\n@@ -442,0 +505,1 @@\n+        BasicType bt = type2field[ft->basic_type()];\n@@ -444,1 +508,0 @@\n-        BasicType bt = type2field[ft->basic_type()];\n@@ -447,1 +510,7 @@\n-        value = kit->access_load_at(base, adr, adr_type, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+        ciField* field = inline_klass()->get_field_by_offset(field_offset(i), false);\n+        bool load_bundle = !InlineTypeNode::is_multifield_scalarized(field);\n+        if (load_bundle) {\n+          value = kit->gvn().transform(LoadVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, ft->bundle_size(), bt));\n+        } else {\n+          value = kit->access_load_at(base, adr, adr_type, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+        }\n@@ -478,0 +547,1 @@\n+  int field_idx = 0;\n@@ -486,1 +556,3 @@\n-      \/\/ Store field value to memory\n+      int vec_len = ft->bundle_size();\n+      BasicType bt = type2field[ft->basic_type()];\n+      const Type* val_type = Type::get_const_type(ft);\n@@ -489,4 +561,8 @@\n-      BasicType bt = type2field[ft->basic_type()];\n-      const Type* val_type = Type::get_const_type(ft);\n-      bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n-      kit->access_store_at(base, adr, adr_type, value, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+      if (value->bottom_type()->isa_vect()) {\n+        assert(value->bottom_type()->is_vect()->length() == (uint)vec_len, \"\");\n+        Node* store = kit->gvn().transform(StoreVectorNode::make(0, kit->control(), kit->memory(adr), adr, adr_type, value, vec_len));\n+        kit->set_memory(store, adr_type);\n+      } else {\n+        bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n+        kit->access_store_at(base, adr, adr_type, value, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators);\n+      }\n@@ -694,1 +770,1 @@\n-  if (oop->isa_InlineType() && !phase->type(oop)->maybe_null()) {\n+  if (oop->isa_InlineType() && !oop->isa_VectorBox() && !phase->type(oop)->maybe_null()) {\n@@ -724,1 +800,1 @@\n-        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n@@ -755,0 +831,13 @@\n+Node* InlineTypeNode::default_value(PhaseGVN& gvn, ciType* field_type, ciInlineKlass* klass, int index) {\n+  BasicType bt = field_type->basic_type();\n+  int vec_len = field_type->bundle_size();\n+  Node* value = gvn.zerocon(field_type->basic_type());\n+  bool is_multifield_base = klass->declared_nonstatic_field_at(index)->is_multifield_base();\n+  if (is_multifield_base &&\n+      is_java_primitive(bt) &&\n+      Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n+      value = gvn.transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field_type), false));\n+  }\n+  return value;\n+}\n+\n@@ -769,1 +858,1 @@\n-    Node* value = gvn.zerocon(ft->basic_type());\n+    Node* value = default_value(gvn, ft, vk, i);\n@@ -806,1 +895,2 @@\n-    if (!gvn->type(value)->is_zero_type()) {\n+    if (!gvn->type(value)->is_zero_type() &&\n+        !VectorNode::is_all_zeros_vector(value)) {\n@@ -922,1 +1012,1 @@\n-InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {\n+Node* InlineTypeNode::make_larval(GraphKit* kit) const {\n@@ -924,12 +1014,7 @@\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n-  if (allocate) {\n-    \/\/ Re-execute if buffering triggers deoptimization\n-    PreserveReexecuteState preexecs(kit);\n-    kit->jvms()->set_should_reexecute(true);\n-    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n-    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-    alloc->_larval = true;\n+  \/\/ Re-execute if buffering triggers deoptimization\n+  PreserveReexecuteState preexecs(kit);\n+  kit->jvms()->set_should_reexecute(true);\n+  Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+  Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+  alloc->_larval = true;\n@@ -938,8 +1023,2 @@\n-    store(kit, alloc_oop, alloc_oop, vk);\n-    res->set_oop(alloc_oop);\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, true));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  assert(!allocate || res->is_allocated(&kit->gvn()), \"must be allocated\");\n-  return res;\n+  store(kit, alloc_oop, alloc_oop, vk);\n+  return alloc_oop;\n@@ -948,2 +1027,1 @@\n-InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {\n-  Node* obj = get_oop();\n+InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk) {\n@@ -961,9 +1039,1 @@\n-  ciInlineKlass* vk = inline_klass();\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, false));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  return res;\n+  return InlineTypeNode::make_from_oop(kit, obj, vk->inline_klass(), !vk->maybe_null());\n@@ -1120,1 +1190,20 @@\n-      if (multi->is_Start()) {\n+      ciInlineKlass* ik = inline_klass();\n+      ciField* field = ik->declared_nonstatic_field_at(i);\n+      if (!InlineTypeNode::is_multifield_scalarized(field)) {\n+        Node* not_null_oop =  NULL;\n+        if (multi->is_Call()) {\n+          if (in) {\n+            not_null_oop = multi->as_Call()->in(base_input);\n+          } else {\n+            not_null_oop =  multi->as_Call()->proj_out(TypeFunc::Parms);\n+          }\n+          assert(not_null_oop->bottom_type()->isa_instptr(), \"\");\n+          load(kit, not_null_oop, not_null_oop, ik, visited, \/* holder_offset *\/ 0);\n+          parm = field_value(i);\n+        } else if (multi->is_Start()) {\n+          assert(in, \"return from start?\");\n+          parm = default_value(gvn, type, ik, i);\n+        } else {\n+          assert(false, \"unhandled case\");\n+        }\n+      } else if (multi->is_Start()) {\n@@ -1148,1 +1237,1 @@\n-      base_input += type->size();\n+      base_input += (type->size() \/ type->bundle_size());\n@@ -1175,1 +1264,1 @@\n-    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n@@ -1216,1 +1305,1 @@\n-    Node* value = gvn.zerocon(ft->basic_type());\n+    Node* value = default_value(gvn, ft, vk, i);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":137,"deletions":48,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -2314,1 +2314,1 @@\n- }\n+  }\n@@ -2334,0 +2334,11 @@\n+  if (_gvn.type(base)->is_inlinetypeptr() && is_store) {\n+    \/\/ FIXME: Larval bit check is needed to preserve the semantics of value\n+    \/\/ objects which can be mutated only if its _larval bit is set. Since\n+    \/\/ the oop is not always an AllocateNode, we have to find an utility way\n+    \/\/ to check the larval state for all kind of oops.\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+    if (alloc != nullptr) {\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+    }\n+  }\n+\n@@ -2362,0 +2373,5 @@\n+        \/\/ Skip over direct field access for VectorPayloadMF* class instances since\n+        \/\/ multifield is loaded into vector, alternatively we can create a lane\n+        \/\/ extraction logic. Given that unsafe put operations over vector payloads are part\n+        \/\/ of fallback implementation, for the time being suboptimality should not be major\n+        \/\/ concern.\n@@ -2363,1 +2379,1 @@\n-        if (field != nullptr) {\n+        if (field != nullptr && !VectorSupport::is_vector_payload_mf(vk->get_InlineKlass())) {\n@@ -2611,5 +2627,0 @@\n-  if (argument(1)->is_InlineType() && is_store) {\n-    InlineTypeNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(argument(1))->inline_klass());\n-    value = value->make_larval(this, false);\n-    replace_in_map(argument(1), value);\n-  }\n@@ -2632,1 +2643,1 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  set_result(value->as_InlineType()->make_larval(this));\n@@ -2639,6 +2650,4 @@\n-  if (!buffer->is_InlineType()) {\n-    return false;\n-  }\n-  InlineTypeNode* vt = buffer->as_InlineType();\n-  if (!vt->is_allocated(&_gvn)) {\n-    return false;\n+\n+  \/\/ Incoming value should be a buffer with inline type and not InlineTypeNode.\n+  if (buffer->is_InlineType() || !buffer->bottom_type()->is_inlinetypeptr()) {\n+     return false;\n@@ -2646,2 +2655,6 @@\n-  \/\/ TODO 8239003 Why is this needed?\n-  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n+\n+  \/\/ Allocation node must exist to generate IR for transitioning allocation out\n+  \/\/ of larval state. Disable the intrinsic and take unsafe slow path if allocation\n+  \/\/ is not reachable,  oop returned by Unsafe_finishPrivateBuffer native method\n+  \/\/ will automatically rematerialize InlineTypeNode.\n+  if (AllocateNode::Ideal_allocation(buffer) == nullptr) {\n@@ -2650,1 +2663,0 @@\n-\n@@ -2655,2 +2667,2 @@\n-\n-  set_result(vt->finish_larval(this));\n+  const TypeInstPtr* ptr = buffer->bottom_type()->isa_instptr();\n+  set_result(InlineTypeNode::finish_larval(this, buffer, ptr));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -112,1 +112,3 @@\n-      if (C->inlining_incrementally() && res->is_InlineType()) {\n+      \/\/ VectorBoxes should be treated as special InlineTypeNodes, we will defer its buffering\n+      \/\/ to a later stage to give opportunity for consumption by subsequent expanders.\n+      if (C->inlining_incrementally() && res->is_InlineType() && !res->is_VectorBox()) {\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -961,1 +961,4 @@\n-\n+  \/\/ Bufferes in larval state should not be scalarized.\n+  if (alloc->_larval) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1244,1 +1244,6 @@\n-  if (base != nullptr && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n+  if (base != nullptr && base->is_InlineType() &&\n+      \/\/ Multifields are loaded into vectors and lane level loads needs\n+      \/\/ an explicit extraction operation.\n+      (bottom_type()->isa_vect() ||\n+       !VectorSupport::is_vector_payload_mf(base->as_InlineType()->inline_klass()->get_InlineKlass())) &&\n+      offset > oopDesc::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+class VectorBoxNode;\n@@ -739,0 +740,1 @@\n+        DEFINE_CLASS_ID(VectorBox, InlineType, 0)\n@@ -984,0 +986,1 @@\n+  DEFINE_CLASS_QUERY(VectorBox)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -807,0 +807,1 @@\n+      ScopeValue* is_larval = nullptr;\n@@ -819,0 +820,6 @@\n+\n+        Node* larval_node = sfpt->in(first_ind++);\n+        assert(larval_node != nullptr && larval_node->is_Con(), \"is_larval node not found\");\n+\n+        const TypeInt* larval_type = larval_node->bottom_type()->is_int();\n+        is_larval = new ConstantIntValue(larval_type->get_con());\n@@ -821,1 +828,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init);\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), is_init, is_larval);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -926,1 +926,8 @@\n-    if (tf()->returns_inline_type_as_fields()) {\n+    if (res->isa_InlineType() && VectorSupport::skip_value_scalarization(res->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+      InlineTypeNode* vt = res->as_InlineType();\n+      \/\/ Prevent returning uninitialized VBA, this will make associated box useless and\n+      \/\/ will be swept by dead code eliminator. Once VBA is expanded and initialized during\n+      \/\/ PhaseVector box users will be tied to newly allocated and initialized objects.\n+      assert(vt->get_is_buffered(), \"\");\n+      ret->add_req(vt->get_is_buffered()->get_int() ? vt->get_oop() : res);\n+    } else if (tf()->returns_inline_type_as_fields()) {\n@@ -1149,1 +1156,1 @@\n-  \/\/ record exit from a method if compiled while Dtrace is turned on.\n+  \/\/ record exit from a method if compiled while Dtrace is returned on.\n@@ -1772,3 +1779,6 @@\n-          \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n-          assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n-          map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(n);\n+          if (alloc == nullptr || !alloc->_larval) {\n+            \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n+            assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n+            map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          }\n@@ -1879,1 +1889,1 @@\n-      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n+      } else if (m->is_InlineType() && n->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n@@ -1918,1 +1928,1 @@\n-      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr()) {\n+      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr() && m->is_InlineType() && n->is_InlineType()) {\n@@ -2369,2 +2379,9 @@\n-    if ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n-        return_type->is_inlinetypeptr()) {\n+    \/\/ Buffer vector return values, for regular inline object caller\n+    \/\/ expects scalarized fields to be passed back.\n+    bool is_vector_value = value->is_InlineType() &&\n+                           VectorSupport::skip_value_scalarization(value->as_InlineType()->inline_klass()->get_InlineKlass());\n+    \/\/ Defer returning VectorBoxAllocation node, they will be expanded and initialized\n+    \/\/ during box expansion and will replace all uses of box.\n+    bool skip_scalarization = is_vector_value && Compile::current()->inlining_incrementally();\n+    if (!is_vector_value && ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n+        return_type->is_inlinetypeptr())) {\n@@ -2384,1 +2401,2 @@\n-    } else if (value->is_InlineType()) {\n+    } else if (skip_scalarization ||\n+               (value->Opcode() != Op_VectorBox && value->is_InlineType())) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -342,1 +343,1 @@\n-  int holder_depth = field->type()->size();\n+  int holder_depth = field->type()->size() \/ field->type()->bundle_size();\n@@ -359,1 +360,1 @@\n-    int nargs = 1 + field->type()->size();\n+    int nargs = 1 + field->type()->size() \/ field->type()->bundle_size();\n@@ -368,1 +369,14 @@\n-  new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n+\n+  BasicType bt = field->type()->basic_type();\n+  int vec_len = field->secondary_fields_count();\n+  bool scalarize_fields = !field->is_multifield_base() || !is_java_primitive(bt) ||\n+                          !Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt);\n+  if (scalarize_fields) {\n+    for(int i = 0; i < vec_len; i++) {\n+      new_vt->set_field_value_by_offset(field->offset_in_bytes() + i * type2aelembytes(bt), val);\n+    }\n+  } else {\n+    val = _gvn.transform(VectorNode::scalar2vector(val, field->secondary_fields_count(), Type::get_const_type(field->type()), false));\n+    new_vt->set_field_value_by_offset(field->offset_in_bytes(), val);\n+  }\n+\n@@ -372,1 +386,1 @@\n-    int nargs = 1 + field->type()->size();\n+    int nargs = 1 + InlineTypeNode::stack_size_for_field(field);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -989,0 +990,4 @@\n+  case Op_ReplicateF:\n+    return n->in(1)->bottom_type() == TypeF::ZERO;\n+  case Op_ReplicateD:\n+    return n->in(1)->bottom_type() == TypeD::ZERO;\n@@ -1413,0 +1418,17 @@\n+Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1)->Opcode() == Op_VectorStoreMask) {\n+    if (Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+      \/\/ \/\/ Handled by VectorLoadMaskNode::Identity()\n+    } else {\n+      const TypeVect* out_vt = vect_type();\n+      const TypeVect* in_vt = in(1)->in(1)->bottom_type()->is_vect();\n+      if (out_vt->length() == in_vt->length() &&\n+          out_vt->length_in_bytes() == in_vt->length_in_bytes()) {\n+        const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n+        return new VectorMaskCastNode(in(1)->in(1), vmask_type);\n+      }\n+    }\n+  }\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1414,1 +1436,1 @@\n-  BasicType out_bt = type()->is_vect()->element_basic_type();\n+  BasicType out_bt = vect_type()->element_basic_type();\n@@ -1419,0 +1441,5 @@\n+  \/\/ VectorLoadMask (VectorStoreMask mask) ==> mask\n+  if (in(1)->Opcode() == Op_VectorStoreMask &&\n+      Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+    return in(1)->in(1);\n+  }\n@@ -1743,38 +1770,18 @@\n-Node* VectorUnboxNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* n = obj()->uncast();\n-  if (EnableVectorReboxing && n->Opcode() == Op_VectorBox) {\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n-      \/\/ Handled by VectorUnboxNode::Identity()\n-    } else {\n-      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(n);\n-      ciKlass* vbox_klass = vbox->box_type()->instance_klass();\n-      const TypeVect* in_vt = vbox->vec_type();\n-      const TypeVect* out_vt = type()->is_vect();\n-\n-      if (in_vt->length() == out_vt->length()) {\n-        Node* value = vbox->in(VectorBoxNode::Value);\n-\n-        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-        if (is_vector_mask) {\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n-          const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n-          return new VectorMaskCastNode(value, vmask_type);\n-        } else if (is_vector_shuffle) {\n-          if (!is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n-            return new VectorLoadShuffleNode(value, out_vt);\n-          }\n-        } else {\n-          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n-        }\n-      } else {\n-        \/\/ Vector length mismatch.\n-        \/\/ Sometimes happen in pathological cases (e.g., when unboxing happens in effectively dead code).\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-  Node* n = obj()->uncast();\n+  Node* n = obj();\n+  assert(n->is_InlineType(), \"\");\n+  if (!n->is_VectorBox()) {\n+    \/\/ FIXME: Directly return Vector loaded from multi-field for concrete\n+    \/\/ vector InlineType nodes. This can save deferring unbox expansion.\n+    \/\/ For masks\/shuffle emit additional pruning IR to match the vector size.\n+  }\n+  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n+  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n+  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n+  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n+  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n+  \/\/ to get to the VectorBox.\n+  if (!n->is_VectorBox() &&\n+      VectorSupport::is_vector(n->as_InlineType()->inline_klass()->get_InlineKlass())) {\n+    n = n->as_InlineType()->get_oop();\n+  }\n+  n = n->uncast();\n@@ -1783,4 +1790,2 @@\n-    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n-      return n->in(VectorBoxNode::Value); \/\/ VectorUnbox (VectorBox v) ==> v\n-    } else {\n-      \/\/ Handled by VectorUnboxNode::Ideal().\n+    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n+      return n->as_VectorBox()->get_vec(); \/\/ VectorUnbox (VectorBox v) ==> v\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":48,"deletions":43,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1509,0 +1510,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1686,1 +1688,1 @@\n-class VectorBoxNode : public Node {\n+class VectorBoxNode : public InlineTypeNode {\n@@ -1688,12 +1690,31 @@\n-  const TypeInstPtr* const _box_type;\n-  const TypeVect*    const _vec_type;\n- public:\n-  enum {\n-     Box   = 1,\n-     Value = 2\n-  };\n-  VectorBoxNode(Compile* C, Node* box, Node* val,\n-                const TypeInstPtr* box_type, const TypeVect* vt)\n-    : Node(nullptr, box, val), _box_type(box_type), _vec_type(vt) {\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n+  const TypeInstPtr* _box_type;\n+  const TypeVect*    _vec_type;\n+\n+ public:\n+  void set_box_type(const TypeInstPtr* box_type) { _box_type = box_type; }\n+  void set_vec_type(const TypeVect* vec_type) { _vec_type = vec_type; }\n+\n+  VectorBoxNode(Compile* C, ciInlineKlass* vk, Node* oop, const TypeInstPtr* box_type, const TypeVect* vt, bool null_free) :\n+    InlineTypeNode(vk, oop, null_free) {\n+      init_flags(Flag_is_macro);\n+      init_class_id(Class_VectorBox);\n+      set_vec_type(vt);\n+      set_box_type(box_type);\n+      C->add_macro_node(this);\n+  }\n+\n+  static VectorBoxNode* make_box_node(PhaseGVN& gvn, Compile* C, Node* box, Node* val,\n+                                      const TypeInstPtr* box_type, const TypeVect* vt) {\n+    ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n+    VectorBoxNode* box_node = new VectorBoxNode(C, vk, box, box_type, vt, false);\n+\n+    ciInlineKlass* payload = vk->declared_nonstatic_field_at(0)->type()->as_inline_klass();\n+    Node* payload_value = InlineTypeNode::make_uninitialized(gvn, payload, true);\n+    payload_value->as_InlineType()->set_field_value(0, val);\n+    payload_value = gvn.transform(payload_value);\n+\n+    box_node->set_field_value(0, payload_value);\n+    box_node->set_is_buffered(gvn, false);\n+    box_node->set_is_init(gvn);\n+\n+    return box_node;\n@@ -1705,0 +1726,5 @@\n+  Node*  get_vec() {\n+    assert(field_value(0)->is_InlineType(), \"\");\n+    return field_value(0)->as_InlineType()->field_value(0);\n+  }\n+\n@@ -1728,2 +1754,0 @@\n- private:\n-  bool _shuffle_to_vector;\n@@ -1733,1 +1757,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n@@ -1735,1 +1759,0 @@\n-    _shuffle_to_vector = shuffle_to_vector;\n@@ -1745,2 +1768,0 @@\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":40,"deletions":19,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2296,0 +2296,4 @@\n+bool Arguments::enable_valhalla(const char* prop_value) {\n+  return strstr(prop_value, \"jdk.incubator.vector\");\n+}\n+\n@@ -2405,0 +2409,3 @@\n+      if (enable_valhalla(tail)) {\n+        EnablePrimitiveClasses = true;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -323,0 +323,2 @@\n+  static bool enable_valhalla(const char* prop_value);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1278,8 +1278,0 @@\n-#if COMPILER2_OR_JVMCI\n-        if (EnableVectorSupport && VectorSupport::is_vector(ik)) {\n-          obj = VectorSupport::allocate_vector(ik, fr, reg_map, sv, THREAD);\n-        } else {\n-          obj = ik->allocate_instance(THREAD);\n-        }\n-#else\n-#endif \/\/ COMPILER2_OR_JVMCI\n@@ -1306,0 +1298,8 @@\n+    if (k->is_inline_klass()) {\n+      intptr_t is_larval = StackValue::create_stack_value(fr, reg_map, sv->is_larval())->get_jint();\n+      jint larval = (jint)*((jint*)&is_larval);\n+      if (larval == 1) {\n+        obj->set_mark(obj->mark().enter_larval_state());\n+      }\n+    }\n+\n@@ -1503,0 +1503,1 @@\n+  int _secondary_fields_count;\n@@ -1504,1 +1505,1 @@\n-  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false) { }\n+  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false), _secondary_fields_count(0) { }\n@@ -1511,0 +1512,36 @@\n+static void init_multi_field(oop obj, int offset, BasicType elem_bt, address addr) {\n+  switch (elem_bt) {\n+    case T_BOOLEAN: obj->bool_field_put(offset, *(jboolean*)addr); break;\n+    case T_BYTE:    obj->byte_field_put(offset, *(jbyte*)addr); break;\n+    case T_SHORT:   obj->short_field_put(offset, *(jshort*)addr); break;\n+    case T_INT:     obj->int_field_put(offset, *(jint*)addr); break;\n+    case T_FLOAT:   obj->float_field_put(offset, *(jfloat*)addr); break;\n+    case T_LONG:    obj->long_field_put(offset, *(jlong*)addr); break;\n+    case T_DOUBLE:  obj->double_field_put(offset, *(jdouble*)addr); break;\n+    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n+  }\n+}\n+\n+static void reassign_vectorized_multi_fields(frame* fr, RegisterMap* reg_map, Location location, oop obj, int offset, BasicType elem_bt, int fields_count) {\n+  int elem_size = type2aelembytes(elem_bt);\n+  if (location.is_register()) {\n+    \/\/ Value was in a callee-saved register.\n+    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+\n+    for (int i = 0; i < fields_count; i++) {\n+      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+      int second_offset = offset + i * elem_size;\n+      init_multi_field(obj, second_offset, elem_bt, elem_addr);\n+    }\n+  } else {\n+    \/\/ Value was directly saved on the stack.\n+    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+    for (int i = 0; i < fields_count; i++) {\n+      int second_offset = offset + i * elem_size;\n+      init_multi_field(obj, second_offset, elem_bt, base_addr + i * elem_size);\n+    }\n+  }\n+}\n+\n@@ -1518,1 +1555,1 @@\n-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.field_flags().is_injected())) {\n+      if (!fs.access_flags().is_static() && !fs.is_multifield() && (!skip_internal || !fs.field_flags().is_injected())) {\n@@ -1522,0 +1559,1 @@\n+        field._secondary_fields_count = fs.is_multifield_base() ? fs.field_descriptor().secondary_fields_count(fs.index()) : 1;\n@@ -1549,17 +1587,34 @@\n-    ScopeValue* scope_field = sv->field_at(svIndex);\n-    StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n-    switch (type) {\n-      case T_OBJECT:\n-      case T_ARRAY:\n-        assert(value->type() == T_OBJECT, \"Agreement.\");\n-        obj->obj_field_put(offset, value->get_obj()());\n-        break;\n-\n-      case T_INT: case T_FLOAT: { \/\/ 4 bytes.\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        bool big_value = false;\n-        if (i+1 < fields->length() && fields->at(i+1)._type == T_INT) {\n-          if (scope_field->is_location()) {\n-            Location::Type type = ((LocationValue*) scope_field)->location().type();\n-            if (type == Location::dbl || type == Location::lng) {\n-              big_value = true;\n+\n+    int secondary_fields_count = fields->at(i)._secondary_fields_count;\n+    if (sv->field_at(svIndex)->is_location()) {\n+      Location location = sv->field_at(svIndex)->as_LocationValue()->location();\n+      if (location.type() == Location::vector) {\n+        \/\/ Re-assign vectorized multi-fields\n+        reassign_vectorized_multi_fields(fr, reg_map, location, obj, offset, type, secondary_fields_count);\n+        svIndex++;\n+        continue;\n+      }\n+    }\n+\n+    assert(secondary_fields_count <= sv->field_size(), \"\");\n+    for (int j = 0; j < secondary_fields_count; j++) {\n+      ScopeValue* scope_field = sv->field_at(svIndex);\n+      StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n+      int sec_offset = offset + j * type2aelembytes(type);\n+      switch (type) {\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          assert(value->type() == T_OBJECT, \"Agreement.\");\n+          obj->obj_field_put(sec_offset, value->get_obj()());\n+          break;\n+\n+        \/\/ Have to cast to INT (32 bits) pointer to avoid little\/big-endian problem.\n+        case T_INT: case T_FLOAT: { \/\/ 4 bytes.\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          bool big_value = false;\n+          if (i+1 < fields->length() && fields->at(i+1)._type == T_INT) {\n+            if (scope_field->is_location()) {\n+              Location::Type type = ((LocationValue*) scope_field)->location().type();\n+              if (type == Location::dbl || type == Location::lng) {\n+                big_value = true;\n+              }\n@@ -1567,5 +1622,5 @@\n-          }\n-          if (scope_field->is_constant_int()) {\n-            ScopeValue* next_scope_field = sv->field_at(svIndex + 1);\n-            if (next_scope_field->is_constant_long() || next_scope_field->is_constant_double()) {\n-              big_value = true;\n+            if (scope_field->is_constant_int()) {\n+              ScopeValue* next_scope_field = sv->field_at(svIndex + 1);\n+              if (next_scope_field->is_constant_long() || next_scope_field->is_constant_double()) {\n+                big_value = true;\n+              }\n@@ -1574,8 +1629,8 @@\n-        }\n-        if (big_value) {\n-          i++;\n-          assert(i < fields->length(), \"second T_INT field needed\");\n-          assert(fields->at(i)._type == T_INT, \"T_INT field needed\");\n-        } else {\n-          obj->int_field_put(offset, value->get_jint());\n-          break;\n+          if (big_value) {\n+            i++;\n+            assert(i < fields->length(), \"second T_INT field needed\");\n+            assert(fields->at(i)._type == T_INT, \"T_INT field needed\");\n+          } else {\n+            obj->int_field_put(sec_offset, value->get_jint());\n+            break;\n+          }\n@@ -1584,1 +1639,0 @@\n-      }\n@@ -1587,11 +1641,11 @@\n-      case T_LONG: case T_DOUBLE: {\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        StackValue* low = StackValue::create_stack_value(fr, reg_map, sv->field_at(++svIndex));\n-#ifdef _LP64\n-        jlong res = (jlong)low->get_intptr();\n-#else\n-        jlong res = jlong_from(value->get_jint(), low->get_jint());\n-#endif\n-        obj->long_field_put(offset, res);\n-        break;\n-      }\n+        case T_LONG: case T_DOUBLE: {\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          StackValue* low = StackValue::create_stack_value(fr, reg_map, sv->field_at(++svIndex));\n+  #ifdef _LP64\n+          jlong res = (jlong)low->get_intptr();\n+  #else\n+          jlong res = jlong_from((jint)value->get_int(), (jint)low->get_jint());\n+  #endif\n+          obj->long_field_put(sec_offset, res);\n+          break;\n+        }\n@@ -1599,4 +1653,4 @@\n-      case T_SHORT:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        obj->short_field_put(offset, (jshort)value->get_jint());\n-        break;\n+        case T_SHORT:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          obj->short_field_put(sec_offset, (jshort)value->get_jint());\n+          break;\n@@ -1604,4 +1658,4 @@\n-      case T_CHAR:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        obj->char_field_put(offset, (jchar)value->get_jint());\n-        break;\n+        case T_CHAR:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          obj->char_field_put(sec_offset, (jchar)value->get_jint());\n+          break;\n@@ -1609,4 +1663,4 @@\n-      case T_BYTE:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        obj->byte_field_put(offset, (jbyte)value->get_jint());\n-        break;\n+        case T_BYTE:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          obj->byte_field_put(sec_offset, (jbyte)value->get_jint());\n+          break;\n@@ -1614,4 +1668,4 @@\n-      case T_BOOLEAN:\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        obj->bool_field_put(offset, (jboolean)value->get_jint());\n-        break;\n+        case T_BOOLEAN:\n+          assert(value->type() == T_INT, \"Agreement.\");\n+          obj->bool_field_put(sec_offset, (jboolean)value->get_jint());\n+          break;\n@@ -1619,2 +1673,4 @@\n-      default:\n-        ShouldNotReachHere();\n+        default:\n+          ShouldNotReachHere();\n+      }\n+      svIndex++;\n@@ -1622,1 +1678,0 @@\n-    svIndex++;\n@@ -1665,21 +1720,0 @@\n-#if COMPILER2_OR_JVMCI\n-    if (EnableVectorSupport && VectorSupport::is_vector(k)) {\n-      assert(sv->field_size() == 1, \"%s not a vector\", k->name()->as_C_string());\n-      ScopeValue* payload = sv->field_at(0);\n-      if (payload->is_location() &&\n-          payload->as_LocationValue()->location().type() == Location::vector) {\n-#ifndef PRODUCT\n-        if (PrintDeoptimizationDetails) {\n-          tty->print_cr(\"skip field reassignment for this vector - it should be assigned already\");\n-          if (Verbose) {\n-            Handle obj = sv->value();\n-            k->oop_print_on(obj(), tty);\n-          }\n-        }\n-#endif \/\/ !PRODUCT\n-        continue; \/\/ Such vector's value was already restored in VectorSupport::allocate_vector().\n-      }\n-      \/\/ Else fall-through to do assignment for scalar-replaced boxed vector representation\n-      \/\/ which could be restored after vector object allocation.\n-    }\n-#endif \/* !COMPILER2_OR_JVMCI *\/\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":126,"deletions":92,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -556,0 +557,3 @@\n+JRT_LEAF(int, SharedRuntime::skip_value_scalarization(InlineKlass* klass))\n+  return (int) VectorSupport::skip_value_scalarization(klass);\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,0 +218,3 @@\n+# lworld+vector\n+compiler\/vectorapi\/VectorReinterpretTest.java\n+compiler\/vectorapi\/reshape\/TestVectorReinterpret.java\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    @IR(failOn = {CALL_UNSAFE})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n@@ -209,1 +209,1 @@\n-  for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}