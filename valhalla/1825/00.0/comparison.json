{"files":[{"patch":"@@ -1195,2 +1195,2 @@\n-            build_number: \"3\",\n-            file: \"bundles\/jcov-3.0+3.zip\",\n+            build_number: \"5\",\n+            file: \"bundles\/jcov-3.0+5.zip\",\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5503,1 +5503,0 @@\n-  assert(! Universe::heap()->is_in(k), \"should not be an oop\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+#include \"services\/management.hpp\"\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,0 +165,4 @@\n+\n+  \/\/ Fetch Klass::access_flags.\n+  jint                   access_flags() { return flags().as_int(); }\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -219,9 +219,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciKlass::access_flags\n-jint ciKlass::access_flags() {\n-  assert(is_loaded(), \"not loaded\");\n-  GUARDED_VM_ENTRY(\n-    return get_Klass()->access_flags().as_unsigned_short();\n-  )\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -136,3 +136,0 @@\n-  \/\/ Fetch Klass::access_flags.\n-  jint                   access_flags();\n-\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1097,4 +1097,0 @@\n-  \/\/ Set the raw access_flags, this is used by reflection instead of modifier flags.\n-  \/\/ The Java code for array classes gets the access flags from the element type.\n-  assert(!k->is_array_klass() || k->access_flags().as_unsigned_short() == 0, \"access flags are not set for arrays\");\n-  set_raw_access_flags(mirror(), k->access_flags().as_unsigned_short());\n@@ -1110,0 +1106,2 @@\n+    \/\/ The Java code for array classes gets the access flags from the element type.\n+    set_raw_access_flags(mirror(), 0);\n@@ -1146,0 +1144,2 @@\n+    \/\/ Set the raw access_flags, this is used by reflection instead of modifier flags.\n+    set_raw_access_flags(mirror(), InstanceKlass::cast(k)->access_flags().as_unsigned_short());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2302,3 +2302,4 @@\n-  return klass->is_public() &&\n-         (InstanceKlass::cast(klass)->is_same_class_package(vmClasses::Object_klass()) ||       \/\/ java.lang\n-          InstanceKlass::cast(klass)->is_same_class_package(vmClasses::MethodHandle_klass()));  \/\/ java.lang.invoke\n+  InstanceKlass* ik = InstanceKlass::cast(klass);\n+  return ik->is_public() &&\n+         (ik->is_same_class_package(vmClasses::Object_klass()) ||       \/\/ java.lang\n+          ik->is_same_class_package(vmClasses::MethodHandle_klass()));  \/\/ java.lang.invoke\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1395,1 +1395,1 @@\n-      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), ConstraintCastNode::StrongDependency);\n+      Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base->bottom_type(), ConstraintCastNode::DependencyType::NonFloatingNarrowing);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-  template <class T>\n-  inline void arraycopy_marking(T* dst, size_t count);\n+  template <bool IS_GENERATIONAL, class T>\n+  void arraycopy_marking(T* dst, size_t count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -434,1 +434,5 @@\n-    arraycopy_marking(dst, count);\n+    if (_heap->mode()->is_generational()) {\n+      arraycopy_marking<true>(dst, count);\n+    } else {\n+      arraycopy_marking<false>(dst, count);\n+    }\n@@ -446,1 +450,1 @@\n-template <class T>\n+template <bool IS_GENERATIONAL, class T>\n@@ -450,1 +454,2 @@\n-    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(dst))) {\n+    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(dst)) ||\n+        (IS_GENERATIONAL && _heap->heap_region_containing(dst)->is_old() && _heap->is_concurrent_young_mark_in_progress())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -90,0 +90,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_AOTEndRecording(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -226,0 +226,1 @@\n+  nonstatic_field(InstanceKlass,               _access_flags,                                 AccessFlags)                           \\\n@@ -285,1 +286,0 @@\n-  nonstatic_field(Klass,                       _access_flags,                                 AccessFlags)                           \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -549,1 +549,1 @@\n-      MutexLocker ml(THREAD, FullGCALot_lock);\n+      MutexLocker ml(THREAD, FullGCALot_lock, Mutex::_no_safepoint_check_flag);\n@@ -1489,1 +1489,1 @@\n-  MutexLocker ml(FullGCALot_lock);\n+  MutexLocker ml(FullGCALot_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,2 @@\n-  set_is_cloneable(); \/\/ All arrays are considered to be cloneable (See JLS 20.1.5)\n+  \/\/ All arrays are considered to be cloneable (See JLS 20.1.5)\n+  set_is_cloneable_fast();\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/accessFlags.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -616,0 +616,11 @@\n+void InstanceKlass::set_is_cloneable() {\n+  if (name() == vmSymbols::java_lang_invoke_MemberName()) {\n+    assert(is_final(), \"no subclasses allowed\");\n+    \/\/ MemberName cloning should not be intrinsified and always happen in JVM_Clone.\n+  } else if (reference_type() != REF_NONE) {\n+    \/\/ Reference cloning should not be intrinsified and always happen in JVM_Clone.\n+  } else {\n+    set_is_cloneable_fast();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -277,0 +277,2 @@\n+  AccessFlags        _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n+\n@@ -357,0 +359,16 @@\n+  \/\/ Access flags\n+  AccessFlags access_flags() const         { return _access_flags;  }\n+  void set_access_flags(AccessFlags flags) { _access_flags = flags; }\n+\n+  bool is_public() const                { return _access_flags.is_public(); }\n+  bool is_final() const                 { return _access_flags.is_final(); }\n+  bool is_interface() const override    { return _access_flags.is_interface(); }\n+  bool is_abstract() const override     { return _access_flags.is_abstract(); }\n+  bool is_synthetic() const             { return _access_flags.is_synthetic(); }\n+  void set_is_synthetic()               { _access_flags.set_is_synthetic(); }\n+  bool is_identity_class() const override { return _access_flags.is_identity_class(); }\n+\n+  static ByteSize access_flags_offset() { return byte_offset_of(InstanceKlass, _access_flags); }\n+\n+  void set_is_cloneable();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,11 +75,0 @@\n-void Klass::set_is_cloneable() {\n-  if (name() == vmSymbols::java_lang_invoke_MemberName()) {\n-    assert(is_final(), \"no subclasses allowed\");\n-    \/\/ MemberName cloning should not be intrinsified and always happen in JVM_Clone.\n-  } else if (is_instance_klass() && InstanceKlass::cast(this)->reference_type() != REF_NONE) {\n-    \/\/ Reference cloning should not be intrinsified and always happen in JVM_Clone.\n-  } else {\n-    _misc_flags.set_is_cloneable_fast(true);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"utilities\/accessFlags.hpp\"\n@@ -127,3 +126,2 @@\n-  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n-                                \/\/ Some flags created by the JVM, not in the class file itself,\n-                                \/\/ are in _misc_flags below.\n+  \/\/ Some flags created by the JVM, not in the class file itself,\n+  \/\/ are in _misc_flags below.\n@@ -460,1 +458,0 @@\n-  static ByteSize access_flags_offset()          { return byte_offset_of(Klass, _access_flags); }\n@@ -737,11 +734,5 @@\n-  \/\/ Access flags\n-  AccessFlags access_flags() const         { return _access_flags;  }\n-  void set_access_flags(AccessFlags flags) { _access_flags = flags; }\n-\n-  bool is_public() const                { return _access_flags.is_public(); }\n-  bool is_final() const                 { return _access_flags.is_final(); }\n-  bool is_interface() const             { return _access_flags.is_interface(); }\n-  bool is_abstract() const              { return _access_flags.is_abstract(); }\n-  bool is_synthetic() const             { return _access_flags.is_synthetic(); }\n-  bool is_identity_class() const        { assert(is_instance_klass(), \"only for instanceKlass\"); return _access_flags.is_identity_class(); }\n-  void set_is_synthetic()               { _access_flags.set_is_synthetic(); }\n+\n+  virtual bool is_interface() const     { return false; }\n+  virtual bool is_abstract() const      { return false; }\n+  virtual bool is_identity_class() const { return false; }\n+\n@@ -760,1 +751,1 @@\n-  void set_is_cloneable();\n+  void set_is_cloneable_fast() { _misc_flags.set_is_cloneable_fast(true); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  assert(element->is_final(), \"Flat layouts below require monomorphic elements\");\n@@ -183,0 +182,1 @@\n+  assert(vk->is_final(), \"Flat layouts below require monomorphic elements\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"castnode.hpp\"\n@@ -41,0 +40,5 @@\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::FloatingNarrowing(true, true, \"floating narrowing dependency\"); \/\/ not pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::FloatingNonNarrowing(true, false, \"floating non-narrowing dependency\"); \/\/ not pinned, doesn't narrow type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::NonFloatingNarrowing(false, true, \"non-floating narrowing dependency\"); \/\/ pinned, narrows type\n+const ConstraintCastNode::DependencyType ConstraintCastNode::DependencyType::NonFloatingNonNarrowing(false, false, \"non-floating non-narrowing dependency\"); \/\/ pinned, doesn't narrow type\n+\n@@ -44,1 +48,2 @@\n-  if (_dependency == UnconditionalDependency) {\n+  if (!_dependency.narrows_type()) {\n+    \/\/ If this cast doesn't carry a type dependency (i.e. not used for type narrowing), we cannot optimize it.\n@@ -47,0 +52,4 @@\n+\n+  \/\/ This cast node carries a type dependency. We can remove it if:\n+  \/\/ - Its input has a narrower type\n+  \/\/ - There's a dominating cast with same input but narrower type\n@@ -130,1 +139,1 @@\n-  return TypeNode::hash() + (int)_dependency + (_extra_types != nullptr ? _extra_types->hash() : 0);\n+  return TypeNode::hash() + _dependency.hash() + (_extra_types != nullptr ? _extra_types->hash() : 0);\n@@ -138,1 +147,1 @@\n-  if (cast._dependency != _dependency) {\n+  if (!cast._dependency.cmp(_dependency)) {\n@@ -151,1 +160,1 @@\n-Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt) {\n+Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt) {\n@@ -164,3 +173,3 @@\n-  if (_dependency == UnconditionalDependency) {\n-    return nullptr;\n-  }\n+  \/\/ See discussion at definition of ConstraintCastNode::DependencyType: replacing this cast with a dominating one is\n+  \/\/ not safe if _dependency.narrows_type() is not true.\n+  assert(_dependency.narrows_type(), \"cast can't be replaced by dominating one\");\n@@ -226,3 +235,2 @@\n-  if (_dependency != RegularDependency) {\n-    st->print(\" %s dependency\", _dependency == StrongDependency ? \"strong\" : \"unconditional\");\n-  }\n+  st->print(\" \");\n+  _dependency.dump_on(st);\n@@ -232,10 +240,3 @@\n-const Type* CastIINode::Value(PhaseGVN* phase) const {\n-  const Type *res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_int(), \"res must be int\");\n-\n-  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n-  \/\/ see if we can remove type assertion after loop opts\n-  res = widen_type(phase, res, T_INT);\n+CastIINode* CastIINode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastIINode(in(0), parent, type, dependency, _range_check_dependency, _extra_types);\n+}\n@@ -243,1 +244,2 @@\n-  return res;\n+CastLLNode* CastLLNode::make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  return new CastLLNode(in(0), parent, type, dependency, _extra_types);\n@@ -246,4 +248,2 @@\n-Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n-  Node* n = clone();\n-  n->set_req(1, parent);\n-  n->as_ConstraintCast()->set_type(type);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+  Node* n = make_with(parent, type, dependency);\n@@ -263,2 +263,2 @@\n-  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+  if (!phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -270,1 +270,0 @@\n-  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -300,1 +299,1 @@\n-  assert(_dependency == RegularDependency, \"already pinned\");\n+  assert(_dependency.is_floating(), \"already pinned\");\n@@ -302,1 +301,1 @@\n-    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+    return new CastIINode(in(0), in(1), bottom_type(), _dependency.with_pinned_dependency(), has_range_check());\n@@ -336,10 +335,0 @@\n-const Type* CastLLNode::Value(PhaseGVN* phase) const {\n-  const Type* res = ConstraintCastNode::Value(phase);\n-  if (res == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  assert(res->isa_long(), \"res must be long\");\n-\n-  return widen_type(phase, res, T_LONG);\n-}\n-\n@@ -413,1 +402,1 @@\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    \/\/ makes sure we run widen_type() to potentially common type assertions after loop opts\n@@ -600,1 +589,1 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -621,1 +610,1 @@\n-Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+Node* ConstraintCastNode::optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt) {\n@@ -643,2 +632,36 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n-    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n+    const TypeInteger* tx = phase->type(x)->is_integer(bt);\n+    const TypeInteger* ty = phase->type(y)->is_integer(bt);\n+\n+    \/\/ (Cast (Add x y) tz) is transformed into (Add (Cast x rx) (Cast y ry))\n+    \/\/\n+    \/\/ tz = [tzlo, tzhi]\n+    \/\/ rx = [rxlo, rxhi]\n+    \/\/ ry = [rylo, ryhi]\n+    \/\/ with type of x, tx = [txlo, txhi]\n+    \/\/ with type of y, ty = [tylo, tyhi]\n+    \/\/\n+    \/\/ From Compile::push_thru_add():\n+    \/\/ rxlo = max(tzlo - tyhi, txlo)\n+    \/\/ rxhi = min(tzhi - tylo, txhi)\n+    \/\/ rylo = max(tzlo - txhi, tylo)\n+    \/\/ ryhi = min(tzhi - txlo, tyhi)\n+    \/\/\n+    \/\/ If x is a constant, then txlo = txhi\n+    \/\/ rxlo = txlo, rxhi = txhi\n+    \/\/ The bounds of the type of the Add after transformation then is:\n+    \/\/ rxlo + rylo >= txlo + tzlo - txhi >= tzlo\n+    \/\/ rxhi + ryhi <= txhi + tzhi - txlo <= tzhi\n+    \/\/ The resulting type is not wider than the type of the Cast\n+    \/\/ before transformation\n+    \/\/\n+    \/\/ If neither x nor y are constant then the type of the resulting\n+    \/\/ Add can be wider than the type of the type of the Cast before\n+    \/\/ transformation.\n+    \/\/ For instance, tx = [0, 10], ty = [0, 10], tz = [0, 10]\n+    \/\/ then rx = [0, 10], ry = [0, 10]\n+    \/\/ and rx + ry = [0, 20] which is wider than tz\n+    \/\/\n+    \/\/ Same reasoning applies to (Cast (Sub x y) tz)\n+    const DependencyType& dependency = (!tx->is_con() && !ty->is_con()) ? _dependency.with_non_narrowing() : _dependency;\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx, dependency);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry, dependency);\n@@ -656,2 +679,3 @@\n-const Type* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n-  if (!phase->C->post_loop_opts_phase()) {\n+Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+  Node* res = optimize_integer_cast_of_add(phase, bt);\n+  if (res != nullptr) {\n@@ -660,0 +684,12 @@\n+  const Type* t = Value(phase);\n+  if (t != Type::TOP && phase->C->post_loop_opts_phase()) {\n+    const Type* bottom_t = bottom_type();\n+    const TypeInteger* wide_t = widen_type(phase, bottom_t, bt);\n+    if (wide_t != bottom_t) {\n+      \/\/ Widening the type of the Cast (to allow some commoning) causes the Cast to change how it can be optimized (if\n+      \/\/ type of its input is narrower than the Cast's type, we can't remove it to not loose the control dependency).\n+      return make_with(in(1), wide_t, _dependency.with_non_narrowing());\n+    }\n+  }\n+  return nullptr;\n+}\n@@ -661,0 +697,2 @@\n+const TypeInteger* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n+  const TypeInteger* this_type = res->is_integer(bt);\n@@ -669,1 +707,1 @@\n-    return res;\n+    return this_type;\n@@ -672,1 +710,0 @@\n-  const TypeInteger* this_type = res->is_integer(bt);\n@@ -693,1 +730,1 @@\n-  return res;\n+  return this_type;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":88,"deletions":51,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -36,4 +36,97 @@\n-  enum DependencyType {\n-    RegularDependency, \/\/ if cast doesn't improve input type, cast can be removed\n-    StrongDependency,  \/\/ leave cast in even if _type doesn't improve input type, can be replaced by stricter dominating cast if one exist\n-    UnconditionalDependency \/\/ leave cast in unconditionally\n+  \/\/ Cast nodes are subject to a few optimizations:\n+  \/\/\n+  \/\/ 1- if the type carried by the Cast doesn't narrow the type of its input, the cast can be replaced by its input.\n+  \/\/ Similarly, if a dominating Cast with the same input and a narrower type constraint is found, it can replace the\n+  \/\/ current cast.\n+  \/\/\n+  \/\/ 2- if the condition that the Cast is control dependent is hoisted, the Cast is hoisted as well\n+  \/\/\n+  \/\/ 1- and 2- are not always applied depending on what constraint are applied to the Cast: there are cases where 1-\n+  \/\/ and 2- apply, where neither 1- nor 2- apply and where one or the other apply. This class abstract away these\n+  \/\/ details.\n+  \/\/\n+  \/\/ If _narrows_type is true, the cast carries a type dependency: \"after\" the control the cast is dependent on, its data\n+  \/\/ input is known to have a narrower type (stored in the cast node itself). Optimizations 1- above only apply to cast\n+  \/\/ nodes for which _narrows_type is true.\n+  \/\/ if _floating is true, the cast only depends on a single control: its control input. Otherwise, it is pinned at its\n+  \/\/ current location. Optimizations 2- only apply to cast nodes for which _floating is true.\n+  \/\/ _floating here is similar to Node::depends_only_on_test().\n+  \/\/ The 4 combinations of _narrows_types\/_floating true\/false have some use. See below, at the end of this class\n+  \/\/ definition, for examples.\n+  class DependencyType {\n+  private:\n+    const bool _floating; \/\/ Does this Cast depends on its control input or is it pinned?\n+    const bool _narrows_type; \/\/ Does this Cast narrows the type i.e. if input type is narrower can it be removed?\n+    const char* _desc;\n+    DependencyType(bool depends_on_test, bool narrows_type, const char* desc)\n+      : _floating(depends_on_test),\n+        _narrows_type(narrows_type),\n+        _desc(desc) {\n+    }\n+    NONCOPYABLE(DependencyType);\n+\n+  public:\n+\n+    bool is_floating() const {\n+      return _floating;\n+    }\n+\n+    bool narrows_type() const {\n+      return _narrows_type;\n+    }\n+\n+    void dump_on(outputStream *st) const {\n+      st->print(\"%s\", _desc);\n+    }\n+\n+    uint hash() const {\n+      return (_floating ? 1 : 0) + (_narrows_type ? 2 : 0);\n+    }\n+\n+    bool cmp(const DependencyType& other) const {\n+      return _floating == other._floating && _narrows_type == other._narrows_type;\n+    }\n+\n+    const DependencyType& with_non_narrowing() const {\n+      if (_floating) {\n+        return FloatingNonNarrowing;\n+      }\n+      return NonFloatingNonNarrowing;\n+    }\n+\n+    const DependencyType& with_pinned_dependency() const {\n+      if (_narrows_type) {\n+        return NonFloatingNarrowing;\n+      }\n+      return NonFloatingNonNarrowing;\n+    }\n+\n+    \/\/ All the possible combinations of floating\/narrowing with example use cases:\n+\n+    \/\/ Use case example: Range Check CastII\n+    \/\/ Floating: The Cast is only dependent on the single range check. If the range check was ever to be hoisted it\n+    \/\/           would be safe to let the Cast float to where the range check is hoisted up to.\n+    \/\/ Narrowing: The Cast narrows the type to a positive index. If the input to the Cast is narrower, we can safely\n+    \/\/            remove the cast because the array access will be safe.\n+    static const DependencyType FloatingNarrowing;\n+    \/\/ Use case example: Widening Cast nodes' types after loop opts: We want to common Casts with slightly different types.\n+    \/\/ Floating: These Casts only depend on the single control.\n+    \/\/ NonNarrowing: Even when the input type is narrower, we are not removing the Cast. Otherwise, the dependency\n+    \/\/               to the single control is lost, and an array access could float above its range check because we\n+    \/\/               just removed the dependency to the range check by removing the Cast. This could lead to an\n+    \/\/               out-of-bounds access.\n+    static const DependencyType FloatingNonNarrowing;\n+    \/\/ Use case example: An array accesses that is no longer dependent on a single range check (e.g. range check smearing).\n+    \/\/ NonFloating: The array access must be pinned below all the checks it depends on. If the check it directly depends\n+    \/\/              on with a control input is hoisted, we do not hoist the Cast as well. If we allowed the Cast to float,\n+    \/\/              we risk that the array access ends up above another check it depends on (we cannot model two control\n+    \/\/              dependencies for a node in the IR). This could lead to an out-of-bounds access.\n+    \/\/ Narrowing: If the Cast does not narrow the input type, then it's safe to remove the cast because the array access\n+    \/\/            will be safe.\n+    static const DependencyType NonFloatingNarrowing;\n+    \/\/ Use case example: Sinking nodes out of a loop\n+    \/\/ Non-Floating & Non-Narrowing: We don't want the Cast that forces the node to be out of loop to be removed in any\n+    \/\/                               case. Otherwise, the sunk node could float back into the loop, undoing the sinking.\n+    \/\/                               This Cast is only used for pinning without caring about narrowing types.\n+    static const DependencyType NonFloatingNonNarrowing;\n+\n@@ -42,2 +135,2 @@\n-  protected:\n-  const DependencyType _dependency;\n+protected:\n+  const DependencyType& _dependency;\n@@ -47,2 +140,8 @@\n-  const Type* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n-  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n+  const TypeInteger* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n+\n+  virtual ConstraintCastNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const {\n+    ShouldNotReachHere(); \/\/ Only implemented for CastII and CastLL\n+    return nullptr;\n+  }\n+\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -50,1 +149,0 @@\n-  private:\n@@ -58,1 +156,1 @@\n-  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency,\n@@ -70,2 +168,4 @@\n-  virtual bool depends_only_on_test() const { return _dependency == RegularDependency; }\n-  bool carry_dependency() const { return _dependency != RegularDependency; }\n+  bool carry_dependency() const { return !_dependency.cmp(DependencyType::FloatingNarrowing); }\n+  \/\/ A cast node depends_only_on_test if and only if it is floating\n+  virtual bool depends_only_on_test() const { return _dependency.is_floating(); }\n+  const DependencyType& dependency() const { return _dependency; }\n@@ -73,1 +173,1 @@\n-  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt);\n+  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, const DependencyType& dependency, BasicType bt);\n@@ -79,1 +179,1 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, const DependencyType& dependency,\n@@ -82,0 +182,1 @@\n+  Node* optimize_integer_cast_of_add(PhaseGVN* phase, BasicType bt);\n@@ -105,1 +206,1 @@\n-  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+  CastIINode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n@@ -113,1 +214,1 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n+\n@@ -125,0 +226,1 @@\n+  CastIINode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -134,1 +236,1 @@\n-  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -140,2 +242,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-\n@@ -150,0 +250,1 @@\n+  CastLLNode* make_with(Node* parent, const TypeInteger* type, const DependencyType& dependency) const;\n@@ -154,1 +255,1 @@\n-  CastHHNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastHHNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -165,1 +266,1 @@\n-  CastFFNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastFFNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -176,1 +277,1 @@\n-  CastDDNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastDDNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -187,1 +288,1 @@\n-  CastVVNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastVVNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -201,1 +302,1 @@\n-  CastPPNode (Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CastPPNode (Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n@@ -213,1 +314,1 @@\n-  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, const DependencyType& dependency = DependencyType::FloatingNarrowing, const TypeTuple* types = nullptr)\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":126,"deletions":25,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2299,1 +2299,1 @@\n-          cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+          cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2309,1 +2309,1 @@\n-            cast = new CastPPNode(r, uin, TypePtr::NOTNULL, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CastPPNode(r, uin, TypePtr::NOTNULL, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2321,1 +2321,1 @@\n-            cast = new CheckCastPPNode(r, n, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CheckCastPPNode(r, n, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2324,1 +2324,1 @@\n-            cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n@@ -2328,1 +2328,1 @@\n-        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing, extra_types);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1795,2 +1795,0 @@\n-      if (flat->offset() == in_bytes(Klass::access_flags_offset()))\n-        alias_type(idx)->set_rewritable(false);\n@@ -1806,0 +1804,6 @@\n+\n+    if (flat->isa_instklassptr()) {\n+      if (flat->offset() == in_bytes(InstanceKlass::access_flags_offset())) {\n+        alias_type(idx)->set_rewritable(false);\n+      }\n+    }\n@@ -5148,1 +5152,1 @@\n-    value = new CastIINode(ctrl, value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n+    value = new CastIINode(ctrl, value, itype, carry_dependency ? ConstraintCastNode::DependencyType::NonFloatingNarrowing : ConstraintCastNode::DependencyType::FloatingNarrowing, true \/* range check dependency *\/);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -771,1 +771,1 @@\n-  return _igvn->transform(ConstraintCastNode::make_cast_for_type(not_eq_control, base, _igvn->type(castpp), ConstraintCastNode::UnconditionalDependency, nullptr));\n+  return _igvn->transform(ConstraintCastNode::make_cast_for_type(not_eq_control, base, _igvn->type(castpp), ConstraintCastNode::DependencyType::NonFloatingNonNarrowing, nullptr));\n@@ -1258,1 +1258,1 @@\n-    nsr_merge_pointer = _igvn->transform(ConstraintCastNode::make_cast_for_type(cast->in(0), cast->in(1), new_t, ConstraintCastNode::RegularDependency, nullptr));\n+    nsr_merge_pointer = _igvn->transform(ConstraintCastNode::make_cast_for_type(cast->in(0), cast->in(1), new_t, ConstraintCastNode::DependencyType::FloatingNarrowing, nullptr));\n@@ -1417,1 +1417,1 @@\n-        Node* new_cast = ConstraintCastNode::make_cast_for_type(out->in(0), out->in(1), out_new_t, ConstraintCastNode::StrongDependency, nullptr);\n+        Node* new_cast = ConstraintCastNode::make_cast_for_type(out->in(0), out->in(1), out_new_t, ConstraintCastNode::DependencyType::NonFloatingNarrowing, nullptr);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1905,1 +1905,1 @@\n-  return _gvn.transform(new CastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n+  return _gvn.transform(new CastPPNode(control(), array, arytype, ConstraintCastNode::DependencyType::NonFloatingNarrowing));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1212,1 +1212,1 @@\n-      ConstraintCastNode::RegularDependency, bt);\n+      ConstraintCastNode::DependencyType::FloatingNarrowing, bt);\n@@ -1242,1 +1242,1 @@\n-      ConstraintCastNode::RegularDependency, bt);\n+      ConstraintCastNode::DependencyType::FloatingNarrowing, bt);\n@@ -2839,1 +2839,1 @@\n-        Node* new_base = _gvn.transform(new CastPPNode(control(), base, array_type, ConstraintCastNode::StrongDependency));\n+        Node* new_base = _gvn.transform(new CastPPNode(control(), base, array_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing));\n@@ -2855,1 +2855,1 @@\n-          ptr = _gvn.transform(new CastPPNode(control(), ptr, ptr_type->with_field_offset(0), ConstraintCastNode::StrongDependency));\n+          ptr = _gvn.transform(new CastPPNode(control(), ptr, ptr_type->with_field_offset(0), ConstraintCastNode::DependencyType::NonFloatingNarrowing));\n@@ -2873,1 +2873,1 @@\n-      Node* new_value = _gvn.transform(new CastPPNode(control(), value, value_type, ConstraintCastNode::StrongDependency));\n+      Node* new_value = _gvn.transform(new CastPPNode(control(), value, value_type, ConstraintCastNode::DependencyType::NonFloatingNarrowing));\n@@ -4443,1 +4443,1 @@\n-                                    Klass::access_flags_offset(), TypeInt::CHAR, T_CHAR);\n+                                    InstanceKlass::access_flags_offset(), TypeInt::CHAR, T_CHAR);\n@@ -4555,4 +4555,1 @@\n-    if (generate_interface_guard(kls, region) != nullptr)\n-      \/\/ A guard was added.  If the guard is taken, it was an interface.\n-      phi->add_req(null());\n-    if (generate_array_guard(kls, region) != nullptr)\n+    if (generate_array_guard(kls, region) != nullptr) {\n@@ -4561,0 +4558,7 @@\n+    }\n+    \/\/ Check for interface after array since this checks AccessFlags offset into InstanceKlass.\n+    \/\/ In other words, we are accessing subtype-specific information, so we need to determine the subtype first.\n+    if (generate_interface_guard(kls, region) != nullptr) {\n+      \/\/ A guard was added.  If the guard is taken, it was an interface.\n+      phi->add_req(null());\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1242,1 +1242,1 @@\n-  if (n->is_ConstraintCast()) {\n+  if (n->is_ConstraintCast() && n->as_ConstraintCast()->dependency().narrows_type()) {\n@@ -2012,1 +2012,1 @@\n-                                                              ConstraintCastNode::UnconditionalDependency, nullptr);\n+                                                              ConstraintCastNode::DependencyType::NonFloatingNonNarrowing, nullptr);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2201,1 +2201,2 @@\n-      \/\/ Address is aligned to execute prefetch to the beginning of cache line size.\n+      \/\/ Address is aligned to execute prefetch to the beginning of cache line size\n+      \/\/ (it is important when BIS instruction is used on SPARC as prefetch).\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  Node* casted_length = new CastLLNode(inline_block, length, inline_range, ConstraintCastNode::RegularDependency);\n+  Node* casted_length = new CastLLNode(inline_block, length, inline_range, ConstraintCastNode::DependencyType::FloatingNarrowing);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,0 +334,4 @@\n+  \/\/ Determines if a vector operation needs to be partially implemented with a mask\n+  \/\/ controlling only the lanes in range [0, vector_length) are processed. This applies\n+  \/\/ to operations whose vector length is less than the hardware-supported maximum\n+  \/\/ vector length. Returns true if the operation requires masking, false otherwise.\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2135,2 +2135,3 @@\n-  if (tkls->offset() == in_bytes(Klass::access_flags_offset())) {\n-    \/\/ The field is Klass::_access_flags.  Return its (constant) value.\n+\n+  if (tkls->isa_instklassptr() && tkls->offset() == in_bytes(InstanceKlass::access_flags_offset())) {\n+    \/\/ The field is InstanceKlass::_access_flags.  Return its (constant) value.\n@@ -2138,1 +2139,2 @@\n-    return TypeInt::make(klass->access_flags());\n+    ciInstanceKlass* iklass = tkls->is_instklassptr()->instance_klass();\n+    return TypeInt::make(iklass->access_flags());\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -234,0 +234,13 @@\n+JVM_ENTRY(jboolean, JVM_AOTEndRecording(JNIEnv *env))\n+#if INCLUDE_CDS\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    if (!AOTMetaspace::preimage_static_archive_dumped()) {\n+      AOTMetaspace::dump_static_archive(THREAD);\n+      return JNI_TRUE;\n+    }\n+  }\n+  return JNI_FALSE;\n+#else\n+  return JNI_FALSE;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1610,4 +1610,4 @@\n-          aot_log_info(aot)(\"UseCompressedOops disabled due to \"\n-                            \"max heap %zu > compressed oop heap %zu. \"\n-                            \"Please check the setting of MaxRAMPercentage %5.2f.\",\n-                            reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);\n+          log_debug(gc, heap, coops)(\"UseCompressedOops disabled due to \"\n+                                     \"max heap %zu > compressed oop heap %zu. \"\n+                                     \"Please check the setting of MaxRAMPercentage %5.2f.\",\n+                                     reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1399,0 +1399,1 @@\n+          range(0, 100)                                                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  nonstatic_field(InstanceKlass,               _access_flags,                                 AccessFlags)                           \\\n@@ -230,1 +231,0 @@\n-  nonstatic_field(Klass,                       _access_flags,                                 AccessFlags)                           \\\n@@ -358,0 +358,1 @@\n+     static_field(ThreadLocalAllocBuffer,      _reserve_for_allocation_prefetch,              int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  friend class Klass;\n+  friend class InstanceKlass;\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-        int mod = getModifiers();\n+        int mod = getModifiers() & Modifier.fieldModifiers();\n@@ -405,1 +405,1 @@\n-        int mod = getModifiers();\n+        int mod = getModifiers() & Modifier.fieldModifiers();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6027,6 +6027,10 @@\n-            \/\/ Check that all extended classes and interfaces\n-            \/\/ are compatible (i.e. no two define methods with same arguments\n-            \/\/ yet different return types).  (JLS 8.4.8.3)\n-            chk.checkCompatibleSupertypes(tree.pos(), c.type);\n-            chk.checkDefaultMethodClashes(tree.pos(), c.type);\n-            chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n+            try {\n+                \/\/ Check that all extended classes and interfaces\n+                \/\/ are compatible (i.e. no two define methods with same arguments\n+                \/\/ yet different return types).  (JLS 8.4.8.3)\n+                chk.checkCompatibleSupertypes(tree.pos(), c.type);\n+                chk.checkDefaultMethodClashes(tree.pos(), c.type);\n+                chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n+            } catch (CompletionFailure cf) {\n+                chk.completionError(tree.pos(), cf);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    accessFlags  = new CIntField(type.getCIntegerField(\"_access_flags\"), 0);\n@@ -97,1 +96,0 @@\n-  private static CIntField accessFlags;\n@@ -119,3 +117,0 @@\n-  public long     getAccessFlags()      { return            accessFlags.getValue(this);  }\n-  \/\/ Convenience routine\n-  public AccessFlags getAccessFlagsObj(){ return new AccessFlags(getAccessFlags());      }\n@@ -177,1 +172,0 @@\n-      visitor.doCInt(accessFlags, true);\n@@ -207,8 +201,0 @@\n-\n-  \/\/ Convenience routines\n-  public boolean isPublic()                 { return getAccessFlagsObj().isPublic(); }\n-  public boolean isFinal()                  { return getAccessFlagsObj().isFinal(); }\n-  public boolean isInterface()              { return getAccessFlagsObj().isInterface(); }\n-  public boolean isAbstract()               { return getAccessFlagsObj().isAbstract(); }\n-  public boolean isSuper()                  { return getAccessFlagsObj().isSuper(); }\n-  public boolean isSynthetic()              { return getAccessFlagsObj().isSynthetic(); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Klass.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-    final int klassAccessFlagsOffset = getFieldOffset(\"Klass::_access_flags\", Integer.class, \"AccessFlags\");\n@@ -96,0 +95,1 @@\n+    final int instanceKlassAccessFlagsOffset = getFieldOffset(\"InstanceKlass::_access_flags\", Integer.class, \"AccessFlags\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-gc\/cslocker\/TestCSLocker.java 8373025 generic-all\n@@ -186,3 +185,0 @@\n-serviceability\/sa\/ClhsdbScanOops.java#parallel    8373022 generic-all\n-serviceability\/sa\/ClhsdbScanOops.java#serial      8373022 generic-all\n-\n@@ -292,6 +288,0 @@\n-\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded001\/TestDescription.java 8373022 generic-all\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded002\/TestDescription.java 8373022 generic-all\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded003\/TestDescription.java 8373022 generic-all\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded004\/TestDescription.java 8373022 generic-all\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isUsageThresholdExceeded\/isexceeded005\/TestDescription.java 8373022 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -586,0 +586,10 @@\n+    public static final String CMOVE_F = PREFIX + \"CMOVE_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_F, \"CMoveF\");\n+    }\n+\n+    public static final String CMOVE_D = PREFIX + \"CMOVE_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_D, \"CMoveD\");\n+    }\n+\n@@ -591,0 +601,15 @@\n+    public static final String CMOVE_L = PREFIX + \"CMOVE_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMOVE_L, \"CMoveL\");\n+    }\n+\n+    public static final String CMP_F = PREFIX + \"CMP_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_F, \"CmpF\");\n+    }\n+\n+    public static final String CMP_D = PREFIX + \"CMP_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_D, \"CmpD\");\n+    }\n+\n@@ -1503,0 +1528,10 @@\n+    public static final String VECTOR_MASK_GEN = PREFIX + \"VECTOR_MASK_GEN\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_GEN, \"VectorMaskGen\");\n+    }\n+\n+    public static final String VECTOR_MASK_FIRST_TRUE = PREFIX + \"VECTOR_MASK_FIRST_TRUE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_FIRST_TRUE, \"VectorMaskFirstTrue\");\n+    }\n+\n@@ -1716,0 +1751,10 @@\n+    public static final String COUNT_TRAILING_ZEROS_I = PREFIX + \"COUNT_TRAILING_ZEROS_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(COUNT_TRAILING_ZEROS_I, \"CountTrailingZerosI\");\n+    }\n+\n+    public static final String COUNT_TRAILING_ZEROS_L = PREFIX + \"COUNT_TRAILING_ZEROS_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(COUNT_TRAILING_ZEROS_L, \"CountTrailingZerosL\");\n+    }\n+\n@@ -1726,0 +1771,10 @@\n+    public static final String COUNT_LEADING_ZEROS_I = PREFIX + \"COUNT_LEADING_ZEROS_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(COUNT_LEADING_ZEROS_I, \"CountLeadingZerosI\");\n+    }\n+\n+    public static final String COUNT_LEADING_ZEROS_L = PREFIX + \"COUNT_LEADING_ZEROS_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(COUNT_LEADING_ZEROS_L, \"CountLeadingZerosL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -503,0 +503,1 @@\n+sun\/awt\/image\/bug8038000.java 8373065 generic-all\n@@ -726,1 +727,0 @@\n-com\/sun\/jdi\/MethodInvokeWithTraceOnTest.java                    8373022 generic-all\n@@ -839,0 +839,1 @@\n+java\/lang\/reflect\/Modifier\/toStringTest.java 8373989 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}