{"files":[{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -50,1 +51,0 @@\n-#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -322,22 +322,0 @@\n- * HPROF_FLAT_ARRAYS        list of flat arrays\n- *\n- *               [flat array sub-records]*\n- *\n- *               HPROF_FLAT_ARRAY      flat array\n- *\n- *                          id         array object ID (dumped as HPROF_GC_PRIM_ARRAY_DUMP)\n- *                          id         element class ID (dumped by HPROF_GC_CLASS_DUMP)\n- *\n- * HPROF_INLINED_FIELDS     decribes inlined fields\n- *\n- *               [class with inlined fields sub-records]*\n- *\n- *               HPROF_CLASS_WITH_INLINED_FIELDS\n- *\n- *                          id         class ID (dumped as HPROF_GC_CLASS_DUMP)\n- *\n- *                          u2         number of instance inlined fields (not including super)\n- *                          [u2,       inlined field index,\n- *                           u2,       synthetic field count,\n- *                           id,       original field name,\n- *                           id]*      inlined field class ID (dumped by HPROF_GC_CLASS_DUMP)\n@@ -381,7 +359,0 @@\n-  \/\/ inlined object support\n-  HPROF_FLAT_ARRAYS             = 0x12,\n-  HPROF_INLINED_FIELDS          = 0x13,\n-  \/\/ inlined object subrecords\n-  HPROF_FLAT_ARRAY                  = 0x01,\n-  HPROF_CLASS_WITH_INLINED_FIELDS   = 0x01,\n-\n@@ -422,65 +393,0 @@\n-\n-class AbstractDumpWriter;\n-\n-class InlinedObjects {\n-\n-  struct ClassInlinedFields {\n-    const Klass *klass;\n-    uintx base_index;   \/\/ base index of the inlined field names (1st field has index base_index+1).\n-    ClassInlinedFields(const Klass *klass = nullptr, uintx base_index = 0) : klass(klass), base_index(base_index) {}\n-\n-    \/\/ For GrowableArray::find_sorted().\n-    static int compare(const ClassInlinedFields& a, const ClassInlinedFields& b) {\n-      return a.klass - b.klass;\n-    }\n-    \/\/ For GrowableArray::sort().\n-    static int compare(ClassInlinedFields* a, ClassInlinedFields* b) {\n-      return compare(*a, *b);\n-    }\n-  };\n-\n-  uintx _min_string_id;\n-  uintx _max_string_id;\n-\n-  GrowableArray<ClassInlinedFields> *_inlined_field_map;\n-\n-  \/\/ counters for classes with inlined fields and for the fields\n-  int _classes_count;\n-  int _inlined_fields_count;\n-\n-  static InlinedObjects *_instance;\n-\n-  static void inlined_field_names_callback(InlinedObjects* _this, const Klass *klass, uintx base_index, int count);\n-\n-  GrowableArray<oop> *_flat_arrays;\n-\n-public:\n-  InlinedObjects()\n-    : _min_string_id(0), _max_string_id(0),\n-    _inlined_field_map(nullptr),\n-    _classes_count(0), _inlined_fields_count(0),\n-    _flat_arrays(nullptr) {\n-  }\n-\n-  static InlinedObjects* get_instance() {\n-    return _instance;\n-  }\n-\n-  void init();\n-  void release();\n-\n-  void dump_inlined_field_names(AbstractDumpWriter *writer);\n-\n-  uintx get_base_index_for(Klass* k);\n-  uintx get_next_string_id(uintx id);\n-\n-  void dump_classed_with_inlined_fields(AbstractDumpWriter* writer);\n-\n-  void add_flat_array(oop array);\n-  void dump_flat_arrays(AbstractDumpWriter* writer);\n-\n-};\n-\n-InlinedObjects *InlinedObjects::_instance = nullptr;\n-\n-\n@@ -537,0 +443,1 @@\n+  void write_objectID(uintptr_t id);\n@@ -623,0 +530,4 @@\n+void AbstractDumpWriter::write_objectID(uintptr_t id) {\n+  write_address((address)id);\n+}\n+\n@@ -828,0 +739,2 @@\n+class DumperFlatObject;\n+class DumperFlatObjectList;\n@@ -843,2 +756,2 @@\n-  \/\/ calculates the total size of the all fields of the given class.\n-  static u4 instance_size(InstanceKlass* ik, DumperClassCacheTableEntry* class_cache_entry = nullptr);\n+  \/\/ returns the size of the instance of the given class\n+  static u4 instance_size(InstanceKlass* ik);\n@@ -856,8 +769,3 @@\n-  \/\/ dump the raw values of the instance fields of the given identity or inlined object;\n-  \/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n-  \/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry);\n-  \/\/ dump the raw values of the instance fields of the given inlined object;\n-  \/\/ dump_instance_fields wrapper for inlined objects\n-  static void dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry);\n-\n+  \/\/ dump the raw values of the instance fields of the given object, fills flat_fields\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset,\n+                                   DumperClassCacheTableEntry* class_cache_entry, DumperFlatObjectList* flat_fields);\n@@ -867,3 +775,4 @@\n-  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* k, uintx *inlined_fields_index = nullptr);\n-  \/\/ creates HPROF_GC_INSTANCE_DUMP record for the given object\n-  static void dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache);\n+  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* k);\n+  \/\/ creates HPROF_GC_INSTANCE_DUMP record for the given object, fills flat_fields\n+  static void dump_instance(AbstractDumpWriter* writer, uintptr_t id, oop o, int offset, InstanceKlass* ik,\n+                            DumperClassCacheTable* class_cache, DumperFlatObjectList* flat_fields);\n@@ -875,4 +784,2 @@\n-  \/\/ creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array\n-  static void dump_object_array(AbstractDumpWriter* writer, objArrayOop array);\n-  \/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n-  static void dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array, DumperClassCacheTable* class_cache);\n+  \/\/ creates HPROF_GC_OBJ_ARRAY_DUMP record for the given object array, fills flat_elements if the object is flat array\n+  static void dump_object_array(AbstractDumpWriter* writer, objArrayOop array, DumperFlatObjectList* flat_elements);\n@@ -886,3 +793,0 @@\n-  \/\/ extended version to dump flat arrays as primitive arrays;\n-  \/\/ type_size specifies size of the inlined objects.\n-  static int calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size);\n@@ -904,10 +808,0 @@\n-  \/\/ helper methods for inlined fields.\n-  static bool is_inlined_field(const fieldDescriptor& fld) {\n-    return fld.is_flat();\n-  }\n-  static InlineKlass* get_inlined_field_klass(const fieldDescriptor& fld) {\n-    assert(is_inlined_field(fld), \"must be inlined field\");\n-    InstanceKlass* holder_klass = fld.field_holder();\n-    return InlineKlass::cast(holder_klass->get_inline_type_field_klass(fld.index()));\n-  }\n-\n@@ -927,0 +821,9 @@\n+\n+  \/\/ Direct instances of ObjArrayKlass represent the Java types that Java code can see.\n+  \/\/ RefArrayKlass\/FlatArrayKlass describe different implementations of the arrays, filter them out to avoid duplicates.\n+  static bool filter_out_klass(Klass* k) {\n+    if (k->is_objArray_klass() && k->kind() != Klass::KlassKind::ObjArrayKlassKind) {\n+      return true;\n+    }\n+    return false;\n+  }\n@@ -935,0 +838,34 @@\n+public:\n+  class FieldDescriptor {\n+  private:\n+    char _sigs_start;\n+    int _offset;\n+    InlineKlass* _inline_klass; \/\/ nullptr for heap object\n+    LayoutKind _layout_kind;\n+  public:\n+    FieldDescriptor(): _sigs_start(0), _offset(0), _inline_klass(nullptr), _layout_kind(LayoutKind::UNKNOWN) {}\n+\n+    template<typename FieldStreamType>\n+    FieldDescriptor(const FieldStreamType& field)\n+      : _sigs_start(field.signature()->char_at(0)), _offset(field.offset())\n+    {\n+      if (field.is_flat()) {\n+        const fieldDescriptor& fd = field.field_descriptor();\n+        InstanceKlass* holder_klass = fd.field_holder();\n+        InlineLayoutInfo* layout_info = holder_klass->inline_layout_info_adr(fd.index());\n+        _inline_klass = layout_info->klass();\n+        _layout_kind = layout_info->kind();\n+      } else {\n+        _inline_klass = nullptr;\n+        _layout_kind = LayoutKind::REFERENCE;\n+      }\n+    }\n+\n+    char sig_start() const            { return _sigs_start; }\n+    int offset() const                { return _offset; }\n+    bool is_flat() const              { return _inline_klass != nullptr; }\n+    InlineKlass* inline_klass() const { return _inline_klass; }\n+    LayoutKind layout_kind() const    { return _layout_kind; }\n+    bool is_flat_nullable() const     { return _layout_kind == LayoutKind::NULLABLE_ATOMIC_FLAT; }\n+  };\n+\n@@ -936,3 +873,1 @@\n-  GrowableArray<char> _sigs_start;\n-  GrowableArray<int> _offsets;\n-  GrowableArray<InlineKlass*> _inline_klasses;\n+  GrowableArray<FieldDescriptor> _fields;\n@@ -940,1 +875,0 @@\n-  int _entries;\n@@ -943,9 +877,11 @@\n-  DumperClassCacheTableEntry() : _instance_size(0), _entries(0) {};\n-\n-  int field_count()             { return _entries; }\n-  char sig_start(int field_idx) { return _sigs_start.at(field_idx); }\n-  void push_sig_start_inlined() { _sigs_start.push('Q'); }\n-  bool is_inlined(int field_idx){ return _sigs_start.at(field_idx) == 'Q'; }\n-  InlineKlass* inline_klass(int field_idx) { assert(is_inlined(field_idx), \"Not inlined\"); return _inline_klasses.at(field_idx); }\n-  int offset(int field_idx)     { return _offsets.at(field_idx); }\n-  u4 instance_size()            { return _instance_size; }\n+  DumperClassCacheTableEntry(): _instance_size(0) {}\n+\n+  template<typename FieldStreamType>\n+  void add_field(const FieldStreamType& field) {\n+    _fields.push(FieldDescriptor(field));\n+    _instance_size += DumperSupport::sig2size(field.signature());\n+  }\n+\n+  const FieldDescriptor& field(int index) const { return _fields.at(index); }\n+  int field_count() const { return _fields.length(); }\n+  u4 instance_size() const { return _instance_size; }\n@@ -967,1 +903,1 @@\n-                            TABLE_SIZE, AnyObj::C_HEAP, mtServiceability> PtrTable;\n+                    TABLE_SIZE, AnyObj::C_HEAP, mtServiceability> PtrTable;\n@@ -998,13 +934,1 @@\n-          InlineKlass* inlineKlass = nullptr;\n-          if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n-            inlineKlass = DumperSupport::get_inlined_field_klass(fld.field_descriptor());\n-            entry->push_sig_start_inlined();\n-            entry->_instance_size += DumperSupport::instance_size(inlineKlass);\n-          } else {\n-            Symbol* sig = fld.signature();\n-            entry->_sigs_start.push(sig->char_at(0));\n-            entry->_instance_size += DumperSupport::sig2size(sig);\n-          }\n-          entry->_inline_klasses.push(inlineKlass);\n-          entry->_offsets.push(fld.offset());\n-          entry->_entries++;\n+          entry->add_field(fld);\n@@ -1041,0 +965,64 @@\n+\/\/ Describes flat object (flatted field or element of flat array) in the holder oop\n+class DumperFlatObject: public CHeapObj<mtServiceability> {\n+  friend class DumperFlatObjectList;\n+private:\n+  DumperFlatObject* _next;\n+\n+  const uintptr_t _id; \/\/ object id\n+\n+  const int _offset;\n+  InlineKlass* const _inline_klass;\n+\n+public:\n+  DumperFlatObject(uintptr_t id, int offset, InlineKlass* inline_klass)\n+    : _next(nullptr), _id(id), _offset(offset), _inline_klass(inline_klass) {\n+  }\n+\n+  uintptr_t object_id()       const { return _id; }\n+  int offset()                const { return _offset; }\n+  InlineKlass* inline_klass() const { return _inline_klass; }\n+};\n+\n+class FlatObjectIdProvider {\n+public:\n+  virtual uintptr_t get_id() = 0;\n+};\n+\n+\/\/ Simple FIFO.\n+class DumperFlatObjectList {\n+private:\n+  FlatObjectIdProvider* _id_provider;\n+  DumperFlatObject* _head;\n+  DumperFlatObject* _tail;\n+\n+  void push(DumperFlatObject* obj) {\n+    if (_head == nullptr) {\n+      _head = _tail = obj;\n+    } else {\n+      assert(_tail != nullptr, \"must be\");\n+      _tail->_next = obj;\n+      _tail = obj;\n+    }\n+  }\n+\n+public:\n+  DumperFlatObjectList(FlatObjectIdProvider* id_provider): _id_provider(id_provider), _head(nullptr), _tail(nullptr) {}\n+\n+  bool is_empty() const { return _head == nullptr; }\n+\n+  uintptr_t push(int offset, InlineKlass* inline_klass) {\n+    uintptr_t id = _id_provider->get_id();\n+    DumperFlatObject* obj = new DumperFlatObject(id, offset, inline_klass);\n+    push(obj);\n+    return id;\n+  }\n+\n+  DumperFlatObject* pop() {\n+    assert(!is_empty(), \"sanity\");\n+    DumperFlatObject* element = _head;\n+    _head = element->_next;\n+    element->_next = nullptr;\n+    return element;\n+  }\n+};\n+\n@@ -1120,1 +1108,0 @@\n-\n@@ -1179,14 +1166,6 @@\n-\/\/ calculates the total size of the all fields of the given class.\n-u4 DumperSupport::instance_size(InstanceKlass* ik, DumperClassCacheTableEntry* class_cache_entry) {\n-  if (class_cache_entry != nullptr) {\n-    return class_cache_entry->instance_size();\n-  } else {\n-    u4 size = 0;\n-    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n-      if (!fld.access_flags().is_static()) {\n-        if (is_inlined_field(fld.field_descriptor())) {\n-          size += instance_size(get_inlined_field_klass(fld.field_descriptor()));\n-        } else {\n-          size += sig2size(fld.signature());\n-        }\n-      }\n+\/\/ returns the size of the instance of the given class\n+u4 DumperSupport::instance_size(InstanceKlass* ik) {\n+  u4 size = 0;\n+  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n+    if (!fld.access_flags().is_static()) {\n+      size += sig2size(fld.signature());\n@@ -1194,1 +1173,0 @@\n-    return size;\n@@ -1196,0 +1174,1 @@\n+  return size;\n@@ -1204,1 +1183,1 @@\n-      assert(!is_inlined_field(fldc.field_descriptor()), \"static fields cannot be inlined\");\n+      assert(!fldc.is_flat(), \"static fields cannot be flat\");\n@@ -1248,1 +1227,1 @@\n-      assert(!is_inlined_field(fld.field_descriptor()), \"static fields cannot be inlined\");\n+      assert(!fld.is_flat(), \"static fields cannot be flat\");\n@@ -1286,4 +1265,3 @@\n-\/\/ dump the raw values of the instance fields of the given identity or inlined object;\n-\/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n-\/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class.\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry) {\n+\/\/ dump the raw values of the instance fields of the given object, fills flat_fields\n+void DumperSupport:: dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset,\n+                                          DumperClassCacheTableEntry* class_cache_entry, DumperFlatObjectList* flat_fields) {\n@@ -1292,5 +1270,13 @@\n-    if (class_cache_entry->is_inlined(idx)) {\n-      InlineKlass* field_klass = class_cache_entry->inline_klass(idx);\n-      int fields_offset = offset + (class_cache_entry->offset(idx) - field_klass->payload_offset());\n-      DumperClassCacheTableEntry* inline_class_cache_entry = class_cache->lookup_or_create(field_klass);\n-      dump_inlined_object_fields(writer, o, fields_offset, class_cache, inline_class_cache_entry);\n+    const DumperClassCacheTableEntry::FieldDescriptor& field = class_cache_entry->field(idx);\n+    int field_offset = offset + field.offset();\n+    if (field.is_flat()) {\n+      \/\/ check for possible nulls\n+      if (field.is_flat_nullable()) {\n+        address payload = cast_from_oop<address>(o) + field_offset;\n+        if (field.inline_klass()->is_payload_marked_as_null(payload)) {\n+          writer->write_objectID(nullptr);\n+          continue;\n+        }\n+      }\n+      uintptr_t object_id = flat_fields->push(field_offset, field.inline_klass());\n+      writer->write_objectID(object_id);\n@@ -1298,1 +1284,1 @@\n-      dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+      dump_field_value(writer, field.sig_start(), o, field_offset);\n@@ -1303,5 +1289,0 @@\n-void DumperSupport::dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry) {\n-  \/\/ the object is inlined, so all its fields are stored without headers.\n-  dump_instance_fields(writer, o, offset, class_cache, class_cache_entry);\n-}\n-\n@@ -1314,6 +1295,1 @@\n-      if (is_inlined_field(fldc.field_descriptor())) {\n-        \/\/ add \"synthetic\" fields for inlined fields.\n-        field_count += get_instance_fields_count(get_inlined_field_klass(fldc.field_descriptor()));\n-      } else {\n-        field_count++;\n-      }\n+      field_count++;\n@@ -1327,9 +1303,1 @@\n-\/\/ inlined_fields_id is not-nullptr for inlined fields (to get synthetic field name IDs\n-\/\/ by using InlinedObjects::get_next_string_id()).\n-void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* ik, uintx* inlined_fields_id) {\n-  \/\/ inlined_fields_id != nullptr means ik is a class of inlined field.\n-  \/\/ Inlined field id pointer for this class; lazyly initialized\n-  \/\/ if the class has inlined field(s) and the caller didn't provide inlined_fields_id.\n-  uintx *this_klass_inlined_fields_id = inlined_fields_id;\n-  uintx inlined_id = 0;\n-\n+void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* ik) {\n@@ -1339,23 +1307,1 @@\n-      if (is_inlined_field(fld.field_descriptor())) {\n-        \/\/ dump \"synthetic\" fields for inlined fields.\n-        if (this_klass_inlined_fields_id == nullptr) {\n-          inlined_id = InlinedObjects::get_instance()->get_base_index_for(ik);\n-          this_klass_inlined_fields_id = &inlined_id;\n-        }\n-        dump_instance_field_descriptors(writer, get_inlined_field_klass(fld.field_descriptor()), this_klass_inlined_fields_id);\n-      } else {\n-        Symbol* sig = fld.signature();\n-        Symbol* name = nullptr;\n-        \/\/ Use inlined_fields_id provided by caller.\n-        if (inlined_fields_id != nullptr) {\n-          uintx name_id = InlinedObjects::get_instance()->get_next_string_id(*inlined_fields_id);\n-\n-          \/\/ name_id == 0 is returned on error. use original field signature.\n-          if (name_id != 0) {\n-            *inlined_fields_id = name_id;\n-            name = reinterpret_cast<Symbol*>(name_id);\n-          }\n-        }\n-        if (name == nullptr) {\n-          name = fld.name();\n-        }\n+      Symbol* sig = fld.signature();\n@@ -1363,3 +1309,2 @@\n-        writer->write_symbolID(name);         \/\/ name\n-        writer->write_u1(sig2tag(sig));       \/\/ type\n-      }\n+      writer->write_symbolID(fld.name());   \/\/ name\n+      writer->write_u1(sig2tag(sig));       \/\/ type\n@@ -1371,3 +1316,2 @@\n-void DumperSupport::dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache) {\n-  InstanceKlass* ik = InstanceKlass::cast(o->klass());\n-\n+void DumperSupport::dump_instance(AbstractDumpWriter* writer, uintptr_t id, oop o, int offset, InstanceKlass* ik,\n+                                  DumperClassCacheTable* class_cache, DumperFlatObjectList* flat_fields) {\n@@ -1376,1 +1320,1 @@\n-  u4 is = instance_size(ik, cache_entry);\n+  u4 is = cache_entry->instance_size();\n@@ -1380,1 +1324,1 @@\n-  writer->write_objectID(o);\n+  writer->write_objectID(id);\n@@ -1390,1 +1334,7 @@\n-  dump_instance_fields(writer, o, 0, class_cache, cache_entry);\n+  if (offset != 0) {\n+    \/\/ the object itself if flattened, so all fields are stored without headers\n+    InlineKlass* inline_klass = InlineKlass::cast(ik);\n+    offset -= inline_klass->payload_offset();\n+  }\n+\n+  dump_instance_fields(writer, o, offset, cache_entry, flat_fields);\n@@ -1433,1 +1383,1 @@\n-  writer->write_u4(HeapWordSize * ik->size_helper());\n+  writer->write_u4(DumperSupport::instance_size(ik));\n@@ -1487,1 +1437,4 @@\n-int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size) {\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n+  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_FLAT_ELEMENT, \"invalid array element type\");\n+\n@@ -1490,0 +1443,7 @@\n+  int type_size;\n+  if (type == T_OBJECT || type == T_FLAT_ELEMENT) {\n+    type_size = sizeof(address);\n+  } else {\n+    type_size = type2aelembytes(type);\n+  }\n+\n@@ -1497,1 +1457,0 @@\n-    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n@@ -1504,16 +1463,0 @@\n-int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n-  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n-  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_FLAT_ELEMENT, \"invalid array element type\");\n-  int type_size;\n-  if (type == T_OBJECT) {\n-    type_size = sizeof(address);\n-  } else if (type == T_FLAT_ELEMENT) {\n-      \/\/ TODO: FIXME\n-      fatal(\"Not supported yet\"); \/\/ FIXME: JDK-8325678\n-  } else {\n-    type_size = type2aelembytes(type);\n-  }\n-\n-  return calculate_array_max_length(writer, array, type_size, header_size);\n-}\n-\n@@ -1521,1 +1464,1 @@\n-void DumperSupport::dump_object_array(AbstractDumpWriter* writer, objArrayOop array) {\n+void DumperSupport::dump_object_array(AbstractDumpWriter* writer, objArrayOop array, DumperFlatObjectList* flat_elements) {\n@@ -1536,41 +1479,27 @@\n-  for (int index = 0; index < length; index++) {\n-    oop o = array->obj_at(index);\n-    o = mask_dormant_archived_object(o, array);\n-    writer->write_objectID(o);\n-  }\n-\n-  writer->end_sub_record();\n-}\n-\n-\/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n-void DumperSupport::dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array, DumperClassCacheTable* class_cache) {\n-  FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n-  InlineKlass* element_klass = array_klass->element_klass();\n-  int element_size = instance_size(element_klass);\n-  \/*                          id         array object ID\n-   *                          u4         stack trace serial number\n-   *                          u4         number of elements\n-   *                          u1         element type\n-   *\/\n-  short header_size = 1 + sizeof(address) + 2 * 4 + 1;\n-\n-  \/\/ TODO: use T_SHORT\/T_INT\/T_LONG if needed to avoid truncation\n-  BasicType type = T_BYTE;\n-  int type_size = type2aelembytes(type);\n-  int length = calculate_array_max_length(writer, array, element_size, header_size);\n-  u4 length_in_bytes = (u4)(length * element_size);\n-  u4 size = header_size + length_in_bytes;\n-\n-  writer->start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);\n-  writer->write_objectID(array);\n-  writer->write_u4(STACK_TRACE_ID);\n-  \/\/ TODO: round up array length for T_SHORT\/T_INT\/T_LONG\n-  writer->write_u4(length * element_size);\n-  writer->write_u1(type2tag(type));\n-\n-  for (int index = 0; index < length; index++) {\n-    \/\/ need offset in the holder to read inlined object. calculate it from flatArrayOop::value_at_addr()\n-    int offset = (int)((address)array->value_at_addr(index, array_klass->layout_helper())\n-                  - cast_from_oop<address>(array));\n-    DumperClassCacheTableEntry* class_cache_entry = class_cache->lookup_or_create(element_klass);\n-    dump_inlined_object_fields(writer, array, offset, class_cache, class_cache_entry);\n+  if (array->is_flatArray()) {\n+    flatArrayOop farray = flatArrayOop(array);\n+    FlatArrayKlass* faklass = FlatArrayKlass::cast(farray->klass());\n+\n+    InlineKlass* vk = faklass->element_klass();\n+    bool need_null_check = faklass->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+\n+    for (int index = 0; index < length; index++) {\n+      address addr = (address)farray->value_at_addr(index, faklass->layout_helper());\n+      \/\/ check for null\n+      if (need_null_check) {\n+        if (vk->is_payload_marked_as_null(addr)) {\n+          writer->write_objectID(nullptr);\n+          continue;\n+        }\n+      }\n+      \/\/ offset in the array oop\n+      int offset = (int)(addr - cast_from_oop<address>(farray));\n+      uintptr_t object_id = flat_elements->push(offset, vk);\n+      writer->write_objectID(object_id);\n+    }\n+  } else {\n+    for (int index = 0; index < length; index++) {\n+      oop o = array->obj_at(index);\n+      o = mask_dormant_archived_object(o, array);\n+      writer->write_objectID(o);\n+    }\n@@ -1579,4 +1508,0 @@\n-  \/\/ TODO: write padding bytes for T_SHORT\/T_INT\/T_LONG\n-\n-  InlinedObjects::get_instance()->add_flat_array(array);\n-\n@@ -1707,264 +1632,0 @@\n-class InlinedFieldNameDumper : public LockedClassesDo {\n-public:\n-  typedef void (*Callback)(InlinedObjects *owner, const Klass *klass, uintx base_index, int count);\n-\n-private:\n-  AbstractDumpWriter* _writer;\n-  InlinedObjects *_owner;\n-  Callback       _callback;\n-  uintx _index;\n-\n-  void dump_inlined_field_names(GrowableArray<Symbol*>* super_names, Symbol* field_name, InlineKlass* klass) {\n-    super_names->push(field_name);\n-    for (HierarchicalFieldStream<JavaFieldStream> fld(klass); !fld.done(); fld.next()) {\n-      if (!fld.access_flags().is_static()) {\n-        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n-          dump_inlined_field_names(super_names, fld.name(), DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n-        } else {\n-          \/\/ get next string ID.\n-          uintx next_index = _owner->get_next_string_id(_index);\n-          if (next_index == 0) {\n-            \/\/ something went wrong (overflow?)\n-            \/\/ stop generation; the rest of inlined objects will have original field names.\n-            return;\n-          }\n-          _index = next_index;\n-\n-          \/\/ Calculate length.\n-          int len = fld.name()->utf8_length();\n-          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n-            len += (*it)->utf8_length() + 1;    \/\/ +1 for \".\".\n-          }\n-\n-          DumperSupport::write_header(_writer, HPROF_UTF8, oopSize + len);\n-          _writer->write_symbolID(reinterpret_cast<Symbol*>(_index));\n-          \/\/ Write the string value.\n-          \/\/ 1) super_names.\n-          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n-            _writer->write_raw((*it)->bytes(), (*it)->utf8_length());\n-            _writer->write_u1('.');\n-          }\n-          \/\/ 2) field name.\n-          _writer->write_raw(fld.name()->bytes(), fld.name()->utf8_length());\n-        }\n-      }\n-    }\n-    super_names->pop();\n-  }\n-\n-  void dump_inlined_field_names(Symbol* field_name, InlineKlass* field_klass) {\n-    GrowableArray<Symbol*> super_names(4, mtServiceability);\n-    dump_inlined_field_names(&super_names, field_name, field_klass);\n-  }\n-\n-public:\n-  InlinedFieldNameDumper(AbstractDumpWriter* writer, InlinedObjects* owner, Callback callback)\n-    : _writer(writer), _owner(owner), _callback(callback), _index(0)  {\n-  }\n-\n-  void do_klass(Klass* k) {\n-    if (!k->is_instance_klass()) {\n-      return;\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    \/\/ if (ik->has_inline_type_fields()) {\n-    \/\/   return;\n-    \/\/ }\n-\n-    uintx base_index = _index;\n-    int count = 0;\n-\n-    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n-      if (!fld.access_flags().is_static()) {\n-        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n-          dump_inlined_field_names(fld.name(), DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n-          count++;\n-        }\n-      }\n-    }\n-\n-    if (count != 0) {\n-      _callback(_owner, k, base_index, count);\n-    }\n-  }\n-};\n-\n-class InlinedFieldsDumper : public LockedClassesDo {\n-private:\n-  AbstractDumpWriter* _writer;\n-\n-public:\n-  InlinedFieldsDumper(AbstractDumpWriter* writer) : _writer(writer) {}\n-\n-  void do_klass(Klass* k) {\n-    if (!k->is_instance_klass()) {\n-      return;\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    \/\/ if (ik->has_inline_type_fields()) {\n-    \/\/   return;\n-    \/\/ }\n-\n-    \/\/ We can be at a point where java mirror does not exist yet.\n-    \/\/ So we need to check that the class is at least loaded, to avoid crash from a null mirror.\n-    if (!ik->is_loaded()) {\n-      return;\n-    }\n-\n-    u2 inlined_count = 0;\n-    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n-      if (!fld.access_flags().is_static()) {\n-        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n-          inlined_count++;\n-        }\n-      }\n-    }\n-    if (inlined_count != 0) {\n-      _writer->write_u1(HPROF_CLASS_WITH_INLINED_FIELDS);\n-\n-      \/\/ class ID\n-      _writer->write_classID(ik);\n-      \/\/ number of inlined fields\n-      _writer->write_u2(inlined_count);\n-      u2 index = 0;\n-      for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n-        if (!fld.access_flags().is_static()) {\n-          if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n-            \/\/ inlined field index\n-            _writer->write_u2(index);\n-            \/\/ synthetic field count\n-            u2 field_count = DumperSupport::get_instance_fields_count(DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n-            _writer->write_u2(field_count);\n-            \/\/ original field name\n-            _writer->write_symbolID(fld.name());\n-            \/\/ inlined field class ID\n-            _writer->write_classID(DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n-\n-            index += field_count;\n-          } else {\n-            index++;\n-          }\n-        }\n-      }\n-    }\n-  }\n-};\n-\n-\n-void InlinedObjects::init() {\n-  _instance = this;\n-\n-  struct Closure : public SymbolClosure {\n-    uintx _min_id = max_uintx;\n-    uintx _max_id = 0;\n-    Closure() : _min_id(max_uintx), _max_id(0) {}\n-\n-    void do_symbol(Symbol** p) {\n-      uintx val = reinterpret_cast<uintx>(*p);\n-      if (val < _min_id) {\n-        _min_id = val;\n-      }\n-      if (val > _max_id) {\n-        _max_id = val;\n-      }\n-    }\n-  } closure;\n-\n-  SymbolTable::symbols_do(&closure);\n-\n-  _min_string_id = closure._min_id;\n-  _max_string_id = closure._max_id;\n-}\n-\n-void InlinedObjects::release() {\n-  _instance = nullptr;\n-\n-  if (_inlined_field_map != nullptr) {\n-    delete _inlined_field_map;\n-    _inlined_field_map = nullptr;\n-  }\n-  if (_flat_arrays != nullptr) {\n-    delete _flat_arrays;\n-    _flat_arrays = nullptr;\n-  }\n-}\n-\n-void InlinedObjects::inlined_field_names_callback(InlinedObjects* _this, const Klass* klass, uintx base_index, int count) {\n-  if (_this->_inlined_field_map == nullptr) {\n-    _this->_inlined_field_map = new (mtServiceability) GrowableArray<ClassInlinedFields>(100, mtServiceability);\n-  }\n-  _this->_inlined_field_map->append(ClassInlinedFields(klass, base_index));\n-\n-  \/\/ counters for dumping classes with inlined fields\n-  _this->_classes_count++;\n-  _this->_inlined_fields_count += count;\n-}\n-\n-void InlinedObjects::dump_inlined_field_names(AbstractDumpWriter* writer) {\n-  InlinedFieldNameDumper nameDumper(writer, this, inlined_field_names_callback);\n-  ClassLoaderDataGraph::classes_do(&nameDumper);\n-\n-  if (_inlined_field_map != nullptr) {\n-    \/\/ prepare the map for  get_base_index_for().\n-    _inlined_field_map->sort(ClassInlinedFields::compare);\n-  }\n-}\n-\n-uintx InlinedObjects::get_base_index_for(Klass* k) {\n-  if (_inlined_field_map != nullptr) {\n-    bool found = false;\n-    int idx = _inlined_field_map->find_sorted<ClassInlinedFields, ClassInlinedFields::compare>(ClassInlinedFields(k, 0), found);\n-    if (found) {\n-        return _inlined_field_map->at(idx).base_index;\n-    }\n-  }\n-\n-  \/\/ return max_uintx, so get_next_string_id returns 0.\n-  return max_uintx;\n-}\n-\n-uintx InlinedObjects::get_next_string_id(uintx id) {\n-  if (++id == _min_string_id) {\n-    return _max_string_id + 1;\n-  }\n-  return id;\n-}\n-\n-void InlinedObjects::dump_classed_with_inlined_fields(AbstractDumpWriter* writer) {\n-  if (_classes_count != 0) {\n-    \/\/ Record for each class contains tag(u1), class ID and count(u2)\n-    \/\/ for each inlined field index(u2), synthetic fields count(u2), original field name and class ID\n-    int size = _classes_count * (1 + sizeof(address) + 2)\n-             + _inlined_fields_count * (2 + 2 + sizeof(address) + sizeof(address));\n-    DumperSupport::write_header(writer, HPROF_INLINED_FIELDS, (u4)size);\n-\n-    InlinedFieldsDumper dumper(writer);\n-    ClassLoaderDataGraph::classes_do(&dumper);\n-  }\n-}\n-\n-void InlinedObjects::add_flat_array(oop array) {\n-  if (_flat_arrays == nullptr) {\n-    _flat_arrays = new (mtServiceability) GrowableArray<oop>(100, mtServiceability);\n-  }\n-  _flat_arrays->append(array);\n-}\n-\n-void InlinedObjects::dump_flat_arrays(AbstractDumpWriter* writer) {\n-  if (_flat_arrays != nullptr) {\n-    \/\/ For each flat array the record contains tag (u1), object ID and class ID.\n-    int size = _flat_arrays->length() * (1 + sizeof(address) + sizeof(address));\n-\n-    DumperSupport::write_header(writer, HPROF_FLAT_ARRAYS, (u4)size);\n-    for (GrowableArrayIterator<oop> it = _flat_arrays->begin(); it != _flat_arrays->end(); ++it) {\n-      flatArrayOop array = flatArrayOop(*it);\n-      FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n-      InlineKlass* element_klass = array_klass->element_klass();\n-      writer->write_u1(HPROF_FLAT_ARRAY);\n-      writer->write_objectID(array);\n-      writer->write_classID(element_klass);\n-    }\n-  }\n-}\n-\n-\n@@ -2006,0 +1667,3 @@\n+    if (DumperSupport::filter_out_klass(k)) {\n+      return;\n+    }\n@@ -2030,0 +1694,3 @@\n+    if (DumperSupport::filter_out_klass(k)) {\n+      return;\n+    }\n@@ -2455,0 +2122,44 @@\n+class FlatObjectDumper: public FlatObjectIdProvider {\n+private:\n+  volatile uintptr_t _id_counter;\n+public:\n+  FlatObjectDumper(): _id_counter(0) {\n+  }\n+\n+  void dump_flat_objects(AbstractDumpWriter* writer, oop holder,\n+                         DumperClassCacheTable* class_cache, DumperFlatObjectList* flat_objects);\n+\n+  \/\/ FlatObjectIdProvider implementation\n+  virtual uintptr_t get_id() override {\n+    \/\/ need to protect against overflow, so use instead of fetch_then_add\n+    const uintptr_t max_value = (uintptr_t)-1;\n+    uintptr_t old_value = AtomicAccess::load(&_id_counter);\n+    while (old_value != max_value) {\n+      uintptr_t new_value = old_value + 1;\n+      \/\/ to avoid conflicts with oop addresses skip aligned values\n+      if ((new_value & MinObjAlignmentInBytesMask) == 0) {\n+        new_value++;\n+      }\n+      uintptr_t value = AtomicAccess::cmpxchg(&_id_counter, old_value, new_value);\n+      if (value == old_value) {\n+        \/\/ success\n+        return new_value;\n+      }\n+      old_value = value;\n+    }\n+    \/\/ if we are here, maximum id value is reached\n+    return max_value;\n+  }\n+\n+};\n+\n+void FlatObjectDumper::dump_flat_objects(AbstractDumpWriter* writer, oop holder,\n+                                         DumperClassCacheTable* class_cache, DumperFlatObjectList* flat_objects) {\n+  \/\/ DumperSupport::dump_instance can add entries to flat_objects\n+  while (!flat_objects->is_empty()) {\n+    DumperFlatObject* obj = flat_objects->pop();\n+    DumperSupport::dump_instance(writer, obj->object_id(), holder, obj->offset(), obj->inline_klass(), class_cache, flat_objects);\n+    delete obj;\n+  }\n+}\n+\n@@ -2458,1 +2169,1 @@\n- public:\n+public:\n@@ -2462,0 +2173,1 @@\n+\n@@ -2468,0 +2180,1 @@\n+  FlatObjectDumper* _flat_dumper;\n@@ -2472,2 +2185,2 @@\n-  HeapObjectDumper(AbstractDumpWriter* writer, UnmountedVThreadDumper* vthread_dumper)\n-    : _writer(writer), _vthread_dumper(vthread_dumper) {}\n+  HeapObjectDumper(AbstractDumpWriter* writer, UnmountedVThreadDumper* vthread_dumper, FlatObjectDumper* flat_dumper)\n+    : _writer(writer), _vthread_dumper(vthread_dumper), _flat_dumper(flat_dumper) {}\n@@ -2492,0 +2205,1 @@\n+    DumperFlatObjectList flat_fields(_flat_dumper);\n@@ -2493,1 +2207,11 @@\n-    DumperSupport::dump_instance(writer(), o, &_class_cache);\n+    DumperSupport::dump_instance(writer(),\n+                                 cast_from_oop<uintptr_t>(o), \/\/ object_id is the address\n+                                 o, 0,                        \/\/ for heap instance holder is oop, offset is 0\n+                                 InstanceKlass::cast(o->klass()),\n+                                 &_class_cache, &flat_fields);\n+\n+    \/\/ if there are flattened fields, dump them\n+    if (!flat_fields.is_empty()) {\n+      _flat_dumper->dump_flat_objects(writer(), o, &_class_cache, &flat_fields);\n+    }\n+\n@@ -2501,0 +2225,1 @@\n+    DumperFlatObjectList flat_elements(_flat_dumper);\n@@ -2502,3 +2227,5 @@\n-    DumperSupport::dump_object_array(writer(), objArrayOop(o));\n-  } else if (o->is_flatArray()) {\n-    DumperSupport::dump_flat_array(writer(), flatArrayOop(o), &_class_cache);\n+    DumperSupport::dump_object_array(writer(), objArrayOop(o), &flat_elements);\n+    \/\/ if this is flat array, dump its elements\n+    if (!flat_elements.is_empty()) {\n+      _flat_dumper->dump_flat_objects(writer(), o, &_class_cache, &flat_elements);\n+    }\n@@ -2584,1 +2311,0 @@\n-  InlinedObjects*  _inlined_objects;\n@@ -2595,1 +2321,1 @@\n-  DumpMerger(const char* path, DumpWriter* writer, InlinedObjects* inlined_objects, int dump_seq) :\n+  DumpMerger(const char* path, DumpWriter* writer, int dump_seq) :\n@@ -2597,1 +2323,0 @@\n-    _inlined_objects(inlined_objects),\n@@ -2629,1 +2354,0 @@\n-    _inlined_objects->dump_flat_arrays(_writer);\n@@ -2631,1 +2355,0 @@\n-    _inlined_objects->release();\n@@ -2751,4 +2474,0 @@\n-\n-  \/\/ Inlined object support.\n-  InlinedObjects          _inlined_objects;\n-\n@@ -2760,0 +2479,3 @@\n+  \/\/ flat value object support\n+  FlatObjectDumper        _flat_dumper;\n+\n@@ -2835,2 +2557,0 @@\n-  InlinedObjects* inlined_objects() { return &_inlined_objects; }\n-\n@@ -2973,7 +2693,0 @@\n-    \/\/ HPROF_UTF8 records for inlined field names.\n-    inlined_objects()->init();\n-    inlined_objects()->dump_inlined_field_names(writer());\n-\n-    \/\/ HPROF_INLINED_FIELDS\n-    inlined_objects()->dump_classed_with_inlined_fields(writer());\n-\n@@ -3033,1 +2746,1 @@\n-    HeapObjectDumper obj_dumper(&segment_writer, this);\n+    HeapObjectDumper obj_dumper(&segment_writer, this, &_flat_dumper);\n@@ -3182,1 +2895,1 @@\n-  DumpMerger merger(path, &writer, dumper.inlined_objects(), dumper.dump_seq());\n+  DumpMerger merger(path, &writer, dumper.dump_seq());\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":301,"deletions":588,"binary":false,"changes":889,"status":"modified"},{"patch":"@@ -171,2 +171,0 @@\n-serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java 8317416 generic-all\n-\n@@ -223,1 +221,0 @@\n-serviceability\/HeapDump\/DuplicateArrayClassesTest.java 8365722 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n- * @ignore Fix JDK-8328468\n@@ -29,1 +28,1 @@\n- * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.value\n@@ -31,1 +30,0 @@\n- * @compile HeapDump.java\n@@ -41,1 +39,5 @@\n-import jdk.internal.value.PrimitiveClass;\n+import java.util.Enumeration;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n@@ -45,1 +47,0 @@\n-import jdk.test.lib.hprof.model.InlinedJavaObject;\n@@ -56,4 +57,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.util.Enumeration;\n-\n@@ -61,0 +58,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -63,10 +61,1 @@\n-class TestClass {\n-\n-    public static primitive class MyPrimitive0 {\n-        public byte prim0_fld1;\n-        public MyPrimitive0(int fld1) { prim0_fld1 = (byte)fld1; }\n-    }\n-    public static primitive class MyPrimitive {\n-        public MyPrimitive0 prim_prim0;\n-        public byte prim_fld1;\n-        public int prim_fld2;\n+value class TestClass {\n@@ -74,3 +63,3 @@\n-        public MyPrimitive(int p0, int fld1, int fld2) {\n-            prim_fld1 = (byte)fld1; prim_fld2 = fld2; prim_prim0 = new MyPrimitive0(p0);\n-        }\n+    public static value class Value0 {\n+        public int value0_int;\n+        public Value0(int i) { value0_int = i; }\n@@ -79,3 +68,4 @@\n-    public static primitive class PrimitiveHolder {\n-        \/\/ offset of the inlined hld_flatObj is the same as offset of inlined PrimitiveHolder\n-        public MyPrimitive hld_flatObj;\n+    \/\/ value class with the only value filed\n+    \/\/ offset of flattened value_value0 is the same as offset of flattened Value\n+    public static value class Value {\n+        public Value0 value_value0;\n@@ -83,2 +73,2 @@\n-        public PrimitiveHolder(int n) {\n-            hld_flatObj = new MyPrimitive((byte)n, n+1, n+2);\n+        public Value(int i) {\n+            value_value0 = i == 0 ? null : new Value0(i);\n@@ -88,5 +78,2 @@\n-    \/\/ primitive class with reference\n-    public static primitive class MyPrimitiveRef {\n-        public byte ref_fld1;\n-        public int ref_fld2;\n-        public String ref_strObj;\n+    public static value class ValueHolder {\n+        public Value holder_value;\n@@ -94,4 +81,3 @@\n-        public MyPrimitiveRef(int v1, int v2) {\n-            ref_fld1 = (byte)v1;\n-            ref_fld2 = v2;\n-            ref_strObj = \"#\" + String.valueOf(v2); }\n+        public ValueHolder(int i) {\n+            holder_value = new Value(i);\n+        }\n@@ -100,3 +86,3 @@\n-    public static primitive class PrimitiveHolderRef {\n-        public MyPrimitiveRef[] flatArr = new MyPrimitiveRef[5];\n-        public MyPrimitiveRef flatObj;\n+    \/\/ value class with reference (String)\n+    public static value class ValueRef {\n+        public Value ref_value;\n@@ -104,6 +90,4 @@\n-        public PrimitiveHolderRef(int n) {\n-            ref_str = String.valueOf(n);\n-            flatObj = new MyPrimitiveRef(n, n + 10);\n-            for (int i = 0; i < flatArr.length; i++) {\n-                flatArr[i] = new MyPrimitiveRef(i + n + 1, i + n + 11);\n-            }\n+\n+        public ValueRef(int i) {\n+            ref_value = new Value(i);\n+            ref_str = \"#\" + String.valueOf(i);\n@@ -113,11 +97,18 @@\n-    public MyPrimitive[] main_flatArr = new MyPrimitive[3];\n-    public MyPrimitive main_flatObj = new MyPrimitive(10, 15, 9);\n-    public MyPrimitiveRef main_flatObjRef = new MyPrimitiveRef(11, 144);\n-    public MyPrimitiveRef[] flatArrRef = new MyPrimitiveRef[4];\n-    public String main_strObj = \"targ.strObj\";\n-\n-    public Object main_nullObj;\n-\n-    public final PrimitiveHolder main_primHolder = new PrimitiveHolder(16);\n-    \/\/ array of compound primitive objects\n-    public final PrimitiveHolderRef[] primHolderArr = new PrimitiveHolderRef[4];\n+    \/\/ nullable value\n+    public Value nullableValue = new Value(1);\n+    \/\/ null restricted value\n+    @Strict\n+    @NullRestricted\n+    public Value nullRestrictedValue = new Value(11);\n+    \/\/ null value\n+    public Value nullValue = null;\n+    \/\/ value object with reference\n+    public ValueRef refValue = new ValueRef(21);\n+\n+    \/\/ nullable array\n+    public Value[] nullableArray = createNullableArray(101);\n+    \/\/ null restricted array\n+    public Value[] nullRestrictedArray = createNullRestrictedArray(201);\n+\n+    \/\/ static value field (for sanity, cannot be flat)\n+    public static Value staticValue = new Value(31);\n@@ -125,0 +116,2 @@\n+    public TestClass() {\n+    }\n@@ -126,6 +119,4 @@\n-    \/\/ static inlined fields\n-    public static MyPrimitive main_flatObjStatic = new MyPrimitive(13, 241, 24);\n-    public static MyPrimitiveRef[] flatArrRefStatic = new MyPrimitiveRef[6];\n-    static {\n-        for (int i = 0; i < flatArrRefStatic.length; i++) {\n-            flatArrRefStatic[i] = new MyPrimitiveRef(i + 200, i + 225);\n+    static Value[] createNullableArray(int seed) {\n+        Value[] arr = (Value[])ValueClass.newNullableAtomicArray(Value.class, 5);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (i % 2 != 0) ? null : new Value(seed + i);\n@@ -133,0 +124,1 @@\n+        return arr;\n@@ -135,9 +127,5 @@\n-    public TestClass() {\n-        for (int i = 0; i < main_flatArr.length; i++) {\n-            main_flatArr[i] = new MyPrimitive(i + 10, i + 110, i + 35);\n-        }\n-        for (int i = 0; i < flatArrRef.length; i++) {\n-            flatArrRef[i] = new MyPrimitiveRef(i + 100, i + 120);\n-        }\n-        for (int i = 0; i < primHolderArr.length; i++) {\n-            primHolderArr[i] = new PrimitiveHolderRef(20 + i);\n+    static Value[] createNullRestrictedArray(int seed) {\n+        Value defValue = new Value(0);\n+        Value[] arr = (Value[])ValueClass.newNullRestrictedNonAtomicArray(Value.class, 5, defValue);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Value(seed + i);\n@@ -145,0 +133,1 @@\n+        return arr;\n@@ -149,1 +138,0 @@\n-\n@@ -155,1 +143,0 @@\n-\n@@ -166,1 +153,3 @@\n-            LingeredApp.startApp(theApp, \"--enable-preview\"\/*, \"-XX:+PrintInlineLayout\"*\/);\n+            LingeredApp.startApp(theApp, \"--enable-preview\", \"-XX:+PrintInlineLayout\", \"-XX:+PrintFlatArrayLayout\",\n+                                 \"--add-modules=java.base\",\n+                                 \"--add-exports=java.base\/jdk.internal.value=ALL-UNNAMED\");\n@@ -274,1 +263,0 @@\n-                    + (PrimitiveClass.isPrimitiveClass(testField.getType()) ? \"(primitive) \" : \"\")\n@@ -296,1 +284,0 @@\n-                    case 'Q':\n@@ -318,6 +305,2 @@\n-                                if (arr.isFlatArray()) {\n-                                    compareObjects(logPrefix + \"  \", elementValue, dumpElements[j]);\n-                                } else {\n-                                    comparePrimitiveValues(elementValue, dumpElements[j]);\n-                                    log(logPrefix + \"  [\" + j + \"]: \" + elementValue + \" ( == \" + dumpElements[j] + \")\");\n-                                }\n+                                comparePrimitiveValues(elementValue, dumpElements[j]);\n+                                log(logPrefix + \"  [\" + j + \"]: \" + elementValue + \" ( == \" + dumpElements[j] + \")\");\n@@ -381,1 +364,1 @@\n-        if (type == '[' || type == 'Q') {\n+        if (type == '[') {\n@@ -385,3 +368,0 @@\n-        if (dumpType == 'Q') {\n-            dumpType = 'L';\n-        }\n@@ -469,1 +449,1 @@\n-                    log(logPrefix + (value instanceof InlinedJavaObject ? \"inlined \" : \"\") + \"object \" + obj);\n+                    log(logPrefix + \"object \" + obj);\n@@ -481,13 +461,2 @@\n-            } else if (value instanceof JavaValueArray arr) { \/\/ array of primitive type or flat array\n-                if (arr.isFlatArray()) {\n-                    log(logPrefix + \" flat array \" + arr + \" length: \" + arr.getLength());\n-                    JavaThing[] values = arr.getElements();\n-                    for (int v = 0; v < values.length; v++) {\n-                        log(prefix + \"  [\" + v + \"]: \" + values[v]);\n-                        if (values[v] instanceof JavaObject obj) {\n-                            print(prefix + \"    \", obj);\n-                        }\n-                    }\n-                } else {\n-                    log(logPrefix + \"(array of '\" + (char)arr.getElementType() + \"')\" + \": \" + arr.valueString());\n-                }\n+            } else if (value instanceof JavaValueArray arr) {\n+                log(logPrefix + \"(array of '\" + (char)arr.getElementType() + \"')\" + \": \" + arr.valueString());\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java","additions":70,"deletions":101,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hprof.model;\n-\n-public class InlinedJavaField extends JavaField {\n-\n-    private final JavaClass inlinedFieldClass;\n-\n-    public InlinedJavaField(String name, String signature, JavaClass inlinedFieldClass) {\n-        super(name, signature);\n-        this.inlinedFieldClass = inlinedFieldClass;\n-    }\n-\n-    @Override\n-    public boolean hasId() {\n-        return false;\n-    }\n-\n-    public JavaClass getInlinedFieldClass() {\n-        return inlinedFieldClass;\n-    }\n-\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/InlinedJavaField.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hprof.model;\n-\n-import java.io.IOException;\n-\n-\/**\n- * Represents Inlined Java object\n- *\/\n-public class InlinedJavaObject extends JavaObject {\n-\n-    \/**\n-     * Construct a new InlinedJavaObject.\n-     *\n-     * @param clazz the class object\n-     * @param offset The offset of field data\n-     *\/\n-    public InlinedJavaObject(JavaClass clazz, long offset) {\n-        super(clazz, offset);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"inlined \" + super.toString();\n-    }\n-\n-    @Override\n-    protected final long readValueLength() throws IOException {\n-        \/\/ TODO: revise - clazz.getInlinedInstanceSize()?\n-        return 0;\n-    }\n-\n-    @Override\n-    protected long dataStartOffset() {\n-        return getOffset();\n-    }\n-\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/InlinedJavaObject.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,3 +76,0 @@\n-    \/\/ Size of the instance in the object of the class is inlined.\n-    \/\/ Calculated lazily.\n-    private int inlinedInstanceSize = -1;\n@@ -120,40 +117,0 @@\n-\n-        \/\/ Resolve inlined fields. Should be done before resolveSuperclass for correct field counting\n-        Snapshot.ClassInlinedFields[] inlinedFields = snapshot.findClassInlinedFields(id);\n-        if (inlinedFields != null) {\n-            int newCount = fields.length;\n-            for (Snapshot.ClassInlinedFields f: inlinedFields) {\n-                if (f.synthFieldCount == 0) {\n-                    \/\/ Empty primitive class. just skip it - no data there.\n-                    continue;\n-                }\n-                JavaHeapObject clazz = snapshot.findThing(f.fieldClassID);\n-                if (clazz instanceof JavaClass fieldClass) {\n-                    fieldClass.resolve(snapshot);\n-\n-                    \/\/ Set new field.\n-                    fields[f.fieldIndex] = new InlinedJavaField(f.fieldName, 'Q' + fieldClass.getName() + ';', fieldClass);\n-                    newCount -= (f.synthFieldCount - 1);\n-                    \/\/ Reset invalid fields.\n-                    for (int i = 1; i < f.synthFieldCount; i++) {\n-                        fields[f.fieldIndex + i] = null;\n-                    }\n-                } else {\n-                    \/\/ The field class not found.\n-                    System.out.println(\"WARNING: class of inlined field not found:\" + getName() + \".\" + f.fieldName);\n-                }\n-            }\n-\n-            \/\/ Set new fields.\n-            JavaField[] newFields = new JavaField[newCount];\n-            int oldIndex = 0;\n-            for (int i = 0; i < newFields.length; i++) {\n-                while (fields[oldIndex] == null) {\n-                    oldIndex++;\n-                }\n-                newFields[i] = fields[oldIndex];\n-                oldIndex++;\n-            }\n-            fields = newFields;\n-        }\n-\n@@ -174,1 +131,0 @@\n-\n@@ -424,38 +380,0 @@\n-    public int getInlinedInstanceSize() {\n-        if (inlinedInstanceSize < 0) {\n-            int size = 0;\n-            for (JavaField f: fields) {\n-                if (f instanceof InlinedJavaField inlinedField) {\n-                    size += inlinedField.getInlinedFieldClass().getInlinedInstanceSize();\n-                } else {\n-                    char sig = f.getSignature().charAt(0);\n-                    switch (sig) {\n-                        case 'L':\n-                        case '[':\n-                            size += mySnapshot.getIdentifierSize();\n-                            break;\n-                        case 'B':\n-                        case 'Z':\n-                            size += 1;\n-                            break;\n-                        case 'C':\n-                        case 'S':\n-                            size += 2;\n-                            break;\n-                        case 'I':\n-                        case 'F':\n-                            size += 4;\n-                            break;\n-                        case 'J':\n-                        case 'D':\n-                            size += 8;\n-                            break;\n-                        default:\n-                            throw new RuntimeException(\"unknown field type: \" + sig);\n-                    }\n-                }\n-            }\n-            inlinedInstanceSize = size;\n-        }\n-        return inlinedInstanceSize;\n-    }\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaClass.java","additions":1,"deletions":83,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -45,6 +45,0 @@\n-\n-    public JavaObject(Object clazz, long offset) {\n-        super(offset);\n-        this.clazz = clazz;\n-    }\n-\n@@ -58,1 +52,2 @@\n-        this(makeId(classID), offset);\n+        super(offset);\n+        this.clazz = makeId(classID);\n@@ -224,1 +219,1 @@\n-    protected long readValueLength() throws IOException {\n+    protected final long readValueLength() throws IOException {\n@@ -234,1 +229,1 @@\n-    protected long dataStartOffset() {\n+    private long dataStartOffset() {\n@@ -268,65 +263,20 @@\n-                if (f instanceof InlinedJavaField inlinedField) {\n-                    JavaClass fieldClass = inlinedField.getInlinedFieldClass();\n-                    fieldValues[target+fieldNo] = new InlinedJavaObject(fieldClass, offset);\n-                    offset += fieldClass.getInlinedInstanceSize();\n-                } else {\n-                    switch (sig) {\n-                        case 'L':\n-                        case '[': {\n-                            long id = objectIdAt(offset);\n-                            offset += idSize();\n-                            JavaObjectRef ref = new JavaObjectRef(id);\n-                            fieldValues[target + fieldNo] = ref.dereference(snapshot, f, verbose);\n-                            break;\n-                        }\n-                        case 'Z': {\n-                            byte value = byteAt(offset);\n-                            offset++;\n-                            fieldValues[target + fieldNo] = new JavaBoolean(value != 0);\n-                            break;\n-                        }\n-                        case 'B': {\n-                            byte value = byteAt(offset);\n-                            offset++;\n-                            fieldValues[target + fieldNo] = new JavaByte(value);\n-                            break;\n-                        }\n-                        case 'S': {\n-                            short value = shortAt(offset);\n-                            offset += 2;\n-                            fieldValues[target + fieldNo] = new JavaShort(value);\n-                            break;\n-                        }\n-                        case 'C': {\n-                            char value = charAt(offset);\n-                            offset += 2;\n-                            fieldValues[target + fieldNo] = new JavaChar(value);\n-                            break;\n-                        }\n-                        case 'I': {\n-                            int value = intAt(offset);\n-                            offset += 4;\n-                            fieldValues[target + fieldNo] = new JavaInt(value);\n-                            break;\n-                        }\n-                        case 'J': {\n-                            long value = longAt(offset);\n-                            offset += 8;\n-                            fieldValues[target + fieldNo] = new JavaLong(value);\n-                            break;\n-                        }\n-                        case 'F': {\n-                            float value = floatAt(offset);\n-                            offset += 4;\n-                            fieldValues[target + fieldNo] = new JavaFloat(value);\n-                            break;\n-                        }\n-                        case 'D': {\n-                            double value = doubleAt(offset);\n-                            offset += 8;\n-                            fieldValues[target + fieldNo] = new JavaDouble(value);\n-                            break;\n-                        }\n-                        default:\n-                            throw new RuntimeException(\"invalid signature: \" + sig);\n-\n+                switch (sig) {\n+                    case 'L':\n+                    case '[': {\n+                        long id = objectIdAt(offset);\n+                        offset += idSize();\n+                        JavaObjectRef ref = new JavaObjectRef(id);\n+                        fieldValues[target+fieldNo] = ref.dereference(snapshot, f, verbose);\n+                        break;\n+                    }\n+                    case 'Z': {\n+                        byte value = byteAt(offset);\n+                        offset++;\n+                        fieldValues[target+fieldNo] = new JavaBoolean(value != 0);\n+                        break;\n+                    }\n+                    case 'B': {\n+                        byte value = byteAt(offset);\n+                        offset++;\n+                        fieldValues[target+fieldNo] = new JavaByte(value);\n+                        break;\n@@ -334,0 +284,39 @@\n+                    case 'S': {\n+                        short value = shortAt(offset);\n+                        offset += 2;\n+                        fieldValues[target+fieldNo] = new JavaShort(value);\n+                        break;\n+                    }\n+                    case 'C': {\n+                        char value = charAt(offset);\n+                        offset += 2;\n+                        fieldValues[target+fieldNo] = new JavaChar(value);\n+                        break;\n+                    }\n+                    case 'I': {\n+                        int value = intAt(offset);\n+                        offset += 4;\n+                        fieldValues[target+fieldNo] = new JavaInt(value);\n+                        break;\n+                    }\n+                    case 'J': {\n+                        long value = longAt(offset);\n+                        offset += 8;\n+                        fieldValues[target+fieldNo] = new JavaLong(value);\n+                        break;\n+                    }\n+                    case 'F': {\n+                        float value = floatAt(offset);\n+                        offset += 4;\n+                        fieldValues[target+fieldNo] = new JavaFloat(value);\n+                        break;\n+                    }\n+                    case 'D': {\n+                        double value = doubleAt(offset);\n+                        offset += 8;\n+                        fieldValues[target+fieldNo] = new JavaDouble(value);\n+                        break;\n+                    }\n+                    default:\n+                        throw new RuntimeException(\"invalid signature: \" + sig);\n+\n@@ -335,4 +324,4 @@\n-            } catch (IOException exp) {\n-                System.err.println(\"lazy read failed at offset \" + offset);\n-                exp.printStackTrace();\n-                return Snapshot.EMPTY_JAVATHING_ARRAY;\n+        } catch (IOException exp) {\n+            System.err.println(\"lazy read failed at offset \" + offset);\n+            exp.printStackTrace();\n+            return Snapshot.EMPTY_JAVATHING_ARRAY;\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaObject.java","additions":67,"deletions":78,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n- * An array of values, that is, an array of ints, boolean, floats, etc.\n- * or flat array of primitive objects.\n+ * An array of values, that is, an array of ints, boolean, floats or the like.\n@@ -46,0 +45,23 @@\n+    private static String arrayTypeName(byte sig) {\n+        switch (sig) {\n+            case 'B':\n+                return \"byte[]\";\n+            case 'Z':\n+                return \"boolean[]\";\n+            case 'C':\n+                return \"char[]\";\n+            case 'S':\n+                return \"short[]\";\n+            case 'I':\n+                return \"int[]\";\n+            case 'F':\n+                return \"float[]\";\n+            case 'J':\n+                return \"long[]\";\n+            case 'D':\n+                return \"double[]\";\n+            default:\n+                throw new RuntimeException(\"invalid array element sig: \" + sig);\n+        }\n+    }\n+\n@@ -81,1 +103,1 @@\n-        return len * elementSize(getRealElementType());\n+        return len * elementSize(getElementType());\n@@ -153,7 +175,0 @@\n-                case 'Q': {\n-                    for (int i = 0; i < len; i++) {\n-                        res[i] = new InlinedJavaObject(flatArrayElementClass, offset);\n-                        offset += flatArrayElementClass.getInlinedInstanceSize();\n-                    }\n-                    return res;\n-                }\n@@ -170,2 +185,0 @@\n-    private long objID;\n-\n@@ -187,4 +200,1 @@\n-    \/\/ Flat array support.\n-    private JavaClass flatArrayElementClass;\n-\n-    public JavaValueArray(long id, byte elementSignature, long offset) {\n+    public JavaValueArray(byte elementSignature, long offset) {\n@@ -192,1 +202,0 @@\n-        this.objID = id;\n@@ -200,8 +209,0 @@\n-    public boolean isFlatArray() {\n-        return flatArrayElementClass != null;\n-    }\n-\n-    public JavaClass getFlatElementClazz() {\n-        return flatArrayElementClass;\n-    }\n-\n@@ -216,17 +217,4 @@\n-\n-        byte elementType = getElementType();\n-        String elementSig = \"\" + (char)elementType;\n-        \/\/ Check if this is a flat array of primitive objects.\n-        Number elementClassID = snapshot.findFlatArrayElementType(objID);\n-        if (elementClassID != null) {\n-            \/\/ This is flat array.\n-            JavaHeapObject elementClazz = snapshot.findThing(getIdValue(elementClassID));\n-            if (elementClazz instanceof JavaClass elementJavaClazz) {\n-                flatArrayElementClass = elementJavaClazz;\n-                \/\/ need to resolve the element class\n-                flatArrayElementClass.resolve(snapshot);\n-                elementSig = \"Q\" + flatArrayElementClass.getName() + \";\";\n-            } else {\n-                \/\/ The class not found.\n-                System.out.println(\"WARNING: flat array element class not found\");\n-            }\n+        byte elementSig = getElementType();\n+        clazz = snapshot.findClass(arrayTypeName(elementSig));\n+        if (clazz == null) {\n+            clazz = snapshot.getArrayClass(\"\" + ((char) elementSig));\n@@ -234,1 +222,0 @@\n-        clazz = snapshot.getArrayClass(elementSig);\n@@ -260,3 +247,0 @@\n-            case 'Q':\n-                divider = flatArrayElementClass.getInlinedInstanceSize();\n-                break;\n@@ -277,4 +261,0 @@\n-        return isFlatArray() ? (byte)'Q' : getRealElementType();\n-    }\n-\n-    private byte getRealElementType() {\n@@ -303,1 +283,1 @@\n-        if (elementSignature == 'C' && !isFlatArray())  {\n+        if (elementSignature == 'C')  {\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":31,"deletions":51,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -68,4 +68,0 @@\n-    private Map<Number, Number> flatArrays = new HashMap<>();\n-\n-    private Map<Number, ClassInlinedFields[]> inlinedFields = new HashMap<>();\n-\n@@ -212,35 +208,0 @@\n-    public void addFlatArray(long objID, long elementClassID) {\n-        flatArrays.put(makeId(objID), makeId(elementClassID));\n-    }\n-\n-    \/**\n-     * @return null if the array is not flat array\n-     *\/\n-    Number findFlatArrayElementType(long arrayObjectID) {\n-        return flatArrays.get(makeId(arrayObjectID));\n-    }\n-\n-    public static class ClassInlinedFields {\n-        final int fieldIndex;\n-        final int synthFieldCount;\n-        final String fieldName;\n-        final long fieldClassID;\n-\n-        public ClassInlinedFields(int fieldIndex, int synthFieldCount, String fieldName, long fieldClassID) {\n-            this.fieldIndex = fieldIndex;\n-            this.synthFieldCount = synthFieldCount;\n-            this.fieldName = fieldName;\n-            this.fieldClassID =  fieldClassID;\n-        }\n-    }\n-\n-    public void addClassInlinedFields(long classID, ClassInlinedFields[] fields) {\n-        inlinedFields.put(makeId(classID), fields);\n-    }\n-\n-    \/**\n-     * @return null if the class has no inlined fields\n-     *\/\n-    ClassInlinedFields[] findClassInlinedFields(long classID) {\n-        return inlinedFields.get(makeId(classID));\n-    }\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -99,6 +99,0 @@\n-    static final int HPROF_FLAT_ARRAYS          = 0x12;\n-    static final int HPROF_INLINED_FIELDS       = 0x13;\n-\n-    static final int HPROF_FLAT_ARRAY           = 0x01;\n-    static final int HPROF_CLASS_WITH_INLINED_FIELDS = 0x01;\n-\n@@ -251,1 +245,1 @@\n-                    if (dumpsToSkip == 0) {\n+                    if (dumpsToSkip <= 0) {\n@@ -260,0 +254,1 @@\n+                        return snapshot;\n@@ -269,3 +264,3 @@\n-                        if (dumpsToSkip == 0) {\n-                            \/\/ update dumpsToSkip to skip other dumps\n-                            dumpsToSkip--;\n+                        if (dumpsToSkip <= 0) {\n+                            skipBytes(length);  \/\/ should be no-op\n+                            return snapshot;\n@@ -286,1 +281,1 @@\n-                        if (dumpsToSkip == 0) {\n+                        if (dumpsToSkip <= 0) {\n@@ -360,9 +355,0 @@\n-                case HPROF_FLAT_ARRAYS: {\n-                    readFlatArrays(length);\n-                    break;\n-                }\n-                case HPROF_INLINED_FIELDS: {\n-                    readInlinedFields(length);\n-                    break;\n-                }\n-\n@@ -869,1 +855,1 @@\n-            JavaValueArray va = new JavaValueArray(id, primitiveSignature, start);\n+            JavaValueArray va = new JavaValueArray(primitiveSignature, start);\n@@ -919,52 +905,0 @@\n-    private void readFlatArrays(long length) throws IOException {\n-        while (length > 0) {\n-            byte tag = in.readByte();\n-            length--;\n-            switch (tag) {\n-                case HPROF_FLAT_ARRAY: {\n-                    long objId = readID();\n-                    length -= identifierSize;\n-                    long elementClassId = readID();\n-                    length -= identifierSize;\n-                    snapshot.addFlatArray(objId, elementClassId);\n-                    break;\n-                }\n-                default: {\n-                    throw new IOException(\"Invalid tag \" + tag);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void readInlinedFields(long length) throws IOException {\n-        while (length > 0) {\n-            byte tag = in.readByte();\n-            length--;\n-            switch (tag) {\n-                case HPROF_CLASS_WITH_INLINED_FIELDS: {\n-                    long classID = readID();\n-                    length -= identifierSize;\n-                    int fieldNum = in.readUnsignedShort();\n-                    length -= 2;\n-                    Snapshot.ClassInlinedFields[] fields = new Snapshot.ClassInlinedFields[fieldNum];\n-                    for (int i = 0; i < fieldNum; i++) {\n-                        int fieldIndex = in.readUnsignedShort();\n-                        length -= 2;\n-                        int synthFieldCount = in.readUnsignedShort();\n-                        length -= 2;\n-                        String fieldName = getNameFromID(readID());\n-                        length -= identifierSize;\n-                        long fieldClassId = readID();\n-                        length -= identifierSize;\n-                        fields[i] = new Snapshot.ClassInlinedFields(fieldIndex, synthFieldCount, fieldName, fieldClassId);\n-                    }\n-                    snapshot.addClassInlinedFields(classID, fields);\n-                    break;\n-                }\n-                default: {\n-                    throw new IOException(\"Invalid tag \" + tag);\n-                }\n-            }\n-        }\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/HprofReader.java","additions":7,"deletions":73,"binary":false,"changes":80,"status":"modified"}]}