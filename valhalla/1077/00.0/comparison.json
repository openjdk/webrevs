{"files":[{"patch":"@@ -233,1 +233,2 @@\n-                              long timestamp, String currentVersion, String preReleaseTag, String moduleClasses) throws IOException {\n+                              long timestamp, String currentVersion, String preReleaseTag, String moduleClasses,\n+                              String includedModulesFile) throws IOException {\n@@ -249,0 +250,3 @@\n+        Set<String> includedModules = Files.lines(Paths.get(includedModulesFile))\n+                                           .flatMap(l -> Arrays.stream(l.split(\" \")))\n+                                           .collect(Collectors.toSet());\n@@ -250,1 +254,2 @@\n-        loadVersionClassesFromDirectory(data.classes, data.modules, moduleClassPath, currentVersion, previousVersion);\n+        loadVersionClassesFromDirectory(data.classes, data.modules, moduleClassPath,\n+                                        includedModules, currentVersion, previousVersion);\n@@ -1543,1 +1548,1 @@\n-        Map<String, String> extraModulesPackagesToDerive = new HashMap<>();\n+        Map<String, Set<String>> extraModulesPackagesToDerive = new HashMap<>();\n@@ -1560,1 +1565,2 @@\n-                                                     extraModulesPackagesToDerive.put(permittedPack, currentPack);\n+                                                     extraModulesPackagesToDerive.computeIfAbsent(permittedPack, x -> new HashSet<>())\n+                                                                                 .add(currentPack);\n@@ -1579,6 +1585,11 @@\n-            for (Iterator<Entry<String, String>> it = extraModulesPackagesToDerive.entrySet().iterator(); it.hasNext();) {\n-                Entry<String, String> e = it.next();\n-                Optional<ModuleHeaderDescription> module = currentVersionModules.values().stream().map(md -> md.header.get(0)).filter(d -> containsPackage(d, e.getValue())).findAny();\n-                if (module.isPresent()) {\n-                    if (!module.get().extraModulePackages.contains(e.getKey())) {\n-                        module.get().extraModulePackages.add(e.getKey());\n+            for (Iterator<Entry<String, Set<String>>> it = extraModulesPackagesToDerive.entrySet().iterator(); it.hasNext();) {\n+                Entry<String, Set<String>> e = it.next();\n+                for (String basePackage : e.getValue()) {\n+                    Optional<ModuleHeaderDescription> module = currentVersionModules.values().stream().map(md -> md.header.get(0)).filter(d -> containsPackage(d, basePackage)).findAny();\n+                    if (module.isPresent()) {\n+                        if (!module.get().extraModulePackages.contains(e.getKey())) {\n+                            module.get().extraModulePackages.add(e.getKey());\n+                        }\n+                        it.remove();\n+                        modified = true;\n+                        break;\n@@ -1586,2 +1597,0 @@\n-                    it.remove();\n-                    modified = true;\n@@ -1607,0 +1616,1 @@\n+                                    Set<String> includedModules,\n@@ -1624,0 +1634,4 @@\n+                    if (!includedModules.contains(p.getFileName().toString())) {\n+                        continue;\n+                    }\n+\n@@ -1649,0 +1663,4 @@\n+                    } else {\n+                        throw new IllegalArgumentException(\"Included module: \" +\n+                                                           p.getFileName() +\n+                                                           \" does not have a module-info.class\");\n@@ -1738,0 +1756,8 @@\n+        Map<String, Set<String>> package2ModulesUsingIt = new HashMap<>();\n+        Map<String, String> package2Module = new HashMap<>();\n+        currentVersionModules.values()\n+               .forEach(md -> {\n+                   md.header.get(0).allPackages().forEach(pack -> {\n+                       package2Module.put(pack, md.name);\n+                   });\n+               });\n@@ -1744,0 +1770,1 @@\n+                Set<String> thisClassIncludedClasses = new HashSet<>();\n@@ -1747,1 +1774,1 @@\n-                    modified |= include(includedClasses, currentVersionClasses, clazz.name);\n+                    include(thisClassIncludedClasses, currentVersionClasses, clazz.name);\n@@ -1751,1 +1778,1 @@\n-                    modified |= include(includedClasses, currentVersionClasses, header.extendsAttr);\n+                    include(thisClassIncludedClasses, currentVersionClasses, header.extendsAttr);\n@@ -1753,1 +1780,1 @@\n-                        modified |= include(includedClasses, currentVersionClasses, i);\n+                        include(thisClassIncludedClasses, currentVersionClasses, i);\n@@ -1757,1 +1784,1 @@\n-                            modified |= include(includedClasses, currentVersionClasses, i);\n+                            include(thisClassIncludedClasses, currentVersionClasses, i);\n@@ -1761,12 +1788,29 @@\n-                    modified |= includeOutputType(Collections.singleton(header),\n-                                                  h -> \"\",\n-                                                  includedClasses,\n-                                                  currentVersionClasses);\n-                    modified |= includeOutputType(clazz.fields,\n-                                                  f -> f.descriptor,\n-                                                  includedClasses,\n-                                                  currentVersionClasses);\n-                    modified |= includeOutputType(clazz.methods,\n-                                                  m -> m.descriptor,\n-                                                  includedClasses,\n-                                                  currentVersionClasses);\n+                    includeOutputType(Collections.singleton(header),\n+                                      h -> \"\",\n+                                      thisClassIncludedClasses,\n+                                      currentVersionClasses);\n+                    includeOutputType(clazz.fields,\n+                                      f -> f.descriptor,\n+                                      thisClassIncludedClasses,\n+                                      currentVersionClasses);\n+                    includeOutputType(clazz.methods,\n+                                      m -> m.descriptor,\n+                                      thisClassIncludedClasses,\n+                                      currentVersionClasses);\n+                }\n+\n+                if (includedClasses.addAll(thisClassIncludedClasses)) {\n+                    modified |= true;\n+                }\n+\n+                for (String includedClass : thisClassIncludedClasses) {\n+                    int lastSlash = includedClass.lastIndexOf('\/');\n+                    String pack;\n+                    if (lastSlash != (-1)) {\n+                        pack = includedClass.substring(0, lastSlash)\n+                                            .replace('.', '\/');\n+                    } else {\n+                        pack = \"\";\n+                    }\n+                    package2ModulesUsingIt.computeIfAbsent(pack, p -> new HashSet<>())\n+                                          .add(package2Module.get(clazz.packge()));\n@@ -1837,2 +1881,18 @@\n-            header.exports.removeIf(ed -> ed.isQualified() &&\n-                                          !allIncludedPackages.contains(ed.packageName()));\n+            for (Iterator<ExportsDescription> it = header.exports.iterator(); it.hasNext();) {\n+                ExportsDescription ed = it.next();\n+\n+                if (!ed.isQualified()) {\n+                    continue;\n+                }\n+\n+                Set<String> usingModules = package2ModulesUsingIt.getOrDefault(ed.packageName(), Set.of());\n+\n+                ed.to.retainAll(usingModules);\n+\n+                if (ed.to.isEmpty()) {\n+                    it.remove();\n+                    if (allIncludedPackages.contains(ed.packageName())) {\n+                        header.extraModulePackages.add(ed.packageName());\n+                    }\n+                }\n+            }\n@@ -1875,11 +1935,1 @@\n-                  .flatMap(h -> {\n-                      List<String> packages = new ArrayList<>();\n-                      h.exports.stream()\n-                               .map(ExportsDescription::packageName)\n-                               .forEach(packages::add);\n-                      if (h.extraModulePackages != null) {\n-                          packages.addAll(h.extraModulePackages);\n-                      }\n-                      return packages.stream();\n-                  })\n-                  .map(p -> p.replace('\/', '.'))\n+                  .flatMap(ModuleHeaderDescription::allPackages)\n@@ -2044,1 +2094,3 @@\n-        loadVersionClasses(classes, modules, classBytes, excludeList, \"$\", version);\n+        String computedBaseline = baseline.apply(data);\n+\n+        loadVersionClasses(classes, modules, classBytes, excludeList, \"$\", computedBaseline);\n@@ -2067,1 +2119,1 @@\n-            versions.add(new PlatformInput(null, version, baseline.apply(data), null));\n+            versions.add(new PlatformInput(null, version, computedBaseline, null));\n@@ -2074,1 +2126,1 @@\n-        \/\/re-write all platforms that have version as their basline:\n+        \/\/re-write all platforms that have version as their baseline:\n@@ -2094,1 +2146,4 @@\n-        String specVersion = System.getProperty(\"java.specification.version\");\n+        String platformVersion = System.getProperty(\"java.specification.version\");\n+        String currentVersion =\n+                Integer.toString(Integer.parseInt(platformVersion), Character.MAX_RADIX);\n+        String version = currentVersion.toUpperCase(Locale.ROOT);\n@@ -2101,0 +2156,1 @@\n+                                    .filter(v -> v.version.compareTo(version) < 0)\n@@ -2107,1 +2163,1 @@\n-        incrementalUpdate(ctDescriptionFile, excludeFile, specVersion, classBytes, baseline, args);\n+        incrementalUpdate(ctDescriptionFile, excludeFile, platformVersion, classBytes, baseline, args);\n@@ -2111,2 +2167,1 @@\n-        JavacTool tool = JavacTool.create();\n-        Context ctx = new Context();\n+        Set<String> includedModuleNames = new HashSet<>();\n@@ -2114,5 +2169,1 @@\n-        JavacTask task = tool.getTask(null, null, null,\n-                                      List.of(\"--release\", version),\n-                                      null, null, ctx);\n-        task.getElements().getTypeElement(\"java.lang.Object\");\n-        JavaFileManager fm = ctx.get(JavaFileManager.class);\n+        JavaFileManager moduleFM = setupJavac(\"--release\", version);\n@@ -2120,1 +2171,0 @@\n-        List<byte[]> data = new ArrayList<>();\n@@ -2123,1 +2173,1 @@\n-                    fm.listLocationsForModules(modLoc)) {\n+                    moduleFM.listLocationsForModules(modLoc)) {\n@@ -2125,16 +2175,31 @@\n-                    Iterable<JavaFileObject> files =\n-                            fm.list(loc,\n-                                    \"\",\n-                                    EnumSet.of(Kind.CLASS),\n-                                    true);\n-\n-                    for (JavaFileObject jfo : files) {\n-                        try (InputStream is = jfo.openInputStream();\n-                             InputStream in =\n-                                     new BufferedInputStream(is)) {\n-                            ByteArrayOutputStream baos =\n-                                    new ByteArrayOutputStream();\n-\n-                            in.transferTo(baos);\n-                            data.add(baos.toByteArray());\n-                        }\n+                    includedModuleNames.add(moduleFM.inferModuleName(loc));\n+                }\n+            }\n+        }\n+\n+        JavaFileManager dumpFM = setupJavac(\"--source\", version);\n+        List<byte[]> data = new ArrayList<>();\n+\n+        for (Location modLoc : LOCATIONS) {\n+            for (String moduleName : includedModuleNames) {\n+                Location loc = dumpFM.getLocationForModule(modLoc, moduleName);\n+\n+                if (loc == null) {\n+                    continue;\n+                }\n+\n+                Iterable<JavaFileObject> files =\n+                        dumpFM.list(loc,\n+                                \"\",\n+                                EnumSet.of(Kind.CLASS),\n+                                true);\n+\n+                for (JavaFileObject jfo : files) {\n+                    try (InputStream is = jfo.openInputStream();\n+                         InputStream in =\n+                                 new BufferedInputStream(is)) {\n+                        ByteArrayOutputStream baos =\n+                                new ByteArrayOutputStream();\n+\n+                        in.transferTo(baos);\n+                        data.add(baos.toByteArray());\n@@ -2153,0 +2218,9 @@\n+        private JavaFileManager setupJavac(String... options) {\n+            JavacTool tool = JavacTool.create();\n+            Context ctx = new Context();\n+            JavacTask task = tool.getTask(null, null, null,\n+                                          List.of(options),\n+                                          null, null, ctx);\n+            task.getElements().getTypeElement(\"java.lang.Object\");\n+            return ctx.get(JavaFileManager.class);\n+        }\n@@ -2354,0 +2428,1 @@\n+        Iterable<? extends ClassHeaderDescription> headers = sortedHeaders(clazzDesc.header, baseline);\n@@ -2355,2 +2430,2 @@\n-        for (ClassHeaderDescription existing : clazzDesc.header) {\n-            if (existing.equals(headerDesc) && (!existed || (baseline != null && existing.versions.contains(baseline)))) {\n+        for (ClassHeaderDescription existing : headers) {\n+            if (existing.equals(headerDesc)) {\n@@ -2359,0 +2434,1 @@\n+                break;\n@@ -2365,1 +2441,1 @@\n-            for (ClassHeaderDescription existing : clazzDesc.header) {\n+            for (ClassHeaderDescription existing : headers) {\n@@ -2394,0 +2470,20 @@\n+    private <T extends FeatureDescription> Iterable<? extends T> sortedHeaders(List<? extends T> headers, String baseline) {\n+        if (baseline == null) {\n+            return headers;\n+        }\n+\n+        \/\/move the description whose version contains baseline to the front:\n+        List<T> result = new ArrayList<>(headers);\n+\n+        for (Iterator<T> it = result.iterator(); it.hasNext();) {\n+            T fd = it.next();\n+            if (fd.versions.contains(baseline)) {\n+                it.remove();\n+                result.add(0, fd);\n+                break;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n@@ -2801,1 +2897,1 @@\n-    boolean include(Set<String> includedClasses, ClassList classes, String clazzName) {\n+    void include(Set<String> includedClasses, ClassList classes, String clazzName) {\n@@ -2803,1 +2899,1 @@\n-            return false;\n+            return ;\n@@ -2808,1 +2904,1 @@\n-            return false;\n+            return ;\n@@ -2811,1 +2907,1 @@\n-        boolean modified = includedClasses.add(clazzName);\n+        includedClasses.add(clazzName);\n@@ -2814,1 +2910,1 @@\n-            modified |= includedClasses.add(outer.name);\n+            includedClasses.add(outer.name);\n@@ -2816,2 +2912,0 @@\n-\n-        return modified;\n@@ -2820,1 +2914,1 @@\n-    <T extends FeatureDescription> boolean includeOutputType(Iterable<T> features,\n+    <T extends FeatureDescription> void includeOutputType(Iterable<T> features,\n@@ -2824,2 +2918,0 @@\n-        boolean modified = false;\n-\n@@ -2831,1 +2923,1 @@\n-                modified |= include(includedClasses, classes, m.group(1));\n+                include(includedClasses, classes, m.group(1));\n@@ -2834,2 +2926,0 @@\n-\n-        return modified;\n@@ -3259,0 +3349,14 @@\n+        public Stream<String> allPackages() {\n+            List<String> packages = new ArrayList<>();\n+\n+            exports.stream()\n+                   .map(ExportsDescription::packageName)\n+                   .forEach(packages::add);\n+            if (extraModulePackages != null) {\n+                packages.addAll(extraModulePackages);\n+            }\n+\n+            return packages.stream()\n+                           .map(p -> p.replace('\/', '.'));\n+        }\n+\n@@ -3664,0 +3768,1 @@\n+                output.append(\" permittedSubclasses \" + serializeList(permittedSubclasses));\n@@ -3684,0 +3789,5 @@\n+            isSealed = reader.attributes.containsKey(\"permittedSubclasses\");\n+            if (isSealed) {\n+                String subclassesList = reader.attributes.get(\"permittedSubclasses\");\n+                permittedSubclasses = deserializeList(subclassesList);\n+            }\n@@ -3692,5 +3802,0 @@\n-            isSealed = reader.attributes.containsKey(\"permittedSubclasses\");\n-            if (isSealed) {\n-                String subclassesList = reader.attributes.get(\"permittedSubclasses\");\n-                permittedSubclasses = deserializeList(subclassesList);\n-            }\n@@ -4646,0 +4751,1 @@\n+                String includedModules;\n@@ -4647,1 +4753,1 @@\n-                if (args.length == 7) {\n+                if (args.length == 8) {\n@@ -4655,1 +4761,2 @@\n-                } else if (args.length == 8) {\n+                    includedModules = args[7];\n+                } else if (args.length == 9) {\n@@ -4663,0 +4770,1 @@\n+                    includedModules = args[8];\n@@ -4679,1 +4787,2 @@\n-                                                  moduleClasses);\n+                                                  moduleClasses,\n+                                                  includedModules);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":204,"deletions":95,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-    jdk\/internal\/classfile\/snippet-files \\\n-    jdk\/internal\/classfile\/components\/snippet-files\n+    java\/lang\/classfile\/snippet-files \\\n+    java\/lang\/classfile\/components\/snippet-files\n","filename":"make\/modules\/java.base\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,5 +101,0 @@\n-        --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -865,1 +865,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c exeGetCreatedJavaVMs.c\n@@ -1508,0 +1508,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMonitorWithDeadObjectTest += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1371,1 +1371,1 @@\n-                                           FloatRegister src, BasicType src_bt) {\n+                                           FloatRegister src, BasicType src_bt, bool is_unsigned) {\n@@ -1375,2 +1375,1 @@\n-      assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n-      sxtl(dst, T8H, src, T8B);\n+      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n@@ -1380,2 +1379,2 @@\n-      sxtl(dst, T8H, src, T8B);\n-      sxtl(dst, T4S, dst, T4H);\n+      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n+      _xshll(is_unsigned, dst, T4S, dst, T4H, 0);\n@@ -1386,1 +1385,1 @@\n-    sxtl(dst, T4S, src, T4H);\n+    _xshll(is_unsigned, dst, T4S, src, T4H, 0);\n@@ -1390,1 +1389,1 @@\n-    sxtl(dst, T2D, src, T2S);\n+    _xshll(is_unsigned, dst, T2D, src, T2S, 0);\n@@ -1424,1 +1423,2 @@\n-                                          FloatRegister src, SIMD_RegVariant src_size) {\n+                                          FloatRegister src, SIMD_RegVariant src_size,\n+                                          bool is_unsigned) {\n@@ -1426,0 +1426,1 @@\n+\n@@ -1429,1 +1430,1 @@\n-      sve_sunpklo(dst, H, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, H, src);\n@@ -1432,2 +1433,2 @@\n-      sve_sunpklo(dst, H, src);\n-      sve_sunpklo(dst, S, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, H, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, dst);\n@@ -1436,3 +1437,3 @@\n-      sve_sunpklo(dst, H, src);\n-      sve_sunpklo(dst, S, dst);\n-      sve_sunpklo(dst, D, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, H, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, D, dst);\n@@ -1445,1 +1446,1 @@\n-      sve_sunpklo(dst, S, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, src);\n@@ -1447,2 +1448,2 @@\n-      sve_sunpklo(dst, S, src);\n-      sve_sunpklo(dst, D, dst);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, S, src);\n+      _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, D, dst);\n@@ -1451,1 +1452,1 @@\n-    sve_sunpklo(dst, D, src);\n+    _sve_xunpk(is_unsigned, \/* is_high *\/ false, dst, D, src);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-                          FloatRegister src, BasicType src_bt);\n+                          FloatRegister src, BasicType src_bt, bool is_unsigned = false);\n@@ -105,1 +105,1 @@\n-                         FloatRegister src, SIMD_RegVariant src_size);\n+                         FloatRegister src, SIMD_RegVariant src_size, bool is_unsigned = false);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4600,0 +4600,17 @@\n+void MacroAssembler::restore_cpu_control_state_after_jni(Register tmp1, Register tmp2) {\n+  if (RestoreMXCSROnJNICalls) {\n+    Label OK;\n+    get_fpcr(tmp1);\n+    mov(tmp2, tmp1);\n+    \/\/ Set FPCR to the state we need. We do want Round to Nearest. We\n+    \/\/ don't want non-IEEE rounding modes or floating-point traps.\n+    bfi(tmp1, zr, 22, 4); \/\/ Clear DN, FZ, and Rmode\n+    bfi(tmp1, zr, 8, 5);  \/\/ Clear exception-control bits (8-12)\n+    bfi(tmp1, zr, 0, 2);  \/\/ Clear AH:FIZ\n+    eor(tmp2, tmp1, tmp2);\n+    cbz(tmp2, OK);        \/\/ Only reset FPCR if it's wrong\n+    set_fpcr(tmp1);\n+    bind(OK);\n+  }\n+}\n+\n@@ -6029,1 +6046,1 @@\n-\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n@@ -6246,0 +6263,3 @@\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ Return the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -6252,3 +6272,0 @@\n-  \/\/ Adjust result: res == len ? len : 0\n-  cmp(len, res);\n-  csel(res, res, zr, EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1111,2 +1111,2 @@\n-  \/\/ only if +VerifyFPU\n-  void verify_FPU(int stack_depth, const char* s = \"illegal FPU state\");\n+  \/\/ Restore cpu control state after JNI call\n+  void restore_cpu_control_state_after_jni(Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2129,0 +2129,3 @@\n+  \/\/ Verify or restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(rscratch1, rscratch2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1392,0 +1392,3 @@\n+  \/\/ Restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(rscratch1, rscratch2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2603,0 +2603,7 @@\n+  \/\/ There might be a volatile load before this Unsafe CAS.\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ sync();\n+  } else {\n+    __ lwsync();\n+  }\n+\n@@ -2964,3 +2971,18 @@\n-  Register Rco = noreg;\n-  if (UseCompressedOops && data->is_oop()) {\n-    Rco = __ encode_heap_oop(Rtmp, data->as_register());\n+  Register Robj = noreg;\n+  if (data->is_oop()) {\n+    if (UseCompressedOops) {\n+      Robj = __ encode_heap_oop(Rtmp, data->as_register());\n+    } else {\n+      Robj = data->as_register();\n+      if (Robj == dest->as_register()) { \/\/ May happen with ZGC.\n+        __ mr(Rtmp, Robj);\n+        Robj = Rtmp;\n+      }\n+    }\n+  }\n+\n+  \/\/ There might be a volatile load before this Unsafe OP.\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ sync();\n+  } else {\n+    __ lwsync();\n@@ -2986,0 +3008,1 @@\n+    assert_different_registers(Rptr, Rold, Robj);\n@@ -2987,2 +3010,1 @@\n-      assert_different_registers(Rptr, Rold, Rco);\n-      __ stwcx_(Rco, Rptr);\n+      __ stwcx_(Robj, Rptr);\n@@ -2991,7 +3013,0 @@\n-      Register Robj = data->as_register();\n-      assert_different_registers(Rptr, Rold, Rtmp);\n-      assert_different_registers(Rptr, Robj, Rtmp);\n-      if (Robj == Rold) { \/\/ May happen with ZGC.\n-        __ mr(Rtmp, Robj);\n-        Robj = Rtmp;\n-      }\n@@ -3025,0 +3040,6 @@\n+\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ isync();\n+  } else {\n+    __ sync();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-    return _xmmindex->is_valid() && _xmmindex->encoding() >= 8;\n+    return _xmmindex->is_valid() && ((_xmmindex->encoding() & 8) == 8);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1126,0 +1126,24 @@\n+  \/* Note on 'non-obvious' assembly sequence:\n+   *\n+   * While there are vminps\/vmaxps instructions, there are two important differences between hardware\n+   * and Java on how they handle floats:\n+   *  a. -0.0 and +0.0 are considered equal (vminps\/vmaxps will return second parameter when inputs are equal)\n+   *  b. NaN is not necesarily propagated (vminps\/vmaxps will return second parameter when either input is NaN)\n+   *\n+   * It is still more efficient to use vminps\/vmaxps, but with some pre\/post-processing:\n+   *  a. -0.0\/+0.0: Bias negative (positive) numbers to second parameter before vminps (vmaxps)\n+   *                (only useful when signs differ, noop otherwise)\n+   *  b. NaN: Check if it was the first parameter that had the NaN (with vcmp[UNORD_Q])\n+\n+   *  Following pseudo code describes the algorithm for max[FD] (Min algorithm is on similar lines):\n+   *   btmp = (b < +0.0) ? a : b\n+   *   atmp = (b < +0.0) ? b : a\n+   *   Tmp  = Max_Float(atmp , btmp)\n+   *   Res  = (atmp == NaN) ? atmp : Tmp\n+   *\/\n+\n+  void (MacroAssembler::*vblend)(XMMRegister, XMMRegister, XMMRegister, XMMRegister, int, bool, XMMRegister);\n+  void (MacroAssembler::*vmaxmin)(XMMRegister, XMMRegister, XMMRegister, int);\n+  void (MacroAssembler::*vcmp)(XMMRegister, XMMRegister, XMMRegister, int, int);\n+  XMMRegister mask;\n+\n@@ -1127,5 +1151,4 @@\n-    vblendvps(atmp, a, b, a, vlen_enc);\n-    vblendvps(btmp, b, a, a, vlen_enc);\n-    vminps(tmp, atmp, btmp, vlen_enc);\n-    vcmpps(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvps(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = a;\n+    vblend = &MacroAssembler::vblendvps;\n+    vmaxmin = &MacroAssembler::vminps;\n+    vcmp = &MacroAssembler::vcmpps;\n@@ -1133,5 +1156,4 @@\n-    vblendvps(btmp, b, a, b, vlen_enc);\n-    vblendvps(atmp, a, b, b, vlen_enc);\n-    vmaxps(tmp, atmp, btmp, vlen_enc);\n-    vcmpps(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvps(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = b;\n+    vblend = &MacroAssembler::vblendvps;\n+    vmaxmin = &MacroAssembler::vmaxps;\n+    vcmp = &MacroAssembler::vcmpps;\n@@ -1139,5 +1161,4 @@\n-    vblendvpd(atmp, a, b, a, vlen_enc);\n-    vblendvpd(btmp, b, a, a, vlen_enc);\n-    vminpd(tmp, atmp, btmp, vlen_enc);\n-    vcmppd(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvpd(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = a;\n+    vblend = &MacroAssembler::vblendvpd;\n+    vmaxmin = &MacroAssembler::vminpd;\n+    vcmp = &MacroAssembler::vcmppd;\n@@ -1146,5 +1167,4 @@\n-    vblendvpd(btmp, b, a, b, vlen_enc);\n-    vblendvpd(atmp, a, b, b, vlen_enc);\n-    vmaxpd(tmp, atmp, btmp, vlen_enc);\n-    vcmppd(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvpd(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = b;\n+    vblend = &MacroAssembler::vblendvpd;\n+    vmaxmin = &MacroAssembler::vmaxpd;\n+    vcmp = &MacroAssembler::vcmppd;\n@@ -1152,0 +1172,26 @@\n+\n+  \/\/ Make sure EnableX86ECoreOpts isn't disabled on register overlaps\n+  XMMRegister maxmin, scratch;\n+  if (dst == btmp) {\n+    maxmin = btmp;\n+    scratch = tmp;\n+  } else {\n+    maxmin = tmp;\n+    scratch = btmp;\n+  }\n+\n+  bool precompute_mask = EnableX86ECoreOpts && UseAVX>1;\n+  if (precompute_mask && !is_double_word) {\n+    vpsrad(tmp, mask, 32, vlen_enc);\n+    mask = tmp;\n+  } else if (precompute_mask && is_double_word) {\n+    vpxor(tmp, tmp, tmp, vlen_enc);\n+    vpcmpgtq(tmp, tmp, mask, vlen_enc);\n+    mask = tmp;\n+  }\n+\n+  (this->*vblend)(atmp, a, b, mask, vlen_enc, !precompute_mask, btmp);\n+  (this->*vblend)(btmp, b, a, mask, vlen_enc, !precompute_mask, tmp);\n+  (this->*vmaxmin)(maxmin, atmp, btmp, vlen_enc);\n+  (this->*vcmp)(scratch, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n+  (this->*vblend)(dst, maxmin, atmp, scratch, vlen_enc, false, scratch);\n@@ -5350,1 +5396,1 @@\n-    vblendvpd(dst, one, dst, src, vec_enc);\n+    vblendvpd(dst, one, dst, src, vec_enc, true, xtmp1);\n@@ -5353,1 +5399,1 @@\n-    vblendvpd(dst, dst, src, xtmp1, vec_enc);\n+    vblendvpd(dst, dst, src, xtmp1, vec_enc, false, xtmp1);\n@@ -5358,1 +5404,1 @@\n-    vblendvps(dst, one, dst, src, vec_enc);\n+    vblendvps(dst, one, dst, src, vec_enc, true, xtmp1);\n@@ -5361,1 +5407,1 @@\n-    vblendvps(dst, dst, src, xtmp1, vec_enc);\n+    vblendvps(dst, dst, src, xtmp1, vec_enc, false, xtmp1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":70,"deletions":24,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -3714,0 +3714,50 @@\n+\/\/ Vector float blend\n+\/\/ vblendvps(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg)\n+void MacroAssembler::vblendvps(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister mask, int vector_len, bool compute_mask, XMMRegister scratch) {\n+  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n+  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n+  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst;\n+  bool dst_available = dst != mask && (dst != src1 || dst != src2);\n+  if (blend_emulation && scratch_available && dst_available) {\n+    if (compute_mask) {\n+      vpsrad(scratch, mask, 32, vector_len);\n+      mask = scratch;\n+    }\n+    if (dst == src1) {\n+      vpandn(dst,     mask, src1, vector_len); \/\/ if mask == 0, src1\n+      vpand (scratch, mask, src2, vector_len); \/\/ if mask == 1, src2\n+    } else {\n+      vpand (dst,     mask, src2, vector_len); \/\/ if mask == 1, src2\n+      vpandn(scratch, mask, src1, vector_len); \/\/ if mask == 0, src1\n+    }\n+    vpor(dst, dst, scratch, vector_len);\n+  } else {\n+    Assembler::vblendvps(dst, src1, src2, mask, vector_len);\n+  }\n+}\n+\n+\/\/ vblendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg)\n+void MacroAssembler::vblendvpd(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister mask, int vector_len, bool compute_mask, XMMRegister scratch) {\n+  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n+  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n+  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst && (!compute_mask || scratch != mask);\n+  bool dst_available = dst != mask && (dst != src1 || dst != src2);\n+  if (blend_emulation && scratch_available && dst_available) {\n+    if (compute_mask) {\n+      vpxor(scratch, scratch, scratch, vector_len);\n+      vpcmpgtq(scratch, scratch, mask, vector_len);\n+      mask = scratch;\n+    }\n+    if (dst == src1) {\n+      vpandn(dst,     mask, src1, vector_len); \/\/ if mask == 0, src\n+      vpand (scratch, mask, src2, vector_len); \/\/ if mask == 1, src2\n+    } else {\n+      vpand (dst,     mask, src2, vector_len); \/\/ if mask == 1, src2\n+      vpandn(scratch, mask, src1, vector_len); \/\/ if mask == 0, src\n+    }\n+    vpor(dst, dst, scratch, vector_len);\n+  } else {\n+    Assembler::vblendvpd(dst, src1, src2, mask, vector_len);\n+  }\n+}\n+\n@@ -9349,1 +9399,3 @@\n-\/\/   ..\\jdk\\src\\java.base\\share\\classes\\java\\lang\\StringUTF16.java\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ Return the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -9351,1 +9403,1 @@\n-\/\/   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+\/\/   public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -9353,3 +9405,3 @@\n-\/\/       int c = src[srcOff++];\n-\/\/       if (c >>> 8 != 0) {\n-\/\/         return 0;\n+\/\/       char c = src[srcOff];\n+\/\/       if (c > 0xff) {\n+\/\/           return i;  \/\/ return index of non-latin1 char\n@@ -9357,1 +9409,3 @@\n-\/\/       dst[dstOff++] = (byte)c;\n+\/\/       dst[dstOff] = (byte)c;\n+\/\/       srcOff++;\n+\/\/       dstOff++;\n@@ -9365,1 +9419,1 @@\n-  Label copy_chars_loop, return_length, return_zero, done;\n+  Label copy_chars_loop, done, reset_sp, copy_tail;\n@@ -9380,1 +9434,1 @@\n-  push(len);\n+  movl(result, len);\n@@ -9386,1 +9440,1 @@\n-    Label copy_32_loop, copy_loop_tail, below_threshold;\n+    Label copy_32_loop, copy_loop_tail, below_threshold, reset_for_copy_tail;\n@@ -9391,1 +9445,1 @@\n-    \/\/ if length of the string is less than 16, handle it in an old fashioned way\n+    \/\/ if length of the string is less than 32, handle it the old fashioned way\n@@ -9397,2 +9451,2 @@\n-    movl(result, 0x00FF);\n-    evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);\n+    movl(tmp5, 0x00FF);\n+    evpbroadcastw(tmp2Reg, tmp5, Assembler::AVX_512bit);\n@@ -9401,1 +9455,1 @@\n-    jcc(Assembler::zero, post_alignment);\n+    jccb(Assembler::zero, post_alignment);\n@@ -9410,1 +9464,1 @@\n-    jcc(Assembler::zero, post_alignment);\n+    jccb(Assembler::zero, post_alignment);\n@@ -9413,4 +9467,5 @@\n-    movl(result, 0xFFFFFFFF);\n-    shlxl(result, result, tmp5);\n-    notl(result);\n-    kmovdl(mask2, result);\n+    movl(len, 0xFFFFFFFF);\n+    shlxl(len, len, tmp5);\n+    notl(len);\n+    kmovdl(mask2, len);\n+    movl(len, result);\n@@ -9421,1 +9476,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jcc(Assembler::carryClear, copy_tail);\n@@ -9436,1 +9491,1 @@\n-    jcc(Assembler::zero, copy_loop_tail);\n+    jccb(Assembler::zero, copy_loop_tail);\n@@ -9446,1 +9501,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jccb(Assembler::carryClear, reset_for_copy_tail);\n@@ -9452,1 +9507,1 @@\n-    jcc(Assembler::notZero, copy_32_loop);\n+    jccb(Assembler::notZero, copy_32_loop);\n@@ -9457,1 +9512,1 @@\n-    jcc(Assembler::zero, return_length);\n+    jcc(Assembler::zero, done);\n@@ -9462,3 +9517,3 @@\n-    movl(result, 0xFFFFFFFF);\n-    shlxl(result, result, len);\n-    notl(result);\n+    movl(tmp5, 0xFFFFFFFF);\n+    shlxl(tmp5, tmp5, len);\n+    notl(tmp5);\n@@ -9466,1 +9521,1 @@\n-    kmovdl(mask2, result);\n+    kmovdl(mask2, tmp5);\n@@ -9471,1 +9526,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jcc(Assembler::carryClear, copy_tail);\n@@ -9474,1 +9529,7 @@\n-    jmp(return_length);\n+    jmp(done);\n+\n+    bind(reset_for_copy_tail);\n+    lea(src, Address(src, tmp5, Address::times_2));\n+    lea(dst, Address(dst, tmp5, Address::times_1));\n+    subptr(len, tmp5);\n+    jmp(copy_chars_loop);\n@@ -9480,1 +9541,1 @@\n-    Label copy_32_loop, copy_16, copy_tail;\n+    Label copy_32_loop, copy_16, copy_tail_sse, reset_for_copy_tail;\n@@ -9482,1 +9543,3 @@\n-    movl(result, len);\n+    \/\/ vectored compression\n+    testl(len, 0xfffffff8);\n+    jcc(Assembler::zero, copy_tail);\n@@ -9485,0 +9548,2 @@\n+    movdl(tmp1Reg, tmp5);\n+    pshufd(tmp1Reg, tmp1Reg, 0);   \/\/ store Unicode mask in tmp1Reg\n@@ -9486,5 +9551,2 @@\n-    \/\/ vectored compression\n-    andl(len, 0xfffffff0);    \/\/ vector count (in chars)\n-    andl(result, 0x0000000f);    \/\/ tail count (in chars)\n-    testl(len, len);\n-    jcc(Assembler::zero, copy_16);\n+    andl(len, 0xfffffff0);\n+    jccb(Assembler::zero, copy_16);\n@@ -9493,2 +9555,0 @@\n-    movdl(tmp1Reg, tmp5);\n-    pshufd(tmp1Reg, tmp1Reg, 0);   \/\/ store Unicode mask in tmp1Reg\n@@ -9507,1 +9567,1 @@\n-    jcc(Assembler::notZero, return_zero);\n+    jccb(Assembler::notZero, reset_for_copy_tail);\n@@ -9511,1 +9571,1 @@\n-    jcc(Assembler::notZero, copy_32_loop);\n+    jccb(Assembler::notZero, copy_32_loop);\n@@ -9515,5 +9575,3 @@\n-    movl(len, result);\n-    andl(len, 0xfffffff8);    \/\/ vector count (in chars)\n-    andl(result, 0x00000007);    \/\/ tail count (in chars)\n-    testl(len, len);\n-    jccb(Assembler::zero, copy_tail);\n+    \/\/ len = 0\n+    testl(result, 0x00000008);     \/\/ check if there's a block of 8 chars to compress\n+    jccb(Assembler::zero, copy_tail_sse);\n@@ -9521,2 +9579,0 @@\n-    movdl(tmp1Reg, tmp5);\n-    pshufd(tmp1Reg, tmp1Reg, 0);   \/\/ store Unicode mask in tmp1Reg\n@@ -9527,1 +9583,1 @@\n-    jccb(Assembler::notZero, return_zero);\n+    jccb(Assembler::notZero, reset_for_copy_tail);\n@@ -9532,0 +9588,1 @@\n+    jmpb(copy_tail_sse);\n@@ -9533,1 +9590,9 @@\n-    bind(copy_tail);\n+    bind(reset_for_copy_tail);\n+    movl(tmp5, result);\n+    andl(tmp5, 0x0000000f);\n+    lea(src, Address(src, tmp5, Address::times_2));\n+    lea(dst, Address(dst, tmp5, Address::times_1));\n+    subptr(len, tmp5);\n+    jmpb(copy_chars_loop);\n+\n+    bind(copy_tail_sse);\n@@ -9535,0 +9600,1 @@\n+    andl(len, 0x00000007);    \/\/ tail count (in chars)\n@@ -9537,0 +9603,1 @@\n+  bind(copy_tail);\n@@ -9538,1 +9605,1 @@\n-  jccb(Assembler::zero, return_length);\n+  jccb(Assembler::zero, done);\n@@ -9544,4 +9611,4 @@\n-  load_unsigned_short(result, Address(src, len, Address::times_2));\n-  testl(result, 0xff00);      \/\/ check if Unicode char\n-  jccb(Assembler::notZero, return_zero);\n-  movb(Address(dst, len, Address::times_1), result);  \/\/ ASCII char; compress to 1 byte\n+  load_unsigned_short(tmp5, Address(src, len, Address::times_2));\n+  testl(tmp5, 0xff00);      \/\/ check if Unicode char\n+  jccb(Assembler::notZero, reset_sp);\n+  movb(Address(dst, len, Address::times_1), tmp5);  \/\/ ASCII char; compress to 1 byte\n@@ -9549,6 +9616,1 @@\n-  jcc(Assembler::notZero, copy_chars_loop);\n-\n-  \/\/ if compression succeeded, return length\n-  bind(return_length);\n-  pop(result);\n-  jmpb(done);\n+  jccb(Assembler::notZero, copy_chars_loop);\n@@ -9556,4 +9618,3 @@\n-  \/\/ if compression failed, return 0\n-  bind(return_zero);\n-  xorl(result, result);\n-  addptr(rsp, wordSize);\n+  \/\/ add len then return (len will be zero if compress succeeded, otherwise negative)\n+  bind(reset_sp);\n+  addl(result, len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":125,"deletions":64,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -1193,0 +1193,4 @@\n+  \/\/ Vector float blend\n+  void vblendvps(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg);\n+  void vblendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7838,1 +7838,1 @@\n-  predicate(UseAVX > 0 &&\n+  predicate(UseAVX > 0 && !EnableX86ECoreOpts &&\n@@ -7852,1 +7852,1 @@\n-  predicate(UseAVX > 0 &&\n+  predicate(UseAVX > 0 && !EnableX86ECoreOpts &&\n@@ -7865,0 +7865,16 @@\n+instruct vblendvp(legVec dst, legVec src1, legVec src2, legVec mask, legVec vtmp) %{\n+  predicate(UseAVX > 0 && EnableX86ECoreOpts &&\n+            n->in(2)->bottom_type()->isa_vectmask() == NULL &&\n+            Matcher::vector_length_in_bytes(n) <= 32);\n+  match(Set dst (VectorBlend (Binary src1 src2) mask));\n+  format %{ \"vector_blend  $dst,$src1,$src2,$mask\\t! using $vtmp as TEMP\" %}\n+  effect(TEMP vtmp, TEMP dst);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpandn($vtmp$$XMMRegister, $mask$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+    __ vpand ($dst$$XMMRegister,  $mask$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpor  ($dst$$XMMRegister,  $dst$$XMMRegister,  $vtmp$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4512,8 +4512,0 @@\n-\n-\/\/ Following pseudo code describes the algorithm for max[FD]:\n-\/\/ Min algorithm is on similar lines\n-\/\/  btmp = (b < +0.0) ? a : b\n-\/\/  atmp = (b < +0.0) ? b : a\n-\/\/  Tmp  = Max_Float(atmp , btmp)\n-\/\/  Res  = (atmp == NaN) ? atmp : Tmp\n-\n@@ -4525,7 +4517,1 @@\n-  format %{\n-     \"vblendvps        $btmp,$b,$a,$b           \\n\\t\"\n-     \"vblendvps        $atmp,$a,$b,$b           \\n\\t\"\n-     \"vmaxss           $tmp,$atmp,$btmp         \\n\\t\"\n-     \"vcmpps.unordered $btmp,$atmp,$atmp        \\n\\t\"\n-     \"vblendvps        $dst,$tmp,$atmp,$btmp    \\n\\t\"\n-  %}\n+  format %{ \"maxF $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4533,7 +4519,2 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n- %}\n+    __ vminmax_fp(Op_MaxV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n@@ -4561,7 +4542,1 @@\n-  format %{\n-     \"vblendvpd        $btmp,$b,$a,$b            \\n\\t\"\n-     \"vblendvpd        $atmp,$a,$b,$b            \\n\\t\"\n-     \"vmaxsd           $tmp,$atmp,$btmp          \\n\\t\"\n-     \"vcmppd.unordered $btmp,$atmp,$atmp         \\n\\t\"\n-     \"vblendvpd        $dst,$tmp,$atmp,$btmp     \\n\\t\"\n-  %}\n+  format %{ \"maxD $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4569,6 +4544,1 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vminmax_fp(Op_MaxV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n@@ -4597,7 +4567,1 @@\n-  format %{\n-     \"vblendvps        $atmp,$a,$b,$a             \\n\\t\"\n-     \"vblendvps        $btmp,$b,$a,$a             \\n\\t\"\n-     \"vminss           $tmp,$atmp,$btmp           \\n\\t\"\n-     \"vcmpps.unordered $btmp,$atmp,$atmp          \\n\\t\"\n-     \"vblendvps        $dst,$tmp,$atmp,$btmp      \\n\\t\"\n-  %}\n+  format %{ \"minF $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4605,6 +4569,1 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vminmax_fp(Op_MinV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n@@ -4633,7 +4592,1 @@\n-  format %{\n-     \"vblendvpd        $atmp,$a,$b,$a           \\n\\t\"\n-     \"vblendvpd        $btmp,$b,$a,$a           \\n\\t\"\n-     \"vminsd           $tmp,$atmp,$btmp         \\n\\t\"\n-     \"vcmppd.unordered $btmp,$atmp,$atmp        \\n\\t\"\n-     \"vblendvpd        $dst,$tmp,$atmp,$btmp    \\n\\t\"\n-  %}\n+    format %{ \"minD $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4641,6 +4594,1 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vminmax_fp(Op_MinV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":9,"deletions":61,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"include\/jvm_io.h\"\n@@ -33,0 +35,2 @@\n+#include \"runtime\/java.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n@@ -43,0 +47,3 @@\n+bool CDSConfig::_module_patching_disables_cds = false;\n+bool CDSConfig::_java_base_module_patching_disables_cds = false;\n+\n@@ -48,0 +55,330 @@\n+char* CDSConfig::_default_archive_path = nullptr;\n+char* CDSConfig::_static_archive_path = nullptr;\n+char* CDSConfig::_dynamic_archive_path = nullptr;\n+\n+void CDSConfig::initialize() {\n+  if (is_dumping_static_archive()) {\n+    if (RequireSharedSpaces) {\n+      warning(\"Cannot dump shared archive while using shared archive\");\n+    }\n+    UseSharedSpaces = false;\n+  }\n+\n+  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n+  \/\/ This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.\n+  \/\/\n+  \/\/ UseSharedSpaces may be disabled if -XX:SharedArchiveFile is invalid.\n+  if (is_dumping_static_archive() || UseSharedSpaces) {\n+    init_shared_archive_paths();\n+  }\n+}\n+\n+char* CDSConfig::default_archive_path() {\n+  if (_default_archive_path == nullptr) {\n+    char jvm_path[JVM_MAXPATHLEN];\n+    os::jvm_path(jvm_path, sizeof(jvm_path));\n+    char *end = strrchr(jvm_path, *os::file_separator());\n+    if (end != nullptr) *end = '\\0';\n+    size_t jvm_path_len = strlen(jvm_path);\n+    size_t file_sep_len = strlen(os::file_separator());\n+    const size_t len = jvm_path_len + file_sep_len + strlen(\"classes_nocoops_valhalla.jsa\") + 1;\n+    _default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n+    LP64_ONLY(bool nocoops = !UseCompressedOops);\n+    NOT_LP64(bool nocoops = false);\n+    bool valhalla = is_valhalla_preview();\n+    jio_snprintf(_default_archive_path, len, \"%s%sclasses%s%s.jsa\",\n+                jvm_path, os::file_separator(),\n+                 nocoops ? \"_nocoops\" : \"\",\n+                 valhalla ? \"_valhalla\" : \"\");\n+  }\n+  return _default_archive_path;\n+}\n+\n+int CDSConfig::num_archives(const char* archive_path) {\n+  if (archive_path == nullptr) {\n+    return 0;\n+  }\n+  int npaths = 1;\n+  char* p = (char*)archive_path;\n+  while (*p != '\\0') {\n+    if (*p == os::path_separator()[0]) {\n+      npaths++;\n+    }\n+    p++;\n+  }\n+  return npaths;\n+}\n+\n+void CDSConfig::extract_shared_archive_paths(const char* archive_path,\n+                                             char** base_archive_path,\n+                                             char** top_archive_path) {\n+  char* begin_ptr = (char*)archive_path;\n+  char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);\n+  if (end_ptr == nullptr || end_ptr == begin_ptr) {\n+    vm_exit_during_initialization(\"Base archive was not specified\", archive_path);\n+  }\n+  size_t len = end_ptr - begin_ptr;\n+  char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n+  strncpy(cur_path, begin_ptr, len);\n+  cur_path[len] = '\\0';\n+  *base_archive_path = cur_path;\n+\n+  begin_ptr = ++end_ptr;\n+  if (*begin_ptr == '\\0') {\n+    vm_exit_during_initialization(\"Top archive was not specified\", archive_path);\n+  }\n+  end_ptr = strchr(begin_ptr, '\\0');\n+  assert(end_ptr != nullptr, \"sanity\");\n+  len = end_ptr - begin_ptr;\n+  cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n+  strncpy(cur_path, begin_ptr, len + 1);\n+  *top_archive_path = cur_path;\n+}\n+\n+void CDSConfig::init_shared_archive_paths() {\n+  if (ArchiveClassesAtExit != nullptr) {\n+    assert(!RecordDynamicDumpInfo, \"already checked\");\n+    if (is_dumping_static_archive()) {\n+      vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump\");\n+    }\n+    check_unsupported_dumping_properties();\n+\n+    if (os::same_files(default_archive_path(), ArchiveClassesAtExit)) {\n+      vm_exit_during_initialization(\n+        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", default_archive_path());\n+    }\n+  }\n+\n+  if (SharedArchiveFile == nullptr) {\n+    _static_archive_path = default_archive_path();\n+  } else {\n+    int archives = num_archives(SharedArchiveFile);\n+    assert(archives > 0, \"must be\");\n+\n+    if (is_dumping_archive() && archives > 1) {\n+      vm_exit_during_initialization(\n+        \"Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping\");\n+    }\n+\n+    if (is_dumping_static_archive()) {\n+      assert(archives == 1, \"must be\");\n+      \/\/ Static dump is simple: only one archive is allowed in SharedArchiveFile. This file\n+      \/\/ will be overwritten no matter regardless of its contents\n+      _static_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n+    } else {\n+      \/\/ SharedArchiveFile may specify one or two files. In case (c), the path for base.jsa\n+      \/\/ is read from top.jsa\n+      \/\/    (a) 1 file:  -XX:SharedArchiveFile=base.jsa\n+      \/\/    (b) 2 files: -XX:SharedArchiveFile=base.jsa:top.jsa\n+      \/\/    (c) 2 files: -XX:SharedArchiveFile=top.jsa\n+      \/\/\n+      \/\/ However, if either RecordDynamicDumpInfo or ArchiveClassesAtExit is used, we do not\n+      \/\/ allow cases (b) and (c). Case (b) is already checked above.\n+\n+      if (archives > 2) {\n+        vm_exit_during_initialization(\n+          \"Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option\");\n+      }\n+      if (archives == 1) {\n+        char* base_archive_path = nullptr;\n+        bool success =\n+          FileMapInfo::get_base_archive_name_from_header(SharedArchiveFile, &base_archive_path);\n+        if (!success) {\n+          \/\/ If +AutoCreateSharedArchive and the specified shared archive does not exist,\n+          \/\/ regenerate the dynamic archive base on default archive.\n+          if (AutoCreateSharedArchive && !os::file_exists(SharedArchiveFile)) {\n+            enable_dumping_dynamic_archive();\n+            ArchiveClassesAtExit = const_cast<char *>(SharedArchiveFile);\n+            _static_archive_path = default_archive_path();\n+            SharedArchiveFile = nullptr;\n+          } else {\n+            if (AutoCreateSharedArchive) {\n+              warning(\"-XX:+AutoCreateSharedArchive is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+              AutoCreateSharedArchive = false;\n+            }\n+            Arguments::no_shared_spaces(\"invalid archive\");\n+          }\n+        } else if (base_archive_path == nullptr) {\n+          \/\/ User has specified a single archive, which is a static archive.\n+          _static_archive_path = const_cast<char *>(SharedArchiveFile);\n+        } else {\n+          \/\/ User has specified a single archive, which is a dynamic archive.\n+          _dynamic_archive_path = const_cast<char *>(SharedArchiveFile);\n+          _static_archive_path = base_archive_path; \/\/ has been c-heap allocated.\n+        }\n+      } else {\n+        extract_shared_archive_paths((const char*)SharedArchiveFile,\n+                                      &_static_archive_path, &_dynamic_archive_path);\n+        if (_static_archive_path == nullptr) {\n+          assert(_dynamic_archive_path == nullptr, \"must be\");\n+          Arguments::no_shared_spaces(\"invalid archive\");\n+        }\n+      }\n+\n+      if (_dynamic_archive_path != nullptr) {\n+        \/\/ Check for case (c)\n+        if (RecordDynamicDumpInfo) {\n+          vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n+                                        SharedArchiveFile);\n+        }\n+        if (ArchiveClassesAtExit != nullptr) {\n+          vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n+                                        SharedArchiveFile);\n+        }\n+      }\n+\n+      if (ArchiveClassesAtExit != nullptr && os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {\n+          vm_exit_during_initialization(\n+            \"Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit\",\n+            SharedArchiveFile);\n+      }\n+    }\n+  }\n+}\n+\n+void CDSConfig::check_system_property(const char* key, const char* value) {\n+  if (Arguments::is_internal_module_property(key)) {\n+    MetaspaceShared::disable_optimized_module_handling();\n+    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n+      strcmp(key, \"jdk.module.validation\") == 0 ||\n+      strcmp(key, \"java.system.class.loader\") == 0) {\n+    disable_loading_full_module_graph();\n+    disable_dumping_full_module_graph();\n+    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+}\n+\n+static const char* unsupported_properties[] = {\n+  \"jdk.module.limitmods\",\n+  \"jdk.module.upgrade.path\",\n+};\n+static const char* unsupported_options[] = {\n+  \"--limit-modules\",\n+  \"--upgrade-module-path\",\n+};\n+\n+void CDSConfig::check_unsupported_dumping_properties() {\n+  assert(is_dumping_archive(), \"this function is only used with CDS dump time\");\n+  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n+  \/\/ If a vm option is found in the unsupported_options array, vm will exit with an error message.\n+  SystemProperty* sp = Arguments::system_properties();\n+  while (sp != nullptr) {\n+    for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n+      if (strcmp(sp->key(), unsupported_properties[i]) == 0) {\n+        vm_exit_during_initialization(\n+          \"Cannot use the following option when dumping the shared archive\", unsupported_options[i]);\n+      }\n+    }\n+    sp = sp->next();\n+  }\n+\n+  if (module_patching_disables_cds()) {\n+    vm_exit_during_initialization(\n+            \"Cannot use the following option when dumping the shared archive\", \"--patch-module\");\n+  }\n+\n+\n+  \/\/ Check for an exploded module build in use with -Xshare:dump.\n+  if (!Arguments::has_jimage()) {\n+    vm_exit_during_initialization(\"Dumping the shared archive is not supported with an exploded module build\");\n+  }\n+}\n+\n+bool CDSConfig::check_unsupported_cds_runtime_properties() {\n+  assert(UseSharedSpaces, \"this function is only used with -Xshare:{on,auto}\");\n+  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n+  if (ArchiveClassesAtExit != nullptr) {\n+    \/\/ dynamic dumping, just return false for now.\n+    \/\/ check_unsupported_dumping_properties() will be called later to check the same set of\n+    \/\/ properties, and will exit the VM with the correct error message if the unsupported properties\n+    \/\/ are used.\n+    return false;\n+  }\n+  for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n+    if (Arguments::get_property(unsupported_properties[i]) != nullptr) {\n+      if (RequireSharedSpaces) {\n+        warning(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n+      } else {\n+        log_info(cds)(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n+      }\n+      return true;\n+    }\n+  }\n+\n+  if (module_patching_disables_cds()) {\n+    if (RequireSharedSpaces) {\n+      warning(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    } else {\n+      log_info(cds)(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    }\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool CDSConfig::check_vm_args_consistency(bool mode_flag_cmd_line) {\n+  if (is_dumping_static_archive()) {\n+    if (!mode_flag_cmd_line) {\n+      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n+      \/\/\n+      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n+      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n+      Arguments::set_mode_flags(Arguments::_int);\n+    } else if (Arguments::mode() == Arguments::_comp) {\n+      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n+      \/\/ Java code, so there's not much benefit in running -Xcomp.\n+      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n+      Arguments::set_mode_flags(Arguments::_mixed);\n+    }\n+\n+    \/\/ String deduplication may cause CDS to iterate the strings in different order from one\n+    \/\/ run to another which resulting in non-determinstic CDS archives.\n+    \/\/ Disable UseStringDeduplication while dumping CDS archive.\n+    UseStringDeduplication = false;\n+  }\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != nullptr && RecordDynamicDumpInfo) {\n+    jio_fprintf(defaultStream::output_stream(),\n+                \"-XX:+RecordDynamicDumpInfo cannot be used with -XX:ArchiveClassesAtExit.\\n\");\n+    return false;\n+  }\n+\n+  if (ArchiveClassesAtExit == nullptr && !RecordDynamicDumpInfo) {\n+    disable_dumping_dynamic_archive();\n+  } else {\n+    enable_dumping_dynamic_archive();\n+  }\n+\n+  if (AutoCreateSharedArchive) {\n+    if (SharedArchiveFile == nullptr) {\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n+      return false;\n+    }\n+    if (ArchiveClassesAtExit != nullptr) {\n+      log_warning(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      return false;\n+    }\n+  }\n+\n+  if (UseSharedSpaces && java_base_module_patching_disables_cds() && module_patching_disables_cds()) {\n+    Arguments::no_shared_spaces(\"CDS is disabled when \" JAVA_BASE_NAME \" module is patched.\");\n+  }\n+  if (UseSharedSpaces && check_unsupported_cds_runtime_properties()) {\n+    UseSharedSpaces = false;\n+  }\n+\n+  if (is_dumping_archive()) {\n+    \/\/ Always verify non-system classes during CDS dump\n+    if (!BytecodeVerificationRemote) {\n+      BytecodeVerificationRemote = true;\n+      log_info(cds)(\"All non-system classes will be verified (-Xverify:remote) during CDS dump time.\");\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":337,"deletions":0,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +38,7 @@\n+\n+  static bool _module_patching_disables_cds;\n+  static bool _java_base_module_patching_disables_cds;\n+\n+  static char*  _default_archive_path;\n+  static char*  _static_archive_path;\n+  static char*  _dynamic_archive_path;\n@@ -39,0 +47,6 @@\n+  static void extract_shared_archive_paths(const char* archive_path,\n+                                           char** base_archive_path,\n+                                           char** top_archive_path);\n+  static void init_shared_archive_paths();\n+  static bool check_unsupported_cds_runtime_properties();\n+\n@@ -40,0 +54,11 @@\n+  \/\/ Initialization and command-line checking\n+  static void initialize() NOT_CDS_RETURN;\n+  static void check_system_property(const char* key, const char* value) NOT_CDS_RETURN;\n+  static void check_unsupported_dumping_properties() NOT_CDS_RETURN;\n+  static bool check_vm_args_consistency(bool mode_flag_cmd_line) NOT_CDS_RETURN_(false);\n+\n+  static bool module_patching_disables_cds() { return _module_patching_disables_cds; }\n+  static void set_module_patching_disables_cds() { _module_patching_disables_cds = true; }\n+  static bool java_base_module_patching_disables_cds() { return _java_base_module_patching_disables_cds; }\n+  static void set_java_base_module_patching_disables_cds() { _java_base_module_patching_disables_cds = true; }\n+\n@@ -48,0 +73,11 @@\n+  \/\/ Archive paths\n+  \/\/ Points to the classes.jsa in $JAVA_HOME\n+  static char* default_archive_path()                         NOT_CDS_RETURN_(nullptr);\n+  \/\/ The actual static archive  (if any) selected at runtime\n+  static const char* static_archive_path()                   { return CDS_ONLY(_static_archive_path) NOT_CDS(nullptr); }\n+  \/\/ The actual dynamic archive  (if any) selected at runtime\n+  static const char* dynamic_archive_path()                  { return CDS_ONLY(_dynamic_archive_path) NOT_CDS(nullptr); }\n+\n+  static int num_archives(const char* archive_path)          NOT_CDS_RETURN_(0);\n+\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -230,2 +230,2 @@\n-    const char* default_base_archive_name = Arguments::get_default_shared_archive_path();\n-    const char* current_base_archive_name = Arguments::GetSharedArchivePath();\n+    const char* default_base_archive_name = CDSConfig::default_archive_path();\n+    const char* current_base_archive_name = CDSConfig::static_archive_path();\n@@ -267,1 +267,1 @@\n-    copy_base_archive_name(Arguments::GetSharedArchivePath());\n+    copy_base_archive_name(CDSConfig::static_archive_path());\n@@ -468,15 +468,7 @@\n-  } else if ((has_timestamp() && _timestamp != st.st_mtime) ||\n-             _filesize != st.st_size) {\n-    ok = false;\n-    if (PrintSharedArchiveAndExit) {\n-      log_warning(cds)(_timestamp != st.st_mtime ?\n-                                 \"Timestamp mismatch\" :\n-                                 \"File size mismatch\");\n-    } else {\n-      const char* bad_jar_msg = \"A jar file is not the one used while building the shared archive file:\";\n-      log_warning(cds)(\"%s %s\", bad_jar_msg, name);\n-      if (!log_is_enabled(Info, cds)) {\n-        log_warning(cds)(\"%s %s\", bad_jar_msg, name);\n-      }\n-      if (_timestamp != st.st_mtime) {\n-        log_warning(cds)(\"%s timestamp has changed.\", name);\n+  } else {\n+    bool size_differs = _filesize != st.st_size;\n+    bool time_differs = has_timestamp() && _timestamp != st.st_mtime;\n+    if (time_differs || size_differs) {\n+      ok = false;\n+      if (PrintSharedArchiveAndExit) {\n+        log_warning(cds)(time_differs ? \"Timestamp mismatch\" : \"File size mismatch\");\n@@ -484,1 +476,11 @@\n-        log_warning(cds)(\"%s size has changed.\", name);\n+        const char* bad_file_msg = \"This file is not the one used while building the shared archive file:\";\n+        log_warning(cds)(\"%s %s\", bad_file_msg, name);\n+        if (!log_is_enabled(Info, cds)) {\n+          log_warning(cds)(\"%s %s\", bad_file_msg, name);\n+        }\n+        if (time_differs) {\n+          log_warning(cds)(\"%s timestamp has changed.\", name);\n+        }\n+        if (size_differs) {\n+          log_warning(cds)(\"%s size has changed.\", name);\n+        }\n@@ -987,1 +989,1 @@\n-  int num_paths = Arguments::num_archives(rp);\n+  int num_paths = CDSConfig::num_archives(rp);\n@@ -1319,1 +1321,1 @@\n-    *base_archive_name = Arguments::get_default_shared_archive_path();\n+    *base_archive_name = CDSConfig::default_archive_path();\n@@ -2348,1 +2350,1 @@\n-        ArchiveClassesAtExit = Arguments::GetSharedDynamicArchivePath();\n+        ArchiveClassesAtExit = CDSConfig::dynamic_archive_path();\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-  const char* static_archive = Arguments::GetSharedArchivePath();\n+  const char* static_archive = CDSConfig::static_archive_path();\n@@ -656,2 +656,1 @@\n-  Arguments::check_unsupported_dumping_properties();\n-\n+  CDSConfig::check_unsupported_dumping_properties();\n@@ -788,1 +787,0 @@\n-    StringTable::allocate_shared_strings_array(CHECK);\n@@ -798,0 +796,4 @@\n+\n+    \/\/ Do this at the very end, when no Java code will be executed. Otherwise\n+    \/\/ some new strings may be added to the intern table.\n+    StringTable::allocate_shared_strings_array(CHECK);\n@@ -993,2 +995,2 @@\n-  const char* static_archive = Arguments::GetSharedArchivePath();\n-  assert(static_archive != nullptr, \"SharedArchivePath is nullptr\");\n+  const char* static_archive = CDSConfig::static_archive_path();\n+  assert(static_archive != nullptr, \"sanity\");\n@@ -1007,1 +1009,1 @@\n-  const char* dynamic_archive = Arguments::GetSharedDynamicArchivePath();\n+  const char* dynamic_archive = CDSConfig::dynamic_archive_path();\n@@ -1500,1 +1502,1 @@\n-      tty->print_cr(\"\\n\\nBase archive name: %s\", Arguments::GetSharedArchivePath());\n+      tty->print_cr(\"\\n\\nBase archive name: %s\", CDSConfig::static_archive_path());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -204,0 +204,1 @@\n+  bool deprecated()             const { return is_loaded() && get_Method()->deprecated(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,0 +483,1 @@\n+  return ciBitData(nullptr);\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -957,0 +957,2 @@\n+    _java_lang_Deprecated,\n+    _java_lang_Deprecated_for_removal,\n@@ -1128,0 +1130,1 @@\n+    b_tag_val = 'Z',  \/\/ payload is boolean\n@@ -1150,0 +1153,26 @@\n+    if (AnnotationCollector::_java_lang_Deprecated == id) {\n+      assert(count <= 2, \"change this if more element-value pairs are added to the @Deprecated annotation\");\n+      \/\/ @Deprecated can specify forRemoval=true\n+      const u1* offset = abase + member_off;\n+      for (int i = 0; i < count; ++i) {\n+        int member_index = Bytes::get_Java_u2((address)offset);\n+        offset += 2;\n+        member = check_symbol_at(cp, member_index);\n+        if (member == vmSymbols::since()) {\n+          assert(*((address)offset) == s_tag_val, \"invariant\");\n+          offset += 3;\n+          continue;\n+        }\n+        if (member == vmSymbols::for_removal()) {\n+          assert(*((address)offset) == b_tag_val, \"invariant\");\n+          const u2 boolean_value_index = Bytes::get_Java_u2((address)offset + 1);\n+          if (cp->int_at(boolean_value_index) == 1) {\n+            \/\/ forRemoval == true\n+            coll->set_annotation(AnnotationCollector::_java_lang_Deprecated_for_removal);\n+          }\n+          break;\n+        }\n+\n+      }\n+      continue;\n+    }\n@@ -2050,0 +2079,3 @@\n+    case VM_SYMBOL_ENUM_NAME(java_lang_Deprecated): {\n+      return _java_lang_Deprecated;\n+    }\n@@ -2094,0 +2126,4 @@\n+  if (has_annotation(_java_lang_Deprecated))\n+    m->set_deprecated();\n+  if (has_annotation(_java_lang_Deprecated_for_removal))\n+    m->set_deprecated_for_removal();\n@@ -2107,0 +2143,16 @@\n+  if (has_annotation(_java_lang_Deprecated)) {\n+    Array<Method*>* methods = ik->methods();\n+    int length = ik->methods()->length();\n+    for (int i = 0; i < length; i++) {\n+      Method* m = methods->at(i);\n+      m->set_deprecated();\n+    }\n+  }\n+  if (has_annotation(_java_lang_Deprecated_for_removal)) {\n+    Array<Method*>* methods = ik->methods();\n+    int length = ik->methods()->length();\n+    for (int i = 0; i < length; i++) {\n+      Method* m = methods->at(i);\n+      m->set_deprecated_for_removal();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -615,1 +615,1 @@\n-  \/\/ these classes are unloading.  Must be called\n+  \/\/ these classes are unloading.  This must be called\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,3 +189,2 @@\n-  void set_unloading_next(ClassLoaderData* unloading_next);\n-  ClassLoaderData* unloading_next() const;\n-\n+\n+public:\n@@ -195,0 +194,5 @@\n+  void set_unloading_next(ClassLoaderData* unloading_next);\n+  ClassLoaderData* unloading_next() const;\n+  void unload();\n+\n+private:\n@@ -206,0 +210,2 @@\n+  void classes_do(void f(Klass* const));\n+\n@@ -207,1 +213,0 @@\n-  void unload();\n@@ -210,1 +215,0 @@\n-  void classes_do(void f(Klass* const));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2017,1 +2017,1 @@\n-    case NEW :\n+    case NEW:\n@@ -2020,4 +2020,3 @@\n-    case STARTED :\n-    case RUNNABLE :\n-    case RUNNING :\n-    case PARKING :\n+    case STARTED:\n+    case RUNNING:\n+    case PARKING:\n@@ -2025,1 +2024,3 @@\n-    case YIELDING :\n+    case UNPARKED:\n+    case YIELDING:\n+    case YIELDED:\n@@ -2028,2 +2029,2 @@\n-    case PARKED :\n-    case PINNED :\n+    case PARKED:\n+    case PINNED:\n@@ -2036,1 +2037,1 @@\n-    case TERMINATED :\n+    case TERMINATED:\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -529,8 +529,8 @@\n-    RUNNABLE      = 2,\n-    RUNNING       = 3,\n-    PARKING       = 4,\n-    PARKED        = 5,\n-    PINNED        = 6,\n-    TIMED_PARKING = 7,\n-    TIMED_PARKED  = 8,\n-    TIMED_PINNED  = 9,\n+    RUNNING       = 2,\n+    PARKING       = 3,\n+    PARKED        = 4,\n+    PINNED        = 5,\n+    TIMED_PARKING = 6,\n+    TIMED_PARKED  = 7,\n+    TIMED_PINNED  = 8,\n+    UNPARKED      = 9,\n@@ -538,0 +538,1 @@\n+    YIELDED       = 11,\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -943,1 +943,1 @@\n-  assert(!Arguments::module_patching_disables_cds(), \"Cannot use CDS\");\n+  assert(!CDSConfig::module_patching_disables_cds(), \"Cannot use CDS\");\n@@ -1019,1 +1019,1 @@\n-        assert(!Arguments::module_patching_disables_cds(), \"Cannot use CDS\");\n+        assert(!CDSConfig::module_patching_disables_cds(), \"Cannot use CDS\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,0 +1015,1 @@\n+                                     \"Z\"                                                                                                       \\\n@@ -1029,0 +1030,1 @@\n+                                            \"Z\"                                                                                                \\\n@@ -1044,0 +1046,1 @@\n+                                      \"Z\"                                                                                                      \\\n@@ -1058,0 +1061,1 @@\n+                                             \"Z\"                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,1 +165,3 @@\n-                                                                                                  \\\n+  template(java_lang_Deprecated,                      \"Ljava\/lang\/Deprecated;\")                   \\\n+  template(since,                                     \"since\")                                    \\\n+  template(for_removal,                               \"forRemoval\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  blob->flush();\n+  blob->purge();\n@@ -176,1 +176,1 @@\n-void CodeBlob::flush() {\n+void CodeBlob::purge(bool free_code_cache_data) {\n@@ -791,0 +791,4 @@\n+  if (blob == nullptr) {\n+    return nullptr; \/\/ caller must handle this\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  virtual void flush();\n+  virtual void purge(bool free_code_cache_data = true);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  virtual void flush() = 0;\n+  virtual void purge(bool free_code_cache_data = true) = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -642,1 +643,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -792,1 +793,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -1418,1 +1419,1 @@\n-  if (_unlinked_next != nullptr) {\n+  if (_is_unlinked) {\n@@ -1452,1 +1453,1 @@\n-  CodeCache::register_unlinked(this);\n+  ClassUnloadingContext::context()->register_unlinked_nmethod(this);\n@@ -1455,1 +1456,1 @@\n-void nmethod::flush() {\n+void nmethod::purge(bool free_code_cache_data) {\n@@ -1478,2 +1479,4 @@\n-  CodeBlob::flush();\n-  CodeCache::free(this);\n+  CodeBlob::purge();\n+  if (free_code_cache_data) {\n+    CodeCache::free(this);\n+  }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  nmethod* _unlinked_next;\n+  bool _is_unlinked;\n@@ -451,2 +451,2 @@\n-  nmethod* unlinked_next() const                  { return _unlinked_next; }\n-  void set_unlinked_next(nmethod* next)           { _unlinked_next = next; }\n+  bool is_unlinked() const                        { return _is_unlinked; }\n+  void set_is_unlinked()                          { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n@@ -532,1 +532,1 @@\n-  void flush();\n+  void purge(bool free_code_cache_data = true);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-  if (compiler->is_jvmci()) {\n+  if (compiler->is_jvmci() && !UseJVMCINativeLibrary) {\n@@ -300,1 +300,1 @@\n-      if (compiler->is_jvmci()) {\n+      if (compiler->is_jvmci() && !UseJVMCINativeLibrary) {\n@@ -775,5 +775,0 @@\n-Handle CompileBroker::create_thread_oop(const char* name, TRAPS) {\n-  Handle thread_oop = JavaThread::create_system_thread_object(name, CHECK_NH);\n-  return thread_oop;\n-}\n-\n@@ -926,0 +921,7 @@\n+static jobject create_compiler_thread(AbstractCompiler* compiler, int i, TRAPS) {\n+  char name_buffer[256];\n+  os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", compiler->name(), i);\n+  Handle thread_oop = JavaThread::create_system_thread_object(name_buffer, CHECK_NULL);\n+  return JNIHandles::make_global(thread_oop);\n+}\n+\n@@ -956,10 +958,1 @@\n-  char name_buffer[256];\n-\n-    jobject thread_handle = nullptr;\n-    \/\/ Create all j.l.Thread objects for C1 and C2 threads here, but only one\n-    \/\/ for JVMCI compiler which can create further ones on demand.\n-    JVMCI_ONLY(if (!UseJVMCICompiler || !UseDynamicNumberOfCompilerThreads || i == 0) {)\n-    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"%s CompilerThread%d\", _compilers[1]->name(), i);\n-    Handle thread_oop = create_thread_oop(name_buffer, CHECK);\n-    thread_handle = JNIHandles::make_global(thread_oop);\n-    JVMCI_ONLY(})\n+    jobject thread_handle = create_compiler_thread(_compilers[1], i, CHECK);\n@@ -988,3 +981,1 @@\n-    os::snprintf_checked(name_buffer, sizeof(name_buffer), \"C1 CompilerThread%d\", i);\n-    Handle thread_oop = create_thread_oop(name_buffer, CHECK);\n-    jobject thread_handle = JNIHandles::make_global(thread_oop);\n+    jobject thread_handle = create_compiler_thread(_compilers[0], i, CHECK);\n@@ -1018,1 +1009,1 @@\n-      Handle thread_oop = create_thread_oop(\"Deoptimize objects a lot single mode\", CHECK);\n+      Handle thread_oop = JavaThread::create_system_thread_object(\"Deoptimize objects a lot single mode\", CHECK);\n@@ -1045,7 +1036,9 @@\n-      if (UseJVMCICompiler) {\n-        \/\/ Native compiler threads as used in C1\/C2 can reuse the j.l.Thread\n-        \/\/ objects as their existence is completely hidden from the rest of\n-        \/\/ the VM (and those compiler threads can't call Java code to do the\n-        \/\/ creation anyway). For JVMCI we have to create new j.l.Thread objects\n-        \/\/ as they are visible and we can see unexpected thread lifecycle\n-        \/\/ transitions if we bind them to new JavaThreads.\n+      if (UseJVMCICompiler && !UseJVMCINativeLibrary && _compiler2_objects[i] == nullptr) {\n+        \/\/ Native compiler threads as used in C1\/C2 can reuse the j.l.Thread objects as their\n+        \/\/ existence is completely hidden from the rest of the VM (and those compiler threads can't\n+        \/\/ call Java code to do the creation anyway).\n+        \/\/\n+        \/\/ For pure Java JVMCI we have to create new j.l.Thread objects as they are visible and we\n+        \/\/ can see unexpected thread lifecycle transitions if we bind them to new JavaThreads.  For\n+        \/\/ native library JVMCI it's preferred to use the C1\/C2 strategy as this avoids unnecessary\n+        \/\/ coupling with Java.\n@@ -1059,1 +1052,1 @@\n-          thread_oop = create_thread_oop(name_buffer, THREAD);\n+          thread_oop = JavaThread::create_system_thread_object(name_buffer, THREAD);\n@@ -1079,0 +1072,1 @@\n+      guarantee(compiler2_object(i) != nullptr, \"Thread oop must exist\");\n@@ -1797,1 +1791,1 @@\n-    blob->flush();\n+    blob->purge();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":24,"deletions":30,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp\"\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.inline.hpp\"\n@@ -88,1 +88,1 @@\n-    EVAC_FAILURE_INJECTOR_ONLY(_evac_failure_inject_counter(0) COMMA)\n+    ALLOCATION_FAILURE_INJECTOR_ONLY(_allocation_failure_inject_counter(0) COMMA)\n@@ -430,1 +430,1 @@\n-#if EVAC_FAILURE_INJECTOR\n+#if ALLOCATION_FAILURE_INJECTOR\n@@ -432,1 +432,1 @@\n-  return _g1h->evac_failure_injector()->evacuation_should_fail(_evac_failure_inject_counter, region_idx);\n+  return _g1h->allocation_failure_injector()->allocation_should_fail(_allocation_failure_inject_counter, region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1028,3 +1029,6 @@\n-  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-  DEBUG_ONLY(MetaspaceUtils::verify();)\n+  {\n+    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", gc_timer());\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n@@ -1496,1 +1500,1 @@\n-    start_array(id)->allocate_block(obj_beg);\n+    start_array(id)->update_for_block(obj_beg, obj_beg + obj_len);\n@@ -1768,0 +1772,3 @@\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* lock_codeblob_free_separately *\/);\n+\n@@ -2057,0 +2064,2 @@\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n@@ -2068,2 +2077,9 @@\n-    \/\/ Release unloaded nmethods's memory.\n-    CodeCache::flush_unlinked_nmethods();\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n@@ -2450,1 +2466,0 @@\n-  old_gen->start_array()->reset();\n@@ -2522,1 +2537,1 @@\n-  _start_array->allocate_block(addr);\n+  _start_array->update_for_block(addr, addr + cast_to_oop(addr)->size());\n@@ -2615,1 +2630,1 @@\n-    start_array->allocate_block(addr);\n+    start_array->update_for_block(addr, addr + cast_to_oop(addr)->size());\n@@ -3121,1 +3136,1 @@\n-    _start_array->allocate_block(destination());\n+    _start_array->update_for_block(destination(), destination() + words);\n@@ -3161,1 +3176,0 @@\n-  _space_id(space_id),\n@@ -3186,2 +3200,3 @@\n-    _start_array->allocate_block(addr);\n-    addr += cast_to_oop(addr)->size();\n+    size_t size = cast_to_oop(addr)->size();\n+    _start_array->update_for_block(addr, addr + size);\n+    addr += size;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    bool attempt_more_loopopts = ShenandoahLoopOptsAfterExpansion;\n@@ -57,9 +56,3 @@\n-    PhaseIdealLoop::verify(igvn);\n-    if (attempt_more_loopopts) {\n-      C->set_major_progress();\n-      if (!C->optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {\n-        return false;\n-      }\n-      C->clear_major_progress();\n-      C->process_for_post_loop_opts_igvn(igvn);\n-      if (C->failing()) return false;\n+    C->set_major_progress();\n+    if (!C->optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {\n+      return false;\n@@ -68,0 +61,4 @@\n+    C->clear_major_progress();\n+    C->process_for_post_loop_opts_igvn(igvn);\n+    if (C->failing()) return false;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -791,0 +792,3 @@\n+  \/\/ Initialize CPUTimeCounters object, which must be done before creation of the heap.\n+  CPUTimeCounters::initialize();\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,5 +61,7 @@\n-   flag(has_scalarized_args       , 1 << 19) \\\n-   flag(has_scalarized_return     , 1 << 20) \\\n-   flag(c1_needs_stack_repair     , 1 << 21) \\\n-   flag(c2_needs_stack_repair     , 1 << 22) \\\n-   flag(mismatch                  , 1 << 23) \\\n+   flag(deprecated                , 1 << 19) \\\n+   flag(deprecated_for_removal    , 1 << 20) \\\n+   flag(has_scalarized_args       , 1 << 21) \\\n+   flag(has_scalarized_return     , 1 << 22) \\\n+   flag(c1_needs_stack_repair     , 1 << 23) \\\n+   flag(c2_needs_stack_repair     , 1 << 24) \\\n+   flag(mismatch                  , 1 << 25) \\\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-  jint int_at(int cp_index) {\n+  jint int_at(int cp_index) const {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,4 +64,0 @@\n-oop Klass::java_mirror_no_keepalive() const {\n-  return _java_mirror.peek();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+inline oop Klass::java_mirror_no_keepalive() const {\n+  return _java_mirror.peek();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,0 +256,6 @@\n+  void set_deprecated() { constMethod()->set_deprecated(); }\n+  bool deprecated() const { return constMethod()->deprecated(); }\n+\n+  void set_deprecated_for_removal() { constMethod()->set_deprecated_for_removal(); }\n+  bool deprecated_for_removal() const { return constMethod()->deprecated_for_removal(); }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -706,3 +706,0 @@\n-  if (CompilerConfig::is_c1_simple_only() && !ProfileInterpreter) {\n-    return no_profile_data;\n-  }\n@@ -1034,3 +1031,0 @@\n-  if (CompilerConfig::is_c1_simple_only() && !ProfileInterpreter) {\n-    return 0;\n-  }\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-    return _header._struct._flags;\n+    return Atomic::load_acquire(&_header._struct._flags);\n@@ -210,2 +210,26 @@\n-  void set_flag_at(u1 flag_number) {\n-    _header._struct._flags |= (u1)(0x1 << flag_number);\n+  bool set_flag_at(u1 flag_number) {\n+    const u1 bit = 1 << flag_number;\n+    u1 compare_value;\n+    do {\n+      compare_value = _header._struct._flags;\n+      if ((compare_value & bit) == bit) {\n+        \/\/ already set.\n+        return false;\n+      }\n+    } while (compare_value != Atomic::cmpxchg(&_header._struct._flags, compare_value, static_cast<u1>(compare_value | bit)));\n+    return true;\n+  }\n+\n+  bool clear_flag_at(u1 flag_number) {\n+    const u1 bit = 1 << flag_number;\n+    u1 compare_value;\n+    u1 exchange_value;\n+    do {\n+      compare_value = _header._struct._flags;\n+      if ((compare_value & bit) == 0) {\n+        \/\/ already cleaed.\n+        return false;\n+      }\n+      exchange_value = compare_value & ~bit;\n+    } while (compare_value != Atomic::cmpxchg(&_header._struct._flags, compare_value, exchange_value));\n+    return true;\n@@ -213,0 +237,1 @@\n+\n@@ -214,1 +239,1 @@\n-    return (_header._struct._flags & (0x1 << flag_number)) != 0;\n+    return (flags() & (1 << flag_number)) != 0;\n@@ -515,2 +540,3 @@\n-      null_seen_flag              = DataLayout::first_flag + 0,\n-      exception_handler_entered_flag     = null_seen_flag + 1,\n+      null_seen_flag                  = DataLayout::first_flag + 0,\n+      exception_handler_entered_flag  = null_seen_flag + 1,\n+      deprecated_method_callsite_flag = exception_handler_entered_flag + 1\n@@ -519,1 +545,1 @@\n-      exception_seen_flag         = exception_handler_entered_flag + 1,\n+    , exception_seen_flag             = deprecated_method_callsite_flag + 1\n@@ -521,1 +547,1 @@\n-      last_bit_data_flag\n+    , last_bit_data_flag\n@@ -544,0 +570,3 @@\n+  bool deprecated_method_call_site() const { return flag_at(deprecated_method_callsite_flag); }\n+  bool set_deprecated_method_call_site() { return data()->set_flag_at(deprecated_method_callsite_flag); }\n+  bool clear_deprecated_method_call_site() { return data()->clear_flag_at(deprecated_method_callsite_flag); }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -287,73 +287,0 @@\n-  \/\/ Try to improve the type of the CastII if we recognize a CmpI\/If pattern.\n-  \/\/\n-  \/\/ in1  in2\n-  \/\/  |    |\n-  \/\/  +--- | --+\n-  \/\/  |    |   |\n-  \/\/ CmpINode  |\n-  \/\/    |      |\n-  \/\/ BoolNode  |\n-  \/\/    |      |\n-  \/\/  IfNode   |\n-  \/\/    |      |\n-  \/\/  IfProj   |\n-  \/\/    |      |\n-  \/\/   CastIINode\n-  \/\/\n-  if (carry_dependency()) {\n-    if (in(0) != nullptr && in(0)->in(0) != nullptr && in(0)->in(0)->is_If()) {\n-      assert(in(0)->is_IfFalse() || in(0)->is_IfTrue(), \"should be If proj\");\n-      Node* proj = in(0);\n-      if (proj->in(0)->in(1)->is_Bool()) {\n-        Node* b = proj->in(0)->in(1);\n-        if (b->in(1)->Opcode() == Op_CmpI) {\n-          Node* cmp = b->in(1);\n-          if (cmp->in(1) == in(1) && phase->type(cmp->in(2))->isa_int()) {\n-            const TypeInt* in2_t = phase->type(cmp->in(2))->is_int();\n-            const Type* t = TypeInt::INT;\n-            BoolTest test = b->as_Bool()->_test;\n-            if (proj->is_IfFalse()) {\n-              test = test.negate();\n-            }\n-            BoolTest::mask m = test._test;\n-            jlong lo_long = min_jint;\n-            jlong hi_long = max_jint;\n-            if (m == BoolTest::le || m == BoolTest::lt) {\n-              hi_long = in2_t->_hi;\n-              if (m == BoolTest::lt) {\n-                hi_long -= 1;\n-              }\n-            } else if (m == BoolTest::ge || m == BoolTest::gt) {\n-              lo_long = in2_t->_lo;\n-              if (m == BoolTest::gt) {\n-                lo_long += 1;\n-              }\n-            } else if (m == BoolTest::eq) {\n-              lo_long = in2_t->_lo;\n-              hi_long = in2_t->_hi;\n-            } else if (m == BoolTest::ne) {\n-              \/\/ can't do any better\n-            } else {\n-              stringStream ss;\n-              test.dump_on(&ss);\n-              fatal(\"unexpected comparison %s\", ss.freeze());\n-            }\n-            int lo_int = (int)lo_long;\n-            int hi_int = (int)hi_long;\n-\n-            if (lo_long != (jlong)lo_int) {\n-              lo_int = min_jint;\n-            }\n-            if (hi_long != (jlong)hi_int) {\n-              hi_int = max_jint;\n-            }\n-\n-            t = TypeInt::make(lo_int, hi_int, Type::WidenMax);\n-\n-            res = res->filter_speculative(t);\n-            return res;\n-          }\n-        }\n-      }\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":0,"deletions":73,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-\/\/ We also use NoSafepointVerifier to block potential safepoints.\n+\/\/ We can't have safepoints in this code.\n@@ -106,2 +106,1 @@\n-  if (thread->has_async_exception_condition()) {return (result_type)0;} \\\n-  NoSafepointVerifier nsv;\n+  if (thread->has_async_exception_condition()) {return (result_type)0;}\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2136,1 +2136,1 @@\n-  const char* p = Arguments::get_default_shared_archive_path();\n+  const char* p = CDSConfig::default_archive_path();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,5 +104,0 @@\n-bool   Arguments::_module_patching_disables_cds = false;\n-\n-char*  Arguments::_default_shared_archive_path  = nullptr;\n-char*  Arguments::SharedArchivePath             = nullptr;\n-char*  Arguments::SharedDynamicArchivePath      = nullptr;\n@@ -1268,13 +1263,1 @@\n-#if INCLUDE_CDS\n-  if (is_internal_module_property(key)) {\n-    MetaspaceShared::disable_optimized_module_handling();\n-    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n-  }\n-  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n-      strcmp(key, \"jdk.module.validation\") == 0 ||\n-      strcmp(key, \"java.system.class.loader\") == 0) {\n-    CDSConfig::disable_loading_full_module_graph();\n-    CDSConfig::disable_dumping_full_module_graph();\n-    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n-  }\n-#endif\n+  CDSConfig::check_system_property(key, value);\n@@ -1334,66 +1317,0 @@\n-#if INCLUDE_CDS\n-const char* unsupported_properties[] = { \"jdk.module.limitmods\",\n-                                         \"jdk.module.upgrade.path\"};\n-const char* unsupported_options[] = { \"--limit-modules\",\n-                                      \"--upgrade-module-path\"};\n-void Arguments::check_unsupported_dumping_properties() {\n-  assert(CDSConfig::is_dumping_archive(),\n-         \"this function is only used with CDS dump time\");\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n-  \/\/ If a vm option is found in the unsupported_options array, vm will exit with an error message.\n-  SystemProperty* sp = system_properties();\n-  while (sp != nullptr) {\n-    for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-      if (strcmp(sp->key(), unsupported_properties[i]) == 0) {\n-        vm_exit_during_initialization(\n-          \"Cannot use the following option when dumping the shared archive\", unsupported_options[i]);\n-      }\n-    }\n-    sp = sp->next();\n-  }\n-\n-  if (_module_patching_disables_cds) {\n-    vm_exit_during_initialization(\n-            \"Cannot use the following option when dumping the shared archive\", \"--patch-module\");\n-  }\n-\n-  \/\/ Check for an exploded module build in use with -Xshare:dump.\n-  if (!has_jimage()) {\n-    vm_exit_during_initialization(\"Dumping the shared archive is not supported with an exploded module build\");\n-  }\n-}\n-\n-bool Arguments::check_unsupported_cds_runtime_properties() {\n-  assert(UseSharedSpaces, \"this function is only used with -Xshare:{on,auto}\");\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n-  if (ArchiveClassesAtExit != nullptr) {\n-    \/\/ dynamic dumping, just return false for now.\n-    \/\/ check_unsupported_dumping_properties() will be called later to check the same set of\n-    \/\/ properties, and will exit the VM with the correct error message if the unsupported properties\n-    \/\/ are used.\n-    return false;\n-  }\n-  for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-    if (get_property(unsupported_properties[i]) != nullptr) {\n-      if (RequireSharedSpaces) {\n-        warning(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      } else {\n-        log_info(cds)(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      }\n-      return true;\n-    }\n-  }\n-\n-  if (_module_patching_disables_cds) {\n-    if (RequireSharedSpaces) {\n-      warning(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n-    } else {\n-      log_info(cds)(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n-    }\n-    return true;\n-  }\n-\n-  return false;\n-}\n-#endif\n-\n@@ -1449,1 +1366,1 @@\n-static void no_shared_spaces(const char* message) {\n+void Arguments::no_shared_spaces(const char* message) {\n@@ -2995,5 +2912,0 @@\n-static bool _java_base_module_patching_disables_cds = false;\n-bool Arguments::patch_mod_javabase() {\n-  return _java_base_module_patching_disables_cds;\n-}\n-\n@@ -3002,1 +2914,1 @@\n-    _module_patching_disables_cds = true;\n+    CDSConfig::set_module_patching_disables_cds();\n@@ -3004,1 +2916,1 @@\n-      _java_base_module_patching_disables_cds = true;\n+      CDSConfig::set_java_base_module_patching_disables_cds();\n@@ -3152,25 +3064,1 @@\n-#if INCLUDE_CDS\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    if (!mode_flag_cmd_line) {\n-      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n-      \/\/\n-      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n-      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n-      set_mode_flags(_int);\n-    } else if (_mode == _comp) {\n-      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n-      \/\/ Java code, so there's not much benefit in running -Xcomp.\n-      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n-      set_mode_flags(_mixed);\n-    }\n-\n-    \/\/ String deduplication may cause CDS to iterate the strings in different order from one\n-    \/\/ run to another which resulting in non-determinstic CDS archives.\n-    \/\/ Disable UseStringDeduplication while dumping CDS archive.\n-    UseStringDeduplication = false;\n-  }\n-\n-  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n-  if (ArchiveClassesAtExit != nullptr && RecordDynamicDumpInfo) {\n-    jio_fprintf(defaultStream::output_stream(),\n-                \"-XX:+RecordDynamicDumpInfo cannot be used with -XX:ArchiveClassesAtExit.\\n\");\n+  if (!CDSConfig::check_vm_args_consistency(mode_flag_cmd_line)) {\n@@ -3180,33 +3068,0 @@\n-  if (ArchiveClassesAtExit == nullptr && !RecordDynamicDumpInfo) {\n-    CDSConfig::disable_dumping_dynamic_archive();\n-  } else {\n-    CDSConfig::enable_dumping_dynamic_archive();\n-  }\n-\n-  if (AutoCreateSharedArchive) {\n-    if (SharedArchiveFile == nullptr) {\n-      log_warning(cds)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n-      return JNI_ERR;\n-    }\n-    if (ArchiveClassesAtExit != nullptr) {\n-      log_warning(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n-      return JNI_ERR;\n-    }\n-  }\n-\n-  if (UseSharedSpaces && patch_mod_javabase() && _module_patching_disables_cds) {\n-    no_shared_spaces(\"CDS is disabled when \" JAVA_BASE_NAME \" module is patched.\");\n-  }\n-  if (UseSharedSpaces && check_unsupported_cds_runtime_properties()) {\n-    UseSharedSpaces = false;\n-  }\n-\n-  if (CDSConfig::is_dumping_archive()) {\n-    \/\/ Always verify non-system classes during CDS dump\n-    if (!BytecodeVerificationRemote) {\n-      BytecodeVerificationRemote = true;\n-      log_info(cds)(\"All non-system classes will be verified (-Xverify:remote) during CDS dump time.\");\n-    }\n-  }\n-#endif\n-\n@@ -3480,185 +3335,0 @@\n-void Arguments::set_shared_spaces_flags_and_archive_paths() {\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    if (RequireSharedSpaces) {\n-      warning(\"Cannot dump shared archive while using shared archive\");\n-    }\n-    UseSharedSpaces = false;\n-  }\n-#if INCLUDE_CDS\n-  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n-  \/\/ This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.\n-  \/\/\n-  \/\/ UseSharedSpaces may be disabled if -XX:SharedArchiveFile is invalid.\n-  if (CDSConfig::is_dumping_static_archive() || UseSharedSpaces) {\n-    init_shared_archive_paths();\n-  }\n-#endif  \/\/ INCLUDE_CDS\n-}\n-\n-#if INCLUDE_CDS\n-\/\/ Sharing support\n-\/\/ Construct the path to the archive\n-char* Arguments::get_default_shared_archive_path() {\n-  if (_default_shared_archive_path == nullptr) {\n-    char jvm_path[JVM_MAXPATHLEN];\n-    os::jvm_path(jvm_path, sizeof(jvm_path));\n-    char *end = strrchr(jvm_path, *os::file_separator());\n-    if (end != nullptr) *end = '\\0';\n-    size_t jvm_path_len = strlen(jvm_path);\n-    size_t file_sep_len = strlen(os::file_separator());\n-    const size_t len = jvm_path_len + file_sep_len + strlen(\"classes_nocoops_valhalla.jsa\") + 1;\n-    _default_shared_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n-    LP64_ONLY(bool nocoops = !UseCompressedOops);\n-    NOT_LP64(bool nocoops = false);\n-    bool valhalla = CDSConfig::is_valhalla_preview();\n-    jio_snprintf(_default_shared_archive_path, len, \"%s%sclasses%s%s.jsa\",\n-                jvm_path, os::file_separator(),\n-                 nocoops ? \"_nocoops\" : \"\",\n-                 valhalla ? \"_valhalla\" : \"\");\n-  }\n-  return _default_shared_archive_path;\n-}\n-\n-int Arguments::num_archives(const char* archive_path) {\n-  if (archive_path == nullptr) {\n-    return 0;\n-  }\n-  int npaths = 1;\n-  char* p = (char*)archive_path;\n-  while (*p != '\\0') {\n-    if (*p == os::path_separator()[0]) {\n-      npaths++;\n-    }\n-    p++;\n-  }\n-  return npaths;\n-}\n-\n-void Arguments::extract_shared_archive_paths(const char* archive_path,\n-                                         char** base_archive_path,\n-                                         char** top_archive_path) {\n-  char* begin_ptr = (char*)archive_path;\n-  char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);\n-  if (end_ptr == nullptr || end_ptr == begin_ptr) {\n-    vm_exit_during_initialization(\"Base archive was not specified\", archive_path);\n-  }\n-  size_t len = end_ptr - begin_ptr;\n-  char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n-  strncpy(cur_path, begin_ptr, len);\n-  cur_path[len] = '\\0';\n-  *base_archive_path = cur_path;\n-\n-  begin_ptr = ++end_ptr;\n-  if (*begin_ptr == '\\0') {\n-    vm_exit_during_initialization(\"Top archive was not specified\", archive_path);\n-  }\n-  end_ptr = strchr(begin_ptr, '\\0');\n-  assert(end_ptr != nullptr, \"sanity\");\n-  len = end_ptr - begin_ptr;\n-  cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n-  strncpy(cur_path, begin_ptr, len + 1);\n-  *top_archive_path = cur_path;\n-}\n-\n-void Arguments::init_shared_archive_paths() {\n-  if (ArchiveClassesAtExit != nullptr) {\n-    assert(!RecordDynamicDumpInfo, \"already checked\");\n-    if (CDSConfig::is_dumping_static_archive()) {\n-      vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump\");\n-    }\n-    check_unsupported_dumping_properties();\n-\n-    if (os::same_files(get_default_shared_archive_path(), ArchiveClassesAtExit)) {\n-      vm_exit_during_initialization(\n-        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", get_default_shared_archive_path());\n-    }\n-  }\n-\n-  if (SharedArchiveFile == nullptr) {\n-    SharedArchivePath = get_default_shared_archive_path();\n-  } else {\n-    int archives = num_archives(SharedArchiveFile);\n-    assert(archives > 0, \"must be\");\n-\n-    if (CDSConfig::is_dumping_archive() && archives > 1) {\n-      vm_exit_during_initialization(\n-        \"Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping\");\n-    }\n-\n-    if (CDSConfig::is_dumping_static_archive()) {\n-      assert(archives == 1, \"must be\");\n-      \/\/ Static dump is simple: only one archive is allowed in SharedArchiveFile. This file\n-      \/\/ will be overwritten no matter regardless of its contents\n-      SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);\n-    } else {\n-      \/\/ SharedArchiveFile may specify one or two files. In case (c), the path for base.jsa\n-      \/\/ is read from top.jsa\n-      \/\/    (a) 1 file:  -XX:SharedArchiveFile=base.jsa\n-      \/\/    (b) 2 files: -XX:SharedArchiveFile=base.jsa:top.jsa\n-      \/\/    (c) 2 files: -XX:SharedArchiveFile=top.jsa\n-      \/\/\n-      \/\/ However, if either RecordDynamicDumpInfo or ArchiveClassesAtExit is used, we do not\n-      \/\/ allow cases (b) and (c). Case (b) is already checked above.\n-\n-      if (archives > 2) {\n-        vm_exit_during_initialization(\n-          \"Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option\");\n-      }\n-      if (archives == 1) {\n-        char* base_archive_path = nullptr;\n-        bool success =\n-          FileMapInfo::get_base_archive_name_from_header(SharedArchiveFile, &base_archive_path);\n-        if (!success) {\n-          \/\/ If +AutoCreateSharedArchive and the specified shared archive does not exist,\n-          \/\/ regenerate the dynamic archive base on default archive.\n-          if (AutoCreateSharedArchive && !os::file_exists(SharedArchiveFile)) {\n-            CDSConfig::enable_dumping_dynamic_archive();\n-            ArchiveClassesAtExit = const_cast<char *>(SharedArchiveFile);\n-            SharedArchivePath = get_default_shared_archive_path();\n-            SharedArchiveFile = nullptr;\n-          } else {\n-            if (AutoCreateSharedArchive) {\n-              warning(\"-XX:+AutoCreateSharedArchive is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n-              AutoCreateSharedArchive = false;\n-            }\n-            no_shared_spaces(\"invalid archive\");\n-          }\n-        } else if (base_archive_path == nullptr) {\n-          \/\/ User has specified a single archive, which is a static archive.\n-          SharedArchivePath = const_cast<char *>(SharedArchiveFile);\n-        } else {\n-          \/\/ User has specified a single archive, which is a dynamic archive.\n-          SharedDynamicArchivePath = const_cast<char *>(SharedArchiveFile);\n-          SharedArchivePath = base_archive_path; \/\/ has been c-heap allocated.\n-        }\n-      } else {\n-        extract_shared_archive_paths((const char*)SharedArchiveFile,\n-                                      &SharedArchivePath, &SharedDynamicArchivePath);\n-        if (SharedArchivePath == nullptr) {\n-          assert(SharedDynamicArchivePath == nullptr, \"must be\");\n-          no_shared_spaces(\"invalid archive\");\n-        }\n-      }\n-\n-      if (SharedDynamicArchivePath != nullptr) {\n-        \/\/ Check for case (c)\n-        if (RecordDynamicDumpInfo) {\n-          vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n-                                        SharedArchiveFile);\n-        }\n-        if (ArchiveClassesAtExit != nullptr) {\n-          vm_exit_during_initialization(\"-XX:ArchiveClassesAtExit is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile\",\n-                                        SharedArchiveFile);\n-        }\n-      }\n-\n-      if (ArchiveClassesAtExit != nullptr && os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {\n-          vm_exit_during_initialization(\n-            \"Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit\",\n-            SharedArchiveFile);\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ INCLUDE_CDS\n-\n@@ -4109,1 +3779,1 @@\n-  set_shared_spaces_flags_and_archive_paths();\n+  CDSConfig::initialize();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":336,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  static void set_mode_flags(Mode mode);\n@@ -257,2 +256,0 @@\n-  static bool _module_patching_disables_cds;\n-\n@@ -270,1 +267,0 @@\n-  static void set_shared_spaces_flags_and_archive_paths();\n@@ -369,7 +365,0 @@\n-\n-  static char*  _default_shared_archive_path;\n-  static char*  SharedArchivePath;\n-  static char*  SharedDynamicArchivePath;\n-  static void extract_shared_archive_paths(const char* archive_path,\n-                                         char** base_archive_path,\n-                                         char** top_archive_path) NOT_CDS_RETURN;\n@@ -379,1 +368,0 @@\n-  static int num_archives(const char* archive_path) NOT_CDS_RETURN_(0);\n@@ -447,2 +435,1 @@\n-  static const char* GetSharedArchivePath() { return SharedArchivePath; }\n-  static const char* GetSharedDynamicArchivePath() { return SharedDynamicArchivePath; }\n+  static void no_shared_spaces(const char* message);\n@@ -487,2 +474,0 @@\n-  static bool patch_mod_javabase();\n-  static bool module_patching_disables_cds() { return _module_patching_disables_cds; }\n@@ -510,3 +495,0 @@\n-  static char* get_default_shared_archive_path() NOT_CDS_RETURN_(nullptr);\n-  static void  init_shared_archive_paths() NOT_CDS_RETURN;\n-\n@@ -515,0 +497,1 @@\n+  static void set_mode_flags(Mode mode);\n@@ -526,4 +509,0 @@\n-  static void check_unsupported_dumping_properties() NOT_CDS_RETURN;\n-\n-  static bool check_unsupported_cds_runtime_properties() NOT_CDS_RETURN0;\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -89,0 +89,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -1391,0 +1394,1 @@\n+  JFR_ONLY(bool patched_caller = false;)\n@@ -1420,0 +1424,1 @@\n+          JFR_ONLY(patched_caller = true;)\n@@ -1432,1 +1437,4 @@\n-        if (ssc->is_clean()) ssc->set(static_call_info);\n+        if (ssc->is_clean()) {\n+          ssc->set(static_call_info);\n+          JFR_ONLY(patched_caller = true;)\n+        }\n@@ -1436,0 +1444,1 @@\n+  JFR_ONLY(if (patched_caller) Jfr::on_backpatching(callee_method(), THREAD);)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+class ObjectMonitorDeflationLogging;\n+\n@@ -87,0 +89,11 @@\n+class ObjectMonitorDeflationSafepointer : public StackObj {\n+  JavaThread* const                    _current;\n+  ObjectMonitorDeflationLogging* const _log;\n+\n+public:\n+  ObjectMonitorDeflationSafepointer(JavaThread* current, ObjectMonitorDeflationLogging* log)\n+    : _current(current), _log(log) {}\n+\n+  void block_for_safepoint(const char* op_name, const char* count_name, size_t counter);\n+};\n+\n@@ -89,4 +102,3 @@\n-size_t MonitorList::unlink_deflated(Thread* current, LogStream* ls,\n-                                    elapsedTimer* timer_p,\n-                                    size_t deflated_count,\n-                                    GrowableArray<ObjectMonitor*>* unlinked_list) {\n+size_t MonitorList::unlink_deflated(size_t deflated_count,\n+                                    GrowableArray<ObjectMonitor*>* unlinked_list,\n+                                    ObjectMonitorDeflationSafepointer* safepointer) {\n@@ -97,1 +109,0 @@\n-  \/\/ The in-use list head can be null during the final audit.\n@@ -157,6 +168,2 @@\n-    if (current->is_Java_thread()) {\n-      \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n-      ObjectSynchronizer::chk_for_block_req(JavaThread::cast(current), \"unlinking\",\n-                                            \"unlinked_count\", unlinked_count,\n-                                            ls, timer_p);\n-    }\n+    \/\/ Must check for a safepoint\/handshake and honor it.\n+    safepointer->block_for_safepoint(\"unlinking\", \"unlinked_count\", unlinked_count);\n@@ -1150,1 +1157,0 @@\n-      assert(monitor->object_peek() != nullptr, \"Owned monitors should not have a dead object\");\n@@ -1576,29 +1582,0 @@\n-void ObjectSynchronizer::chk_for_block_req(JavaThread* current, const char* op_name,\n-                                           const char* cnt_name, size_t cnt,\n-                                           LogStream* ls, elapsedTimer* timer_p) {\n-  if (!SafepointMechanism::should_process(current)) {\n-    return;\n-  }\n-\n-  \/\/ A safepoint\/handshake has started.\n-  if (ls != nullptr) {\n-    timer_p->stop();\n-    ls->print_cr(\"pausing %s: %s=\" SIZE_FORMAT \", in_use_list stats: ceiling=\"\n-                 SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                 op_name, cnt_name, cnt, in_use_list_ceiling(),\n-                 _in_use_list.count(), _in_use_list.max());\n-  }\n-\n-  {\n-    \/\/ Honor block request.\n-    ThreadBlockInVM tbivm(current);\n-  }\n-\n-  if (ls != nullptr) {\n-    ls->print_cr(\"resuming %s: in_use_list stats: ceiling=\" SIZE_FORMAT\n-                 \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT, op_name,\n-                 in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-    timer_p->start();\n-  }\n-}\n-\n@@ -1608,2 +1585,1 @@\n-size_t ObjectSynchronizer::deflate_monitor_list(Thread* current, LogStream* ls,\n-                                                elapsedTimer* timer_p) {\n+size_t ObjectSynchronizer::deflate_monitor_list(ObjectMonitorDeflationSafepointer* safepointer) {\n@@ -1622,5 +1598,2 @@\n-    if (current->is_Java_thread()) {\n-      \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n-      chk_for_block_req(JavaThread::cast(current), \"deflation\", \"deflated_count\",\n-                        deflated_count, ls, timer_p);\n-    }\n+    \/\/ Must check for a safepoint\/handshake and honor it.\n+    safepointer->block_for_safepoint(\"deflation\", \"deflated_count\", deflated_count);\n@@ -1652,2 +1625,2 @@\n-static size_t delete_monitors(JavaThread* current, GrowableArray<ObjectMonitor*>* delete_list,\n-                              LogStream* ls, elapsedTimer* timer_p) {\n+static size_t delete_monitors(GrowableArray<ObjectMonitor*>* delete_list,\n+                              ObjectMonitorDeflationSafepointer* safepointer) {\n@@ -1660,2 +1633,1 @@\n-    ObjectSynchronizer::chk_for_block_req(current, \"deletion\", \"deleted_count\",\n-                                          deleted_count, ls, timer_p);\n+    safepointer->block_for_safepoint(\"deletion\", \"deleted_count\", deleted_count);\n@@ -1666,8 +1638,66 @@\n-\/\/ This function is called by the MonitorDeflationThread to deflate\n-\/\/ ObjectMonitors.\n-size_t ObjectSynchronizer::deflate_idle_monitors() {\n-  Thread* current = Thread::current();\n-  if (current->is_Java_thread()) {\n-    \/\/ The async deflation request has been processed.\n-    _last_async_deflation_time_ns = os::javaTimeNanos();\n-    set_is_async_deflation_requested(false);\n+class ObjectMonitorDeflationLogging: public StackObj {\n+  LogStreamHandle(Debug, monitorinflation) _debug;\n+  LogStreamHandle(Info, monitorinflation)  _info;\n+  LogStream*                               _stream;\n+  elapsedTimer                             _timer;\n+\n+  size_t ceiling() const { return ObjectSynchronizer::in_use_list_ceiling(); }\n+  size_t count() const   { return ObjectSynchronizer::_in_use_list.count(); }\n+  size_t max() const     { return ObjectSynchronizer::_in_use_list.max(); }\n+\n+public:\n+  ObjectMonitorDeflationLogging()\n+    : _debug(), _info(), _stream(nullptr) {\n+    if (_debug.is_enabled()) {\n+      _stream = &_debug;\n+    } else if (_info.is_enabled()) {\n+      _stream = &_info;\n+    }\n+  }\n+\n+  void begin() {\n+    if (_stream != nullptr) {\n+      _stream->print_cr(\"begin deflating: in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n+                        ceiling(), count(), max());\n+      _timer.start();\n+    }\n+  }\n+\n+  void before_handshake(size_t unlinked_count) {\n+    if (_stream != nullptr) {\n+      _timer.stop();\n+      _stream->print_cr(\"before handshaking: unlinked_count=\" SIZE_FORMAT\n+                        \", in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\"\n+                        SIZE_FORMAT \", max=\" SIZE_FORMAT,\n+                        unlinked_count, ceiling(), count(), max());\n+    }\n+  }\n+\n+  void after_handshake() {\n+    if (_stream != nullptr) {\n+      _stream->print_cr(\"after handshaking: in_use_list stats: ceiling=\"\n+                        SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n+                        ceiling(), count(), max());\n+      _timer.start();\n+    }\n+  }\n+\n+  void end(size_t deflated_count, size_t unlinked_count) {\n+    if (_stream != nullptr) {\n+      _timer.stop();\n+      if (deflated_count != 0 || unlinked_count != 0 || _debug.is_enabled()) {\n+        _stream->print_cr(\"deflated_count=\" SIZE_FORMAT \", {unlinked,deleted}_count=\" SIZE_FORMAT \" monitors in %3.7f secs\",\n+                          deflated_count, unlinked_count, _timer.seconds());\n+      }\n+      _stream->print_cr(\"end deflating: in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n+                        ceiling(), count(), max());\n+    }\n+  }\n+\n+  void before_block_for_safepoint(const char* op_name, const char* cnt_name, size_t cnt) {\n+    if (_stream != nullptr) {\n+      _timer.stop();\n+      _stream->print_cr(\"pausing %s: %s=\" SIZE_FORMAT \", in_use_list stats: ceiling=\"\n+                        SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n+                        op_name, cnt_name, cnt, ceiling(), count(), max());\n+    }\n@@ -1676,7 +1706,7 @@\n-  LogStreamHandle(Debug, monitorinflation) lsh_debug;\n-  LogStreamHandle(Info, monitorinflation) lsh_info;\n-  LogStream* ls = nullptr;\n-  if (log_is_enabled(Debug, monitorinflation)) {\n-    ls = &lsh_debug;\n-  } else if (log_is_enabled(Info, monitorinflation)) {\n-    ls = &lsh_info;\n+  void after_block_for_safepoint(const char* op_name) {\n+    if (_stream != nullptr) {\n+      _stream->print_cr(\"resuming %s: in_use_list stats: ceiling=\" SIZE_FORMAT\n+                        \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT, op_name,\n+                        ceiling(), count(), max());\n+      _timer.start();\n+    }\n@@ -1684,0 +1714,1 @@\n+};\n@@ -1685,5 +1716,3 @@\n-  elapsedTimer timer;\n-  if (ls != nullptr) {\n-    ls->print_cr(\"begin deflating: in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                 in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-    timer.start();\n+void ObjectMonitorDeflationSafepointer::block_for_safepoint(const char* op_name, const char* count_name, size_t counter) {\n+  if (!SafepointMechanism::should_process(_current)) {\n+    return;\n@@ -1692,0 +1721,26 @@\n+  \/\/ A safepoint\/handshake has started.\n+  _log->before_block_for_safepoint(op_name, count_name, counter);\n+\n+  {\n+    \/\/ Honor block request.\n+    ThreadBlockInVM tbivm(_current);\n+  }\n+\n+  _log->after_block_for_safepoint(op_name);\n+}\n+\n+\/\/ This function is called by the MonitorDeflationThread to deflate\n+\/\/ ObjectMonitors.\n+size_t ObjectSynchronizer::deflate_idle_monitors() {\n+  JavaThread* current = JavaThread::current();\n+  assert(current->is_monitor_deflation_thread(), \"The only monitor deflater\");\n+\n+  \/\/ The async deflation request has been processed.\n+  _last_async_deflation_time_ns = os::javaTimeNanos();\n+  set_is_async_deflation_requested(false);\n+\n+  ObjectMonitorDeflationLogging log;\n+  ObjectMonitorDeflationSafepointer safepointer(current, &log);\n+\n+  log.begin();\n+\n@@ -1693,1 +1748,3 @@\n-  size_t deflated_count = deflate_monitor_list(current, ls, &timer);\n+  size_t deflated_count = deflate_monitor_list(&safepointer);\n+\n+  \/\/ Unlink the deflated ObjectMonitors from the in-use list.\n@@ -1697,4 +1754,1 @@\n-    \/\/ There are ObjectMonitors that have been deflated.\n-\n-    \/\/ Unlink deflated ObjectMonitors from the in-use list.\n-    ResourceMark rm;\n+    ResourceMark rm(current);\n@@ -1702,10 +1756,1 @@\n-    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, deflated_count, &delete_list);\n-    if (current->is_monitor_deflation_thread()) {\n-      if (ls != nullptr) {\n-        timer.stop();\n-        ls->print_cr(\"before handshaking: unlinked_count=\" SIZE_FORMAT\n-                     \", in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\"\n-                     SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     unlinked_count, in_use_list_ceiling(),\n-                     _in_use_list.count(), _in_use_list.max());\n-      }\n+    unlinked_count = _in_use_list.unlink_deflated(deflated_count, &delete_list, &safepointer);\n@@ -1713,21 +1758,13 @@\n-      \/\/ A JavaThread needs to handshake in order to safely free the\n-      \/\/ ObjectMonitors that were deflated in this cycle.\n-      HandshakeForDeflation hfd_hc;\n-      Handshake::execute(&hfd_hc);\n-      \/\/ Also, we sync and desync GC threads around the handshake, so that they can\n-      \/\/ safely read the mark-word and look-through to the object-monitor, without\n-      \/\/ being afraid that the object-monitor is going away.\n-      VM_RendezvousGCThreads sync_gc;\n-      VMThread::execute(&sync_gc);\n-\n-      if (ls != nullptr) {\n-        ls->print_cr(\"after handshaking: in_use_list stats: ceiling=\"\n-                     SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-        timer.start();\n-      }\n-    } else {\n-      \/\/ This is not a monitor deflation thread.\n-      \/\/ No handshake or rendezvous is needed when we are already at safepoint.\n-      assert_at_safepoint();\n-    }\n+    log.before_handshake(unlinked_count);\n+\n+    \/\/ A JavaThread needs to handshake in order to safely free the\n+    \/\/ ObjectMonitors that were deflated in this cycle.\n+    HandshakeForDeflation hfd_hc;\n+    Handshake::execute(&hfd_hc);\n+    \/\/ Also, we sync and desync GC threads around the handshake, so that they can\n+    \/\/ safely read the mark-word and look-through to the object-monitor, without\n+    \/\/ being afraid that the object-monitor is going away.\n+    VM_RendezvousGCThreads sync_gc;\n+    VMThread::execute(&sync_gc);\n+\n+    log.after_handshake();\n@@ -1737,1 +1774,3 @@\n-    deleted_count = delete_monitors(JavaThread::cast(current), &delete_list, ls, &timer);\n+\n+    \/\/ Delete the unlinked ObjectMonitors.\n+    deleted_count = delete_monitors(&delete_list, &safepointer);\n@@ -1741,9 +1780,1 @@\n-  if (ls != nullptr) {\n-    timer.stop();\n-    if (deflated_count != 0 || unlinked_count != 0 || log_is_enabled(Debug, monitorinflation)) {\n-      ls->print_cr(\"deflated_count=\" SIZE_FORMAT \", {unlinked,deleted}_count=\" SIZE_FORMAT \" monitors in %3.7f secs\",\n-                   deflated_count, unlinked_count, timer.seconds());\n-    }\n-    ls->print_cr(\"end deflating: in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                 in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-  }\n+  log.end(deflated_count, unlinked_count);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":149,"deletions":118,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -350,0 +350,6 @@\n+    if (monitor->object_peek() == nullptr) {\n+      \/\/ JNI code doesn't necessarily keep the monitor object\n+      \/\/ alive. Filter out monitors with dead objects.\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -889,2 +889,2 @@\n-  static oop mask_dormant_archived_object(oop o) {\n-    if (o != nullptr && o->klass()->java_mirror() == nullptr) {\n+  static oop mask_dormant_archived_object(oop o, oop ref_obj) {\n+    if (o != nullptr && o->klass()->java_mirror_no_keepalive() == nullptr) {\n@@ -893,0 +893,1 @@\n+      report_dormant_archived_object(o, ref_obj);\n@@ -908,0 +909,14 @@\n+\n+  static void report_dormant_archived_object(oop o, oop ref_obj) {\n+    if (log_is_enabled(Trace, cds, heap)) {\n+      ResourceMark rm;\n+      if (ref_obj != nullptr) {\n+        log_trace(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n+                  p2i(o), o->klass()->external_name(),\n+                  p2i(ref_obj), ref_obj->klass()->external_name());\n+      } else {\n+        log_trace(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\",\n+                  p2i(o), o->klass()->external_name());\n+      }\n+    }\n+  }\n@@ -1108,7 +1123,1 @@\n-      if (o != nullptr && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == nullptr) {\n-        ResourceMark rm;\n-        log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n-                             p2i(o), o->klass()->external_name(),\n-                             p2i(obj), obj->klass()->external_name());\n-      }\n-      o = mask_dormant_archived_object(o);\n+      o = mask_dormant_archived_object(o, obj);\n@@ -1511,7 +1520,1 @@\n-    if (o != nullptr && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == nullptr) {\n-      ResourceMark rm;\n-      log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n-                           p2i(o), o->klass()->external_name(),\n-                           p2i(array), array->klass()->external_name());\n-    }\n-    o = mask_dormant_archived_object(o);\n+    o = mask_dormant_archived_object(o, array);\n@@ -2389,2 +2392,1 @@\n-  if (DumperSupport::mask_dormant_archived_object(o) == nullptr) {\n-    log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\", p2i(o), o->klass()->external_name());\n+  if (DumperSupport::mask_dormant_archived_object(o, nullptr) == nullptr) {\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-  #define DEFAULT_CACHE_LINE_SIZE 64\n+#error \"Platform should define DEFAULT_CACHE_LINE_SIZE\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,10 +194,1 @@\n- * <h2><a id=unnamedClasses>Unnamed Classes<\/a><\/h2>\n- *\n- * A {@code class} file representing an {@linkplain #isUnnamedClass unnamed class}\n- * is generated by a Java compiler from a source file for an unnamed class.\n- * The {@code Class} object representing an unnamed class is top-level,\n- * {@linkplain #isSynthetic synthetic}, and {@code final}. While an\n- * unnamed class does <em>not<\/em> have a name in its Java source\n- * form, several of the name-related methods of {@code java.lang.Class}\n- * do return non-null and non-empty results for the {@code Class}\n- * object representing an unnamed class.\n+ * <h2><a id=implicitClasses>Implicitly Declared Classes<\/a><\/h2>\n@@ -206,1 +197,1 @@\n- * unnamed class, say {@code HelloWorld.java}, creates a\n+ * implicitly declared class, say {@code HelloWorld.java}, creates a\n@@ -212,1 +203,1 @@\n- * For the {@code Class} object of an unnamed class {@code\n+ * For the {@code Class} object of an implicitly declared class {@code\n@@ -216,2 +207,2 @@\n- * simple name} of such an unnamed class is the empty string and the\n- * {@linkplain #getCanonicalName canonical name} is {@code null}.\n+ * simple name} of such an implicitly declared class is {@code \"HelloWorld\"} and\n+ * the {@linkplain #getCanonicalName canonical name} is {@code \"HelloWorld\"}.\n@@ -1857,1 +1848,1 @@\n-     * {@linkplain #isAnonymousClass() anonymous} or {@linkplain #isUnnamedClass() unnamed}.\n+     * {@linkplain #isAnonymousClass() anonymous}.\n@@ -1870,3 +1861,0 @@\n-        if (isUnnamedClass()) {\n-            return \"\";\n-        }\n@@ -1922,1 +1910,0 @@\n-     * <li>an {@linkplain #isUnnamedClass() unnamed class}\n@@ -1942,3 +1929,0 @@\n-        if (isUnnamedClass()) {\n-            return null;\n-        }\n@@ -1979,20 +1963,0 @@\n-    \/**\n-     * {@return {@code true} if and only if the underlying class\n-     * is an unnamed class}\n-     *\n-     * @apiNote\n-     * An unnamed class is not an {@linkplain #isAnonymousClass anonymous class}.\n-     *\n-     * @since 21\n-     *\n-     * @jls 7.3 Compilation Units\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n-                    reflective=true)\n-    public boolean isUnnamedClass() {\n-        return PreviewFeatures.isEnabled() && isSynthetic()\n-                                           && isTopLevelClass()\n-                                           && Modifier.isFinal(getModifiers());\n-    }\n-\n-\n@@ -2005,1 +1969,0 @@\n-     * An anonymous class is not an {@linkplain #isUnnamedClass() unnamed class}.\n@@ -2970,0 +2933,15 @@\n+    \/**\n+     * Returns the most specific {@code Method} object of this class, super class or\n+     * interface that have the specified method name and parameter types.\n+     *\n+     * @param publicOnly true if only public methods are examined, otherwise all methods\n+     * @param name the name of the method\n+     * @param parameterTypes the parameter array\n+     * @return the {@code Method} object for the method found from this class matching\n+     * the specified name and parameters, or null if not found\n+     *\/\n+    Method findMethod(boolean publicOnly, String name, Class<?>... parameterTypes) {\n+        PublicMethods.MethodList res = getMethodsRecursive(name, parameterTypes, true, publicOnly);\n+        return res == null ? null : getReflectionFactory().copyMethod(res.getMostSpecific());\n+    }\n+\n@@ -3798,1 +3776,1 @@\n-            \/* includeStatic *\/ true);\n+            \/* includeStatic *\/ true, \/* publicOnly *\/ true);\n@@ -3807,3 +3785,4 @@\n-                                                         boolean includeStatic) {\n-        \/\/ 1st check declared public methods\n-        Method[] methods = privateGetDeclaredMethods(\/* publicOnly *\/ true);\n+                                                         boolean includeStatic,\n+                                                         boolean publicOnly) {\n+        \/\/ 1st check declared methods\n+        Method[] methods = privateGetDeclaredMethods(publicOnly);\n@@ -3823,1 +3802,1 @@\n-            res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);\n+            res = sc.getMethodsRecursive(name, parameterTypes, includeStatic, publicOnly);\n@@ -3830,2 +3809,1 @@\n-                res, intf.getMethodsRecursive(name, parameterTypes,\n-                                              \/* includeStatic *\/ false));\n+                res, intf.getMethodsRecursive(name, parameterTypes, \/* includeStatic *\/ false, publicOnly));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":28,"deletions":50,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2349,0 +2349,3 @@\n+            public Method findMethod(Class<?> klass, boolean publicOnly, String name, Class<?>... parameterTypes) {\n+                return klass.findMethod(publicOnly, name, parameterTypes);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.classfile;\n+\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n+import java.lang.classfile.attribute.CharacterRangeTableAttribute;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.attribute.CompilationIDAttribute;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.attribute.DeprecatedAttribute;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.LineNumberTableAttribute;\n+import java.lang.classfile.attribute.LocalVariableTableAttribute;\n+import java.lang.classfile.attribute.LocalVariableTypeTableAttribute;\n+import java.lang.classfile.attribute.MethodParametersAttribute;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleHashesAttribute;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.attribute.ModuleTargetAttribute;\n+import java.lang.classfile.attribute.NestHostAttribute;\n+import java.lang.classfile.attribute.NestMembersAttribute;\n+import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n+import java.lang.classfile.attribute.PreloadAttribute;\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.classfile.attribute.SourceIDAttribute;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.attribute.SyntheticAttribute;\n+import java.lang.classfile.attribute.UnknownAttribute;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Models a classfile attribute {@jvms 4.7}.  Many, though not all, subtypes of\n+ * {@linkplain Attribute} will implement {@link ClassElement}, {@link\n+ * MethodElement}, {@link FieldElement}, or {@link CodeElement}; attributes that\n+ * are also elements will be delivered when traversing the elements of the\n+ * corresponding model type. Additionally, all attributes are accessible\n+ * directly from the corresponding model type through {@link\n+ * AttributedElement#findAttribute(AttributeMapper)}.\n+ * @param <A> the attribute type\n+ *\n+ * @sealedGraph\n+ * @since 22\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+public sealed interface Attribute<A extends Attribute<A>>\n+        extends WritableElement<A>\n+        permits AnnotationDefaultAttribute, BootstrapMethodsAttribute,\n+                CharacterRangeTableAttribute, CodeAttribute, CompilationIDAttribute,\n+                ConstantValueAttribute, DeprecatedAttribute, EnclosingMethodAttribute,\n+                ExceptionsAttribute, InnerClassesAttribute, LineNumberTableAttribute,\n+                LocalVariableTableAttribute, LocalVariableTypeTableAttribute,\n+                MethodParametersAttribute, ModuleAttribute, ModuleHashesAttribute,\n+                ModuleMainClassAttribute, ModulePackagesAttribute, ModuleResolutionAttribute,\n+                ModuleTargetAttribute, NestHostAttribute, NestMembersAttribute,\n+                PermittedSubclassesAttribute, PreloadAttribute,\n+                RecordAttribute, RuntimeInvisibleAnnotationsAttribute,\n+                RuntimeInvisibleParameterAnnotationsAttribute, RuntimeInvisibleTypeAnnotationsAttribute,\n+                RuntimeVisibleAnnotationsAttribute, RuntimeVisibleParameterAnnotationsAttribute,\n+                RuntimeVisibleTypeAnnotationsAttribute, SignatureAttribute,\n+                SourceDebugExtensionAttribute, SourceFileAttribute, SourceIDAttribute,\n+                StackMapTableAttribute, SyntheticAttribute,\n+                UnknownAttribute, BoundAttribute, UnboundAttribute, CustomAttribute {\n+    \/**\n+     * {@return the name of the attribute}\n+     *\/\n+    String attributeName();\n+\n+    \/**\n+     * {@return the {@link AttributeMapper} associated with this attribute}\n+     *\/\n+    AttributeMapper<A> attributeMapper();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package jdk.internal.classfile;\n+package java.lang.classfile;\n@@ -33,50 +33,50 @@\n-import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n-import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n-import jdk.internal.classfile.attribute.CharacterRangeInfo;\n-import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n-import jdk.internal.classfile.attribute.CodeAttribute;\n-import jdk.internal.classfile.attribute.CompilationIDAttribute;\n-import jdk.internal.classfile.attribute.ConstantValueAttribute;\n-import jdk.internal.classfile.attribute.DeprecatedAttribute;\n-import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n-import jdk.internal.classfile.attribute.ExceptionsAttribute;\n-import jdk.internal.classfile.attribute.InnerClassInfo;\n-import jdk.internal.classfile.attribute.InnerClassesAttribute;\n-import jdk.internal.classfile.attribute.LineNumberInfo;\n-import jdk.internal.classfile.attribute.LineNumberTableAttribute;\n-import jdk.internal.classfile.attribute.LocalVariableInfo;\n-import jdk.internal.classfile.attribute.LocalVariableTableAttribute;\n-import jdk.internal.classfile.attribute.LocalVariableTypeInfo;\n-import jdk.internal.classfile.attribute.LocalVariableTypeTableAttribute;\n-import jdk.internal.classfile.attribute.MethodParameterInfo;\n-import jdk.internal.classfile.attribute.MethodParametersAttribute;\n-import jdk.internal.classfile.attribute.ModuleAttribute;\n-import jdk.internal.classfile.attribute.ModuleExportInfo;\n-import jdk.internal.classfile.attribute.ModuleHashInfo;\n-import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n-import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n-import jdk.internal.classfile.attribute.ModuleOpenInfo;\n-import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n-import jdk.internal.classfile.attribute.ModuleProvideInfo;\n-import jdk.internal.classfile.attribute.ModuleRequireInfo;\n-import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n-import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n-import jdk.internal.classfile.attribute.NestHostAttribute;\n-import jdk.internal.classfile.attribute.NestMembersAttribute;\n-import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n-import jdk.internal.classfile.attribute.PreloadAttribute;\n-import jdk.internal.classfile.attribute.RecordAttribute;\n-import jdk.internal.classfile.attribute.RecordComponentInfo;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.SignatureAttribute;\n-import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n-import jdk.internal.classfile.attribute.SourceFileAttribute;\n-import jdk.internal.classfile.attribute.SourceIDAttribute;\n-import jdk.internal.classfile.attribute.StackMapTableAttribute;\n-import jdk.internal.classfile.attribute.SyntheticAttribute;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n+import java.lang.classfile.attribute.CharacterRangeInfo;\n+import java.lang.classfile.attribute.CharacterRangeTableAttribute;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.attribute.CompilationIDAttribute;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.attribute.DeprecatedAttribute;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.LineNumberInfo;\n+import java.lang.classfile.attribute.LineNumberTableAttribute;\n+import java.lang.classfile.attribute.LocalVariableInfo;\n+import java.lang.classfile.attribute.LocalVariableTableAttribute;\n+import java.lang.classfile.attribute.LocalVariableTypeInfo;\n+import java.lang.classfile.attribute.LocalVariableTypeTableAttribute;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.MethodParametersAttribute;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleHashInfo;\n+import java.lang.classfile.attribute.ModuleHashesAttribute;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.classfile.attribute.ModuleProvideInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.attribute.ModuleTargetAttribute;\n+import java.lang.classfile.attribute.NestHostAttribute;\n+import java.lang.classfile.attribute.NestMembersAttribute;\n+import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n+import java.lang.classfile.attribute.PreloadAttribute;\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RecordComponentInfo;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.classfile.attribute.SourceIDAttribute;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.attribute.SyntheticAttribute;\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -88,0 +88,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -93,0 +94,2 @@\n+ *\n+ * @since 22\n@@ -94,0 +97,1 @@\n+@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n@@ -174,1 +178,1 @@\n-    \/** RuntimeInvisibleTypeAnnotations *\/\n+    \/** RuntimeInvisibleParameterAnnotations *\/\n@@ -177,1 +181,1 @@\n-    \/**  *\/\n+    \/** RuntimeInvisibleTypeAnnotations *\/\n@@ -212,1 +216,1 @@\n-            ANNOTATION_DEFAULT = new AbstractAttributeMapper<>(NAME_ANNOTATION_DEFAULT, Classfile.JAVA_5_VERSION) {\n+            ANNOTATION_DEFAULT = new AbstractAttributeMapper<>(NAME_ANNOTATION_DEFAULT) {\n@@ -231,1 +235,1 @@\n-            BOOTSTRAP_METHODS = new AbstractAttributeMapper<>(NAME_BOOTSTRAP_METHODS, Classfile.JAVA_17_VERSION) {\n+            BOOTSTRAP_METHODS = new AbstractAttributeMapper<>(NAME_BOOTSTRAP_METHODS) {\n@@ -250,1 +254,1 @@\n-            CHARACTER_RANGE_TABLE = new AbstractAttributeMapper<>(NAME_CHARACTER_RANGE_TABLE, true, Classfile.JAVA_4_VERSION) {\n+            CHARACTER_RANGE_TABLE = new AbstractAttributeMapper<>(NAME_CHARACTER_RANGE_TABLE, true) {\n@@ -354,1 +358,1 @@\n-            ENCLOSING_METHOD = new AbstractAttributeMapper<>(NAME_ENCLOSING_METHOD, Classfile.JAVA_5_VERSION) {\n+            ENCLOSING_METHOD = new AbstractAttributeMapper<>(NAME_ENCLOSING_METHOD) {\n@@ -470,1 +474,1 @@\n-            LOCAL_VARIABLE_TYPE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TYPE_TABLE, true, Classfile.JAVA_5_VERSION) {\n+            LOCAL_VARIABLE_TYPE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TYPE_TABLE, true) {\n@@ -497,1 +501,1 @@\n-            METHOD_PARAMETERS = new AbstractAttributeMapper<>(NAME_METHOD_PARAMETERS, Classfile.JAVA_8_VERSION) {\n+            METHOD_PARAMETERS = new AbstractAttributeMapper<>(NAME_METHOD_PARAMETERS) {\n@@ -521,1 +525,1 @@\n-            MODULE = new AbstractAttributeMapper<>(NAME_MODULE, Classfile.JAVA_9_VERSION) {\n+            MODULE = new AbstractAttributeMapper<>(NAME_MODULE) {\n@@ -566,1 +570,1 @@\n-            MODULE_HASHES = new AbstractAttributeMapper<>(NAME_MODULE_HASHES, Classfile.JAVA_9_VERSION) {\n+            MODULE_HASHES = new AbstractAttributeMapper<>(NAME_MODULE_HASHES) {\n@@ -592,1 +596,1 @@\n-            MODULE_MAIN_CLASS = new AbstractAttributeMapper<>(NAME_MODULE_MAIN_CLASS, Classfile.JAVA_9_VERSION) {\n+            MODULE_MAIN_CLASS = new AbstractAttributeMapper<>(NAME_MODULE_MAIN_CLASS) {\n@@ -611,1 +615,1 @@\n-            MODULE_PACKAGES = new AbstractAttributeMapper<>(NAME_MODULE_PACKAGES, Classfile.JAVA_9_VERSION) {\n+            MODULE_PACKAGES = new AbstractAttributeMapper<>(NAME_MODULE_PACKAGES) {\n@@ -630,1 +634,1 @@\n-            MODULE_RESOLUTION = new AbstractAttributeMapper<>(NAME_MODULE_RESOLUTION, Classfile.JAVA_9_VERSION) {\n+            MODULE_RESOLUTION = new AbstractAttributeMapper<>(NAME_MODULE_RESOLUTION) {\n@@ -649,1 +653,1 @@\n-            MODULE_TARGET = new AbstractAttributeMapper<>(NAME_MODULE_TARGET, Classfile.JAVA_9_VERSION) {\n+            MODULE_TARGET = new AbstractAttributeMapper<>(NAME_MODULE_TARGET) {\n@@ -668,1 +672,1 @@\n-            NEST_HOST = new AbstractAttributeMapper<>(NAME_NEST_HOST, Classfile.JAVA_11_VERSION) {\n+            NEST_HOST = new AbstractAttributeMapper<>(NAME_NEST_HOST) {\n@@ -687,1 +691,1 @@\n-            NEST_MEMBERS = new AbstractAttributeMapper<>(NAME_NEST_MEMBERS, Classfile.JAVA_11_VERSION) {\n+            NEST_MEMBERS = new AbstractAttributeMapper<>(NAME_NEST_MEMBERS) {\n@@ -706,1 +710,1 @@\n-            PERMITTED_SUBCLASSES = new AbstractAttributeMapper<>(NAME_PERMITTED_SUBCLASSES, Classfile.JAVA_15_VERSION) {\n+            PERMITTED_SUBCLASSES = new AbstractAttributeMapper<>(NAME_PERMITTED_SUBCLASSES) {\n@@ -725,1 +729,1 @@\n-            PRELOAD = new AbstractAttributeMapper<>(NAME_PRELOAD, Classfile.JAVA_21_VERSION) {\n+            PRELOAD = new AbstractAttributeMapper<>(NAME_PRELOAD) {\n@@ -744,1 +748,1 @@\n-            RECORD = new AbstractAttributeMapper<>(NAME_RECORD, Classfile.JAVA_16_VERSION) {\n+            RECORD = new AbstractAttributeMapper<>(NAME_RECORD) {\n@@ -769,1 +773,1 @@\n-            RUNTIME_INVISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+            RUNTIME_INVISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_ANNOTATIONS) {\n@@ -788,1 +792,1 @@\n-            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS) {\n@@ -810,1 +814,1 @@\n-            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, Classfile.JAVA_8_VERSION) {\n+            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) {\n@@ -829,1 +833,1 @@\n-            RUNTIME_VISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+            RUNTIME_VISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_ANNOTATIONS) {\n@@ -848,1 +852,1 @@\n-            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS) {\n@@ -870,1 +874,1 @@\n-            RUNTIME_VISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS, Classfile.JAVA_8_VERSION) {\n+            RUNTIME_VISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS) {\n@@ -889,1 +893,1 @@\n-            SIGNATURE = new AbstractAttributeMapper<>(NAME_SIGNATURE, Classfile.JAVA_5_VERSION) {\n+            SIGNATURE = new AbstractAttributeMapper<>(NAME_SIGNATURE) {\n@@ -908,1 +912,1 @@\n-            SOURCE_DEBUG_EXTENSION = new AbstractAttributeMapper<>(NAME_SOURCE_DEBUG_EXTENSION, Classfile.JAVA_5_VERSION) {\n+            SOURCE_DEBUG_EXTENSION = new AbstractAttributeMapper<>(NAME_SOURCE_DEBUG_EXTENSION) {\n@@ -965,1 +969,1 @@\n-            STACK_MAP_TABLE = new AbstractAttributeMapper<>(NAME_STACK_MAP_TABLE, Classfile.JAVA_6_VERSION) {\n+            STACK_MAP_TABLE = new AbstractAttributeMapper<>(NAME_STACK_MAP_TABLE) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attributes.java","additions":83,"deletions":79,"binary":false,"changes":162,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Attributes.java","status":"renamed"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.classfile;\n+\n+import java.lang.classfile.attribute.CompilationIDAttribute;\n+import java.lang.classfile.attribute.DeprecatedAttribute;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleHashesAttribute;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.attribute.ModuleTargetAttribute;\n+import java.lang.classfile.attribute.NestHostAttribute;\n+import java.lang.classfile.attribute.NestMembersAttribute;\n+import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n+import java.lang.classfile.attribute.PreloadAttribute;\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.classfile.attribute.SourceIDAttribute;\n+import java.lang.classfile.attribute.SyntheticAttribute;\n+import java.lang.classfile.attribute.UnknownAttribute;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A marker interface for elements that can appear when traversing\n+ * a {@link ClassModel} or be presented to a {@link ClassBuilder}.\n+ *\n+ * @sealedGraph\n+ * @since 22\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+public sealed interface ClassElement extends ClassFileElement\n+        permits AccessFlags, Superclass, Interfaces, ClassFileVersion,\n+                FieldModel, MethodModel,\n+                CustomAttribute, CompilationIDAttribute, DeprecatedAttribute,\n+                EnclosingMethodAttribute, InnerClassesAttribute,\n+                ModuleAttribute, ModuleHashesAttribute, ModuleMainClassAttribute,\n+                ModulePackagesAttribute, ModuleResolutionAttribute, ModuleTargetAttribute,\n+                NestHostAttribute, NestMembersAttribute, PermittedSubclassesAttribute, PreloadAttribute,\n+                RecordAttribute,\n+                RuntimeInvisibleAnnotationsAttribute, RuntimeInvisibleTypeAnnotationsAttribute,\n+                RuntimeVisibleAnnotationsAttribute, RuntimeVisibleTypeAnnotationsAttribute,\n+                SignatureAttribute, SourceDebugExtensionAttribute,\n+                SourceFileAttribute, SourceIDAttribute, SyntheticAttribute, UnknownAttribute {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassElement.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,1502 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.classfile;\n+\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.UnknownAttribute;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.ClassFileImpl;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.classfile.attribute.CharacterRangeInfo;\n+import java.lang.classfile.attribute.LocalVariableInfo;\n+import java.lang.classfile.attribute.LocalVariableTypeInfo;\n+import java.lang.classfile.instruction.ExceptionCatch;\n+import java.util.List;\n+import static java.util.Objects.requireNonNull;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Represents a context for parsing, transforming, and generating classfiles.\n+ * A {@code ClassFile} has a set of options that condition how parsing and\n+ * generation is done.\n+ *\n+ * @since 22\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+public sealed interface ClassFile\n+        permits ClassFileImpl {\n+\n+    \/**\n+     * {@return a context with default options}\n+     *\/\n+    static ClassFile of() {\n+        return ClassFileImpl.DEFAULT_CONTEXT;\n+    }\n+\n+    \/**\n+     * {@return a new context with options altered from the default}\n+     * @param options the desired processing options\n+     *\/\n+    static ClassFile of(Option... options) {\n+        return of().withOptions(options);\n+    }\n+\n+    \/**\n+     * {@return a copy of the context with altered options}\n+     * @param options the desired processing options\n+     *\/\n+    ClassFile withOptions(Option... options);\n+\n+    \/**\n+     * An option that affects the parsing and writing of classfiles.\n+     *\n+     * @sealedGraph\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    sealed interface Option {\n+    }\n+\n+    \/**\n+     * Option describing attribute mappers for custom attributes.\n+     * Default is only to process standard attributes.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    sealed interface AttributeMapperOption extends Option\n+            permits ClassFileImpl.AttributeMapperOptionImpl {\n+\n+        \/**\n+         * {@return an option describing attribute mappers for custom attributes}\n+         * @param attributeMapper a function mapping attribute names to attribute mappers\n+         *\/\n+        static AttributeMapperOption of(Function<Utf8Entry, AttributeMapper<?>> attributeMapper) {\n+            requireNonNull(attributeMapper);\n+            return new ClassFileImpl.AttributeMapperOptionImpl(attributeMapper);\n+        }\n+\n+        \/**\n+         * {@return the function mapping attribute names to attribute mappers}\n+         *\/\n+        Function<Utf8Entry, AttributeMapper<?>> attributeMapper();\n+    }\n+\n+    \/**\n+     * Option describing the class hierarchy resolver to use when generating\n+     * stack maps.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    sealed interface ClassHierarchyResolverOption extends Option\n+            permits ClassFileImpl.ClassHierarchyResolverOptionImpl {\n+\n+        \/**\n+         * {@return an option describing the class hierarchy resolver to use when\n+         * generating stack maps}\n+         * @param classHierarchyResolver the resolver\n+         *\/\n+        static ClassHierarchyResolverOption of(ClassHierarchyResolver classHierarchyResolver) {\n+            requireNonNull(classHierarchyResolver);\n+            return new ClassFileImpl.ClassHierarchyResolverOptionImpl(classHierarchyResolver);\n+        }\n+\n+        \/**\n+         * {@return the class hierarchy resolver}\n+         *\/\n+        ClassHierarchyResolver classHierarchyResolver();\n+    }\n+\n+    \/**\n+     * Option describing whether to preserve the original constant pool when\n+     * transforming a classfile.  Reusing the constant pool enables significant\n+     * optimizations in processing time and minimizes differences between the\n+     * original and transformed classfile, but may result in a bigger classfile\n+     * when a classfile is significantly transformed.\n+     * Default is {@code SHARED_POOL} to preserve the original constant\n+     * pool.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum ConstantPoolSharingOption implements Option {\n+\n+        \/** Preserves the original constant pool when transforming classfile *\/\n+        SHARED_POOL,\n+\n+        \/** Creates a new constant pool when transforming classfile *\/\n+        NEW_POOL\n+    }\n+\n+    \/**\n+     * Option describing whether to patch out unreachable code.\n+     * Default is {@code PATCH_DEAD_CODE} to automatically patch out unreachable\n+     * code with NOPs.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum DeadCodeOption implements Option {\n+\n+        \/** Patch unreachable code *\/\n+        PATCH_DEAD_CODE,\n+\n+        \/** Keep the unreachable code *\/\n+        KEEP_DEAD_CODE\n+    }\n+\n+    \/**\n+     * Option describing whether to filter unresolved labels.\n+     * Default is {@code FAIL_ON_DEAD_LABELS} to throw IllegalStateException\n+     * when any {@link ExceptionCatch}, {@link LocalVariableInfo},\n+     * {@link LocalVariableTypeInfo}, or {@link CharacterRangeInfo}\n+     * reference to unresolved {@link Label} during bytecode serialization.\n+     * Setting this option to {@code DROP_DEAD_LABELS} filters the above\n+     * elements instead.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum DeadLabelsOption implements Option {\n+\n+        \/** Fail on unresolved labels *\/\n+        FAIL_ON_DEAD_LABELS,\n+\n+        \/** Filter unresolved labels *\/\n+        DROP_DEAD_LABELS\n+    }\n+\n+    \/**\n+     * Option describing whether to process or discard debug elements.\n+     * Debug elements include the local variable table, local variable type\n+     * table, and character range table.  Discarding debug elements may\n+     * reduce the overhead of parsing or transforming classfiles.\n+     * Default is {@code PASS_DEBUG} to process debug elements.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum DebugElementsOption implements Option {\n+\n+        \/** Process debug elements *\/\n+        PASS_DEBUG,\n+\n+        \/** Drop debug elements *\/\n+        DROP_DEBUG\n+    }\n+\n+    \/**\n+     * Option describing whether to process or discard line numbers.\n+     * Discarding line numbers may reduce the overhead of parsing or transforming\n+     * classfiles.\n+     * Default is {@code PASS_LINE_NUMBERS} to process line numbers.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum LineNumbersOption implements Option {\n+\n+        \/** Process line numbers *\/\n+        PASS_LINE_NUMBERS,\n+\n+        \/** Drop line numbers *\/\n+        DROP_LINE_NUMBERS;\n+    }\n+\n+    \/**\n+     * Option describing whether to automatically rewrite short jumps to\n+     * long when necessary.\n+     * Default is {@code FIX_SHORT_JUMPS} to automatically rewrite jump\n+     * instructions.\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum ShortJumpsOption implements Option {\n+\n+        \/** Automatically convert short jumps to long when necessary *\/\n+        FIX_SHORT_JUMPS,\n+\n+        \/** Fail if short jump overflows *\/\n+        FAIL_ON_SHORT_JUMPS\n+    }\n+\n+    \/**\n+     * Option describing whether to generate stackmaps.\n+     * Default is {@code STACK_MAPS_WHEN_REQUIRED} to generate stack\n+     * maps for {@link #JAVA_6_VERSION} or above, where specifically for\n+     * {@link #JAVA_6_VERSION} the stack maps may not be generated.\n+     * @jvms 4.10.1 Verification by Type Checking\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum StackMapsOption implements Option {\n+\n+        \/** Generate stack maps when required *\/\n+        STACK_MAPS_WHEN_REQUIRED,\n+\n+        \/** Always generate stack maps *\/\n+        GENERATE_STACK_MAPS,\n+\n+        \/** Drop stack maps from code *\/\n+        DROP_STACK_MAPS\n+    }\n+\n+    \/**\n+     * Option describing whether to process or discard unrecognized or problematic\n+     * original attributes when a class, record component, field, method or code is\n+     * transformed in its exploded form.\n+     * Default is {@code PASS_ALL_ATTRIBUTES} to process all original attributes.\n+     * @see AttributeMapper.AttributeStability\n+     *\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+    enum AttributesProcessingOption implements Option {\n+\n+        \/** Process all original attributes during transformation *\/\n+        PASS_ALL_ATTRIBUTES,\n+\n+        \/** Drop unknown attributes during transformation *\/\n+        DROP_UNKNOWN_ATTRIBUTES,\n+\n+        \/** Drop unknown and unstable original attributes during transformation *\/\n+        DROP_UNSTABLE_ATRIBUTES;\n+    }\n+\n+    \/**\n+     * Parse a classfile into a {@link ClassModel}.\n+     * @param bytes the bytes of the classfile\n+     * @return the class model\n+     * @throws IllegalArgumentException or its subclass if the classfile format is\n+     * not supported or an incompatibility prevents parsing of the classfile\n+     *\/\n+    ClassModel parse(byte[] bytes);\n+\n+    \/**\n+     * Parse a classfile into a {@link ClassModel}.\n+     * @param path the path to the classfile\n+     * @return the class model\n+     * @throws java.io.IOException if an I\/O error occurs\n+     * @throws IllegalArgumentException or its subclass if the classfile format is\n+     * not supported or an incompatibility prevents parsing of the classfile\n+     *\/\n+    default ClassModel parse(Path path) throws IOException {\n+        return parse(Files.readAllBytes(path));\n+    }\n+\n+    \/**\n+     * Build a classfile into a byte array.\n+     * @param thisClass the name of the class to build\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the classfile bytes\n+     * @throws IllegalArgumentException if {@code thisClass} represents a primitive type\n+     *\/\n+    default byte[] build(ClassDesc thisClass,\n+                         Consumer<? super ClassBuilder> handler) {\n+        ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+        return build(pool.classEntry(thisClass), pool, handler);\n+    }\n+\n+    \/**\n+     * Build a classfile into a byte array using the provided constant pool\n+     * builder.\n+     *\n+     * @param thisClassEntry the name of the class to build\n+     * @param constantPool the constant pool builder\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the classfile bytes\n+     *\/\n+    byte[] build(ClassEntry thisClassEntry,\n+                 ConstantPoolBuilder constantPool,\n+                 Consumer<? super ClassBuilder> handler);\n+\n+    \/**\n+     * Build a classfile into a file.\n+     * @param path the path to the file to write\n+     * @param thisClass the name of the class to build\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @throws java.io.IOException if an I\/O error occurs\n+     *\/\n+    default void buildTo(Path path,\n+                         ClassDesc thisClass,\n+                         Consumer<ClassBuilder> handler) throws IOException {\n+        Files.write(path, build(thisClass, handler));\n+    }\n+\n+    \/**\n+     * Build a classfile into a file using the provided constant pool\n+     * builder.\n+     *\n+     * @param path the path to the file to write\n+     * @param thisClassEntry the name of the class to build\n+     * @param constantPool the constant pool builder\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @throws java.io.IOException if an I\/O error occurs\n+     *\/\n+    default void buildTo(Path path,\n+                         ClassEntry thisClassEntry,\n+                         ConstantPoolBuilder constantPool,\n+                         Consumer<? super ClassBuilder> handler) throws IOException {\n+        Files.write(path, build(thisClassEntry, constantPool, handler));\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a byte array.\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @return the classfile bytes\n+     *\/\n+    default byte[] buildModule(ModuleAttribute moduleAttribute) {\n+        return buildModule(moduleAttribute, clb -> {});\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a byte array.\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the classfile bytes\n+     *\/\n+    default byte[] buildModule(ModuleAttribute moduleAttribute,\n+                                     Consumer<? super ClassBuilder> handler) {\n+        return build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(AccessFlag.MODULE);\n+            clb.with(moduleAttribute);\n+            handler.accept(clb);\n+        });\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a file.\n+     * @param path the file to write\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @throws java.io.IOException if an I\/O error occurs\n+     *\/\n+    default void buildModuleTo(Path path,\n+                                     ModuleAttribute moduleAttribute) throws IOException {\n+        buildModuleTo(path, moduleAttribute, clb -> {});\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a file.\n+     * @param path the file to write\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @throws java.io.IOException if an I\/O error occurs\n+     *\/\n+    default void buildModuleTo(Path path,\n+                                     ModuleAttribute moduleAttribute,\n+                                     Consumer<? super ClassBuilder> handler) throws IOException {\n+        Files.write(path, buildModule(moduleAttribute, handler));\n+    }\n+\n+    \/**\n+     * Transform one classfile into a new classfile with the aid of a\n+     * {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     *\n+     * @implNote\n+     * This method behaves as if:\n+     * {@snippet lang=java :\n+     *     this.build(model.thisClass(), ConstantPoolBuilder.of(model),\n+     *                     b -> b.transform(model, transform));\n+     * }\n+     *\n+     * @param model the class model to transform\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     *\/\n+    default byte[] transform(ClassModel model, ClassTransform transform) {\n+        return transform(model, model.thisClass(), transform);\n+    }\n+\n+    \/**\n+     * Transform one classfile into a new classfile with the aid of a\n+     * {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     *\n+     * @param model the class model to transform\n+     * @param newClassName new class name\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     *\/\n+    default byte[] transform(ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n+        return transform(model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n+    }\n+\n+    \/**\n+     * Transform one classfile into a new classfile with the aid of a\n+     * {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     *\n+     * @implNote\n+     * This method behaves as if:\n+     * {@snippet lang=java :\n+     *     this.build(newClassName, ConstantPoolBuilder.of(model),\n+     *                     b -> b.transform(model, transform));\n+     * }\n+     *\n+     * @param model the class model to transform\n+     * @param newClassName new class name\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     *\/\n+    byte[] transform(ClassModel model, ClassEntry newClassName, ClassTransform transform);\n+\n+    \/**\n+     * Verify a classfile.  Any verification errors found will be returned.\n+     * @param model the class model to verify\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     *\/\n+    List<VerifyError> verify(ClassModel model);\n+\n+    \/**\n+     * Verify a classfile.  Any verification errors found will be returned.\n+     * @param bytes the classfile bytes to verify\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     *\/\n+    List<VerifyError> verify(byte[] bytes);\n+\n+    \/**\n+     * Verify a classfile.  Any verification errors found will be returned.\n+     * @param path the classfile path to verify\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     * @throws java.io.IOException if an I\/O error occurs\n+     *\/\n+    default List<VerifyError> verify(Path path) throws IOException {\n+        return verify(Files.readAllBytes(path));\n+    }\n+\n+    \/** 0xCAFEBABE *\/\n+    int MAGIC_NUMBER = 0xCAFEBABE;\n+\n+    \/** The integer value used to encode the NOP instruction. *\/\n+    int NOP             = 0;\n+\n+    \/** The integer value used to encode the ACONST_NULL instruction. *\/\n+    int ACONST_NULL     = 1;\n+\n+    \/** The integer value used to encode the ICONST_M1 instruction. *\/\n+    int ICONST_M1       = 2;\n+\n+    \/** The integer value used to encode the ICONST_0 instruction. *\/\n+    int ICONST_0        = 3;\n+\n+    \/** The integer value used to encode the ICONST_1 instruction. *\/\n+    int ICONST_1        = 4;\n+\n+    \/** The integer value used to encode the ICONST_2 instruction. *\/\n+    int ICONST_2        = 5;\n+\n+    \/** The integer value used to encode the ICONST_3 instruction. *\/\n+    int ICONST_3        = 6;\n+\n+    \/** The integer value used to encode the ICONST_4 instruction. *\/\n+    int ICONST_4        = 7;\n+\n+    \/** The integer value used to encode the ICONST_5 instruction. *\/\n+    int ICONST_5        = 8;\n+\n+    \/** The integer value used to encode the LCONST_0 instruction. *\/\n+    int LCONST_0        = 9;\n+\n+    \/** The integer value used to encode the LCONST_1 instruction. *\/\n+    int LCONST_1        = 10;\n+\n+    \/** The integer value used to encode the FCONST_0 instruction. *\/\n+    int FCONST_0        = 11;\n+\n+    \/** The integer value used to encode the FCONST_1 instruction. *\/\n+    int FCONST_1        = 12;\n+\n+    \/** The integer value used to encode the FCONST_2 instruction. *\/\n+    int FCONST_2        = 13;\n+\n+    \/** The integer value used to encode the DCONST_0 instruction. *\/\n+    int DCONST_0        = 14;\n+\n+    \/** The integer value used to encode the DCONST_1 instruction. *\/\n+    int DCONST_1        = 15;\n+\n+    \/** The integer value used to encode the BIPUSH instruction. *\/\n+    int BIPUSH          = 16;\n+\n+    \/** The integer value used to encode the SIPUSH instruction. *\/\n+    int SIPUSH          = 17;\n+\n+    \/** The integer value used to encode the LDC instruction. *\/\n+    int LDC             = 18;\n+\n+    \/** The integer value used to encode the LDC_W instruction. *\/\n+    int LDC_W           = 19;\n+\n+    \/** The integer value used to encode the LDC2_W instruction. *\/\n+    int LDC2_W          = 20;\n+\n+    \/** The integer value used to encode the ILOAD instruction. *\/\n+    int ILOAD           = 21;\n+\n+    \/** The integer value used to encode the LLOAD instruction. *\/\n+    int LLOAD           = 22;\n+\n+    \/** The integer value used to encode the FLOAD instruction. *\/\n+    int FLOAD           = 23;\n+\n+    \/** The integer value used to encode the DLOAD instruction. *\/\n+    int DLOAD           = 24;\n+\n+    \/** The integer value used to encode the ALOAD instruction. *\/\n+    int ALOAD           = 25;\n+\n+    \/** The integer value used to encode the ILOAD_0 instruction. *\/\n+    int ILOAD_0         = 26;\n+\n+    \/** The integer value used to encode the ILOAD_1 instruction. *\/\n+    int ILOAD_1         = 27;\n+\n+    \/** The integer value used to encode the ILOAD_2 instruction. *\/\n+    int ILOAD_2         = 28;\n+\n+    \/** The integer value used to encode the ILOAD_3 instruction. *\/\n+    int ILOAD_3         = 29;\n+\n+    \/** The integer value used to encode the LLOAD_0 instruction. *\/\n+    int LLOAD_0         = 30;\n+\n+    \/** The integer value used to encode the LLOAD_1 instruction. *\/\n+    int LLOAD_1         = 31;\n+\n+    \/** The integer value used to encode the LLOAD_2 instruction. *\/\n+    int LLOAD_2         = 32;\n+\n+    \/** The integer value used to encode the LLOAD_3 instruction. *\/\n+    int LLOAD_3         = 33;\n+\n+    \/** The integer value used to encode the FLOAD_0 instruction. *\/\n+    int FLOAD_0         = 34;\n+\n+    \/** The integer value used to encode the FLOAD_1 instruction. *\/\n+    int FLOAD_1         = 35;\n+\n+    \/** The integer value used to encode the FLOAD_2 instruction. *\/\n+    int FLOAD_2         = 36;\n+\n+    \/** The integer value used to encode the FLOAD_3 instruction. *\/\n+    int FLOAD_3         = 37;\n+\n+    \/** The integer value used to encode the DLOAD_0 instruction. *\/\n+    int DLOAD_0         = 38;\n+\n+    \/** The integer value used to encode the DLOAD_1 instruction. *\/\n+    int DLOAD_1         = 39;\n+\n+    \/** The integer value used to encode the DLOAD_2 instruction. *\/\n+    int DLOAD_2         = 40;\n+\n+    \/** The integer value used to encode the DLOAD_3 instruction. *\/\n+    int DLOAD_3         = 41;\n+\n+    \/** The integer value used to encode the ALOAD_0 instruction. *\/\n+    int ALOAD_0         = 42;\n+\n+    \/** The integer value used to encode the ALOAD_1 instruction. *\/\n+    int ALOAD_1         = 43;\n+\n+    \/** The integer value used to encode the ALOAD_2 instruction. *\/\n+    int ALOAD_2         = 44;\n+\n+    \/** The integer value used to encode the ALOAD_3 instruction. *\/\n+    int ALOAD_3         = 45;\n+\n+    \/** The integer value used to encode the IALOAD instruction. *\/\n+    int IALOAD          = 46;\n+\n+    \/** The integer value used to encode the LALOAD instruction. *\/\n+    int LALOAD          = 47;\n+\n+    \/** The integer value used to encode the FALOAD instruction. *\/\n+    int FALOAD          = 48;\n+\n+    \/** The integer value used to encode the DALOAD instruction. *\/\n+    int DALOAD          = 49;\n+\n+    \/** The integer value used to encode the AALOAD instruction. *\/\n+    int AALOAD          = 50;\n+\n+    \/** The integer value used to encode the BALOAD instruction. *\/\n+    int BALOAD          = 51;\n+\n+    \/** The integer value used to encode the CALOAD instruction. *\/\n+    int CALOAD          = 52;\n+\n+    \/** The integer value used to encode the SALOAD instruction. *\/\n+    int SALOAD          = 53;\n+\n+    \/** The integer value used to encode the ISTORE instruction. *\/\n+    int ISTORE          = 54;\n+\n+    \/** The integer value used to encode the LSTORE instruction. *\/\n+    int LSTORE          = 55;\n+\n+    \/** The integer value used to encode the FSTORE instruction. *\/\n+    int FSTORE          = 56;\n+\n+    \/** The integer value used to encode the DSTORE instruction. *\/\n+    int DSTORE          = 57;\n+\n+    \/** The integer value used to encode the ASTORE instruction. *\/\n+    int ASTORE          = 58;\n+\n+    \/** The integer value used to encode the ISTORE_0 instruction. *\/\n+    int ISTORE_0        = 59;\n+\n+    \/** The integer value used to encode the ISTORE_1 instruction. *\/\n+    int ISTORE_1        = 60;\n+\n+    \/** The integer value used to encode the ISTORE_2 instruction. *\/\n+    int ISTORE_2        = 61;\n+\n+    \/** The integer value used to encode the ISTORE_3 instruction. *\/\n+    int ISTORE_3        = 62;\n+\n+    \/** The integer value used to encode the LSTORE_0 instruction. *\/\n+    int LSTORE_0        = 63;\n+\n+    \/** The integer value used to encode the LSTORE_1 instruction. *\/\n+    int LSTORE_1        = 64;\n+\n+    \/** The integer value used to encode the LSTORE_2 instruction. *\/\n+    int LSTORE_2        = 65;\n+\n+    \/** The integer value used to encode the LSTORE_3 instruction. *\/\n+    int LSTORE_3        = 66;\n+\n+    \/** The integer value used to encode the FSTORE_0 instruction. *\/\n+    int FSTORE_0        = 67;\n+\n+    \/** The integer value used to encode the FSTORE_1 instruction. *\/\n+    int FSTORE_1        = 68;\n+\n+    \/** The integer value used to encode the FSTORE_2 instruction. *\/\n+    int FSTORE_2        = 69;\n+\n+    \/** The integer value used to encode the FSTORE_3 instruction. *\/\n+    int FSTORE_3        = 70;\n+\n+    \/** The integer value used to encode the DSTORE_0 instruction. *\/\n+    int DSTORE_0        = 71;\n+\n+    \/** The integer value used to encode the DSTORE_1 instruction. *\/\n+    int DSTORE_1        = 72;\n+\n+    \/** The integer value used to encode the DSTORE_2 instruction. *\/\n+    int DSTORE_2        = 73;\n+\n+    \/** The integer value used to encode the DSTORE_3 instruction. *\/\n+    int DSTORE_3        = 74;\n+\n+    \/** The integer value used to encode the ASTORE_0 instruction. *\/\n+    int ASTORE_0        = 75;\n+\n+    \/** The integer value used to encode the ASTORE_1 instruction. *\/\n+    int ASTORE_1        = 76;\n+\n+    \/** The integer value used to encode the ASTORE_2 instruction. *\/\n+    int ASTORE_2        = 77;\n+\n+    \/** The integer value used to encode the ASTORE_3 instruction. *\/\n+    int ASTORE_3        = 78;\n+\n+    \/** The integer value used to encode the IASTORE instruction. *\/\n+    int IASTORE         = 79;\n+\n+    \/** The integer value used to encode the LASTORE instruction. *\/\n+    int LASTORE         = 80;\n+\n+    \/** The integer value used to encode the FASTORE instruction. *\/\n+    int FASTORE         = 81;\n+\n+    \/** The integer value used to encode the DASTORE instruction. *\/\n+    int DASTORE         = 82;\n+\n+    \/** The integer value used to encode the AASTORE instruction. *\/\n+    int AASTORE         = 83;\n+\n+    \/** The integer value used to encode the BASTORE instruction. *\/\n+    int BASTORE         = 84;\n+\n+    \/** The integer value used to encode the CASTORE instruction. *\/\n+    int CASTORE         = 85;\n+\n+    \/** The integer value used to encode the SASTORE instruction. *\/\n+    int SASTORE         = 86;\n+\n+    \/** The integer value used to encode the POP instruction. *\/\n+    int POP             = 87;\n+\n+    \/** The integer value used to encode the POP2 instruction. *\/\n+    int POP2            = 88;\n+\n+    \/** The integer value used to encode the DUP instruction. *\/\n+    int DUP             = 89;\n+\n+    \/** The integer value used to encode the DUP_X1 instruction. *\/\n+    int DUP_X1          = 90;\n+\n+    \/** The integer value used to encode the DUP_X2 instruction. *\/\n+    int DUP_X2          = 91;\n+\n+    \/** The integer value used to encode the DUP2 instruction. *\/\n+    int DUP2            = 92;\n+\n+    \/** The integer value used to encode the DUP2_X1 instruction. *\/\n+    int DUP2_X1         = 93;\n+\n+    \/** The integer value used to encode the DUP2_X2 instruction. *\/\n+    int DUP2_X2         = 94;\n+\n+    \/** The integer value used to encode the SWAP instruction. *\/\n+    int SWAP            = 95;\n+\n+    \/** The integer value used to encode the IADD instruction. *\/\n+    int IADD            = 96;\n+\n+    \/** The integer value used to encode the LADD instruction. *\/\n+    int LADD            = 97;\n+\n+    \/** The integer value used to encode the FADD instruction. *\/\n+    int FADD            = 98;\n+\n+    \/** The integer value used to encode the DADD instruction. *\/\n+    int DADD            = 99;\n+\n+    \/** The integer value used to encode the ISUB instruction. *\/\n+    int ISUB            = 100;\n+\n+    \/** The integer value used to encode the LSUB instruction. *\/\n+    int LSUB            = 101;\n+\n+    \/** The integer value used to encode the FSUB instruction. *\/\n+    int FSUB            = 102;\n+\n+    \/** The integer value used to encode the DSUB instruction. *\/\n+    int DSUB            = 103;\n+\n+    \/** The integer value used to encode the IMUL instruction. *\/\n+    int IMUL            = 104;\n+\n+    \/** The integer value used to encode the LMUL instruction. *\/\n+    int LMUL            = 105;\n+\n+    \/** The integer value used to encode the FMUL instruction. *\/\n+    int FMUL            = 106;\n+\n+    \/** The integer value used to encode the DMUL instruction. *\/\n+    int DMUL            = 107;\n+\n+    \/** The integer value used to encode the IDIV instruction. *\/\n+    int IDIV            = 108;\n+\n+    \/** The integer value used to encode the LDIV instruction. *\/\n+    int LDIV            = 109;\n+\n+    \/** The integer value used to encode the FDIV instruction. *\/\n+    int FDIV            = 110;\n+\n+    \/** The integer value used to encode the DDIV instruction. *\/\n+    int DDIV            = 111;\n+\n+    \/** The integer value used to encode the IREM instruction. *\/\n+    int IREM            = 112;\n+\n+    \/** The integer value used to encode the LREM instruction. *\/\n+    int LREM            = 113;\n+\n+    \/** The integer value used to encode the FREM instruction. *\/\n+    int FREM            = 114;\n+\n+    \/** The integer value used to encode the DREM instruction. *\/\n+    int DREM            = 115;\n+\n+    \/** The integer value used to encode the INEG instruction. *\/\n+    int INEG            = 116;\n+\n+    \/** The integer value used to encode the LNEG instruction. *\/\n+    int LNEG            = 117;\n+\n+    \/** The integer value used to encode the FNEG instruction. *\/\n+    int FNEG            = 118;\n+\n+    \/** The integer value used to encode the DNEG instruction. *\/\n+    int DNEG            = 119;\n+\n+    \/** The integer value used to encode the ISHL instruction. *\/\n+    int ISHL            = 120;\n+\n+    \/** The integer value used to encode the LSHL instruction. *\/\n+    int LSHL            = 121;\n+\n+    \/** The integer value used to encode the ISHR instruction. *\/\n+    int ISHR            = 122;\n+\n+    \/** The integer value used to encode the LSHR instruction. *\/\n+    int LSHR            = 123;\n+\n+    \/** The integer value used to encode the IUSHR instruction. *\/\n+    int IUSHR           = 124;\n+\n+    \/** The integer value used to encode the LUSHR instruction. *\/\n+    int LUSHR           = 125;\n+\n+    \/** The integer value used to encode the IAND instruction. *\/\n+    int IAND            = 126;\n+\n+    \/** The integer value used to encode the LAND instruction. *\/\n+    int LAND            = 127;\n+\n+    \/** The integer value used to encode the IOR instruction. *\/\n+    int IOR             = 128;\n+\n+    \/** The integer value used to encode the LOR instruction. *\/\n+    int LOR             = 129;\n+\n+    \/** The integer value used to encode the IXOR instruction. *\/\n+    int IXOR            = 130;\n+\n+    \/** The integer value used to encode the LXOR instruction. *\/\n+    int LXOR            = 131;\n+\n+    \/** The integer value used to encode the IINC instruction. *\/\n+    int IINC            = 132;\n+\n+    \/** The integer value used to encode the I2L instruction. *\/\n+    int I2L             = 133;\n+\n+    \/** The integer value used to encode the I2F instruction. *\/\n+    int I2F             = 134;\n+\n+    \/** The integer value used to encode the I2D instruction. *\/\n+    int I2D             = 135;\n+\n+    \/** The integer value used to encode the L2I instruction. *\/\n+    int L2I             = 136;\n+\n+    \/** The integer value used to encode the L2F instruction. *\/\n+    int L2F             = 137;\n+\n+    \/** The integer value used to encode the L2D instruction. *\/\n+    int L2D             = 138;\n+\n+    \/** The integer value used to encode the F2I instruction. *\/\n+    int F2I             = 139;\n+\n+    \/** The integer value used to encode the F2L instruction. *\/\n+    int F2L             = 140;\n+\n+    \/** The integer value used to encode the F2D instruction. *\/\n+    int F2D             = 141;\n+\n+    \/** The integer value used to encode the D2I instruction. *\/\n+    int D2I             = 142;\n+\n+    \/** The integer value used to encode the D2L instruction. *\/\n+    int D2L             = 143;\n+\n+    \/** The integer value used to encode the D2F instruction. *\/\n+    int D2F             = 144;\n+\n+    \/** The integer value used to encode the I2B instruction. *\/\n+    int I2B             = 145;\n+\n+    \/** The integer value used to encode the I2C instruction. *\/\n+    int I2C             = 146;\n+\n+    \/** The integer value used to encode the I2S instruction. *\/\n+    int I2S             = 147;\n+\n+    \/** The integer value used to encode the LCMP instruction. *\/\n+    int LCMP            = 148;\n+\n+    \/** The integer value used to encode the FCMPL instruction. *\/\n+    int FCMPL           = 149;\n+\n+    \/** The integer value used to encode the FCMPG instruction. *\/\n+    int FCMPG           = 150;\n+\n+    \/** The integer value used to encode the DCMPL instruction. *\/\n+    int DCMPL           = 151;\n+\n+    \/** The integer value used to encode the DCMPG instruction. *\/\n+    int DCMPG           = 152;\n+\n+    \/** The integer value used to encode the IFEQ instruction. *\/\n+    int IFEQ            = 153;\n+\n+    \/** The integer value used to encode the IFNE instruction. *\/\n+    int IFNE            = 154;\n+\n+    \/** The integer value used to encode the IFLT instruction. *\/\n+    int IFLT            = 155;\n+\n+    \/** The integer value used to encode the IFGE instruction. *\/\n+    int IFGE            = 156;\n+\n+    \/** The integer value used to encode the IFGT instruction. *\/\n+    int IFGT            = 157;\n+\n+    \/** The integer value used to encode the IFLE instruction. *\/\n+    int IFLE            = 158;\n+\n+    \/** The integer value used to encode the IF_ICMPEQ instruction. *\/\n+    int IF_ICMPEQ       = 159;\n+\n+    \/** The integer value used to encode the IF_ICMPNE instruction. *\/\n+    int IF_ICMPNE       = 160;\n+\n+    \/** The integer value used to encode the IF_ICMPLT instruction. *\/\n+    int IF_ICMPLT       = 161;\n+\n+    \/** The integer value used to encode the IF_ICMPGE instruction. *\/\n+    int IF_ICMPGE       = 162;\n+\n+    \/** The integer value used to encode the IF_ICMPGT instruction. *\/\n+    int IF_ICMPGT       = 163;\n+\n+    \/** The integer value used to encode the IF_ICMPLE instruction. *\/\n+    int IF_ICMPLE       = 164;\n+\n+    \/** The integer value used to encode the IF_ACMPEQ instruction. *\/\n+    int IF_ACMPEQ       = 165;\n+\n+    \/** The integer value used to encode the IF_ACMPNE instruction. *\/\n+    int IF_ACMPNE       = 166;\n+\n+    \/** The integer value used to encode the GOTO instruction. *\/\n+    int GOTO            = 167;\n+\n+    \/** The integer value used to encode the JSR instruction. *\/\n+    int JSR             = 168;\n+\n+    \/** The integer value used to encode the RET instruction. *\/\n+    int RET             = 169;\n+\n+    \/** The integer value used to encode the TABLESWITCH instruction. *\/\n+    int TABLESWITCH     = 170;\n+\n+    \/** The integer value used to encode the LOOKUPSWITCH instruction. *\/\n+    int LOOKUPSWITCH    = 171;\n+\n+    \/** The integer value used to encode the IRETURN instruction. *\/\n+    int IRETURN         = 172;\n+\n+    \/** The integer value used to encode the LRETURN instruction. *\/\n+    int LRETURN         = 173;\n+\n+    \/** The integer value used to encode the FRETURN instruction. *\/\n+    int FRETURN         = 174;\n+\n+    \/** The integer value used to encode the DRETURN instruction. *\/\n+    int DRETURN         = 175;\n+\n+    \/** The integer value used to encode the ARETURN instruction. *\/\n+    int ARETURN         = 176;\n+\n+    \/** The integer value used to encode the RETURN instruction. *\/\n+    int RETURN          = 177;\n+\n+    \/** The integer value used to encode the GETSTATIC instruction. *\/\n+    int GETSTATIC       = 178;\n+\n+    \/** The integer value used to encode the PUTSTATIC instruction. *\/\n+    int PUTSTATIC       = 179;\n+\n+    \/** The integer value used to encode the GETFIELD instruction. *\/\n+    int GETFIELD        = 180;\n+\n+    \/** The integer value used to encode the PUTFIELD instruction. *\/\n+    int PUTFIELD        = 181;\n+\n+    \/** The integer value used to encode the INVOKEVIRTUAL instruction. *\/\n+    int INVOKEVIRTUAL   = 182;\n+\n+    \/** The integer value used to encode the INVOKESPECIAL instruction. *\/\n+    int INVOKESPECIAL   = 183;\n+\n+    \/** The integer value used to encode the INVOKESTATIC instruction. *\/\n+    int INVOKESTATIC    = 184;\n+\n+    \/** The integer value used to encode the INVOKEINTERFACE instruction. *\/\n+    int INVOKEINTERFACE = 185;\n+\n+    \/** The integer value used to encode the INVOKEDYNAMIC instruction. *\/\n+    int INVOKEDYNAMIC   = 186;\n+\n+    \/** The integer value used to encode the NEW instruction. *\/\n+    int NEW             = 187;\n+\n+    \/** The integer value used to encode the NEWARRAY instruction. *\/\n+    int NEWARRAY        = 188;\n+\n+    \/** The integer value used to encode the ANEWARRAY instruction. *\/\n+    int ANEWARRAY       = 189;\n+\n+    \/** The integer value used to encode the ARRAYLENGTH instruction. *\/\n+    int ARRAYLENGTH     = 190;\n+\n+    \/** The integer value used to encode the ATHROW instruction. *\/\n+    int ATHROW          = 191;\n+\n+    \/** The integer value used to encode the CHECKCAST instruction. *\/\n+    int CHECKCAST       = 192;\n+\n+    \/** The integer value used to encode the INSTANCEOF instruction. *\/\n+    int INSTANCEOF      = 193;\n+\n+    \/** The integer value used to encode the MONITORENTER instruction. *\/\n+    int MONITORENTER    = 194;\n+\n+    \/** The integer value used to encode the MONITOREXIT instruction. *\/\n+    int MONITOREXIT     = 195;\n+\n+    \/** The integer value used to encode the WIDE instruction. *\/\n+    int WIDE            = 196;\n+\n+    \/** The integer value used to encode the MULTIANEWARRAY instruction. *\/\n+    int MULTIANEWARRAY  = 197;\n+\n+    \/** The integer value used to encode the IFNULL instruction. *\/\n+    int IFNULL          = 198;\n+\n+    \/** The integer value used to encode the IFNONNULL instruction. *\/\n+    int IFNONNULL       = 199;\n+\n+    \/** The integer value used to encode the GOTO_W instruction. *\/\n+    int GOTO_W          = 200;\n+\n+    \/** The integer value used to encode the JSR_W instruction. *\/\n+    int JSR_W           = 201;\n+\n+    \/** The value of PUBLIC access and property modifier. *\/\n+    int ACC_PUBLIC = 0x0001;\n+\n+    \/** The value of PROTECTED access and property modifier. *\/\n+    int ACC_PROTECTED = 0x0004;\n+\n+    \/** The value of PRIVATE access and property modifier. *\/\n+    int ACC_PRIVATE = 0x0002;\n+\n+    \/** The value of INTERFACE access and property modifier. *\/\n+    int ACC_INTERFACE = 0x0200;\n+\n+    \/** The value of ENUM access and property modifier. *\/\n+    int ACC_ENUM = 0x4000;\n+\n+    \/** The value of ANNOTATION access and property modifier. *\/\n+    int ACC_ANNOTATION = 0x2000;\n+\n+    \/** The value of SUPER access and property modifier. *\/\n+    int ACC_SUPER = 0x0020;\n+\n+    \/** The value of IDENTITY access and property modifier. *\/\n+    int ACC_IDENTITY = 0x0020;\n+\n+    \/** The value of ABSTRACT access and property modifier. *\/\n+    int ACC_ABSTRACT = 0x0400;\n+\n+    \/** The value of VOLATILE access and property modifier. *\/\n+    int ACC_VOLATILE = 0x0040;\n+\n+    \/** The value of TRANSIENT access and property modifier. *\/\n+    int ACC_TRANSIENT = 0x0080;\n+\n+    \/** The value of SYNTHETIC access and property modifier. *\/\n+    int ACC_SYNTHETIC = 0x1000;\n+\n+    \/** The value of STATIC access and property modifier. *\/\n+    int ACC_STATIC = 0x0008;\n+\n+    \/** The value of FINAL access and property modifier. *\/\n+    int ACC_FINAL = 0x0010;\n+\n+    \/** The value of SYNCHRONIZED access and property modifier. *\/\n+    int ACC_SYNCHRONIZED = 0x0020;\n+\n+    \/** The value of BRIDGE access and property modifier. *\/\n+    int ACC_BRIDGE = 0x0040;\n+\n+    \/** The value of VARARGS access and property modifier. *\/\n+    int ACC_VARARGS = 0x0080;\n+\n+    \/** The value of NATIVE access and property modifier. *\/\n+    int ACC_NATIVE = 0x0100;\n+\n+    \/** The value of STRICT access and property modifier. *\/\n+    int ACC_STRICT = 0x0800;\n+\n+    \/** The value of MODULE access and property modifier. *\/\n+    int ACC_MODULE = 0x8000;\n+\n+    \/** The value of OPEN access and property modifier. *\/\n+    int ACC_OPEN = 0x20;\n+\n+    \/** The value of MANDATED access and property modifier. *\/\n+    int ACC_MANDATED = 0x8000;\n+\n+    \/** The value of TRANSITIVE access and property modifier. *\/\n+    int ACC_TRANSITIVE = 0x20;\n+\n+    \/** The value of STATIC_PHASE access and property modifier. *\/\n+    int ACC_STATIC_PHASE = 0x40;\n+\n+    \/** The value of STATEMENT {@link CharacterRangeInfo} kind. *\/\n+    int CRT_STATEMENT       = 0x0001;\n+\n+    \/** The value of BLOCK {@link CharacterRangeInfo} kind. *\/\n+    int CRT_BLOCK           = 0x0002;\n+\n+    \/** The value of ASSIGNMENT {@link CharacterRangeInfo} kind. *\/\n+    int CRT_ASSIGNMENT      = 0x0004;\n+\n+    \/** The value of FLOW_CONTROLLER {@link CharacterRangeInfo} kind. *\/\n+    int CRT_FLOW_CONTROLLER = 0x0008;\n+\n+    \/** The value of FLOW_TARGET {@link CharacterRangeInfo} kind. *\/\n+    int CRT_FLOW_TARGET     = 0x0010;\n+\n+    \/** The value of INVOKE {@link CharacterRangeInfo} kind. *\/\n+    int CRT_INVOKE          = 0x0020;\n+\n+    \/** The value of CREATE {@link CharacterRangeInfo} kind. *\/\n+    int CRT_CREATE          = 0x0040;\n+\n+    \/** The value of BRANCH_TRUE {@link CharacterRangeInfo} kind. *\/\n+    int CRT_BRANCH_TRUE     = 0x0080;\n+\n+    \/** The value of BRANCH_FALSE {@link CharacterRangeInfo} kind. *\/\n+    int CRT_BRANCH_FALSE    = 0x0100;\n+\n+    \/** The value of constant pool tag CLASS. *\/\n+    int TAG_CLASS = 7;\n+\n+    \/** The value of constant pool tag CONSTANTDYNAMIC. *\/\n+    int TAG_CONSTANTDYNAMIC = 17;\n+\n+    \/** The value of constant pool tag DOUBLE. *\/\n+    int TAG_DOUBLE = 6;\n+\n+    \/** The value of constant pool tag FIELDREF. *\/\n+    int TAG_FIELDREF = 9;\n+\n+    \/** The value of constant pool tag FLOAT. *\/\n+    int TAG_FLOAT = 4;\n+\n+    \/** The value of constant pool tag INTEGER. *\/\n+    int TAG_INTEGER = 3;\n+\n+    \/** The value of constant pool tag INTERFACEMETHODREF. *\/\n+    int TAG_INTERFACEMETHODREF = 11;\n+\n+    \/** The value of constant pool tag INVOKEDYNAMIC. *\/\n+    int TAG_INVOKEDYNAMIC = 18;\n+\n+    \/** The value of constant pool tag LONG. *\/\n+    int TAG_LONG = 5;\n+\n+    \/** The value of constant pool tag METHODHANDLE. *\/\n+    int TAG_METHODHANDLE = 15;\n+\n+    \/** The value of constant pool tag METHODREF. *\/\n+    int TAG_METHODREF = 10;\n+\n+    \/** The value of constant pool tag METHODTYPE. *\/\n+    int TAG_METHODTYPE = 16;\n+\n+    \/** The value of constant pool tag MODULE. *\/\n+    int TAG_MODULE = 19;\n+\n+    \/** The value of constant pool tag NAMEANDTYPE. *\/\n+    int TAG_NAMEANDTYPE = 12;\n+\n+    \/** The value of constant pool tag PACKAGE. *\/\n+    int TAG_PACKAGE = 20;\n+\n+    \/** The value of constant pool tag STRING. *\/\n+    int TAG_STRING = 8;\n+\n+    \/** The value of constant pool tag UNICODE. *\/\n+    int TAG_UNICODE = 2;\n+\n+    \/** The value of constant pool tag UTF8. *\/\n+    int TAG_UTF8 = 1;\n+\n+    \/\/ annotation element values\n+\n+    \/** The value of annotation element value type AEV_BYTE. *\/\n+    int AEV_BYTE = 'B';\n+\n+    \/** The value of annotation element value type AEV_CHAR. *\/\n+    int AEV_CHAR = 'C';\n+\n+    \/** The value of annotation element value type AEV_DOUBLE. *\/\n+    int AEV_DOUBLE = 'D';\n+\n+    \/** The value of annotation element value type AEV_FLOAT. *\/\n+    int AEV_FLOAT = 'F';\n+\n+    \/** The value of annotation element value type AEV_INT. *\/\n+    int AEV_INT = 'I';\n+\n+    \/** The value of annotation element value type AEV_LONG. *\/\n+    int AEV_LONG = 'J';\n+\n+    \/** The value of annotation element value type AEV_SHORT. *\/\n+    int AEV_SHORT = 'S';\n+\n+    \/** The value of annotation element value type AEV_BOOLEAN. *\/\n+    int AEV_BOOLEAN = 'Z';\n+\n+    \/** The value of annotation element value type AEV_STRING. *\/\n+    int AEV_STRING = 's';\n+\n+    \/** The value of annotation element value type AEV_ENUM. *\/\n+    int AEV_ENUM = 'e';\n+\n+    \/** The value of annotation element value type AEV_CLASS. *\/\n+    int AEV_CLASS = 'c';\n+\n+    \/** The value of annotation element value type AEV_ANNOTATION. *\/\n+    int AEV_ANNOTATION = '@';\n+\n+    \/** The value of annotation element value type AEV_ARRAY. *\/\n+    int AEV_ARRAY = '[';\n+\n+    \/\/type annotations\n+\n+    \/** The value of type annotation target type CLASS_TYPE_PARAMETER. *\/\n+    int TAT_CLASS_TYPE_PARAMETER = 0x00;\n+\n+    \/** The value of type annotation target type METHOD_TYPE_PARAMETER. *\/\n+    int TAT_METHOD_TYPE_PARAMETER = 0x01;\n+\n+    \/** The value of type annotation target type CLASS_EXTENDS. *\/\n+    int TAT_CLASS_EXTENDS = 0x10;\n+\n+    \/** The value of type annotation target type CLASS_TYPE_PARAMETER_BOUND. *\/\n+    int TAT_CLASS_TYPE_PARAMETER_BOUND = 0x11;\n+\n+    \/** The value of type annotation target type METHOD_TYPE_PARAMETER_BOUND. *\/\n+    int TAT_METHOD_TYPE_PARAMETER_BOUND = 0x12;\n+\n+    \/** The value of type annotation target type FIELD. *\/\n+    int TAT_FIELD = 0x13;\n+\n+    \/** The value of type annotation target type METHOD_RETURN. *\/\n+    int TAT_METHOD_RETURN = 0x14;\n+\n+    \/** The value of type annotation target type METHOD_RECEIVER. *\/\n+    int TAT_METHOD_RECEIVER = 0x15;\n+\n+    \/** The value of type annotation target type METHOD_FORMAL_PARAMETER. *\/\n+    int TAT_METHOD_FORMAL_PARAMETER = 0x16;\n+\n+    \/** The value of type annotation target type THROWS. *\/\n+    int TAT_THROWS = 0x17;\n+\n+    \/** The value of type annotation target type LOCAL_VARIABLE. *\/\n+    int TAT_LOCAL_VARIABLE = 0x40;\n+\n+    \/** The value of type annotation target type RESOURCE_VARIABLE. *\/\n+    int TAT_RESOURCE_VARIABLE = 0x41;\n+\n+    \/** The value of type annotation target type EXCEPTION_PARAMETER. *\/\n+    int TAT_EXCEPTION_PARAMETER = 0x42;\n+\n+    \/** The value of type annotation target type INSTANCEOF. *\/\n+    int TAT_INSTANCEOF = 0x43;\n+\n+    \/** The value of type annotation target type NEW. *\/\n+    int TAT_NEW = 0x44;\n+\n+    \/** The value of type annotation target type CONSTRUCTOR_REFERENCE. *\/\n+    int TAT_CONSTRUCTOR_REFERENCE = 0x45;\n+\n+    \/** The value of type annotation target type METHOD_REFERENCE. *\/\n+    int TAT_METHOD_REFERENCE = 0x46;\n+\n+    \/** The value of type annotation target type CAST. *\/\n+    int TAT_CAST = 0x47;\n+\n+    \/** The value of type annotation target type CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT. *\/\n+    int TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;\n+\n+    \/** The value of type annotation target type METHOD_INVOCATION_TYPE_ARGUMENT. *\/\n+    int TAT_METHOD_INVOCATION_TYPE_ARGUMENT = 0x49;\n+\n+    \/** The value of type annotation target type CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT. *\/\n+    int TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 0x4A;\n+\n+    \/** The value of type annotation target type METHOD_REFERENCE_TYPE_ARGUMENT. *\/\n+    int TAT_METHOD_REFERENCE_TYPE_ARGUMENT = 0x4B;\n+\n+    \/\/stackmap verification types\n+\n+    \/** The value of verification type TOP. *\/\n+    int VT_TOP = 0;\n+\n+    \/** The value of verification type INTEGER. *\/\n+    int VT_INTEGER = 1;\n+\n+    \/** The value of verification type FLOAT. *\/\n+    int VT_FLOAT = 2;\n+\n+    \/** The value of verification type DOUBLE. *\/\n+    int VT_DOUBLE = 3;\n+\n+    \/** The value of verification type LONG. *\/\n+    int VT_LONG = 4;\n+\n+    \/** The value of verification type NULL. *\/\n+    int VT_NULL = 5;\n+\n+    \/** The value of verification type UNINITIALIZED_THIS. *\/\n+    int VT_UNINITIALIZED_THIS = 6;\n+\n+    \/** The value of verification type OBJECT. *\/\n+    int VT_OBJECT = 7;\n+\n+    \/** The value of verification type UNINITIALIZED. *\/\n+    int VT_UNINITIALIZED = 8;\n+\n+    \/** The value of default class access flags *\/\n+    int DEFAULT_CLASS_FLAGS = ACC_PUBLIC;\n+\n+    \/** The class major version of JAVA_1. *\/\n+    int JAVA_1_VERSION = 45;\n+\n+    \/** The class major version of JAVA_2. *\/\n+    int JAVA_2_VERSION = 46;\n+\n+    \/** The class major version of JAVA_3. *\/\n+    int JAVA_3_VERSION = 47;\n+\n+    \/** The class major version of JAVA_4. *\/\n+    int JAVA_4_VERSION = 48;\n+\n+    \/** The class major version of JAVA_5. *\/\n+    int JAVA_5_VERSION = 49;\n+\n+    \/** The class major version of JAVA_6. *\/\n+    int JAVA_6_VERSION = 50;\n+\n+    \/** The class major version of JAVA_7. *\/\n+    int JAVA_7_VERSION = 51;\n+\n+    \/** The class major version of JAVA_8. *\/\n+    int JAVA_8_VERSION = 52;\n+\n+    \/** The class major version of JAVA_9. *\/\n+    int JAVA_9_VERSION = 53;\n+\n+    \/** The class major version of JAVA_10. *\/\n+    int JAVA_10_VERSION = 54;\n+\n+    \/** The class major version of JAVA_11. *\/\n+    int JAVA_11_VERSION = 55;\n+\n+    \/** The class major version of JAVA_12. *\/\n+    int JAVA_12_VERSION = 56;\n+\n+    \/** The class major version of JAVA_13. *\/\n+    int JAVA_13_VERSION = 57;\n+\n+    \/** The class major version of JAVA_14. *\/\n+    int JAVA_14_VERSION = 58;\n+\n+    \/** The class major version of JAVA_15. *\/\n+    int JAVA_15_VERSION = 59;\n+\n+    \/** The class major version of JAVA_16. *\/\n+    int JAVA_16_VERSION = 60;\n+\n+    \/** The class major version of JAVA_17. *\/\n+    int JAVA_17_VERSION = 61;\n+\n+    \/** The class major version of JAVA_18. *\/\n+    int JAVA_18_VERSION = 62;\n+\n+    \/** The class major version of JAVA_19. *\/\n+    int JAVA_19_VERSION = 63;\n+\n+    \/** The class major version of JAVA_20. *\/\n+    int JAVA_20_VERSION = 64;\n+\n+    \/** The class major version of JAVA_21. *\/\n+    int JAVA_21_VERSION = 65;\n+\n+    \/** The class major version of JAVA_22. *\/\n+    int JAVA_22_VERSION = 66;\n+\n+    \/**\n+     * A minor version number indicating a class uses preview features\n+     * of a Java SE version since 12, for major versions {@value\n+     * #JAVA_12_VERSION} and above.\n+     *\/\n+    int PREVIEW_MINOR_VERSION = 65535;\n+\n+    \/**\n+     * {@return the latest major Java version}\n+     *\/\n+    static int latestMajorVersion() {\n+        return JAVA_22_VERSION;\n+    }\n+\n+    \/**\n+     * {@return the latest minor Java version}\n+     *\/\n+    static int latestMinorVersion() {\n+        return 0;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":1502,"deletions":0,"binary":false,"changes":1502,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package jdk.internal.classfile.attribute;\n+package java.lang.classfile.attribute;\n@@ -31,3 +31,3 @@\n-import jdk.internal.classfile.Attribute;\n-import jdk.internal.classfile.ClassElement;\n-import jdk.internal.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -37,0 +37,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -44,0 +45,1 @@\n+@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PreloadAttribute.java","additions":6,"deletions":4,"binary":false,"changes":10,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/PreloadAttribute.java","status":"renamed"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * <h2>Provides classfile parsing, generation, and transformation library.<\/h2>\n+ * The {@code java.lang.classfile} package contains classes for reading, writing, and\n+ * modifying Java class files, as specified in Chapter {@jvms 4} of the <cite>Java\n+ * Java Virtual Machine Specification<\/cite>.\n+ *\n+ * <h2>Reading classfiles<\/h2>\n+ * The main class for reading classfiles is {@link java.lang.classfile.ClassModel}; we\n+ * convert bytes into a {@link java.lang.classfile.ClassModel} with {@link\n+ * java.lang.classfile.ClassFile#parse(byte[])}:\n+ * <p>\n+ * {@snippet lang=java :\n+ * ClassModel cm = ClassFile.of().parse(bytes);\n+ * }\n+ * <p>\n+ * There are several additional overloads of {@code parse} that let you specify\n+ * various processing options.\n+ * <p>\n+ * A {@link java.lang.classfile.ClassModel} is an immutable description of a class\n+ * file.  It provides accessor methods to get at class metadata (e.g., {@link\n+ * java.lang.classfile.ClassModel#thisClass()}, {@link java.lang.classfile.ClassModel#flags()}),\n+ * as well as subordinate classfile entities ({@link java.lang.classfile.ClassModel#fields()},\n+ * {@link java.lang.classfile.ClassModel#attributes()}). A {@link\n+ * java.lang.classfile.ClassModel} is inflated lazily; most parts of the classfile are\n+ * not parsed until they are actually needed.\n+ * <p>\n+ * We can enumerate the names of the fields and methods in a class by:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"enumerateFieldsMethods1\"}\n+ * <p>\n+ * When we enumerate the methods, we get a {@link java.lang.classfile.MethodModel} for each method; like a\n+ * {@code ClassModel}, it gives us access to method metadata and\n+ * the ability to descend into subordinate entities such as the bytecodes of the\n+ * method body. In this way, a {@code ClassModel} is the root of a\n+ * tree, with children for fields, methods, and attributes, and {@code MethodModel} in\n+ * turn has its own children (attributes, {@code CodeModel}, etc.)\n+ * <p>\n+ * Methods like {@link java.lang.classfile.ClassModel#methods} allows us to traverse the class structure\n+ * explicitly, going straight to the parts we are interested in.  This is useful\n+ * for certain kinds of analysis, but if we wanted to process the whole\n+ * classfile, we may want something more organized.  A {@link\n+ * java.lang.classfile.ClassModel} also provides us with a view of the classfile as a\n+ * series of class <em>elements<\/em>, which may include methods, fields, attributes,\n+ * and more, and which can be distinguished with pattern matching.  We could\n+ * rewrite the above example as:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"enumerateFieldsMethods2\"}\n+ * <p>\n+ * The models returned as elements from traversing {@code ClassModel} can in\n+ * turn be sources of elements.  If we wanted to\n+ * traverse a classfile and enumerate all the classes for which we access fields\n+ * and methods, we can pick out the class elements that describe methods, then\n+ * in turn pick out the method elements that describe the code attribute, and\n+ * finally pick out the code elements that describe field access and invocation\n+ * instructions:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"gatherDependencies1\"}\n+ * <p>\n+ * This same query could alternately be processed as a stream pipeline over\n+ * class elements:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"gatherDependencies2\"}\n+ *\n+ * <h3>Models and elements<\/h3>\n+ * The view of classfiles presented by this API is framed in terms of\n+ * <em>models<\/em> and <em>elements<\/em>.  Models represent complex structures,\n+ * such as classes, methods, fields, record elements, or the code body of a\n+ * method.  Models can be explored either via random-access navigation (such as\n+ * the {@link java.lang.classfile.ClassModel#methods()} accessor) or as a linear\n+ * sequence of <em>elements<\/em>. (Elements can in turn also be models; a {@link\n+ * java.lang.classfile.FieldModel} is also an element of a class.) For each model type\n+ * (e.g., {@link java.lang.classfile.MethodModel}), there is a corresponding element\n+ * type ({@link java.lang.classfile.MethodElement}).  Models and elements are immutable\n+ * and are inflated lazily so creating a model does not necessarily require\n+ * processing its entire content.\n+ *\n+ * <h3>The constant pool<\/h3>\n+ * Much of the interesting content in a classfile lives in the <em>constant\n+ * pool<\/em>. {@link java.lang.classfile.ClassModel} provides a lazily-inflated,\n+ * read-only view of the constant pool via {@link java.lang.classfile.ClassModel#constantPool()}.\n+ * Descriptions of classfile content is often exposed in the form of various\n+ * subtypes of {@link java.lang.classfile.constantpool.PoolEntry}, such as {@link\n+ * java.lang.classfile.constantpool.ClassEntry} or {@link java.lang.classfile.constantpool.Utf8Entry}.\n+ * <p>\n+ * Constant pool entries are also exposed through models and elements; in the\n+ * above traversal example, the {@link java.lang.classfile.instruction.InvokeInstruction}\n+ * element exposed a method for {@code owner} that corresponds to a {@code\n+ * Constant_Class_info} entry in the constant pool.\n+ *\n+ * <h3>Attributes<\/h3>\n+ * Much of the contents of a classfile is stored in attributes; attributes are\n+ * found on classes, methods, fields, record components, and on the {@code Code}\n+ * attribute.  Most attributes are surfaced as elements; for example, {@link\n+ * java.lang.classfile.attribute.SignatureAttribute} is a {@link\n+ * java.lang.classfile.ClassElement}, {@link java.lang.classfile.MethodElement}, and {@link\n+ * java.lang.classfile.FieldElement} since it can appear in all of those places, and is\n+ * included when iterating the elements of the corresponding model.\n+ * <p>\n+ * Some attributes are not surfaced as elements; these are attributes that are\n+ * tightly coupled to -- and logically part of -- other parts of the class file.\n+ * These include the {@code BootstrapMethods}, {@code LineNumberTable}, {@code\n+ * StackMapTable}, {@code LocalVariableTable}, and {@code\n+ * LocalVariableTypeTable} attributes.  These are processed by the library and\n+ * treated as part of the structure they are coupled to (the entries of the\n+ * {@code BootstrapMethods} attribute are treated as part of the constant pool;\n+ * line numbers and local variable metadata are modeled as elements of {@link\n+ * java.lang.classfile.CodeModel}.)\n+ * <p>\n+ * The {@code Code} attribute, in addition to being modeled as a {@link\n+ * java.lang.classfile.MethodElement}, is also a model in its own right ({@link\n+ * java.lang.classfile.CodeModel}) due to its complex structure.\n+ * <p>\n+ * Each standard attribute has an interface (in {@code java.lang.classfile.attribute})\n+ * which exposes the contents of the attribute and provides factories to\n+ * construct the attribute.  For example, the {@code Signature} attribute is\n+ * defined by the {@link java.lang.classfile.attribute.SignatureAttribute} class, and\n+ * provides accessors for {@link java.lang.classfile.attribute.SignatureAttribute#signature()}\n+ * as well as factories taking {@link java.lang.classfile.constantpool.Utf8Entry} or\n+ * {@link java.lang.String}.\n+ *\n+ * <h3>Custom attributes<\/h3>\n+ * Attributes are converted between their classfile form and their corresponding\n+ * object form via an {@link java.lang.classfile.AttributeMapper}.  An {@code\n+ * AttributeMapper} provides the\n+ * {@link java.lang.classfile.AttributeMapper#readAttribute(AttributedElement,\n+ * ClassReader, int)} method for mapping from the classfile format\n+ * to an attribute instance, and the\n+ * {@link java.lang.classfile.AttributeMapper#writeAttribute(java.lang.classfile.BufWriter,\n+ * java.lang.Object)} method for mapping back to the classfile format.  It also\n+ * contains metadata including the attribute name, the set of classfile entities\n+ * where the attribute is applicable, and whether multiple attributes of the\n+ * same kind are allowed on a single entity.\n+ * <p>\n+ * There are built-in attribute mappers (in {@link java.lang.classfile.Attributes}) for\n+ * each of the attribute types defined in section {@jvms 4.7} of <cite>The Java Virtual\n+ * Machine Specification<\/cite>, as well as several common nonstandard attributes used by the\n+ * JDK such as {@code CharacterRangeTable}.\n+ * <p>\n+ * Unrecognized attributes are delivered as elements of type {@link\n+ * java.lang.classfile.attribute.UnknownAttribute}, which provide access only to the\n+ * {@code byte[]} contents of the attribute.\n+ * <p>\n+ * For nonstandard attributes, user-provided attribute mappers can be specified\n+ * through the use of the {@link\n+ * java.lang.classfile.ClassFile.AttributeMapperOption#of(java.util.function.Function)}}\n+ * classfile option.  Implementations of custom attributes should extend {@link\n+ * java.lang.classfile.CustomAttribute}.\n+ *\n+ * <h3>Options<\/h3>\n+ * <p>\n+ * {@link java.lang.classfile.ClassFile#of(java.lang.classfile.ClassFile.Option[])}\n+ * accepts a list of options.  {@link java.lang.classfile.ClassFile.Option} is a base interface\n+ * for some statically enumerated options, as well as factories for more complex options,\n+ * including:\n+ * <ul>\n+ *   <li>{@link java.lang.classfile.ClassFile.StackMapsOption}\n+ * -- generate stackmaps (default is {@code STACK_MAPS_WHEN_REQUIRED})<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.DebugElementsOption}\n+ * -- processing of debug information, such as local variable metadata (default is {@code PASS_DEBUG}) <\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.LineNumbersOption}\n+ * -- processing of line numbers (default is {@code PASS_LINE_NUMBERS}) <\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.AttributesProcessingOption}\n+ * -- unrecognized or problematic original attributes (default is {@code PASS_ALL_ATTRIBUTES})<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.ConstantPoolSharingOption}}\n+ * -- share constant pool when transforming (default is {@code SHARED_POOL})<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.ClassHierarchyResolverOption#of(java.lang.classfile.ClassHierarchyResolver)}\n+ * -- specify a custom class hierarchy resolver used by stack map generation<\/li>\n+ *   <li>{@link java.lang.classfile.ClassFile.AttributeMapperOption#of(java.util.function.Function)}\n+ * -- specify format of custom attributes<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Most options allow you to request that certain parts of the classfile be\n+ * skipped during traversal, such as debug information or unrecognized\n+ * attributes.  Some options allow you to suppress generation of portions of the\n+ * classfile, such as stack maps.  Many of these options are to access\n+ * performance tradeoffs; processing debug information and line numbers has a\n+ * cost (both in writing and reading.)  If you don't need this information, you\n+ * can suppress it with options to gain some performance.\n+ *\n+ * <h2>Writing classfiles<\/h2>\n+ * ClassFile generation is accomplished through <em>builders<\/em>.  For each\n+ * entity type that has a model, there is also a corresponding builder type;\n+ * classes are built through {@link java.lang.classfile.ClassBuilder}, methods through\n+ * {@link java.lang.classfile.MethodBuilder}, etc.\n+ * <p>\n+ * Rather than creating builders directly, builders are provided as an argument\n+ * to a user-provided lambda.  To generate the familiar \"hello world\" program,\n+ * we ask for a class builder, and use that class builder to create method\n+ * builders for the constructor and {@code main} method, and in turn use the\n+ * method builders to create a {@code Code} attribute and use the code builders\n+ * to generate the instructions:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"helloWorld1\"}\n+ * <p>\n+ * The convenience methods {@code ClassBuilder.buildMethodBody} allows us to ask\n+ * {@link ClassBuilder} to create code builders to build method bodies directly,\n+ * skipping the method builder custom lambda:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"helloWorld2\"}\n+ * <p>\n+ * Builders often support multiple ways of expressing the same entity at\n+ * different levels of abstraction.  For example, the {@code invokevirtual}\n+ * instruction invoking {@code println} could have been generated with {@link\n+ * java.lang.classfile.CodeBuilder#invokevirtual(java.lang.constant.ClassDesc,\n+ * java.lang.String, java.lang.constant.MethodTypeDesc) CodeBuilder.invokevirtual}, {@link\n+ * java.lang.classfile.CodeBuilder#invokeInstruction(java.lang.classfile.Opcode,\n+ * java.lang.constant.ClassDesc, java.lang.String, java.lang.constant.MethodTypeDesc,\n+ * boolean) CodeBuilder.invokeInstruction}, or {@link\n+ * java.lang.classfile.CodeBuilder#with(java.lang.classfile.ClassFileElement)\n+ * CodeBuilder.with}.\n+ * <p>\n+ * The convenience method {@code CodeBuilder.invokevirtual} behaves as if it calls\n+ * the convenience method {@code CodeBuilder.invokeInstruction}, which in turn behaves\n+ * as if it calls method {@code CodeBuilder.with}. This composing of method calls on the\n+ * builder enables the composing of transforms (as described later).\n+ *\n+ * <h3>Symbolic information<\/h3>\n+ * To describe symbolic information for classes and types, the API uses the\n+ * nominal descriptor abstractions from {@code java.lang.constant} such as {@link\n+ * java.lang.constant.ClassDesc} and {@link java.lang.constant.MethodTypeDesc},\n+ * which is less error-prone than using raw strings.\n+ * <p>\n+ * If a constant pool entry has a nominal representation then it provides a\n+ * method returning the corresponding nominal descriptor type e.g.\n+ * method {@link java.lang.classfile.constantpool.ClassEntry#asSymbol} returns\n+ * {@code ClassDesc}.\n+ * <p>\n+ * Where appropriate builders provide two methods for building an element with\n+ * symbolic information, one accepting nominal descriptors, and the other\n+ * accepting constant pool entries.\n+ *\n+ * <h3>Consistency checks, syntax checks and verification<\/h3>\n+ * No consistency checks are performed while building or transforming classfiles\n+ * (except for null arguments checks). All builders and classfile elements factory\n+ * methods accepts the provided information without implicit validation.\n+ * However, fatal inconsistencies (like for example invalid code sequence or\n+ * unresolved labels) affects internal tools and may cause exceptions later in\n+ * the classfile building process.\n+ * <p>\n+ * Using nominal descriptors assures the right serial form is applied by the\n+ * ClassFile API library based on the actual context. Also these nominal\n+ * descriptors are validated during their construction, so it is not possible to\n+ * create them with invalid content by mistake. Following example pass class\n+ * name to the {@link java.lang.constant.ClassDesc#of} method for validation\n+ * and the library performs automatic conversion to the right internal form of\n+ * the class name when serialized in the constant pool as a class entry.\n+ * {@snippet lang=java :\n+ * var validClassEntry = constantPoolBuilder.classEntry(ClassDesc.of(\"mypackage.MyClass\"));\n+ * }\n+ * <p>\n+ * On the other hand it is possible to use builders methods and factories accepting\n+ * constant pool entries directly. Constant pool entries can be constructed also\n+ * directly from raw values, with no additional conversions or validations.\n+ * Following example uses intentionally wrong class name form and it is applied\n+ * without any validation or conversion.\n+ * {@snippet lang=java :\n+ * var invalidClassEntry = constantPoolBuilder.classEntry(\n+ *                             constantPoolBuilder.utf8Entry(\"mypackage.MyClass\"));\n+ * }\n+ * <p>\n+ * More complex verification of a classfile can be achieved by invocation of\n+ * {@link java.lang.classfile.ClassFile#verify}.\n+ *\n+ * <h2>Transforming classfiles<\/h2>\n+ * ClassFile Processing APIs are most frequently used to combine reading and\n+ * writing into transformation, where a classfile is read, localized changes are\n+ * made, but much of the classfile is passed through unchanged.  For each kind\n+ * of builder, {@code XxxBuilder} has a method {@code with(XxxElement)} so that\n+ * elements that we wish to pass through unchanged can be handed directly back\n+ * to the builder.\n+ * <p>\n+ * If we wanted to strip out methods whose names starts with \"debug\", we could\n+ * get an existing {@link java.lang.classfile.ClassModel}, build a new classfile that\n+ * provides a {@link java.lang.classfile.ClassBuilder}, iterate the elements of the\n+ * original {@link java.lang.classfile.ClassModel}, and pass through all of them to\n+ * the builder except the methods we want to drop:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"stripDebugMethods1\"}\n+ * <p>\n+ * This hands every class element, except for those corresponding to methods\n+ * whose names start with {@code debug}, back to the builder.  Transformations\n+ * can of course be more complicated, diving into method bodies and instructions\n+ * and transforming those as well, but the same structure is repeated at every\n+ * level, since every entity has corresponding model, builder, and element\n+ * abstractions.\n+ * <p>\n+ * Transformation can be viewed as a \"flatMap\" operation on the sequence of\n+ * elements; for every element, we could pass it through unchanged, drop it, or\n+ * replace it with one or more elements.  Because transformation is such a\n+ * common operation on classfiles, each model type has a corresponding {@code\n+ * XxxTransform} type (which describes a transform on a sequence of {@code\n+ * XxxElement}) and each builder type has {@code transformYyy} methods for transforming\n+ * its child models.  A transform is simply a functional interface that takes a\n+ * builder and an element, and an implementation \"flatMap\"s elements\n+ * into the builder.  We could express the above as:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"stripDebugMethods2\"}\n+ * <p>\n+ * {@code ClassTransform.dropping} convenience method allow us to simplify the same\n+ * transformation construction and express the above as:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"stripDebugMethods3\"}\n+ *\n+ * <h3>Lifting transforms<\/h3>\n+ * While the example using transformations are only slightly shorter, the\n+ * advantage of expressing transformation in this way is that the transform\n+ * operations can be more easily combined.  Suppose we want to redirect\n+ * invocations of static methods on {@code Foo} to the corresponding method on\n+ * {@code Bar} instead.  We could express this as a transformation on {@link\n+ * java.lang.classfile.CodeElement}:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"fooToBarTransform\"}\n+ * <p>\n+ * We can then <em>lift<\/em> this transformation on code elements into a\n+ * transformation on method elements.  This intercepts method elements that\n+ * correspond to a {@code Code} attribute, dives into its code elements, and\n+ * applies the code transform to them, and passes other method elements through\n+ * unchanged:\n+ * {@snippet lang=java :\n+ * MethodTransform mt = MethodTransform.transformingCode(fooToBar);\n+ * }\n+ * <p>\n+ * and further lift the transform on method elements into one on class\n+ * elements:\n+ * {@snippet lang=java :\n+ * ClassTransform ct = ClassTransform.transformingMethods(mt);\n+ * }\n+ * <p>\n+ * or lift the code transform into the class transform directly:\n+ * {@snippet lang=java :\n+ * ClassTransform ct = ClassTransform.transformingMethodBodiess(fooToBar);\n+ * }\n+ * <p>\n+ * and then transform the classfile:\n+ * {@snippet lang=java :\n+ * var cc = ClassFile.of();\n+ * byte[] newBytes = cc.transform(cc.parse(bytes), ct);\n+ * }\n+ * <p>\n+ * This is much more concise (and less error-prone) than the equivalent\n+ * expressed by traversing the classfile structure directly:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"fooToBarUnrolled\"}\n+ *\n+ * <h3>Composing transforms<\/h3>\n+ * Transforms on the same type of element can be composed in sequence, where the\n+ * output of the first is fed to the input of the second.  Suppose we want to\n+ * instrument all method calls, where we print the name of a method before\n+ * calling it:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"instrumentCallsTransform\"}\n+ * <p>\n+ * Then we can compose {@code fooToBar} and {@code instrumentCalls} with {@link\n+ * java.lang.classfile.CodeTransform#andThen(java.lang.classfile.CodeTransform)}:\n+ * <p>\n+ * {@snippet lang=java :\n+ * var cc = ClassFile.of();\n+ * byte[] newBytes = cc.transform(cc.parse(bytes),\n+ *                                ClassTransform.transformingMethods(\n+ *                                    MethodTransform.transformingCode(\n+ *                                        fooToBar.andThen(instrumentCalls))));\n+ * }\n+ *\n+ * Transform {@code instrumentCalls} will receive all code elements produced by\n+ * transform {@code forToBar}, either those code elements from the original classfile\n+ * or replacements (replacing static invocations to {@code Foo} with those to {@code Bar}).\n+ *\n+ * <h3>Constant pool sharing<\/h3>\n+ * Transformation doesn't merely handle the logistics of reading, transforming\n+ * elements, and writing.  Most of the time when we are transforming a\n+ * classfile, we are making relatively minor changes.  To optimize such cases,\n+ * transformation seeds the new classfile with a copy of the constant pool from\n+ * the original classfile; this enables significant optimizations (methods and\n+ * attributes that are not transformed can be processed by bulk-copying their\n+ * bytes, rather than parsing them and regenerating their contents.)  If\n+ * constant pool sharing is not desired it can be suppressed\n+ * with the {@link java.lang.classfile.ClassFile.ConstantPoolSharingOption} option.\n+ * Such suppression may be beneficial when transformation removes many elements,\n+ * resulting in many unreferenced constant pool entries.\n+ *\n+ * <h3>Transformation handling of unknown classfile elements<\/h3>\n+ * Custom classfile transformations might be unaware of classfile elements\n+ * introduced by future JDK releases. To achieve deterministic stability,\n+ * classfile transforms interested in consuming all classfile elements should be\n+ * implemented strictly to throw exceptions if running on a newer JDK, if the\n+ * transformed class file is a newer version, or if a new and unknown classfile\n+ * element appears. As for example in the following strict compatibility-checking\n+ * transformation snippets:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"strictTransform1\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"strictTransform2\"}\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"strictTransform3\"}\n+ * <p>\n+ * Conversely, classfile transforms that are only interested in consuming a portion\n+ * of classfile elements do not need to concern with new and unknown classfile\n+ * elements and may pass them through. Following example shows such future-proof\n+ * code transformation:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"benevolentTransform\"}\n+ *\n+ * <h2>API conventions<\/h2>\n+ * <p>\n+ * The API is largely derived from a <a href=\"#data_model\"><em>data model<\/em><\/a>\n+ * for the classfile format, which defines each element kind (which includes models and\n+ * attributes) and its properties.  For each element kind, there is a\n+ * corresponding interface to describe that element, and factory methods to\n+ * create that element.  Some element kinds also have convenience methods on the\n+ * corresponding builder (e.g., {@link\n+ * java.lang.classfile.CodeBuilder#invokevirtual(java.lang.constant.ClassDesc,\n+ * java.lang.String, java.lang.constant.MethodTypeDesc)}).\n+ * <p>\n+ * Most symbolic information in elements is represented by constant pool entries\n+ * (for example, the owner of a field is represented by a {@link\n+ * java.lang.classfile.constantpool.ClassEntry}.) Factories and builders also\n+ * accept nominal descriptors from {@code java.lang.constant} (e.g., {@link\n+ * java.lang.constant.ClassDesc}.)\n+ *\n+ * <h2><a id=\"data_model\"><\/a>Data model<\/h2>\n+ * We define each kind of element by its name, an optional arity indicator (zero\n+ * or more, zero or one, exactly one), and a list of components.  The elements\n+ * of a class are fields, methods, and the attributes that can appear on\n+ * classes:\n+ * <p>\n+ * {@snippet lang=\"text\" :\n+ * ClassElement =\n+ *     FieldModel*(UtfEntry name, Utf8Entry descriptor)\n+ *     | MethodModel*(UtfEntry name, Utf8Entry descriptor)\n+ *     | ModuleAttribute?(int flags, ModuleEntry moduleName, UtfEntry moduleVersion,\n+ *                        List<ModuleRequireInfo> requires, List<ModuleOpenInfo> opens,\n+ *                        List<ModuleExportInfo> exports, List<ModuleProvidesInfo> provides,\n+ *                        List<ClassEntry> uses)\n+ *     | ModulePackagesAttribute?(List<PackageEntry> packages)\n+ *     | ModuleTargetAttribute?(Utf8Entry targetPlatform)\n+ *     | ModuleHashesAttribute?(Utf8Entry algorithm, List<HashInfo> hashes)\n+ *     | ModuleResolutionAttribute?(int resolutionFlags)\n+ *     | SourceFileAttribute?(Utf8Entry sourceFile)\n+ *     | SourceDebugExtensionsAttribute?(byte[] contents)\n+ *     | CompilationIDAttribute?(Utf8Entry compilationId)\n+ *     | SourceIDAttribute?(Utf8Entry sourceId)\n+ *     | NestHostAttribute?(ClassEntry nestHost)\n+ *     | NestMembersAttribute?(List<ClassEntry> nestMembers)\n+ *     | RecordAttribute?(List<RecordComponent> components)\n+ *     | EnclosingMethodAttribute?(ClassEntry className, NameAndTypeEntry method)\n+ *     | InnerClassesAttribute?(List<InnerClassInfo> classes)\n+ *     | PermittedSubclassesAttribute?(List<ClassEntry> permittedSubclasses)\n+ *     | PreloadAttribute?(List<ClassEntry> preloads)\n+ *     | DeclarationElement*\n+ * }\n+ *<p>\n+ * where {@code DeclarationElement} are the elements that are common to all declarations\n+ * (classes,  methods, fields) and so are factored out:\n+ *\n+ * {@snippet lang=\"text\" :\n+ * DeclarationElement =\n+ *     SignatureAttribute?(Utf8Entry signature)\n+ *     | SyntheticAttribute?()\n+ *     | DeprecatedAttribute?()\n+ *     | RuntimeInvisibleAnnotationsAttribute?(List<Annotation> annotations)\n+ *     | RuntimeVisibleAnnotationsAttribute?(List<Annotation> annotations)\n+ *     | CustomAttribute*\n+ *     | UnknownAttribute*\n+ * }\n+ *\n+ * Fields and methods are models with their own elements.  The elements of fields\n+ * and methods are fairly simple; most of the complexity of methods lives in the\n+ * {@link java.lang.classfile.CodeModel} (which models the {@code Code} attribute\n+ * along with the code-related attributes: stack map table, local variable table,\n+ * line number table, etc.)\n+ *\n+ * {@snippet lang=\"text\" :\n+ * FieldElement =\n+ *     DeclarationElement\n+ *     | ConstantValueAttribute?(ConstantValueEntry constant)\n+ *\n+ * MethodElement =\n+ *     DeclarationElement\n+ *     | CodeModel?()\n+ *     | AnnotationDefaultAttribute?(ElementValue defaultValue)\n+ *     | MethodParametersAttribute?(List<MethodParameterInfo> parameters)\n+ *     | ExceptionsAttribute?(List<ClassEntry> exceptions)\n+ * }\n+ *\n+ * {@link java.lang.classfile.CodeModel} is unique in that its elements are <em>ordered<\/em>.\n+ * Elements of {@code Code} include ordinary bytecodes, as well as a number of pseudo-instructions\n+ * representing branch targets, line number metadata, local variable metadata, and\n+ * catch blocks.\n+ *\n+ * {@snippet lang=\"text\" :\n+ * CodeElement = Instruction | PseudoInstruction\n+ *\n+ * Instruction =\n+ *     LoadInstruction(TypeKind type, int slot)\n+ *     | StoreInstruction(TypeKind type, int slot)\n+ *     | IncrementInstruction(int slot, int constant)\n+ *     | BranchInstruction(Opcode opcode, Label target)\n+ *     | LookupSwitchInstruction(Label defaultTarget, List<SwitchCase> cases)\n+ *     | TableSwitchInstruction(Label defaultTarget, int low, int high,\n+ *                              List<SwitchCase> cases)\n+ *     | ReturnInstruction(TypeKind kind)\n+ *     | ThrowInstruction()\n+ *     | FieldInstruction(Opcode opcode, FieldRefEntry field)\n+ *     | InvokeInstruction(Opcode opcode, MemberRefEntry method, boolean isInterface)\n+ *     | InvokeDynamicInstruction(InvokeDynamicEntry invokedynamic)\n+ *     | NewObjectInstruction(ClassEntry className)\n+ *     | NewReferenceArrayInstruction(ClassEntry componentType)\n+ *     | NewPrimitiveArrayInstruction(TypeKind typeKind)\n+ *     | NewMultiArrayInstruction(ClassEntry componentType, int dims)\n+ *     | ArrayLoadInstruction(Opcode opcode)\n+ *     | ArrayStoreInstruction(Opcode opcode)\n+ *     | TypeCheckInstruction(Opcode opcode, ClassEntry className)\n+ *     | ConvertInstruction(TypeKind from, TypeKind to)\n+ *     | OperatorInstruction(Opcode opcode)\n+ *     | ConstantInstruction(ConstantDesc constant)\n+ *     | StackInstruction(Opcode opcode)\n+ *     | MonitorInstruction(Opcode opcode)\n+ *     | NopInstruction()\n+ *\n+ * PseudoInstruction =\n+ *     | LabelTarget(Label label)\n+ *     | LineNumber(int line)\n+ *     | ExceptionCatch(Label tryStart, Label tryEnd, Label handler, ClassEntry exception)\n+ *     | LocalVariable(int slot, UtfEntry name, Utf8Entry type, Label startScope, Label endScope)\n+ *     | LocalVariableType(int slot, Utf8Entry name, Utf8Entry type, Label startScope, Label endScope)\n+ *     | CharacterRange(int rangeStart, int rangeEnd, int flags, Label startScope, Label endScope)\n+ * }\n+ *\n+ * @since 22\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+package java.lang.classfile;\n+\n+import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"},{"patch":"@@ -51,4 +51,4 @@\n-import jdk.internal.classfile.ClassHierarchyResolver;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.TypeKind;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n@@ -66,1 +66,1 @@\n-import static jdk.internal.classfile.Classfile.*;\n+import static java.lang.classfile.ClassFile.*;\n@@ -371,1 +371,1 @@\n-        return Classfile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n+        return ClassFile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,3 +45,3 @@\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.Label;\n-import jdk.internal.classfile.instruction.SwitchCase;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.instruction.SwitchCase;\n@@ -390,1 +390,1 @@\n-        byte[] classBytes = Classfile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n+        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n@@ -394,1 +394,1 @@\n-                               Classfile.ACC_FINAL | Classfile.ACC_PUBLIC | Classfile.ACC_STATIC,\n+                               ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,5 @@\n+    \/**\n+     * Return most specific method that matches name and parameterTypes.\n+     *\/\n+    Method findMethod(Class<?> klass, boolean publicOnly, String name, Class<?>... parameterTypes);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,10 +34,10 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.*;\n-import jdk.internal.classfile.constantpool.ClassEntry;\n-import jdk.internal.classfile.constantpool.ConstantPool;\n-import jdk.internal.classfile.constantpool.ConstantValueEntry;\n-import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n-import jdk.internal.classfile.constantpool.ModuleEntry;\n-import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n-import jdk.internal.classfile.constantpool.PackageEntry;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPool;\n+import java.lang.classfile.constantpool.ConstantValueEntry;\n+import java.lang.classfile.constantpool.LoadableConstantEntry;\n+import java.lang.classfile.constantpool.ModuleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.PackageEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import jdk.internal.classfile.Annotation;\n+import java.lang.classfile.Annotation;\n@@ -46,14 +46,14 @@\n-import jdk.internal.classfile.AnnotationElement;\n-import jdk.internal.classfile.AnnotationValue;\n-import jdk.internal.classfile.AnnotationValue.*;\n-import jdk.internal.classfile.Attribute;\n-import jdk.internal.classfile.ClassModel;\n-import jdk.internal.classfile.components.ClassPrinter.*;\n-import jdk.internal.classfile.CodeModel;\n-import jdk.internal.classfile.Instruction;\n-import jdk.internal.classfile.MethodModel;\n-import jdk.internal.classfile.TypeAnnotation;\n-import jdk.internal.classfile.attribute.*;\n-import jdk.internal.classfile.attribute.StackMapFrameInfo.*;\n-import jdk.internal.classfile.constantpool.*;\n-import jdk.internal.classfile.instruction.*;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.AnnotationValue.*;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.components.ClassPrinter.*;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.instruction.*;\n@@ -61,3 +61,3 @@\n-import static jdk.internal.classfile.Classfile.*;\n-import jdk.internal.classfile.CompoundElement;\n-import jdk.internal.classfile.FieldModel;\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.CompoundElement;\n+import java.lang.classfile.FieldModel;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,56 +27,56 @@\n-import jdk.internal.classfile.Annotation;\n-import jdk.internal.classfile.AnnotationElement;\n-import jdk.internal.classfile.AnnotationValue;\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.ClassElement;\n-import jdk.internal.classfile.ClassSignature;\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n-import jdk.internal.classfile.CodeModel;\n-import jdk.internal.classfile.CodeTransform;\n-import jdk.internal.classfile.FieldBuilder;\n-import jdk.internal.classfile.FieldElement;\n-import jdk.internal.classfile.FieldModel;\n-import jdk.internal.classfile.FieldTransform;\n-import jdk.internal.classfile.Interfaces;\n-import jdk.internal.classfile.MethodBuilder;\n-import jdk.internal.classfile.MethodElement;\n-import jdk.internal.classfile.MethodModel;\n-import jdk.internal.classfile.MethodSignature;\n-import jdk.internal.classfile.MethodTransform;\n-import jdk.internal.classfile.Signature;\n-import jdk.internal.classfile.Superclass;\n-import jdk.internal.classfile.TypeAnnotation;\n-import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n-import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n-import jdk.internal.classfile.attribute.ExceptionsAttribute;\n-import jdk.internal.classfile.attribute.InnerClassInfo;\n-import jdk.internal.classfile.attribute.InnerClassesAttribute;\n-import jdk.internal.classfile.attribute.ModuleAttribute;\n-import jdk.internal.classfile.attribute.ModuleProvideInfo;\n-import jdk.internal.classfile.attribute.NestHostAttribute;\n-import jdk.internal.classfile.attribute.NestMembersAttribute;\n-import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n-import jdk.internal.classfile.attribute.PreloadAttribute;\n-import jdk.internal.classfile.attribute.RecordAttribute;\n-import jdk.internal.classfile.attribute.RecordComponentInfo;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.SignatureAttribute;\n-import jdk.internal.classfile.components.ClassRemapper;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n-import jdk.internal.classfile.instruction.ConstantInstruction.LoadConstantInstruction;\n-import jdk.internal.classfile.instruction.ExceptionCatch;\n-import jdk.internal.classfile.instruction.FieldInstruction;\n-import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n-import jdk.internal.classfile.instruction.InvokeInstruction;\n-import jdk.internal.classfile.instruction.LocalVariable;\n-import jdk.internal.classfile.instruction.LocalVariableType;\n-import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n-import jdk.internal.classfile.instruction.NewObjectInstruction;\n-import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n-import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassSignature;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.FieldBuilder;\n+import java.lang.classfile.FieldElement;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.FieldTransform;\n+import java.lang.classfile.Interfaces;\n+import java.lang.classfile.MethodBuilder;\n+import java.lang.classfile.MethodElement;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodSignature;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.Signature;\n+import java.lang.classfile.Superclass;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleProvideInfo;\n+import java.lang.classfile.attribute.NestHostAttribute;\n+import java.lang.classfile.attribute.NestMembersAttribute;\n+import java.lang.classfile.attribute.PreloadAttribute;\n+import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RecordComponentInfo;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.components.ClassRemapper;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.instruction.ConstantInstruction.LoadConstantInstruction;\n+import java.lang.classfile.instruction.ExceptionCatch;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.LocalVariable;\n+import java.lang.classfile.instruction.LocalVariableType;\n+import java.lang.classfile.instruction.NewMultiArrayInstruction;\n+import java.lang.classfile.instruction.NewObjectInstruction;\n+import java.lang.classfile.instruction.NewReferenceArrayInstruction;\n+import java.lang.classfile.instruction.TypeCheckInstruction;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -31,65 +31,65 @@\n-import jdk.internal.classfile.Annotation;\n-import jdk.internal.classfile.AnnotationElement;\n-import jdk.internal.classfile.AnnotationValue;\n-import jdk.internal.classfile.Attribute;\n-import jdk.internal.classfile.AttributeMapper;\n-import jdk.internal.classfile.Attributes;\n-import jdk.internal.classfile.BootstrapMethodEntry;\n-import jdk.internal.classfile.BufWriter;\n-import jdk.internal.classfile.constantpool.ClassEntry;\n-import jdk.internal.classfile.Label;\n-import jdk.internal.classfile.TypeAnnotation;\n-import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n-import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n-import jdk.internal.classfile.attribute.CharacterRangeInfo;\n-import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n-import jdk.internal.classfile.attribute.CompilationIDAttribute;\n-import jdk.internal.classfile.attribute.ConstantValueAttribute;\n-import jdk.internal.classfile.attribute.DeprecatedAttribute;\n-import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n-import jdk.internal.classfile.attribute.ExceptionsAttribute;\n-import jdk.internal.classfile.attribute.InnerClassInfo;\n-import jdk.internal.classfile.attribute.InnerClassesAttribute;\n-import jdk.internal.classfile.attribute.LineNumberInfo;\n-import jdk.internal.classfile.attribute.LineNumberTableAttribute;\n-import jdk.internal.classfile.attribute.LocalVariableInfo;\n-import jdk.internal.classfile.attribute.LocalVariableTableAttribute;\n-import jdk.internal.classfile.attribute.LocalVariableTypeInfo;\n-import jdk.internal.classfile.attribute.LocalVariableTypeTableAttribute;\n-import jdk.internal.classfile.attribute.MethodParameterInfo;\n-import jdk.internal.classfile.attribute.MethodParametersAttribute;\n-import jdk.internal.classfile.attribute.ModuleAttribute;\n-import jdk.internal.classfile.attribute.ModuleExportInfo;\n-import jdk.internal.classfile.attribute.ModuleHashInfo;\n-import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n-import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n-import jdk.internal.classfile.attribute.ModuleOpenInfo;\n-import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n-import jdk.internal.classfile.attribute.ModuleProvideInfo;\n-import jdk.internal.classfile.attribute.ModuleRequireInfo;\n-import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n-import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n-import jdk.internal.classfile.attribute.NestHostAttribute;\n-import jdk.internal.classfile.attribute.NestMembersAttribute;\n-import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n-import jdk.internal.classfile.attribute.PreloadAttribute;\n-import jdk.internal.classfile.attribute.RecordAttribute;\n-import jdk.internal.classfile.attribute.RecordComponentInfo;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n-import jdk.internal.classfile.attribute.SignatureAttribute;\n-import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n-import jdk.internal.classfile.attribute.SourceFileAttribute;\n-import jdk.internal.classfile.attribute.SourceIDAttribute;\n-import jdk.internal.classfile.attribute.StackMapTableAttribute;\n-import jdk.internal.classfile.attribute.StackMapFrameInfo;\n-import jdk.internal.classfile.attribute.SyntheticAttribute;\n-import jdk.internal.classfile.constantpool.ConstantValueEntry;\n-import jdk.internal.classfile.constantpool.ModuleEntry;\n-import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n-import jdk.internal.classfile.constantpool.PackageEntry;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BootstrapMethodEntry;\n+import java.lang.classfile.BufWriter;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n+import java.lang.classfile.attribute.CharacterRangeInfo;\n+import java.lang.classfile.attribute.CharacterRangeTableAttribute;\n+import java.lang.classfile.attribute.CompilationIDAttribute;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.attribute.DeprecatedAttribute;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.LineNumberInfo;\n+import java.lang.classfile.attribute.LineNumberTableAttribute;\n+import java.lang.classfile.attribute.LocalVariableInfo;\n+import java.lang.classfile.attribute.LocalVariableTableAttribute;\n+import java.lang.classfile.attribute.LocalVariableTypeInfo;\n+import java.lang.classfile.attribute.LocalVariableTypeTableAttribute;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.MethodParametersAttribute;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleHashInfo;\n+import java.lang.classfile.attribute.ModuleHashesAttribute;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.classfile.attribute.ModuleProvideInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.attribute.ModuleTargetAttribute;\n+import java.lang.classfile.attribute.NestHostAttribute;\n+import java.lang.classfile.attribute.NestMembersAttribute;\n+import java.lang.classfile.attribute.PermittedSubclassesAttribute;\n+import java.lang.classfile.attribute.PreloadAttribute;\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RecordComponentInfo;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.classfile.attribute.SourceIDAttribute;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.SyntheticAttribute;\n+import java.lang.classfile.constantpool.ConstantValueEntry;\n+import java.lang.classfile.constantpool.ModuleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.PackageEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -954,9 +954,0 @@\n-\n-    public static abstract sealed class CustomAttribute<T extends CustomAttribute<T>>\n-            extends UnboundAttribute<T>\n-            permits jdk.internal.classfile.CustomAttribute {\n-\n-        public CustomAttribute(AttributeMapper<T> mapper) {\n-            super(mapper);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":65,"deletions":74,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\")\n+        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\", status=\"Deprecated\")\n@@ -77,1 +77,3 @@\n-        @JEP(number=446, title=\"Scoped Values\", status=\"Preview\")\n+        @JEP(number=463, title=\"Implicitly Declared Classes and Instance Main Methods\", status=\"Preview\")\n+        IMPLICIT_CLASSES,\n+        @JEP(number=464, title=\"Scoped Values\", status=\"Second Preview\")\n@@ -79,1 +81,1 @@\n-        @JEP(number=453, title=\"Structured Concurrency\", status=\"Preview\")\n+        @JEP(number=462, title=\"Structured Concurrency\", status=\"Second Preview\")\n@@ -81,0 +83,4 @@\n+        @JEP(number=457, title=\"ClassFile API\", status=\"Preview\")\n+        CLASSFILE_API,\n+        @JEP(number=461, title=\"Stream Gatherers\", status=\"Preview\")\n+        STREAM_GATHERERS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -82,0 +82,5 @@\n+    exports java.lang.classfile;\n+    exports java.lang.classfile.attribute;\n+    exports java.lang.classfile.components;\n+    exports java.lang.classfile.constantpool;\n+    exports java.lang.classfile.instruction;\n@@ -152,3 +157,6 @@\n-        jdk.incubator.vector,\n-        jdk.jfr,\n-        jdk.jshell;\n+        jdk.incubator.vector, \/\/ participates in preview features\n+        jdk.jartool, \/\/ participates in preview features\n+        jdk.jdeps, \/\/ participates in preview features\n+        jdk.jfr, \/\/ participates in preview features\n+        jdk.jlink,   \/\/ participates in preview features\n+        jdk.jshell; \/\/ participates in preview features\n@@ -188,22 +196,0 @@\n-    exports jdk.internal.classfile to\n-        jdk.jartool,\n-        jdk.jdeps,\n-        jdk.jfr,\n-        jdk.jlink,\n-        jdk.jshell;\n-    exports jdk.internal.classfile.attribute to\n-        jdk.jartool,\n-        jdk.jdeps,\n-        jdk.jfr,\n-        jdk.jlink;\n-    exports jdk.internal.classfile.components to\n-        jdk.jfr;\n-    exports jdk.internal.classfile.constantpool to\n-        jdk.jartool,\n-        jdk.jdeps,\n-        jdk.jfr,\n-        jdk.jlink;\n-    exports jdk.internal.classfile.instruction to\n-        jdk.jdeps,\n-        jdk.jlink,\n-        jdk.jshell;\n@@ -244,0 +230,1 @@\n+        jdk.compiler,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    \/** Class is a unnamed top level class.\n+    \/** Class is an implicitly declared top level class.\n@@ -136,1 +136,1 @@\n-    public static final int UNNAMED_CLASS    = 1<<23;\n+    public static final int IMPLICIT_CLASS    = 1<<23;\n@@ -528,1 +528,1 @@\n-        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n+        IMPLICIT_CLASS(Flags.IMPLICIT_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-import static com.sun.tools.javac.code.Flags.RECORD;\n-import static com.sun.tools.javac.code.Flags.SEALED;\n-import static com.sun.tools.javac.code.Flags.NON_SEALED;\n@@ -87,1 +84,1 @@\n-    private static final Context.Key<Preview> previewKey = new Context.Key<>();\n+    protected static final Context.Key<Preview> previewKey = new Context.Key<>();\n@@ -97,1 +94,2 @@\n-    Preview(Context context) {\n+    @SuppressWarnings(\"this-escape\")\n+    protected Preview(Context context) {\n@@ -213,1 +211,1 @@\n-            case UNNAMED_CLASSES -> true;\n+            case IMPLICIT_CLASSES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-        UNNAMED_CLASSES(JDK21, Fragments.FeatureUnnamedClasses, DiagKind.PLURAL),\n+        IMPLICIT_CLASSES(JDK21, Fragments.FeatureImplicitClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,0 +445,4 @@\n+    public boolean isImplicit() {\n+        return (flags_field & IMPLICIT_CLASS) != 0;\n+    }\n+\n@@ -1266,1 +1270,0 @@\n-    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1380,1 +1383,1 @@\n-             return isUnnamed() ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+             return fullname;\n@@ -1561,1 +1564,1 @@\n-            if (owner.kind == PCK) \/\/ Handles unnamed classes as well\n+            if (owner.kind == PCK) \/\/ Handles implicitly declared classes as well\n@@ -1652,5 +1655,0 @@\n-\n-        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-        public boolean isUnnamed() {\n-            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2426,0 +2426,1 @@\n+            @SuppressWarnings(\"fallthrough\")\n@@ -2429,9 +2430,13 @@\n-                    switch (s.getKind()) {\n-                        case OTHER:\n-                        case UNION:\n-                        case INTERSECTION:\n-                        case PACKAGE:\n-                        case EXECUTABLE:\n-                        case NONE:\n-                        case VOID:\n-                        case ERROR:\n+                    switch (s.getTag()) {\n+                        case CLASS:\n+                            if (s instanceof UnionClassType ||\n+                                s instanceof IntersectionClassType) {\n+                                return s;\n+                            }\n+                            \/\/fall-through\n+                        case BYTE, CHAR, SHORT, LONG, FLOAT, INT, DOUBLE, BOOLEAN,\n+                             ARRAY, MODULE, TYPEVAR, WILDCARD, BOT:\n+                            return s.dropMetadata(Annotations.class);\n+                        case VOID, METHOD, PACKAGE, FORALL, DEFERRED,\n+                             NONE, ERROR, UNKNOWN, UNDETVAR, UNINITIALIZED_THIS,\n+                             UNINITIALIZED_OBJECT:\n@@ -2439,1 +2444,2 @@\n-                        default: return s.cloneWithMetadata(t.getMetadata()).dropMetadata(Annotations.class);\n+                        default:\n+                            throw new AssertionError(s.getTag().name());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -4209,2 +4209,2 @@\n-        if (tree.var.vartype != null) {\n-            annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n+        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n+        if (!tree.var.isImplicitlyTyped()) {\n@@ -4212,1 +4212,1 @@\n-            annotate.flush();\n+        annotate.flush();\n@@ -5536,1 +5536,1 @@\n-                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                if (c.isImplicit()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -455,1 +455,2 @@\n-            if (sym.kind == TYP && sym.name == name && sym.name != names.error) {\n+            if (sym.kind == TYP && sym.name == name && sym.name != names.error &&\n+                    !sym.isImplicit()) {\n@@ -2359,1 +2360,1 @@\n-            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+            log.error(pos, Errors.ImplicitClassDoesNotHaveMainMethod);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3062,8 +3062,0 @@\n-        if (previewClassFile) {\n-            if ((c.flags_field & SYNTHETIC) != 0 &&\n-                    c.owner.kind == PCK &&\n-                    (c.flags_field & AUXILIARY) == 0 &&\n-                    (c.flags_field & FINAL) != 0) {\n-                c.flags_field |= UNNAMED_CLASS;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1148,0 +1148,2 @@\n+        \/\/ Process annotations if processing is not disabled and there\n+        \/\/ is at least one Processor available.\n@@ -1153,5 +1155,1 @@\n-\n-            \/\/ Process annotations if processing is requested and there\n-            \/\/ is at least one Processor available.\n-            processAnnotations = procEnvImpl.atLeastOneProcessor() &&\n-                explicitAnnotationProcessingRequested();\n+            processAnnotations = procEnvImpl.atLeastOneProcessor();\n@@ -1160,0 +1158,5 @@\n+                if (!explicitAnnotationProcessingRequested() &&\n+                    !optionsCheckingInitiallyDisabled) {\n+                    log.note(Notes.ImplicitAnnotationProcessing);\n+                }\n+\n@@ -1168,0 +1171,2 @@\n+            } else { \/\/ free resources\n+                procEnvImpl.close();\n@@ -1169,2 +1174,0 @@\n-        } else { \/\/ free resources\n-            procEnvImpl.close();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-        this.keepDocComments = false;\n+        this.keepDocComments = parser.keepDocComments;\n@@ -217,1 +217,1 @@\n-        this.docComments = null;\n+        this.docComments = parser.docComments;\n@@ -3388,0 +3388,2 @@\n+                case FINAL:\n+                    if (parenDepth > 0) return PatternResult.PATTERN;\n@@ -3958,2 +3960,2 @@\n-        boolean firstTypeDecl = true;   \/\/ have we see a class, enum, or interface declaration yet?\n-        boolean isUnnamedClass = false;\n+        boolean firstTypeDecl = true;   \/\/ have we seen a class, enum, or interface declaration yet?\n+        boolean isImplicitClass = false;\n@@ -4022,1 +4024,1 @@\n-                \/\/ Do to a significant number of existing negative tests\n+                \/\/ Due to a significant number of existing negative tests\n@@ -4026,1 +4028,1 @@\n-                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ implicitly declared classes did not exist and error reporting\n@@ -4028,1 +4030,1 @@\n-                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                if (Feature.IMPLICIT_CLASSES.allowedInSource(source) && !isDeclaration()) {\n@@ -4032,1 +4034,1 @@\n-                            speculative.topLevelMethodOrFieldDeclaration(finalMods);\n+                            speculative.topLevelMethodOrFieldDeclaration(finalMods, null);\n@@ -4040,3 +4042,3 @@\n-                    checkSourceLevel(token.pos, Feature.UNNAMED_CLASSES);\n-                    defs.appendList(topLevelMethodOrFieldDeclaration(mods));\n-                    isUnnamedClass = true;\n+                    checkSourceLevel(token.pos, Feature.IMPLICIT_CLASSES);\n+                    defs.appendList(topLevelMethodOrFieldDeclaration(mods, docComment));\n+                    isImplicitClass = true;\n@@ -4054,1 +4056,1 @@\n-        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n@@ -4069,2 +4071,2 @@\n-    \/\/ Restructure top level to be an unnamed class.\n-    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+    \/\/ Restructure top level to be an implicitly declared class.\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n@@ -4076,1 +4078,1 @@\n-                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+                log.error(def.pos(), Errors.ImplicitClassShouldNotHavePackageDeclaration);\n@@ -4095,4 +4097,4 @@\n-        JCModifiers unnamedMods = F.at(Position.NOPOS)\n-                .Modifiers(Flags.FINAL|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n-        JCClassDecl unnamed = F.at(primaryPos).ClassDef(\n-                unnamedMods, name, List.nil(), null, List.nil(), List.nil(),\n+        JCModifiers implicitMods = F.at(Position.NOPOS)\n+                .Modifiers(Flags.FINAL|Flags.IMPLICIT_CLASS, List.nil());\n+        JCClassDecl implicit = F.at(primaryPos).ClassDef(\n+                implicitMods, name, List.nil(), null, List.nil(), List.nil(),\n@@ -4100,1 +4102,1 @@\n-        topDefs.append(unnamed);\n+        topDefs.append(implicit);\n@@ -4777,2 +4779,1 @@\n-    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods) throws AssertionError {\n-        int topPos = token.pos;\n+    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods, Comment dc) throws AssertionError {\n@@ -4780,1 +4781,1 @@\n-        Comment dc = token.docComment();\n+        dc = dc == null ? token.docComment() : dc;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -527,2 +527,2 @@\n-compiler.err.unnamed.class.should.not.have.package.declaration=\\\n-    unnamed class should not have package declaration\n+compiler.err.implicit.class.should.not.have.package.declaration=\\\n+    implicitly declared class should not have package declaration\n@@ -530,2 +530,2 @@\n-compiler.err.unnamed.class.does.not.have.main.method=\\\n-    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+compiler.err.implicit.class.does.not.have.main.method=\\\n+    implicitly declared class does not have main method in the form of void main() or void main(String[] args)\n@@ -3224,2 +3224,2 @@\n-compiler.misc.feature.unnamed.classes=\\\n-    unnamed classes\n+compiler.misc.feature.implicit.classes=\\\n+    implicitly declared classes\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.internal.classfile.*;\n+import java.lang.classfile.*;\n@@ -34,4 +34,4 @@\n-import jdk.internal.classfile.constantpool.*;\n-import jdk.internal.classfile.attribute.*;\n-import static jdk.internal.classfile.Classfile.*;\n-import static jdk.internal.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.attribute.*;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.classfile.attribute.StackMapFrameInfo.*;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,15 +41,13 @@\n-import com.sun.tools.javac.jvm.ClassFile;\n-import jdk.internal.classfile.AccessFlags;\n-import jdk.internal.classfile.Attributes;\n-import jdk.internal.classfile.ClassModel;\n-import jdk.internal.classfile.ClassSignature;\n-import jdk.internal.classfile.Classfile;\n-\n-import static jdk.internal.classfile.Classfile.*;\n-import jdk.internal.classfile.constantpool.*;\n-import jdk.internal.classfile.FieldModel;\n-import jdk.internal.classfile.MethodModel;\n-import jdk.internal.classfile.MethodSignature;\n-import jdk.internal.classfile.Signature;\n-import jdk.internal.classfile.attribute.CodeAttribute;\n-import jdk.internal.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassSignature;\n+import java.lang.classfile.ClassFile;\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodSignature;\n+import java.lang.classfile.Signature;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n@@ -721,1 +719,1 @@\n-            case Classfile.TAG_INTEGER: {\n+            case ClassFile.TAG_INTEGER: {\n@@ -735,1 +733,1 @@\n-            case Classfile.TAG_STRING:\n+            case ClassFile.TAG_STRING:\n@@ -833,19 +831,19 @@\n-        ACC_PUBLIC      (Classfile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n-        ACC_PRIVATE     (Classfile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n-        ACC_PROTECTED   (Classfile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n-        ACC_STATIC      (Classfile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n-        ACC_FINAL       (Classfile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n-        ACC_SUPER       (Classfile.ACC_SUPER,        null,           true,  false, false, false),\n-        ACC_SYNCHRONIZED(Classfile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n-        ACC_VOLATILE    (Classfile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n-        ACC_BRIDGE      (Classfile.ACC_BRIDGE,       null,           false, false, false, true ),\n-        ACC_TRANSIENT   (Classfile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n-        ACC_VARARGS     (Classfile.ACC_VARARGS,      null,           false, false, false, true ),\n-        ACC_NATIVE      (Classfile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n-        ACC_INTERFACE   (Classfile.ACC_INTERFACE,    null,           true,   true, false, false),\n-        ACC_ABSTRACT    (Classfile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n-        ACC_STRICT      (Classfile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n-        ACC_SYNTHETIC   (Classfile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n-        ACC_ANNOTATION  (Classfile.ACC_ANNOTATION,   null,           true,   true, false, false),\n-        ACC_ENUM        (Classfile.ACC_ENUM,         null,           true,   true, true,  false),\n-        ACC_MODULE      (Classfile.ACC_MODULE,       null,           true,  false, false, false);\n+        ACC_PUBLIC      (ClassFile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n+        ACC_PRIVATE     (ClassFile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n+        ACC_PROTECTED   (ClassFile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n+        ACC_STATIC      (ClassFile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n+        ACC_FINAL       (ClassFile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n+        ACC_SUPER       (ClassFile.ACC_SUPER,        null,           true,  false, false, false),\n+        ACC_SYNCHRONIZED(ClassFile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n+        ACC_VOLATILE    (ClassFile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n+        ACC_BRIDGE      (ClassFile.ACC_BRIDGE,       null,           false, false, false, true ),\n+        ACC_TRANSIENT   (ClassFile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n+        ACC_VARARGS     (ClassFile.ACC_VARARGS,      null,           false, false, false, true ),\n+        ACC_NATIVE      (ClassFile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n+        ACC_INTERFACE   (ClassFile.ACC_INTERFACE,    null,           true,   true, false, false),\n+        ACC_ABSTRACT    (ClassFile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n+        ACC_STRICT      (ClassFile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n+        ACC_SYNTHETIC   (ClassFile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n+        ACC_ANNOTATION  (ClassFile.ACC_ANNOTATION,   null,           true,   true, false, false),\n+        ACC_ENUM        (ClassFile.ACC_ENUM,         null,           true,   true, true,  false),\n+        ACC_MODULE      (ClassFile.ACC_MODULE,       null,           true,  false, false, false);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -37,5 +37,6 @@\n-import jdk.internal.classfile.AnnotationValue;\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.Label;\n-import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+\n@@ -43,0 +44,1 @@\n+\n@@ -70,1 +72,1 @@\n-        byte[] bytes = Classfile.of().build(ClassDesc.of(fullClassName), cb -> build(cb));\n+        byte[] bytes = ClassFile.of().build(ClassDesc.of(fullClassName), cb -> build(cb));\n@@ -84,1 +86,1 @@\n-        builder.withMethod(SET_METHOD.name(), SET_METHOD.descriptor(), Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+        builder.withMethod(SET_METHOD.name(), SET_METHOD.descriptor(), ClassFile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n@@ -105,1 +107,1 @@\n-        builder.withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, Classfile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n+        builder.withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, ClassFile.ACC_PUBLIC, methodBuilder -> methodBuilder.withCode(codeBuilder -> {\n@@ -115,1 +117,1 @@\n-        List<jdk.internal.classfile.Annotation> annotations = new ArrayList<>();\n+        List<java.lang.classfile.Annotation> annotations = new ArrayList<>();\n@@ -117,1 +119,1 @@\n-            List<jdk.internal.classfile.AnnotationElement> list = new ArrayList<>();\n+            List<java.lang.classfile.AnnotationElement> list = new ArrayList<>();\n@@ -123,1 +125,1 @@\n-                var ae = jdk.internal.classfile.AnnotationElement.of(v.getName(), av);\n+                var ae = java.lang.classfile.AnnotationElement.of(v.getName(), av);\n@@ -127,1 +129,1 @@\n-            annotations.add(jdk.internal.classfile.Annotation.of(cd, list));\n+            annotations.add(java.lang.classfile.Annotation.of(cd, list));\n@@ -134,1 +136,1 @@\n-            builder.withField(v.getName(), Bytecode.classDesc(v), Classfile.ACC_PRIVATE);\n+            builder.withField(v.getName(), Bytecode.classDesc(v), ClassFile.ACC_PRIVATE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  TempNewSymbol A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n-  TempNewSymbol D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  Symbol* A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n+  Symbol* D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n@@ -45,1 +45,1 @@\n-  TempNewSymbol interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+  Symbol* interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n@@ -113,0 +113,5 @@\n+\n+  \/\/ clean up temporary symbols\n+  A->decrement_refcount();\n+  D->decrement_refcount();\n+  interf->decrement_refcount();\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-compiler\/codecache\/CheckLargePages.java 8317831 linux-x64\n+compiler\/codecache\/CheckLargePages.java 8319795 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.value\n@@ -66,2 +65,1 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.value\n@@ -84,2 +82,1 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.value\n@@ -102,2 +99,1 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.value\n@@ -121,2 +117,1 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.value\n+ * @modules java.base\/jdk.internal.value\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-import jdk.internal.classfile.Label;\n-import jdk.internal.classfile.TypeKind;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.TypeKind;\n@@ -60,1 +60,0 @@\n- *          java.base\/jdk.internal.classfile\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @modules java.base\/jdk.internal.classfile\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ObjectMethods.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -461,0 +461,1 @@\n+java\/awt\/KeyboardFocusmanager\/ConsumeNextMnemonicKeyTypedTest\/ConsumeNextMnemonicKeyTypedTest.java 8321303 linux-all\n@@ -573,1 +574,0 @@\n-java\/nio\/file\/Files\/probeContentType\/Basic.java                 8320943 windows-all\n@@ -654,0 +654,1 @@\n+javax\/swing\/JFrame\/MaximizeWindowTest.java 8321289 linux-all\n@@ -686,3 +687,0 @@\n-javax\/swing\/JTree\/8003400\/Test8003400.java 8309734 linux-all\n-javax\/swing\/JTable\/7124218\/SelectEditTableCell.java 8309734 linux-all\n-javax\/swing\/JFileChooser\/JFileChooserSetLocationTest.java 8309734 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -657,0 +657,4 @@\n+\n+jdk_core_no_security = \\\n+   :jdk_core \\\n+   -:jdk_security\n","filename":"test\/jdk\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.internal.classfile.Classfile;\n+import java.lang.classfile.ClassFile;\n@@ -42,1 +42,2 @@\n-import static jdk.internal.classfile.Classfile.*;\n+import static java.lang.classfile.ClassFile.*;\n+\n@@ -44,0 +45,1 @@\n+\n@@ -50,4 +52,2 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n@@ -90,1 +90,1 @@\n-        var cf = Classfile.of();\n+        var cf = ClassFile.of();\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,8 +26,6 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicCallSiteDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n+\n+import java.lang.constant.*;\n@@ -41,5 +39,0 @@\n-import jdk.internal.classfile.ClassBuilder;\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.TypeKind;\n-\n@@ -54,1 +47,1 @@\n-                .withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, Classfile.ACC_PUBLIC,\n+                .withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, ClassFile.ACC_PUBLIC,\n@@ -66,1 +59,1 @@\n-        byte[] byteArray = Classfile.of().build(genClassDesc, classBuilder -> {\n+        byte[] byteArray = ClassFile.of().build(genClassDesc, classBuilder -> {\n@@ -70,1 +63,1 @@\n-                            Classfile.ACC_PUBLIC + Classfile.ACC_STATIC, methodBuilder -> methodBuilder\n+                            ClassFile.ACC_PUBLIC + ClassFile.ACC_STATIC, methodBuilder -> methodBuilder\n@@ -113,1 +106,1 @@\n-        byte[] bytes = Classfile.of().build(genClassDesc, classBuilder -> {\n+        byte[] bytes = ClassFile.of().build(genClassDesc, classBuilder -> {\n@@ -116,1 +109,1 @@\n-                    Classfile.ACC_PUBLIC + Classfile.ACC_STATIC, methodBuilder -> methodBuilder\n+                    ClassFile.ACC_PUBLIC + ClassFile.ACC_STATIC, methodBuilder -> methodBuilder\n@@ -155,1 +148,1 @@\n-            byte[] bytes = Classfile.of().build(classDesc, classBuilder -> {\n+            byte[] bytes = ClassFile.of().build(classDesc, classBuilder -> {\n@@ -158,1 +151,1 @@\n-                                        Classfile.ACC_PUBLIC + Classfile.ACC_STATIC,\n+                                        ClassFile.ACC_PUBLIC + ClassFile.ACC_STATIC,\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.*;\n-import jdk.internal.classfile.constantpool.*;\n-import jdk.internal.classfile.instruction.*;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.instruction.*;\n@@ -35,1 +35,1 @@\n-import jdk.internal.classfile.components.CodeStackTracker;\n+import java.lang.classfile.components.CodeStackTracker;\n@@ -42,1 +42,1 @@\n-        return Classfile.of(Classfile.StackMapsOption.DROP_STACK_MAPS).build(clm.thisClass().asSymbol(), clb -> {\n+        return ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(clm.thisClass().asSymbol(), clb -> {\n@@ -48,1 +48,1 @@\n-                    case ClassfileVersion v -> clb.withVersion(v.majorVersion(), v.minorVersion());\n+                    case ClassFileVersion v -> clb.withVersion(v.majorVersion(), v.minorVersion());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n+        for (RecordedEvent event : events) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestSyncOnValueBasedClassEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,6 +28,2 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- *          java.base\/jdk.internal.classfile.instruction\n- *          java.base\/jdk.internal.classfile.components\n- *          java.base\/jdk.internal.classfile.impl\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile.impl\n@@ -41,3 +37,3 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.InnerClassInfo;\n-import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n@@ -98,1 +94,1 @@\n-        ClassModel outerClass = Classfile.of().parse(outerFile);\n+        ClassModel outerClass = ClassFile.of().parse(outerFile);\n@@ -101,1 +97,1 @@\n-            ClassModel innerClass = Classfile.of().parse(innerFile);\n+            ClassModel innerClass = ClassFile.of().parse(innerFile);\n@@ -111,2 +107,2 @@\n-        int mask = Classfile.ACC_PUBLIC | Classfile.ACC_FINAL | Classfile.ACC_INTERFACE | Classfile.ACC_ABSTRACT |\n-                   Classfile.ACC_SYNTHETIC | Classfile.ACC_ANNOTATION | Classfile.ACC_ENUM | Classfile.ACC_IDENTITY;\n+        int mask = ClassFile.ACC_PUBLIC | ClassFile.ACC_FINAL | ClassFile.ACC_INTERFACE | ClassFile.ACC_ABSTRACT |\n+                   ClassFile.ACC_SYNTHETIC | ClassFile.ACC_ANNOTATION | ClassFile.ACC_ENUM | ClassFile.ACC_IDENTITY;\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousClassFlags.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import static jdk.internal.classfile.TypeAnnotation.TargetType.*;\n+import static java.lang.classfile.TypeAnnotation.TargetType.*;\n@@ -30,6 +30,2 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- *          java.base\/jdk.internal.classfile.instruction\n- *          java.base\/jdk.internal.classfile.components\n- *          java.base\/jdk.internal.classfile.impl\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NewObjects.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,6 +28,2 @@\n- *  @modules java.base\/jdk.internal.classfile\n- *           java.base\/jdk.internal.classfile.attribute\n- *           java.base\/jdk.internal.classfile.constantpool\n- *           java.base\/jdk.internal.classfile.instruction\n- *           java.base\/jdk.internal.classfile.components\n- *           java.base\/jdk.internal.classfile.impl\n+ *  @enablePreview\n+ *  @modules java.base\/jdk.internal.classfile.impl\n@@ -40,2 +36,2 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.*;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n@@ -52,1 +48,1 @@\n-            ClassModel cf = Classfile.of().parse(classFile.toPath());\n+            ClassModel cf = ClassFile.of().parse(classFile.toPath());\n","filename":"test\/langtools\/tools\/javac\/classfiles\/InnerClasses\/SyntheticClasses.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @enablePreview\n@@ -31,5 +32,0 @@\n- *          java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- *          java.base\/jdk.internal.classfile.instruction\n- *          java.base\/jdk.internal.classfile.components\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesInAnonymousClassTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,6 +29,2 @@\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- *          java.base\/jdk.internal.classfile.instruction\n- *          java.base\/jdk.internal.classfile.components\n- *          java.base\/jdk.internal.classfile.impl\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile.impl\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesInLocalClassTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,3 +24,3 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.*;\n-import jdk.internal.classfile.constantpool.*;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.*;\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesTestBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -30,5 +31,0 @@\n- *          java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- *          java.base\/jdk.internal.classfile.instruction\n- *          java.base\/jdk.internal.classfile.components\n@@ -42,2 +38,2 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.constantpool.*;\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n@@ -499,1 +495,1 @@\n-            ClassModel cm = Classfile.of().parse(in.readAllBytes());\n+            ClassModel cm = ClassFile.of().parse(in.readAllBytes());\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -222,5 +222,0 @@\n-\n-# Pending removal\n-compiler.note.implicit.annotation.processing\n-compiler.warn.proc.use.proc.or.implicit\n-\n@@ -230,1 +225,1 @@\n-compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n+compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @enablePreview\n@@ -32,5 +33,0 @@\n- *          java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- *          java.base\/jdk.internal.classfile.instruction\n- *          java.base\/jdk.internal.classfile.components\n@@ -44,2 +40,2 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n@@ -66,1 +62,2 @@\n-import com.sun.tools.javac.launcher.Main;\n+import com.sun.tools.javac.launcher.SourceLauncher;\n+import com.sun.tools.javac.launcher.Fault;\n@@ -72,1 +69,0 @@\n-import toolbox.TestRunner.Test;\n@@ -301,2 +297,2 @@\n-        Files.createDirectories(base);\n-        Path file = base.resolve(\"NoClass.java\");\n+        var path = Files.createDirectories(base.resolve(\"p\"));\n+        Path file = path.resolve(\"NoClass.java\");\n@@ -307,0 +303,8 @@\n+    @Test\n+    public void testMismatchOfPathAndPackage(Path base) throws IOException {\n+        Files.createDirectories(base);\n+        Path file = base.resolve(\"MismatchOfPathAndPackage.java\");\n+        Files.write(file, List.of(\"package p;\"));\n+        testError(file, \"\", \"error: end of path to source file does not match its package name p: \" + file);\n+    }\n+\n@@ -547,1 +551,1 @@\n-    @Test\n+    \/\/@Test temporary disabled as enabled preview allows no-param main\n@@ -555,1 +559,1 @@\n-    @Test\n+    \/\/@Test temporary disabled as enabled preview allows non-public main\n@@ -563,1 +567,1 @@\n-    @Test\n+    \/\/@Test temporary disabled as enabled preview allows non-static main\n@@ -568,1 +572,1 @@\n-                \"error: 'main' method is not declared 'public static'\");\n+                \"error: can't find main(String[]) method in class: NotStatic\");\n@@ -576,1 +580,1 @@\n-                \"error: 'main' method is not declared with a return type of 'void'\");\n+                \"error: can't find main(String[]) method in class: NotVoid\");\n@@ -627,1 +631,1 @@\n-                .vmOptions(\"--source\", \"8\")\n+                .vmOptions(\"--source\", \"21\")\n@@ -724,1 +728,1 @@\n-            ClassModel cf = Classfile.of().parse(moduleInfoFile);\n+            ClassModel cf = ClassFile.of().parse(moduleInfoFile);\n@@ -726,1 +730,1 @@\n-            byte[] newBytes = Classfile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof Attributes)\n+            byte[] newBytes = ClassFile.of().transform(cf, ClassTransform.dropping(ce -> ce instanceof Attributes)\n@@ -744,1 +748,1 @@\n-                Main m = new Main(err);\n+                SourceLauncher m = new SourceLauncher(err);\n@@ -801,1 +805,1 @@\n-            error(\"No exception thrown; expected Main.Fault\");\n+            error(\"No exception thrown; expected Fault\");\n@@ -803,2 +807,2 @@\n-            if (!(found instanceof Main.Fault)) {\n-                error(\"Unexpected exception; expected Main.Fault\");\n+            if (!(found instanceof Fault)) {\n+                error(\"Unexpected exception; expected Fault\");\n@@ -836,11 +840,1 @@\n-    class Result {\n-        private final String stdOut;\n-        private final String stdErr;\n-        private final Throwable exception;\n-\n-        Result(String stdOut, String stdErr, Throwable exception) {\n-            this.stdOut = stdOut;\n-            this.stdErr = stdErr;\n-            this.exception = exception;\n-        }\n-    }\n+    record Result(String stdOut, String stdErr, Throwable exception) {}\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":29,"deletions":35,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -755,0 +755,1 @@\n+        Path modulesList = ctSym.resolve(\"modules-list\");\n@@ -757,0 +758,1 @@\n+        try (Writer w = Files.newBufferedWriter(modulesList)) {}\n@@ -761,1 +763,1 @@\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", \"\", modules.toString());\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", \"\", modules.toString(), modulesList.toString());\n@@ -838,1 +840,1 @@\n-                   header exports api,nonapi[java.base] requires name\\\\u0020;java.base\\\\u0020;flags\\\\u0020;8000\\\\u0020;version\\\\u0020;0 flags 8000\n+                   header exports api extraModulePackages nonapi requires name\\\\u0020;java.base\\\\u0020;flags\\\\u0020;8000\\\\u0020;version\\\\u0020;0 flags 8000\n@@ -1041,0 +1043,1 @@\n+        Path modulesList = descDest.resolve(\"modules-list\");\n@@ -1043,0 +1046,1 @@\n+        try (Writer w = Files.newBufferedWriter(modulesList)) {}\n@@ -1044,6 +1048,1 @@\n-        try {\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", \"\", modules.toString());\n-        } catch (Throwable t) {\n-            t.printStackTrace();\n-            throw t;\n-        }\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", \"\", modules.toString(), modulesList.toString());\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @enablePreview\n@@ -35,5 +36,0 @@\n- *      java.base\/jdk.internal.classfile\n- *      java.base\/jdk.internal.classfile.attribute\n- *      java.base\/jdk.internal.classfile.constantpool\n- *      java.base\/jdk.internal.classfile.instruction\n- *      java.base\/jdk.internal.classfile.components\n@@ -72,5 +68,5 @@\n-import jdk.internal.classfile.*;\n-import jdk.internal.classfile.attribute.*;\n-import jdk.internal.classfile.Opcode;\n-import jdk.internal.classfile.constantpool.*;\n-import jdk.internal.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.instruction.FieldInstruction;\n@@ -1300,1 +1296,1 @@\n-                    ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                    ClassModel classFile = ClassFile.of().parse(fileEntry.toPath());\n@@ -1324,1 +1320,1 @@\n-                ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                ClassModel classFile = ClassFile.of().parse(fileEntry.toPath());\n@@ -1472,1 +1468,1 @@\n-                ClassModel classFile = Classfile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n+                ClassModel classFile = ClassFile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n@@ -1575,1 +1571,1 @@\n-        ClassModel classFile = Classfile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n+        ClassModel classFile = ClassFile.of().parse(findClassFileOrFail(dir, \"R.class\").toPath());\n@@ -1791,1 +1787,1 @@\n-                ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                ClassModel classFile = ClassFile.of().parse(fileEntry.toPath());\n@@ -1795,1 +1791,1 @@\n-                            Assert.check(((method.flags().flagsMask() & Classfile.ACC_PUBLIC) != 0) && ((method.flags().flagsMask() & Classfile.ACC_FINAL) != 0));\n+                            Assert.check(((method.flags().flagsMask() & ClassFile.ACC_PUBLIC) != 0) && ((method.flags().flagsMask() & ClassFile.ACC_FINAL) != 0));\n@@ -1824,1 +1820,1 @@\n-                    ClassModel classFile = Classfile.of().parse(fileEntry.toPath());\n+                    ClassModel classFile = ClassFile.of().parse(fileEntry.toPath());\n@@ -1847,3 +1843,3 @@\n-            case \"private\" -> Classfile.ACC_PRIVATE;\n-            case \"protected\" -> Classfile.ACC_PROTECTED;\n-            case \"public\" -> Classfile.ACC_PUBLIC;\n+            case \"private\" -> ClassFile.ACC_PRIVATE;\n+            case \"protected\" -> ClassFile.ACC_PROTECTED;\n+            case \"public\" -> ClassFile.ACC_PUBLIC;\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"}]}