{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -387,9 +388,3 @@\n-        Node* init_value = alloc->in(AllocateNode::InitValue);\n-        if (init_value != nullptr) {\n-          if (val == start_mem) {\n-            \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n-            \/\/ Somehow we ended up with root mem and therefore walked past the alloc. Fix this. Triggered by TestGenerated::test15\n-            \/\/ Don't we need field_value_by_offset?\n-            return nullptr;\n-          }\n-          values.at_put(j, init_value);\n+        Node* init_value = value_from_alloc(ft, adr_t, alloc);\n+        if (init_value == nullptr) {\n+          return nullptr;\n@@ -397,2 +392,2 @@\n-          assert(alloc->in(AllocateNode::RawInitValue) == nullptr, \"init value may not be null\");\n-          values.at_put(j, _igvn.zerocon(ft));\n+          values.at_put(j, init_value);\n+          continue;\n@@ -400,1 +395,0 @@\n-        continue;\n@@ -419,5 +413,3 @@\n-        Node* init_value = alloc->in(AllocateNode::InitValue);\n-        if (init_value != nullptr) {\n-          \/\/ TODO 8350865 Scalar replacement does not work well for flat arrays.\n-          \/\/ Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n-          values.at_put(j, init_value);\n+        Node* init_value = value_from_alloc(ft, adr_t, alloc);\n+        if (init_value == nullptr) {\n+          return nullptr;\n@@ -425,2 +417,1 @@\n-          assert(alloc->in(AllocateNode::RawInitValue) == nullptr, \"init value may not be null\");\n-          values.at_put(j, _igvn.zerocon(ft));\n+          values.at_put(j, init_value);\n@@ -468,0 +459,56 @@\n+\/\/ Extract the initial value of a field in an allocation\n+Node* PhaseMacroExpand::value_from_alloc(BasicType ft, const TypeOopPtr* adr_t, AllocateNode* alloc) {\n+  Node* init_value = alloc->in(AllocateNode::InitValue);\n+  if (init_value == nullptr) {\n+    assert(alloc->in(AllocateNode::RawInitValue) == nullptr, \"conflicting InitValue and RawInitValue\");\n+    return _igvn.zerocon(ft);\n+  }\n+\n+  const TypeAryPtr* ary_t = adr_t->isa_aryptr();\n+  assert(ary_t != nullptr, \"must be a pointer into an array\");\n+\n+  \/\/ If this is not a flat array, then it must be an oop array with elements being init_value\n+  if (ary_t->is_not_flat()) {\n+#ifdef ASSERT\n+    BasicType init_bt = init_value->bottom_type()->basic_type();\n+    assert(ft == init_bt ||\n+           (!is_java_primitive(ft) && !is_java_primitive(init_bt) && type2aelembytes(ft, true) == type2aelembytes(init_bt, true)) ||\n+           (is_subword_type(ft) && init_bt == T_INT),\n+           \"invalid init_value of type %s for field of type %s\", type2name(init_bt), type2name(ft));\n+#endif \/\/ ASSERT\n+    return init_value;\n+  }\n+\n+  assert(ary_t->klass_is_exact() && ary_t->is_flat(), \"must be an exact flat array\");\n+  assert(ary_t->field_offset().get() != Type::OffsetBot, \"unknown offset\");\n+  if (init_value->is_EncodeP()) {\n+    init_value = init_value->in(1);\n+  }\n+  \/\/ Cannot look through init_value if it is an oop\n+  if (!init_value->is_InlineType()) {\n+    return nullptr;\n+  }\n+\n+  ciInlineKlass* vk = init_value->bottom_type()->inline_klass();\n+  if (ary_t->field_offset().get() == vk->null_marker_offset_in_payload()) {\n+    init_value = init_value->as_InlineType()->get_null_marker();\n+  } else {\n+    init_value = init_value->as_InlineType()->field_value_by_offset(ary_t->field_offset().get() + vk->payload_offset(), true);\n+  }\n+\n+  if (ft == T_NARROWOOP) {\n+    assert(init_value->bottom_type()->isa_ptr(), \"must be a pointer\");\n+    init_value = transform_later(new EncodePNode(init_value, init_value->bottom_type()->make_narrowoop()));\n+  }\n+\n+#ifdef ASSERT\n+  BasicType init_bt = init_value->bottom_type()->basic_type();\n+  assert(ft == init_bt ||\n+         (!is_java_primitive(ft) && !is_java_primitive(init_bt) && type2aelembytes(ft, true) == type2aelembytes(init_bt, true)) ||\n+         (is_subword_type(ft) && init_bt == T_INT),\n+         \"invalid init_value of type %s for field of type %s\", type2name(init_bt), type2name(ft));\n+#endif \/\/ ASSERT\n+\n+  return init_value;\n+}\n+\n@@ -541,20 +588,1 @@\n-      Node* init_value = alloc->in(AllocateNode::InitValue);\n-      if (init_value != nullptr) {\n-        if (adr_t->is_flat()) {\n-          if (init_value->is_EncodeP()) {\n-            init_value = init_value->in(1);\n-          }\n-          if (!init_value->is_InlineType()) {\n-            return nullptr;\n-          }\n-          assert(adr_t->is_aryptr()->field_offset().get() != Type::OffsetBot, \"Unknown offset\");\n-          offset = adr_t->is_aryptr()->field_offset().get() + init_value->bottom_type()->inline_klass()->payload_offset();\n-          init_value = init_value->as_InlineType()->field_value_by_offset(offset, true);\n-          if (ft == T_NARROWOOP) {\n-            init_value = transform_later(new EncodePNode(init_value, init_value->bottom_type()->make_ptr()));\n-          }\n-        }\n-        return init_value;\n-      }\n-      assert(alloc->in(AllocateNode::RawInitValue) == nullptr, \"init value may not be null\");\n-      return _igvn.zerocon(ft);\n+      return value_from_alloc(ft, adr_t, alloc);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":67,"deletions":39,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  Node* value_from_alloc(BasicType ft, const TypeOopPtr* adr_t, AllocateNode* alloc);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}