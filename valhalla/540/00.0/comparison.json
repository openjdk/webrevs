{"files":[{"patch":"@@ -1008,1 +1008,6 @@\n-\n+  void gfmul_avx512(XMMRegister ghash, XMMRegister hkey);\n+  void generateHtbl_48_block_zmm(Register htbl);\n+  void ghash16_encrypt16_parallel(Register key, Register subkeyHtbl, XMMRegister ctr_blockx,\n+                                  XMMRegister aad_hashx, Register in, Register out, Register data, Register pos, bool reduction,\n+                                  XMMRegister addmask, bool no_ghash_input, Register rounds, Register ghash_pos,\n+                                  bool final_reduction, int index, XMMRegister counter_inc_mask);\n@@ -1014,0 +1019,2 @@\n+  void aesgcm_encrypt(Register in, Register len, Register ct, Register out, Register key,\n+                      Register state, Register subkeyHtbl, Register counter);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4410,0 +4410,89 @@\n+  address ghash_polynomial512_addr() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"_ghash_poly512_addr\");\n+    address start = __ pc();\n+    __ emit_data64(0x00000001C2000000, relocInfo::none); \/\/ POLY for reduction\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x00000001C2000000, relocInfo::none);\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x00000001C2000000, relocInfo::none);\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x00000001C2000000, relocInfo::none);\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none); \/\/ POLY\n+    __ emit_data64(0xC200000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none); \/\/ TWOONE\n+    __ emit_data64(0x0000000100000000, relocInfo::none);\n+    return start;\n+}\n+\n+  \/\/ Vector AES Galois Counter Mode implementation. Parameters:\n+  \/\/ Windows regs            |  Linux regs\n+  \/\/ in = c_rarg0 (rcx)      |  c_rarg0 (rsi)\n+  \/\/ len = c_rarg1 (rdx)     |  c_rarg1 (rdi)\n+  \/\/ ct = c_rarg2 (r8)       |  c_rarg2 (rdx)\n+  \/\/ out = c_rarg3 (r9)      |  c_rarg3 (rcx)\n+  \/\/ key = r10               |  c_rarg4 (r8)\n+  \/\/ state = r13             |  c_rarg5 (r9)\n+  \/\/ subkeyHtbl = r14        |  r11\n+  \/\/ counter = rsi           |  r12\n+  \/\/ return - number of processed bytes\n+  address generate_galoisCounterMode_AESCrypt() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"galoisCounterMode_AESCrypt\");\n+    address start = __ pc();\n+    const Register in = c_rarg0;\n+    const Register len = c_rarg1;\n+    const Register ct = c_rarg2;\n+    const Register out = c_rarg3;\n+    \/\/ and updated with the incremented counter in the end\n+#ifndef _WIN64\n+    const Register key = c_rarg4;\n+    const Register state = c_rarg5;\n+    const Address subkeyH_mem(rbp, 2 * wordSize);\n+    const Register subkeyHtbl = r11;\n+    const Address counter_mem(rbp, 3 * wordSize);\n+    const Register counter = r12;\n+#else\n+    const Address key_mem(rbp, 6 * wordSize);\n+    const Register key = r10;\n+    const Address state_mem(rbp, 7 * wordSize);\n+    const Register state = r13;\n+    const Address subkeyH_mem(rbp, 8 * wordSize);\n+    const Register subkeyHtbl = r14;\n+    const Address counter_mem(rbp, 9 * wordSize);\n+    const Register counter = rsi;\n+#endif\n+    __ enter();\n+   \/\/ Save state before entering routine\n+    __ push(r12);\n+    __ push(r13);\n+    __ push(r14);\n+    __ push(r15);\n+    __ push(rbx);\n+#ifdef _WIN64\n+    \/\/ on win64, fill len_reg from stack position\n+    __ push(rsi);\n+    __ movptr(key, key_mem);\n+    __ movptr(state, state_mem);\n+#endif\n+    __ movptr(subkeyHtbl, subkeyH_mem);\n+    __ movptr(counter, counter_mem);\n+\n+    __ aesgcm_encrypt(in, len, ct, out, key, state, subkeyHtbl, counter);\n+\n+    \/\/ Restore state before leaving routine\n+#ifdef _WIN64\n+    __ pop(rsi);\n+#endif\n+    __ pop(rbx);\n+    __ pop(r15);\n+    __ pop(r14);\n+    __ pop(r13);\n+    __ pop(r12);\n+\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret(0);\n+     return start;\n+  }\n+\n@@ -7806,0 +7895,4 @@\n+        StubRoutines::x86::_counter_mask_addr = counter_mask_addr();\n+        StubRoutines::x86::_ghash_poly512_addr = ghash_polynomial512_addr();\n+        StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n+        StubRoutines::_galoisCounterMode_AESCrypt = generate_galoisCounterMode_AESCrypt();\n@@ -7810,0 +7903,1 @@\n+\n@@ -7812,1 +7906,3 @@\n-        StubRoutines::x86::_counter_mask_addr = counter_mask_addr();\n+        if (StubRoutines::x86::_counter_mask_addr == NULL) {\n+          StubRoutines::x86::_counter_mask_addr = counter_mask_addr();\n+        }\n@@ -7852,1 +7948,3 @@\n-    StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n+      if (StubRoutines::x86::_ghash_long_swap_mask_addr == NULL) {\n+        StubRoutines::x86::_ghash_long_swap_mask_addr = generate_ghash_long_swap_mask();\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":100,"deletions":2,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -984,5 +984,7 @@\n-    case _claim_none:       out->print_cr(\"none\"); break;\n-    case _claim_finalizable:out->print_cr(\"finalizable\"); break;\n-    case _claim_strong:     out->print_cr(\"strong\"); break;\n-    case _claim_other:      out->print_cr(\"other\"); break;\n-    default:                ShouldNotReachHere();\n+    case _claim_none:                       out->print_cr(\"none\"); break;\n+    case _claim_finalizable:                out->print_cr(\"finalizable\"); break;\n+    case _claim_strong:                     out->print_cr(\"strong\"); break;\n+    case _claim_other:                      out->print_cr(\"other\"); break;\n+    case _claim_other | _claim_finalizable: out->print_cr(\"other and finalizable\"); break;\n+    case _claim_other | _claim_strong:      out->print_cr(\"other and strong\"); break;\n+    default:                                ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -211,3 +211,0 @@\n-bool java_lang_String::is_instance(oop obj) {\n-  return is_instance_inlined(obj);\n-}\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -240,3 +240,2 @@\n-  \/\/ Testers\n-  static bool is_instance(oop obj);\n-  static inline bool is_instance_inlined(oop obj);\n+  \/\/ Tester\n+  static inline bool is_instance(oop obj);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-bool java_lang_String::is_instance_inlined(oop obj) {\n+bool java_lang_String::is_instance(oop obj) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n@@ -438,0 +439,3 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n+    if (!UseAESIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -422,0 +422,5 @@\n+  do_class(com_sun_crypto_provider_galoisCounterMode, \"com\/sun\/crypto\/provider\/GaloisCounterMode\")                      \\\n+   do_intrinsic(_galoisCounterMode_AESCrypt, com_sun_crypto_provider_galoisCounterMode, gcm_crypt_name, aes_gcm_signature, F_S)   \\\n+   do_name(gcm_crypt_name, \"implGCMCrypt\")                                                                                 \\\n+   do_signature(aes_gcm_signature, \"([BII[BI[BILcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")                                                             \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -467,0 +467,1 @@\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), obj_ptr, word_sz);\n@@ -471,1 +472,0 @@\n-    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), obj_ptr, word_sz);\n@@ -483,9 +483,1 @@\n-      }\n-      if (old_mark.has_displaced_mark_helper()) {\n-        \/\/ In this case, we have to install the old mark word containing the\n-        \/\/ displacement tag, and update the age in the displaced mark word.\n-        markWord new_mark = old_mark.displaced_mark_helper().set_age(age);\n-        old_mark.set_displaced_mark_helper(new_mark);\n-        obj->set_mark(old_mark);\n-      } else {\n-        obj->set_mark(old_mark.set_age(age));\n+        obj->incr_age();\n@@ -494,2 +486,0 @@\n-    } else {\n-      obj->set_mark(old_mark);\n@@ -562,4 +552,1 @@\n-\n-    if (pss == NULL) {\n-      continue;\n-    }\n+    assert(pss != nullptr, \"must be initialized\");\n@@ -588,4 +575,1 @@\n-\n-    if (pss == NULL) {\n-      continue;\n-    }\n+    assert(pss != nullptr, \"must be initialized\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -107,0 +107,6 @@\n+void ParCompactionManager::flush_all_string_dedup_requests() {\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().total_workers();\n+  for (uint i=0; i<=parallel_gc_threads; i++) {\n+    _manager_array[i]->flush_string_dedup_requests();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/parallel\/psStringDedup.hpp\"\n@@ -1025,0 +1026,2 @@\n+  ParCompactionManager::flush_all_string_dedup_requests();\n+\n@@ -1793,1 +1796,1 @@\n-    marking_phase(vmthread_cm, maximum_heap_compaction, &_gc_tracer);\n+    marking_phase(vmthread_cm, &_gc_tracer);\n@@ -2078,1 +2081,0 @@\n-                                      bool maximum_heap_compaction,\n@@ -2283,1 +2285,0 @@\n-    MutableSpace* const space = space_info->space();\n@@ -3093,6 +3094,0 @@\n-\/\/\n-\/\/ For more details, please refer to ยง4.2 of the VEE'19 paper:\n-\/\/ Haoyu Li, Mingyu Wu, Binyu Zang, and Haibo Chen. 2019. ScissorGC: scalable and efficient\n-\/\/ compaction for Java full garbage collection. In Proceedings of the 15th ACM SIGPLAN\/SIGOPS\n-\/\/ International Conference on Virtual Execution Environments (VEE 2019). ACM, New York, NY, USA,\n-\/\/ 108-121. DOI: https:\/\/doi.org\/10.1145\/3313808.3313820\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+    manager->flush_string_dedup_requests();\n@@ -355,1 +356,1 @@\n-  if (obj->cas_forward_to(obj, obj_mark)) {\n+  if (obj->forward_to_atomic(obj, obj_mark) == NULL) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"gc\/serial\/serialStringDedup.hpp\"\n@@ -40,0 +42,6 @@\n+  if (StringDedup::is_enabled() &&\n+      java_lang_String::is_instance(obj) &&\n+      SerialStringDedup::is_candidate_from_mark(obj)) {\n+    _string_dedup_requests->add(obj);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -322,3 +322,0 @@\n-    static oop resolve(oop obj) {\n-      return Raw::resolve(obj);\n-    }\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2632,0 +2632,43 @@\n+C2V_VMENTRY(void, setThreadLocalObject, (JNIEnv* env, jobject, jint id, jobject value))\n+  requireInHotSpot(\"setThreadLocalObject\", JVMCI_CHECK);\n+  if (id == 0) {\n+    thread->set_jvmci_reserved_oop0(JNIHandles::resolve(value));\n+    return;\n+  }\n+  THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n+            err_msg(\"%d is not a valid thread local id\", id));\n+}\n+\n+C2V_VMENTRY_NULL(jobject, getThreadLocalObject, (JNIEnv* env, jobject, jint id))\n+  requireInHotSpot(\"getThreadLocalObject\", JVMCI_CHECK_NULL);\n+  if (id == 0) {\n+    return JNIHandles::make_local(thread->get_jvmci_reserved_oop0());\n+  }\n+  THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n+              err_msg(\"%d is not a valid thread local id\", id));\n+}\n+\n+C2V_VMENTRY(void, setThreadLocalLong, (JNIEnv* env, jobject, jint id, jlong value))\n+  requireInHotSpot(\"setThreadLocalLong\", JVMCI_CHECK);\n+  if (id == 0) {\n+    thread->set_jvmci_reserved0(value);\n+  } else if (id == 1) {\n+    thread->set_jvmci_reserved1(value);\n+  } else {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n+              err_msg(\"%d is not a valid thread local id\", id));\n+  }\n+}\n+\n+C2V_VMENTRY_0(jlong, getThreadLocalLong, (JNIEnv* env, jobject, jint id))\n+  requireInHotSpot(\"getThreadLocalLong\", JVMCI_CHECK_0);\n+  if (id == 0) {\n+    return thread->get_jvmci_reserved0();\n+  } else if (id == 1) {\n+    return thread->get_jvmci_reserved1();\n+  } else {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n+                err_msg(\"%d is not a valid thread local id\", id));\n+  }\n+}\n+\n@@ -2773,0 +2816,4 @@\n+  {CC \"getThreadLocalObject\",                         CC \"(I)\" OBJECT,                                                                      FN_PTR(getThreadLocalObject)},\n+  {CC \"setThreadLocalObject\",                         CC \"(I\" OBJECT \")V\",                                                                  FN_PTR(setThreadLocalObject)},\n+  {CC \"getThreadLocalLong\",                           CC \"(I)J\",                                                                            FN_PTR(getThreadLocalLong)},\n+  {CC \"setThreadLocalLong\",                           CC \"(IJ)V\",                                                                           FN_PTR(setThreadLocalLong)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-  nonstatic_field(JavaThread,                  _jvmci_reserved0,                              intptr_t*)                             \\\n-  nonstatic_field(JavaThread,                  _jvmci_reserved1,                              intptr_t*)                             \\\n+  nonstatic_field(JavaThread,                  _jvmci_reserved0,                              jlong)                                 \\\n+  nonstatic_field(JavaThread,                  _jvmci_reserved1,                              jlong)                                 \\\n@@ -311,0 +311,1 @@\n+  static_field(StubRoutines,                _galoisCounterMode_AESCrypt,                      address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -293,3 +293,1 @@\n-  \/\/ I would have liked to declare this a pure virtual, but that breaks\n-  \/\/ in mysterious ways, for unknown reasons.\n-  virtual void do_void();\n+  virtual void do_void() = 0;\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\/\/ * resolve: Resolve a stable to-space invariant oop that is guaranteed not to relocate its payload until a subsequent thread transition.\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -209,7 +209,0 @@\n-  template <class GCBarrierType, DecoratorSet decorators>\n-  struct PostRuntimeDispatch<GCBarrierType, BARRIER_RESOLVE, decorators>: public AllStatic {\n-    static oop access_barrier(oop obj) {\n-      return GCBarrierType::resolve(obj);\n-    }\n-  };\n-\n@@ -370,7 +363,0 @@\n-\n-  template <DecoratorSet decorators, typename T>\n-  oop RuntimeDispatch<decorators, T, BARRIER_RESOLVE>::resolve_init(oop obj) {\n-    func_t function = BarrierResolver<decorators, func_t, BARRIER_RESOLVE>::resolve_barrier();\n-    _resolve_func = function;\n-    return function(obj);\n-  }\n","filename":"src\/hotspot\/share\/oops\/access.inline.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,2 +75,1 @@\n-    BARRIER_VALUE_COPY,\n-    BARRIER_RESOLVE\n+    BARRIER_VALUE_COPY\n@@ -127,1 +126,0 @@\n-    typedef oop (*resolve_func_t)(oop obj);\n@@ -155,1 +153,0 @@\n-  ACCESS_GENERATE_ACCESS_FUNCTION(BARRIER_RESOLVE, resolve_func_t);\n@@ -405,1 +402,0 @@\n-\n@@ -408,1 +404,0 @@\n-  static oop resolve(oop obj) { return obj; }\n@@ -602,12 +597,0 @@\n-  template <DecoratorSet decorators, typename T>\n-  struct RuntimeDispatch<decorators, T, BARRIER_RESOLVE>: AllStatic {\n-    typedef typename AccessFunction<decorators, T, BARRIER_RESOLVE>::type func_t;\n-    static func_t _resolve_func;\n-\n-    static oop resolve_init(oop obj);\n-\n-    static inline oop resolve(oop obj) {\n-      return _resolve_func(obj);\n-    }\n-  };\n-\n@@ -659,4 +642,0 @@\n-  template <DecoratorSet decorators, typename T>\n-  typename AccessFunction<decorators, T, BARRIER_RESOLVE>::type\n-  RuntimeDispatch<decorators, T, BARRIER_RESOLVE>::_resolve_func = &resolve_init;\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -270,6 +270,0 @@\n-  \/\/ Should this header (including its age bits) be preserved in the\n-  \/\/ case of a promotion failure during scavenge?\n-  bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n-    return (!is_unlocked() || !has_no_hash() || (EnableValhalla && is_larval_state()));\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,1 +264,0 @@\n-  inline bool cas_forward_to(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -310,1 +309,0 @@\n-  inline bool mark_must_be_preserved_for_promotion_failure(markWord m) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n-  uintptr_t v = HeapAccess<MO_RELAXED>::load_at(as_oop(), mark_offset_in_bytes());\n-  return markWord(v);\n+  return Atomic::load(&_mark);\n@@ -53,2 +52,1 @@\n-  uintptr_t v = HeapAccess<MO_ACQUIRE>::load_at(as_oop(), mark_offset_in_bytes());\n-  return markWord(v);\n+  return Atomic::load_acquire(&_mark);\n@@ -62,1 +60,1 @@\n-  HeapAccess<MO_RELAXED>::store_at(as_oop(), mark_offset_in_bytes(), m.value());\n+  Atomic::store(&_mark, m);\n@@ -70,1 +68,1 @@\n-  HeapAccess<MO_RELEASE>::store_at(as_oop(), mark_offset_in_bytes(), m.value());\n+  Atomic::release_store(&_mark, m);\n@@ -74,2 +72,1 @@\n-  uintptr_t v = HeapAccess<>::atomic_cmpxchg_at(as_oop(), mark_offset_in_bytes(), old_mark.value(), new_mark.value());\n-  return markWord(v);\n+  return Atomic::cmpxchg(&_mark, old_mark, new_mark);\n@@ -296,8 +293,0 @@\n-\/\/ Used by parallel scavengers\n-bool oopDesc::cas_forward_to(oop p, markWord compare, atomic_memory_order order) {\n-  verify_forwardee(p);\n-  markWord m = markWord::encode_pointer_as_mark(p);\n-  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n-  return cas_set_mark(m, compare, order) == compare;\n-}\n-\n@@ -416,4 +405,0 @@\n-bool oopDesc::mark_must_be_preserved_for_promotion_failure(markWord m) const {\n-  return m.must_be_preserved_for_promotion_failure(this);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -649,0 +649,1 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1121,0 +1121,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"galoisCounterMode_AESCrypt\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2648,1 +2648,1 @@\n-    \/* close each nested if ===> *\/  } } } } } } } }\n+  \/* close each nested if ===> *\/  } } } } } } } }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -546,1 +546,1 @@\n-  bool block_size_threshold_ok = (block->number_of_nodes() > 10) ? true : false;\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n@@ -976,1 +976,1 @@\n-  bool block_size_threshold_ok = (block->number_of_nodes() > 10) ? true : false;\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -558,0 +558,3 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n+    return inline_galoisCounterMode_AESCrypt();\n+\n@@ -724,0 +727,2 @@\n+  case vmIntrinsics::_galoisCounterMode_AESCrypt:\n+    return inline_galoisCounterMode_AESCrypt_predicate();\n@@ -7059,0 +7064,128 @@\n+\/\/------------------------------inline_galoisCounterMode_AESCrypt-----------------------\n+bool LibraryCallKit::inline_galoisCounterMode_AESCrypt() {\n+  assert(UseAES, \"need AES instruction support\");\n+  address stubAddr = NULL;\n+  const char *stubName = NULL;\n+  stubAddr = StubRoutines::galoisCounterMode_AESCrypt();\n+  stubName = \"galoisCounterMode_AESCrypt\";\n+\n+  if (stubAddr == NULL) return false;\n+\n+  Node* in      = argument(0);\n+  Node* inOfs   = argument(1);\n+  Node* len     = argument(2);\n+  Node* ct      = argument(3);\n+  Node* ctOfs   = argument(4);\n+  Node* out     = argument(5);\n+  Node* outOfs  = argument(6);\n+  Node* gctr_object = argument(7);\n+  Node* ghash_object = argument(8);\n+\n+  \/\/ (1) in, ct and out are arrays.\n+  const Type* in_type = in->Value(&_gvn);\n+  const Type* ct_type = ct->Value(&_gvn);\n+  const Type* out_type = out->Value(&_gvn);\n+  const TypeAryPtr* top_in = in_type->isa_aryptr();\n+  const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n+  const TypeAryPtr* top_out = out_type->isa_aryptr();\n+  assert(top_in != NULL && top_in->klass() != NULL &&\n+         top_ct != NULL && top_ct->klass() != NULL &&\n+         top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n+\n+  \/\/ checks are the responsibility of the caller\n+  Node* in_start = in;\n+  Node* ct_start = ct;\n+  Node* out_start = out;\n+  if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n+    assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n+    in_start = array_element_address(in, inOfs, T_BYTE);\n+    ct_start = array_element_address(ct, ctOfs, T_BYTE);\n+    out_start = array_element_address(out, outOfs, T_BYTE);\n+  }\n+\n+  \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n+  \/\/ (because of the predicated logic executed earlier).\n+  \/\/ so we cast it here safely.\n+  \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n+  Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+  Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n+  Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n+  Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n+\n+  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n+      return false;\n+  }\n+  \/\/ cast it to what we know it will be at runtime\n+  const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n+  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n+  ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n+  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n+  const TypeOopPtr* xtype = aklass->as_instance_type();\n+  Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n+  aescrypt_object = _gvn.transform(aescrypt_object);\n+  \/\/ we need to get the start of the aescrypt_object's expanded key array\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  if (k_start == NULL) return false;\n+\n+  \/\/ similarly, get the start address of the r vector\n+  Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n+  Node* state_start = array_element_address(state, intcon(0), T_LONG);\n+  Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n+\n+  \/\/ Call the stub, passing params\n+  Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                               OptoRuntime::galoisCounterMode_aescrypt_Type(),\n+                               stubAddr, stubName, TypePtr::BOTTOM,\n+                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n+\n+  \/\/ return cipher length (int)\n+  Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n+  set_result(retvalue);\n+  return true;\n+}\n+\n+\/\/----------------------------inline_galoisCounterMode_AESCrypt_predicate----------------------------\n+\/\/ Return node representing slow path of predicate check.\n+\/\/ the pseudo code we want to emulate with this predicate is:\n+\/\/ for encryption:\n+\/\/    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath\n+\/\/ for decryption:\n+\/\/    if ((embeddedCipherObj instanceof AESCrypt) && (cipher!=plain)) do_intrinsic, else do_javapath\n+\/\/    note cipher==plain is more conservative than the original java code but that's OK\n+\/\/\n+\n+Node* LibraryCallKit::inline_galoisCounterMode_AESCrypt_predicate() {\n+  \/\/ The receiver was checked for NULL already.\n+  Node* objGCTR = argument(7);\n+  \/\/ Load embeddedCipher field of GCTR object.\n+  Node* embeddedCipherObj = load_field_from_object(objGCTR, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+  assert(embeddedCipherObj != NULL, \"embeddedCipherObj is null\");\n+\n+  \/\/ get AESCrypt klass for instanceOf check\n+  \/\/ AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point\n+  \/\/ will have same classloader as CipherBlockChaining object\n+  const TypeInstPtr* tinst = _gvn.type(objGCTR)->isa_instptr();\n+  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+\n+  \/\/ we want to do an instanceof comparison against the AESCrypt class\n+  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  if (!klass_AESCrypt->is_loaded()) {\n+    \/\/ if AESCrypt is not even loaded, we never take the intrinsic fast path\n+    Node* ctrl = control();\n+    set_control(top()); \/\/ no regular fast path\n+    return ctrl;\n+  }\n+\n+  ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n+  Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));\n+  Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));\n+  Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));\n+  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+\n+  return instof_false; \/\/ even if it is NULL\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -341,0 +341,2 @@\n+  bool inline_galoisCounterMode_AESCrypt();\n+  Node* inline_galoisCounterMode_AESCrypt_predicate();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1607,0 +1607,3 @@\n+  bool is_raw_to_oop_cast = n->is_ConstraintCast() &&\n+                            n->in(1)->bottom_type()->isa_rawptr() &&\n+                            !n->bottom_type()->isa_rawptr();\n@@ -1613,0 +1616,1 @@\n+      !is_raw_to_oop_cast && \/\/ don't extend live ranges of raw oops\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-                                                 mem->in(0)->Opcode() == Op_MemBarCPUOrder)) {\n+                                               mem->in(0)->Opcode() == Op_MemBarCPUOrder)) {\n@@ -1072,1 +1072,0 @@\n-    bool final = !atp->is_rewritable();\n@@ -1080,1 +1079,4 @@\n-    \/\/ a synchronized region.\n+    \/\/ a synchronized region. It is not safe to step over MemBarCPUOrder,\n+    \/\/ because alias info above them may be inaccurate (e.g., due to\n+    \/\/ mixed\/mismatched unsafe accesses).\n+    bool is_final_mem = !atp->is_rewritable();\n@@ -1083,3 +1085,3 @@\n-      if ((final && (opc == Op_MemBarAcquire ||\n-                     opc == Op_MemBarAcquireLock ||\n-                     opc == Op_LoadFence)) ||\n+      if ((is_final_mem && (opc == Op_MemBarAcquire ||\n+                            opc == Op_MemBarAcquireLock ||\n+                            opc == Op_LoadFence)) ||\n@@ -1089,2 +1091,1 @@\n-          opc == Op_MemBarStoreStore ||\n-          opc == Op_MemBarCPUOrder) {\n+          opc == Op_MemBarStoreStore) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -964,0 +964,25 @@\n+\/\/for counterMode calls of aescrypt encrypt\/decrypt, four pointers and a length, returning int\n+const TypeFunc* OptoRuntime::galoisCounterMode_aescrypt_Type() {\n+  \/\/ create input type (domain)\n+  int num_args = 8;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ byte[] in + inOfs\n+  fields[argp++] = TypeInt::INT;     \/\/ int len\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ byte[] ct + ctOfs\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ byte[] out + outOfs\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ byte[] key from AESCrypt obj\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ long[] state from GHASH obj\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ long[] subkeyHtbl from GHASH obj\n+  fields[argp++] = TypePtr::NOTNULL; \/\/ byte[] counter from GCTR obj\n+\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+  \/\/ returning cipher len (int)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT;\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -260,0 +260,1 @@\n+  static const TypeFunc* galoisCounterMode_aescrypt_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3781,1 +3781,1 @@\n-    ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);\n+    ThreadStateTransition::transition_from_vm(thread, _thread_in_native);\n@@ -4001,5 +4001,2 @@\n-  \/\/ of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by\n-  \/\/ using ThreadStateTransition::transition, we do a callback to the safepoint code if\n-  \/\/ needed.\n-\n-  ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);\n+  \/\/ of in the JVM_ENTRY. But in this situation we have to do it manually.\n+  ThreadStateTransition::transition_from_vm(thread, _thread_in_native);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-         ThreadStateTransition::transition(_jthread, _saved_state, _thread_in_native);\n+         ThreadStateTransition::transition_from_vm(_jthread, _thread_in_native);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  if (!java_lang_String::is_instance_inlined(type())) {\n+  if (!java_lang_String::is_instance(type())) {\n@@ -542,1 +542,1 @@\n-  } else if (java_lang_String::is_instance_inlined(type_str)) {\n+  } else if (java_lang_String::is_instance(type_str)) {\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-          \"Zap freed resource\/arena space with 0xABABABAB\")                 \\\n+          \"Zap freed resource\/arena space\")                                 \\\n@@ -463,1 +463,1 @@\n-          \"Zap freed VM handle space with 0xBCBCBCBC\")                      \\\n+          \"Zap freed VM handle space\")                                      \\\n@@ -466,1 +466,1 @@\n-          \"Zap allocated\/freed stack segments with 0xFADFADED\")             \\\n+          \"Zap allocated\/freed stack segments\")                             \\\n@@ -469,1 +469,1 @@\n-          \"Zap unused heap space with 0xBAADBABE\")                          \\\n+          \"Zap unused heap space\")                                          \\\n@@ -475,1 +475,1 @@\n-          \"Zap filler objects with 0xDEAFBABE\")                             \\\n+          \"Zap filler objects\")                                             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  bool clear_pending_exception = true;\n@@ -69,0 +68,3 @@\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  thread->clear_pending_exception();\n+\n@@ -71,11 +73,1 @@\n-  ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_Java);\n-\n-  \/\/ Make sure that we handle asynchronous stops and suspends _before_ we clear all thread state\n-  \/\/ in JavaCallWrapper::JavaCallWrapper(). This way, we can decide if we need to do any pd actions\n-  \/\/ to prepare for stop\/suspend (flush register windows on sparcs, cache sp, or other state).\n-  if (thread->has_special_runtime_exit_condition()) {\n-    thread->handle_special_runtime_exit_condition();\n-    if (HAS_PENDING_EXCEPTION) {\n-      clear_pending_exception = false;\n-    }\n-  }\n+  ThreadStateTransition::transition_from_vm(thread, _thread_in_Java, true \/* check_asyncs *\/);\n@@ -108,5 +100,0 @@\n-  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n-  if(clear_pending_exception) {\n-    _thread->clear_pending_exception();\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+address StubRoutines::_galoisCounterMode_AESCrypt          = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+  static address _galoisCounterMode_AESCrypt;\n@@ -416,0 +417,1 @@\n+  static address galoisCounterMode_AESCrypt()   { return _galoisCounterMode_AESCrypt; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1020,2 +1020,2 @@\n-  _jvmci_reserved0(nullptr),\n-  _jvmci_reserved1(nullptr),\n+  _jvmci_reserved0(0),\n+  _jvmci_reserved1(0),\n@@ -1231,1 +1231,3 @@\n-  ThreadStateTransition::transition(this, _thread_new, _thread_in_vm);\n+  assert(this->thread_state() == _thread_new, \"wrong thread state\");\n+  set_thread_state(_thread_in_vm);\n+\n@@ -1648,1 +1650,1 @@\n-      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in a recent unsafe memory access operation in compiled Java code\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation in compiled Java code\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -963,2 +963,2 @@\n-  intptr_t*  _jvmci_reserved0;\n-  intptr_t*  _jvmci_reserved1;\n+  jlong      _jvmci_reserved0;\n+  jlong      _jvmci_reserved1;\n@@ -975,0 +975,24 @@\n+  void set_jvmci_reserved_oop0(oop value) {\n+    _jvmci_reserved_oop0 = value;\n+  }\n+\n+  oop get_jvmci_reserved_oop0() {\n+    return _jvmci_reserved_oop0;\n+  }\n+\n+  void set_jvmci_reserved0(jlong value) {\n+    _jvmci_reserved0 = value;\n+  }\n+\n+  jlong get_jvmci_reserved0() {\n+    return _jvmci_reserved0;\n+  }\n+\n+  void set_jvmci_reserved1(jlong value) {\n+    _jvmci_reserved1 = value;\n+  }\n+\n+  jlong get_jvmci_reserved1() {\n+    return _jvmci_reserved1;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -545,0 +545,1 @@\n+     static_field(StubRoutines,                _galoisCounterMode_AESCrypt,                   address)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -587,0 +587,40 @@\n+    \/**\n+     * Sets the current thread's {@code JavaThread::_jvmci_reserved_oop<id>} field to {@code value}.\n+     *\n+     * @throws IllegalArgumentException if the {@code JavaThread::_jvmci_reserved_oop<id>} field\n+     *             does not exist\n+     *\/\n+    public void setThreadLocalObject(int id, Object value) {\n+        compilerToVm.setThreadLocalObject(id, value);\n+    }\n+\n+    \/**\n+     * Get the value of the current thread's {@code JavaThread::_jvmci_reserved_oop<id>} field.\n+     *\n+     * @throws IllegalArgumentException if the {@code JavaThread::_jvmci_reserved_oop<id>} field\n+     *             does not exist\n+     *\/\n+    public Object getThreadLocalObject(int id) {\n+        return compilerToVm.getThreadLocalObject(id);\n+    }\n+\n+    \/**\n+     * Sets the current thread's {@code JavaThread::_jvmci_reserved<id>} field to {@code value}.\n+     *\n+     * @throws IllegalArgumentException if the {@code JavaThread::_jvmci_reserved<id>} field does\n+     *             not exist\n+     *\/\n+    public void setThreadLocalLong(int id, long value) {\n+        compilerToVm.setThreadLocalLong(id, value);\n+    }\n+\n+    \/**\n+     * Get the value of the current thread's {@code JavaThread::_jvmci_reserved<id>} field.\n+     *\n+     * @throws IllegalArgumentException if the {@code JavaThread::_jvmci_reserved<id>} field does\n+     *             not exist\n+     *\/\n+    public long getThreadLocalLong(int id) {\n+        return compilerToVm.getThreadLocalLong(id);\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}