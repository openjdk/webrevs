{"files":[{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @summary Sanity test for BigClassTreeClassLoader\n+ * @enablePreview\n+ * @run main BigClassTreeClassLoader\n+ *\/\n+\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.constant.*;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/\/ A classloader that will generate a big value class inheritance tree (depth,\n+\/\/ and possibly breadth) of classes on the fly. For example, with a\n+\/\/ maximum depth limit of 3, one can load \"Gen3\" via this classloader,\n+\/\/ which will generate the following:\n+\/\/\n+\/\/ public value class Gen2 --> Gen1 --> Gen0 --> java.lang.Object\n+\/\/\n+\/\/ Optionally, a long field chain can also be generated in one of the Gen classes.\n+\/\/ This creates a chain of Field value classes which have other Field objects as\n+\/\/ fields up to the maximum depth. Class depth = field width. Only the Gen's field\n+\/\/ is static, the rest are not. For example, with a maximum depth limit of 3 and\n+\/\/ field at 1, this classloader will generate the following:\n+\/\/\n+\/\/ public value class Gen2 --> Gen1 --> Gen0 --> java.lang.Object\n+\/\/                              | public static Field2 theField;\n+\/\/         public value class Field2\n+\/\/                              | theField\n+\/\/                            Field1\n+\/\/                              | theField\n+\/\/                            Field0\n+\/\/\n+\/\/ Field0 will have a field theField of java.lang.Object. It is possible to change\n+\/\/ both the field class as well as the superclass of Field0 to introduce interesting\n+\/\/ class circularity.\n+\/\/\n+\/\/ This classloader is parallel capable. It uses the built in classloading lock via\n+\/\/ loadClass to ensure that it defines a given GenX or FieldX only once.\n+public class BigClassTreeClassLoader extends ClassLoader {\n+\n+    \/\/ Sanity test, this should never fail.\n+    public static void main(String[] args) throws ClassNotFoundException {\n+        var fields = new FieldGeneration(1, Optional.empty(), Optional.empty());\n+        Class.forName(\"Gen2\", false, new BigClassTreeClassLoader(3, fields));\n+    }\n+\n+    \/\/ A field generation strategy that disables field generation.\n+    public static FieldGeneration NO_FIELD_GEN = new FieldGeneration(-1, Optional.empty(), Optional.empty());\n+\n+    \/\/ A sane depth\/width limit.\n+    private static final int SANE_LIMIT = 100;\n+\n+    \/\/ We want to perform different things depending on what kind of class we are\n+    \/\/ generating. Therefore, we utilize a strategy pattern.\n+    private final Strategy[] availableStrategies;\n+\n+    \/\/ A store of all the classes already defined. Existing classes must be reused\n+    \/\/ otherwise an exception will be raised.\n+    private final Map<String, Class<?>> defined;\n+\n+    private final int limitInclusive;\n+\n+    \/\/ Create the generator with no fields.\n+    public BigClassTreeClassLoader(int depthLimitInclusive) {\n+        this(depthLimitInclusive, NO_FIELD_GEN);\n+    }\n+\n+    \/\/ Create the generator with fields.\n+    public BigClassTreeClassLoader(int depthLimitInclusive,\n+                                   FieldGeneration fields) {\n+        if (depthLimitInclusive < 0 || depthLimitInclusive > SANE_LIMIT) {\n+            throw new IllegalArgumentException(\"depth limit beyond sane bounds\");\n+        }\n+        \/\/ Make it compatible with zero indices.\n+        this.limitInclusive = depthLimitInclusive - 1;\n+        this.defined = new HashMap<>();\n+        if (fields.index > limitInclusive) {\n+            throw new IllegalArgumentException(\"field generation index invalid\");\n+        }\n+        this.availableStrategies = new Strategy[] { new GenStrategy(fields.index), new FieldStrategy(fields) };\n+        \/\/ Finally, register as a parallel capable classloader for stress tests.\n+        if(!registerAsParallelCapable() || !isRegisteredAsParallelCapable()) {\n+            throw new IllegalStateException(\"could not register parallel classloader\");\n+        }\n+    }\n+\n+    \/\/ The index X means GenX will have the field. Set to -1 to disable.\n+    \/\/ The furthest chained field Field0 can have an optional superclass\/declared field.\n+    public static record FieldGeneration (int index,\n+                                          Optional<String> deepestParentClass,\n+                                          Optional<String> deepestFieldClass) {}\n+\n+    \/\/ We will bottom-up generate a class tree. It knows what to do for a\n+    \/\/ specific class based on the provided name. This is not thread-safe itself,\n+    \/\/ but since it is called safely via a synchronized block in loadClass,\n+    \/\/ adding custom synchronization primitives can yield in a deadlock.\n+    public Class<?> findClass(final String name) throws ClassNotFoundException {\n+        \/\/ We only generate classes starting with our known prefix.\n+        final Strategy strategy = Arrays.stream(availableStrategies)\n+                                        .filter(st -> name.startsWith(st.prefix()))\n+                                        .findFirst()\n+                                        .orElseThrow(ClassNotFoundException::new);\n+        \/\/ Derive the correct parameters (or error).\n+        String prefix = strategy.prefix();\n+        int depth;\n+        try {\n+            String itersString = name.substring(prefix.length());\n+            depth = Integer.parseInt(itersString);\n+            \/\/ Some bounds sanity checking.\n+            if (depth < 0 || depth > limitInclusive) {\n+                throw new IllegalArgumentException(\"attempting to generate beyond limits\");\n+            }\n+        } catch (IllegalArgumentException | IndexOutOfBoundsException e) {\n+            throw new ClassNotFoundException(\"can't generate class since it does not conform to limits\", e);\n+        }\n+        \/\/ If we have already generated this class, reuse it.\n+        Class<?> clazz = defined.get(name);\n+        if (clazz != null) {\n+            return clazz;\n+        }\n+        \/\/ Make the actual and define it.\n+        clazz = makeClass(name,\n+                          strategy.parent(depth),\n+                          strategy.flags(limitInclusive, depth),\n+                          clb -> strategy.process(limitInclusive, depth, clb),\n+                          cob -> strategy.constructorPre(limitInclusive, depth, cob)\n+        );\n+        return clazz;\n+    }\n+\n+    private interface Strategy {\n+        String prefix();\n+        String parent(int depth);\n+        int flags(int limitInclusive, int depth);\n+        void process(int limitInclusive, int depth, ClassBuilder builder);\n+        default void constructorPre(int limitInclusive, int depth, CodeBuilder builder) {}\n+    }\n+\n+    \/\/ The Gen classes generate classes that have a large inheritance tree.\n+    \/\/ GenX has Gen(X-1) as a superclass. Gen0 inherits from Object.\n+    private static final class GenStrategy implements Strategy {\n+        private final int fieldIndex;\n+\n+        public GenStrategy(int fieldIndex) {\n+            this.fieldIndex = fieldIndex;\n+        }\n+\n+        public String prefix() {\n+            return \"Gen\";\n+        }\n+\n+        public String parent(int depth) {\n+            return depth == 0 ? Object.class.getName() : prefix() + (depth - 1);\n+        }\n+\n+        public int flags(int limitInclusive, int depth) {\n+            return depth == limitInclusive ? ACC_FINAL : ACC_ABSTRACT;\n+        }\n+\n+        public void process(int limitInclusive, int depth, ClassBuilder builder) {\n+            \/\/ Is this the generation that will have the field chain?\n+            if (depth == fieldIndex) {\n+                ClassDesc fieldClass = ClassDesc.of(FieldStrategy.PREFIX + \"\" + limitInclusive);\n+                \/\/ We use an uninitialized static field to denote the outermost Field class.\n+                builder.withField(\"theField\", fieldClass, ACC_PUBLIC | ACC_STATIC)\n+                       .with(LoadableDescriptorsAttribute.of(builder.constantPool().utf8Entry(fieldClass)));\n+            }\n+        }\n+    }\n+\n+    \/\/ The field strategy allows generating deep fields, including potential circularity.\n+    \/\/ FieldX has Field(X-1) as a field. Field0 is special as it can inherit from something\n+    \/\/ other than Object, and contain a custom field.\n+    private static final class FieldStrategy implements Strategy {\n+        public static final String PREFIX = \"Field\";\n+        private final FieldGeneration fields;\n+\n+        public FieldStrategy(FieldGeneration fields) {\n+            this.fields = fields;\n+        }\n+\n+        public String prefix() {\n+            return PREFIX;\n+        }\n+\n+        public String parent(int depth) {\n+            \/\/ Only the deepest class has a custom parent.\n+            return fields.deepestParentClass().filter(_ -> depth == 0).orElse(Object.class.getName());\n+        }\n+\n+        public int flags(int limitInclusive, int depth) {\n+            \/\/ Every field class is final.\n+            return ACC_FINAL;\n+        }\n+\n+        public void process(int limitInclusive, int depth, ClassBuilder builder) {\n+            ClassDesc fieldClass = computeFieldClass(depth);\n+            if (depth != 0) {\n+                builder.with(LoadableDescriptorsAttribute.of(builder.constantPool().utf8Entry(fieldClass)));\n+            }\n+            \/\/ The field is non-static, final, and therefore needs ACC_STRICT_INIT\n+            builder.withField(\"theField\", fieldClass, ACC_PUBLIC | ACC_FINAL | ACC_STRICT_INIT);\n+        }\n+\n+        public void constructorPre(int limitInclusive, int depth, CodeBuilder builder) {\n+            ClassDesc thisField = ClassDesc.of(prefix() + \"\" + depth);\n+            ClassDesc fieldClass = computeFieldClass(depth);\n+            \/\/ We need to make sure to initialize the field as the first thing in the constructor.\n+            builder.aload(0)\n+                   .aconst_null()\n+                   .putfield(thisField, \"theField\", fieldClass);\n+        }\n+\n+        private ClassDesc computeFieldClass(int depth) {\n+            if (depth == 0) {\n+                return ClassDesc.of(fields.deepestFieldClass().orElse(Object.class.getName()));\n+            } else {\n+                return ClassDesc.of(prefix() + (depth - 1));\n+            }\n+        }\n+    }\n+\n+    \/\/ Make the class. Not thread-safe, should be called when obtaining a\n+    \/\/ classloading lock for the particular class.\n+    private Class<?> makeClass(String thisGen,\n+                                String parentGen,\n+                                int addFlags,\n+                                Consumer<ClassBuilder> classBuilder,\n+                                Consumer<CodeBuilder> constructorBuilder) {\n+        ClassDesc parentDesc = ClassDesc.of(parentGen);\n+        \/\/ A class that has itself as a loadable descriptor.\n+        byte[] bytes = ClassFile.of().build(ClassDesc.of(thisGen), clb -> {\n+            clb\n+                \/\/ Use Valhalla version.\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                \/\/ Explicitly do not add ACC_SUPER or ACC_ABSTRACT.\n+                .withFlags(ACC_PUBLIC | addFlags)\n+                \/\/ Not strictly necessary for java\/lang\/Object.\n+                .withSuperclass(parentDesc)\n+                \/\/ Make sure to init the correct superclass.\n+                .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                    constructorBuilder.accept(cob);\n+                    cob.aload(0)\n+                       .invokespecial(parentDesc, INIT_NAME, MTD_void)\n+                       .return_();\n+                });\n+            \/\/ Do the additional things defined by the strategy.\n+            classBuilder.accept(clb);\n+        });\n+        \/\/ Define the actual class and register it.\n+        Class<?> clazz = defineClass(thisGen, bytes, 0, bytes.length);\n+        defined.put(thisGen, clazz);\n+        return clazz;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/BigClassTreeClassLoader.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+class Child {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  69; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"Child\"; \/\/ #1\n+    class #1; \/\/ #2\n+    Utf8 \"Parent\"; \/\/ #3\n+    class #3; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    NameAndType #5 #6; \/\/ #7\n+    Method #4 #7; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access NOTE: this is a value class, which cannot inherit from identity\n+  #2;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70008B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+  } \/\/ Attributes\n+} \/\/ end class Child\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/Child.jcod","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Invokes eight threads that concurrently have to resolve the same\n+            set of classes, thereby putting stress on the classloader and\n+            deadlocks will be noticed. This execution is iterated many times.\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile BigClassTreeClassLoader.java\n+ * @run junit\/othervm ConcurrentClassLoadingTest\n+ *\/\n+\n+import java.util.Optional;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/\/ This test makes use of BigClassTreeClassLoader. Please refer to its documentation.\n+class ConcurrentClassLoadingTest {\n+    private static final boolean DEBUG = false;\n+    private static final int N_ITER = 100;\n+    private static final int DEPTH = 100;\n+\n+    void test() throws InterruptedException {\n+        for (int i = 1; i <= N_ITER; i++) {\n+            if (DEBUG) System.out.println(\"Iteration \" + i);\n+            doIteration(8);\n+        }\n+    }\n+\n+    \/\/ Should crash the VM if it fails\/deadlocks.\n+    private void doIteration(int n) throws InterruptedException {\n+        \/\/ Use a barrier to ensure all threads reach a certain point before calling\n+        \/\/ the method that defines the class (which internally calls native code).\n+        final CyclicBarrier barrier = new CyclicBarrier(n);\n+        \/\/ Every iteration has a new instance of a class loader, to make sure we\n+        \/\/ create unique (Class, ClassLoader) pairs to force loading.\n+        \/\/ We generate DEPTH fields, and they are defined in childmost class.\n+        var fields = new BigClassTreeClassLoader.FieldGeneration(DEPTH - 1, Optional.empty(), Optional.empty());\n+        \/\/ Instantiate the class generating classloader.\n+        final var cl = new BigClassTreeClassLoader(DEPTH, fields);\n+        Thread[] threads = new Thread[n];\n+        \/\/ Spawn all the threads with their respective worker classes.\n+        for (int i = 0; i < n; i++) {\n+            Thread thread = new Thread(() -> {\n+                try {\n+                    \/\/ Wait for all threads to reach this point.\n+                    barrier.await();\n+                    \/\/ This will trigger the generation and loading of the childmost class.\n+                    \/\/ That itself will trigger loading of many field value classes.\n+                    Class<?> workerClass = Class.forName(\"Gen\" + (DEPTH - 1), false, cl);\n+                    Object worker = workerClass.getDeclaredConstructor().newInstance();\n+                } catch(InterruptedException | BrokenBarrierException e) {\n+                    throw new IllegalStateException(\"test setup: waiting for barrier saw error\", e);\n+                } catch(ReflectiveOperationException e) {\n+                    \/\/ A ReflectiveOperationException could get thrown if\n+                    \/\/ something goes wrong internally. This should make the test\n+                    \/\/ case fail as it represents a real problem.\n+                    throw new IllegalStateException(\"reflective exception, could be an underlying bug\", e);\n+                }\n+            });\n+            threads[i] = thread;\n+            thread.start();\n+        }\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/ConcurrentClassLoadingTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+public value class InnerValue {\n+    public int x = 19;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/InnerValue.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Ensures preloading.\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @run junit LoadableDescriptorsTest\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.LoadableDescriptorsAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.Field;\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/\/ NOTE: Needs further work for JDK-8367134.\n+class LoadableDescriptorsTest {\n+    private static final boolean DEBUG = false;\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"LTest;\",\n+        \"I\",\n+        \"[[LTest;\",\n+    })\n+    void test(String descriptorString) throws ReflectiveOperationException {\n+        ClassDesc loadableClass = ClassDesc.ofDescriptor(descriptorString);\n+        var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+            clb\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n+                .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob ->\n+                cob.aload(0)\n+                    .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                    .return_())\n+                    .withField(\"theField\", loadableClass, ACC_PUBLIC)\n+                .with(LoadableDescriptorsAttribute.of(clb.constantPool().utf8Entry(loadableClass)))\n+        );\n+\n+        Class<?> clazz = ByteCodeLoader.load(\"Test\", bytes);\n+        Object instance = clazz.getDeclaredConstructor().newInstance();\n+        Field field = clazz.getDeclaredField(\"theField\");\n+        field.get(instance);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/LoadableDescriptorsTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+public value class OuterValue {\n+    public InnerValue inner = null;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/OuterValue.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+class Parent {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  69; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"Parent\"; \/\/ #1\n+    class #1; \/\/ #2\n+    Utf8 \"java\/lang\/Object\"; \/\/ #3\n+    class #3; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    NameAndType #5 #6; \/\/ #7\n+    Method #4 #7; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access NOTE: this is an identity class\n+  #2;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70008B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+  } \/\/ Attributes\n+} \/\/ end class Parent\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/Parent.jcod","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Ensures circularity does not cause crashes.\n+ * @enablePreview\n+ * @compile BigClassTreeClassLoader.java\n+ * @run junit PreLoadCircularityTest\n+ *\/\n+\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+\/\/ This test makes use of BigClassTreeClassLoader. Please refer to its documentation.\n+class PreLoadCircularityTest {\n+\n+    @ParameterizedTest\n+    @MethodSource(\"constellations\")\n+    void test(int depth, int fieldIndex, Optional<String> fieldClass, Optional<String> parentClass)\n+            throws ClassNotFoundException, ReflectiveOperationException {\n+        \/\/ Create the generator.\n+        var fg = new BigClassTreeClassLoader.FieldGeneration(fieldIndex, fieldClass, parentClass);\n+        BigClassTreeClassLoader cl = new BigClassTreeClassLoader(depth, fg);\n+        \/\/ Generate the classes!\n+        Class<?> clazz = Class.forName(\"Gen\" + (depth - 1), false, cl);\n+        clazz.getDeclaredConstructor().newInstance();\n+    }\n+\n+    private static Stream<Arguments> constellations() {\n+        return Stream.of(\n+            \/\/ Class Gen10 will have 30 fields and Field0 will inherit from Gen15.\n+            \/\/ This forms a cycle through field preloading and inheritance.\n+            Arguments.of(30, 10, Optional.of(Object.class.getName()), Optional.of(\"Gen15\")),\n+            \/\/ Class Gen10 will have 30 fields and Field0 will refer to Gen10.\n+            \/\/ This forms a cycle through field preloading.\n+            Arguments.of(30, 10, Optional.of(\"Gen10\"), Optional.empty()),\n+            \/\/ Class Gen10 will have 30 fields and Field0 will inherit from\n+            \/\/ Gen15 and refer to Gen13. This forms a cycle through field and\n+            \/\/ inheritance preloading.\n+            Arguments.of(30, 10, Optional.of(\"Gen13\"), Optional.of(\"Gen15\"))\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/PreLoadCircularityTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Ensures that a value class is not initialized when preloaded.\n+ * @enablePreview\n+ * @run junit PreLoadDoesNotInitTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+class PreLoadDoesNotInitTest {\n+\n+    @Test\n+    void test() {\n+        Outer outer = new Outer();\n+        outer.doSomething();\n+        if (Outer.THE_FIELD != 19) {\n+            throw new IllegalStateException(\"class was initialized when it should not have been\");\n+        }\n+        \/\/ Sanity: make sure it loads when we actually use it.\n+        new Inner();\n+        if (Outer.THE_FIELD != 0) {\n+            throw new IllegalStateException(\"class was not initialized when it should have been\");\n+        }\n+    }\n+\n+    public static class Outer {\n+        \/\/ Value class as a field should ensure that Outer contains a loadable\n+        \/\/ descriptor for it. We will preload Inner.\n+        private Inner inner;\n+\n+        \/\/ This is a static field that gets updated by Inner's static\n+        \/\/ initializer. We expect this to remain as 19.\n+        public static int THE_FIELD = 19;\n+\n+        private void doSomething() {}\n+    }\n+\n+    public static value class Inner {\n+        private int x = 0;\n+\n+        static {\n+            \/\/ This static field only gets updated once Inner is initialized.\n+            \/\/ In this test case, this should NOT happen.\n+            Outer.THE_FIELD = 0;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/PreLoadDoesNotInitTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Even if LoadableDescriptors fail, we observe correct operation.\n+            This uses a custom classloader to ensure that classloading\/linking will\n+            initially fail due to LoadableDescriptors.\n+   @compile OuterValue.java\n+   @compile InnerValue.java\n+ * @enablePreview\n+ * @run junit PreLoadFailuresDoNotImpactApplicationTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class PreLoadFailuresDoNotImpactApplicationTest {\n+\n+    @Test\n+    void test() throws ReflectiveOperationException, InterruptedException {\n+        \/\/ Create an instance of the Outer class with a custom classloader.\n+        \/\/ This should trigger the first preload.\n+        Class<?> clazz = Class.forName(\"OuterValue\", false, new CL());\n+        Object outer = clazz.getDeclaredConstructor().newInstance();\n+        \/\/ Each thread will try to load the field inner. We have to do getDeclaredField in each thread\n+        \/\/ as this attempts to load the class Inner which is what we want to fail on the first time.\n+        Thread t1 = new Thread(() -> {\n+            try {\n+                \/\/ Here the classloader will instigate a failure twice:\n+                \/\/ 1) when linking Inner due to LoadableDescriptor failing, this failure is quiet; and\n+                \/\/ 2) a \"normal\" ClassNotFound error that should get picked up by the application.\n+                var theField = clazz.getDeclaredField(\"inner\");\n+                Object theInner = theField.get(outer);\n+                throw new RuntimeException(\"should have failed classloading Inner fist time, VM bug\");\n+            } catch (NoClassDefFoundError workingAsIntended) {\n+            } catch (IllegalAccessException | NoSuchFieldException e) {\n+                throw new RuntimeException(\"test bug: field accessing\", e);\n+            }\n+        });\n+        \/\/ Execution need not be concurrent or parallel.\n+        \/\/ Let this thread fail at classloading Inner.\n+        t1.start();\n+        t1.join();\n+        Thread t2 = new Thread(() -> {\n+            try {\n+                \/\/ Here, the classloader will not fail, this should be business as usual.\n+                var theField = clazz.getDeclaredField(\"inner\");\n+                Object theInner = theField.get(outer);\n+            } catch (NoClassDefFoundError e) {\n+                throw new IllegalStateException(\"should not have failed classloading Inner second time, VM bug\", e);\n+            } catch (IllegalAccessException | NoSuchFieldException e) {\n+                throw new RuntimeException(\"test bug: field accessing\", e);\n+            }\n+        });\n+        \/\/ This execution should succeed.\n+        t2.start();\n+        t2.join();\n+    }\n+\n+    \/\/ This classloader uses loadClass instead of overriding findClass because it makes the test logic\n+    \/\/ a bit easier to write and understand. For the purpose of this test, overriding loadClass should\n+    \/\/ be fine.\n+    static class CL extends ClassLoader {\n+        private int attempts = 0;\n+\n+        public synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+            switch (name) {\n+            case \"OuterValue\": {\n+                return customLoadSimple(name);\n+            }\n+            case \"InnerValue\": {\n+                \/\/ First access failure: when Outer is preloading Inner via LoadableDescriptor.\n+                \/\/ Second access failure: when we try to load Inner the first time (LoadableDescriptor).\n+                \/\/ Third access failure: when class linking occurs (LoadableDescriptor).\n+                \/\/ Fourth access and onwards should succeed.\n+                if (attempts++ < 3) {\n+                    throw new ClassNotFoundException(\"purposeful exception: we can't find this class\");\n+                }\n+                return customLoadSimple(name);\n+            }\n+            default:\n+                \/\/ Delegate loading to the parent classloader.\n+                return super.loadClass(name, resolve);\n+            }\n+        }\n+\n+        \/\/ This will get the class data as a byte[]. DOES NOT support packages.\n+        private Class<?> customLoadSimple(String name) {\n+            byte[] bytes;\n+            try {\n+                bytes = PreLoadFailuresDoNotImpactApplicationTest.class\n+                    .getClassLoader()\n+                    .getResourceAsStream(name + \".class\")\n+                    .readAllBytes();\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\"test bug: IO exception trying to load custom class \" + name, e);\n+            }\n+            return defineClass(name, bytes, 0, bytes.length, null);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/PreLoadFailuresDoNotImpactApplicationTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @summary Ensures a non-abstract value class cannot inherit from an identity class.\n+ * @enablePreview\n+ * @clean Parent\n+ * @clean Child\n+ * @compile Parent.jcod\n+ * @compile Child.jcod\n+ * @run junit ValueClassInheritanceTest\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class ValueClassInheritanceTest {\n+    private final boolean DEBUG = false;\n+\n+    @Test\n+    void test() throws ReflectiveOperationException {\n+        try {\n+            \/\/ We create a new instance of the child class.\n+            \/\/ This should see that the class hierarchy is illegal and throw an exception.\n+            Class<?> clazz = Class.forName(\"Child\");\n+            Object instance = clazz.getDeclaredConstructor().newInstance();\n+            if (DEBUG) System.out.println(instance);\n+        } catch (IncompatibleClassChangeError weWantThis) {\n+            \/\/ The error that we are looking for.\n+            return;\n+        }\n+        \/\/ A lack of exception will fail this test.\n+        throw new IllegalStateException(\"expected IncompatibleClassChangeError to be thrown\");\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classloading\/ValueClassInheritanceTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}