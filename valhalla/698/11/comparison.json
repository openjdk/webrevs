{"files":[{"patch":"@@ -203,4 +203,3 @@\n-    private static final int ANNOTATION = 0x00002000;\n-    private static final int ENUM       = 0x00004000;\n-    private static final int SYNTHETIC  = 0x00001000;\n-    private static final int VALUE_CLASS     = 0x00000040;\n+    private static final int ANNOTATION= 0x00002000;\n+    private static final int ENUM      = 0x00004000;\n+    private static final int SYNTHETIC = 0x00001000;\n@@ -515,2 +514,2 @@\n-                                    ClassLoader loader,\n-                                    Class<?> caller)\n+                                            ClassLoader loader,\n+                                            Class<?> caller)\n@@ -633,0 +632,11 @@\n+    \/**\n+     * Returns {@code true} if this class is an identity class.\n+     *\n+     * @return {@code true} if this class is an identity class;\n+     * otherwise {@code false}\n+     * @since Valhalla\n+     *\/\n+    public boolean isIdentity() {\n+        return (this.getModifiers() & Modifier.IDENTITY) != 0;\n+    }\n+\n@@ -641,1 +651,1 @@\n-        return (this.getModifiers() & VALUE_CLASS) != 0;\n+        return (this.getModifiers() & Modifier.VALUE) != 0;\n@@ -1445,0 +1455,2 @@\n+     * The modifiers also include the Java Virtual Machine's constants for\n+     * {@code identity class} and {@code value class}.\n@@ -1474,15 +1486,0 @@\n-    \/**\n-     * Gets the signers of this class.\n-     *\n-     * @return  the signers of this class, or null if there are no signers.  In\n-     *          particular, this method returns null if this {@code Class} object represents\n-     *          a primitive type or void.\n-     * @since   1.1\n-     *\/\n-    public native Object[] getSigners();\n-\n-    \/**\n-     * Set the signers of this class.\n-     *\/\n-    native void setSigners(Object[] signers);\n-\n@@ -1492,0 +1489,13 @@\n+     *\n+     * <p> If the underlying class is an array class, then its\n+     * {@code PUBLIC}, {@code PRIVATE} and {@code PROTECTED}\n+     * access flags are the same as those of its component type.  If this\n+     * {@code Class} object represents a primitive type or void, the\n+     * {@code PUBLIC} access flag is present, and the\n+     * {@code PROTECTED} and {@code PRIVATE} access flags are always\n+     * absent. If this {@code Class} object represents an array class, a\n+     * primitive type or void, then the {@code FINAL} access flag is always\n+     * present and the interface access flag is always\n+     * absent. The values of its other access flags are not determined\n+     * by this specification.\n+     *\n@@ -1504,1 +1514,2 @@\n-                                            (isMemberClass() || isLocalClass() || isAnonymousClass()) ?\n+                                            (isMemberClass() || isLocalClass() ||\n+                                             isAnonymousClass() || isArray()) ?\n@@ -1509,0 +1520,17 @@\n+    \/**\n+     * Gets the signers of this class.\n+     *\n+     * @return  the signers of this class, or null if there are no signers.  In\n+     *          particular, this method returns null if this {@code Class} object represents\n+     *          a primitive type or void.\n+     * @since   1.1\n+     *\/\n+    public native Object[] getSigners();\n+\n+\n+    \/**\n+     * Set the signers of this class.\n+     *\/\n+    native void setSigners(Object[] signers);\n+\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":51,"deletions":23,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-            STATIC(AccessFlag.STATIC.mask()),\n+            STATIC(AccessFlag.STATIC_PHASE.mask()),\n@@ -1584,1 +1584,1 @@\n-         * {@link #build buid} method will add \"{@code requires java.base}\" if\n+         * {@link #build build} method will add \"{@code requires java.base}\" if\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n- * <p>The access flag constants are ordered by non-decreasing mask\n+ * @implSpec\n+ * The access flag constants are ordered by non-decreasing mask\n@@ -71,0 +72,12 @@\n+ * @apiNote\n+ * The JVM class file format has a new version defined for each new\n+ * {@linkplain Runtime.Version#feature() feature release}. A new class\n+ * file version may define new access flags or retire old ones. {@code\n+ * AccessFlag} is intended to model the set of access flags across\n+ * class file format versions. The range of versions an access flag is\n+ * recognized is not explicitly indicated in this API. See the current\n+ * <cite>The Java Virtual Machine Specification<\/cite> for\n+ * details. Unless otherwise indicated, access flags can be assumed to\n+ * be recognized in the {@linkplain Runtime#version() current\n+ * version}.\n+ *\n@@ -84,1 +97,1 @@\n-     * {@code 0x0001}.\n+     * <code>{@value Modifier#PUBLIC}<\/code>.\n@@ -93,1 +106,1 @@\n-     * value of {@code 0x0002}.\n+     * value of <code>{@value Modifier#PRIVATE}<\/code>.\n@@ -95,2 +108,1 @@\n-    PRIVATE(Modifier.PRIVATE, true,\n-            Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n@@ -101,1 +113,1 @@\n-     * value of {@code 0x0004}.\n+     * value of <code>{@value Modifier#PROTECTED}<\/code>.\n@@ -103,2 +115,1 @@\n-    PROTECTED(Modifier.PROTECTED, true,\n-              Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n@@ -109,1 +120,1 @@\n-     * {@code 0x0008}.\n+     * <code>{@value Modifier#STATIC}<\/code>.\n@@ -111,2 +122,1 @@\n-    STATIC(Modifier.STATIC, true,\n-           Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n@@ -117,1 +127,1 @@\n-     * value of {@code 0x0010}.\n+     * value of <code>{@value Modifier#FINAL}<\/code>.\n@@ -126,0 +136,10 @@\n+     *\n+     * @apiNote\n+     * In Java SE 8 and above, the JVM treats the {@code ACC_SUPER}\n+     * flag as set in every class file (JVMS {@jvms 4.1}).\n+     * NOTE: The Valhalla draft JVMS spec does not define a value for ACC_SUPER.\n+     * Historically, the value 0x0020 was used to indicate ACC_SUPER, which affected the\n+     * semantics of any invokespecial instructions (6.5.invokespecial) appearing in the class.\n+     * In Java SE 8, the ACC_SUPER semantics became mandatory, regardless of the setting of\n+     * ACC_SUPER or the class file version number, and the flag no longer had any effect.\n+     * Now the flag has been repurposed as ACC_IDENTITY.\n@@ -127,1 +147,1 @@\n-    SUPER(0x0000_0020, false, Set.of(Location.CLASS)),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS),\n@@ -130,2 +150,2 @@\n-     * The access flag {@code ACC_IDENTITY} with a mask value of {@code\n-     * 0x0020}.\n+     * The access flag {@code ACC_IDENTITY} with a mask value of {@code {@value Modifier#IDENTITY}}.\n+     * @jls 4.1-B. Class access and property modifiers\n@@ -133,1 +153,1 @@\n-\/\/    IDENTITY(0x0000_0020, false, Set.of(Location.CLASS)),\n+    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_INNER_CLASS),\n@@ -147,1 +167,1 @@\n-    TRANSITIVE(0x0000_0020, false, Set.of(Location.MODULE_REQUIRES)),\n+    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),\n@@ -152,1 +172,1 @@\n-     * a mask value of {@code 0x0020}.\n+     * a mask value of <code>{@value Modifier#SYNCHRONIZED}<\/code>.\n@@ -154,1 +174,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Set.of(Location.METHOD)),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD),\n@@ -161,1 +181,1 @@\n-    STATIC_PHASE(0x0000_0040, false, Set.of(Location.MODULE_REQUIRES)),\n+    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),\n@@ -163,1 +183,7 @@\n-     \/**\n+    \/**\n+     * The access flag {@code ACC_VALUE} with a mask value of {@code {@value Modifier#VALUE}}.\n+     * @jls 4.1-B. Class access and property modifiers\n+     *\/\n+    VALUE(Modifier.VALUE, true, Set.of(Location.CLASS, Location.INNER_CLASS)),\n+\n+    \/**\n@@ -166,1 +192,1 @@\n-      * value of {@code 0x0040}.\n+      * value of <code>{@value Modifier#VOLATILE}<\/code>.\n@@ -168,1 +194,1 @@\n-    VOLATILE(Modifier.VOLATILE, true, Set.of(Location.FIELD)),\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD),\n@@ -171,2 +197,2 @@\n-     * The access flag {@code ACC_BRIDGE} with a mask value of {@code\n-     * 0x0040}.\n+     * The access flag {@code ACC_BRIDGE} with a mask value of\n+     * <code>{@value Modifier#BRIDGE}<\/code>\n@@ -175,1 +201,1 @@\n-    BRIDGE(0x0000_0040, false, Set.of(Location.METHOD)),\n+    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),\n@@ -180,1 +206,1 @@\n-     * mask value of {@code 0x0080}.\n+     * mask value of <code>{@value Modifier#TRANSIENT}<\/code>.\n@@ -182,1 +208,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Set.of(Location.FIELD)),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD),\n@@ -185,2 +211,2 @@\n-     * The access flag {@code ACC_VARARGS} with a mask value of {@code\n-     * 0x0080}.\n+     * The access flag {@code ACC_VARARGS} with a mask value of\n+     * <code>{@value Modifier#VARARGS}<\/code>.\n@@ -189,1 +215,1 @@\n-    VARARGS(0x0000_0080, false, Set.of(Location.METHOD)),\n+    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),\n@@ -193,2 +219,2 @@\n-     * modifier {@link Modifier#NATIVE native} with a mask value of {@code\n-     * 0x0100}.\n+     * modifier {@link Modifier#NATIVE native} with a mask value of\n+     * <code>{@value Modifier#NATIVE}<\/code>.\n@@ -196,1 +222,1 @@\n-    NATIVE(Modifier.NATIVE, true, Set.of(Location.METHOD)),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD),\n@@ -203,2 +229,1 @@\n-    INTERFACE(Modifier.INTERFACE, false,\n-              Set.of(Location.CLASS, Location.INNER_CLASS)),\n+    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),\n@@ -209,1 +234,1 @@\n-     * value of {@code 0x0400}.\n+     * value of <code>{@value Modifier#ABSTRACT}<\/code>.\n@@ -217,1 +242,6 @@\n-     * {@code 0x0800}.\n+     * <code>{@value Modifier#STRICT}<\/code>.\n+     *\n+     * @apiNote\n+     * The {@code ACC_STRICT} access flag is defined for class file\n+     * major versions 46 through 60, inclusive (JVMS {@jvms 4.6}),\n+     * corresponding to Java SE 1.2 through 16.\n@@ -219,1 +249,1 @@\n-    STRICT(Modifier.STRICT, true, Set.of(Location.METHOD)),\n+    STRICT(Modifier.STRICT, true, Location.SET_METHOD),\n@@ -223,1 +253,1 @@\n-     * {@code 0x1000}.\n+     * <code>{@value Modifier#SYNTHETIC}<\/code>.\n@@ -228,1 +258,1 @@\n-    SYNTHETIC(0x0000_1000, false,\n+    SYNTHETIC(Modifier.SYNTHETIC, false,\n@@ -236,1 +266,1 @@\n-     * {@code 0x2000}.\n+     * <code>{@value Modifier#ANNOTATION}<\/code>.\n@@ -239,2 +269,1 @@\n-    ANNOTATION(0x0000_2000, false,\n-               Set.of(Location.CLASS, Location.INNER_CLASS)),\n+    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),\n@@ -243,2 +272,2 @@\n-     * The access flag {@code ACC_ENUM} with a mask value of {@code\n-     * 0x4000}.\n+     * The access flag {@code ACC_ENUM} with a mask value of\n+     * <code>{@value Modifier#ENUM}<\/code>.\n@@ -247,1 +276,1 @@\n-    ENUM(0x0000_4000, false,\n+    ENUM(Modifier.ENUM, false,\n@@ -252,1 +281,1 @@\n-     * {@code 0x8000}.\n+     * <code>{@value Modifier#MANDATED}<\/code>.\n@@ -254,1 +283,1 @@\n-    MANDATED(0x0000_8000, false,\n+    MANDATED(Modifier.MANDATED, false,\n@@ -263,1 +292,1 @@\n-    MODULE(0x0000_8000, false, Set.of(Location.CLASS))\n+    MODULE(0x0000_8000, false, Location.SET_CLASS)\n@@ -269,2 +298,2 @@\n-    private int mask;\n-    private boolean sourceModifier;\n+    private final int mask;\n+    private final boolean sourceModifier;\n@@ -274,1 +303,1 @@\n-    private Set<Location> locations;\n+    private final Set<Location> locations;\n@@ -305,1 +334,1 @@\n-     * {@return a set of access flags for the given mask value\n+     * {@return an unmodifiable set of access flags for the given mask value\n@@ -315,0 +344,1 @@\n+        int unmatchedFlags = mask;\n@@ -319,1 +349,1 @@\n-                mask = mask & ~accessMask;\n+                unmatchedFlags = unmatchedFlags & ~accessMask;\n@@ -322,1 +352,1 @@\n-        if (mask != 0) {\n+        if (unmatchedFlags != 0) {\n@@ -324,1 +354,1 @@\n-                                               Integer.toHexString(mask) +\n+                                               Integer.toHexString(unmatchedFlags) +\n@@ -393,0 +423,10 @@\n+        \/\/ Repeated sets of locations used by AccessFlag constants\n+        private static final Set<Location> SET_FIELD_METHOD_INNER_CLASS =\n+            Set.of(FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_METHOD = Set.of(METHOD);\n+        private static final Set<Location> SET_FIELD = Set.of(FIELD);\n+        private static final Set<Location> SET_CLASS = Set.of(CLASS);\n+        private static final Set<Location> SET_CLASS_INNER_CLASS =\n+            Set.of(CLASS, INNER_CLASS);\n+        private static final Set<Location> SET_MODULE_REQUIRES =\n+            Set.of(MODULE_REQUIRES);\n@@ -398,1 +438,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER,\n+                                Set.of(PUBLIC, FINAL, SUPER, IDENTITY, VALUE,\n@@ -412,1 +452,1 @@\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED, IDENTITY, VALUE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":99,"deletions":59,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,5 +217,0 @@\n-     * @implSpec\n-     * Map this executable's {@linkplain #getModifiers() modifiers} to\n-     * access flags using {@link AccessFlag#maskToAccessFlags} for a\n-     * {@linkplain AccessFlag.Location#METHOD method location}\n-     *\n@@ -228,1 +223,2 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.METHOD);\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                                            AccessFlag.Location.METHOD);\n@@ -277,3 +273,1 @@\n-    public int getParameterCount() {\n-        throw new AbstractMethodError();\n-    }\n+    public abstract int getParameterCount();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-     * The default implementation returns an empty set.\n+     * The default implementation throws {@link\n+     * UnsupportedOperationException}.\n@@ -96,1 +97,1 @@\n-        return Set.of();\n+        throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Member.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * constants to decode class and member access modifiers.  The sets of\n- * modifiers are represented as integers with distinct bit positions\n+ * constants to decode class and member access modifiers.\n+ * The {@link AccessFlag} class should be used instead of this class.\n+ * The sets of modifiers are represented as integers with non-distinct bit positions\n@@ -39,0 +40,2 @@\n+ * @see Class#accessFlags()\n+ * @see Member#accessFlags()\n@@ -117,0 +120,3 @@\n+     * @apiNote {@code isSynchronized} should only be called with the modifiers\n+     * of a {@linkplain Method#getModifiers() method}.\n+     *\n@@ -129,0 +135,3 @@\n+     * @apiNote {@code isIdentity} should only be called with the modifiers\n+     * of a {@linkplain Class#getModifiers() class}.\n+     *\n@@ -149,0 +158,15 @@\n+    \/**\n+     * Return {@code true} if the integer argument includes the\n+     * {@code value} modifier, {@code false} otherwise.\n+     *\n+     * @apiNote {@code isValue} should only be called with the modifiers\n+     * of a {@linkplain Class#getModifiers() class}.\n+     *\n+     * @param   mod a set of modifiers\n+     * @return {@code true} if {@code mod} includes the\n+     * {@code value} modifier; {@code false} otherwise.\n+     *\/\n+    public static boolean isValue(int mod) {\n+        return (mod & VALUE) != 0;\n+    }\n+\n@@ -312,1 +336,8 @@\n-    public static final int IDENTITY            = 0x00000020;\n+    public static final int IDENTITY         = 0x00000020;\n+\n+    \/**\n+     * The {@code int} value representing the {@code value}\n+     * modifier.\n+     * @see AccessFlag#VALUE\n+     *\/\n+    public static final int VALUE            = 0x00000040;\n@@ -352,0 +383,1 @@\n+     * @see AccessFlag#STRICT\n@@ -359,3 +391,3 @@\n-    static final int BRIDGE      = 0x00000040;\n-    static final int VARARGS     = 0x00000080;\n-    static final int SYNTHETIC   = 0x00001000;\n+    static final int BRIDGE    = 0x00000040;\n+    static final int VARARGS   = 0x00000080;\n+    static final int SYNTHETIC = 0x00001000;\n@@ -363,2 +395,2 @@\n-    static final int ENUM        = 0x00004000;\n-    static final int MANDATED    = 0x00008000;\n+    static final int ENUM      = 0x00004000;\n+    static final int MANDATED  = 0x00008000;\n@@ -390,1 +422,2 @@\n-        Modifier.STRICT         | Modifier.IDENTITY;\n+        Modifier.IDENTITY       | Modifier.VALUE        |\n+        Modifier.STRICT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -511,1 +511,1 @@\n-                    accessFlags = Modifier.FINAL | Modifier.IDENTITY;  \/\/ non-public, final\n+                    accessFlags = Modifier.FINAL | Modifier.IDENTITY;  \/\/ non-public, final, identity\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import java.lang.reflect.Modifier;\n@@ -685,2 +686,1 @@\n-        int mods = clazz.getModifiers();\n-        return (mods & 0x00000100) != 0;\n+        return (clazz.getModifiers() & Opcodes.ACC_PRIMITIVE) != 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,3 @@\n-                                     AnotherEnum.class)) {\n+                                     AnotherEnum.class,\n+                                     AValueClass.class,\n+                                     APrimitiveClass.class)) {\n@@ -114,0 +116,6 @@\n+\n+@ExpectedGenericString(\"final value class AValueClass<E>\")\n+value class AValueClass<E> {}\n+\n+@ExpectedGenericString(\"final primitive class APrimitiveClass<E>\")\n+primitive class APrimitiveClass<E> {}\n","filename":"test\/jdk\/java\/lang\/Class\/GenericStringTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266670\n+ * @bug 8266670 8281463\n@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -47,0 +48,4 @@\n+    \/*\n+     * Verify sourceModifier() == true access flags have a\n+     * corresponding constant in java.lang.reflect.Modifier.\n+     *\/\n@@ -97,1 +102,1 @@\n-        \/\/ Then test for disjointness\n+        \/\/ ...then test for disjointness\n@@ -110,0 +115,2 @@\n+                if (accessFlag.equals(AccessFlag.SUPER))\n+                    continue;       \/\/ SUPER is defined to overlap with IDENTITY\n@@ -139,1 +146,3 @@\n-                if (!expectedSet.equals(computedSet)) {\n+                if (!computedSet.containsAll(expectedSet)) {\n+                    System.out.println(\"expected: \" + expectedSet);\n+                    System.out.println(\"computed: \" + computedSet);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on classes.\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+\/*\n+ * Class access flags that can directly or indirectly declared in\n+ * source include:\n+ * public, private, protected, static, final, interface, abstract,\n+ * annotation, enum.\n+ *\n+ * Additionally, the access flags super and synthetic cannot be\n+ * explicitly applied.\n+ *\n+ * This test is written on top of the facilities of core reflection.\n+ *\n+ * Note that core reflection does not offer a supported mechanism to\n+ * return the Class object created from a module-info.class\n+ * file. Therefore, this test does not attempt to probe the setting of\n+ * that access flag.\n+ *\n+ * For a class, the VM must treat the class as if the ACC_SUPER bit\n+ * were set, but that bit is cleared by HotSpot when it is passed out\n+ * to the core reflection libraries. Therefore, this test does not\n+ * attempt to check whether or not AccessFlag.SUPER is set.\n+ *\/\n+@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER, IDENTITY]\")\n+public final class ClassAccessFlagTest {\n+    public static void main(String... args) {\n+        \/\/ Top-level and axuillary classes; i.e. non-inner classes\n+        Class<?>[] testClasses = {\n+            ClassAccessFlagTest.class,\n+            TestInterface.class,\n+            ExpectedClassFlags.class,\n+            TestOuterEnum.class\n+        };\n+        checkClasses(testClasses);\n+\n+        \/\/ Nested classes of ClassAccessFlagTest\n+        checkClasses(ClassAccessFlagTest.class.getDeclaredClasses());\n+\n+        checkPrimitives();\n+        checkArrays();\n+    }\n+\n+    private static void checkClasses(Class<?>[] classes) {\n+        for (var clazz : classes) {\n+            checkClass(clazz);\n+        }\n+    }\n+\n+    private static void checkClass(Class<?> clazz) {\n+        ExpectedClassFlags expected =\n+            clazz.getAnnotation(ExpectedClassFlags.class);\n+        if (expected != null) {\n+            String actual = clazz.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + clazz +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    private static void checkPrimitives() {\n+        final Class<?>[] primitives = {\n+            byte.class,\n+            int.class,\n+            long.class,\n+            short.class,\n+            char.class,\n+            float.class,\n+            double.class,\n+            boolean.class,\n+            void.class \/\/ same access flag rules\n+        };\n+\n+        var mustBePresent = Set.of(AccessFlag.PUBLIC, AccessFlag.FINAL);\n+        var mustBeAbsent = Set.of(AccessFlag.PRIVATE,\n+                                  AccessFlag.PROTECTED,\n+                                  AccessFlag.INTERFACE);\n+\n+        for(var primClass : primitives) {\n+            \/\/ PUBLIC must be present, PROTECTED and PRIVATE must be\n+            \/\/ absent.\n+            \/\/ FINAL must be present, INTERFACE must be absent.\n+            var accessFlags = primClass.accessFlags();\n+            if (!accessFlags.containsAll(mustBePresent)) {\n+                throw new RuntimeException(\"Missing mandatory flags on \" +\n+                                           primClass);\n+            }\n+\n+            if (containsAny(accessFlags, mustBeAbsent)) {\n+                throw new RuntimeException(\"Unexpected flags present on \" +\n+                                           primClass);\n+            }\n+        }\n+    }\n+\n+    private static boolean containsAny(Set<AccessFlag> input,\n+                                       Set<AccessFlag> test) {\n+        var copy = new HashSet<>(input);\n+        return copy.removeAll(test);\n+    }\n+\n+    private static void checkArrays() {\n+        Class<?>[] accessClasses = {\n+            PublicInterface.class,\n+            ProtectedInterface.class,\n+            PrivateInterface.class,\n+        };\n+\n+        for (var accessClass : accessClasses) {\n+            AccessFlag accessLevel;\n+            var flags = accessClass.accessFlags();\n+            if (flags.contains(AccessFlag.PUBLIC))\n+                accessLevel = AccessFlag.PUBLIC;\n+            else if (flags.contains(AccessFlag.PROTECTED))\n+                accessLevel = AccessFlag.PROTECTED;\n+            else if (flags.contains(AccessFlag.PRIVATE))\n+                accessLevel = AccessFlag.PRIVATE;\n+            else\n+                accessLevel = null;\n+\n+            var arrayClass = accessClass.arrayType();\n+            \/\/ Access modifier must match on the array type\n+            if (accessLevel != null) {\n+                if (!arrayClass.accessFlags().contains(accessLevel)) {\n+                    throw new RuntimeException(\"Mismatched access flags on \" +\n+                                               arrayClass);\n+                }\n+            } else {\n+                if (containsAny(arrayClass.accessFlags(),\n+                                Set.of(AccessFlag.PUBLIC,\n+                                       AccessFlag.PROTECTED,\n+                                       AccessFlag.PRIVATE))) {\n+                    throw new RuntimeException(\"Unexpected access flags on \" +\n+                                               arrayClass);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ inner classes and interfaces; possible flags on INNER_CLASS\n+    \/\/ locations:\n+    \/\/ PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, INTERFACE, ABSTRACT,\n+    \/\/ SYNTHETIC, ANNOTATION, ENUM.\n+\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, INTERFACE, ABSTRACT]\")\n+    public      interface PublicInterface {}\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, INTERFACE, ABSTRACT]\")\n+    protected   interface ProtectedInterface {}\n+    @ExpectedClassFlags(\"[PRIVATE, STATIC, INTERFACE, ABSTRACT]\")\n+    private     interface PrivateInterface {}\n+    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    \/*package*\/ interface PackageInterface {}\n+\n+    @ExpectedClassFlags(\"[FINAL, IDENTITY]\")\n+    \/*package*\/ final class TestFinalClass {}\n+\n+    @ExpectedClassFlags(\"[IDENTITY, ABSTRACT]\")\n+    \/*package*\/ abstract class TestAbstractClass {}\n+\n+    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT, ANNOTATION]\")\n+    \/*package*\/ @interface TestMarkerAnnotation {}\n+\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, IDENTITY, ENUM]\")\n+    public enum MetaSynVar {\n+        QUUX;\n+    }\n+\n+    \/\/ Is there is at least one special enum constant, the enum class\n+    \/\/ itself is implicitly abstract rather than final.\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, IDENTITY, ABSTRACT, ENUM]\")\n+    protected enum MetaSynVar2 {\n+        WOMBAT{\n+            @Override\n+            public int foo() {return 42;}\n+        };\n+        public abstract int foo();\n+    }\n+\n+    @ExpectedClassFlags(\"[PRIVATE, IDENTITY, ABSTRACT]\")\n+    private abstract class Foo {}\n+\n+    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    interface StaticTestInterface {}\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@interface ExpectedClassFlags {\n+    String value();\n+}\n+\n+@ExpectedClassFlags(\"[INTERFACE, ABSTRACT]\")\n+interface TestInterface {}\n+\n+\n+@ExpectedClassFlags(\"[FINAL, SUPER, IDENTITY, ENUM]\")\n+enum TestOuterEnum {\n+    INSTANCE;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on fields.\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Field modifiers include:\n+ * public, private, protected, static, final, volatile, transient,\n+ *\n+ * Additionall, the access flags enum and synthetic cannot be\n+ * explicitly applied.\n+ *\/\n+public class FieldAccessFlagTest {\n+    public static void main(String... args) {\n+        for (var field :\n+                 FieldAccessFlagTest.class.getDeclaredFields()) {\n+            checkField(field);\n+        }\n+\n+        for (var field :\n+                 MetaSynVar.class.getDeclaredFields()) {\n+            checkField(field);\n+        }\n+    }\n+\n+    private static void checkField(Field field) {\n+        ExpectedFieldFlags expected =\n+            field.getAnnotation(ExpectedFieldFlags.class);\n+        if (expected != null) {\n+            String actual = field.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + field +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    \/\/ Fields\n+    @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL]\")\n+    public static final String f1 = \"foo\";\n+\n+    @ExpectedFieldFlags(\"[PRIVATE, VOLATILE, TRANSIENT]\")\n+    private volatile transient String secret = \"xxyzzy\";\n+\n+    @ExpectedFieldFlags(\"[PROTECTED]\")\n+    protected String meadow = \"\";\n+\n+    \/\/ Enum constant should have the enum access flag set\n+    static enum MetaSynVar {\n+        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        FOO,\n+\n+        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        BAR;\n+\n+        @ExpectedFieldFlags(\"[PRIVATE]\") \/\/ no \"ENUM\"\n+        private int field = 0;\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedFieldFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on methods and parameters\n+ * @compile -parameters MethodAccessFlagTest.java\n+ * @run main MethodAccessFlagTest\n+ *\/\n+\n+\/\/ Use -parameters flag to javac to have access flag information about\n+\/\/ parameters preserved in the resulting class file.\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Method modifiers include:\n+ * public, private, protected, static, final, synchronized,\n+ * bridge, varargs, native, abstract, strictfp, synthetic,\n+ *\n+ * At a source level, constructors can have modifiers public,\n+ * protected, or private.\n+ *\n+ * The modifiers bridge and synthetic cannot be applied directly and\n+ * strictfp can only be applied in older source versions.\n+ *\n+ * Method parameters can be final, synthetic, and mandated.\n+ *\/\n+public abstract class MethodAccessFlagTest {\n+    @ExpectedMethodFlags(\"[PUBLIC, STATIC, VARARGS]\")\n+    public static void main(String... args) {\n+        for (var ctor :\n+                 MethodAccessFlagTest.class.getDeclaredConstructors()) {\n+            checkExecutable(ctor);\n+        }\n+\n+        for (var method :\n+                 MethodAccessFlagTest.class.getDeclaredMethods()) {\n+            checkExecutable(method);\n+        }\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : NestedClass.class.getConstructors()) {\n+            for (var parameter : ctor.getParameters()) {\n+                String expected = null;\n+                if (parameter.getType() == int.class) {\n+                    \/\/ The explicit int parameter is expected to have\n+                    \/\/ the final flag\n+                    expected = \"[FINAL]\";\n+                } else {\n+                    \/\/ The implicit this$0 parameter is expected to have the\n+                    \/\/ final and mandated flags\n+                    expected = \"[FINAL, MANDATED]\";\n+                }\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            expected);\n+            }\n+        }\n+\n+        for (var method : BridgeExample.class.getDeclaredMethods()) {\n+            \/\/ Find the two \"clone\" methods, one implicit and one\n+            \/\/ explicit\n+            if (!method.getName().equals(\"clone\")) {\n+                throw new RuntimeException(\"Unexpected name for \" + method);\n+            }\n+            String expected = null;\n+            if (method.getReturnType() == Object.class) {\n+                expected = \"[PUBLIC, BRIDGE, SYNTHETIC]\";\n+            } else {\n+                expected = \"[PUBLIC]\";\n+            }\n+            checkString(method.toString(),\n+                        method.accessFlags().toString(),\n+                        expected);\n+        }\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : TestEnum.class.getDeclaredConstructors()) {\n+            \/\/ Each of the two parameters used in javac's enum\n+            \/\/ constructor implementation is synthetic. This may need\n+            \/\/ to be updated if javac's enum constructor generation\n+            \/\/ idiom changes.\n+            for (var parameter : ctor.getParameters()) {\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            \"[SYNTHETIC]\");\n+            }\n+        }\n+\n+    }\n+\n+    class NestedClass {\n+        private int i;\n+        \/\/ Implicit leading parameter\n+        public NestedClass(final int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    class BridgeExample implements Cloneable {\n+        public BridgeExample(){}\n+        \/\/ Triggers generation of a bridge method.\n+        public BridgeExample clone() {\n+            return new BridgeExample();\n+        }\n+    }\n+\n+    \/\/ Use as a host for a constructor with synthetic parameters\n+    enum TestEnum {\n+        INSTANCE;\n+    }\n+\n+    private static void checkExecutable(Executable method) {\n+        ExpectedMethodFlags emf =\n+            method.getAnnotation(ExpectedMethodFlags.class);\n+        if (emf != null) {\n+            String actual = method.accessFlags().toString();\n+            checkString(method.toString(), emf.value(), actual);\n+        }\n+    }\n+\n+    private static void checkString(String declaration,\n+                               String expected,\n+                               String actual) {\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"On \" + declaration +\n+                                       \" expected \" + expected +\n+                                       \" got \" + actual);\n+        }\n+    }\n+\n+    \/\/ Constructors\n+    @ExpectedMethodFlags(\"[PUBLIC]\")\n+    public MethodAccessFlagTest() {}\n+\n+    @ExpectedMethodFlags(\"[PROTECTED]\")\n+    protected MethodAccessFlagTest(int i) {super();}\n+\n+    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    private MethodAccessFlagTest(String s) {super();}\n+\n+    \/\/ Methods\n+    @ExpectedMethodFlags(\"[PROTECTED, SYNCHRONIZED]\")\n+    protected synchronized void m0() {}\n+\n+    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    private void m1() {}\n+\n+    @ExpectedMethodFlags(\"[ABSTRACT]\")\n+    abstract void m2();\n+\n+    @ExpectedMethodFlags(\"[PUBLIC, FINAL]\")\n+    public final void m3() {}\n+\n+    @ExpectedMethodFlags(\"[NATIVE]\")\n+    native void m4();\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedMethodFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/MethodAccessFlagTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on module-related structures.\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import java.lang.module.*;\n+import java.util.Set;\n+\n+public class ModuleDescriptorAccessFlagTest {\n+    public static void main(String... args) {\n+        \/\/ Test ModuleDescriptor.Modifier\n+        var openMod = ModuleDescriptor.newModule(\"foo\",\n+                                                 Set.of(ModuleDescriptor.Modifier.OPEN,\n+                                                        ModuleDescriptor.Modifier.SYNTHETIC,\n+                                                        ModuleDescriptor.Modifier.MANDATED)).build();\n+        checkAccessFlags(openMod, openMod.accessFlags(), \"[OPEN, SYNTHETIC, MANDATED]\");\n+        \/\/ AUTOMATIC does not have a corresponding access flag so is\n+        \/\/ *not* tested here.\n+\n+        \/\/ Test ModuleDescriptor.Requires.Modifier\n+        var requireMod = ModuleDescriptor.newModule(\"bar\")\n+            .requires(Set.of(ModuleDescriptor.Requires.Modifier.STATIC,\n+                             ModuleDescriptor.Requires.Modifier.SYNTHETIC,\n+                             ModuleDescriptor.Requires.Modifier.TRANSITIVE), \"baz\")\n+            .build();\n+\n+        for (ModuleDescriptor.Requires requires : requireMod.requires()) {\n+            if (\"java.base\".equals(requires.name())) {\n+                checkAccessFlags(requires, requires.accessFlags(), \"[MANDATED]\");\n+            } else {\n+                \/\/ Note \"STATIC_PHASE\" rather than \"STATIC\"\n+                checkAccessFlags(requires, requires.accessFlags(), \"[TRANSITIVE, STATIC_PHASE, SYNTHETIC]\");\n+            }\n+        }\n+\n+        \/\/ Test ModuleDescriptor.Exports.Modifier\n+        var exportMod = ModuleDescriptor.newModule(\"baz\")\n+            .exports(Set.of(ModuleDescriptor.Exports.Modifier.MANDATED,\n+                            ModuleDescriptor.Exports.Modifier.SYNTHETIC), \"quux\")\n+            .build();\n+        for (ModuleDescriptor.Exports exports : exportMod.exports()) {\n+            checkAccessFlags(exports, exports.accessFlags(), \"[SYNTHETIC, MANDATED]\");\n+        }\n+\n+        \/\/ Test ModuleDescriptor.Opens.Modifier\n+        var opensMod = ModuleDescriptor.newModule(\"quux\")\n+            .exports(Set.of(ModuleDescriptor.Exports.Modifier.MANDATED,\n+                            ModuleDescriptor.Exports.Modifier.SYNTHETIC), \"xxyzzy\")\n+            .build();\n+        for (ModuleDescriptor.Opens opens : exportMod.opens()) {\n+            checkAccessFlags(opens, opens.accessFlags(), \"[SYNTHETIC, MANDATED]\");\n+        }\n+    }\n+\n+    private static void checkAccessFlags(Object o, Set<AccessFlag> accessFlags, String expected) {\n+        String actual = accessFlags.toString();\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"On \" + o.toString() +\n+                                       \" expected \" + expected +\n+                                       \" got \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ModuleDescriptorAccessFlagTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected value of STRICT AccessFlag\n+ * @compile -source 16 -target 16 StrictAccessFlagTest.java\n+ * @run main StrictAccessFlagTest\n+ *\/\n+\n+\/\/ Note: cannot use --release 16 because the accessFlags() method is\n+\/\/ not found in release 16; therefore -source and -target are used\n+\/\/ instead.\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Test expected value of ACC_STRICT access flag.\n+ *\/\n+\/\/ Declaring the class strictfp implicitly sets ACC_STRICT on all its\n+\/\/ methods and constructors.\n+public strictfp class StrictAccessFlagTest {\n+    @ExpectedFlags(\"[PUBLIC, STATIC, VARARGS, STRICT]\")\n+    public static void main(String... args) {\n+        for (var ctor :\n+                 StrictAccessFlagTest.class.getDeclaredConstructors()) {\n+            checkExecutable(ctor);\n+        }\n+\n+        for (var method :\n+                 StrictAccessFlagTest.class.getDeclaredMethods()) {\n+            checkExecutable(method);\n+        }\n+    }\n+\n+    private static void checkExecutable(Executable method) {\n+        ExpectedFlags expected =\n+            method.getAnnotation(ExpectedFlags.class);\n+        if (expected != null) {\n+            String actual = method.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + method +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    \/\/ Constructor\n+    @ExpectedFlags(\"[PUBLIC, STRICT]\")\n+    public StrictAccessFlagTest() {}\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/StrictAccessFlagTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-public class StaticFactoryTest {\n+public final identity class StaticFactoryTest {\n@@ -46,0 +46,13 @@\n+\n+    static identity class SimpleIdentity {\n+        public final int x;\n+\n+        SimpleIdentity() {\n+            x = -1;\n+        }\n+\n+        public SimpleIdentity(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n@@ -73,2 +86,6 @@\n-                new Object[] { SimplePrimitive.class, true },\n-                new Object[] { SimpleValue.class, false },\n+                new Object[] { SimpleIdentity.class, true, false, false },\n+                new Object[] { SimplePrimitive.class, false, true, true },\n+                new Object[] { SimpleValue.class, false, true, false },\n+                new Object[] { InterfaceWithNested.IdentityClass.class, true, false, false },\n+                new Object[] { InterfaceWithNested.ValueClass.class, false, true, false },\n+                new Object[] { InterfaceWithNested.PrimitiveClass.class, false, true, true },\n@@ -79,1 +96,2 @@\n-    public void testConstructor(Class<?> c, boolean isPrimitiveClass) throws ReflectiveOperationException {\n+    public void testConstructor(Class<?> c, boolean isIdentityClass,\n+                                boolean isValueClass, boolean isPrimitiveClass) throws ReflectiveOperationException {\n@@ -82,0 +100,1 @@\n+        System.out.printf(\"cn: %s, mod: 0x%04X%n\", cn, c.getModifiers());\n@@ -83,2 +102,3 @@\n-        assertTrue(clz.isValue());\n-        assertTrue(clz.isPrimitiveClass() == isPrimitiveClass);\n+        assertEquals(clz.isIdentity(), isIdentityClass, \"identity class: \" + clz);\n+        assertEquals(clz.isValue(), isValueClass, \"value class: \" + clz);\n+        assertEquals(clz.isPrimitiveClass(), isPrimitiveClass, \"primitive class: \" + clz);\n@@ -97,2 +117,2 @@\n-            if (Modifier.isStatic(m.getModifiers())) {\n-                assertFalse(m.getName().equals(\"<init>\"));\n+            if (Modifier.isStatic(m.getModifiers()) && \"<init>\".equals(m.getName())) {\n+                assertTrue(isIdentityClass, \"<init> method is not in an identity class\");\n@@ -103,0 +123,13 @@\n+\n+    interface SimpleInterface {}\n+\n+    identity interface SimpleIdentityInterface {} \/\/ Illegal class modifiers from VM\n+\n+    value interface SimpleValueInterface {}\n+\n+    interface InterfaceWithNested {\n+        identity class IdentityClass {}\n+        value class ValueClass {}\n+        primitive class PrimitiveClass {}\n+    }\n+\n@@ -104,0 +137,21 @@\n+    static Object[][] interfaces() {\n+        return new Object[][]{\n+                new Object[] { SimpleInterface.class, false, false, true },\n+                new Object[] { SimpleIdentityInterface.class, true, false, true },  \/\/ VM throws\n+                new Object[] { SimpleValueInterface.class, false, true, true },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"interfaces\")\n+    public void testInterfaces(Class<?> c, boolean isIdentityClass,\n+                                boolean isValueClass, boolean isAbstract) throws ReflectiveOperationException {\n+        String cn = c.getName();\n+        Class<?> clz = Class.forName(cn);\n+        System.out.printf(\"cn: %s, mod: 0x%04X%n\", cn, c.getModifiers());\n+\n+        assertEquals(clz.isIdentity(), isIdentityClass, \"identity class: \" + clz);\n+        assertEquals(clz.isValue(), isValueClass, \"value class: \" + clz);\n+        assertEquals(Modifier.isAbstract(clz.getModifiers()), isAbstract, \"abstract: \" + clz);\n+    }\n+\n+        @DataProvider\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryTest.java","additions":63,"deletions":9,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,2 @@\n+            throw new AssertionError(\"Primitive flag missing\");\n+        if ((Inner.class.getModifiers() & AccessFlags.ACC_VALUE) == 0)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InnerClassAttributeValuenessTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}