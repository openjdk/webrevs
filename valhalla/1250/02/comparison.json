{"files":[{"patch":"@@ -8,0 +8,1 @@\n+warning=issuestitle\n","filename":".jcheck\/conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -182,2 +182,3 @@\n-to\n-<code>jtreg:$(TOPDIR)\/test\/hotspot\/jtreg:tier1 jtreg:$(TOPDIR)\/test\/jdk:tier1 jtreg:$(TOPDIR)\/test\/langtools:tier1 jtreg:$(TOPDIR)\/test\/nashorn:tier1 jtreg:$(TOPDIR)\/test\/jaxp:tier1<\/code>.\n+to include all subcomponent test directories that define `tier1`,\n+for example:\n+<code>jtreg:$(TOPDIR)\/test\/hotspot\/jtreg:tier1 jtreg:$(TOPDIR)\/test\/jdk:tier1 jtreg:$(TOPDIR)\/test\/langtools:tier1 ...<\/code>.\n","filename":"doc\/testing.html","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -106,5 +106,5 @@\n-example, `:tier1` will expand to `jtreg:$(TOPDIR)\/test\/hotspot\/jtreg:tier1\n-jtreg:$(TOPDIR)\/test\/jdk:tier1 jtreg:$(TOPDIR)\/test\/langtools:tier1\n-jtreg:$(TOPDIR)\/test\/nashorn:tier1 jtreg:$(TOPDIR)\/test\/jaxp:tier1`. You can\n-always submit a list of fully qualified test descriptors in the `TEST` variable\n-if you want to shortcut the parser.\n+example, `:tier1` will expand to include all subcomponent test directories\n+that define `tier1`, for example: `jtreg:$(TOPDIR)\/test\/hotspot\/jtreg:tier1\n+jtreg:$(TOPDIR)\/test\/jdk:tier1 jtreg:$(TOPDIR)\/test\/langtools:tier1 ...`. You\n+can always submit a list of fully qualified test descriptors in the `TEST`\n+variable if you want to shortcut the parser.\n","filename":"doc\/testing.md","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    DISABLED_WARNINGS := rawtypes deprecation unchecked serial cast this-escape, \\\n+    DISABLED_WARNINGS := rawtypes deprecation unchecked serial cast this-escape dangling-doc-comments, \\\n","filename":"make\/CompileDemos.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -686,22 +686,19 @@\n-    $(eval MAN_$m := $(call FindModuleManDirs, $m)) \\\n-    $(foreach d, $(MAN_$m), \\\n-      $(foreach f, $(call ApplySpecFilter, $(filter %.md, $(call FindFiles, $d))), \\\n-        $(eval $m_$f_NAME := MAN_TO_HTML_$m_$(strip $(call RelativePath, $f, $(TOPDIR)))) \\\n-        $(eval $(call SetupProcessMarkdown, $($m_$f_NAME), \\\n-            SRC := $d, \\\n-            FILES := $f, \\\n-            DEST := $(DOCS_OUTPUTDIR)\/specs\/man, \\\n-            FILTER := $(PANDOC_HTML_MANPAGE_FILTER), \\\n-            CSS := $(GLOBAL_SPECS_DEFAULT_CSS_FILE), \\\n-            REPLACEMENTS := \\\n-\t\t@@COPYRIGHT_YEAR@@ => $(COPYRIGHT_YEAR) ; \\\n-\t\t@@VERSION_SHORT@@ => $(VERSION_SHORT) ; \\\n-\t\t@@VERSION_SPECIFICATION@@ => $(VERSION_SPECIFICATION), \\\n-            OPTIONS := --toc -V include-before='$(SPECS_TOP)' -V include-after='$(SPECS_BOTTOM_1)', \\\n-            POST_PROCESS := $(TOOL_FIXUPPANDOC) --insert-nav --nav-right-info '$(HEADER_RIGHT_SIDE_INFO)' \\\n-                --nav-subdirs 1 --nav-link-guides, \\\n-            EXTRA_DEPS := $(PANDOC_HTML_MANPAGE_FILTER) \\\n-                $(PANDOC_HTML_MANPAGE_FILTER_SOURCE), \\\n-        )) \\\n-        $(eval JDK_SPECS_TARGETS += $($($m_$f_NAME))) \\\n-      ) \\\n+    $(eval MAN_$m := $(call ApplySpecFilter, $(filter %.md, $(call FindFiles, \\\n+          $(call FindModuleManDirs, $m))))) \\\n+    $(if $(MAN_$m), \\\n+      $(eval $(call SetupProcessMarkdown, MAN_TO_HTML_$m, \\\n+        FILES := $(MAN_$m), \\\n+        DEST := $(DOCS_OUTPUTDIR)\/specs\/man, \\\n+        FILTER := $(PANDOC_HTML_MANPAGE_FILTER), \\\n+        CSS := $(GLOBAL_SPECS_DEFAULT_CSS_FILE), \\\n+        REPLACEMENTS := \\\n+            @@COPYRIGHT_YEAR@@ => $(COPYRIGHT_YEAR) ; \\\n+            @@VERSION_SHORT@@ => $(VERSION_SHORT) ; \\\n+            @@VERSION_SPECIFICATION@@ => $(VERSION_SPECIFICATION), \\\n+        OPTIONS := --toc -V include-before='$(SPECS_TOP)' -V include-after='$(SPECS_BOTTOM_1)', \\\n+        POST_PROCESS := $(TOOL_FIXUPPANDOC) --insert-nav --nav-right-info '$(HEADER_RIGHT_SIDE_INFO)' \\\n+            --nav-subdirs 1 --nav-link-guides, \\\n+        EXTRA_DEPS := $(PANDOC_HTML_MANPAGE_FILTER) \\\n+            $(PANDOC_HTML_MANPAGE_FILTER_SOURCE), \\\n+      )) \\\n+      $(eval JDK_SPECS_TARGETS += $(MAN_TO_HTML_$m)) \\\n","filename":"make\/Docs.gmk","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+# Hook to include the corresponding custom file, if present.\n+$(eval $(call IncludeCustomExtension, TestImage-pre.gmk))\n+\n","filename":"make\/TestImage.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-    CFLAGS_OS_DEF_JVM=\"-DAIX -Dalloca'(size)'=__builtin_alloca'(size)' -D_LARGE_FILES\"\n+    CFLAGS_OS_DEF_JVM=\"-DAIX -D_LARGE_FILES\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-    EXECUTABLE_LDFLAGS=\"$EXECUTABLE_LDFLAGS -Wl,--allow-shlib-undefined\"\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -193,0 +193,11 @@\n+  # Setup default CDS alignment. On platforms where one build may run on machines with different\n+  # page sizes, the JVM choses a compatible alignment to fit all possible page sizes. This slightly\n+  # increases archive size.\n+  # The only platform having this problem at the moment is Linux on aarch64, which may encounter\n+  # three different page sizes: 4K, 64K, and if run on Mac m1 hardware, 16K.\n+  COMPATIBLE_CDS_ALIGNMENT_DEFAULT=false\n+  if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\" && test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+    COMPATIBLE_CDS_ALIGNMENT_DEFAULT=true\n+  fi\n+  AC_SUBST(COMPATIBLE_CDS_ALIGNMENT_DEFAULT)\n+\n@@ -676,1 +687,1 @@\n-  UTIL_ARG_ENABLE(NAME: compatible-cds-alignment, DEFAULT: false,\n+  UTIL_ARG_ENABLE(NAME: compatible-cds-alignment, DEFAULT: $COMPATIBLE_CDS_ALIGNMENT_DEFAULT,\n","filename":"make\/autoconf\/jdk-options.m4","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-INTERIM_LANGTOOLS_BASE_MODULES := java.compiler jdk.compiler jdk.javadoc\n+INTERIM_LANGTOOLS_BASE_MODULES := java.compiler jdk.compiler jdk.internal.md jdk.javadoc\n","filename":"make\/autoconf\/spec.gmk.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,4 @@\n-  ifneq ($$($1_REPLACEMENTS), )\n-    $1_$2_PANDOC_INPUT := $$(SUPPORT_OUTPUTDIR)\/markdown\/$$($1_$2_MARKER)_pre.tmp\n+  # Only continue if this target file hasn't been processed already. This lets\n+  # the first found source file override any other with the same name.\n+  ifeq ($$($1_$2_OUTPUT_FILE_PROCESSED), )\n+    $1_$2_OUTPUT_FILE_PROCESSED := true\n@@ -44,8 +46,2 @@\n-    $$(eval $$(call SetupTextFileProcessing, $1_$2_PREPROCESSED, \\\n-        SOURCE_FILES := $$($1_$2_INPUT_FILE), \\\n-        OUTPUT_FILE := $$($1_$2_PANDOC_INPUT), \\\n-        REPLACEMENTS := $$($1_REPLACEMENTS), \\\n-    ))\n-  else\n-    $1_$2_PANDOC_INPUT := $$($1_$2_INPUT_FILE)\n-  endif\n+    ifneq ($$($1_REPLACEMENTS), )\n+      $1_$2_PANDOC_INPUT := $$(SUPPORT_OUTPUTDIR)\/markdown\/$$($1_$2_MARKER)_pre.tmp\n@@ -53,5 +49,8 @@\n-  ifneq ($$($1_POST_PROCESS), )\n-    $1_$2_PANDOC_OUTPUT := $$(SUPPORT_OUTPUTDIR)\/markdown\/$$($1_$2_MARKER)_post.tmp\n-  else\n-    $1_$2_PANDOC_OUTPUT := $$($1_$2_OUTPUT_FILE)\n-  endif\n+      $$(eval $$(call SetupTextFileProcessing, $1_$2_PREPROCESSED, \\\n+          SOURCE_FILES := $$($1_$2_INPUT_FILE), \\\n+          OUTPUT_FILE := $$($1_$2_PANDOC_INPUT), \\\n+          REPLACEMENTS := $$($1_REPLACEMENTS), \\\n+      ))\n+    else\n+      $1_$2_PANDOC_INPUT := $$($1_$2_INPUT_FILE)\n+    endif\n@@ -59,3 +58,2 @@\n-  ifneq ($$($1_CSS), )\n-    ifneq ($$(findstring https:\/, $$($1_CSS)), )\n-      $1_$2_CSS_OPTION := --css '$$($1_CSS)'\n+    ifneq ($$($1_POST_PROCESS), )\n+      $1_$2_PANDOC_OUTPUT := $$(SUPPORT_OUTPUTDIR)\/markdown\/$$($1_$2_MARKER)_post.tmp\n@@ -63,2 +61,10 @@\n-      $1_$2_CSS := $$(strip $$(call RelativePath, $$($1_CSS), $$($1_$2_TARGET_DIR)))\n-      $1_$2_CSS_OPTION := --css '$$($1_$2_CSS)'\n+      $1_$2_PANDOC_OUTPUT := $$($1_$2_OUTPUT_FILE)\n+    endif\n+\n+    ifneq ($$($1_CSS), )\n+      ifneq ($$(findstring https:\/, $$($1_CSS)), )\n+        $1_$2_CSS_OPTION := --css '$$($1_CSS)'\n+      else\n+        $1_$2_CSS := $$(strip $$(call RelativePath, $$($1_CSS), $$($1_$2_TARGET_DIR)))\n+        $1_$2_CSS_OPTION := --css '$$($1_$2_CSS)'\n+      endif\n@@ -66,1 +72,0 @@\n-  endif\n@@ -68,4 +73,4 @@\n-  # This does not need to be included in VARDEPS since it's from the actual\n-  # source file. Only run the shell if the recipe gets executed below.\n-  $1_$2_OPTIONS_FROM_SRC = \\\n-      $$(shell $$(GREP) _pandoc-options_: $3\/$2 | $$(CUT) -d : -f 2-)\n+    # This does not need to be included in VARDEPS since it's from the actual\n+    # source file. Only run the shell if the recipe gets executed below.\n+    $1_$2_OPTIONS_FROM_SRC = \\\n+        $$(shell $$(GREP) _pandoc-options_: $3\/$2 | $$(CUT) -d : -f 2-)\n@@ -73,3 +78,3 @@\n-  ifneq ($$($1_FILTER), )\n-    $1_$2_OPTIONS := --filter $$($1_FILTER)\n-  endif\n+    ifneq ($$($1_FILTER), )\n+      $1_$2_OPTIONS := --filter $$($1_FILTER)\n+    endif\n@@ -77,4 +82,4 @@\n-  $1_$2_VARDEPS := $$($1_OPTIONS) $$($1_$2_OPTIONS) $$($1_CSS) \\\n-      $$($1_REPLACEMENTS) $$($1_POST_PROCESS)\n-  $1_$2_VARDEPS_FILE := $$(call DependOnVariable, $1_$2_VARDEPS, \\\n-      $$(SUPPORT_OUTPUTDIR)\/markdown\/$$($1_$2_MARKER).vardeps)\n+    $1_$2_VARDEPS := $$($1_OPTIONS) $$($1_$2_OPTIONS) $$($1_CSS) \\\n+        $$($1_REPLACEMENTS) $$($1_POST_PROCESS)\n+    $1_$2_VARDEPS_FILE := $$(call DependOnVariable, $1_$2_VARDEPS, \\\n+        $$(SUPPORT_OUTPUTDIR)\/markdown\/$$($1_$2_MARKER).vardeps)\n@@ -82,1 +87,1 @@\n-  $$($1_$2_PANDOC_OUTPUT): $$($1_$2_PANDOC_INPUT) $$($1_$2_VARDEPS_FILE) $$($1_EXTRA_DEPS)\n+    $$($1_$2_PANDOC_OUTPUT): $$($1_$2_PANDOC_INPUT) $$($1_$2_VARDEPS_FILE) $$($1_EXTRA_DEPS)\n@@ -99,4 +104,4 @@\n-  # If we have no post processing, PANDOC_OUTPUT is set to OUTPUT_FILE. Otherwise\n-  # PANDOC_OUTPUT is a temporary file, and we must now create the real OUTPUT_FILE.\n-  ifneq ($$($1_POST_PROCESS), )\n-    $$($1_$2_OUTPUT_FILE): $$($1_$2_PANDOC_OUTPUT)\n+    # If we have no post processing, PANDOC_OUTPUT is set to OUTPUT_FILE. Otherwise\n+    # PANDOC_OUTPUT is a temporary file, and we must now create the real OUTPUT_FILE.\n+    ifneq ($$($1_POST_PROCESS), )\n+      $$($1_$2_OUTPUT_FILE): $$($1_$2_PANDOC_OUTPUT)\n@@ -107,1 +112,1 @@\n-  endif\n+    endif\n@@ -109,1 +114,2 @@\n-  $1 += $$($1_$2_OUTPUT_FILE)\n+    $1 += $$($1_$2_OUTPUT_FILE)\n+  endif\n","filename":"make\/common\/ProcessMarkdown.gmk","additions":45,"deletions":39,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    jdk.internal.le \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+@import url('..\/api\/resource-files\/fonts\/dejavu.css');\n+\n@@ -27,1 +29,0 @@\n-  margin: 2em 2em;\n@@ -30,0 +31,5 @@\n+  margin: 0;\n+  padding: 0;\n+  height: 100%;\n+  width: 100%;\n+  min-width: 100%;\n@@ -34,2 +40,11 @@\n-  font-family: DejaVu Sans Mono, Bitstream Vera Sans Mono, Luxi Mono,\n-    Courier New, monospace;\n+    font-family: DejaVu Sans Mono, Bitstream Vera Sans Mono, Luxi Mono, Courier New, monospace;\n+}\n+\n+main, footer {\n+  margin: 16px 27px;\n+}\n+\n+\/* Adjust horizontal margin for content elements outside of main element *\/\n+:is(body, header) > :is(nav, h1, h2, h3, h4, h5, h6, p, .sub-title) {\n+    margin-left: 27px;\n+    margin-right: 27px;\n@@ -39,1 +54,1 @@\n-  margin: 1.5ex 0em 1.5ex 2em;\n+  margin: 1.5ex 0 1.5ex 2em;\n@@ -43,2 +58,2 @@\n-  padding: 0pt;\n-  margin: 1ex 0em;\n+  margin-top: 1ex;\n+  margin-bottom: 1ex;\n@@ -47,6 +62,2 @@\n-p:first-child, pre:first-child { margin-top: 0pt; }\n-\n-h1 {\n-  font-weight: bold;\n-  padding: 0pt;\n-  margin: 2ex .5ex 1ex 0pt;\n+dd > p:first-child, pre:first-child {\n+  margin-top: 0;\n@@ -56,1 +67,1 @@\n-  margin-top: 0ex;\n+  margin-top: 0;\n@@ -59,4 +70,3 @@\n-h2 {\n-  font-weight: bold;\n-  padding: 0pt;\n-  margin: 2ex 0pt 1ex 0pt;\n+h1, h2 {\n+  margin-top: 2ex;\n+  margin-bottom: 1ex;\n@@ -65,4 +75,3 @@\n-h3 {\n-  font-weight: bold;\n-  padding: 0pt;\n-  margin: 1.5ex 0pt 1ex 0pt;\n+h3, h4, h5 {\n+  margin-top: 1.5ex;\n+  margin-bottom: 1ex;\n@@ -73,3 +82,0 @@\n-  font-weight: bold;\n-  padding: 0pt;\n-  margin: 1.5ex 0pt 1ex 0pt;\n@@ -103,1 +109,1 @@\n-  border-width: 0px;\n+  border-width: 0;\n@@ -157,1 +163,1 @@\n-  font-size: 80%;\n+  font-size: 11.2px;\n@@ -159,1 +165,1 @@\n-  margin: -2.5em -2.5em 2.5em -2.5em;\n+  line-height: initial;\n@@ -186,2 +192,13 @@\n-header#title-block-header {\n-    margin-top:-2em;\n+\/* Rules below replicate sizing of navigation bar in API docs *\/\n+header#title-block-header div.navbar {\n+    padding: 0 20px 0 26px;\n+    margin-bottom: 30px;\n+    background-color: #4D7A97;\n+    color: #FFFFFF;\n+    height: 44px;\n+    overflow: hidden;\n+    font-size: 0.857em;\n+    line-height: initial;\n+    display: flex;\n+    flex-direction: row-reverse;\n+    align-items: center;\n@@ -190,12 +207,4 @@\n-header#title-block-header div.navbar {\n-    margin: 0 -2.5em 2.5em -2.5em;\n-    padding: 0 2.5em;\n-    background-color:#4D7A97;\n-    color:#FFFFFF;\n-    float:left;\n-    width:100%;\n-    clear:right;\n-    min-height:2.8em;\n-    padding-top:10px;\n-    overflow:hidden;\n-    font-size:12px;\n+header#title-block-header div.navbar nav {\n+    flex: 1 1 auto;\n+    font-size: 12px;\n+    white-space: nowrap;\n@@ -205,4 +214,3 @@\n-    float:right;\n-    font-size:11px;\n-    height:2.9em;\n-    margin: auto 0;\n+    flex: 0 0 auto;\n+    font-size: 10.978px;\n+    white-space: nowrap;\n","filename":"make\/data\/docs-resources\/resources\/jdk-default.css","additions":54,"deletions":46,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-   public class DirAttributes {\n+   public static class DirAttributes {\n","filename":"make\/ide\/visualstudio\/hotspot\/src\/classes\/build\/tools\/projectcreator\/FileTreeCreator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    static final String LIKELY_SCRIPT_PREFIX = \"likelyScript.\";\n@@ -117,0 +118,1 @@\n+    static boolean nonlikelyScript;\n@@ -120,0 +122,3 @@\n+    \/\/ \"likelyScript\" map\n+    private static final Map<String, SortedSet<String>> likelyScriptMap = new HashMap<>();\n+\n@@ -178,1 +183,1 @@\n-       \/\/ no instantiation\n+        \/\/ no instantiation\n@@ -478,2 +483,2 @@\n-                .filter(key -> key.startsWith(PARENT_LOCALE_PREFIX))\n-                .forEach(key -> {\n+            .filter(key -> key.startsWith(PARENT_LOCALE_PREFIX))\n+            .forEach(key -> {\n@@ -495,0 +500,10 @@\n+        handlerLikelySubtags.getData().forEach((from, to) -> {\n+            if (!from.contains(\"-\")) { \/\/ look for language-only tag\n+                var script = to.split(\"-\")[1];\n+                var key = LIKELY_SCRIPT_PREFIX + script;\n+                var prev = likelyScriptMap.putIfAbsent(key, new TreeSet<String>(Set.of(from)));\n+                if (prev != null) {\n+                    prev.add(from);\n+                }\n+            }\n+        });\n@@ -564,0 +579,1 @@\n+            metaInfo.putAll(likelyScriptMap);\n@@ -1138,1 +1154,1 @@\n-            Locale p = childToParentLocaleMap.get(l);\n+            Locale p = getParentLocale(l);\n@@ -1155,0 +1171,21 @@\n+    private static Locale getParentLocale(Locale child) {\n+        Locale parent = childToParentLocaleMap.get(child);\n+\n+        \/\/ check non-likely script for root\n+        if (nonlikelyScript && parent == null && child.getCountry().isEmpty()) {\n+            var lang = \" \" + child.getLanguage() + \" \";\n+            var script = child.getScript();\n+\n+            if (!script.isEmpty()) {\n+                parent = likelyScriptMap.entrySet().stream()\n+                    .filter(e -> e.getValue().contains(lang))\n+                    .findAny()\n+                    .map(Map.Entry::getKey)\n+                    .map(likely -> likely.equals(script) ? null : Locale.ROOT)\n+                    .orElse(null);\n+            }\n+        }\n+\n+        return parent;\n+    }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.stream.Collectors;\n@@ -309,7 +310,6 @@\n-                    private static final Map<String, String> resourceNameToLocales = HashMap.newHashMap(%d);\n-                %s\n-                    static {\n-                \"\"\", CLDRConverter.isBaseModule ? \"cldr\" : \"resources.cldr.provider\",\n-                className, metaInfo.keySet().stream().filter(k -> k.equals(\"AvailableLocales\")).count(),\n-                CLDRConverter.isBaseModule ?\n-                    \"\"\"\n+                \"\"\",\n+                    CLDRConverter.isBaseModule ? \"cldr\" : \"resources.cldr.provider\",\n+                    className);\n+\n+            if (CLDRConverter.isBaseModule) {\n+                out.printf(\"\"\"\n@@ -318,0 +318,3 @@\n+                        static final boolean nonlikelyScript = %s; \/\/ package access from CLDRLocaleProviderAdapter\n+\n+                        static {\n@@ -320,24 +323,11 @@\n-                        CLDRConverter.handlerSupplMeta.getLanguageAliasData().size()) :\n-                    \"\");\n-\n-            for (String key : metaInfo.keySet()) {\n-                if (key.startsWith(CLDRConverter.PARENT_LOCALE_PREFIX)) {\n-                    String parentTag = key.substring(CLDRConverter.PARENT_LOCALE_PREFIX.length());\n-                    if (\"root\".equals(parentTag)) {\n-                        out.printf(\"        parentLocalesMap.put(Locale.ROOT,\\n\");\n-                    } else {\n-                        out.printf(\"        parentLocalesMap.put(Locale.forLanguageTag(\\\"%s\\\"),\\n\",\n-                                   parentTag);\n-                    }\n-                    String[] children = toLocaleList(metaInfo.get(key), true).split(\" \");\n-                    Arrays.sort(children);\n-                    out.printf(\"            new String[] {\\n\" +\n-                               \"                \");\n-                    int count = 0;\n-                    for (int i = 0; i < children.length; i++) {\n-                        String child = children[i];\n-                        out.printf(\"\\\"%s\\\", \", child);\n-                        count += child.length() + 4;\n-                        if (i != children.length - 1 && count > 64) {\n-                            out.printf(\"\\n                \");\n-                            count = 0;\n+                        CLDRConverter.handlerSupplMeta.getLanguageAliasData().size(),\n+                        Boolean.valueOf(CLDRConverter.nonlikelyScript)));\n+\n+                for (String key : metaInfo.keySet()) {\n+                    if (key.startsWith(CLDRConverter.PARENT_LOCALE_PREFIX)) {\n+                        String parentTag = key.substring(CLDRConverter.PARENT_LOCALE_PREFIX.length());\n+                        if (\"root\".equals(parentTag)) {\n+                            out.printf(\"        parentLocalesMap.put(Locale.ROOT,\\n\");\n+                        } else {\n+                            out.printf(\"        parentLocalesMap.put(Locale.forLanguageTag(\\\"%s\\\"),\\n\",\n+                                    parentTag);\n@@ -345,6 +335,1 @@\n-                    }\n-                    out.printf(\"\\n            });\\n\");\n-                } else {\n-                    if (\"AvailableLocales\".equals(key)) {\n-                        out.printf(\"        resourceNameToLocales.put(\\\"%s\\\",\\n\", key);\n-                        out.printf(\"            \\\"%s\\\");\\n\", toLocaleList(applyLanguageAliases(metaInfo.get(key)), false));\n+                        generateStringArray(metaInfo.get(key), out);\n@@ -353,3 +338,3 @@\n-            }\n-            \/\/ for languageAliasMap\n-            if (CLDRConverter.isBaseModule) {\n+                out.println();\n+\n+                \/\/ for languageAliasMap\n@@ -359,1 +344,1 @@\n-            }\n+                out.printf(\"    }\\n\\n\");\n@@ -361,1 +346,1 @@\n-            out.printf(\"    }\\n\\n\");\n+                \/\/ end of static initializer block.\n@@ -363,4 +348,1 @@\n-            \/\/ end of static initializer block.\n-\n-            \/\/ Canonical TZ names for delayed initialization\n-            if (CLDRConverter.isBaseModule) {\n+                \/\/ Delayed initialization section\n@@ -368,2 +350,4 @@\n-                               private static class TZCanonicalIDMapHolder {\n-                                   static final Map<String, String> tzCanonicalIDMap = HashMap.newHashMap(%d);\n+                               private static class CLDRMapHolder {\n+                                   private static final Map<String, String> tzCanonicalIDMap = HashMap.newHashMap(%d);\n+                                   private static final Map<String, String> likelyScriptMap = HashMap.newHashMap(%d);\n+\n@@ -371,1 +355,2 @@\n-                           \"\"\", CLDRConverter.handlerTimeZone.getData().size());\n+                           \"\"\", CLDRConverter.handlerTimeZone.getData().size(),\n+                                metaInfo.keySet().stream().filter(k -> k.startsWith(CLDRConverter.LIKELY_SCRIPT_PREFIX)).count());\n@@ -376,1 +361,1 @@\n-                                ids[0]);\n+                            ids[0]);\n@@ -382,1 +367,12 @@\n-                out.printf(\"        }\\n    }\\n\\n\");\n+                out.println();\n+\n+                \/\/ for likelyScript map\n+                for (String key : metaInfo.keySet()) {\n+                    if (key.startsWith(CLDRConverter.LIKELY_SCRIPT_PREFIX)) {\n+                        \/\/ ensure spaces at the begin\/end for delimiting purposes\n+                        out.printf(\"            likelyScriptMap.put(\\\"%s\\\", \\\"%s\\\");\\n\",\n+                                key.substring(CLDRConverter.LIKELY_SCRIPT_PREFIX.length()),\n+                                \" \" + metaInfo.get(key).stream().collect(Collectors.joining(\" \")) + \" \");\n+                    }\n+                }\n+                out.printf(\"        }\\n    }\\n\");\n@@ -384,0 +380,1 @@\n+            out.println();\n@@ -393,1 +390,1 @@\n-                        return resourceNameToLocales.getOrDefault(category, \"\");\n+                        return \" %s\";\n@@ -395,2 +392,0 @@\n-                    %s\n-                }\n@@ -398,1 +393,4 @@\n-                CLDRConverter.isBaseModule ? \"\"\"\n+                toLocaleList(applyLanguageAliases(metaInfo.get(\"AvailableLocales\")), false));\n+\n+            if(CLDRConverter.isBaseModule) {\n+                out.printf(\"\"\"\n@@ -407,1 +405,1 @@\n-                        return TZCanonicalIDMapHolder.tzCanonicalIDMap;\n+                        return CLDRMapHolder.tzCanonicalIDMap;\n@@ -413,1 +411,8 @@\n-                \"\"\" : \"\");\n+\n+                    \/\/ package access from CLDRLocaleProviderAdapter\n+                    Map<String, String> likelyScriptMap() {\n+                        return CLDRMapHolder.likelyScriptMap;\n+                    }\n+                \"\"\");\n+            }\n+            out.printf(\"}\\n\");\n@@ -417,0 +422,18 @@\n+    private static void generateStringArray(SortedSet<String> set, PrintWriter out) throws IOException {\n+        String[] children = toLocaleList(set, true).split(\" \");\n+        Arrays.sort(children);\n+        out.printf(\"            new String[] {\\n\" +\n+                \"                \");\n+        int count = 0;\n+        for (int i = 0; i < children.length; i++) {\n+            String child = children[i];\n+            out.printf(\"\\\"%s\\\", \", child);\n+            count += child.length() + 4;\n+            if (i != children.length - 1 && count > 64) {\n+                out.printf(\"\\n                \");\n+                count = 0;\n+            }\n+        }\n+        out.printf(\"\\n            });\\n\");\n+    }\n+\n@@ -436,1 +459,3 @@\n-                sb.append(' ');\n+                if (sb.length() > 0) {\n+                    sb.append(' ');\n+                }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/ResourceBundleGenerator.java","additions":84,"deletions":59,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    private final Map<String, Object> firstDayMap;\n-    private final Map<String, Object> minDaysMap;\n+    private static final Map<String, Object> firstDayMap = new HashMap<>();\n+    private static final Map<String, Object> minDaysMap = new HashMap<>();\n@@ -67,1 +67,1 @@\n-    private final Map<String, String> parentLocalesMap;\n+    private static final Map<String, String> parentLocalesMap = new HashMap<>();\n@@ -71,1 +71,1 @@\n-    private final Map<String, Map<String, SortedSet<String>>> inputSkeletonMap;\n+    private static final Map<String, Map<String, SortedSet<String>>> inputSkeletonMap = new HashMap<>();\n@@ -76,7 +76,0 @@\n-    SupplementalDataParseHandler() {\n-        firstDayMap = new HashMap<>();\n-        minDaysMap = new HashMap<>();\n-        parentLocalesMap = new HashMap<>();\n-        inputSkeletonMap = new HashMap<>();\n-    }\n-\n@@ -161,0 +154,2 @@\n+                    var parent = attributes.getValue(\"parent\").replaceAll(\"_\", \"-\");\n+\n@@ -162,1 +157,1 @@\n-                        attributes.getValue(\"parent\").replaceAll(\"_\", \"-\"),\n+                        parent,\n@@ -164,0 +159,4 @@\n+\n+                    if (\"root\".equals(parent)) {\n+                        CLDRConverter.nonlikelyScript = \"nonlikelyScript\".equals(attributes.getValue(\"localeRules\"));\n+                    }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/SupplementalDataParseHandler.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,3 +315,0 @@\n-            if (Math.abs(time - System.currentTimeMillis()) > ((long) 10) * 365 * 24 * 60 * 60 * 1000) {\n-                throw new RuntimeException(\"time is more than 10 years from present: \" + time);\n-            }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecurrencydata\/GenerateCurrencyData.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -781,1 +781,1 @@\n-        result.appendLine(\"protected void mult(long[] a, long[] b, long[] r) {\");\n+        result.appendLine(\"protected int mult(long[] a, long[] b, long[] r) {\");\n@@ -807,0 +807,3 @@\n+        result.appendIndent();\n+        result.append(\"return 0;\");\n+        result.appendLine();\n@@ -836,1 +839,1 @@\n-        result.appendLine(\"protected void square(long[] a, long[] r) {\");\n+        result.appendLine(\"protected int square(long[] a, long[] r) {\");\n@@ -877,0 +880,3 @@\n+        result.appendIndent();\n+        result.append(\"return 0;\");\n+        result.appendLine();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -160,1 +162,4 @@\n-            String tagText = contents.toString().trim();\n+            String tagText = contents.stream()\n+                    .map(Object::toString)\n+                    .collect(Collectors.joining())\n+                    .trim();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/JSpec.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -108,2 +110,5 @@\n-            UnknownBlockTagTree blockTag = (UnknownBlockTagTree)tag;\n-            String tagText = blockTag.getContent().toString().trim();\n+            UnknownBlockTagTree blockTag = (UnknownBlockTagTree) tag;\n+            String tagText = blockTag.getContent().stream()\n+                    .map(Object::toString)\n+                    .collect(Collectors.joining())\n+                    .trim();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/ToolGuide.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -978,1 +978,1 @@\n-            int targetIdx = addString(cp, header.moduleMainClass);\n+            int targetIdx = addClassName(cp, header.moduleMainClass);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-DISABLED_WARNINGS_java +=\n+DISABLED_WARNINGS_java += dangling-doc-comments\n","filename":"make\/modules\/java.base\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+\n+COPY += .ico\n","filename":"make\/modules\/jdk.httpserver\/Java.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += dangling-doc-comments\n+\n","filename":"make\/modules\/jdk.incubator.vector\/Java.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-#\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-include LibCommon.gmk\n-\n-ifeq ($(call isTargetOs, aix), false)\n-  ##############################################################################\n-  ## Build lible\n-  ##############################################################################\n-\n-  $(eval $(call SetupJdkLibrary, BUILD_LIBLE, \\\n-      NAME := le, \\\n-      LINK_TYPE := C++, \\\n-      OPTIMIZATION := LOW, \\\n-      EXTRA_HEADER_DIRS := \\\n-          java.base:libjava \\\n-          java.base:libjvm, \\\n-      LD_SET_ORIGIN := false, \\\n-      LIBS_windows := user32.lib, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBLE)\n-endif\n","filename":"make\/modules\/jdk.internal.le\/Lib.gmk","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-DOCLINT += -Xdoclint:all\/protected\n+COPY += .txt\n","filename":"make\/modules\/jdk.internal.md\/Java.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/modules\/jdk.incubator.vector\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+DISABLED_WARNINGS_java += dangling-doc-comments\n+\n","filename":"make\/modules\/jdk.jpackage\/Java.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"","filename":"make\/modules\/jdk.unsupported\/Java.gmk","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/modules\/jdk.accessibility\/Java.gmk","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        serial preview unchecked deprecation, \\\n+        serial preview unchecked deprecation dangling-doc-comments, \\\n@@ -112,0 +112,2 @@\n+        --add-exports java.base\/sun.security.util.math=ALL-UNNAMED \\\n+        --add-exports java.base\/sun.security.util.math.intpoly=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -697,0 +697,5 @@\n+\/\/ Class for all non_special pointer registers (excluding rfp)\n+reg_class no_special_no_rfp_ptr_reg %{\n+  return _NO_SPECIAL_NO_RFP_PTR_REG_mask;\n+%}\n+\n@@ -1128,0 +1133,1 @@\n+extern RegMask _NO_SPECIAL_NO_RFP_PTR_REG_mask;\n@@ -1216,0 +1222,1 @@\n+  RegMask _NO_SPECIAL_NO_RFP_PTR_REG_mask;\n@@ -1252,0 +1259,3 @@\n+\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -4716,0 +4726,12 @@\n+\/\/ This operand is not allowed to use rfp even if\n+\/\/ rfp is not used to hold the frame pointer.\n+operand iRegPNoSpNoRfp()\n+%{\n+  constraint(ALLOC_IN_RC(no_special_no_rfp_ptr_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -16165,1 +16187,3 @@\n-instruct TailCalljmpInd(iRegPNoSp jump_target, inline_cache_RegP method_ptr)\n+\/\/ Don't use rfp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset rfp to the caller state.\n+instruct TailCalljmpInd(iRegPNoSpNoRfp jump_target, inline_cache_RegP method_ptr)\n@@ -16178,1 +16202,1 @@\n-instruct TailjmpInd(iRegPNoSp jump_target, iRegP_R0 ex_oop)\n+instruct TailjmpInd(iRegPNoSpNoRfp jump_target, iRegP_R0 ex_oop)\n@@ -16284,1 +16308,1 @@\n-  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+  format %{ \"partialSubtypeCheck $result, $sub, $super_reg, $super_con\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n@@ -162,1 +162,0 @@\n-      case Op_LoadVectorGather:\n@@ -164,1 +163,0 @@\n-      case Op_LoadVectorGatherMasked:\n@@ -173,0 +171,6 @@\n+      case Op_LoadVectorGather:\n+      case Op_LoadVectorGatherMasked:\n+        if (UseSVE == 0 || is_subword_type(bt)) {\n+          return false;\n+        }\n+        break;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1265,1 +1265,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -2690,1 +2691,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -894,1 +894,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -927,0 +933,3 @@\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n@@ -1149,1 +1158,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1166,1 +1181,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n@@ -1200,1 +1215,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, x->is_null_free());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -289,2 +289,1 @@\n-\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array) {\n@@ -315,1 +314,3 @@\n-  initialize_body(obj, arr_size, base_offset, t1, t2);\n+  if (zero_array) {\n+    initialize_body(obj, arr_size, base_offset, t1, t2);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case);\n+  \/\/ zero_array          : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-  RegMaskIterator rmi(stub->live());\n+  RegMaskIterator rmi(stub->preserve_set());\n@@ -522,1 +522,1 @@\n-      \/\/ We have size encoding in OptoReg of stub->live()\n+      \/\/ We have size encoding in OptoReg of stub->preserve_set()\n@@ -563,6 +563,2 @@\n-  \/\/ Remove C-ABI SOE registers, scratch regs and _ref register that will be updated\n-  if (stub->result() != noreg) {\n-    _gp_regs -= RegSet::range(r19, r30) + RegSet::of(r8, r9, stub->result());\n-  } else {\n-    _gp_regs -= RegSet::range(r19, r30) + RegSet::of(r8, r9);\n-  }\n+  \/\/ Remove C-ABI SOE registers and scratch regs\n+  _gp_regs -= RegSet::range(r19, r30) + RegSet::of(r8, r9);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -145,3 +145,5 @@\n-\/\/ Default value if probing is not implemented for a certain platform: 128TB\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n-\/\/ Minimum value returned, if probing fails: 64GB\n+\/\/ Default value if probing is not implemented for a certain platform\n+\/\/ Max address bit is restricted by implicit assumptions in the code, for instance\n+\/\/ the bit layout of XForwardingEntry or Partial array entry (see XMarkStackEntry) in mark stack\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = 46;\n+\/\/ Minimum value returned, if probing fails\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/xGlobals_aarch64.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,3 +39,5 @@\n-\/\/ Default value if probing is not implemented for a certain platform: 128TB\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n-\/\/ Minimum value returned, if probing fails: 64GB\n+\/\/ Default value if probing is not implemented for a certain platform\n+\/\/ Max address bit is restricted by implicit assumptions in the code, for instance\n+\/\/ the bit layout of XForwardingEntry or Partial array entry (see XMarkStackEntry) in mark stack\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = 46;\n+\/\/ Minimum value returned, if probing fail\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zAddress_aarch64.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1144,1 +1144,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -1163,1 +1162,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5908,1 +5908,0 @@\n-  Register cnt2 = tmp2;  \/\/ cnt2 only used in array length compare\n@@ -5911,0 +5910,1 @@\n+  int klass_offset  = arrayOopDesc::klass_offset_in_bytes();\n@@ -5914,0 +5914,10 @@\n+  \/\/ When the length offset is not aligned to 8 bytes,\n+  \/\/ then we align it down. This is valid because the new\n+  \/\/ offset will always be the klass which is the same\n+  \/\/ for type arrays.\n+  int start_offset = align_down(length_offset, BytesPerWord);\n+  int extra_length = base_offset - start_offset;\n+  assert(start_offset == length_offset || start_offset == klass_offset,\n+         \"start offset must be 8-byte-aligned or be the klass offset\");\n+  assert(base_offset != start_offset, \"must include the length field\");\n+  extra_length = extra_length \/ elem_size; \/\/ We count in elements, not bytes.\n@@ -5947,5 +5957,4 @@\n-    ldrw(cnt2, Address(a2, length_offset));\n-    eorw(tmp5, cnt1, cnt2);\n-    cbnzw(tmp5, DONE);\n-    lea(a1, Address(a1, base_offset));\n-    lea(a2, Address(a2, base_offset));\n+    \/\/ Increase loop counter by diff between base- and actual start-offset.\n+    addw(cnt1, cnt1, extra_length);\n+    lea(a1, Address(a1, start_offset));\n+    lea(a2, Address(a2, start_offset));\n@@ -6014,1 +6023,3 @@\n-    ldrw(cnt2, Address(a2, length_offset));\n+    \/\/ Increase loop counter by diff between base- and actual start-offset.\n+    addw(cnt1, cnt1, extra_length);\n+\n@@ -6019,1 +6030,1 @@\n-    ldr(tmp3, Address(pre(a1, base_offset)));\n+    ldr(tmp3, Address(pre(a1, start_offset)));\n@@ -6022,1 +6033,1 @@\n-    ldr(tmp4, Address(pre(a2, base_offset)));\n+    ldr(tmp4, Address(pre(a2, start_offset)));\n@@ -6024,2 +6035,0 @@\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n@@ -6057,3 +6066,1 @@\n-    ldr(tmp4, Address(pre(a2, base_offset)));\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n+    ldr(tmp4, Address(pre(a2, start_offset)));\n@@ -6080,3 +6087,0 @@\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n-    cbz(cnt1, SAME);\n@@ -6084,2 +6088,2 @@\n-    ldr(tmp3, Address(a1, base_offset));\n-    ldr(tmp4, Address(a2, base_offset));\n+    ldr(tmp3, Address(a1, start_offset));\n+    ldr(tmp4, Address(a2, start_offset));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -37,1 +37,1 @@\n-    guarantee(ni->data() == (intptr_t)(x + o), \"instructions must match\");\n+    guarantee(ni->data() == (intptr_t)x, \"instructions must match\");\n@@ -39,1 +39,1 @@\n-    ni->set_data((intptr_t)(x + o));\n+    ni->set_data((intptr_t)x);\n","filename":"src\/hotspot\/cpu\/arm\/relocInfo_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-  : _masm(masm), _reg_mask(stub->live()), _result_reg(stub->result()) {\n+  : _masm(masm), _reg_mask(stub->preserve_set()) {\n@@ -320,5 +320,0 @@\n-      \/\/ '_result_reg' will hold the end result of the operation. Its content must thus not be preserved.\n-      if (std_reg == _result_reg) {\n-        continue;\n-      }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-  Register _result_reg;\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -890,1 +890,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -914,1 +913,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n-  \/\/ Currently we don't support splitting of relocations.\n-  assert(o == 0, \"tried to split relocations\");\n-\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -659,11 +659,13 @@\n-#define INSN(NAME, op)                                                                \\\n-  void NAME(Register Rd, const int32_t offset) {                                      \\\n-    guarantee(is_simm21(offset) && ((offset % 2) == 0), \"offset is invalid.\");        \\\n-    unsigned insn = 0;                                                                \\\n-    patch((address)&insn, 6, 0, op);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                 \\\n-    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                 \\\n-    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                      \\\n-    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                 \\\n-    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                      \\\n-    emit(insn);                                                                       \\\n+ private:\n+  \/\/ All calls and jumps must go via MASM.\n+  \/\/ Format J-type\n+  void _jal(Register Rd, const int32_t offset) {\n+    guarantee(is_simm21(offset) && ((offset % 2) == 0), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    patch((address)&insn, 6, 0, 0b1101111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));\n+    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));\n+    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));\n+    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));\n+    emit(insn);\n@@ -672,15 +674,11 @@\n-  INSN(jal, 0b1101111);\n-\n-#undef INSN\n-\n-#define INSN(NAME, op, funct)                                                         \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                         \\\n-    guarantee(is_simm12(offset), \"offset is invalid.\");                               \\\n-    unsigned insn = 0;                                                                \\\n-    patch((address)&insn, 6, 0, op);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                 \\\n-    patch((address)&insn, 14, 12, funct);                                             \\\n-    patch_reg((address)&insn, 15, Rs);                                                \\\n-    int32_t val = offset & 0xfff;                                                     \\\n-    patch((address)&insn, 31, 20, val);                                               \\\n-    emit(insn);                                                                       \\\n+  \/\/ Format I-type\n+  void _jalr(Register Rd, Register Rs, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    patch((address)&insn, 6, 0, 0b1100111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 14, 12, 0b000);\n+    patch_reg((address)&insn, 15, Rs);\n+    int32_t val = offset & 0xfff;\n+    patch((address)&insn, 31, 20, val);\n+    emit(insn);\n@@ -689,3 +687,1 @@\n-  INSN(_jalr, 0b1100111, 0b000);\n-\n-#undef INSN\n+ public:\n@@ -1872,1 +1868,0 @@\n-  INSN(vandn_vx,   0b1010111, 0b100, 0b000001);\n@@ -1874,1 +1869,0 @@\n-  INSN(vclmul_vx,  0b1010111, 0b110, 0b001100);\n@@ -1876,1 +1870,0 @@\n-  INSN(vclmulh_vx, 0b1010111, 0b110, 0b001101);\n@@ -1878,1 +1871,0 @@\n-  INSN(vror_vx,    0b1010111, 0b100, 0b010100);\n@@ -1880,1 +1872,0 @@\n-  INSN(vrol_vx,    0b1010111, 0b100, 0b010101);\n@@ -1890,2 +1881,6 @@\n-  INSN(vbrev8_v, 0b1010111, 0b010, 0b01000, 0b010010);\n-  INSN(vrev8_v,  0b1010111, 0b010, 0b01001, 0b010010);\n+  INSN(vbrev_v,  0b1010111, 0b010, 0b01010, 0b010010); \/\/ reverse bits in every element\n+  INSN(vbrev8_v, 0b1010111, 0b010, 0b01000, 0b010010); \/\/ reverse bits in every byte of element\n+  INSN(vrev8_v,  0b1010111, 0b010, 0b01001, 0b010010); \/\/ reverse bytes in every elememt\n+\n+  INSN(vclz_v,  0b1010111, 0b010, 0b01100, 0b010010); \/\/ count leading zeros\n+  INSN(vctz_v,  0b1010111, 0b010, 0b01101, 0b010010); \/\/ count trailing zeros\n@@ -1907,0 +1902,10 @@\n+#define INSN(NAME, op, funct3, Vs1, funct6)                                    \\\n+  void NAME(VectorRegister Vd, VectorRegister Vs2, VectorMask vm = unmasked) { \\\n+    patch_VArith(op, Vd, funct3, Vs1, Vs2, vm, funct6);                        \\\n+  }\n+\n+  \/\/ Vector Basic Bit-manipulation (Zvbb) Extension\n+  INSN(vcpop_v,  0b1010111, 0b010, 0b01110, 0b010010);\n+\n+#undef INSN\n+\n@@ -2288,9 +2293,13 @@\n-#define INSN(NAME, funct4, op)                                                               \\\n-  void NAME(Register Rs1) {                                                                  \\\n-    assert_cond(Rs1 != x0);                                                                  \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_reg((address)&insn, 2, x0);                                                      \\\n-    c_patch_reg((address)&insn, 7, Rs1);                                                     \\\n-    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n-    emit_int16(insn);                                                                        \\\n+ private:\n+  \/\/ All calls and jumps must go via MASM.\n+  \/\/ Format CR, c.jr\/c.jalr\n+  \/\/ Note C instruction can't be changed, i.e. relocation patching.\n+  template <uint8_t InstructionType, uint8_t FunctionType>\n+  void c_cr_if(Register Rs1) {\n+    assert_cond(Rs1 != x0);\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, FunctionType);\n+    c_patch_reg((address)&insn, 2, x0);\n+    c_patch_reg((address)&insn, 7, Rs1);\n+    c_patch((address)&insn, 15, 12, InstructionType);\n+    emit_int16(insn);\n@@ -2299,4 +2308,2 @@\n-  INSN(c_jr,   0b1000, 0b10);\n-  INSN(c_jalr, 0b1001, 0b10);\n-\n-#undef INSN\n+  void c_jr(Register Rs1)   { c_cr_if<0b1000, 0b10>(Rs1); }\n+  void c_jalr(Register Rs1) { c_cr_if<0b1001, 0b10>(Rs1); }\n@@ -2325,24 +2332,16 @@\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(int32_t offset) {                                                                \\\n-    assert(is_simm12(offset) && ((offset % 2) == 0), \"invalid encoding\");                    \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);                               \\\n-    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);                          \\\n-    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);                               \\\n-    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);                               \\\n-    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);                             \\\n-    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);                        \\\n-    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);                             \\\n-    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);                           \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }                                                                                          \\\n-  void NAME(address dest) {                                                                  \\\n-    assert_cond(dest != nullptr);                                                            \\\n-    int64_t distance = dest - pc();                                                          \\\n-    assert(is_simm12(distance) && ((distance % 2) == 0), \"invalid encoding\");                \\\n-    c_j(distance);                                                                           \\\n-  }                                                                                          \\\n-  void NAME(Label &L) {                                                                      \\\n-    wrap_label(L, &Assembler::NAME);                                                         \\\n+  \/\/ Format CJ, c.j (c.jal)\n+  \/\/ Note C instruction can't be changed, i.e. relocation patching.\n+  void c_j(int32_t offset) {\n+    assert(is_simm12(offset) && ((offset % 2) == 0), \"invalid encoding\");\n+    uint16_t insn = 0;\n+    c_patch((address)&insn, 1, 0, 0b01);\n+    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);\n+    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);\n+    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);\n+    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);\n+    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);\n+    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);\n+    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);\n+    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);\n+    c_patch((address)&insn, 15, 13, 0b101);\n+    emit_int16(insn);\n@@ -2351,1 +2350,6 @@\n-  INSN(c_j, 0b101, 0b01);\n+  void c_j(address dest) {\n+    assert_cond(dest != nullptr);\n+    int64_t distance = dest - pc();\n+    assert(is_simm12(distance) && ((distance % 2) == 0), \"invalid encoding\");\n+    c_j(distance);\n+  }\n@@ -2353,1 +2357,5 @@\n-#undef INSN\n+  void c_j(Label &L) {\n+    wrap_label(L, &Assembler::c_j);\n+  }\n+\n+  public:\n@@ -2806,13 +2814,14 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n-    \/* jalr -> c.jr\/c.jalr *\/                                                                \\\n-    if (do_compress() && (offset == 0 && Rs != x0)) {                                        \\\n-      if (Rd == x1) {                                                                        \\\n-        c_jalr(Rs);                                                                          \\\n-        return;                                                                              \\\n-      } else if (Rd == x0) {                                                                 \\\n-        c_jr(Rs);                                                                            \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _jalr(Rd, Rs, offset);                                                                   \\\n+ protected:\n+  \/\/ All calls and jumps must go via MASM.\n+  void jalr(Register Rd, Register Rs, const int32_t offset) {\n+    \/* jalr -> c.jr\/c.jalr *\/\n+    if (do_compress() && (offset == 0 && Rs != x0)) {\n+      if (Rd == x1) {\n+        c_jalr(Rs);\n+        return;\n+      } else if (Rd == x0) {\n+        c_jr(Rs);\n+        return;\n+      }\n+    }\n+    _jalr(Rd, Rs, offset);\n@@ -2821,1 +2830,8 @@\n-  INSN(jalr);\n+  void jal(Register Rd, const int32_t offset) {\n+    \/* jal -> c.j, note c.jal is RV32C only *\/\n+    if (do_compress() &&\n+        Rd == x0 &&\n+        is_simm12(offset) && ((offset % 2) == 0)) {\n+      c_j(offset);\n+      return;\n+    }\n@@ -2823,1 +2839,4 @@\n-#undef INSN\n+    _jal(Rd, offset);\n+  }\n+\n+  public:\n@@ -3003,12 +3022,0 @@\n-\/\/ ---------------------------------------------------------------------------------------\n-\n-#define INSN(NAME, REGISTER)                       \\\n-  void NAME(Register Rs) {                         \\\n-    jalr(REGISTER, Rs, 0);                         \\\n-  }\n-\n-  INSN(jr,   x0);\n-  INSN(jalr, x1);\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":109,"deletions":102,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -1844,11 +1844,1 @@\n-  CodeBlob *cb = CodeCache::find_blob(dest);\n-  if (cb != nullptr) {\n-    __ far_call(RuntimeAddress(dest));\n-  } else {\n-    RuntimeAddress target(dest);\n-    __ relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      __ movptr(t0, target.target(), offset);\n-      __ jalr(x1, t0, offset);\n-    });\n-  }\n+  __ rt_call(dest);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-  RegMaskIterator rmi(stub->live());\n+  RegMaskIterator rmi(stub->preserve_set());\n@@ -417,6 +417,2 @@\n-  \/\/ Remove C-ABI SOE registers, tmp regs and _ref register that will be updated\n-  if (stub->result() != noreg) {\n-    _gp_regs -= RegSet::range(x18, x27) + RegSet::of(x2) + RegSet::of(x8, x9) + RegSet::of(x5, stub->result());\n-  } else {\n-    _gp_regs -= RegSet::range(x18, x27) + RegSet::of(x2, x5) + RegSet::of(x8, x9);\n-  }\n+  \/\/ Remove C-ABI SOE registers and tmp regs\n+  _gp_regs -= RegSet::range(x18, x27) + RegSet::of(x2, x5) + RegSet::of(x8, x9);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-  __ call(target);\n+  __ rt_call(target);\n@@ -706,1 +706,1 @@\n-  __ call(target);\n+  __ rt_call(target);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+  product(bool, UseZvbb, false, EXPERIMENTAL, \"Use Zvbb instructions\")           \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-      __ jalr(x1, t0, offset);\n+      __ jalr(t0, offset);\n","filename":"src\/hotspot\/cpu\/riscv\/jniFastGetField_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-      jalr(x0, t0, offset);\n+      jr(t0, offset);\n@@ -644,1 +644,1 @@\n-  jalr(x0, t0, offset);\n+  jr(t0, offset);\n@@ -650,0 +650,1 @@\n+  int32_t offset = 0;\n@@ -651,1 +652,2 @@\n-  call(entry_point);\n+  mv(t0, entry_point, offset);\n+  jalr(t0, offset);\n@@ -719,7 +721,3 @@\n-  int64_t offset = addr - pc();\n-  if (is_valid_32bit_offset(offset)) {\n-    auipc(Rd, (int32_t)offset + 0x800);  \/\/0x800, Note:the 11th sign bit\n-    addi(Rd, Rd, ((int64_t)offset << 52) >> 52);\n-  } else {\n-    movptr(Rd, addr);\n-  }\n+  int32_t offset;\n+  la(Rd, addr, offset);\n+  addi(Rd, Rd, offset);\n@@ -729,13 +727,1 @@\n-  assert((uintptr_t)addr < (1ull << 48), \"bad address\");\n-\n-  unsigned long target_address = (uintptr_t)addr;\n-  unsigned long low_address = (uintptr_t)CodeCache::low_bound();\n-  unsigned long high_address = (uintptr_t)CodeCache::high_bound();\n-  long offset_low = target_address - low_address;\n-  long offset_high = target_address - high_address;\n-\n-  \/\/ RISC-V doesn't compute a page-aligned address, in order to partially\n-  \/\/ compensate for the use of *signed* offsets in its base+disp12\n-  \/\/ addressing mode (RISC-V's PC-relative reach remains asymmetric\n-  \/\/ [-(2G + 2K), 2G - 2K).\n-  if (offset_high >= -((1L << 31) + (1L << 11)) && offset_low < (1L << 31) - (1L << 11)) {\n+  if (is_32bit_offset_from_codecache((int64_t)addr)) {\n@@ -743,0 +729,1 @@\n+    assert(is_valid_32bit_offset(distance), \"Must be\");\n@@ -746,0 +733,1 @@\n+    assert(!CodeCache::contains(addr), \"Must be\");\n@@ -862,18 +850,12 @@\n-#define INSN(NAME, REGISTER)                                       \\\n-  void MacroAssembler::NAME(const address dest, Register temp) {   \\\n-    assert_cond(dest != nullptr);                                  \\\n-    int64_t distance = dest - pc();                                \\\n-    if (is_simm21(distance) && ((distance % 2) == 0)) {            \\\n-      Assembler::jal(REGISTER, distance);                          \\\n-    } else {                                                       \\\n-      assert(temp != noreg, \"expecting a register\");               \\\n-      int32_t offset = 0;                                          \\\n-      movptr(temp, dest, offset);                                  \\\n-      Assembler::jalr(REGISTER, temp, offset);                     \\\n-    }                                                              \\\n-  }                                                                \\\n-\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n-\n-#undef INSN\n+void MacroAssembler::jump_link(const address dest, Register temp) {\n+  assert_cond(dest != nullptr);\n+  int64_t distance = dest - pc();\n+  if (is_simm21(distance) && ((distance % 2) == 0)) {\n+    Assembler::jal(x1, distance);\n+  } else {\n+    assert(temp != noreg && temp != x0, \"expecting a register\");\n+    int32_t offset = 0;\n+    la(temp, dest, offset);\n+    jalr(temp, offset);\n+  }\n+}\n@@ -881,22 +863,18 @@\n-#define INSN(NAME, REGISTER)                                       \\\n-  void MacroAssembler::NAME(const Address &adr, Register temp) {   \\\n-    switch (adr.getMode()) {                                       \\\n-      case Address::literal: {                                     \\\n-        relocate(adr.rspec(), [&] {                                \\\n-          NAME(adr.target(), temp);                                \\\n-        });                                                        \\\n-        break;                                                     \\\n-      }                                                            \\\n-      case Address::base_plus_offset: {                            \\\n-        int32_t offset = ((int32_t)adr.offset() << 20) >> 20;      \\\n-        la(temp, Address(adr.base(), adr.offset() - offset));      \\\n-        Assembler::jalr(REGISTER, temp, offset);                   \\\n-        break;                                                     \\\n-      }                                                            \\\n-      default:                                                     \\\n-        ShouldNotReachHere();                                      \\\n-    }                                                              \\\n-  }\n-\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n+void MacroAssembler::jump_link(const Address &adr, Register temp) {\n+  switch (adr.getMode()) {\n+    case Address::literal: {\n+      relocate(adr.rspec(), [&] {\n+        jump_link(adr.target(), temp);\n+      });\n+      break;\n+    }\n+    case Address::base_plus_offset: {\n+      int32_t offset = ((int32_t)adr.offset() << 20) >> 20;\n+      la(temp, Address(adr.base(), adr.offset() - offset));\n+      jalr(temp, offset);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n@@ -904,1 +882,4 @@\n-#undef INSN\n+void MacroAssembler::j(const address dest, Register temp) {\n+  assert(CodeCache::contains(dest), \"Must be\");\n+  assert_cond(dest != nullptr);\n+  int64_t distance = dest - pc();\n@@ -906,16 +887,9 @@\n-#define INSN(NAME)                                                                    \\\n-  void MacroAssembler::NAME(Register Rd, const address dest, Register temp) {         \\\n-    assert_cond(dest != nullptr);                                                     \\\n-    int64_t distance = dest - pc();                                                   \\\n-    if (is_simm21(distance) && ((distance % 2) == 0)) {                               \\\n-      Assembler::NAME(Rd, distance);                                                  \\\n-    } else {                                                                          \\\n-      assert_different_registers(Rd, temp);                                           \\\n-      int32_t offset = 0;                                                             \\\n-      movptr(temp, dest, offset);                                                     \\\n-      jalr(Rd, temp, offset);                                                         \\\n-    }                                                                                 \\\n-  }                                                                                   \\\n-  void MacroAssembler::NAME(Register Rd, Label &L, Register temp) {                   \\\n-    assert_different_registers(Rd, temp);                                             \\\n-    wrap_label(Rd, L, temp, &MacroAssembler::NAME);                                   \\\n+  \/\/ We can't patch C, i.e. if Label wasn't bound we need to patch this jump.\n+  IncompressibleRegion ir(this);\n+  if (is_simm21(distance) && ((distance % 2) == 0)) {\n+    Assembler::jal(x0, distance);\n+  } else {\n+    assert(temp != noreg && temp != x0, \"expecting a register\");\n+    int32_t offset = 0;\n+    la(temp, dest, offset);\n+    jr(temp, offset);\n@@ -923,0 +897,1 @@\n+}\n@@ -924,1 +899,18 @@\n-  INSN(jal);\n+void MacroAssembler::j(const Address &adr, Register temp) {\n+  switch (adr.getMode()) {\n+    case Address::literal: {\n+      relocate(adr.rspec(), [&] {\n+        j(adr.target(), temp);\n+      });\n+      break;\n+    }\n+    case Address::base_plus_offset: {\n+      int32_t offset = ((int32_t)adr.offset() << 20) >> 20;\n+      la(temp, Address(adr.base(), adr.offset() - offset));\n+      jr(temp, offset);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n@@ -926,1 +918,9 @@\n-#undef INSN\n+void MacroAssembler::j(Label &lab, Register temp) {\n+  assert_different_registers(x0, temp);\n+  if (lab.is_bound()) {\n+    MacroAssembler::j(target(lab), temp);\n+  } else {\n+    lab.add_patch_at(code(), locator());\n+    MacroAssembler::j(pc(), temp);\n+  }\n+}\n@@ -928,4 +928,4 @@\n-#define INSN(NAME, REGISTER)                                       \\\n-  void MacroAssembler::NAME(Label &l, Register temp) {             \\\n-    jal(REGISTER, l, temp);                                        \\\n-  }                                                                \\\n+void MacroAssembler::jr(Register Rd, int32_t offset) {\n+  assert(Rd != noreg, \"expecting a register\");\n+  Assembler::jalr(x0, Rd, offset);\n+}\n@@ -933,2 +933,7 @@\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n+void MacroAssembler::call(const address dest, Register temp) {\n+  assert_cond(dest != nullptr);\n+  assert(temp != noreg, \"expecting a register\");\n+  int32_t offset = 0;\n+  la(temp, dest, offset);\n+  jalr(temp, offset);\n+}\n@@ -936,1 +941,4 @@\n-#undef INSN\n+void MacroAssembler::jalr(Register Rs, int32_t offset) {\n+  assert(Rs != noreg, \"expecting a register\");\n+  Assembler::jalr(x1, Rs, offset);\n+}\n@@ -938,3 +946,5 @@\n-void MacroAssembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L), tmp);\n+void MacroAssembler::rt_call(address dest, Register tmp) {\n+  CodeBlob *cb = CodeCache::find_blob(dest);\n+  RuntimeAddress target(dest);\n+  if (cb) {\n+    far_call(target, tmp);\n@@ -942,2 +952,5 @@\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc(), tmp);\n+    relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      la(tmp, target.target(), offset);\n+      jalr(tmp, offset);\n+    });\n@@ -2101,1 +2114,1 @@\n-    mv(dst, Address((address)obj, rspec));\n+    la(dst, Address((address)obj, rspec));\n@@ -2117,1 +2130,1 @@\n-  mv(dst, Address((address)obj, rspec));\n+  la(dst, Address((address)obj, rspec));\n@@ -3172,1 +3185,0 @@\n-  assert(ReservedCodeCacheSize < 4*G, \"branch out of range\");\n@@ -3182,1 +3194,1 @@\n-    jalr(x0, tmp, offset);\n+    jr(tmp, offset);\n@@ -3187,1 +3199,0 @@\n-  assert(ReservedCodeCacheSize < 4*G, \"branch out of range\");\n@@ -3197,3 +3208,2 @@\n-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n-    jalr(x1, tmp, offset); \/\/ link\n+    assert(is_valid_32bit_offset(entry.target() - pc()), \"Far call using wrong instructions.\");\n+    call(entry.target(), tmp);\n@@ -3347,5 +3357,1 @@\n-  mv(t1, (address)&SharedRuntime::_partial_subtype_ctr);\n-  Address pst_counter_addr(t1);\n-  ld(t0, pst_counter_addr);\n-  add(t0, t0, 1);\n-  sd(t0, pst_counter_addr);\n+  incrementw(ExternalAddress((address)&SharedRuntime::_partial_subtype_ctr));\n@@ -3459,1 +3465,1 @@\n-      jalr(x0, t0, offset);\n+      jr(t0, offset);\n@@ -3541,1 +3547,1 @@\n-    jal(target);\n+    jump_link(target, t0);\n@@ -4380,1 +4386,1 @@\n-      jal(zero_blocks);\n+      jump_link(zero_blocks, t0);\n@@ -5025,14 +5031,0 @@\n-void MacroAssembler::rt_call(address dest, Register tmp) {\n-  CodeBlob *cb = CodeCache::find_blob(dest);\n-  RuntimeAddress target(dest);\n-  if (cb) {\n-    far_call(target, tmp);\n-  } else {\n-    relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      movptr(tmp, target.target(), offset);\n-      jalr(x1, tmp, offset);\n-    });\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":116,"deletions":124,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -595,1 +595,12 @@\n-  void j(Label &l, Register temp = t0);\n+ private:\n+  void jump_link(const address dest, Register temp);\n+  void jump_link(const Address &adr, Register temp);\n+ public:\n+  \/\/ We try to follow risc-v asm menomics.\n+  \/\/ But as we don't layout a reachable GOT,\n+  \/\/ we often need to resort to movptr, li <48imm>.\n+  \/\/ https:\/\/github.com\/riscv-non-isa\/riscv-asm-manual\/blob\/master\/riscv-asm.md\n+\n+  \/\/ jump: jal x0, offset\n+  \/\/ For long reach uses temp register for:\n+  \/\/ la + jr\n@@ -598,5 +609,20 @@\n-  void jal(Label &l, Register temp = t0);\n-  void jal(const address dest, Register temp = t0);\n-  void jal(const Address &adr, Register temp = t0);\n-  void jal(Register Rd, Label &L, Register temp = t0);\n-  void jal(Register Rd, const address dest, Register temp = t0);\n+  void j(Label &l, Register temp = t0);\n+\n+  \/\/ jump register: jalr x0, offset(rs)\n+  void jr(Register Rd, int32_t offset = 0);\n+\n+  \/\/ call: la + jalr x1\n+  void call(const address dest, Register temp = t0);\n+\n+  \/\/ jalr: jalr x1, offset(rs)\n+  void jalr(Register Rs, int32_t offset = 0);\n+\n+  \/\/ Emit a runtime call. Only invalidates the tmp register which\n+  \/\/ is used to keep the entry address for jalr\/movptr.\n+  \/\/ Uses call() for intra code cache, else movptr + jalr.\n+  void rt_call(address dest, Register tmp = t0);\n+\n+  \/\/ ret: jalr x0, 0(x1)\n+  inline void ret() {\n+    Assembler::jalr(x0, x1, 0);\n+  }\n@@ -692,0 +718,8 @@\n+  \/\/ Ensure that the auipc can reach the destination at x from anywhere within\n+  \/\/ the code cache so that if it is relocated we know it will still reach.\n+  bool is_32bit_offset_from_codecache(int64_t x) {\n+    int64_t low  = (int64_t)CodeCache::low_bound();\n+    int64_t high = (int64_t)CodeCache::high_bound();\n+    return is_valid_32bit_offset(x - low) && is_valid_32bit_offset(x - high);\n+  }\n+\n@@ -736,1 +770,0 @@\n-  typedef void (MacroAssembler::* load_insn_by_temp)(Register Rt, address dest, Register temp);\n@@ -738,1 +771,0 @@\n-  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n@@ -744,0 +776,1 @@\n+  \/\/ la will use movptr instead of GOT when not in reach for auipc.\n@@ -766,7 +799,0 @@\n-  void mv(Register Rd, Address dest) {\n-    assert(dest.getMode() == Address::literal, \"Address mode should be Address::literal\");\n-    relocate(dest.rspec(), [&] {\n-      movptr(Rd, dest.target());\n-    });\n-  }\n-\n@@ -1479,15 +1505,0 @@\n-  \/\/ Emit a runtime call. Only invalidates the tmp register which\n-  \/\/ is used to keep the entry address for jalr\/movptr.\n-  void rt_call(address dest, Register tmp = t0);\n-\n-  void call(const address dest, Register temp = t0) {\n-    assert_cond(dest != nullptr);\n-    assert(temp != noreg, \"expecting a register\");\n-    int32_t offset = 0;\n-    mv(temp, dest, offset);\n-    jalr(x1, temp, offset);\n-  }\n-\n-  inline void ret() {\n-    jalr(x0, x1, 0);\n-  }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":41,"deletions":30,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-  static constexpr bool supports_vector_variable_shifts(void) {\n-    return false;\n+  static bool supports_vector_variable_shifts(void) {\n+    return UseRVV;\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-  a.jalr(x0, t0, offset); \/\/ jalr\n+  a.jr(t0, offset); \/\/ jalr\n@@ -413,1 +413,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -652,0 +652,1 @@\n+\/\/ Class for all non-special integer registers\n@@ -656,0 +657,1 @@\n+\/\/ Class for all non-special long integer registers\n@@ -664,0 +666,1 @@\n+\/\/ Class for all non_special pointer registers\n@@ -668,0 +671,5 @@\n+\/\/ Class for all non_special pointer registers (excluding fp)\n+reg_class no_special_no_fp_ptr_reg %{\n+  return _NO_SPECIAL_NO_FP_PTR_REG_mask;\n+%}\n+\n@@ -1040,0 +1048,1 @@\n+extern RegMask _NO_SPECIAL_NO_FP_PTR_REG_mask;\n@@ -1102,0 +1111,1 @@\n+RegMask _NO_SPECIAL_NO_FP_PTR_REG_mask;\n@@ -1136,0 +1146,3 @@\n+\n+  _NO_SPECIAL_NO_FP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n+  _NO_SPECIAL_NO_FP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n@@ -2140,0 +2153,31 @@\n+\/\/ Binary src (Replicate scalar\/immediate)\n+static bool is_vector_scalar_bitwise_pattern(Node* n, Node* m) {\n+  if (n == nullptr || m == nullptr) {\n+    return false;\n+  }\n+\n+  if (m->Opcode() != Op_Replicate) {\n+    return false;\n+  }\n+\n+  switch (n->Opcode()) {\n+    case Op_AndV:\n+    case Op_OrV:\n+    case Op_XorV: {\n+      return true;\n+    }\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/\/ (XorV src (Replicate m1))\n+\/\/ (XorVMask src (MaskAll m1))\n+static bool is_vector_bitwise_not_pattern(Node* n, Node* m) {\n+  if (n != nullptr && m != nullptr) {\n+    return (n->Opcode() == Op_XorV || n->Opcode() == Op_XorVMask) &&\n+           VectorNode::is_all_ones_vector(m);\n+  }\n+  return false;\n+}\n+\n@@ -2143,2 +2187,4 @@\n-  if (is_vshift_con_pattern(n, m)) { \/\/ ShiftV src (ShiftCntV con)\n-    mstack.push(m, Visit);           \/\/ m = ShiftCntV\n+  if (is_vshift_con_pattern(n, m) || \/\/ ShiftV src (ShiftCntV con)\n+      is_vector_bitwise_not_pattern(n, m) ||\n+      is_vector_scalar_bitwise_pattern(n, m)) {\n+    mstack.push(m, Visit);\n@@ -3178,0 +3224,12 @@\n+\/\/ This operand is not allowed to use fp even if\n+\/\/ fp is not used to hold the frame pointer.\n+operand iRegPNoSpNoFp()\n+%{\n+  constraint(ALLOC_IN_RC(no_special_no_fp_ptr_reg));\n+  match(RegP);\n+  match(iRegPNoSp);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -10509,1 +10567,3 @@\n-instruct TailCalljmpInd(iRegPNoSp jump_target, inline_cache_RegP method_oop)\n+\/\/ Don't use fp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset fp to the caller state.\n+instruct TailCalljmpInd(iRegPNoSpNoFp jump_target, inline_cache_RegP method_oop)\n@@ -10522,1 +10582,1 @@\n-instruct TailjmpInd(iRegPNoSp jump_target, iRegP_R10 ex_oop)\n+instruct TailjmpInd(iRegPNoSpNoFp jump_target, iRegP_R10 ex_oop)\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":64,"deletions":4,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -76,0 +76,6 @@\n+      case Op_CountTrailingZerosV:\n+      case Op_CountLeadingZerosV:\n+      case Op_ReverseBytesV:\n+      case Op_PopCountVL:\n+      case Op_PopCountVI:\n+        return UseZvbb;\n@@ -480,0 +486,124 @@\n+\/\/ vector-immediate and (unpredicated)\n+\n+instruct vand_immI(vReg dst_src, immI5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (AndV dst_src (Replicate con)));\n+  format %{ \"vand_immI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vand_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_immL(vReg dst_src, immL5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (AndV dst_src (Replicate con)));\n+  format %{ \"vand_immL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vand_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-scalar and (unpredicated)\n+\n+instruct vand_regI(vReg dst_src, iRegIorL2I src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (AndV dst_src (Replicate src)));\n+  format %{ \"vand_regI $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vand_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_regL(vReg dst_src, iRegL src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (AndV dst_src (Replicate src)));\n+  format %{ \"vand_regL $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vand_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-immediate and (predicated)\n+\n+instruct vand_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (AndV (Binary dst_src (Replicate con)) v0));\n+  format %{ \"vand_immI_masked $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vand_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_immL_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (AndV (Binary dst_src (Replicate con)) v0));\n+  format %{ \"vand_immL_masked $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vand_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-scalar and (predicated)\n+\n+instruct vand_regI_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (AndV (Binary dst_src (Replicate src)) v0));\n+  format %{ \"vand_regI_masked $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vand_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_regL_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (AndV (Binary dst_src (Replicate src)) v0));\n+  format %{ \"vand_regL_masked $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vand_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -512,0 +642,124 @@\n+\/\/ vector-immediate or (unpredicated)\n+\n+instruct vor_immI(vReg dst_src, immI5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (OrV dst_src (Replicate con)));\n+  format %{ \"vor_immI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vor_vi(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vor_immL(vReg dst_src, immL5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (OrV dst_src (Replicate con)));\n+  format %{ \"vor_immL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vor_vi(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-scalar or (unpredicated)\n+\n+instruct vor_regI(vReg dst_src, iRegIorL2I src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (OrV dst_src (Replicate src)));\n+  format %{ \"vor_regI $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vor_vx(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vor_regL(vReg dst_src, iRegL src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (OrV dst_src (Replicate src)));\n+  format %{ \"vor_regL $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vor_vx(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-immediate or (predicated)\n+\n+instruct vor_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (OrV (Binary dst_src (Replicate con)) v0));\n+  format %{ \"vor_immI_masked $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vor_vi(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              $con$$constant, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vor_immL_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (OrV (Binary dst_src (Replicate con)) v0));\n+  format %{ \"vor_immL_masked $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vor_vi(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              $con$$constant, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-scalar or (predicated)\n+\n+instruct vor_regI_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (OrV (Binary dst_src (Replicate src)) v0));\n+  format %{ \"vor_regI_masked $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vor_vx(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              as_Register($src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vor_regL_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (OrV (Binary dst_src (Replicate src)) v0));\n+  format %{ \"vor_regL_masked $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vor_vx(as_VectorRegister($dst_src$$reg),\n+              as_VectorRegister($dst_src$$reg),\n+              as_Register($src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -544,0 +798,188 @@\n+\/\/ vector-immediate xor (unpredicated)\n+\n+instruct vxor_immI(vReg dst_src, immI5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (XorV dst_src (Replicate con)));\n+  format %{ \"vxor_immI $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxor_immL(vReg dst_src, immL5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (XorV dst_src (Replicate con)));\n+  format %{ \"vxor_immL $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-scalar xor (unpredicated)\n+\n+instruct vxor_regI(vReg dst_src, iRegIorL2I src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (XorV dst_src (Replicate src)));\n+  format %{ \"vxor_regI $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxor_regL(vReg dst_src, iRegL src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (XorV dst_src (Replicate src)));\n+  format %{ \"vxor_regL $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vxor_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-immediate xor (predicated)\n+\n+instruct vxor_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (XorV (Binary dst_src (Replicate con)) v0));\n+  format %{ \"vxor_immI_masked $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxor_immL_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (XorV (Binary dst_src (Replicate con)) v0));\n+  format %{ \"vxor_immL_masked $dst_src, $dst_src, $con\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               $con$$constant, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector-scalar xor (predicated)\n+\n+instruct vxor_regI_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (XorV (Binary dst_src (Replicate src)) v0));\n+  format %{ \"vxor_regI_masked $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxor_regL_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (XorV (Binary dst_src (Replicate src)) v0));\n+  format %{ \"vxor_regL_masked $dst_src, $dst_src, $src\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vxor_vx(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               as_Register($src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector not -----------------------------------\n+\n+\/\/ vector not\n+\n+instruct vnotI(vReg dst, vReg src, immI_M1 m1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (XorV src (Replicate m1)));\n+  format %{ \"vnotI $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src$$reg),\n+               -1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL(vReg dst, vReg src, immL_M1 m1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (XorV src (Replicate m1)));\n+  format %{ \"vnotL $dst, $src\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src$$reg),\n+               -1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector not - predicated\n+\n+instruct vnotI_masked(vReg dst_src, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src (XorV (Binary dst_src (Replicate m1)) v0));\n+  format %{ \"vnotI_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               -1, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnotL_masked(vReg dst_src, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src (XorV (Binary dst_src (Replicate m1)) v0));\n+  format %{ \"vnotL_masked $dst_src, $dst_src, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n+               as_VectorRegister($dst_src$$reg),\n+               -1, Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1779,0 +2221,26 @@\n+\/\/\n+\/\/ Following shift instruct's are shared by vectorization (in SLP, superword.cpp) and Vector API.\n+\/\/\n+\/\/ Shift behaviour in vectorization is defined by java language spec, which includes:\n+\/\/  1. \"If the promoted type of the left-hand operand is int, then only the five lowest-order bits of\n+\/\/      the right-hand operand are used as the shift distance. It is as if the right-hand operand were\n+\/\/      subjected to a bitwise logical AND operator & (§15.22.1) with the mask value 0x1f (0b11111).\n+\/\/      The shift distance actually used is therefore always in the range 0 to 31, inclusive.\"\n+\/\/  2. similarly, for long \"with the mask value 0x3f (0b111111)\"\n+\/\/ check https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/jls-15.html#jls-15.19 for details.\n+\/\/\n+\/\/ Shift behaviour in Vector API is defined as:\n+\/\/   e.g. for ASHR, \"a>>(n&(ESIZE*8-1))\"\n+\/\/   this behaviour is the same as shift instrunction's in riscv vector extension.\n+\/\/ check https:\/\/docs.oracle.com\/en\/java\/javase\/21\/docs\/api\/jdk.incubator.vector\/jdk\/incubator\/vector\/VectorOperators.html#ASHR\n+\/\/ and https:\/\/github.com\/riscv\/riscv-v-spec\/blob\/master\/v-spec.adoc#116-vector-single-width-shift-instructions for details.\n+\/\/\n+\/\/ Despite the difference between these 2 behaviours, the same shift instruct's of byte and short are\n+\/\/ still shared between vectorization and Vector API. The way it works is hidden inside the implementation\n+\/\/ of vectorization and Vector API:\n+\/\/  1. when doing optimization vectorization masks the shift value with \"(BitsPerInt - 1)\" or \"(BitsPerLong - 1)\"\n+\/\/  2. in Vector API, shift value is masked with SHIFT_MASK (e.g. for ByteVector it's \"Byte.SIZE - 1\")\n+\/\/\n+\/\/ If not because of this pre-processing of shift value respectively in vectorization and Vector API, then\n+\/\/ e.g. for a byte shift value 16, the intrinsic behaviour will be different, and they can not share the same\n+\/\/ instruct here, as vectorization requires x >> 16, but Vector API requires x >> (16 & 7).\n@@ -3756,0 +4224,26 @@\n+\/\/ -------------------------------- Reverse Bytes Vector Operations ------------------------\n+\n+instruct vreverse_bytes_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (ReverseBytesV dst_src v0));\n+  format %{ \"vreverse_bytes_masked $dst_src, $dst_src, v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vrev8_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreverse_bytes(vReg dst, vReg src) %{\n+  match(Set dst (ReverseBytesV src));\n+  format %{ \"vreverse_bytes $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vrev8_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3787,0 +4281,87 @@\n+\n+\/\/ ------------------------------ Popcount vector ------------------------------\n+\n+instruct vpopcount_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (PopCountVI dst_src v0));\n+  match(Set dst_src (PopCountVL dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcpop_v $dst_src, $dst_src, $v0\\t# vcpop_v with mask\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vcpop_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcount(vReg dst, vReg src) %{\n+  match(Set dst (PopCountVI src));\n+  match(Set dst (PopCountVL src));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcpop_v $dst, $src\\t# vcpop_v without mask\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vcpop_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountLeadingZerosV --------------------------\n+\n+instruct vcountLeadingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (CountLeadingZerosV dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_leading_zeros_masked $dst_src, $dst_src, v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vclz_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_leading_zeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vclz_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountTrailingZerosV --------------------------\n+\n+instruct vcountTrailingZeros_masked(vReg dst_src, vRegMask_V0 v0) %{\n+  match(Set dst_src (CountTrailingZerosV dst_src v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_trailing_zeros_masked $dst_src, $dst_src, v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vctz_v(as_VectorRegister($dst_src$$reg), as_VectorRegister($dst_src$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(VEC_COST);\n+  format %{ \"vcount_trailing_zeros $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vlen = Matcher::vector_length(this);\n+    __ vsetvli_helper(bt, vlen);\n+    __ vctz_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":581,"deletions":0,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -80,4 +80,1 @@\n-    __ la(t1, ExternalAddress((address)&counter));\n-    __ lwu(t0, Address(t1, 0));\n-    __ addiw(t0, t0, 1);\n-    __ sw(t0, Address(t1, 0));\n+    __ incrementw(ExternalAddress((address)&counter));\n@@ -658,1 +655,1 @@\n-    __ call(CAST_FROM_FN_PTR(address, MacroAssembler::debug64));\n+    __ rt_call(CAST_FROM_FN_PTR(address, MacroAssembler::debug64));\n@@ -5456,1 +5453,1 @@\n-    __ call(runtime_entry);\n+    __ rt_call(runtime_entry);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1209,1 +1209,1 @@\n-    __ call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n+    __ rt_call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n@@ -1258,1 +1258,1 @@\n-    __ call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n@@ -1818,1 +1818,1 @@\n-  __ jal(Interpreter::trace_code(t->tos_in()));\n+  __ call(Interpreter::trace_code(t->tos_in()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,0 +248,6 @@\n+  \/\/ UseZvbb (depends on RVV).\n+  if (UseZvbb && !UseRVV) {\n+    FLAG_SET_DEFAULT(UseZvbb, false);\n+    warning(\"Cannot enable UseZvbb on cpu without RVV support.\");\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  decl(ext_Zvbb        , \"Zvbb\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZvbb))        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,4 +355,0 @@\n-\n-  RelocationHolder rspec(int offset) const {\n-    return offset == 0 ? _rspec : _rspec.plus(offset);\n-  }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2277,1 +2277,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n@@ -2388,1 +2390,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -713,1 +713,7 @@\n-  CodeEmitInfo* info = state_for (x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -738,0 +744,3 @@\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n@@ -772,1 +781,7 @@\n-  CodeEmitInfo* info = state_for (x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -789,1 +804,2 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type,\n+                    klass_reg, slow_path, x->zero_array());\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -194,1 +194,0 @@\n-  Label done;\n@@ -206,1 +205,0 @@\n-  bind(done);\n@@ -277,1 +275,2 @@\n-  Label&   slow_case                   \/\/ Continuation point if fast allocation fails.\n+  Label&   slow_case,                  \/\/ Continuation point if fast allocation fails.\n+  bool     zero_array                  \/\/ zero the allocated array or not\n@@ -308,9 +307,11 @@\n-  Label done;\n-  Register object_fields = t1;\n-  Register Rzero = Z_R1_scratch;\n-  z_aghi(arr_size, -base_offset_in_bytes);\n-  z_bre(done); \/\/ Jump if size of fields is zero.\n-  z_la(object_fields, base_offset_in_bytes, obj);\n-  z_xgr(Rzero, Rzero);\n-  initialize_body(object_fields, arr_size, Rzero);\n-  bind(done);\n+  if (zero_array) {\n+    Label done;\n+    Register object_fields = t1;\n+    Register Rzero = Z_R1_scratch;\n+    z_aghi(arr_size, -base_offset_in_bytes);\n+    z_bre(done); \/\/ Jump if size of fields is zero.\n+    z_la(object_fields, base_offset_in_bytes, obj);\n+    z_xgr(Rzero, Rzero);\n+    initialize_body(object_fields, arr_size, Rzero);\n+    bind(done);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -92,1 +92,2 @@\n-    Label&   slow_case                 \/\/ Continuation point if fast allocation fails.\n+    Label&   slow_case,                \/\/ Continuation point if fast allocation fails.\n+    bool     zero_array                \/\/ zero the allocated array or not\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n-  \/\/ we don't support splitting of relocations, so o must be zero:\n-  assert(o == 0, \"tried to split relocations\");\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -39,1 +37,1 @@\n-        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_data_plain(((intptr_t)x), code());\n@@ -43,1 +41,1 @@\n-          nativeMovConstReg_at(addr())->set_narrow_klass(((intptr_t)x) + o);\n+          nativeMovConstReg_at(addr())->set_narrow_klass(((intptr_t)x));\n@@ -45,1 +43,1 @@\n-          nativeMovConstReg_at(addr())->set_narrow_oop(((intptr_t)x) + o);\n+          nativeMovConstReg_at(addr())->set_narrow_oop(((intptr_t)x));\n@@ -50,1 +48,1 @@\n-        nativeMovConstReg_at(addr())->set_pcrel_addr(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_pcrel_addr(((intptr_t)x), code());\n@@ -53,1 +51,1 @@\n-        nativeMovConstReg_at(addr())->set_pcrel_data(((intptr_t)x) + o, code());\n+        nativeMovConstReg_at(addr())->set_pcrel_data(((intptr_t)x), code());\n","filename":"src\/hotspot\/cpu\/s390\/relocInfo_s390.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1661,1 +1661,2 @@\n-                      *op->stub()->entry());\n+                      *op->stub()->entry(),\n+                      op->zero_array());\n@@ -3639,1 +3640,3 @@\n-  __ bind(*stub->continuation());\n+  if (stub != nullptr) {\n+    __ bind(*stub->continuation());\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1032,1 +1032,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1044,0 +1050,7 @@\n+  int flags;\n+  ciArrayKlass* expected_type;\n+  arraycopy_helper(x, &flags, &expected_type);\n+  if (x->check_flag(Instruction::OmitChecksFlag)) {\n+    flags = 0;\n+  }\n+\n@@ -1051,0 +1064,5 @@\n+\n+  if (expected_type != nullptr && flags == 0) {\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(3 * BytesPerWord);\n+  }\n@@ -1072,4 +1090,0 @@\n-  int flags;\n-  ciArrayKlass* expected_type;\n-  arraycopy_helper(x, &flags, &expected_type);\n-\n@@ -1338,1 +1352,7 @@\n-  CodeEmitInfo* info = state_for(x, x->state());\n+  CodeEmitInfo* info = nullptr;\n+  if (x->state_before() != nullptr && x->state_before()->force_reexecute()) {\n+    info = state_for(x, x->state_before());\n+    info->set_force_reexecute();\n+  } else {\n+    info = state_for(x, x->state());\n+  }\n@@ -1355,1 +1375,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, x->zero_array());\n@@ -1389,1 +1409,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, true, x->is_null_free());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array) {\n@@ -316,5 +316,7 @@\n-  const Register len_zero = len;\n-  \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n-  \/\/ following the length field in initialize_header().\n-  int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n-  initialize_body(obj, arr_size, base_offset, len_zero);\n+  if (zero_array) {\n+    const Register len_zero = len;\n+    \/\/ Align-up to word boundary, because we clear the 4 bytes potentially\n+    \/\/ following the length field in initialize_header().\n+    int base_offset = align_up(base_offset_in_bytes, BytesPerWord);\n+    initialize_body(obj, arr_size, base_offset, len_zero);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case);\n+  \/\/ zero_array          : zero the allocated array or not\n+  void allocate_array(Register obj, Register len, Register t, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case, bool zero_array);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -631,7 +631,0 @@\n-  if (stub->result() != noreg) {\n-    caller_saved.Remove(OptoReg::as_OptoReg(stub->result()->as_VMReg()));\n-  }\n-\n-  \/\/ Create mask of live registers\n-  RegMask live = stub->live();\n-\n@@ -643,1 +636,1 @@\n-  RegMaskIterator rmi(live);\n+  RegMaskIterator rmi(stub->preserve_set());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1216,1 +1216,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n@@ -1236,1 +1235,0 @@\n-  Assembler::InlineSkippedInstructionsCounter skipped_counter(masm);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1610,0 +1610,2 @@\n+\n+  using Assembler::evpsrlq;\n@@ -1631,0 +1633,1 @@\n+  using Assembler::evpsraq;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n@@ -41,1 +41,0 @@\n-  x += o;\n@@ -83,1 +82,1 @@\n-    guarantee(*pd_address_in_code() == (x + o), \"instructions must match\");\n+    guarantee(*pd_address_in_code() == x, \"instructions must match\");\n@@ -85,1 +84,1 @@\n-    *pd_address_in_code() = x + o;\n+    *pd_address_in_code() = x;\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4428,0 +4428,5 @@\n+  if (UseIntPolyIntrinsics) {\n+    StubRoutines::_intpoly_montgomeryMult_P256 = generate_intpoly_montgomeryMult_P256();\n+    StubRoutines::_intpoly_assign = generate_intpoly_assign();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -486,0 +486,3 @@\n+  address generate_intpoly_montgomeryMult_P256();\n+  address generate_intpoly_assign();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_x86.hpp\"\n+#include \"stubGenerator_x86_64.hpp\"\n+\n+#define __ _masm->\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t MODULUS_P256[] = {\n+  0x000fffffffffffffULL, 0x00000fffffffffffULL,\n+  0x0000000000000000ULL, 0x0000001000000000ULL,\n+  0x0000ffffffff0000ULL, 0x0000000000000000ULL,\n+  0x0000000000000000ULL, 0x0000000000000000ULL\n+};\n+static address modulus_p256() {\n+  return (address)MODULUS_P256;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t P256_MASK52[] = {\n+  0x000fffffffffffffULL, 0x000fffffffffffffULL,\n+  0x000fffffffffffffULL, 0x000fffffffffffffULL,\n+  0xffffffffffffffffULL, 0xffffffffffffffffULL,\n+  0xffffffffffffffffULL, 0xffffffffffffffffULL,\n+};\n+static address p256_mask52() {\n+  return (address)P256_MASK52;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t SHIFT1R[] = {\n+  0x0000000000000001ULL, 0x0000000000000002ULL,\n+  0x0000000000000003ULL, 0x0000000000000004ULL,\n+  0x0000000000000005ULL, 0x0000000000000006ULL,\n+  0x0000000000000007ULL, 0x0000000000000000ULL,\n+};\n+static address shift_1R() {\n+  return (address)SHIFT1R;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t SHIFT1L[] = {\n+  0x0000000000000007ULL, 0x0000000000000000ULL,\n+  0x0000000000000001ULL, 0x0000000000000002ULL,\n+  0x0000000000000003ULL, 0x0000000000000004ULL,\n+  0x0000000000000005ULL, 0x0000000000000006ULL,\n+};\n+static address shift_1L() {\n+  return (address)SHIFT1L;\n+}\n+\n+\/**\n+ * Unrolled Word-by-Word Montgomery Multiplication\n+ * r = a * b * 2^-260 (mod P)\n+ *\n+ * Reference [1]: Shay Gueron and Vlad Krasnov\n+ *    \"Fast Prime Field Elliptic Curve Cryptography with 256 Bit Primes\"\n+ *    See Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication for a Montgomery\n+ *    Friendly modulus p\". Note: Step 6. Skipped; Instead use numAdds to reuse existing overflow\n+ *    logic.\n+ *\n+ * Pseudocode:\n+ *\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   M = load(*modulus_p256)                           | 0| 0| 0|m5|m4|m3|m2|m1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   A = load(*aLimbs)                                 | 0| 0| 0|a5|a4|a3|a2|a1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *   Acc1 = 0                                          | 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *      ---- for i = 0 to 4\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc2 = 0                                   | 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          B = replicate(bLimbs[i])                   |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc1+=| 0| 0| 0|c5|c4|c3|c2|c1|\n+ *                                                    *| 0| 0| 0|a5|a4|a3|a2|a1|\n+ *          Acc1 += A *  B                             |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc2+=| 0| 0| 0| 0| 0| 0| 0| 0|\n+ *                                                   *h| 0| 0| 0|a5|a4|a3|a2|a1|\n+ *          Acc2 += A *h B                             |bi|bi|bi|bi|bi|bi|bi|bi|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          N = replicate(Acc1[0])                     |n0|n0|n0|n0|n0|n0|n0|n0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc1+=| 0| 0| 0|c5|c4|c3|c2|c1|\n+ *                                                    *| 0| 0| 0|m5|m4|m3|m2|m1|\n+ *          Acc1 += M *  N                             |n0|n0|n0|n0|n0|n0|n0|n0| Note: 52 low bits of Acc1[0] == 0 due to Montgomery!\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *                                               Acc2+=| 0| 0| 0|d5|d4|d3|d2|d1|\n+ *                                                   *h| 0| 0| 0|m5|m4|m3|m2|m1|\n+ *          Acc2 += M *h N                             |n0|n0|n0|n0|n0|n0|n0|n0|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          if (i == 4) break;\n+ *          \/\/ Combine high\/low partial sums Acc1 + Acc2\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          carry = Acc1[0] >> 52                      | 0| 0| 0| 0| 0| 0| 0|c1|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc2[0] += carry\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc1 = Acc1 shift one q element>>          | 0| 0| 0| 0|c5|c4|c3|c2|\n+ *                                                     +--+--+--+--+--+--+--+--+\n+ *          Acc1 = Acc1 + Acc2\n+ *      ---- done\n+ *   \/\/ Last Carry round: Combine high\/low partial sums Acc1<high_bits> + Acc1 + Acc2\n+ *   carry = Acc1 >> 52\n+ *   Acc1 = Acc1 shift one q element >>\n+ *   Acc1  = mask52(Acc1)\n+ *   Acc2  += carry\n+ *   Acc1 = Acc1 + Acc2\n+ *   output to rLimbs\n+ *\/\n+void montgomeryMultiply(const Register aLimbs, const Register bLimbs, const Register rLimbs, const Register tmp, MacroAssembler* _masm) {\n+  Register t0 = tmp;\n+  Register rscratch = tmp;\n+\n+  \/\/ Inputs\n+  XMMRegister A = xmm0;\n+  XMMRegister B = xmm1;\n+  XMMRegister T = xmm2;\n+\n+  \/\/ Intermediates\n+  XMMRegister Acc1 = xmm10;\n+  XMMRegister Acc2 = xmm11;\n+  XMMRegister N    = xmm12;\n+  XMMRegister carry = xmm13;\n+\n+  \/\/ \/\/ Constants\n+  XMMRegister modulus = xmm20;\n+  XMMRegister shift1L = xmm21;\n+  XMMRegister shift1R = xmm22;\n+  XMMRegister mask52  = xmm23;\n+  KRegister limb0    = k1;\n+  KRegister allLimbs = k2;\n+\n+  __ mov64(t0, 0x1);\n+  __ kmovql(limb0, t0);\n+  __ mov64(t0, 0x1f);\n+  __ kmovql(allLimbs, t0);\n+  __ evmovdquq(shift1L, allLimbs, ExternalAddress(shift_1L()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(shift1R, allLimbs, ExternalAddress(shift_1R()), false, Assembler::AVX_512bit, rscratch);\n+  __ evmovdquq(mask52, allLimbs, ExternalAddress(p256_mask52()), false, Assembler::AVX_512bit, rscratch);\n+\n+  \/\/ M = load(*modulus_p256)\n+  __ evmovdquq(modulus, allLimbs, ExternalAddress(modulus_p256()), false, Assembler::AVX_512bit, rscratch);\n+\n+  \/\/ A = load(*aLimbs);  masked evmovdquq() can be slow. Instead load full 256bit, and compbine with 64bit\n+  __ evmovdquq(A, Address(aLimbs, 8), Assembler::AVX_256bit);\n+  __ evpermq(A, allLimbs, shift1L, A, false, Assembler::AVX_512bit);\n+  __ movq(T, Address(aLimbs, 0));\n+  __ evporq(A, A, T, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = 0\n+  __ vpxorq(Acc1, Acc1, Acc1, Assembler::AVX_512bit);\n+  for (int i = 0; i< 5; i++) {\n+      \/\/ Acc2 = 0\n+      __ vpxorq(Acc2, Acc2, Acc2, Assembler::AVX_512bit);\n+\n+      \/\/ B = replicate(bLimbs[i])\n+      __ vpbroadcastq(B, Address(bLimbs, i*8), Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 += A * B\n+      __ evpmadd52luq(Acc1, A, B, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2 += A *h B\n+      __ evpmadd52huq(Acc2, A, B, Assembler::AVX_512bit);\n+\n+      \/\/ N = replicate(Acc1[0])\n+      __ vpbroadcastq(N, Acc1, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 += M *  N\n+      __ evpmadd52luq(Acc1, modulus, N, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2 += M *h N\n+      __ evpmadd52huq(Acc2, modulus, N, Assembler::AVX_512bit);\n+\n+      if (i == 4) break;\n+\n+      \/\/ Combine high\/low partial sums Acc1 + Acc2\n+\n+      \/\/ carry = Acc1[0] >> 52\n+      __ evpsrlq(carry, limb0, Acc1, 52, true, Assembler::AVX_512bit);\n+\n+      \/\/ Acc2[0] += carry\n+      __ evpaddq(Acc2, limb0, carry, Acc2, true, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 = Acc1 shift one q element >>\n+      __ evpermq(Acc1, allLimbs, shift1R, Acc1, false, Assembler::AVX_512bit);\n+\n+      \/\/ Acc1 = Acc1 + Acc2\n+      __ vpaddq(Acc1, Acc1, Acc2, Assembler::AVX_512bit);\n+  }\n+\n+  \/\/ Last Carry round: Combine high\/low partial sums Acc1<high_bits> + Acc1 + Acc2\n+  \/\/ carry = Acc1 >> 52\n+  __ evpsrlq(carry, allLimbs, Acc1, 52, true, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = Acc1 shift one q element >>\n+  __ evpermq(Acc1, allLimbs, shift1R, Acc1, false, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1  = mask52(Acc1)\n+  __ evpandq(Acc1, Acc1, mask52, Assembler::AVX_512bit); \/\/ Clear top 12 bits\n+\n+  \/\/ Acc2 += carry\n+  __ evpaddq(Acc2, allLimbs, carry, Acc2, true, Assembler::AVX_512bit);\n+\n+  \/\/ Acc1 = Acc1 + Acc2\n+  __ vpaddq(Acc1, Acc1, Acc2, Assembler::AVX_512bit);\n+\n+  \/\/ output to rLimbs (1 + 4 limbs)\n+  __ movq(Address(rLimbs, 0), Acc1);\n+  __ evpermq(Acc1, k0, shift1R, Acc1, true, Assembler::AVX_512bit);\n+  __ evmovdquq(Address(rLimbs, 8), k0, Acc1, true, Assembler::AVX_256bit);\n+}\n+\n+address StubGenerator::generate_intpoly_montgomeryMult_P256() {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_montgomeryMult_P256\");\n+  address start = __ pc();\n+  __ enter();\n+\n+  \/\/ Register Map\n+  const Register aLimbs  = c_rarg0; \/\/ rdi | rcx\n+  const Register bLimbs  = c_rarg1; \/\/ rsi | rdx\n+  const Register rLimbs  = c_rarg2; \/\/ rdx | r8\n+  const Register tmp     = r9;\n+\n+  montgomeryMultiply(aLimbs, bLimbs, rLimbs, tmp, _masm);\n+  __ mov64(rax, 0x1); \/\/ Return 1 (Fig. 5, Step 6 [1] skipped in montgomeryMultiply)\n+\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n+\n+\/\/ A = B if select\n+\/\/ Must be:\n+\/\/  - constant time (i.e. no branches)\n+\/\/  - no-side channel (i.e. all memory must always be accessed, and in same order)\n+void assign_avx(XMMRegister A, Address aAddr, XMMRegister B, Address bAddr, KRegister select, int vector_len, MacroAssembler* _masm) {\n+  __ evmovdquq(A, aAddr, vector_len);\n+  __ evmovdquq(B, bAddr, vector_len);\n+  __ evmovdquq(A, select, B, true, vector_len);\n+  __ evmovdquq(aAddr, A, vector_len);\n+}\n+\n+void assign_scalar(Address aAddr, Address bAddr, Register select, Register tmp, MacroAssembler* _masm) {\n+  \/\/ Original java:\n+  \/\/ long dummyLimbs = maskValue & (a[i] ^ b[i]);\n+  \/\/ a[i] = dummyLimbs ^ a[i];\n+\n+  __ movq(tmp, aAddr);\n+  __ xorq(tmp, bAddr);\n+  __ andq(tmp, select);\n+  __ xorq(aAddr, tmp);\n+}\n+\n+address StubGenerator::generate_intpoly_assign() {\n+  \/\/ KNOWN Lengths:\n+  \/\/   MontgomeryIntPolynP256:  5 = 4 + 1\n+  \/\/   IntegerPolynomial1305:   5 = 4 + 1\n+  \/\/   IntegerPolynomial25519: 10 = 8 + 2\n+  \/\/   IntegerPolynomialP256:  10 = 8 + 2\n+  \/\/   Curve25519OrderField:   10 = 8 + 2\n+  \/\/   Curve25519OrderField:   10 = 8 + 2\n+  \/\/   P256OrderField:         10 = 8 + 2\n+  \/\/   IntegerPolynomialP384:  14 = 8 + 4 + 2\n+  \/\/   P384OrderField:         14 = 8 + 4 + 2\n+  \/\/   IntegerPolynomial448:   16 = 8 + 8\n+  \/\/   Curve448OrderField:     16 = 8 + 8\n+  \/\/   Curve448OrderField:     16 = 8 + 8\n+  \/\/   IntegerPolynomialP521:  19 = 8 + 8 + 2 + 1\n+  \/\/   P521OrderField:         19 = 8 + 8 + 2 + 1\n+  \/\/ Special Cases 5, 10, 14, 16, 19\n+\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", \"intpoly_assign\");\n+  address start = __ pc();\n+  __ enter();\n+\n+  \/\/ Inputs\n+  const Register set     = c_rarg0;\n+  const Register aLimbs  = c_rarg1;\n+  const Register bLimbs  = c_rarg2;\n+  const Register length  = c_rarg3;\n+  XMMRegister A = xmm0;\n+  XMMRegister B = xmm1;\n+\n+  Register tmp = r9;\n+  KRegister select = k1;\n+  Label L_Length5, L_Length10, L_Length14, L_Length16, L_Length19, L_DefaultLoop, L_Done;\n+\n+  __ negq(set);\n+  __ kmovql(select, set);\n+\n+  \/\/ NOTE! Crypto code cannot branch on user input. However; allowed to branch on number of limbs;\n+  \/\/ Number of limbs is a constant in each IntegerPolynomial (i.e. this side-channel branch leaks\n+  \/\/   number of limbs which is not a secret)\n+  __ cmpl(length, 5);\n+  __ jcc(Assembler::equal, L_Length5);\n+  __ cmpl(length, 10);\n+  __ jcc(Assembler::equal, L_Length10);\n+  __ cmpl(length, 14);\n+  __ jcc(Assembler::equal, L_Length14);\n+  __ cmpl(length, 16);\n+  __ jcc(Assembler::equal, L_Length16);\n+  __ cmpl(length, 19);\n+  __ jcc(Assembler::equal, L_Length19);\n+\n+  \/\/ Default copy loop (UNLIKELY)\n+  __ cmpl(length, 0);\n+  __ jcc(Assembler::lessEqual, L_Done);\n+  __ bind(L_DefaultLoop);\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  __ subl(length, 1);\n+  __ lea(aLimbs, Address(aLimbs,8));\n+  __ lea(bLimbs, Address(bLimbs,8));\n+  __ cmpl(length, 0);\n+  __ jcc(Assembler::greater, L_DefaultLoop);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length5); \/\/ 1 + 4\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  assign_avx(A, Address(aLimbs, 8), B, Address(bLimbs, 8), select, Assembler::AVX_256bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length10); \/\/ 2 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 16), B, Address(bLimbs, 16), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length14); \/\/ 2 + 4 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 16), B, Address(bLimbs, 16), select, Assembler::AVX_256bit, _masm);\n+  assign_avx(A, Address(aLimbs, 48), B, Address(bLimbs, 48), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length16); \/\/ 8 + 8\n+  assign_avx(A, Address(aLimbs, 0),  B, Address(bLimbs, 0),  select, Assembler::AVX_512bit, _masm);\n+  assign_avx(A, Address(aLimbs, 64), B, Address(bLimbs, 64), select, Assembler::AVX_512bit, _masm);\n+  __ jmp(L_Done);\n+\n+  __ bind(L_Length19); \/\/ 1 + 2 + 8 + 8\n+  assign_scalar(Address(aLimbs, 0), Address(bLimbs, 0), set, tmp, _masm);\n+  assign_avx(A, Address(aLimbs, 8),  B, Address(bLimbs, 8),  select, Assembler::AVX_128bit, _masm);\n+  assign_avx(A, Address(aLimbs, 24), B, Address(bLimbs, 24), select, Assembler::AVX_512bit, _masm);\n+  assign_avx(A, Address(aLimbs, 88), B, Address(bLimbs, 88), select, Assembler::AVX_512bit, _masm);\n+\n+  __ bind(L_Done);\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -1369,0 +1369,12 @@\n+#ifdef _LP64\n+  if (supports_avx512ifma() && supports_avx512vlbw()) {\n+    if (FLAG_IS_DEFAULT(UseIntPolyIntrinsics)) {\n+      FLAG_SET_DEFAULT(UseIntPolyIntrinsics, true);\n+    }\n+  } else\n+#endif\n+  if (UseIntPolyIntrinsics) {\n+    warning(\"Intrinsics for Polynomial crypto functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseIntPolyIntrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -13558,0 +13558,2 @@\n+\/\/ Don't use ebp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset ebp to the caller state.\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12348,1 +12348,1 @@\n-  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+  format %{ \"partialSubtypeCheck $result, $sub, $super_reg, $super_con\" %}\n@@ -12739,0 +12739,2 @@\n+\/\/ Don't use rbp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset rbp to the caller state.\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {\n+void Relocation::pd_set_data_value(address x, bool verify_only) {\n","filename":"src\/hotspot\/cpu\/zero\/relocInfo_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2445,7 +2445,0 @@\n-\/\/ create binary file, rewriting existing file if required\n-int os::create_binary_file(const char* path, bool rewrite_existing) {\n-  int oflags = O_WRONLY | O_CREAT;\n-  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n-  return ::open(path, oflags, S_IREAD | S_IWRITE);\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                      untype(offset) \/ M, untype(offset) + length \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n@@ -153,1 +153,1 @@\n-                      untype(offset) \/ M, untype(offset) + length \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  AARCH64_ONLY(develop(bool, AssertWXAtThreadSync, false,                \\\n+  AARCH64_ONLY(develop(bool, AssertWXAtThreadSync, true,                \\\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2387,8 +2387,0 @@\n-\n-\/\/ create binary file, rewriting existing file if required\n-int os::create_binary_file(const char* path, bool rewrite_existing) {\n-  int oflags = O_WRONLY | O_CREAT;\n-  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n-  return ::open(path, oflags, S_IREAD | S_IWRITE);\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-                      untype(offset) \/ M, untype(offset + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n@@ -700,1 +700,1 @@\n-                      untype(offset) \/ M, untype(offset + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5124,8 +5124,0 @@\n-\n-\/\/ create binary file, rewriting existing file if required\n-int os::create_binary_file(const char* path, bool rewrite_existing) {\n-  int oflags = O_WRONLY | O_CREAT;\n-  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n-  return ::open(path, oflags, S_IREAD | S_IWRITE);\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  #elif defined(ARM32)\n+  #define SYS_membarrier 389\n","filename":"src\/hotspot\/os\/linux\/systemMemoryBarrier_linux.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-                      untype(offset) \/ M, (untype(offset) + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n@@ -235,1 +235,1 @@\n-                      untype(offset) \/ M, (untype(offset) + length) \/ M, length \/ M);\n+                      untype(offset) \/ M, untype(to_zoffset_end(offset, length)) \/ M, length \/ M);\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zPhysicalMemoryBacking_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4892,7 +4892,0 @@\n-\/\/ create binary file, rewriting existing file if required\n-int os::create_binary_file(const char* path, bool rewrite_existing) {\n-  int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;\n-  oflags |= rewrite_existing ? _O_TRUNC : _O_EXCL;\n-  return ::open(path, oflags, _S_IREAD | _S_IWRITE);\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    .type _SafeFetch32_impl,@function\n+    .type SafeFetch32_impl,@function\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/safefetch_linux_x86_32.S","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1015,0 +1015,2 @@\n+  \/\/ Record size of code before we generate stubs in instructions section\n+  _main_code_size = _insts.size();\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -437,0 +437,3 @@\n+  \/\/ Size of code without stubs generated at the end of instructions section\n+  csize_t      _main_code_size;\n+\n@@ -467,0 +470,1 @@\n+    _main_code_size  = 0;\n@@ -640,0 +644,3 @@\n+  \/\/ size of code without stubs in instruction section\n+  csize_t main_code_size() const         { return _main_code_size; }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+#if defined(X86) || defined(AARCH64) || defined(S390)\n+  case vmIntrinsics::_clone:\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2272,2 +2272,5 @@\n-      if (type != nullptr && type->is_loaded() &&\n-          type->is_instance_klass() && !type->as_instance_klass()->is_interface()) {\n+      if (type != nullptr && type->is_loaded()) {\n+        assert(!type->is_instance_klass() || !type->as_instance_klass()->is_interface(), \"Must not be an interface\");\n+        \/\/ Detects non-interface instances, primitive arrays, and some object arrays.\n+        \/\/ Array receivers can only call Object methods, so we should be able to allow\n+        \/\/ all object arrays here too, even those with unloaded types.\n@@ -2494,1 +2497,1 @@\n-  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before)));\n+  apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()->get_index(), state_before, true)));\n@@ -3926,0 +3929,1 @@\n+  case vmIntrinsics::_clone                  : append_alloc_array_copy(callee); return;\n@@ -3929,0 +3933,3 @@\n+  if (_inline_bailout_msg != nullptr) {\n+    return;\n+  }\n@@ -3990,0 +3997,3 @@\n+  if (_inline_bailout_msg != nullptr) {\n+    return false;\n+  }\n@@ -4703,0 +4713,37 @@\n+void GraphBuilder::append_alloc_array_copy(ciMethod* callee) {\n+  const int args_base = state()->stack_size() - callee->arg_size();\n+  ciType* receiver_type = state()->stack_at(args_base)->exact_type();\n+  if (receiver_type == nullptr) {\n+    inline_bailout(\"must have a receiver\");\n+    return;\n+  }\n+  if (!receiver_type->is_type_array_klass()) {\n+    inline_bailout(\"clone array not primitive\");\n+    return;\n+  }\n+\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_force_reexecute();\n+  Value src = apop();\n+  BasicType basic_type = src->exact_type()->as_array_klass()->element_type()->basic_type();\n+  Value length = append(new ArrayLength(src, state_before));\n+  Value new_array = append_split(new NewTypeArray(length, basic_type, state_before, false));\n+\n+  ValueType* result_type = as_ValueType(callee->return_type());\n+  vmIntrinsics::ID id = vmIntrinsics::_arraycopy;\n+  Values* args = new Values(5);\n+  args->push(src);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(new_array);\n+  args->push(append(new Constant(new IntConstant(0))));\n+  args->push(length);\n+  const bool has_receiver = true;\n+  Intrinsic* array_copy = new Intrinsic(result_type, id,\n+                                    args, has_receiver, state_before,\n+                                    vmIntrinsics::preserves_state(id),\n+                                    vmIntrinsics::can_trap(id));\n+  array_copy->set_flag(Instruction::OmitChecksFlag, true);\n+  append_split(array_copy);\n+  apush(new_array);\n+}\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+  void append_alloc_array_copy(ciMethod* callee);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -388,0 +388,1 @@\n+    OmitChecksFlag,\n@@ -1392,0 +1393,1 @@\n+  bool _zero_array;\n@@ -1395,1 +1397,1 @@\n-  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)\n+  NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before, bool zero_array)\n@@ -1398,0 +1400,1 @@\n+  , _zero_array(zero_array)\n@@ -1402,0 +1405,1 @@\n+  bool zero_array()    const                     { return _zero_array; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -390,0 +390,7 @@\n+#if defined(X86) || defined(AARCH64) || defined(S390)\n+  if (expected_type != nullptr && flags == 0) {\n+    _stub = nullptr;\n+  } else {\n+    _stub = new ArrayCopyStub(this);\n+  }\n+#else\n@@ -391,0 +398,1 @@\n+#endif\n@@ -1124,1 +1132,4 @@\n-  masm->append_code_stub(stub());\n+  ArrayCopyStub* code_stub = stub();\n+  if (code_stub != nullptr) {\n+    masm->append_code_stub(code_stub);\n+  }\n@@ -1515,1 +1526,1 @@\n-void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool is_null_free) {\n+void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array, bool is_null_free) {\n@@ -1526,0 +1537,1 @@\n+                           zero_array,\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1854,0 +1854,1 @@\n+  bool      _zero_array;\n@@ -1857,1 +1858,1 @@\n-  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool is_null_free)\n+  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool zero_array, bool is_null_free)\n@@ -1867,0 +1868,1 @@\n+    , _zero_array(zero_array)\n@@ -1878,0 +1880,1 @@\n+  bool      zero_array()   const                 { return _zero_array;  }\n@@ -2444,1 +2447,1 @@\n-  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool is_null_free);\n+  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool zero_array = true, bool is_null_free = false);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+, _force_reexecute(false)\n@@ -55,0 +56,1 @@\n+  , _force_reexecute(false)\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  bool     _force_reexecute;                     \/\/ force the reexecute flag on, used for patching stub\n@@ -231,0 +232,3 @@\n+  bool force_reexecute() const         { return _force_reexecute; }\n+  void set_force_reexecute()           { _force_reexecute = true; }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  _current_dump_space(nullptr),\n+  _current_dump_region(nullptr),\n@@ -344,1 +344,1 @@\n-  _current_dump_space = &_rw_region;\n+  _current_dump_region = &_rw_region;\n@@ -347,1 +347,1 @@\n-  _current_dump_space->init(&_shared_rs, &_shared_vs);\n+  _current_dump_region->init(&_shared_rs, &_shared_vs);\n@@ -563,1 +563,1 @@\n-void ArchiveBuilder::start_dump_space(DumpRegion* next) {\n+void ArchiveBuilder::start_dump_region(DumpRegion* next) {\n@@ -565,1 +565,1 @@\n-  address top = (address)(current_dump_space()->top());\n+  address top = (address)(current_dump_region()->top());\n@@ -568,2 +568,2 @@\n-  current_dump_space()->pack(next);\n-  _current_dump_space = next;\n+  current_dump_region()->pack(next);\n+  _current_dump_region = next;\n@@ -572,1 +572,1 @@\n-  _last_verified_top = (address)(current_dump_space()->top());\n+  _last_verified_top = (address)(current_dump_region()->top());\n@@ -577,1 +577,1 @@\n-  address top = (address)(current_dump_space()->top());\n+  address top = (address)(current_dump_region()->top());\n@@ -633,1 +633,1 @@\n-  start_dump_space(&_ro_region);\n+  start_dump_region(&_ro_region);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  DumpRegion* _current_dump_space;\n+  DumpRegion* _current_dump_region;\n@@ -117,1 +117,1 @@\n-  DumpRegion* current_dump_space() const {  return _current_dump_space;  }\n+  DumpRegion* current_dump_region() const {  return _current_dump_region;  }\n@@ -281,1 +281,1 @@\n-  void start_dump_space(DumpRegion* next);\n+  void start_dump_region(DumpRegion* next);\n@@ -287,5 +287,5 @@\n-  address buffer_bottom()                    const { return _buffer_bottom;                       }\n-  address buffer_top()                       const { return (address)current_dump_space()->top(); }\n-  address requested_static_archive_bottom()  const { return  _requested_static_archive_bottom;    }\n-  address mapped_static_archive_bottom()     const { return  _mapped_static_archive_bottom;       }\n-  intx buffer_to_requested_delta()           const { return _buffer_to_requested_delta;           }\n+  address buffer_bottom()                    const { return _buffer_bottom;                        }\n+  address buffer_top()                       const { return (address)current_dump_region()->top(); }\n+  address requested_static_archive_bottom()  const { return  _requested_static_archive_bottom;     }\n+  address mapped_static_archive_bottom()     const { return  _mapped_static_archive_bottom;        }\n+  intx buffer_to_requested_delta()           const { return _buffer_to_requested_delta;            }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -70,2 +70,4 @@\n-typedef ResourceHashtable<address, size_t,\n-      127, \/\/ prime number\n+typedef ResourceHashtable<\n+      size_t,    \/\/ offset of a filler from ArchiveHeapWriter::buffer_bottom()\n+      size_t,    \/\/ size of this filler (in bytes)\n+      127,       \/\/ prime number\n@@ -364,1 +366,1 @@\n-    _fillers->put((address)filler, fill_bytes);\n+    _fillers->put(buffered_address_to_offset((address)filler), fill_bytes);\n@@ -369,1 +371,1 @@\n-  size_t* p = _fillers->get(buffered_addr);\n+  size_t* p = _fillers->get(buffered_address_to_offset(buffered_addr));\n@@ -533,4 +535,2 @@\n-  \/\/ in the shared heap. This also has the side effect of pre-initializing the\n-  \/\/ identity_hash for all shared objects, so they are less likely to be written\n-  \/\/ into during run time, increasing the potential of memory sharing.\n-  if (src_obj != nullptr && (!(EnableValhalla && src_obj->mark().is_inline_type()))) {\n+  \/\/ in the shared heap.\n+  if (src_obj != nullptr && !src_obj->fast_no_hash_check() && (!(EnableValhalla && src_obj->mark().is_inline_type()))) {\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -313,11 +313,3 @@\n-  _dump_region->append_intptr_t((intptr_t)ptr, true);\n-}\n-\n-void WriteClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    do_ptr((void**)start);\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n+  \/\/ null pointers do not need to be converted to offsets\n+  if (ptr != nullptr) {\n+    ptr = (address)ArchiveBuilder::current()->buffer_to_offset(ptr);\n@@ -325,0 +317,1 @@\n+  _dump_region->append_intptr_t((intptr_t)ptr, false);\n@@ -332,1 +325,1 @@\n-  *p = (void*)obj;\n+  *p = (void*)obj != nullptr ? (void*)(SharedBaseAddress + obj) : (void*)obj;\n@@ -358,11 +351,0 @@\n-void ReadClosure::do_region(u_char* start, size_t size) {\n-  assert((intptr_t)start % sizeof(intptr_t) == 0, \"bad alignment\");\n-  assert(size % sizeof(intptr_t) == 0, \"bad size\");\n-  do_tag((int)size);\n-  while (size > 0) {\n-    *(intptr_t*)start = nextPtr();\n-    start += sizeof(intptr_t);\n-    size -= sizeof(intptr_t);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -218,1 +218,4 @@\n-  void do_region(u_char* start, size_t size);\n+  char* region_top() {\n+    return _dump_region->top();\n+  }\n+\n@@ -241,1 +244,0 @@\n-  void do_region(u_char* start, size_t size);\n@@ -243,0 +245,1 @@\n+  char* region_top() { return nullptr; }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -57,1 +58,5 @@\n-ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) :\n+    _classlist_file(file),\n+    _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n+    _file_input(do_open(file), \/* need_close=*\/true),\n+    _input_stream(&_file_input) {\n@@ -59,12 +64,2 @@\n-                (parse_mode == _parse_lambda_forms_invokers_only) ? \" (lambda form invokers only)\" : \"\");\n-  _classlist_file = file;\n-  _file = nullptr;\n-  \/\/ Use os::open() because neither fopen() nor os::fopen()\n-  \/\/ can handle long path name on Windows.\n-  int fd = os::open(file, O_RDONLY, S_IREAD);\n-  if (fd != -1) {\n-    \/\/ Obtain a File* from the file descriptor so that fgets()\n-    \/\/ can be used in parse_one_line()\n-    _file = os::fdopen(fd, \"r\");\n-  }\n-  if (_file == nullptr) {\n+                parse_lambda_forms_invokers_only() ? \" (lambda form invokers only)\" : \"\");\n+  if (!_file_input.is_open()) {\n@@ -75,2 +70,1 @@\n-  _line_no = 0;\n-  _token = _line;\n+  _token = _line = nullptr;\n@@ -87,0 +81,13 @@\n+FILE* ClassListParser::do_open(const char* file) {\n+  \/\/ Use os::open() because neither fopen() nor os::fopen()\n+  \/\/ can handle long path name on Windows. (See JDK-8216184)\n+  int fd = os::open(file, O_RDONLY, S_IREAD);\n+  FILE* fp = nullptr;\n+  if (fd != -1) {\n+    \/\/ Obtain a FILE* from the file descriptor so that _input_stream\n+    \/\/ can be used in ClassListParser::parse()\n+    fp = os::fdopen(fd, \"r\");\n+  }\n+  return fp;\n+}\n+\n@@ -92,3 +99,0 @@\n-  if (_file != nullptr) {\n-    fclose(_file);\n-  }\n@@ -101,12 +105,17 @@\n-int ClassListParser::parse(TRAPS) {\n-  int class_count = 0;\n-\n-  while (parse_one_line()) {\n-    if (lambda_form_line()) {\n-      \/\/ The current line is \"@lambda-form-invoker ...\". It has been recorded in LambdaFormInvokers,\n-      \/\/ and will be processed later.\n-      continue;\n-    }\n-\n-    if (_parse_mode == _parse_lambda_forms_invokers_only) {\n-      continue;\n+void ClassListParser::parse(TRAPS) {\n+  for (; !_input_stream.done(); _input_stream.next()) {\n+    _line = _input_stream.current_line();\n+    clean_up_input_line();\n+\n+    \/\/ Each line in the classlist can be one of three forms:\n+    if (_line[0] == '#') {\n+      \/\/ A comment; ignore it\n+    } else if (_line[0] == '@') {\n+      \/\/ @xxx - a tag like @lambda-proxy, to be parsed by parse_at_tags()\n+      parse_at_tags(CHECK);\n+    } else {\n+      \/\/ A class name, followed by optional attributes. E.g.\n+      \/\/   java\/lang\/String\n+      \/\/   java\/lang\/Object id: 1\n+      \/\/   my\/pkg\/TestClass id: 5 super: 1 interfaces: 3 4 source: foo.jar\n+      parse_class_name_and_attributes(CHECK);\n@@ -114,0 +123,2 @@\n+  }\n+}\n@@ -115,7 +126,2 @@\n-    TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n-    if (_indy_items->length() > 0) {\n-      \/\/ The current line is \"@lambda-proxy class_name\". Load the proxy class.\n-      resolve_indy(THREAD, class_name_symbol);\n-      class_count++;\n-      continue;\n-    }\n+void ClassListParser::parse_class_name_and_attributes(TRAPS) {\n+  read_class_name_and_attributes();\n@@ -123,7 +129,3 @@\n-    Klass* klass = load_current_class(class_name_symbol, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n-        \/\/ If we have run out of memory, don't try to load the rest of the classes in\n-        \/\/ the classlist. Throw an exception, which will terminate the dumping process.\n-        return 0; \/\/ THROW\n-      }\n+  if (parse_lambda_forms_invokers_only()) {\n+    return;\n+  }\n@@ -131,12 +133,8 @@\n-      ResourceMark rm(THREAD);\n-      char* ex_msg = (char*)\"\";\n-      oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n-      if (message != nullptr) {\n-        ex_msg = java_lang_String::as_utf8_string(message);\n-      }\n-      log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n-      \/\/ We might have an invalid class name or an bad class. Warn about it\n-      \/\/ and keep going to the next line.\n-      CLEAR_PENDING_EXCEPTION;\n-      log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n-      continue;\n+  check_class_name(_class_name);\n+  TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n+  Klass* klass = load_current_class(class_name_symbol, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      \/\/ If we have run out of memory, don't try to load the rest of the classes in\n+      \/\/ the classlist. Throw an exception, which will terminate the dumping process.\n+      return; \/\/ THROW\n@@ -145,4 +143,5 @@\n-    assert(klass != nullptr, \"sanity\");\n-    if (log_is_enabled(Trace, cds)) {\n-      ResourceMark rm(THREAD);\n-      log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+    ResourceMark rm(THREAD);\n+    char* ex_msg = (char*)\"\";\n+    oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+    if (message != nullptr) {\n+      ex_msg = java_lang_String::as_utf8_string(message);\n@@ -150,0 +149,7 @@\n+    log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+    \/\/ We might have an invalid class name or an bad class. Warn about it\n+    \/\/ and keep going to the next line.\n+    CLEAR_PENDING_EXCEPTION;\n+    log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n+    return;\n+  }\n@@ -151,2 +157,5 @@\n-    if (klass->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(klass);\n+  assert(klass != nullptr, \"sanity\");\n+  if (log_is_enabled(Trace, cds)) {\n+    ResourceMark rm(THREAD);\n+    log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+  }\n@@ -154,6 +163,2 @@\n-      \/\/ Link the class to cause the bytecodes to be rewritten and the\n-      \/\/ cpcache to be created. The linking is done as soon as classes\n-      \/\/ are loaded in order that the related data structures (klass and\n-      \/\/ cpCache) are located together.\n-      MetaspaceShared::try_link_class(THREAD, ik);\n-    }\n+  if (klass->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n@@ -161,1 +166,5 @@\n-    class_count++;\n+    \/\/ Link the class to cause the bytecodes to be rewritten and the\n+    \/\/ cpcache to be created. The linking is done as soon as classes\n+    \/\/ are loaded in order that the related data structures (klass and\n+    \/\/ cpCache) are located together.\n+    MetaspaceShared::try_link_class(THREAD, ik);\n@@ -163,2 +172,0 @@\n-\n-  return class_count;\n@@ -167,4 +174,7 @@\n-bool ClassListParser::parse_one_line() {\n-  for (;;) {\n-    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n-      return false;\n+void ClassListParser::clean_up_input_line() {\n+  int len = (int)strlen(_line);\n+  int i;\n+  \/\/ Replace \\t\\r\\n\\f with ' '\n+  for (i=0; i<len; i++) {\n+    if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n+      _line[i] = ' ';\n@@ -172,18 +182,1 @@\n-    ++ _line_no;\n-    _line_len = (int)strlen(_line);\n-    if (_line_len > _max_allowed_line_len) {\n-      error(\"input line too long (must be no longer than %d chars)\", _max_allowed_line_len);\n-    }\n-    if (*_line == '#') { \/\/ comment\n-      continue;\n-    }\n-\n-    {\n-      int len = (int)strlen(_line);\n-      int i;\n-      \/\/ Replace \\t\\r\\n\\f with ' '\n-      for (i=0; i<len; i++) {\n-        if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n-          _line[i] = ' ';\n-        }\n-      }\n+  }\n@@ -191,10 +184,7 @@\n-      \/\/ Remove trailing newline\/space\n-      while (len > 0) {\n-        if (_line[len-1] == ' ') {\n-          _line[len-1] = '\\0';\n-          len --;\n-        } else {\n-          break;\n-        }\n-      }\n-      _line_len = len;\n+  \/\/ Remove trailing newline\/space\n+  while (len > 0) {\n+    if (_line[len-1] == ' ') {\n+      _line[len-1] = '\\0';\n+      len --;\n+    } else {\n+      break;\n@@ -202,3 +192,0 @@\n-\n-    \/\/ valid line\n-    break;\n@@ -206,0 +193,2 @@\n+  _line_len = len;\n+}\n@@ -207,0 +196,1 @@\n+void ClassListParser::read_class_name_and_attributes() {\n@@ -213,6 +203,0 @@\n-  _indy_items->clear();\n-  _lambda_form_line = false;\n-\n-  if (_line[0] == '@') {\n-    return parse_at_tags();\n-  }\n@@ -221,2 +205,2 @@\n-    \/\/ No optional arguments are specified.\n-    return true;\n+    \/\/ No optional attributes are specified.\n+    return;\n@@ -264,1 +248,0 @@\n-  return true;\n@@ -267,1 +250,1 @@\n-void ClassListParser::split_tokens_by_whitespace(int offset) {\n+void ClassListParser::split_tokens_by_whitespace(int offset, GrowableArray<const char*>* items) {\n@@ -280,1 +263,1 @@\n-    _indy_items->append(_line + start);\n+    items->append(_line + start);\n@@ -289,1 +272,1 @@\n-    error(\"Too few items following the @ tag \\\"%s\\\" line #%d\", _line, _line_no);\n+    error(\"Too few items following the @ tag \\\"%s\\\" line #%zu\", _line, lineno());\n@@ -297,1 +280,1 @@\n-bool ClassListParser::parse_at_tags() {\n+void ClassListParser::parse_at_tags(TRAPS) {\n@@ -299,4 +282,2 @@\n-  int offset;\n-  if ((offset = split_at_tag_from_line()) == 0) {\n-    return false;\n-  }\n+  int offset = split_at_tag_from_line();\n+  assert(offset > 0, \"would have exited VM\");\n@@ -305,1 +286,2 @@\n-    split_tokens_by_whitespace(offset);\n+    _indy_items->clear();\n+    split_tokens_by_whitespace(offset, _indy_items);\n@@ -307,2 +289,10 @@\n-      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _token, _line_no);\n-      return false;\n+      error(\"Line with @ tag has too few items \\\"%s\\\" line #%zu\", _token, lineno());\n+    }\n+    if (!parse_lambda_forms_invokers_only()) {\n+      _class_name = _indy_items->at(0);\n+      check_class_name(_class_name);\n+      TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n+      if (_indy_items->length() > 0) {\n+        \/\/ The current line is \"@lambda-proxy class_name\". Load the proxy class.\n+        resolve_indy(THREAD, class_name_symbol);\n+      }\n@@ -310,3 +300,0 @@\n-    \/\/ set the class name\n-    _class_name = _indy_items->at(0);\n-    return true;\n@@ -315,2 +302,0 @@\n-    _lambda_form_line = true;\n-    return true;\n@@ -318,2 +303,1 @@\n-    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _token, _line_no);\n-    return false;\n+    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%zu\", _token, lineno());\n@@ -426,2 +410,2 @@\n-              \"An error has occurred while processing class list file %s %d:%d.\\n\",\n-              _classlist_file, _line_no, (error_index + 1));\n+              \"An error has occurred while processing class list file %s %zu:%d.\\n\",\n+              _classlist_file, lineno(), (error_index + 1));\n@@ -448,0 +432,1 @@\n+  va_end(ap);\n@@ -450,1 +435,19 @@\n-  va_end(ap);\n+}\n+\n+void ClassListParser::check_class_name(const char* class_name) {\n+  const char* err = nullptr;\n+  size_t len = strlen(class_name);\n+  if (len > (size_t)Symbol::max_length()) {\n+    err = \"class name too long\";\n+  } else {\n+    assert(Symbol::max_length() < INT_MAX && len < INT_MAX, \"must be\");\n+    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, (int)len, \/*version_leq_47*\/false)) {\n+      err = \"class name is not valid UTF8\";\n+    }\n+  }\n+  if (err != nullptr) {\n+    jio_fprintf(defaultStream::error_stream(),\n+              \"An error has occurred while processing class list file %s:%zu %s\\n\",\n+              _classlist_file, lineno(), err);\n+    vm_exit_during_initialization(\"class list format error.\", nullptr);\n+  }\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":140,"deletions":137,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -83,8 +84,0 @@\n-\n-    \/\/ Max number of bytes allowed per line in the classlist.\n-    \/\/ Theoretically Java class names could be 65535 bytes in length. Also, an input line\n-    \/\/ could have a very long path name up to JVM_MAXPATHLEN bytes in length. In reality,\n-    \/\/ 4K bytes is more than enough.\n-    _max_allowed_line_len = 4096,\n-    _line_buf_extra       = 10, \/\/ for detecting input too long\n-    _line_buf_size        = _max_allowed_line_len + _line_buf_extra\n@@ -99,1 +92,0 @@\n-  FILE* _file;\n@@ -103,3 +95,3 @@\n-  \/\/ The following field contains information from the *current* line being\n-  \/\/ parsed.\n-  char                _line[_line_buf_size];  \/\/ The buffer that holds the current line. Some characters in\n+  FileInput           _file_input;\n+  inputStream         _input_stream;\n+  char*               _line;                  \/\/ The buffer that holds the current line. Some characters in\n@@ -108,1 +100,0 @@\n-  int                 _line_no;               \/\/ Line number for current line being parsed\n@@ -116,1 +107,0 @@\n-  bool                _lambda_form_line;\n@@ -132,1 +122,3 @@\n-  bool parse_one_line();\n+  void clean_up_input_line();\n+  void read_class_name_and_attributes();\n+  void parse_class_name_and_attributes(TRAPS);\n@@ -135,0 +127,2 @@\n+  size_t lineno() { return _input_stream.lineno(); }\n+  FILE* do_open(const char* file);\n@@ -139,1 +133,1 @@\n-  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+  static void parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n@@ -141,1 +135,1 @@\n-    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+    parser.parse(THREAD);\n@@ -151,2 +145,2 @@\n-  int parse(TRAPS);\n-  void split_tokens_by_whitespace(int offset);\n+  void parse(TRAPS);\n+  void split_tokens_by_whitespace(int offset, GrowableArray<const char*>* items);\n@@ -154,1 +148,1 @@\n-  bool parse_at_tags();\n+  void parse_at_tags(TRAPS);\n@@ -164,0 +158,3 @@\n+  bool parse_lambda_forms_invokers_only() {\n+    return _parse_mode == _parse_lambda_forms_invokers_only;\n+  }\n@@ -186,0 +183,1 @@\n+  void check_class_name(const char* class_name);\n@@ -193,2 +191,0 @@\n-  bool lambda_form_line() { return _lambda_form_line; }\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-CppVtableInfo** CppVtables::_index = nullptr;\n+static CppVtableInfo* _index[_num_cloned_vtable_kinds];\n@@ -224,1 +224,7 @@\n-char* CppVtables::dumptime_init(ArchiveBuilder* builder) {\n+\/\/ Vtables are all fixed offsets from ArchiveBuilder::current()->mapped_base()\n+\/\/ E.g. ConstantPool is at offset 0x58. We can archive these offsets in the\n+\/\/ RO region and use them to alculate their location at runtime without storing\n+\/\/ the pointers in the RW region\n+char* CppVtables::_vtables_serialized_base = nullptr;\n+\n+void CppVtables::dumptime_init(ArchiveBuilder* builder) {\n@@ -226,2 +232,0 @@\n-  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(CppVtableInfo*);\n-  _index = (CppVtableInfo**)builder->rw_region()->allocate(vtptrs_bytes);\n@@ -233,2 +237,0 @@\n-\n-  return (char*)_index;\n@@ -238,1 +240,6 @@\n-  soc->do_ptr(&_index);\n+  if (!soc->reading()) {\n+    _vtables_serialized_base = (char*)ArchiveBuilder::current()->buffer_top();\n+  }\n+  for (int i = 0; i < _num_cloned_vtable_kinds; i++) {\n+    soc->do_ptr(&_index[i]);\n+  }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  static CppVtableInfo** _index;\n+  static char* _vtables_serialized_base;\n@@ -41,1 +41,1 @@\n-  static char* dumptime_init(ArchiveBuilder* builder);\n+  static void dumptime_init(ArchiveBuilder* builder);\n@@ -46,0 +46,1 @@\n+  static char* vtables_serialized_base() { return _vtables_serialized_base; }\n","filename":"src\/hotspot\/share\/cds\/cppVtables.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-      assert(current_dump_space() == ro_region(), \"Must be RO space\");\n+      assert(current_dump_region() == ro_region(), \"Must be RO space\");\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,8 +281,0 @@\n-\n-    \/\/ The archived objects are discovered in a predictable order. Compute\n-    \/\/ their identity_hash() as soon as we see them. This ensures that the\n-    \/\/ the identity_hash in the object header will have a predictable value,\n-    \/\/ making the archive reproducible.\n-    if (!obj->klass()->is_inline_klass()) {\n-      obj->identity_hash();\n-    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -230,0 +230,8 @@\n+  if (UseCompressedClassPointers) {\n+    aligned_base = align_up(specified_base, Metaspace::reserve_alignment());\n+  }\n+\n+  if (aligned_base != specified_base) {\n+    log_info(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") aligned up to \" INTPTR_FORMAT,\n+                   p2i(specified_base), p2i(aligned_base));\n+  }\n@@ -516,1 +524,1 @@\n-  char* cloned_vtables = CppVtables::dumptime_init(&builder);\n+  CppVtables::dumptime_init(&builder);\n@@ -547,1 +555,1 @@\n-  mapinfo->set_cloned_vtables(cloned_vtables);\n+  mapinfo->set_cloned_vtables(CppVtables::vtables_serialized_base());\n@@ -742,2 +750,2 @@\n-  int class_count = ClassListParser::parse_classlist(classlist_path,\n-                                                     ClassListParser::_parse_all, CHECK);\n+  ClassListParser::parse_classlist(classlist_path,\n+                                   ClassListParser::_parse_all, CHECK);\n@@ -745,2 +753,2 @@\n-    class_count += ClassListParser::parse_classlist(ExtraSharedClassListFile,\n-                                                    ClassListParser::_parse_all, CHECK);\n+    ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                     ClassListParser::_parse_all, CHECK);\n@@ -752,2 +760,2 @@\n-      class_count += ClassListParser::parse_classlist(default_classlist,\n-                                                      ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+      ClassListParser::parse_classlist(default_classlist,\n+                                       ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n@@ -763,1 +771,0 @@\n-  log_info(cds)(\"Shared spaces: preloaded %d classes\", class_count);\n@@ -1269,6 +1276,0 @@\n-  \/\/ If a base address is given, it must have valid alignment and be suitable as encoding base.\n-  if (base_address != nullptr) {\n-    assert(is_aligned(base_address, archive_space_alignment),\n-           \"Archive base address invalid: \" PTR_FORMAT \".\", p2i(base_address));\n-  }\n-\n@@ -1278,0 +1279,6 @@\n+\n+    \/\/ When running without class space, requested archive base should be aligned to cds core alignment.\n+    assert(is_aligned(base_address, archive_space_alignment),\n+             \"Archive base address unaligned: \" PTR_FORMAT \", needs alignment: %zu.\",\n+             p2i(base_address), archive_space_alignment);\n+\n@@ -1298,6 +1305,6 @@\n-  \/\/ To simplify matters, lets assume that metaspace alignment will always be\n-  \/\/  equal or a multiple of archive alignment.\n-  assert(is_power_of_2(class_space_alignment) &&\n-                       is_power_of_2(archive_space_alignment) &&\n-                       class_space_alignment >= archive_space_alignment,\n-                       \"Sanity\");\n+  \/\/ When running with class space, requested archive base must satisfy both cds core alignment\n+  \/\/ and class space alignment.\n+  const size_t base_address_alignment = MAX2(class_space_alignment, archive_space_alignment);\n+  assert(is_aligned(base_address, base_address_alignment),\n+           \"Archive base address unaligned: \" PTR_FORMAT \", needs alignment: %zu.\",\n+           p2i(base_address), base_address_alignment);\n@@ -1311,2 +1318,1 @@\n-  const size_t ccs_begin_offset = align_up(base_address + archive_space_size,\n-                                           class_space_alignment) - base_address;\n+  const size_t ccs_begin_offset = align_up(archive_space_size, class_space_alignment);\n@@ -1316,1 +1322,1 @@\n-      align_up(archive_space_size + gap_size + class_space_size, core_region_alignment());\n+      archive_space_size + gap_size + class_space_size;\n@@ -1341,1 +1347,1 @@\n-      total_space_rs = ReservedSpace(total_range_size, archive_space_alignment,\n+      total_space_rs = ReservedSpace(total_range_size, base_address_alignment,\n@@ -1359,1 +1365,1 @@\n-    assert(is_aligned(total_space_rs.base(), archive_space_alignment), \"Sanity\");\n+    assert(is_aligned(total_space_rs.base(), base_address_alignment), \"Sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -51,2 +51,14 @@\n-  \/\/ Read\/write the region specified.\n-  virtual void do_region(u_char* start, size_t size) = 0;\n+  \/\/ Iterate on the pointers from p[0] through p[num_pointers-1]\n+  void do_ptrs(void** p, size_t size) {\n+    assert((intptr_t)p % sizeof(intptr_t) == 0, \"bad alignment\");\n+    assert(size % sizeof(intptr_t) == 0, \"bad size\");\n+    do_tag((int)size);\n+    while (size > 0) {\n+      do_ptr(p);\n+      p++;\n+      size -= sizeof(intptr_t);\n+    }\n+  }\n+\n+  \/\/ Address of the first element being written (write only)\n+  virtual char* region_top() = 0;\n","filename":"src\/hotspot\/share\/cds\/serializeClosure.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1148,9 +1148,11 @@\n-        \/\/ If there is an old version we're done with it\n-        nmethod* old = method->code();\n-        if (TraceMethodReplacement && old != nullptr) {\n-          ResourceMark rm;\n-          char *method_name = method->name_and_sig_as_C_string();\n-          tty->print_cr(\"Replacing method %s\", method_name);\n-        }\n-        if (old != nullptr) {\n-          old->make_not_used();\n+        if (TieredCompilation) {\n+          \/\/ If there is an old version we're done with it\n+          nmethod* old = method->code();\n+          if (TraceMethodReplacement && old != nullptr) {\n+            ResourceMark rm;\n+            char *method_name = method->name_and_sig_as_C_string();\n+            tty->print_cr(\"Replacing method %s\", method_name);\n+          }\n+          if (old != nullptr) {\n+            old->make_not_used();\n+          }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1187,1 +1187,2 @@\n-\/\/ heuristic (e.g. post call nop instructions; see InlineSkippedInstructionsCounter)\n+\/\/ heuristic (e.g. post call nop instructions and GC barriers;\n+\/\/ see InlineSkippedInstructionsCounter).\n@@ -1193,1 +1194,1 @@\n-        int isize = code->insts_end() - code->verified_entry_point() - code->skipped_instructions_size();\n+        int isize = code->inline_insts_size();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -500,0 +500,4 @@\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+  case vmIntrinsics::_intpoly_assign:\n+    if (!UseIntPolyIntrinsics) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -532,1 +532,12 @@\n-   \/* support for java.util.Base64.Encoder*\/                                                                            \\\n+  \/* support for sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256 *\/                                      \\\n+  do_class(sun_security_util_math_intpoly_MontgomeryIntegerPolynomialP256, \"sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256\")  \\\n+  do_intrinsic(_intpoly_montgomeryMult_P256, sun_security_util_math_intpoly_MontgomeryIntegerPolynomialP256, intPolyMult_name, intPolyMult_signature, F_R) \\\n+  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+                                                                                                                        \\\n+  do_class(sun_security_util_math_intpoly_IntegerPolynomial, \"sun\/security\/util\/math\/intpoly\/IntegerPolynomial\")        \\\n+  do_intrinsic(_intpoly_assign, sun_security_util_math_intpoly_IntegerPolynomial, intPolyAssign_name, intPolyAssign_signature, F_S) \\\n+   do_name(intPolyAssign_name, \"conditionalAssign\")                                                                     \\\n+   do_signature(intPolyAssign_signature, \"(I[J[J)V\")                                                                    \\\n+                                                                                                                        \\\n+  \/* support for java.util.Base64.Encoder*\/                                                                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  soc->do_region((u_char*)&Symbol::_vm_symbols[FIRST_SID],\n+  soc->do_ptrs((void**)&Symbol::_vm_symbols[FIRST_SID],\n@@ -210,1 +210,1 @@\n-  soc->do_region((u_char*)_type_signatures, sizeof(_type_signatures));\n+  soc->do_ptrs((void**)_type_signatures, sizeof(_type_signatures));\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-  template(argsize_name,                              \"argsize\")                                  \\\n+  template(bottom_name,                               \"bottom\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"compiler\/compilerDirectives.hpp\"\n@@ -1333,61 +1332,0 @@\n-void CodeCache::mark_directives_matches(bool top_only) {\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  Thread *thread = Thread::current();\n-  HandleMark hm(thread);\n-\n-  NMethodIterator iter(NMethodIterator::not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    methodHandle mh(thread, nm->method());\n-    if (DirectivesStack::hasMatchingDirectives(mh, top_only)) {\n-      ResourceMark rm;\n-      log_trace(codecache)(\"Mark because of matching directives %s\", mh->external_name());\n-      mh->set_has_matching_directives();\n-    }\n-  }\n-}\n-\n-void CodeCache::recompile_marked_directives_matches() {\n-  Thread *thread = Thread::current();\n-  HandleMark hm(thread);\n-\n-  \/\/ Try the max level and let the directives be applied during the compilation.\n-  int comp_level = CompilationPolicy::highest_compile_level();\n-  RelaxedNMethodIterator iter(RelaxedNMethodIterator::not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    methodHandle mh(thread, nm->method());\n-    if (mh->has_matching_directives()) {\n-      ResourceMark rm;\n-      mh->clear_directive_flags();\n-      bool deopt = false;\n-\n-      if (!nm->is_osr_method()) {\n-        log_trace(codecache)(\"Recompile to level %d because of matching directives %s\",\n-                             comp_level, mh->external_name());\n-        nmethod * comp_nm = CompileBroker::compile_method(mh, InvocationEntryBci, comp_level,\n-                                                          methodHandle(), 0,\n-                                                          CompileTask::Reason_DirectivesChanged,\n-                                                          (JavaThread*)thread);\n-        if (comp_nm == nullptr) {\n-          log_trace(codecache)(\"Recompilation to level %d failed, deoptimize %s\",\n-                               comp_level, mh->external_name());\n-          deopt = true;\n-        }\n-      } else {\n-        log_trace(codecache)(\"Deoptimize OSR %s\", mh->external_name());\n-        deopt = true;\n-      }\n-      \/\/ For some reason the method cannot be compiled by C2, e.g. the new directives forbid it.\n-      \/\/ Deoptimize the method and let the usual hotspot logic do the rest.\n-      if (deopt) {\n-        if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n-          nm->make_not_entrant();\n-          nm->make_deoptimized();\n-        }\n-      }\n-      gc_on_allocation(); \/\/ Flush unused methods from CodeCache if required.\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -298,3 +298,0 @@\n-  static void mark_directives_matches(bool top_only = false);\n-  static void recompile_marked_directives_matches();\n-\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+  uint inline_insts_size;\n@@ -154,0 +155,1 @@\n+    inline_insts_size   += nm->inline_insts_size();\n@@ -188,0 +190,3 @@\n+    if (inline_insts_size != 0) {\n+      tty->print_cr(\"     inline code = %u (%f%%)\", inline_insts_size, (inline_insts_size * 100.0f)\/total_nm_size);\n+    }\n@@ -1267,1 +1272,9 @@\n-  CHECKED_CAST(_skipped_instructions_size, uint16_t, (code_buffer->total_skipped_instructions_size()));\n+\n+  int size = code_buffer->main_code_size();\n+  assert(size >= 0, \"should be initialized\");\n+  \/\/ Use instructions section size if it is 0 (e.g. native wrapper)\n+  if (size == 0) size = code_size(); \/\/ requires _stub_offset to be set\n+  assert(size <= code_size(), \"incorrect size: %d > %d\", size, code_size());\n+  _inline_insts_size = size - _verified_entry_offset\n+                     - code_buffer->total_skipped_instructions_size();\n+  assert(_inline_insts_size >= 0, \"sanity\");\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -226,0 +226,2 @@\n+  int _inline_insts_size;\n+\n@@ -240,1 +242,0 @@\n-  uint16_t _skipped_instructions_size;\n@@ -597,1 +598,1 @@\n-  int skipped_instructions_size () const { return _skipped_instructions_size; }\n+  int inline_insts_size() const { return _inline_insts_size; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -280,24 +280,0 @@\n-\/\/\/\/\/\/\/\/ Methods for RelocationHolder\n-\n-RelocationHolder RelocationHolder::plus(int offset) const {\n-  if (offset != 0) {\n-    switch (type()) {\n-    case relocInfo::none:\n-      break;\n-    case relocInfo::oop_type:\n-      {\n-        oop_Relocation* r = (oop_Relocation*)reloc();\n-        return oop_Relocation::spec(r->oop_index(), r->offset() + offset);\n-      }\n-    case relocInfo::metadata_type:\n-      {\n-        metadata_Relocation* r = (metadata_Relocation*)reloc();\n-        return metadata_Relocation::spec(r->metadata_index(), r->offset() + offset);\n-      }\n-    default:\n-      ShouldNotReachHere();\n-    }\n-  }\n-  return (*this);\n-}\n-\n@@ -405,1 +381,1 @@\n-  p = pack_2_ints_to(p, _oop_index, _offset);\n+  p = pack_1_int_to(p, _oop_index);\n@@ -411,1 +387,1 @@\n-  unpack_2_ints(_oop_index, _offset);\n+  _oop_index = unpack_1_int();\n@@ -416,1 +392,1 @@\n-  p = pack_2_ints_to(p, _metadata_index, _offset);\n+  p = pack_1_int_to(p, _metadata_index);\n@@ -422,1 +398,1 @@\n-  unpack_2_ints(_metadata_index, _offset);\n+  _metadata_index = unpack_1_int();\n@@ -858,2 +834,2 @@\n-      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \" offset=%d]\",\n-                 p2i(oop_addr), p2i(raw_oop), r->offset());\n+      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+                 p2i(oop_addr), p2i(raw_oop));\n@@ -881,2 +857,2 @@\n-      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \" offset=%d]\",\n-                 p2i(metadata_addr), p2i(raw_metadata), r->offset());\n+      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+                 p2i(metadata_addr), p2i(raw_metadata));\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -132,6 +132,1 @@\n-\/\/          [n]      n is the index of an oop in the CodeBlob's oop pool\n-\/\/          [[N]n l] and l is a byte offset to be applied to the oop\n-\/\/          [Nn Ll]  both index and offset may be 32 bits if necessary\n-\/\/   Here is a special hack, used only by the old compiler:\n-\/\/          [[N]n 00] the value is the __address__ of the nth oop in the pool\n-\/\/   (Note that the offset allows optimal references to class variables.)\n+\/\/          [[N]n]   the index of an oop in the CodeBlob's oop pool\n@@ -518,3 +513,0 @@\n-  \/\/ Add a constant offset to a relocation.  Helper for class Address.\n-  RelocationHolder plus(int offset) const;\n-\n@@ -791,2 +783,2 @@\n-  void       pd_set_data_value       (address x, intptr_t off, bool verify_only = false); \/\/ a set or mem-ref\n-  void       pd_verify_data_value    (address x, intptr_t off) { pd_set_data_value(x, off, true); }\n+  void       pd_set_data_value       (address x, bool verify_only = false); \/\/ a set or mem-ref\n+  void       pd_verify_data_value    (address x) { pd_set_data_value(x, true); }\n@@ -898,1 +890,0 @@\n-\/\/ By convention, the \"value\" does not include a separately reckoned \"offset\".\n@@ -903,1 +894,1 @@\n-  bool          is_data() override             { return true; }\n+  bool    is_data() override { return true; }\n@@ -905,6 +896,4 @@\n-  \/\/ both target and offset must be computed somehow from relocation data\n-  virtual int    offset()                      { return 0; }\n-  address         value() override             = 0;\n-  void        set_value(address x) override    { set_value(x, offset()); }\n-  void        set_value(address x, intptr_t o) {\n-    if (addr_in_const())\n+  \/\/ target must be computed somehow from relocation data\n+  address value() override = 0;\n+  void    set_value(address x) override {\n+    if (addr_in_const()) {\n@@ -912,2 +901,3 @@\n-    else\n-      pd_set_data_value(x, o);\n+    } else {\n+      pd_set_data_value(x);\n+    }\n@@ -915,2 +905,2 @@\n-  void        verify_value(address x) {\n-    if (addr_in_const())\n+  void    verify_value(address x) {\n+    if (addr_in_const()) {\n@@ -918,2 +908,3 @@\n-    else\n-      pd_verify_data_value(x, offset());\n+    } else {\n+      pd_verify_data_value(x);\n+    }\n@@ -921,12 +912,0 @@\n-\n-  \/\/ The \"o\" (displacement) argument is relevant only to split relocations\n-  \/\/ on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins'ns\n-  \/\/ can encode more than 32 bits between them.  This allows compilers to\n-  \/\/ share set-hi instructions between addresses that differ by a small\n-  \/\/ offset (e.g., different static variables in the same class).\n-  \/\/ On such machines, the \"x\" argument to set_value on all set-lo\n-  \/\/ instructions must be the same as the \"x\" argument for the\n-  \/\/ corresponding set-hi instructions.  The \"o\" arguments for the\n-  \/\/ set-hi instructions are ignored, and must not affect the high-half\n-  \/\/ immediate constant.  The \"o\" arguments for the set-lo instructions are\n-  \/\/ added into the low-half immediate constant, and must not overflow it.\n@@ -979,3 +958,2 @@\n-  \/\/ encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]\n-  \/\/ an oop in the CodeBlob's oop pool\n-  static RelocationHolder spec(int oop_index, int offset = 0) {\n+  \/\/ an oop in the CodeBlob's oop pool; encoded as [n] or [Nn]\n+  static RelocationHolder spec(int oop_index) {\n@@ -983,1 +961,1 @@\n-    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n+    return RelocationHolder::construct<oop_Relocation>(oop_index);\n@@ -985,1 +963,1 @@\n-  \/\/ an oop in the instruction stream\n+  \/\/ an oop in the instruction stream; encoded as []\n@@ -992,2 +970,1 @@\n-    const int offset    = 0;    \/\/ if you want an offset, use the oop pool\n-    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n+    return RelocationHolder::construct<oop_Relocation>(oop_index);\n@@ -1000,1 +977,0 @@\n-  jint _offset;                     \/\/ byte offset to apply to the oop itself\n@@ -1002,2 +978,2 @@\n-  oop_Relocation(int oop_index, int offset)\n-    : DataRelocation(relocInfo::oop_type), _oop_index(oop_index), _offset(offset) { }\n+  oop_Relocation(int oop_index)\n+    : DataRelocation(relocInfo::oop_type), _oop_index(oop_index) { }\n@@ -1010,1 +986,0 @@\n-  int offset() override { return _offset; }\n@@ -1012,1 +987,1 @@\n-  \/\/ data is packed in \"2_ints\" format:  [i o] or [Ii Oo]\n+  \/\/ oop_index is packed in \"1_int\" format:  [n] or [Nn]\n@@ -1034,3 +1009,2 @@\n-  \/\/ encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]\n-  \/\/ an metadata in the CodeBlob's metadata pool\n-  static RelocationHolder spec(int metadata_index, int offset = 0) {\n+  \/\/ an metadata in the CodeBlob's metadata pool; encoded as [n] or [Nn]\n+  static RelocationHolder spec(int metadata_index) {\n@@ -1038,1 +1012,1 @@\n-    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index);\n@@ -1040,1 +1014,1 @@\n-  \/\/ an metadata in the instruction stream\n+  \/\/ an metadata in the instruction stream; encoded as []\n@@ -1043,2 +1017,1 @@\n-    const int offset    = 0;    \/\/ if you want an offset, use the metadata pool\n-    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index);\n@@ -1051,1 +1024,0 @@\n-  jint _offset;                     \/\/ byte offset to apply to the metadata itself\n@@ -1053,2 +1025,2 @@\n-  metadata_Relocation(int metadata_index, int offset)\n-    : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index), _offset(offset) { }\n+  metadata_Relocation(int metadata_index)\n+    : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index) { }\n@@ -1066,1 +1038,0 @@\n-  int offset() override { return _offset; }\n@@ -1068,1 +1039,1 @@\n-  \/\/ data is packed in \"2_ints\" format:  [i o] or [Ii Oo]\n+  \/\/ metadata_index is packed in \"1_int\" format:  [n] or [Nn]\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":32,"deletions":61,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-VMReg VMRegImpl::stack0 = (VMReg)(intptr_t)VMRegImpl::stack_0()->value();\n+VMReg VMRegImpl::stack0 = (VMReg)(intptr_t)FIRST_STACK;\n","filename":"src\/hotspot\/share\/code\/vmreg.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-    BAD_REG = -1\n+    BAD_REG = -1,\n+    FIRST_STACK = (ConcreteRegisterImpl::number_of_registers + 7) & ~7\n@@ -74,1 +75,1 @@\n-    return first() + ((ConcreteRegisterImpl::number_of_registers + 7) & ~7);\n+    return first() + FIRST_STACK;\n","filename":"src\/hotspot\/share\/code\/vmreg.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  _limit(0), _hit_limit(false),\n+  _limit(0), _hit_limit(false), _limit_in_process(false),\n@@ -184,0 +184,2 @@\n+  \/\/ active limit for this compilation, if any\n+  size_t _limit;\n@@ -185,0 +187,1 @@\n+  \/\/ peak usage, bytes, over all arenas\n@@ -186,0 +189,1 @@\n+  \/\/ usage in node arena when total peaked\n@@ -187,0 +191,1 @@\n+  \/\/ usage in resource area when total peaked\n@@ -188,0 +193,1 @@\n+  \/\/ number of nodes (c2 only) when total peaked\n@@ -195,1 +201,1 @@\n-      _time(0), _num_recomp(0), _thread(nullptr),\n+      _time(0), _num_recomp(0), _thread(nullptr), _limit(0),\n@@ -203,0 +209,1 @@\n+  void set_limit(size_t limit) { _limit = limit; }\n@@ -221,0 +228,1 @@\n+    st->print_cr(\"  limit  : memory limit, if set\");\n@@ -228,1 +236,1 @@\n-    st->print_cr(\"total     NA        RA        result  #nodes  time    type  #rc thread              method\");\n+    st->print_cr(\"total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\");\n@@ -263,1 +271,13 @@\n-    st->print(\"%u \", _live_nodes_at_peak);\n+    if (_live_nodes_at_peak > 0) {\n+      st->print(\"%u \", _live_nodes_at_peak);\n+    } else {\n+      st->print(\"-\");\n+    }\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ Limit\n+    if (_limit > 0) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_limit));\n+    } else {\n+      st->print(\"-\");\n+    }\n@@ -325,1 +345,1 @@\n-           unsigned live_nodes_at_peak, const char* result) {\n+           unsigned live_nodes_at_peak, size_t limit, const char* result) {\n@@ -346,0 +366,1 @@\n+    e->set_limit(limit);\n@@ -433,0 +454,1 @@\n+                    arena_stat->limit(),\n@@ -486,0 +508,4 @@\n+  if (arena_stat->limit_in_process()) {\n+    return; \/\/ avoid recursion on limit hit\n+  }\n+\n@@ -492,1 +518,0 @@\n-\n@@ -498,0 +523,2 @@\n+      arena_stat->set_limit_in_process(true); \/\/ prevent recursive limit hits\n+\n@@ -519,2 +546,2 @@\n-        ss.print(\"Hit MemLimit %s (limit: %zu now: %zu)\",\n-                 (hit_limit_before ? \"again\" : \"\"),\n+        ss.print(\"Hit MemLimit %s(limit: %zu now: %zu)\",\n+                 (hit_limit_before ? \"again \" : \"\"),\n@@ -536,0 +563,2 @@\n+\n+      arena_stat->set_limit_in_process(false);\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  bool _limit_in_process;\n@@ -89,0 +90,3 @@\n+  bool   limit_in_process() const     { return _limit_in_process; }\n+  void   set_limit_in_process(bool v) { _limit_in_process = v; }\n+\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -1174,7 +1175,5 @@\n-  if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n-    \/\/ A request has been made for compilation.  Before we do any\n-    \/\/ real work, check to see if the method has been compiled\n-    \/\/ in the meantime with a definitive result.\n-    if (compilation_is_complete(method, osr_bci, comp_level)) {\n-      return;\n-    }\n+  \/\/ A request has been made for compilation.  Before we do any\n+  \/\/ real work, check to see if the method has been compiled\n+  \/\/ in the meantime with a definitive result.\n+  if (compilation_is_complete(method, osr_bci, comp_level)) {\n+    return;\n@@ -1225,7 +1224,5 @@\n-    if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n-      \/\/ We need to check again to see if the compilation has\n-      \/\/ completed.  A previous compilation may have registered\n-      \/\/ some result.\n-      if (compilation_is_complete(method, osr_bci, comp_level)) {\n-        return;\n-      }\n+    \/\/ We need to check again to see if the compilation has\n+    \/\/ completed.  A previous compilation may have registered\n+    \/\/ some result.\n+    if (compilation_is_complete(method, osr_bci, comp_level)) {\n+      return;\n@@ -1380,1 +1377,1 @@\n-    if (method_code != nullptr && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n+    if (method_code != nullptr) {\n@@ -1399,0 +1396,1 @@\n+    InternalOOMEMark iom(THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-      Reason_DirectivesChanged, \/\/ Changed CompilerDirectivesStack\n@@ -78,2 +77,1 @@\n-      \"bootstrap\",\n-      \"directives_changed\"\n+      \"bootstrap\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -750,19 +750,0 @@\n-bool DirectivesStack::hasMatchingDirectives(const methodHandle& method, bool top_only) {\n-  assert(_depth > 0, \"Must never be empty\");\n-  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n-\n-  CompilerDirectives* dir = _top;\n-  assert(dir != nullptr, \"Must be initialized\");\n-\n-  while (dir != nullptr) {\n-    if (!dir->is_default_directive() && dir->match(method)) {\n-      return true;\n-    }\n-    if (top_only) {\n-      break;\n-    }\n-    dir = dir->next();\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-  static bool hasMatchingDirectives(const methodHandle& method, bool top_only = false);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -45,0 +46,17 @@\n+\/\/ Default compile commands, if defined, are parsed before any of the\n+\/\/ explicitly defined compile commands. Thus, explicitly defined compile\n+\/\/ commands take precedence over default compile commands. The effect is\n+\/\/ as if the default compile commands had been specified at the start of\n+\/\/ the command line.\n+static const char* const default_compile_commands[] = {\n+#ifdef ASSERT\n+    \/\/ In debug builds, impose a (generous) per-compilation memory limit\n+    \/\/ to catch pathological compilations during testing. The suboption\n+    \/\/ \"crash\" will cause the JVM to assert.\n+    \/\/\n+    \/\/ Note: to disable the default limit at the command line,\n+    \/\/ set a limit of 0 (e.g. -XX:CompileCommand=MemLimit,*.*,0).\n+    \"MemLimit,*.*,1G~crash\",\n+#endif\n+    nullptr };\n+\n@@ -908,0 +926,8 @@\n+bool CompilerOracle::parse_from_line_quietly(char* line) {\n+  const bool quiet0 = _quiet;\n+  _quiet = true;\n+  const bool result = parse_from_line(line);\n+  _quiet = quiet0;\n+  return result;\n+}\n+\n@@ -1059,22 +1085,2 @@\n-  char token[1024];\n-  int  pos = 0;\n-  int  c = getc(stream);\n-  bool success = true;\n-  while(c != EOF && pos < (int)(sizeof(token)-1)) {\n-    if (c == '\\n') {\n-      token[pos++] = '\\0';\n-      if (!parse_from_line(token)) {\n-        success = false;\n-      }\n-      pos = 0;\n-    } else {\n-      token[pos++] = c;\n-    }\n-    c = getc(stream);\n-  }\n-  token[pos++] = '\\0';\n-  if (!parse_from_line(token)) {\n-    success = false;\n-  }\n-  fclose(stream);\n-  return success;\n+  FileInput input(stream, \/*need_close=*\/ true);\n+  return parse_from_input(&input, parse_from_line);\n@@ -1083,5 +1089,3 @@\n-bool CompilerOracle::parse_from_string(const char* str, bool (*parse_line)(char*)) {\n-  char token[1024];\n-  int  pos = 0;\n-  const char* sp = str;\n-  int  c = *sp++;\n+bool CompilerOracle::parse_from_input(inputStream::Input* input,\n+                                      CompilerOracle::\n+                                      parse_from_line_fn_t* parse_from_line) {\n@@ -1089,9 +1093,3 @@\n-  while (c != '\\0' && pos < (int)(sizeof(token)-1)) {\n-    if (c == '\\n') {\n-      token[pos++] = '\\0';\n-      if (!parse_line(token)) {\n-        success = false;\n-      }\n-      pos = 0;\n-    } else {\n-      token[pos++] = c;\n+  for (inputStream in(input); !in.done(); in.next()) {\n+    if (!parse_from_line(in.current_line())) {\n+      success = false;\n@@ -1099,5 +1097,0 @@\n-    c = *sp++;\n-  }\n-  token[pos++] = '\\0';\n-  if (!parse_line(token)) {\n-    success = false;\n@@ -1108,0 +1101,7 @@\n+bool CompilerOracle::parse_from_string(const char* str,\n+                                       CompilerOracle::\n+                                       parse_from_line_fn_t* parse_from_line) {\n+  MemoryInput input(str, strlen(str));\n+  return parse_from_input(&input, parse_from_line);\n+}\n+\n@@ -1110,0 +1110,8 @@\n+  \/\/ Register default compile commands first - any commands specified via CompileCommand will\n+  \/\/ supersede these default commands.\n+  for (int i = 0; default_compile_commands[i] != nullptr; i ++) {\n+    char* s = os::strdup(default_compile_commands[i]);\n+    success = CompilerOracle::parse_from_line_quietly(s);\n+    os::free(s);\n+    assert(success, \"default compile command \\\"%s\\\" failed to parse\", default_compile_commands[i]);\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":49,"deletions":41,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -123,0 +124,3 @@\n+ public:\n+  typedef bool parse_from_line_fn_t(char*);\n+\n@@ -128,0 +132,4 @@\n+  \/\/ The core parser.\n+  static bool parse_from_input(inputStream::Input* input,\n+                               parse_from_line_fn_t* parse_from_line);\n+\n@@ -180,1 +188,2 @@\n-  static bool parse_from_string(const char* option_string, bool (*parser)(char*));\n+  static bool parse_from_string(const char* option_string,\n+                                parse_from_line_fn_t* parser);\n@@ -182,0 +191,1 @@\n+  static bool parse_from_line_quietly(char* line);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,2 +133,1 @@\n-HeapWord* G1AllocRegion::new_alloc_region_and_allocate(size_t word_size,\n-                                                       bool force) {\n+HeapWord* G1AllocRegion::new_alloc_region_and_allocate(size_t word_size) {\n@@ -139,1 +138,1 @@\n-  HeapRegion* new_alloc_region = allocate_new_region(word_size, force);\n+  HeapRegion* new_alloc_region = allocate_new_region(word_size);\n@@ -261,3 +260,2 @@\n-HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size,\n-                                                    bool force) {\n-  return _g1h->new_mutator_alloc_region(word_size, force, _node_index);\n+HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size) {\n+  return _g1h->new_mutator_alloc_region(word_size, _node_index);\n@@ -347,3 +345,1 @@\n-HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size,\n-                                                 bool force) {\n-  assert(!force, \"not supported for GC alloc regions\");\n+HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,4 +86,2 @@\n-  \/\/ allocation. The force parameter will be passed on to\n-  \/\/ G1CollectedHeap::allocate_new_alloc_region() and tells it to try\n-  \/\/ to allocate a new region even if the max has been reached.\n-  HeapWord* new_alloc_region_and_allocate(size_t word_size, bool force);\n+  \/\/ allocation.\n+  HeapWord* new_alloc_region_and_allocate(size_t word_size);\n@@ -135,1 +133,1 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size, bool force) = 0;\n+  virtual HeapRegion* allocate_new_region(size_t word_size) = 0;\n@@ -175,6 +173,0 @@\n-  \/\/ Should be called to allocate a new region even if the max of this\n-  \/\/ type of regions has been reached. Should only be called if other\n-  \/\/ allocation attempts have failed and we are not holding a valid\n-  \/\/ active region.\n-  inline HeapWord* attempt_allocation_force(size_t word_size);\n-\n@@ -216,1 +208,1 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size, bool force);\n+  virtual HeapRegion* allocate_new_region(size_t word_size);\n@@ -252,1 +244,1 @@\n-  virtual HeapRegion* allocate_new_region(size_t word_size, bool force);\n+  virtual HeapRegion* allocate_new_region(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  HeapWord* result = new_alloc_region_and_allocate(desired_word_size, false \/* force *\/);\n+  HeapWord* result = new_alloc_region_and_allocate(desired_word_size);\n@@ -111,13 +111,0 @@\n-inline HeapWord* G1AllocRegion::attempt_allocation_force(size_t word_size) {\n-  assert_alloc_region(_alloc_region != nullptr, \"not initialized properly\");\n-\n-  trace(\"forcing alloc\", word_size, word_size);\n-  HeapWord* result = new_alloc_region_and_allocate(word_size, true \/* force *\/);\n-  if (result != nullptr) {\n-    trace(\"alloc forced\", word_size, word_size, word_size, result);\n-    return result;\n-  }\n-  trace(\"alloc forced failed\", word_size, word_size);\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.inline.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -121,1 +122,1 @@\n-    _g1h->hr_printer()->reuse(retained_region);\n+    G1HeapRegionPrinter::reuse(retained_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -124,2 +124,0 @@\n-  inline HeapWord* attempt_allocation_force(size_t word_size);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-inline HeapWord* G1Allocator::attempt_allocation_force(size_t word_size) {\n-  uint node_index = current_node_index();\n-  return mutator_alloc_region(node_index)->attempt_allocation_force(word_size);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-  size_t delta = pointer_delta(p, _offset_base, sizeof(uint8_t));\n+  \/\/ _offset_base can be \"negative\", so can't use pointer_delta().\n+  size_t delta = p - _offset_base;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -536,1 +536,1 @@\n-  ContainerPtr volatile* bucket_entry = howl->get_container_addr(bucket);\n+  ContainerPtr volatile* bucket_entry = howl->container_addr(bucket);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,2 +241,3 @@\n-  ContainerPtr _buckets[2];\n-  \/\/ Do not add class member variables beyond this point\n+  \/\/ VLA implementation.\n+  ContainerPtr _buckets[1];\n+  \/\/ Do not add class member variables beyond this point.\n@@ -249,0 +250,4 @@\n+  ContainerPtr at(EntryCountType index) const;\n+\n+  ContainerPtr const* buckets() const;\n+\n@@ -252,3 +257,1 @@\n-  ContainerPtr* get_container_addr(EntryCountType index) {\n-    return &_buckets[index];\n-  }\n+  ContainerPtr const* container_addr(EntryCountType index) const;\n@@ -256,1 +259,1 @@\n-  bool contains(uint card_idx, G1CardSetConfiguration* config);\n+  ContainerPtr* container_addr(EntryCountType index);\n@@ -258,0 +261,1 @@\n+  bool contains(uint card_idx, G1CardSetConfiguration* config);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -260,0 +260,18 @@\n+inline G1CardSetHowl::ContainerPtr const* G1CardSetHowl::container_addr(EntryCountType index) const {\n+  assert(index < _num_entries, \"precondition\");\n+  return buckets() + index;\n+}\n+\n+inline G1CardSetHowl::ContainerPtr* G1CardSetHowl::container_addr(EntryCountType index) {\n+  return const_cast<ContainerPtr*>(const_cast<const G1CardSetHowl*>(this)->container_addr(index));\n+}\n+\n+inline G1CardSetHowl::ContainerPtr G1CardSetHowl::at(EntryCountType index) const {\n+  return *container_addr(index);\n+}\n+\n+inline G1CardSetHowl::ContainerPtr const* G1CardSetHowl::buckets() const {\n+  const void* ptr = reinterpret_cast<const char*>(this) + header_size_in_bytes();\n+  return reinterpret_cast<ContainerPtr const*>(ptr);\n+}\n+\n@@ -266,1 +284,1 @@\n-    _buckets[i] = G1CardSetInlinePtr();\n+    *container_addr(i) = G1CardSetInlinePtr();\n@@ -268,1 +286,1 @@\n-      G1CardSetInlinePtr value(&_buckets[i], _buckets[i]);\n+      G1CardSetInlinePtr value(container_addr(i), at(i));\n@@ -276,1 +294,1 @@\n-  ContainerPtr* array_entry = get_container_addr(bucket);\n+  ContainerPtr* array_entry = container_addr(bucket);\n@@ -302,1 +320,1 @@\n-    iterate_cardset(_buckets[i], i, found, config);\n+    iterate_cardset(at(i), i, found, config);\n@@ -309,1 +327,1 @@\n-    found(&_buckets[i]);\n+    found(container_addr(i));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -328,1 +329,1 @@\n-    _hr_printer.alloc(hr);\n+    G1HeapRegionPrinter::alloc(hr);\n@@ -527,1 +528,1 @@\n-    _hr_printer.alloc(r);\n+    G1HeapRegionPrinter::alloc(r);\n@@ -713,2 +714,0 @@\n-private:\n-  G1HRPrinter* _hr_printer;\n@@ -718,1 +717,1 @@\n-    _hr_printer->post_compaction(hr);\n+    G1HeapRegionPrinter::post_compaction(hr);\n@@ -721,3 +720,0 @@\n-\n-  PostCompactionPrinterClosure(G1HRPrinter* hr_printer)\n-    : _hr_printer(hr_printer) { }\n@@ -731,2 +727,2 @@\n-  if (_hr_printer.is_active()) {\n-    PostCompactionPrinterClosure cl(hr_printer());\n+  if (G1HeapRegionPrinter::is_active()) {\n+    PostCompactionPrinterClosure cl;\n@@ -1155,1 +1151,0 @@\n-  _hr_printer(),\n@@ -2407,1 +2402,1 @@\n-  guarantee(!is_gc_active(), \"collection is not reentrant\");\n+  guarantee(!is_stw_gc_active(), \"collection is not reentrant\");\n@@ -2477,1 +2472,1 @@\n-  IsGCActiveMark active_gc_mark;\n+  IsSTWGCActiveMark active_gc_mark;\n@@ -2854,1 +2849,0 @@\n-                                                      bool force,\n@@ -2858,1 +2852,1 @@\n-  if (force || should_allocate) {\n+  if (should_allocate) {\n@@ -2865,1 +2859,1 @@\n-      _hr_printer.alloc(new_alloc_region, !should_allocate);\n+      G1HeapRegionPrinter::alloc(new_alloc_region);\n@@ -2881,1 +2875,1 @@\n-  _hr_printer.retire(alloc_region);\n+  G1HeapRegionPrinter::retire(alloc_region);\n@@ -2928,1 +2922,1 @@\n-    _hr_printer.alloc(new_alloc_region);\n+    G1HeapRegionPrinter::alloc(new_alloc_region);\n@@ -2949,1 +2943,1 @@\n-  _hr_printer.retire(alloc_region);\n+  G1HeapRegionPrinter::retire(alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"gc\/g1\/g1HRPrinter.hpp\"\n@@ -268,2 +267,0 @@\n-  G1HRPrinter _hr_printer;\n-\n@@ -471,1 +468,1 @@\n-  HeapRegion* new_mutator_alloc_region(size_t word_size, bool force, uint node_index);\n+  HeapRegion* new_mutator_alloc_region(size_t word_size, uint node_index);\n@@ -672,2 +669,0 @@\n-  G1HRPrinter* hr_printer() { return &_hr_printer; }\n-\n@@ -757,1 +752,1 @@\n-  \/\/ precondition: !is_gc_active()\n+  \/\/ precondition: !is_stw_gc_active()\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-  assert(!is_gc_active(), \"must not pin objects during a GC\");\n+  assert(!is_stw_gc_active(), \"must not pin objects during a GC pause\");\n@@ -277,1 +277,1 @@\n-  assert(!is_gc_active(), \"must not unpin objects during a GC\");\n+  assert(!is_stw_gc_active(), \"must not unpin objects during a GC pause\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -47,1 +47,1 @@\n-  _candidates.sort(compare);\n+  _candidates.sort(compare_gc_efficiency);\n@@ -97,1 +97,16 @@\n-int G1CollectionCandidateList::compare(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n+int G1CollectionCandidateList::compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n+  assert(ci1->_r != nullptr && ci2->_r != nullptr, \"Should not be!\");\n+\n+  double gc_eff1 = ci1->_gc_efficiency;\n+  double gc_eff2 = ci2->_gc_efficiency;\n+\n+  if (gc_eff1 > gc_eff2) {\n+    return -1;\n+  } else if (gc_eff1 < gc_eff2) {\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+int G1CollectionCandidateList::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -109,2 +124,2 @@\n-  double gc_eff1 = ci1->_gc_efficiency;\n-  double gc_eff2 = ci2->_gc_efficiency;\n+  size_t reclaimable1 = ci1->_r->reclaimable_bytes();\n+  size_t reclaimable2 = ci2->_r->reclaimable_bytes();\n@@ -112,1 +127,1 @@\n-  if (gc_eff1 > gc_eff2) {\n+  if (reclaimable1 > reclaimable2) {\n@@ -114,1 +129,1 @@\n-  } if (gc_eff1 < gc_eff2) {\n+  } else if (reclaimable1 < reclaimable2) {\n@@ -185,0 +200,11 @@\n+void G1CollectionSetCandidates::sort_marking_by_efficiency() {\n+  G1CollectionCandidateListIterator iter = _marking_regions.begin();\n+  for (; iter != _marking_regions.end(); ++iter) {\n+    HeapRegion* hr = (*iter)->_r;\n+    (*iter)->_gc_efficiency = hr->calc_gc_efficiency();\n+  }\n+  _marking_regions.sort_by_efficiency();\n+\n+  _marking_regions.verify();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -132,1 +131,3 @@\n-  static int compare(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n+  static int compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n+\n+  static int compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n@@ -216,0 +217,2 @@\n+  void sort_marking_by_efficiency();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-      _data[idx] = CandidateInfo(hr, hr->calc_gc_efficiency());\n+      _data[idx] = CandidateInfo(hr, 0.0);\n@@ -100,1 +100,1 @@\n-    void sort_by_efficiency() {\n+    void sort_by_reclaimable_bytes() {\n@@ -107,1 +107,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare_reclaimble_bytes);\n@@ -155,2 +155,1 @@\n-      assert(!r->rem_set()->is_updating(), \"must be\");\n-      if (!r->rem_set()->is_complete()) {\n+      if (!r->rem_set()->is_tracked()) {\n@@ -252,1 +251,1 @@\n-    _result.sort_by_efficiency();\n+    _result.sort_by_reclaimable_bytes();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -1320,1 +1321,1 @@\n-      _g1h->hr_printer()->cleanup(&_cleanup_list);\n+      G1HeapRegionPrinter::mark_reclaim(&_cleanup_list);\n@@ -1440,0 +1441,1 @@\n+\n@@ -1441,0 +1443,6 @@\n+\n+      if (_needs_remembered_set_rebuild) {\n+        \/\/ Prune rebuild candidates based on G1HeapWastePercent.\n+        \/\/ Improves rebuild time in addition to remembered set memory usage.\n+        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  IsGCActiveMark          _active;\n+  IsSTWGCActiveMark       _active;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/g1\/g1HeapRegionSet.hpp\"\n-#include \"gc\/g1\/g1HRPrinter.hpp\"\n-\n-void G1HRPrinter::cleanup(FreeRegionList* cleanup_list) {\n-  if (is_active()) {\n-    FreeRegionListIterator iter(cleanup_list);\n-    while (iter.more_available()) {\n-      HeapRegion* hr = iter.get_next();\n-      cleanup(hr);\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HRPrinter.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1HRPRINTER_HPP\n-#define SHARE_GC_G1_G1HRPRINTER_HPP\n-\n-#include \"gc\/g1\/g1HeapRegion.hpp\"\n-#include \"logging\/log.hpp\"\n-\n-#define SKIP_RETIRED_FULL_REGIONS 1\n-\n-class FreeRegionList;\n-\n-class G1HRPrinter {\n-\n-private:\n-\n-  \/\/ Print an action event.\n-  static void print(const char* action, HeapRegion* hr) {\n-    log_trace(gc, region)(\"G1HR %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                          action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n-  }\n-\n-public:\n-  \/\/ In some places we iterate over a list in order to generate output\n-  \/\/ for the list's elements. By exposing this we can avoid this\n-  \/\/ iteration if the printer is not active.\n-  bool is_active() { return log_is_enabled(Trace, gc, region); }\n-\n-  \/\/ The methods below are convenient wrappers for the print() method.\n-\n-  void alloc(HeapRegion* hr, bool force = false) {\n-    if (is_active()) {\n-      print((force) ? \"ALLOC-FORCE\" : \"ALLOC\", hr);\n-    }\n-  }\n-\n-  void retire(HeapRegion* hr) {\n-    if (is_active()) {\n-      if (!SKIP_RETIRED_FULL_REGIONS || hr->top() < hr->end()) {\n-        print(\"RETIRE\", hr);\n-      }\n-    }\n-  }\n-\n-  void reuse(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"REUSE\", hr);\n-    }\n-  }\n-\n-  void cset(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"CSET\", hr);\n-    }\n-  }\n-\n-  void evac_failure(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"EVAC-FAILURE\", hr);\n-    }\n-  }\n-\n-  void cleanup(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"CLEANUP\", hr);\n-    }\n-  }\n-\n-  void cleanup(FreeRegionList* free_list);\n-\n-  void post_compaction(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"POST-COMPACTION\", hr);\n-    }\n-  }\n-\n-  void commit(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"COMMIT\", hr);\n-    }\n-  }\n-\n-  void active(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"ACTIVE\", hr);\n-    }\n-  }\n-\n-  void inactive(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"INACTIVE\", hr);\n-    }\n-  }\n-\n-  void uncommit(HeapRegion* hr) {\n-    if (is_active()) {\n-      print(\"UNCOMMIT\", hr);\n-    }\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1HRPRINTER_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HRPrinter.hpp","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -173,1 +174,1 @@\n-    G1CollectedHeap::heap()->hr_printer()->commit(hr);\n+    G1HeapRegionPrinter::commit(hr);\n@@ -196,2 +197,1 @@\n-  G1HRPrinter* printer = G1CollectedHeap::heap()->hr_printer();\n-  if (printer->is_active()) {\n+  if (G1HeapRegionPrinter::is_active()) {\n@@ -202,1 +202,1 @@\n-      printer->uncommit(hr);\n+      G1HeapRegionPrinter::uncommit(hr);\n@@ -226,1 +226,1 @@\n-    G1CollectedHeap::heap()->hr_printer()->active(hr);\n+    G1HeapRegionPrinter::active(hr);\n@@ -253,1 +253,1 @@\n-    G1CollectedHeap::heap()->hr_printer()->inactive(hr);\n+    G1HeapRegionPrinter::inactive(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n+#include \"gc\/g1\/g1HeapRegionSet.hpp\"\n+\n+void G1HeapRegionPrinter::mark_reclaim(FreeRegionList* cleanup_list) {\n+  if (is_active()) {\n+    FreeRegionListIterator iter(cleanup_list);\n+    while (iter.more_available()) {\n+      HeapRegion* hr = iter.get_next();\n+      mark_reclaim(hr);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1HEAPREGIONPRINTER_HPP\n+#define SHARE_GC_G1_G1HEAPREGIONPRINTER_HPP\n+\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+\n+class FreeRegionList;\n+\n+class G1HeapRegionPrinter : public AllStatic {\n+\n+  \/\/ Print an action event.\n+  static void print(const char* action, HeapRegion* hr) {\n+    log_trace(gc, region)(\"G1HR %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n+                          action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n+  }\n+\n+  static void mark_reclaim(HeapRegion* hr) {\n+    print(\"MARK-RECLAIM\", hr);\n+  }\n+\n+public:\n+  \/\/ In some places we iterate over a list in order to generate output\n+  \/\/ for the list's elements. By exposing this we can avoid this\n+  \/\/ iteration if the printer is not active.\n+  static bool is_active() { return log_is_enabled(Trace, gc, region); }\n+\n+  \/\/ The methods below are convenient wrappers for the print() method.\n+\n+  static void alloc(HeapRegion* hr)                     { print(\"ALLOC\", hr); }\n+\n+  static void retire(HeapRegion* hr)                    { print(\"RETIRE\", hr); }\n+\n+  static void reuse(HeapRegion* hr)                     { print(\"REUSE\", hr); }\n+\n+  static void cset(HeapRegion* hr)                      { print(\"CSET\", hr); }\n+\n+  static void evac_failure(HeapRegion* hr)              { print(\"EVAC-FAILURE\", hr); }\n+\n+  static void mark_reclaim(FreeRegionList* free_list);\n+\n+  static void eager_reclaim(HeapRegion* hr)             { print(\"EAGER-RECLAIM\", hr); }\n+\n+  static void evac_reclaim(HeapRegion* hr)              { print(\"EVAC-RECLAIM\", hr); }\n+\n+  static void post_compaction(HeapRegion* hr)           { print(\"POST-COMPACTION\", hr); }\n+\n+  static void commit(HeapRegion* hr)                    { print(\"COMMIT\", hr); }\n+\n+  static void active(HeapRegion* hr)                    { print(\"ACTIVE\", hr); }\n+\n+  static void inactive(HeapRegion* hr)                  { print(\"INACTIVE\", hr); }\n+\n+  static void uncommit(HeapRegion* hr)                  { print(\"UNCOMMIT\", hr); }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1HEAPREGIONPRINTER_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n@@ -35,0 +33,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArenaFreeMemoryTask.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -646,1 +647,1 @@\n-      _g1h->hr_printer()->evac_failure(r);\n+      G1HeapRegionPrinter::evac_failure(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1313,1 +1313,1 @@\n-    G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), candidates());\n+    candidates()->sort_marking_by_efficiency();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,0 +187,2 @@\n+  G1CollectionSetCandidates* candidates() const;\n+\n@@ -189,1 +191,0 @@\n-  G1CollectionSetCandidates* candidates() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -1567,1 +1567,1 @@\n-  assert(!_g1h->is_gc_active(), \"Only call concurrently\");\n+  assert(!_g1h->is_stw_gc_active(), \"Only call concurrently\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  IsGCActiveMark x;\n+  IsSTWGCActiveMark x;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"gc\/g1\/g1HRPrinter.hpp\"\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -52,1 +52,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -56,0 +55,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -219,4 +219,0 @@\n-G1HRPrinter* G1YoungCollector::hr_printer() const {\n-  return _g1h->hr_printer();\n-}\n-\n@@ -267,2 +263,0 @@\n-private:\n-  G1HRPrinter* _hr_printer;\n@@ -270,2 +264,0 @@\n-  G1PrintCollectionSetClosure(G1HRPrinter* hr_printer) : HeapRegionClosure(), _hr_printer(hr_printer) { }\n-\n@@ -273,1 +265,1 @@\n-    _hr_printer->cset(r);\n+    G1HeapRegionPrinter::cset(r);\n@@ -289,2 +281,2 @@\n-  if (hr_printer()->is_active()) {\n-    G1PrintCollectionSetClosure cl(hr_printer());\n+  if (G1HeapRegionPrinter::is_active()) {\n+    G1PrintCollectionSetClosure cl;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-class G1HRPrinter;\n@@ -72,1 +71,0 @@\n-  G1HRPrinter* hr_printer() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1_globals.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n@@ -415,1 +416,1 @@\n-      _g1h->hr_printer()->cleanup(r);\n+      G1HeapRegionPrinter::eager_reclaim(r);\n@@ -763,1 +764,1 @@\n-    _g1h->hr_printer()->cleanup(r);\n+    G1HeapRegionPrinter::evac_reclaim(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,4 +82,1 @@\n-void MutableNUMASpace::mangle_unused_area_complete() {\n-  \/\/ This method should do nothing.\n-  \/\/ It can be called on a numa space during a full compaction.\n-}\n+\n@@ -89,12 +86,1 @@\n-void MutableNUMASpace::set_top_for_allocations(HeapWord* v) {\n-  assert(false, \"Do not mangle MutableNUMASpace's\");\n-}\n-void MutableNUMASpace::set_top_for_allocations() {\n-  \/\/ This method should do nothing.\n-}\n-void MutableNUMASpace::check_mangled_unused_area(HeapWord* limit) {\n-  \/\/ This method should do nothing.\n-}\n-void MutableNUMASpace::check_mangled_unused_area_complete() {\n-  \/\/ This method should do nothing.\n-}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  virtual void mangle_unused_area_complete() PRODUCT_RETURN;\n+\n@@ -178,4 +178,0 @@\n-  virtual void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  virtual void check_mangled_unused_area_complete() PRODUCT_RETURN;\n-  virtual void set_top_for_allocations(HeapWord* v) PRODUCT_RETURN;\n-  virtual void set_top_for_allocations() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n@@ -39,1 +38,0 @@\n-  _mangler(nullptr),\n@@ -48,5 +46,0 @@\n-  _mangler = new MutableSpaceMangler(this);\n-}\n-\n-MutableSpace::~MutableSpace() {\n-  delete _mangler;\n@@ -155,7 +148,0 @@\n-void MutableSpace::check_mangled_unused_area(HeapWord* limit) {\n-  mangler()->check_mangled_unused_area(limit);\n-}\n-\n-void MutableSpace::check_mangled_unused_area_complete() {\n-  mangler()->check_mangled_unused_area_complete();\n-}\n@@ -163,3 +149,0 @@\n-\/\/ Mangle only the unused space that has not previously\n-\/\/ been mangled and that has not been allocated since being\n-\/\/ mangled.\n@@ -167,5 +150,1 @@\n-  mangler()->mangle_unused_area();\n-}\n-\n-void MutableSpace::mangle_unused_area_complete() {\n-  mangler()->mangle_unused_area_complete();\n+  mangle_region(MemRegion(_top, _end));\n@@ -178,7 +157,0 @@\n-void MutableSpace::set_top_for_allocations(HeapWord* v) {\n-  mangler()->set_top_for_allocations(v);\n-}\n-\n-void MutableSpace::set_top_for_allocations() {\n-  mangler()->set_top_for_allocations(top());\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-class MutableSpaceMangler;\n-\n@@ -54,2 +52,0 @@\n-  \/\/ Helper for mangling unused space in debug builds\n-  MutableSpaceMangler* _mangler;\n@@ -63,2 +59,0 @@\n-  MutableSpaceMangler* mangler() { return _mangler; }\n-\n@@ -71,1 +65,1 @@\n-  virtual ~MutableSpace();\n+  virtual ~MutableSpace() = default;\n@@ -110,1 +104,0 @@\n-  \/\/ Methods used in mangling.  See descriptions under SpaceMangler.\n@@ -112,7 +105,1 @@\n-  virtual void mangle_unused_area_complete() PRODUCT_RETURN;\n-  virtual void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  virtual void check_mangled_unused_area_complete() PRODUCT_RETURN;\n-  virtual void set_top_for_allocations(HeapWord* v) PRODUCT_RETURN;\n-\n-  \/\/ Used to save the space's current top for later use during mangling.\n-  virtual void set_top_for_allocations() PRODUCT_RETURN;\n+  virtual void mangle_region(MemRegion mr) PRODUCT_RETURN;\n@@ -122,2 +109,0 @@\n-  virtual void mangle_region(MemRegion mr) PRODUCT_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -60,1 +60,2 @@\n-    size_t delta = pointer_delta(p, _offset_base, sizeof(uint8_t));\n+    \/\/ _offset_base can be \"negative\", so can't use pointer_delta().\n+    size_t delta = p - _offset_base;\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"code\/codeCache.hpp\"\n@@ -38,1 +37,0 @@\n-#include \"gc\/shared\/gcInitLogger.hpp\"\n@@ -462,1 +460,1 @@\n-  assert(!is_gc_active(), \"not reentrant\");\n+  assert(!is_stw_gc_active(), \"not reentrant\");\n@@ -846,18 +844,0 @@\n-#ifndef PRODUCT\n-void ParallelScavengeHeap::record_gen_tops_before_GC() {\n-  if (ZapUnusedHeapArea) {\n-    young_gen()->record_spaces_top();\n-    old_gen()->record_spaces_top();\n-  }\n-}\n-\n-void ParallelScavengeHeap::gen_mangle_unused_area() {\n-  if (ZapUnusedHeapArea) {\n-    young_gen()->eden_space()->mangle_unused_area();\n-    young_gen()->to_space()->mangle_unused_area();\n-    young_gen()->from_space()->mangle_unused_area();\n-    old_gen()->object_space()->mangle_unused_area();\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"gc\/parallel\/objectStartArray.hpp\"\n@@ -37,3 +36,0 @@\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -43,1 +39,0 @@\n-#include \"utilities\/ostream.hpp\"\n@@ -251,6 +246,0 @@\n-  \/\/ Save the tops of the spaces in all generations\n-  void record_gen_tops_before_GC() PRODUCT_RETURN;\n-\n-  \/\/ Mangle the unused parts of all spaces in the heap\n-  void gen_mangle_unused_area() PRODUCT_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"gc\/parallel\/psParallelCompact.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n@@ -379,7 +378,0 @@\n-\n-#ifndef PRODUCT\n-void PSOldGen::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  object_space()->set_top_for_allocations();\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -159,3 +159,0 @@\n-  \/\/ Debugging support\n-  \/\/ Save the tops of all spaces for later use during mangling.\n-  void record_spaces_top() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -966,2 +966,10 @@\n-    \/\/ Update top().  Must be done after clearing the bitmap and summary data.\n-    _space_info[id].publish_new_top();\n+    {\n+      MutableSpace* space = _space_info[id].space();\n+      HeapWord* top = space->top();\n+      HeapWord* new_top = _space_info[id].new_top();\n+      if (ZapUnusedHeapArea && new_top < top) {\n+        space->mangle_region(MemRegion(new_top, top));\n+      }\n+      \/\/ Update top().  Must be done after clearing the bitmap and summary data.\n+      space->set_top(new_top);\n+    }\n@@ -1010,4 +1018,0 @@\n-  if (ZapUnusedHeapArea) {\n-    heap->gen_mangle_unused_area();\n-  }\n-\n@@ -1273,1 +1277,1 @@\n-  assert(!heap->is_gc_active(), \"not reentrant\");\n+  assert(!heap->is_stw_gc_active(), \"not reentrant\");\n@@ -1275,1 +1279,1 @@\n-  IsGCActiveMark mark;\n+  IsSTWGCActiveMark mark;\n@@ -1310,5 +1314,0 @@\n-  if (ZapUnusedHeapArea) {\n-    \/\/ Save information needed to minimize mangling\n-    heap->record_gen_tops_before_GC();\n-  }\n-\n@@ -1472,4 +1471,0 @@\n-  if (ZapUnusedHeapArea) {\n-    old_gen->object_space()->check_mangled_unused_area_complete();\n-  }\n-\n@@ -1496,1 +1491,1 @@\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+    assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n@@ -1513,1 +1508,1 @@\n-  assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n@@ -1990,1 +1985,1 @@\n-  assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -87,1 +87,1 @@\n-  assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n@@ -118,1 +118,1 @@\n-  assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n@@ -235,1 +235,1 @@\n-  assert(!ParallelScavengeHeap::heap()->is_gc_active(), \"not reentrant\");\n+  assert(!ParallelScavengeHeap::heap()->is_stw_gc_active(), \"not reentrant\");\n@@ -239,1 +239,1 @@\n-  IsGCActiveMark mark;\n+  IsSTWGCActiveMark mark;\n@@ -267,1 +267,1 @@\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+    assert(ParallelScavengeHeap::heap()->is_stw_gc_active(), \"called outside gc\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/parallel\/psParallelCompact.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVMOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n@@ -625,14 +624,0 @@\n-\n-    \/\/ If not mangling the spaces, do some checking to verify that\n-    \/\/ the spaces are already mangled.\n-    \/\/ The spaces should be correctly mangled at this point so\n-    \/\/ do some checking here. Note that they are not being mangled\n-    \/\/ in the calls to initialize().\n-    \/\/ Must check mangling before the spaces are reshaped.  Otherwise,\n-    \/\/ the bottom or end of one space may have moved into an area\n-    \/\/ covered by another space and a failure of the check may\n-    \/\/ not correctly indicate which space is not properly mangled.\n-    HeapWord* limit = (HeapWord*) virtual_space()->high();\n-    eden_space()->check_mangled_unused_area(limit);\n-    from_space()->check_mangled_unused_area(limit);\n-      to_space()->check_mangled_unused_area(limit);\n@@ -836,9 +821,0 @@\n-\n-#ifndef PRODUCT\n-void PSYoungGen::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  eden_space()->set_top_for_allocations();\n-  from_space()->set_top_for_allocations();\n-  to_space()->set_top_for_allocations();\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -155,2 +155,0 @@\n-\n-  void record_spaces_top() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -229,0 +229,1 @@\n+    _promotion_failed(false),\n@@ -333,15 +334,0 @@\n-  \/\/ If not clearing the spaces, do some checking to verify that\n-  \/\/ the space are already mangled.\n-  if (!clear_space) {\n-    \/\/ Must check mangling before the spaces are reshaped.  Otherwise,\n-    \/\/ the bottom or end of one space may have moved into another\n-    \/\/ a failure of the check may not correctly indicate which space\n-    \/\/ is not properly mangled.\n-    if (ZapUnusedHeapArea) {\n-      HeapWord* limit = (HeapWord*) _virtual_space.high();\n-      eden()->check_mangled_unused_area(limit);\n-      from()->check_mangled_unused_area(limit);\n-        to()->check_mangled_unused_area(limit);\n-    }\n-  }\n-\n@@ -643,6 +629,1 @@\n-void DefNewGeneration::collect(bool   full,\n-                               bool   clear_all_soft_refs,\n-                               size_t size,\n-                               bool   is_tlab) {\n-  assert(full || size > 0, \"otherwise we don't want to collect\");\n-\n+bool DefNewGeneration::collect(bool clear_all_soft_refs) {\n@@ -651,8 +632,0 @@\n-  \/\/ If the next generation is too full to accommodate promotion\n-  \/\/ from this generation, pass on collection; let the next generation\n-  \/\/ do it.\n-  if (!collection_attempt_is_safe()) {\n-    log_trace(gc)(\":: Collection attempt not safe ::\");\n-    heap->set_incremental_collection_failed(); \/\/ Slight lie: we did not even attempt one\n-    return;\n-  }\n@@ -732,10 +705,0 @@\n-    if (ZapUnusedHeapArea) {\n-      \/\/ This is now done here because of the piece-meal mangling which\n-      \/\/ can check for valid mangling at intermediate points in the\n-      \/\/ collection(s).  When a young collection fails to collect\n-      \/\/ sufficient space resizing of the young generation can occur\n-      \/\/ an redistribute the spaces in the young generation.  Mangle\n-      \/\/ here so that unzapped regions don't get distributed to\n-      \/\/ other spaces.\n-      to()->mangle_unused_area();\n-    }\n@@ -776,0 +739,2 @@\n+\n+  return !_promotion_failed;\n@@ -905,1 +870,1 @@\n-    to()->mangle_unused_area_complete();\n+    to()->mangle_unused_area();\n@@ -963,6 +928,0 @@\n-  if (ZapUnusedHeapArea) {\n-    eden()->check_mangled_unused_area_complete();\n-    from()->check_mangled_unused_area_complete();\n-    to()->check_mangled_unused_area_complete();\n-  }\n-\n@@ -974,7 +933,0 @@\n-void DefNewGeneration::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  eden()->set_top_for_allocations();\n-  to()->set_top_for_allocations();\n-  from()->set_top_for_allocations();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":6,"deletions":54,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  virtual bool should_allocate(size_t word_size, bool is_tlab) {\n+  bool should_allocate(size_t word_size, bool is_tlab) {\n@@ -213,0 +213,1 @@\n+    assert(word_size != 0, \"precondition\");\n@@ -216,1 +217,0 @@\n-    const bool non_zero      = word_size > 0;\n@@ -223,1 +223,0 @@\n-                  non_zero   &&\n@@ -236,3 +235,0 @@\n-  \/\/ Save the tops for eden, from, and to\n-  void record_spaces_top();\n-\n@@ -256,4 +252,1 @@\n-  virtual void collect(bool   full,\n-                       bool   clear_all_soft_refs,\n-                       size_t size,\n-                       bool   is_tlab);\n+  bool collect(bool clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -73,11 +73,0 @@\n-\n-void Generation::print_summary_info_on(outputStream* st) {\n-  StatRecord* sr = stat_record();\n-  double time = sr->accumulated_time.seconds();\n-  st->print_cr(\"Accumulated %s generation GC time %3.7f secs, \"\n-               \"%u GC's, avg GC time %3.7f\",\n-               SerialHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n-               time,\n-               sr->invocations,\n-               sr->invocations > 0 ? time \/ sr->invocations : 0.0);\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -110,14 +110,0 @@\n-  \/\/ Returns \"true\" iff this generation should be used to allocate an\n-  \/\/ object of the given size.  Young generations might\n-  \/\/ wish to exclude very large objects, for example, since, if allocated\n-  \/\/ often, they would greatly increase the frequency of young-gen\n-  \/\/ collection.\n-  virtual bool should_allocate(size_t word_size, bool is_tlab) {\n-    bool result = false;\n-    size_t overflow_limit = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-    if (!is_tlab || supports_tlab_allocation()) {\n-      result = (word_size > 0) && (word_size < overflow_limit);\n-    }\n-    return result;\n-  }\n-\n@@ -134,25 +120,0 @@\n-  \/\/ Returns \"true\" iff collect() should subsequently be called on this\n-  \/\/ this generation. See comment below.\n-  \/\/ This is a generic implementation which can be overridden.\n-  \/\/\n-  \/\/ Note: in the current (1.4) implementation, when serialHeap's\n-  \/\/ incremental_collection_will_fail flag is set, all allocations are\n-  \/\/ slow path (the only fast-path place to allocate is DefNew, which\n-  \/\/ will be full if the flag is set).\n-  \/\/ Thus, older generations which collect younger generations should\n-  \/\/ test this flag and collect if it is set.\n-  virtual bool should_collect(bool   full,\n-                              size_t word_size,\n-                              bool   is_tlab) {\n-    return (full || should_allocate(word_size, is_tlab));\n-  }\n-\n-  \/\/ Perform a garbage collection.\n-  \/\/ If full is true attempt a full garbage collection of this generation.\n-  \/\/ Otherwise, attempting to (at least) free enough space to support an\n-  \/\/ allocation of the given \"word_size\".\n-  virtual void collect(bool   full,\n-                       bool   clear_all_soft_refs,\n-                       size_t word_size,\n-                       bool   is_tlab) = 0;\n-\n@@ -175,9 +136,0 @@\n-  struct StatRecord {\n-    int invocations;\n-    elapsedTimer accumulated_time;\n-    StatRecord() :\n-      invocations(0),\n-      accumulated_time(elapsedTimer()) {}\n-  };\n-private:\n-  StatRecord _stat_record;\n@@ -185,4 +137,0 @@\n-  StatRecord* stat_record() { return &_stat_record; }\n-\n-  virtual void print_summary_info_on(outputStream* st);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-  size_t delta = pointer_delta(p, _offset_base, sizeof(uint8_t));\n+  \/\/ _offset_base can be \"negative\", so can't use pointer_delta().\n+  size_t delta = p - _offset_base;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -369,3 +369,4 @@\n-      space->set_top(get_compaction_top(i));\n-      if (ZapUnusedHeapArea) {\n-        space->mangle_unused_area();\n+      HeapWord* new_top = get_compaction_top(i);\n+      space->set_top(new_top);\n+      if (ZapUnusedHeapArea && new_top < top) {\n+        space->mangle_unused_area(MemRegion(new_top, top));\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-    Generation *young = _young_gen;\n+    DefNewGeneration *young = _young_gen;\n@@ -382,1 +382,1 @@\n-    VM_GenCollectForAllocation op(size, is_tlab, gc_count_before);\n+    VM_SerialCollectForAllocation op(size, is_tlab, gc_count_before);\n@@ -435,14 +435,6 @@\n-void SerialHeap::collect_generation(Generation* gen, bool full, size_t size,\n-                                    bool is_tlab, bool run_verification, bool clear_soft_refs) {\n-  FormatBuffer<> title(\"Collect gen: %s\", gen->short_name());\n-  GCTraceTime(Trace, gc, phases) t1(title);\n-  TraceCollectorStats tcs(gen->counters());\n-  TraceMemoryManagerStats tmms(gen->gc_manager(), gc_cause(), heap()->is_young_gen(gen) ? \"end of minor GC\" : \"end of major GC\");\n-\n-  gen->stat_record()->invocations++;\n-  gen->stat_record()->accumulated_time.start();\n-\n-  \/\/ Must be done anew before each collection because\n-  \/\/ a previous collection will do mangling and will\n-  \/\/ change top of some spaces.\n-  record_gen_tops_before_GC();\n+bool SerialHeap::is_young_gc_safe() const {\n+  if (!_young_gen->to()->is_empty()) {\n+    return false;\n+  }\n+  return _old_gen->promotion_attempt_is_safe(_young_gen->used());\n+}\n@@ -450,1 +442,13 @@\n-  log_trace(gc)(\"%s invoke=%d size=\" SIZE_FORMAT, heap()->is_young_gen(gen) ? \"Young\" : \"Old\", gen->stat_record()->invocations, size * HeapWordSize);\n+bool SerialHeap::do_young_collection(bool clear_soft_refs) {\n+  if (!is_young_gc_safe()) {\n+    return false;\n+  }\n+  IsSTWGCActiveMark gc_active_mark;\n+  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n+  GCIdMark gc_id_mark;\n+  GCTraceCPUTime tcpu(_young_gen->gc_tracer());\n+  GCTraceTime(Info, gc) t(\"Pause Young\", nullptr, gc_cause(), true);\n+  TraceCollectorStats tcs(_young_gen->counters());\n+  TraceMemoryManagerStats tmms(_young_gen->gc_manager(), gc_cause(), \"end of minor GC\");\n+  print_heap_before_gc();\n+  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n@@ -452,1 +456,4 @@\n-  if (run_verification && VerifyBeforeGC) {\n+  increment_total_collections(false);\n+  const bool should_verify = total_collections() >= VerifyGCStartAt;\n+  if (should_verify && VerifyBeforeGC) {\n+    prepare_for_verify();\n@@ -455,0 +462,1 @@\n+  gc_prologue(false);\n@@ -457,3 +465,1 @@\n-  \/\/ Do collection work\n-  {\n-    save_marks();   \/\/ save marks for all gens\n+  save_marks();\n@@ -461,2 +467,1 @@\n-    gen->collect(full, clear_soft_refs, size, is_tlab);\n-  }\n+  bool result = _young_gen->collect(clear_soft_refs);\n@@ -466,3 +471,1 @@\n-  gen->stat_record()->accumulated_time.stop();\n-\n-  update_gc_stats(gen, full);\n+  update_gc_stats(_young_gen, false);\n@@ -470,1 +473,1 @@\n-  if (run_verification && VerifyAfterGC) {\n+  if (should_verify && VerifyAfterGC) {\n@@ -473,86 +476,0 @@\n-}\n-\n-void SerialHeap::do_collection(bool full,\n-                               bool clear_all_soft_refs,\n-                               size_t size,\n-                               bool is_tlab,\n-                               GenerationType max_generation) {\n-  ResourceMark rm;\n-  DEBUG_ONLY(Thread* my_thread = Thread::current();)\n-\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n-  assert(my_thread->is_VM_thread(), \"only VM thread\");\n-  assert(Heap_lock->is_locked(),\n-         \"the requesting thread should have the Heap_lock\");\n-  guarantee(!is_gc_active(), \"collection is not reentrant\");\n-\n-  if (GCLocker::check_active_before_gc()) {\n-    return; \/\/ GC is disabled (e.g. JNI GetXXXCritical operation)\n-  }\n-\n-  const bool do_clear_all_soft_refs = clear_all_soft_refs ||\n-                          soft_ref_policy()->should_clear_all_soft_refs();\n-\n-  ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());\n-\n-  IsGCActiveMark active_gc_mark;\n-\n-  bool complete = full && (max_generation == OldGen);\n-  bool old_collects_young = complete;\n-  bool do_young_collection = !old_collects_young && _young_gen->should_collect(full, size, is_tlab);\n-\n-  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n-\n-  bool run_verification = total_collections() >= VerifyGCStartAt;\n-  bool prepared_for_verification = false;\n-  bool do_full_collection = false;\n-\n-  if (do_young_collection) {\n-    GCIdMark gc_id_mark;\n-    GCTraceCPUTime tcpu(((DefNewGeneration*)_young_gen)->gc_tracer());\n-    GCTraceTime(Info, gc) t(\"Pause Young\", nullptr, gc_cause(), true);\n-\n-    print_heap_before_gc();\n-\n-    if (run_verification && VerifyBeforeGC) {\n-      prepare_for_verify();\n-      prepared_for_verification = true;\n-    }\n-\n-    gc_prologue(complete);\n-    increment_total_collections(complete);\n-\n-    collect_generation(_young_gen,\n-                       full,\n-                       size,\n-                       is_tlab,\n-                       run_verification,\n-                       do_clear_all_soft_refs);\n-\n-    if (size > 0 && (!is_tlab || _young_gen->supports_tlab_allocation()) &&\n-        size * HeapWordSize <= _young_gen->unsafe_max_alloc_nogc()) {\n-      \/\/ Allocation request was met by young GC.\n-      size = 0;\n-    }\n-\n-    \/\/ Ask if young collection is enough. If so, do the final steps for young collection,\n-    \/\/ and fallthrough to the end.\n-    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n-    if (!do_full_collection) {\n-      \/\/ Adjust generation sizes.\n-      _young_gen->compute_new_size();\n-\n-      print_heap_change(pre_gc_values);\n-\n-      \/\/ Track memory usage and detect low memory after GC finishes\n-      MemoryService::track_memory_usage();\n-\n-      gc_epilogue(complete);\n-    }\n-\n-    print_heap_after_gc();\n-\n-  } else {\n-    \/\/ No young collection, ask if we need to perform Full collection.\n-    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n-  }\n@@ -560,4 +477,1 @@\n-  if (do_full_collection) {\n-    GCIdMark gc_id_mark;\n-    GCTraceCPUTime tcpu(SerialFullGC::gc_tracer());\n-    GCTraceTime(Info, gc) t(\"Pause Full\", nullptr, gc_cause(), true);\n+  _young_gen->compute_new_size();\n@@ -565,1 +479,1 @@\n-    print_heap_before_gc();\n+  print_heap_change(pre_gc_values);\n@@ -567,3 +481,2 @@\n-    if (!prepared_for_verification && run_verification && VerifyBeforeGC) {\n-      prepare_for_verify();\n-    }\n+  \/\/ Track memory usage and detect low memory after GC finishes\n+  MemoryService::track_memory_usage();\n@@ -571,4 +484,1 @@\n-    if (!do_young_collection) {\n-      gc_prologue(complete);\n-      increment_total_collections(complete);\n-    }\n+  gc_epilogue(false);\n@@ -576,6 +486,1 @@\n-    \/\/ Accounting quirk: total full collections would be incremented when \"complete\"\n-    \/\/ is set, by calling increment_total_collections above. However, we also need to\n-    \/\/ account Full collections that had \"complete\" unset.\n-    if (!complete) {\n-      increment_total_full_collections();\n-    }\n+  print_heap_after_gc();\n@@ -583,46 +488,1 @@\n-    CodeCache::on_gc_marking_cycle_start();\n-\n-    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n-                              false \/* unregister_nmethods_during_purge *\/,\n-                              false \/* lock_nmethod_free_separately *\/);\n-\n-    collect_generation(_old_gen,\n-                       full,\n-                       size,\n-                       is_tlab,\n-                       run_verification,\n-                       do_clear_all_soft_refs);\n-\n-    CodeCache::on_gc_marking_cycle_finish();\n-    CodeCache::arm_all_nmethods();\n-\n-    \/\/ Adjust generation sizes.\n-    _old_gen->compute_new_size();\n-    _young_gen->compute_new_size();\n-\n-    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-    DEBUG_ONLY(MetaspaceUtils::verify();)\n-\n-    \/\/ Need to clear claim bits for the next mark.\n-    ClassLoaderDataGraph::clear_claimed_marks();\n-\n-    \/\/ Resize the metaspace capacity after full collections\n-    MetaspaceGC::compute_new_size();\n-\n-    print_heap_change(pre_gc_values);\n-\n-    \/\/ Track memory usage and detect low memory after GC finishes\n-    MemoryService::track_memory_usage();\n-\n-    \/\/ Need to tell the epilogue code we are done with Full GC, regardless what was\n-    \/\/ the initial value for \"complete\" flag.\n-    gc_epilogue(true);\n-\n-    print_heap_after_gc();\n-  }\n-}\n-\n-bool SerialHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,\n-                                           SerialHeap::GenerationType max_gen) const {\n-  return max_gen == OldGen && _old_gen->should_collect(full, size, is_tlab);\n+  return result;\n@@ -652,1 +512,2 @@\n-  GCCauseSetter x(this, GCCause::_allocation_failure);\n+  assert(size != 0, \"precondition\");\n+\n@@ -655,1 +516,1 @@\n-  assert(size != 0, \"Precondition violated\");\n+  GCLocker::check_active_before_gc();\n@@ -663,18 +524,0 @@\n-  } else if (!incremental_collection_will_fail(false \/* don't consult_young *\/)) {\n-    \/\/ Do an incremental collection.\n-    do_collection(false,                     \/\/ full\n-                  false,                     \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  SerialHeap::OldGen); \/\/ max_generation\n-  } else {\n-    log_trace(gc)(\" :: Trying full because partial may fail :: \");\n-    \/\/ Try a full collection; see delta for bug id 6266275\n-    \/\/ for the original code and why this has been simplified\n-    \/\/ with from-space allocation criteria modified and\n-    \/\/ such allocation moved out of the safepoint path.\n-    do_collection(true,                      \/\/ full\n-                  false,                     \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  SerialHeap::OldGen); \/\/ max_generation\n@@ -683,1 +526,3 @@\n-  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n+  \/\/ If young-gen can handle this allocation, attempt young-gc firstly.\n+  bool should_run_young_gc = _young_gen->should_allocate(size, is_tlab);\n+  collect_at_safepoint(!should_run_young_gc);\n@@ -685,0 +530,1 @@\n+  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n@@ -686,1 +532,0 @@\n-    assert(is_in_reserved(result), \"result not in heap\");\n@@ -703,6 +548,2 @@\n-\n-    do_collection(true,                      \/\/ full\n-                  true,                      \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  SerialHeap::OldGen); \/\/ max_generation\n+    const bool clear_all_soft_refs = true;\n+    do_full_collection_no_gc_locker(clear_all_soft_refs);\n@@ -713,1 +554,5 @@\n-    assert(is_in_reserved(result), \"result not in heap\");\n+    return result;\n+  }\n+  \/\/ The previous full-gc can shrink the heap, so re-expand it.\n+  result = expand_heap_and_allocate(size, is_tlab);\n+  if (result != nullptr) {\n@@ -789,0 +634,22 @@\n+void SerialHeap::try_collect_at_safepoint(bool full) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+  if (GCLocker::check_active_before_gc()) {\n+    return;\n+  }\n+  collect_at_safepoint(full);\n+}\n+\n+void SerialHeap::collect_at_safepoint(bool full) {\n+  assert(!GCLocker::is_active(), \"precondition\");\n+  bool clear_soft_refs = must_clear_all_soft_refs();\n+\n+  if (!full) {\n+    bool success = do_young_collection(clear_soft_refs);\n+    if (success) {\n+      return;\n+    }\n+    \/\/ Upgrade to Full-GC if young-gc fails\n+  }\n+  do_full_collection_no_gc_locker(clear_soft_refs);\n+}\n+\n@@ -812,4 +679,0 @@\n-  const GenerationType max_generation = should_run_young_gc\n-                                      ? YoungGen\n-                                      : OldGen;\n-\n@@ -817,2 +680,4 @@\n-    VM_GenCollectFull op(gc_count_before, full_gc_count_before,\n-                         cause, max_generation);\n+    VM_SerialGCCollect op(!should_run_young_gc,\n+                          gc_count_before,\n+                          full_gc_count_before,\n+                          cause);\n@@ -841,1 +706,4 @@\n-   do_full_collection(clear_all_soft_refs, OldGen);\n+  if (GCLocker::check_active_before_gc()) {\n+    return;\n+  }\n+  do_full_collection_no_gc_locker(clear_all_soft_refs);\n@@ -844,18 +712,71 @@\n-void SerialHeap::do_full_collection(bool clear_all_soft_refs,\n-                                    GenerationType last_generation) {\n-  do_collection(true,                   \/\/ full\n-                clear_all_soft_refs,    \/\/ clear_all_soft_refs\n-                0,                      \/\/ size\n-                false,                  \/\/ is_tlab\n-                last_generation);       \/\/ last_generation\n-  \/\/ Hack XXX FIX ME !!!\n-  \/\/ A scavenge may not have been attempted, or may have\n-  \/\/ been attempted and failed, because the old gen was too full\n-  if (gc_cause() == GCCause::_gc_locker && incremental_collection_failed()) {\n-    log_debug(gc, jni)(\"GC locker: Trying a full collection because scavenge failed\");\n-    \/\/ This time allow the old gen to be collected as well\n-    do_collection(true,                \/\/ full\n-                  clear_all_soft_refs, \/\/ clear_all_soft_refs\n-                  0,                   \/\/ size\n-                  false,               \/\/ is_tlab\n-                  OldGen);             \/\/ last_generation\n+void SerialHeap::do_full_collection_no_gc_locker(bool clear_all_soft_refs) {\n+  IsSTWGCActiveMark gc_active_mark;\n+  SvcGCMarker sgcm(SvcGCMarker::FULL);\n+  GCIdMark gc_id_mark;\n+  GCTraceCPUTime tcpu(SerialFullGC::gc_tracer());\n+  GCTraceTime(Info, gc) t(\"Pause Full\", nullptr, gc_cause(), true);\n+  TraceCollectorStats tcs(_old_gen->counters());\n+  TraceMemoryManagerStats tmms(_old_gen->gc_manager(), gc_cause(), \"end of major GC\");\n+  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n+  print_heap_before_gc();\n+\n+  increment_total_collections(true);\n+  const bool should_verify = total_collections() >= VerifyGCStartAt;\n+  if (should_verify && VerifyBeforeGC) {\n+    prepare_for_verify();\n+    Universe::verify(\"Before GC\");\n+  }\n+\n+  gc_prologue(true);\n+  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());\n+  CodeCache::on_gc_marking_cycle_start();\n+  ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                            false \/* unregister_nmethods_during_purge *\/,\n+                            false \/* lock_nmethod_free_separately *\/);\n+\n+  STWGCTimer* gc_timer = SerialFullGC::gc_timer();\n+  gc_timer->register_gc_start();\n+\n+  SerialOldTracer* gc_tracer = SerialFullGC::gc_tracer();\n+  gc_tracer->report_gc_start(gc_cause(), gc_timer->gc_start());\n+\n+  pre_full_gc_dump(gc_timer);\n+\n+  SerialFullGC::invoke_at_safepoint(clear_all_soft_refs);\n+\n+  post_full_gc_dump(gc_timer);\n+\n+  gc_timer->register_gc_end();\n+\n+  gc_tracer->report_gc_end(gc_timer->gc_end(), gc_timer->time_partitions());\n+  CodeCache::on_gc_marking_cycle_finish();\n+  CodeCache::arm_all_nmethods();\n+  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::update_pointers());\n+\n+  \/\/ Adjust generation sizes.\n+  _old_gen->compute_new_size();\n+  _young_gen->compute_new_size();\n+\n+  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+  DEBUG_ONLY(MetaspaceUtils::verify();)\n+\n+  \/\/ Need to clear claim bits for the next mark.\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n+  \/\/ Resize the metaspace capacity after full collections\n+  MetaspaceGC::compute_new_size();\n+\n+  print_heap_change(pre_gc_values);\n+\n+  \/\/ Track memory usage and detect low memory after GC finishes\n+  MemoryService::track_memory_usage();\n+\n+  \/\/ Need to tell the epilogue code we are done with Full GC, regardless what was\n+  \/\/ the initial value for \"complete\" flag.\n+  gc_epilogue(true);\n+\n+  print_heap_after_gc();\n+\n+  if (should_verify && VerifyAfterGC) {\n+    Universe::verify(\"After GC\");\n@@ -985,5 +906,1 @@\n-  if (log_is_enabled(Debug, gc, heap, exit)) {\n-    LogStreamHandle(Debug, gc, heap, exit) lsh;\n-    _young_gen->print_summary_info_on(&lsh);\n-    _old_gen->print_summary_info_on(&lsh);\n-  }\n+ \/\/ Does nothing\n@@ -1041,9 +958,0 @@\n-\n-#ifndef PRODUCT\n-void SerialHeap::record_gen_tops_before_GC() {\n-  if (ZapUnusedHeapArea) {\n-    _young_gen->record_spaces_top();\n-    _old_gen->record_spaces_top();\n-  }\n-}\n-#endif  \/\/ not PRODUCT\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":153,"deletions":245,"binary":false,"changes":398,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-  friend class VM_GenCollectForAllocation;\n-  friend class VM_GenCollectFull;\n@@ -90,1 +88,1 @@\n-private:\n+\n@@ -101,3 +99,1 @@\n-  \/\/ Collects the given generation.\n-  void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,\n-                          bool run_verification, bool clear_soft_refs);\n+  bool do_young_collection(bool clear_soft_refs);\n@@ -110,1 +106,0 @@\n-private:\n@@ -119,16 +114,0 @@\n-  \/\/ Helper function for two callbacks below.\n-  \/\/ Considers collection of the first max_level+1 generations.\n-  void do_collection(bool           full,\n-                     bool           clear_all_soft_refs,\n-                     size_t         size,\n-                     bool           is_tlab,\n-                     GenerationType max_generation);\n-\n-  \/\/ Callback from VM_GenCollectForAllocation operation.\n-  \/\/ This function does everything necessary\/possible to satisfy an\n-  \/\/ allocation request that failed in the youngest generation that should\n-  \/\/ have handled it (including collection, expansion, etc.)\n-  HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);\n-\n-  \/\/ Callback from VM_GenCollectFull operation.\n-  \/\/ Perform a full collection of the first max_level+1 generations.\n@@ -136,1 +115,3 @@\n-  void do_full_collection(bool clear_all_soft_refs, GenerationType max_generation);\n+  void do_full_collection_no_gc_locker(bool clear_all_soft_refs);\n+\n+  void collect_at_safepoint(bool full);\n@@ -142,0 +123,2 @@\n+  bool is_young_gc_safe() const;\n+\n@@ -162,0 +145,9 @@\n+  \/\/ Callback from VM_SerialCollectForAllocation operation.\n+  \/\/ This function does everything necessary\/possible to satisfy an\n+  \/\/ allocation request that failed in the youngest generation that should\n+  \/\/ have handled it (including collection, expansion, etc.)\n+  HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);\n+\n+  \/\/ Callback from VM_SerialGCCollect.\n+  void try_collect_at_safepoint(bool full);\n+\n@@ -305,7 +297,0 @@\n-  \/\/ Save the tops of the spaces in all generations\n-  void record_gen_tops_before_GC() PRODUCT_RETURN;\n-\n-  \/\/ Return true if we need to perform full collection.\n-  bool should_do_full_collection(size_t size, bool full,\n-                                 bool is_tlab, GenerationType max_gen) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":16,"deletions":31,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -29,3 +29,1 @@\n-void VM_GenCollectForAllocation::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n-\n+void VM_SerialCollectForAllocation::doit() {\n@@ -42,3 +40,1 @@\n-void VM_GenCollectFull::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::FULL);\n-\n+void VM_SerialGCCollect::doit() {\n@@ -47,1 +43,1 @@\n-  gch->do_full_collection(gch->must_clear_all_soft_refs(), _max_generation);\n+  gch->try_collect_at_safepoint(_full);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialVMOperations.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-class VM_GenCollectForAllocation : public VM_CollectForAllocation {\n+class VM_SerialCollectForAllocation : public VM_CollectForAllocation {\n@@ -35,3 +35,3 @@\n-  VM_GenCollectForAllocation(size_t word_size,\n-                             bool tlab,\n-                             uint gc_count_before)\n+  VM_SerialCollectForAllocation(size_t word_size,\n+                                bool tlab,\n+                                uint gc_count_before)\n@@ -42,2 +42,1 @@\n-  ~VM_GenCollectForAllocation()  {}\n-  virtual VMOp_Type type() const { return VMOp_GenCollectForAllocation; }\n+  virtual VMOp_Type type() const { return VMOp_SerialCollectForAllocation; }\n@@ -49,3 +48,1 @@\n-class VM_GenCollectFull: public VM_GC_Operation {\n- private:\n-  SerialHeap::GenerationType _max_generation;\n+class VM_SerialGCCollect: public VM_GC_Operation {\n@@ -53,9 +50,7 @@\n-  VM_GenCollectFull(uint gc_count_before,\n-                    uint full_gc_count_before,\n-                    GCCause::Cause gc_cause,\n-                    SerialHeap::GenerationType max_generation)\n-    : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before,\n-                      max_generation != SerialHeap::YoungGen \/* full *\/),\n-      _max_generation(max_generation) { }\n-  ~VM_GenCollectFull() {}\n-  virtual VMOp_Type type() const { return VMOp_GenCollectFull; }\n+  VM_SerialGCCollect(bool full,\n+                     uint gc_count_before,\n+                     uint full_gc_count_before,\n+                     GCCause::Cause gc_cause)\n+    : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, full) {}\n+\n+  virtual VMOp_Type type() const { return VMOp_SerialGCCollect; }\n","filename":"src\/hotspot\/share\/gc\/serial\/serialVMOperations.hpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-      MemRegion mangle_region(space()->end(),\n-      (HeapWord*)_virtual_space.high());\n+      MemRegion mangle_region(space()->end(), (HeapWord*)_virtual_space.high());\n@@ -347,31 +346,0 @@\n-bool TenuredGeneration::should_collect(bool  full,\n-                                       size_t size,\n-                                       bool   is_tlab) {\n-  \/\/ This should be one big conditional or (||), but I want to be able to tell\n-  \/\/ why it returns what it returns (without re-evaluating the conditionals\n-  \/\/ in case they aren't idempotent), so I'm doing it this way.\n-  \/\/ DeMorgan says it's okay.\n-  if (full) {\n-    log_trace(gc)(\"TenuredGeneration::should_collect: because full\");\n-    return true;\n-  }\n-  if (should_allocate(size, is_tlab)) {\n-    log_trace(gc)(\"TenuredGeneration::should_collect: because should_allocate(\" SIZE_FORMAT \")\", size);\n-    return true;\n-  }\n-  \/\/ If we don't have very much free space.\n-  \/\/ XXX: 10000 should be a percentage of the capacity!!!\n-  if (free() < 10000) {\n-    log_trace(gc)(\"TenuredGeneration::should_collect: because free(): \" SIZE_FORMAT, free());\n-    return true;\n-  }\n-  \/\/ If we had to expand to accommodate promotions from the young generation\n-  if (_capacity_at_prologue < capacity()) {\n-    log_trace(gc)(\"TenuredGeneration::should_collect: because_capacity_at_prologue: \" SIZE_FORMAT \" < capacity(): \" SIZE_FORMAT,\n-        _capacity_at_prologue, capacity());\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n@@ -456,23 +424,0 @@\n-void TenuredGeneration::collect(bool   full,\n-                                bool   clear_all_soft_refs,\n-                                size_t size,\n-                                bool   is_tlab) {\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  STWGCTimer* gc_timer = SerialFullGC::gc_timer();\n-  gc_timer->register_gc_start();\n-\n-  SerialOldTracer* gc_tracer = SerialFullGC::gc_tracer();\n-  gc_tracer->report_gc_start(gch->gc_cause(), gc_timer->gc_start());\n-\n-  gch->pre_full_gc_dump(gc_timer);\n-\n-  SerialFullGC::invoke_at_safepoint(clear_all_soft_refs);\n-\n-  gch->post_full_gc_dump(gc_timer);\n-\n-  gc_timer->register_gc_end();\n-\n-  gc_tracer->report_gc_end(gc_timer->gc_end(), gc_timer->time_partitions());\n-}\n-\n@@ -511,8 +456,0 @@\n-  if (ZapUnusedHeapArea) {\n-    _the_space->check_mangled_unused_area_complete();\n-  }\n-}\n-\n-void TenuredGeneration::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  _the_space->set_top_for_allocations();\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":64,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -138,5 +138,0 @@\n-  virtual void collect(bool full,\n-                       bool clear_all_soft_refs,\n-                       size_t size,\n-                       bool is_tlab);\n-\n@@ -148,3 +143,8 @@\n-  bool should_collect(bool   full,\n-                      size_t word_size,\n-                      bool   is_tlab);\n+  bool should_allocate(size_t word_size, bool is_tlab) {\n+    bool result = false;\n+    size_t overflow_limit = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n+    if (!is_tlab || supports_tlab_allocation()) {\n+      result = (word_size > 0) && (word_size < overflow_limit);\n+    }\n+    return result;\n+  }\n@@ -155,2 +155,0 @@\n-  void record_spaces_top();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-  nonstatic_field(Generation,                        _stat_record,           Generation::StatRecord)        \\\n-                                                                                                            \\\n-  nonstatic_field(Generation::StatRecord,            invocations,            int)                           \\\n-  nonstatic_field(Generation::StatRecord,            accumulated_time,       elapsedTimer)                  \\\n@@ -70,1 +66,0 @@\n-  declare_toplevel_type(Generation::StatRecord)                               \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  if (nm->is_native_method() || nm->is_compiled_by_c2() || nm->is_compiled_by_c1()) {\n+  if (nm->is_native_method() || nm->is_compiled_by_c2() || nm->is_compiled_by_c1() || nm->is_compiled_by_jvmci()) {\n@@ -72,6 +72,0 @@\n-#if INCLUDE_JVMCI\n-  if (nm->is_compiled_by_jvmci() && nm->jvmci_nmethod_data()->has_entry_barrier()) {\n-    return true;\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-BarrierStubC2::BarrierStubC2(const MachNode* node)\n-  : _node(node),\n-    _entry(),\n-    _continuation() {}\n-\n@@ -103,0 +98,6 @@\n+BarrierStubC2::BarrierStubC2(const MachNode* node)\n+  : _node(node),\n+    _entry(),\n+    _continuation(),\n+    _preserve(live()) {}\n+\n@@ -115,0 +116,21 @@\n+void BarrierStubC2::preserve(Register r) {\n+  const VMReg vm_reg = r->as_VMReg();\n+  assert(vm_reg->is_Register(), \"r must be a general-purpose register\");\n+  _preserve.Insert(OptoReg::as_OptoReg(vm_reg));\n+}\n+\n+void BarrierStubC2::dont_preserve(Register r) {\n+  VMReg vm_reg = r->as_VMReg();\n+  assert(vm_reg->is_Register(), \"r must be a general-purpose register\");\n+  \/\/ Subtract the given register and all its sub-registers (e.g. {R11, R11_H}\n+  \/\/ for r11 in aarch64).\n+  do {\n+    _preserve.Remove(OptoReg::as_OptoReg(vm_reg));\n+    vm_reg = vm_reg->next();\n+  } while (vm_reg->is_Register() && !vm_reg->is_concrete());\n+}\n+\n+const RegMask& BarrierStubC2::preserve_set() const {\n+  return _preserve;\n+}\n+\n@@ -835,0 +857,1 @@\n+  BarrierSetC2State* bs_state = barrier_set_state();\n@@ -857,0 +880,8 @@\n+      \/\/ If this node tracks out-liveness, update it\n+      if (!bs_state->needs_livein_data()) {\n+        RegMask* const regs = bs_state->live(node);\n+        if (regs != nullptr) {\n+          regs->OR(new_live);\n+        }\n+      }\n+\n@@ -880,4 +911,6 @@\n-       \/\/ If this node tracks liveness, update it\n-      RegMask* const regs = barrier_set_state()->live(node);\n-      if (regs != NULL) {\n-        regs->OR(new_live);\n+      \/\/ If this node tracks in-liveness, update it\n+      if (bs_state->needs_livein_data()) {\n+        RegMask* const regs = bs_state->live(node);\n+        if (regs != nullptr) {\n+          regs->OR(new_live);\n+        }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+  virtual bool needs_livein_data() const = 0;\n@@ -245,0 +246,7 @@\n+  RegMask         _preserve;\n+\n+  \/\/ Registers that are live-in\/live-out of the entire memory access\n+  \/\/ implementation (possibly including multiple barriers). Whether live-in or\n+  \/\/ live-out registers are returned depends on\n+  \/\/ BarrierSetC2State::needs_livein_data().\n+  RegMask& live() const;\n@@ -248,1 +256,2 @@\n-  RegMask& live() const;\n+\n+  \/\/ Entry point to the stub.\n@@ -250,0 +259,1 @@\n+  \/\/ Return point from the stub (typically end of barrier).\n@@ -252,1 +262,6 @@\n-  virtual Register result() const = 0;\n+  \/\/ Preserve the value in reg across runtime calls in this barrier.\n+  void preserve(Register reg);\n+  \/\/ Do not preserve the value in reg across runtime calls in this barrier.\n+  void dont_preserve(Register reg);\n+  \/\/ Set of registers whose value needs to be preserved across runtime calls in this barrier.\n+  const RegMask& preserve_set() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  _is_gc_active(false),\n+  _is_stw_gc_active(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,2 +93,1 @@\n-  friend class IsGCActiveMark; \/\/ Block structured external access to _is_gc_active\n-  friend class DisableIsGCActiveMark; \/\/ Disable current IsGCActiveMark\n+  friend class IsSTWGCActiveMark; \/\/ Block structured external access to _is_stw_gc_active\n@@ -96,1 +95,0 @@\n-  friend class ParallelObjectIterator;\n@@ -115,1 +113,1 @@\n-  bool _is_gc_active;\n+  bool _is_stw_gc_active;\n@@ -378,4 +376,2 @@\n-  \/\/ Returns \"true\" iff there is a stop-world GC in progress.  (I assume\n-  \/\/ that it should answer \"false\" for the concurrent part of a concurrent\n-  \/\/ collector -- dld).\n-  bool is_gc_active() const { return _is_gc_active; }\n+  \/\/ Returns \"true\" iff there is a stop-world GC in progress.\n+  bool is_stw_gc_active() const { return _is_stw_gc_active; }\n@@ -407,1 +403,0 @@\n- protected:\n@@ -412,1 +407,0 @@\n- public:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -133,3 +133,3 @@\n-  \/\/ Clean up old interpreter OopMap entries that were replaced\n-  \/\/ during the GC thread root traversal.\n-  OopMapCache::cleanup_old_entries();\n+  \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+  \/\/ might have created lots of old entries. Trigger the cleanup now.\n+  OopMapCache::trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-\/\/        VM_GenCollectFull\n+\/\/        VM_SerialGCCollect\n@@ -47,1 +47,1 @@\n-\/\/          VM_GenCollectForAllocation\n+\/\/          VM_SerialCollectForAllocation\n@@ -66,1 +66,1 @@\n-\/\/  VM_GenCollectForAllocation\n+\/\/  VM_SerialCollectForAllocation\n@@ -72,1 +72,1 @@\n-\/\/  VM_GenCollectFull\n+\/\/  VM_SerialGCCollect\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  product(bool, ZGenerational, false,                                       \\\n+  product(bool, ZGenerational, true,                                        \\\n@@ -544,1 +544,1 @@\n-          \"Initial tenured generation size (in bytes)\")                     \\\n+          \"(Deprecated) Initial tenured generation size (in bytes)\")        \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  return desired_size < max_minus ? desired_size : max_minus;\n+  return MIN2(desired_size, max_minus);\n@@ -267,0 +267,3 @@\n+\n+      \/\/ Derive MinNewSize from MinHeapSize\n+      MinNewSize = MIN2(scale_by_NewRatio_aligned(MinHeapSize, GenAlignment), initial_young_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-\/\/ _is_gc_active state without requiring accessors in CollectedHeap\n+\/\/ _is_stw_gc_active state without requiring accessors in CollectedHeap\n@@ -34,1 +34,1 @@\n-IsGCActiveMark::IsGCActiveMark() {\n+IsSTWGCActiveMark::IsSTWGCActiveMark() {\n@@ -36,2 +36,2 @@\n-  assert(!heap->is_gc_active(), \"Not reentrant\");\n-  heap->_is_gc_active = true;\n+  assert(!heap->is_stw_gc_active(), \"Not reentrant\");\n+  heap->_is_stw_gc_active = true;\n@@ -40,1 +40,1 @@\n-IsGCActiveMark::~IsGCActiveMark() {\n+IsSTWGCActiveMark::~IsSTWGCActiveMark() {\n@@ -42,14 +42,2 @@\n-  assert(heap->is_gc_active(), \"Sanity\");\n-  heap->_is_gc_active = false;\n-}\n-\n-DisableIsGCActiveMark::DisableIsGCActiveMark() {\n-  CollectedHeap* heap = Universe::heap();\n-  assert(heap->is_gc_active(), \"Not reentrant\");\n-  heap->_is_gc_active = false;\n-}\n-\n-DisableIsGCActiveMark::~DisableIsGCActiveMark() {\n-  CollectedHeap* heap = Universe::heap();\n-  assert(!heap->is_gc_active(), \"Sanity\");\n-  heap->_is_gc_active = true;\n+  assert(heap->is_stw_gc_active(), \"Sanity\");\n+  heap->_is_stw_gc_active = false;\n","filename":"src\/hotspot\/share\/gc\/shared\/isGCActiveMark.cpp","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\/\/ _is_gc_active state without requiring accessors in CollectedHeap\n+\/\/ _is_stw_gc_active state without requiring accessors in CollectedHeap\n@@ -33,1 +33,1 @@\n-class IsGCActiveMark : public StackObj {\n+class IsSTWGCActiveMark : public StackObj {\n@@ -35,8 +35,2 @@\n-  IsGCActiveMark();\n-  ~IsGCActiveMark();\n-};\n-\n-class DisableIsGCActiveMark : public StackObj {\n- public:\n-  DisableIsGCActiveMark();\n-  ~DisableIsGCActiveMark();\n+  IsSTWGCActiveMark();\n+  ~IsSTWGCActiveMark();\n","filename":"src\/hotspot\/share\/gc\/shared\/isGCActiveMark.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-JVMFlag::Error InitialTenuringThresholdConstraintFunc(uintx value, bool verbose) {\n+JVMFlag::Error InitialTenuringThresholdConstraintFunc(uint value, bool verbose) {\n@@ -188,1 +188,1 @@\n-JVMFlag::Error MaxTenuringThresholdConstraintFunc(uintx value, bool verbose) {\n+JVMFlag::Error MaxTenuringThresholdConstraintFunc(uint value, bool verbose) {\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n- f(uintx,  InitialTenuringThresholdConstraintFunc)             \\\n- f(uintx,  MaxTenuringThresholdConstraintFunc)                 \\\n+ f(uint,   InitialTenuringThresholdConstraintFunc)             \\\n+ f(uint,   MaxTenuringThresholdConstraintFunc)                 \\\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  if (!_thread->in_retryable_allocation()) {\n+  if (!_thread->is_in_internal_oome_mark()) {\n@@ -129,1 +129,0 @@\n-\n@@ -135,0 +134,1 @@\n+\n@@ -140,1 +140,1 @@\n-    THROW_OOP_(Universe::out_of_memory_error_retry(), true);\n+    THROW_OOP_(Universe::out_of_memory_error_java_heap_without_backtrace(), true);\n@@ -150,1 +150,1 @@\n-  assert(!Universe::heap()->is_gc_active(), \"Allocation during gc not allowed\");\n+  assert(!Universe::heap()->is_stw_gc_active(), \"Allocation during GC pause not allowed\");\n@@ -321,4 +321,1 @@\n-HeapWord* MemAllocator::mem_allocate_slow(Allocation& allocation) const {\n-  \/\/ Allocation of an oop can always invoke a safepoint.\n-  debug_only(allocation._thread->check_for_valid_safepoint_state());\n-\n+HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n@@ -326,2 +323,2 @@\n-    \/\/ Try refilling the TLAB and allocating the object in it.\n-    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n+    \/\/ Try allocating from an existing TLAB.\n+    HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -333,2 +330,2 @@\n-  return mem_allocate_outside_tlab(allocation);\n-}\n+  \/\/ Allocation of an oop can always invoke a safepoint.\n+  debug_only(allocation._thread->check_for_valid_safepoint_state());\n@@ -336,1 +333,0 @@\n-HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n@@ -338,2 +334,2 @@\n-    \/\/ Try allocating from an existing TLAB.\n-    HeapWord* mem = mem_allocate_inside_tlab_fast();\n+    \/\/ Try refilling the TLAB and allocating the object in it.\n+    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n@@ -345,1 +341,1 @@\n-  return mem_allocate_slow(allocation);\n+  return mem_allocate_outside_tlab(allocation);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -55,3 +55,0 @@\n-  \/\/ Fast-path TLAB allocation failed. Takes a slow-path and potentially safepoint.\n-  HeapWord* mem_allocate_slow(Allocation& allocation) const;\n-\n@@ -128,0 +125,27 @@\n+\/\/ Manages a scope where a failed heap allocation results in\n+\/\/ suppression of JVMTI \"resource exhausted\" events and\n+\/\/ throwing a shared, backtrace-less OOME instance.\n+\/\/ Used for OOMEs that will not be propagated to user code.\n+class InternalOOMEMark: public StackObj {\n+ private:\n+  bool _outer;\n+  JavaThread* _thread;\n+\n+ public:\n+  explicit InternalOOMEMark(JavaThread* thread) {\n+    assert(thread != nullptr, \"nullptr is not supported\");\n+    _outer = thread->is_in_internal_oome_mark();\n+    thread->set_is_in_internal_oome_mark(true);\n+    _thread = thread;\n+  }\n+\n+  ~InternalOOMEMark() {\n+    \/\/ Check that only InternalOOMEMark sets\n+    \/\/ JavaThread::_is_in_internal_oome_mark\n+    assert(_thread->is_in_internal_oome_mark(), \"must be\");\n+    _thread->set_is_in_internal_oome_mark(_outer);\n+  }\n+\n+  JavaThread* thread() const  { return _thread; }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -45,7 +45,1 @@\n-  _top(nullptr) {\n-  _mangler = new GenSpaceMangler(this);\n-}\n-\n-ContiguousSpace::~ContiguousSpace() {\n-  delete _mangler;\n-}\n+  _top(nullptr) {}\n@@ -76,5 +70,2 @@\n-void ContiguousSpace::set_top_for_allocations() {\n-  mangler()->set_top_for_allocations(top());\n-}\n-void ContiguousSpace::check_mangled_unused_area(HeapWord* limit) {\n-  mangler()->check_mangled_unused_area(limit);\n+void ContiguousSpace::mangle_unused_area() {\n+  mangle_unused_area(MemRegion(_top, _end));\n@@ -83,2 +74,2 @@\n-void ContiguousSpace::check_mangled_unused_area_complete() {\n-  mangler()->check_mangled_unused_area_complete();\n+void ContiguousSpace::mangle_unused_area(MemRegion mr) {\n+  SpaceMangler::mangle_region(mr);\n@@ -87,9 +78,0 @@\n-\/\/ Mangled only the unused space that has not previously\n-\/\/ been mangled and that has not been allocated since being\n-\/\/ mangled.\n-void ContiguousSpace::mangle_unused_area() {\n-  mangler()->mangle_unused_area();\n-}\n-void ContiguousSpace::mangle_unused_area_complete() {\n-  mangler()->mangle_unused_area_complete();\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,3 +44,0 @@\n-\/\/ Forward decls.\n-class GenSpaceMangler;\n-\n@@ -60,4 +57,0 @@\n-  \/\/ A helper for mangling the unused area of the space in debug builds.\n-  GenSpaceMangler* _mangler;\n-\n-  GenSpaceMangler* mangler() { return _mangler; }\n@@ -71,1 +64,0 @@\n-  ~ContiguousSpace();\n@@ -76,0 +68,2 @@\n+  HeapWord* top() const            { return _top;    }\n+\n@@ -78,0 +72,1 @@\n+  void set_top(HeapWord* value)    { _top = value; }\n@@ -115,13 +110,0 @@\n-  \/\/ Accessors\n-  HeapWord* top() const            { return _top;    }\n-  void set_top(HeapWord* value)    { _top = value; }\n-\n-  \/\/ Used to save the space's current top for later use during mangling.\n-  void set_top_for_allocations() PRODUCT_RETURN;\n-\n-  \/\/ For detecting GC bugs.  Should only be called at GC boundaries, since\n-  \/\/ some unused space may be used as scratch space during GC's.\n-  \/\/ We also call this when expanding a space to satisfy an allocation\n-  \/\/ request. See bug #4668531\n-  \/\/ Mangle regions in the space from the current top up to the\n-  \/\/ previously mangled part of the space.\n@@ -129,8 +111,1 @@\n-  \/\/ Mangle [top, end)\n-  void mangle_unused_area_complete() PRODUCT_RETURN;\n-\n-  \/\/ Do some sparse checking on the area that should have been mangled.\n-  void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  \/\/ Check the complete area that should have been mangled.\n-  \/\/ This code may be null depending on the macro DEBUG_MANGLING.\n-  void check_mangled_unused_area_complete() PRODUCT_RETURN;\n+  void mangle_unused_area(MemRegion mr) PRODUCT_RETURN;\n@@ -142,1 +117,1 @@\n-  virtual HeapWord* allocate(size_t word_size);\n+  HeapWord* allocate(size_t word_size);\n@@ -144,1 +119,1 @@\n-  virtual HeapWord* par_allocate(size_t word_size);\n+  HeapWord* par_allocate(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":6,"deletions":31,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-#include \"gc\/parallel\/mutableSpace.hpp\"\n-#include \"gc\/shared\/space.hpp\"\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n-#include \"logging\/log.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -32,51 +29,1 @@\n-\/\/ Catch-all file for utility classes\n-\n-#ifndef PRODUCT\n-\n-\/\/ Returns true is the location q matches the mangling\n-\/\/ pattern.\n-bool SpaceMangler::is_mangled(HeapWord* q) {\n-  \/\/ This test loses precision but is good enough\n-  return badHeapWord == (max_juint & reinterpret_cast<uintptr_t>(*q));\n-}\n-\n-\n-void SpaceMangler::set_top_for_allocations(HeapWord* v)  {\n-  if (v < end()) {\n-    assert(!CheckZapUnusedHeapArea || is_mangled(v),\n-      \"The high water mark is not mangled\");\n-  }\n-  _top_for_allocations = v;\n-}\n-\n-\/\/ Mangle only the unused space that has not previously\n-\/\/ been mangled and that has not been allocated since being\n-\/\/ mangled.\n-void SpaceMangler::mangle_unused_area() {\n-  assert(ZapUnusedHeapArea, \"Mangling should not be in use\");\n-  \/\/ Mangle between top and the high water mark.  Safeguard\n-  \/\/ against the space changing since top_for_allocations was\n-  \/\/ set.\n-  HeapWord* mangled_end = MIN2(top_for_allocations(), end());\n-  if (top() < mangled_end) {\n-    MemRegion mangle_mr(top(), mangled_end);\n-    SpaceMangler::mangle_region(mangle_mr);\n-    \/\/ Light weight check of mangling.\n-    check_mangled_unused_area(end());\n-  }\n-  \/\/ Complete check of unused area which is functional when\n-  \/\/ DEBUG_MANGLING is defined.\n-  check_mangled_unused_area_complete();\n-}\n-\n-\/\/ A complete mangle is expected in the\n-\/\/ exceptional case where top_for_allocations is not\n-\/\/ properly tracking the high water mark for mangling.\n-\/\/ This can be the case when to-space is being used for\n-\/\/ scratch space during a mark-sweep-compact.  See\n-\/\/ contribute_scratch().\n-void SpaceMangler::mangle_unused_area_complete() {\n-  assert(ZapUnusedHeapArea, \"Mangling should not be in use\");\n-  MemRegion mangle_mr(top(), end());\n-  SpaceMangler::mangle_region(mangle_mr);\n-}\n+#ifdef ASSERT\n@@ -87,1 +34,0 @@\n-#ifdef ASSERT\n@@ -89,1 +35,0 @@\n-#endif\n@@ -92,48 +37,1 @@\n-\/\/ Check that top, top_for_allocations and the last\n-\/\/ word of the space are mangled.  In a tight memory\n-\/\/ situation even this light weight mangling could\n-\/\/ cause paging by touching the end of the space.\n-void  SpaceMangler::check_mangled_unused_area(HeapWord* limit) {\n-  if (CheckZapUnusedHeapArea) {\n-    \/\/ This method can be called while the spaces are\n-    \/\/ being reshaped so skip the test if the end of the\n-    \/\/ space is beyond the specified limit;\n-    if (end() > limit) return;\n-\n-    assert(top() == end() ||\n-           (is_mangled(top())), \"Top not mangled\");\n-    assert((top_for_allocations() < top()) ||\n-           (top_for_allocations() >= end()) ||\n-           (is_mangled(top_for_allocations())),\n-           \"Older unused not mangled\");\n-    assert(top() == end() ||\n-           (is_mangled(end() - 1)), \"End not properly mangled\");\n-    \/\/ Only does checking when DEBUG_MANGLING is defined.\n-    check_mangled_unused_area_complete();\n-  }\n-}\n-\n-#undef DEBUG_MANGLING\n-\/\/ This should only be used while debugging the mangling\n-\/\/ because of the high cost of checking the completeness.\n-void  SpaceMangler::check_mangled_unused_area_complete() {\n-  if (CheckZapUnusedHeapArea) {\n-    assert(ZapUnusedHeapArea, \"Not mangling unused area\");\n-#ifdef DEBUG_MANGLING\n-    HeapWord* q = top();\n-    HeapWord* limit = end();\n-\n-    bool passed = true;\n-    while (q < limit) {\n-      if (!is_mangled(q)) {\n-        passed = false;\n-        break;\n-      }\n-      q++;\n-    }\n-    assert(passed, \"Mangling is not complete\");\n-#endif\n-  }\n-}\n-#undef DEBUG_MANGLING\n-#endif \/\/ not PRODUCT\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.cpp","additions":3,"deletions":105,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class SpaceDecorator: public AllStatic {\n+class SpaceDecorator : AllStatic {\n@@ -41,108 +41,2 @@\n-\/\/ Functionality for use with class Space and class MutableSpace.\n-\/\/   The approach taken with the mangling is to mangle all\n-\/\/ the space initially and then to mangle areas that have\n-\/\/ been allocated since the last collection.  Mangling is\n-\/\/ done in the context of a generation and in the context\n-\/\/ of a space.\n-\/\/   The space in a generation is mangled when it is first\n-\/\/ initialized and when the generation grows.  The spaces\n-\/\/ are not necessarily up-to-date when this mangling occurs\n-\/\/ and the method mangle_region() is used.\n-\/\/   After allocations have been done in a space, the space generally\n-\/\/ need to be remangled.  Remangling is only done on the\n-\/\/ recently allocated regions in the space.  Typically, that is\n-\/\/ the region between the new top and the top just before a\n-\/\/ garbage collection.\n-\/\/   An exception to the usual mangling in a space is done when the\n-\/\/ space is used for an extraordinary purpose.  Specifically, when\n-\/\/ to-space is used as scratch space for a mark-sweep-compact\n-\/\/ collection.\n-\/\/   Spaces are mangled after a collection.  If the generation\n-\/\/ grows after a collection, the added space is mangled as part of\n-\/\/ the growth of the generation.  No additional mangling is needed when the\n-\/\/ spaces are resized after an expansion.\n-\/\/   The class SpaceMangler keeps a pointer to the top of the allocated\n-\/\/ area and provides the methods for doing the piece meal mangling.\n-\/\/ Methods for doing spaces and full checking of the mangling are\n-\/\/ included.  The full checking is done if DEBUG_MANGLING is defined.\n-\/\/   GenSpaceMangler is used with the SerialHeap collectors and\n-\/\/ MutableSpaceMangler is used with the ParallelScavengeHeap collectors.\n-\/\/ These subclasses abstract the differences in the types of spaces used\n-\/\/ by each heap.\n-\n-class SpaceMangler: public CHeapObj<mtGC> {\n-  friend class VMStructs;\n-\n-  \/\/ High water mark for allocations.  Typically, the space above\n-  \/\/ this point have been mangle previously and don't need to be\n-  \/\/ touched again.  Space below this point has been allocated\n-  \/\/ and remangling is needed between the current top and this\n-  \/\/ high water mark.\n-  HeapWord* _top_for_allocations;\n-  HeapWord* top_for_allocations() { return _top_for_allocations; }\n-\n- public:\n-\n-  \/\/ Setting _top_for_allocations to null at initialization\n-  \/\/ makes it always below top so that mangling done as part\n-  \/\/ of the initialize() call of a space does nothing (as it\n-  \/\/ should since the mangling is done as part of the constructor\n-  \/\/ for the space.\n-  SpaceMangler() : _top_for_allocations(nullptr) {}\n-\n-  \/\/ Methods for top and end that delegate to the specific\n-  \/\/ space type.\n-  virtual HeapWord* top() const = 0;\n-  virtual HeapWord* end() const = 0;\n-\n-  \/\/ Return true if q matches the mangled pattern.\n-  static bool is_mangled(HeapWord* q) PRODUCT_RETURN0;\n-\n-  \/\/ Used to save the address in a space for later use during mangling.\n-  void set_top_for_allocations(HeapWord* v);\n-\n-  \/\/ Overwrites the unused portion of this space.\n-  \/\/ Mangle only the region not previously mangled [top, top_previously_mangled)\n-  void mangle_unused_area();\n-  \/\/ Mangle all the unused region [top, end)\n-  void mangle_unused_area_complete();\n-  \/\/ Do some sparse checking on the area that should have been mangled.\n-  void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  \/\/ Do a complete check of the area that should be mangled.\n-  void check_mangled_unused_area_complete() PRODUCT_RETURN;\n-\n-  \/\/ Mangle the MemRegion.  This is a non-space specific mangler.  It\n-  \/\/ is used during the initial mangling of a space before the space\n-  \/\/ is fully constructed.  Also is used when a generation is expanded\n-  \/\/ and possibly before the spaces have been reshaped to to the new\n-  \/\/ size of the generation.\n-  static void mangle_region(MemRegion mr) PRODUCT_RETURN;\n-};\n-\n-class ContiguousSpace;\n-class MutableSpace;\n-\n-\/\/ For use with SerialHeap's\n-class GenSpaceMangler: public SpaceMangler {\n-  ContiguousSpace* _sp;\n-\n-  ContiguousSpace* sp() { return _sp; }\n-\n-  HeapWord* top() const;\n-  HeapWord* end() const;\n-\n- public:\n-  GenSpaceMangler(ContiguousSpace* sp) : SpaceMangler(), _sp(sp) {}\n-};\n-\n-\/\/ For use with ParallelScavengeHeap's.\n-class MutableSpaceMangler: public SpaceMangler {\n-  MutableSpace* _sp;\n-\n-  MutableSpace* sp() { return _sp; }\n-\n-  HeapWord* top() const;\n-  HeapWord* end() const;\n-\n- public:\n-  MutableSpaceMangler(MutableSpace* sp) : SpaceMangler(), _sp(sp) {}\n+struct SpaceMangler : AllStatic {\n+  static void mangle_region(MemRegion mr) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.hpp","additions":3,"deletions":109,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_SPACEDECORATOR_INLINE_HPP\n-#define SHARE_GC_SHARED_SPACEDECORATOR_INLINE_HPP\n-\n-#include \"gc\/shared\/spaceDecorator.hpp\"\n-\n-#include \"gc\/parallel\/mutableSpace.hpp\"\n-#include \"gc\/shared\/space.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-inline HeapWord* GenSpaceMangler::top() const { return _sp->top(); }\n-inline HeapWord* GenSpaceMangler::end() const { return _sp->end(); }\n-\n-inline HeapWord* MutableSpaceMangler::top() const { return _sp->top(); }\n-inline HeapWord* MutableSpaceMangler::end() const { return _sp->end(); }\n-\n-#endif \/\/ SHARE_GC_SHARED_SPACEDECORATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.inline.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  nonstatic_field(CollectedHeap,               _is_gc_active,                                 bool)                                  \\\n+  nonstatic_field(CollectedHeap,               _is_stw_gc_active,                             bool)                                  \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -466,0 +466,6 @@\n+        \"intpoly_montgomeryMult_P256\",\n+        { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahLoad  },   { TypeFunc::Parms+2, ShenandoahStore },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n+        \"intpoly_assign\",\n+        { { TypeFunc::Parms+1, ShenandoahStore }, { TypeFunc::Parms+2, ShenandoahLoad },  { -1, ShenandoahNone },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -31,0 +32,2 @@\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp\"\n@@ -35,5 +38,58 @@\n-ShenandoahFreeSet::ShenandoahFreeSet(ShenandoahHeap* heap, size_t max_regions) :\n-  _heap(heap),\n-  _mutator_free_bitmap(max_regions, mtGC),\n-  _collector_free_bitmap(max_regions, mtGC),\n-  _max(max_regions)\n+static const char* partition_name(ShenandoahFreeSetPartitionId t) {\n+  switch (t) {\n+    case ShenandoahFreeSetPartitionId::NotFree: return \"NotFree\";\n+    case ShenandoahFreeSetPartitionId::Mutator: return \"Mutator\";\n+    case ShenandoahFreeSetPartitionId::Collector: return \"Collector\";\n+    default:\n+      ShouldNotReachHere();\n+      return \"Unrecognized\";\n+  }\n+}\n+\n+#ifndef PRODUCT\n+void ShenandoahRegionPartitions::dump_bitmap() const {\n+  log_info(gc)(\"Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"], Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)]);\n+  log_info(gc)(\"Empty Mutator range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT\n+               \"], Empty Collector range [\" SSIZE_FORMAT \", \" SSIZE_FORMAT \"]\",\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)],\n+               _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+               _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)]);\n+\n+  log_info(gc)(\"%6s: %18s %18s %18s\", \"index\", \"Mutator Bits\", \"Collector Bits\", \"NotFree Bits\");\n+  dump_bitmap_range(0, _max-1);\n+}\n+\n+void ShenandoahRegionPartitions::dump_bitmap_range(idx_t start_region_idx, idx_t end_region_idx) const {\n+  assert((start_region_idx >= 0) && (start_region_idx < (idx_t) _max), \"precondition\");\n+  assert((end_region_idx >= 0) && (end_region_idx < (idx_t) _max), \"precondition\");\n+  idx_t aligned_start = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(start_region_idx);\n+  idx_t aligned_end = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(end_region_idx);\n+  idx_t alignment = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].alignment();\n+  while (aligned_start <= aligned_end) {\n+    dump_bitmap_row(aligned_start);\n+    aligned_start += alignment;\n+  }\n+}\n+\n+void ShenandoahRegionPartitions::dump_bitmap_row(idx_t region_idx) const {\n+  assert((region_idx >= 0) && (region_idx < (idx_t) _max), \"precondition\");\n+  idx_t aligned_idx = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].aligned_index(region_idx);\n+  uintx mutator_bits = _membership[int(ShenandoahFreeSetPartitionId::Mutator)].bits_at(aligned_idx);\n+  uintx collector_bits = _membership[int(ShenandoahFreeSetPartitionId::Collector)].bits_at(aligned_idx);\n+  uintx free_bits = mutator_bits | collector_bits;\n+  uintx notfree_bits =  ~free_bits;\n+  log_info(gc)(SSIZE_FORMAT_W(6) \": \" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0 \" 0x\" SIZE_FORMAT_X_0,\n+               aligned_idx, mutator_bits, collector_bits, notfree_bits);\n+}\n+#endif\n+\n+ShenandoahRegionPartitions::ShenandoahRegionPartitions(size_t max_regions, ShenandoahFreeSet* free_set) :\n+    _max(max_regions),\n+    _region_size_bytes(ShenandoahHeapRegion::region_size_bytes()),\n+    _free_set(free_set),\n+    _membership{ ShenandoahSimpleBitMap(max_regions), ShenandoahSimpleBitMap(max_regions) }\n@@ -41,1 +97,1 @@\n-  clear_internal();\n+  make_all_regions_unavailable();\n@@ -44,3 +100,61 @@\n-void ShenandoahFreeSet::increase_used(size_t num_bytes) {\n-  shenandoah_assert_heaplocked();\n-  _used += num_bytes;\n+inline bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) const {\n+  return r->is_empty() || (r->is_trash() && !_heap->is_concurrent_weak_root_in_progress());\n+}\n+\n+inline bool ShenandoahFreeSet::can_allocate_from(size_t idx) const {\n+  ShenandoahHeapRegion* r = _heap->get_region(idx);\n+  return can_allocate_from(r);\n+}\n+\n+inline size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) const {\n+  if (r->is_trash()) {\n+    \/\/ This would be recycled on allocation path\n+    return ShenandoahHeapRegion::region_size_bytes();\n+  } else {\n+    return r->free();\n+  }\n+}\n+\n+inline size_t ShenandoahFreeSet::alloc_capacity(size_t idx) const {\n+  ShenandoahHeapRegion* r = _heap->get_region(idx);\n+  return alloc_capacity(r);\n+}\n+\n+inline bool ShenandoahFreeSet::has_alloc_capacity(ShenandoahHeapRegion *r) const {\n+  return alloc_capacity(r) > 0;\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::leftmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  idx_t idx = _leftmosts[int(which_partition)];\n+  if (idx >= _max) {\n+    return _max;\n+  } else {\n+    \/\/ Cannot assert that membership[which_partition.is_set(idx) because this helper method may be used\n+    \/\/ to query the original value of leftmost when leftmost must be adjusted because the interval representing\n+    \/\/ which_partition is shrinking after the region that used to be leftmost is retired.\n+    return idx;\n+  }\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::rightmost(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  idx_t idx = _rightmosts[int(which_partition)];\n+  \/\/ Cannot assert that membership[which_partition.is_set(idx) because this helper method may be used\n+  \/\/ to query the original value of leftmost when leftmost must be adjusted because the interval representing\n+  \/\/ which_partition is shrinking after the region that used to be leftmost is retired.\n+  return idx;\n+}\n+\n+void ShenandoahRegionPartitions::make_all_regions_unavailable() {\n+  for (size_t partition_id = 0; partition_id < IntNumPartitions; partition_id++) {\n+    _membership[partition_id].clear_all();\n+    _leftmosts[partition_id] = _max;\n+    _rightmosts[partition_id] = -1;\n+    _leftmosts_empty[partition_id] = _max;\n+    _rightmosts_empty[partition_id] = -1;;\n+    _capacity[partition_id] = 0;\n+    _used[partition_id] = 0;\n+  }\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = _region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+}\n@@ -48,2 +162,21 @@\n-  assert(_used <= _capacity, \"must not use more than we have: used: \" SIZE_FORMAT\n-         \", capacity: \" SIZE_FORMAT \", num_bytes: \" SIZE_FORMAT, _used, _capacity, num_bytes);\n+void ShenandoahRegionPartitions::establish_mutator_intervals(idx_t mutator_leftmost, idx_t mutator_rightmost,\n+                                                             idx_t mutator_leftmost_empty, idx_t mutator_rightmost_empty,\n+                                                             size_t mutator_region_count, size_t mutator_used) {\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count;\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_leftmost;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_rightmost;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_leftmost_empty;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_rightmost_empty;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count;\n+  _used[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_used;\n+  _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count * _region_size_bytes;\n+\n+  _leftmosts[int(ShenandoahFreeSetPartitionId::Collector)] = _max;\n+  _rightmosts[int(ShenandoahFreeSetPartitionId::Collector)] = -1;\n+  _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)] = _max;\n+  _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)] = -1;\n+\n+  _region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+  _used[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n+  _capacity[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -52,4 +185,6 @@\n-bool ShenandoahFreeSet::is_mutator_free(size_t idx) const {\n-  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT \" (left: \" SIZE_FORMAT \", right: \" SIZE_FORMAT \")\",\n-          idx, _max, _mutator_leftmost, _mutator_rightmost);\n-  return _mutator_free_bitmap.at(idx);\n+void ShenandoahRegionPartitions::increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  _used[int(which_partition)] += bytes;\n+  assert (_used[int(which_partition)] <= _capacity[int(which_partition)],\n+          \"Must not use (\" SIZE_FORMAT \") more than capacity (\" SIZE_FORMAT \") after increase by \" SIZE_FORMAT,\n+          _used[int(which_partition)], _capacity[int(which_partition)], bytes);\n@@ -58,4 +193,391 @@\n-bool ShenandoahFreeSet::is_collector_free(size_t idx) const {\n-  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT \" (left: \" SIZE_FORMAT \", right: \" SIZE_FORMAT \")\",\n-          idx, _max, _collector_leftmost, _collector_rightmost);\n-  return _collector_free_bitmap.at(idx);\n+inline void ShenandoahRegionPartitions::shrink_interval_if_range_modifies_either_boundary(\n+  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx) {\n+  assert((low_idx <= high_idx) && (low_idx >= 0) && (high_idx < _max), \"Range must span legal index values\");\n+  if (low_idx == leftmost(partition)) {\n+    assert (!_membership[int(partition)].is_set(low_idx), \"Do not shrink interval if region not removed\");\n+    if (high_idx + 1 == _max) {\n+      _leftmosts[int(partition)] = _max;\n+    } else {\n+      _leftmosts[int(partition)] = find_index_of_next_available_region(partition, high_idx + 1);\n+    }\n+    if (_leftmosts_empty[int(partition)] < _leftmosts[int(partition)]) {\n+      \/\/ This gets us closer to where we need to be; we'll scan further when leftmosts_empty is requested.\n+      _leftmosts_empty[int(partition)] = leftmost(partition);\n+    }\n+  }\n+  if (high_idx == _rightmosts[int(partition)]) {\n+    assert (!_membership[int(partition)].is_set(high_idx), \"Do not shrink interval if region not removed\");\n+    if (low_idx == 0) {\n+      _rightmosts[int(partition)] = -1;\n+    } else {\n+      _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, low_idx - 1);\n+    }\n+    if (_rightmosts_empty[int(partition)] > _rightmosts[int(partition)]) {\n+      \/\/ This gets us closer to where we need to be; we'll scan further when rightmosts_empty is requested.\n+      _rightmosts_empty[int(partition)] = _rightmosts[int(partition)];\n+    }\n+  }\n+  if (_leftmosts[int(partition)] > _rightmosts[int(partition)]) {\n+    _leftmosts[int(partition)] = _max;\n+    _rightmosts[int(partition)] = -1;\n+    _leftmosts_empty[int(partition)] = _max;\n+    _rightmosts_empty[int(partition)] = -1;\n+  }\n+}\n+\n+inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, idx_t idx) {\n+  shrink_interval_if_range_modifies_either_boundary(partition, idx, idx);\n+}\n+\n+inline void ShenandoahRegionPartitions::expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n+                                                                             idx_t idx, size_t region_available) {\n+  if (_leftmosts[int(partition)] > idx) {\n+    _leftmosts[int(partition)] = idx;\n+  }\n+  if (_rightmosts[int(partition)] < idx) {\n+    _rightmosts[int(partition)] = idx;\n+  }\n+  if (region_available == _region_size_bytes) {\n+    if (_leftmosts_empty[int(partition)] > idx) {\n+      _leftmosts_empty[int(partition)] = idx;\n+    }\n+    if (_rightmosts_empty[int(partition)] < idx) {\n+      _rightmosts_empty[int(partition)] = idx;\n+    }\n+  }\n+}\n+\n+void ShenandoahRegionPartitions::retire_range_from_partition(\n+  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx) {\n+\n+  \/\/ Note: we may remove from free partition even if region is not entirely full, such as when available < PLAB::min_size()\n+  assert ((low_idx < _max) && (high_idx < _max), \"Both indices are sane: \" SIZE_FORMAT \" and \" SIZE_FORMAT \" < \" SIZE_FORMAT,\n+          low_idx, high_idx, _max);\n+  assert (partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+\n+  for (idx_t idx = low_idx; idx <= high_idx; idx++) {\n+    assert (in_free_set(partition, idx), \"Must be in partition to remove from partition\");\n+    _membership[int(partition)].clear_bit(idx);\n+  }\n+  _region_counts[int(partition)] -= high_idx + 1 - low_idx;\n+  shrink_interval_if_range_modifies_either_boundary(partition, low_idx, high_idx);\n+}\n+\n+void ShenandoahRegionPartitions::retire_from_partition(ShenandoahFreeSetPartitionId partition, idx_t idx, size_t used_bytes) {\n+\n+  \/\/ Note: we may remove from free partition even if region is not entirely full, such as when available < PLAB::min_size()\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert (partition < NumPartitions, \"Cannot remove from free partitions if not already free\");\n+  assert (in_free_set(partition, idx), \"Must be in partition to remove from partition\");\n+\n+  if (used_bytes < _region_size_bytes) {\n+    \/\/ Count the alignment pad remnant of memory as used when we retire this region\n+    increase_used(partition, _region_size_bytes - used_bytes);\n+  }\n+  _membership[int(partition)].clear_bit(idx);\n+  shrink_interval_if_boundary_modified(partition, idx);\n+  _region_counts[int(partition)]--;\n+}\n+\n+void ShenandoahRegionPartitions::make_free(idx_t idx, ShenandoahFreeSetPartitionId which_partition, size_t available) {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert (membership(idx) == ShenandoahFreeSetPartitionId::NotFree, \"Cannot make free if already free\");\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  assert (available <= _region_size_bytes, \"Available cannot exceed region size\");\n+\n+  _membership[int(which_partition)].set_bit(idx);\n+  _capacity[int(which_partition)] += _region_size_bytes;\n+  _used[int(which_partition)] += _region_size_bytes - available;\n+  expand_interval_if_boundary_modified(which_partition, idx, available);\n+\n+  _region_counts[int(which_partition)]++;\n+}\n+\n+void ShenandoahRegionPartitions::move_from_partition_to_partition(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                                                  ShenandoahFreeSetPartitionId new_partition, size_t available) {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert (orig_partition < NumPartitions, \"Original partition must be valid\");\n+  assert (new_partition < NumPartitions, \"New partition must be valid\");\n+  assert (available <= _region_size_bytes, \"Available cannot exceed region size\");\n+\n+  \/\/ Expected transitions:\n+  \/\/  During rebuild:         Mutator => Collector\n+  \/\/  During flip_to_gc:      Mutator empty => Collector\n+  \/\/ At start of update refs: Collector => Mutator\n+  assert (((available <= _region_size_bytes) &&\n+           (((orig_partition == ShenandoahFreeSetPartitionId::Mutator)\n+             && (new_partition == ShenandoahFreeSetPartitionId::Collector)) ||\n+            ((orig_partition == ShenandoahFreeSetPartitionId::Collector)\n+             && (new_partition == ShenandoahFreeSetPartitionId::Mutator)))) ||\n+          ((available == _region_size_bytes) &&\n+           ((orig_partition == ShenandoahFreeSetPartitionId::Mutator)\n+            && (new_partition == ShenandoahFreeSetPartitionId::Collector))), \"Unexpected movement between partitions\");\n+\n+  size_t used = _region_size_bytes - available;\n+\n+  _membership[int(orig_partition)].clear_bit(idx);\n+  _membership[int(new_partition)].set_bit(idx);\n+\n+  _capacity[int(orig_partition)] -= _region_size_bytes;\n+  _used[int(orig_partition)] -= used;\n+  shrink_interval_if_boundary_modified(orig_partition, idx);\n+\n+  _capacity[int(new_partition)] += _region_size_bytes;;\n+  _used[int(new_partition)] += used;\n+  expand_interval_if_boundary_modified(new_partition, idx, available);\n+\n+  _region_counts[int(orig_partition)]--;\n+  _region_counts[int(new_partition)]++;\n+}\n+\n+const char* ShenandoahRegionPartitions::partition_membership_name(idx_t idx) const {\n+  return partition_name(membership(idx));\n+}\n+\n+inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(idx_t idx) const {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  ShenandoahFreeSetPartitionId result = ShenandoahFreeSetPartitionId::NotFree;\n+  for (uint partition_id = 0; partition_id < UIntNumPartitions; partition_id++) {\n+    if (_membership[partition_id].is_set(idx)) {\n+      assert(result == ShenandoahFreeSetPartitionId::NotFree, \"Region should reside in only one partition\");\n+      result = (ShenandoahFreeSetPartitionId) partition_id;\n+    }\n+  }\n+  return result;\n+}\n+\n+#ifdef ASSERT\n+inline bool ShenandoahRegionPartitions::partition_id_matches(idx_t idx, ShenandoahFreeSetPartitionId test_partition) const {\n+  assert (idx < _max, \"index is sane: \" SIZE_FORMAT \" < \" SIZE_FORMAT, idx, _max);\n+  assert (test_partition < ShenandoahFreeSetPartitionId::NotFree, \"must be a valid partition\");\n+\n+  return membership(idx) == test_partition;\n+}\n+#endif\n+\n+inline bool ShenandoahRegionPartitions::is_empty(ShenandoahFreeSetPartitionId which_partition) const {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  return (leftmost(which_partition) > rightmost(which_partition));\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::find_index_of_next_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t start_index) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  if ((rightmost_idx < leftmost_idx) || (start_index > rightmost_idx)) return _max;\n+  if (start_index < leftmost_idx) {\n+    start_index = leftmost_idx;\n+  }\n+  idx_t result = _membership[int(which_partition)].find_first_set_bit(start_index, rightmost_idx + 1);\n+  if (result > rightmost_idx) {\n+    result = _max;\n+  }\n+  assert (result >= start_index, \"Requires progress\");\n+  return result;\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::find_index_of_previous_available_region(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t last_index) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  \/\/ if (leftmost_idx == max) then (last_index < leftmost_idx)\n+  if (last_index < leftmost_idx) return -1;\n+  if (last_index > rightmost_idx) {\n+    last_index = rightmost_idx;\n+  }\n+  idx_t result = _membership[int(which_partition)].find_last_set_bit(-1, last_index);\n+  if (result < leftmost_idx) {\n+    result = -1;\n+  }\n+  assert (result <= last_index, \"Requires progress\");\n+  return result;\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::find_index_of_next_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t start_index, size_t cluster_size) const {\n+  idx_t rightmost_idx = rightmost(which_partition);\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  if ((rightmost_idx < leftmost_idx) || (start_index > rightmost_idx)) return _max;\n+  idx_t result = _membership[int(which_partition)].find_first_consecutive_set_bits(start_index, rightmost_idx + 1, cluster_size);\n+  if (result > rightmost_idx) {\n+    result = _max;\n+  }\n+  assert (result >= start_index, \"Requires progress\");\n+  return result;\n+}\n+\n+inline idx_t ShenandoahRegionPartitions::find_index_of_previous_available_cluster_of_regions(\n+  ShenandoahFreeSetPartitionId which_partition, idx_t last_index, size_t cluster_size) const {\n+  idx_t leftmost_idx = leftmost(which_partition);\n+  \/\/ if (leftmost_idx == max) then (last_index < leftmost_idx)\n+  if (last_index < leftmost_idx) return -1;\n+  idx_t result = _membership[int(which_partition)].find_last_consecutive_set_bits(leftmost_idx - 1, last_index, cluster_size);\n+  if (result <= leftmost_idx) {\n+    result = -1;\n+  }\n+  assert (result <= last_index, \"Requires progress\");\n+  return result;\n+}\n+\n+idx_t ShenandoahRegionPartitions::leftmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  idx_t max_regions = _max;\n+  if (_leftmosts_empty[int(which_partition)] == _max) {\n+    return _max;\n+  }\n+  for (idx_t idx = find_index_of_next_available_region(which_partition, _leftmosts_empty[int(which_partition)]);\n+       idx < max_regions; ) {\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+    if (_free_set->alloc_capacity(idx) == _region_size_bytes) {\n+      _leftmosts_empty[int(which_partition)] = idx;\n+      return idx;\n+    }\n+    idx = find_index_of_next_available_region(which_partition, idx + 1);\n+  }\n+  _leftmosts_empty[int(which_partition)] = _max;\n+  _rightmosts_empty[int(which_partition)] = -1;\n+  return _max;\n+}\n+\n+idx_t ShenandoahRegionPartitions::rightmost_empty(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"selected free partition must be valid\");\n+  if (_rightmosts_empty[int(which_partition)] < 0) {\n+    return -1;\n+  }\n+  for (idx_t idx = find_index_of_previous_available_region(which_partition, _rightmosts_empty[int(which_partition)]);\n+       idx >= 0; ) {\n+    assert(in_free_set(which_partition, idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+    if (_free_set->alloc_capacity(idx) == _region_size_bytes) {\n+      _rightmosts_empty[int(which_partition)] = idx;\n+      return idx;\n+    }\n+    idx = find_index_of_previous_available_region(which_partition, idx - 1);\n+  }\n+  _leftmosts_empty[int(which_partition)] = _max;\n+  _rightmosts_empty[int(which_partition)] = -1;\n+  return -1;\n+}\n+\n+\n+#ifdef ASSERT\n+void ShenandoahRegionPartitions::assert_bounds() {\n+\n+  idx_t leftmosts[UIntNumPartitions];\n+  idx_t rightmosts[UIntNumPartitions];\n+  idx_t empty_leftmosts[UIntNumPartitions];\n+  idx_t empty_rightmosts[UIntNumPartitions];\n+\n+  for (uint i = 0; i < UIntNumPartitions; i++) {\n+    leftmosts[i] = _max;\n+    empty_leftmosts[i] = _max;\n+    rightmosts[i] = -1;\n+    empty_rightmosts[i] = -1;\n+  }\n+\n+  for (idx_t i = 0; i < _max; i++) {\n+    ShenandoahFreeSetPartitionId partition = membership(i);\n+    switch (partition) {\n+      case ShenandoahFreeSetPartitionId::NotFree:\n+        break;\n+\n+      case ShenandoahFreeSetPartitionId::Mutator:\n+      case ShenandoahFreeSetPartitionId::Collector:\n+      {\n+        size_t capacity = _free_set->alloc_capacity(i);\n+        bool is_empty = (capacity == _region_size_bytes);\n+        assert(capacity > 0, \"free regions must have allocation capacity\");\n+        if (i < leftmosts[int(partition)]) {\n+          leftmosts[int(partition)] = i;\n+        }\n+        if (is_empty && (i < empty_leftmosts[int(partition)])) {\n+          empty_leftmosts[int(partition)] = i;\n+        }\n+        if (i > rightmosts[int(partition)]) {\n+          rightmosts[int(partition)] = i;\n+        }\n+        if (is_empty && (i > empty_rightmosts[int(partition)])) {\n+          empty_rightmosts[int(partition)] = i;\n+        }\n+        break;\n+      }\n+\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  }\n+\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) <= _max,\n+          \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, leftmost(ShenandoahFreeSetPartitionId::Mutator),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::Mutator) < _max,\n+          \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Mutator),  _max);\n+\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) == _max\n+          || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::Mutator), ShenandoahFreeSetPartitionId::Mutator),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Mutator) == _max\n+          || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::Mutator), ShenandoahFreeSetPartitionId::Mutator),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Mutator));\n+\n+  \/\/ If Mutator partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n+  idx_t beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  idx_t end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost(ShenandoahFreeSetPartitionId::Mutator));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::Mutator)];\n+  assert (beg_off >= leftmost_empty(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+  assert (end_off <= rightmost_empty(ShenandoahFreeSetPartitionId::Mutator),\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+\n+  \/\/ Performance invariants. Failing these would not break the free partition, but performance would suffer.\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) <= _max, \"leftmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          leftmost(ShenandoahFreeSetPartitionId::Collector),  _max);\n+  assert (rightmost(ShenandoahFreeSetPartitionId::Collector) < _max, \"rightmost in bounds: \"  SSIZE_FORMAT \" < \" SSIZE_FORMAT,\n+          rightmost(ShenandoahFreeSetPartitionId::Collector),  _max);\n+\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) == _max\n+          || partition_id_matches(leftmost(ShenandoahFreeSetPartitionId::Collector), ShenandoahFreeSetPartitionId::Collector),\n+          \"leftmost region should be free: \" SSIZE_FORMAT,  leftmost(ShenandoahFreeSetPartitionId::Collector));\n+  assert (leftmost(ShenandoahFreeSetPartitionId::Collector) == _max\n+          || partition_id_matches(rightmost(ShenandoahFreeSetPartitionId::Collector), ShenandoahFreeSetPartitionId::Collector),\n+          \"rightmost region should be free: \" SSIZE_FORMAT, rightmost(ShenandoahFreeSetPartitionId::Collector));\n+\n+  \/\/ If Collector partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Likewise for empty region partitions.\n+  beg_off = leftmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  end_off = rightmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::Collector),\n+          \"free regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost(ShenandoahFreeSetPartitionId::Collector));\n+  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::Collector),\n+          \"free regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost(ShenandoahFreeSetPartitionId::Collector));\n+\n+  beg_off = empty_leftmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  end_off = empty_rightmosts[int(ShenandoahFreeSetPartitionId::Collector)];\n+  assert (beg_off >= _leftmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+          \"free empty regions before the leftmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          beg_off, leftmost_empty(ShenandoahFreeSetPartitionId::Collector));\n+  assert (end_off <= _rightmosts_empty[int(ShenandoahFreeSetPartitionId::Collector)],\n+          \"free empty regions past the rightmost: \" SSIZE_FORMAT \", bound \" SSIZE_FORMAT,\n+          end_off, rightmost_empty(ShenandoahFreeSetPartitionId::Collector));\n+}\n+#endif\n+\n+ShenandoahFreeSet::ShenandoahFreeSet(ShenandoahHeap* heap, size_t max_regions) :\n+  _heap(heap),\n+  _partitions(max_regions, this),\n+  _right_to_left_bias(false),\n+  _alloc_bias_weight(0)\n+{\n+  clear_internal();\n@@ -65,0 +587,2 @@\n+  shenandoah_assert_heaplocked();\n+\n@@ -67,2 +591,1 @@\n-  \/\/ Leftmost and rightmost bounds provide enough caching to walk bitmap efficiently. Normally,\n-  \/\/ we would find the region to allocate at right away.\n+  \/\/ Leftmost and rightmost bounds provide enough caching to quickly find a region from which to allocate.\n@@ -70,3 +593,3 @@\n-  \/\/ Allocations are biased: new application allocs go to beginning of the heap, and GC allocs\n-  \/\/ go to the end. This makes application allocation faster, because we would clear lots\n-  \/\/ of regions from the beginning most of the time.\n+  \/\/ Allocations are biased: GC allocations are taken from the high end of the heap.  Regular (and TLAB)\n+  \/\/ mutator allocations are taken from the middle of heap, below the memory reserved for Collector.\n+  \/\/ Humongous mutator allocations are taken from the bottom of the heap.\n@@ -74,2 +597,3 @@\n-  \/\/ Free set maintains mutator and collector views, and normally they allocate in their views only,\n-  \/\/ unless we special cases for stealing and mixed allocations.\n+  \/\/ Free set maintains mutator and collector partitions.  Mutator can only allocate from the\n+  \/\/ Mutator partition.  Collector prefers to allocate from the Collector partition, but may steal\n+  \/\/ regions from the Mutator partition if the Collector partition has been depleted.\n@@ -80,1 +604,0 @@\n-\n@@ -82,5 +605,59 @@\n-      for (size_t idx = _mutator_leftmost; idx <= _mutator_rightmost; idx++) {\n-        if (is_mutator_free(idx)) {\n-          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n-          if (result != nullptr) {\n-            return result;\n+      if (_alloc_bias_weight-- <= 0) {\n+        \/\/ We have observed that regions not collected in previous GC cycle tend to congregate at one end or the other\n+        \/\/ of the heap.  Typically, these are the more recently engaged regions and the objects in these regions have not\n+        \/\/ yet had a chance to die (and\/or are treated as floating garbage).  If we use the same allocation bias on each\n+        \/\/ GC pass, these \"most recently\" engaged regions for GC pass N will also be the \"most recently\" engaged regions\n+        \/\/ for GC pass N+1, and the relatively large amount of live data and\/or floating garbage introduced\n+        \/\/ during the most recent GC pass may once again prevent the region from being collected.  We have found that\n+        \/\/ alternating the allocation behavior between GC passes improves evacuation performance by 3-7% on certain\n+        \/\/ benchmarks.  In the best case, this has the effect of consuming these partially consumed regions before\n+        \/\/ the start of the next mark cycle so all of their garbage can be efficiently reclaimed.\n+        \/\/\n+        \/\/ First, finish consuming regions that are already partially consumed so as to more tightly limit ranges of\n+        \/\/ available regions.  Other potential benefits:\n+        \/\/  1. Eventual collection set has fewer regions because we have packed newly allocated objects into fewer regions\n+        \/\/  2. We preserve the \"empty\" regions longer into the GC cycle, reducing likelihood of allocation failures\n+        \/\/     late in the GC cycle.\n+        idx_t non_empty_on_left = (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator)\n+                                     - _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator));\n+        idx_t non_empty_on_right = (_partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator)\n+                                      - _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator));\n+        _right_to_left_bias = (non_empty_on_right > non_empty_on_left);\n+        _alloc_bias_weight = _InitialAllocBiasWeight;\n+      }\n+      if (_right_to_left_bias) {\n+        \/\/ Allocate within mutator free from high memory to low so as to preserve low memory for humongous allocations\n+        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n+          \/\/ Use signed idx.  Otherwise, loop will never terminate.\n+          idx_t leftmost = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost; ) {\n+            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n+                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+            ShenandoahHeapRegion* r = _heap->get_region(idx);\n+            \/\/ try_allocate_in() increases used if the allocation is successful.\n+            HeapWord* result;\n+            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n+            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n+              return result;\n+            }\n+            idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n+          }\n+        }\n+      } else {\n+        \/\/ Allocate from low to high memory.  This keeps the range of fully empty regions more tightly packed.\n+        \/\/ Note that the most recently allocated regions tend not to be evacuated in a given GC cycle.  So this\n+        \/\/ tends to accumulate \"fragmented\" uncollected regions in high memory.\n+        if (!_partitions.is_empty(ShenandoahFreeSetPartitionId::Mutator)) {\n+          \/\/ Use signed idx.  Otherwise, loop will never terminate.\n+          idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+          for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= rightmost; ) {\n+            assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n+                   \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+            ShenandoahHeapRegion* r = _heap->get_region(idx);\n+            \/\/ try_allocate_in() increases used if the allocation is successful.\n+            HeapWord* result;\n+            size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab)? req.min_size(): req.size();\n+            if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n+              return result;\n+            }\n+            idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, idx + 1);\n@@ -90,1 +667,0 @@\n-\n@@ -95,2 +671,1 @@\n-    case ShenandoahAllocRequest::_alloc_shared_gc: {\n-      \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n+      \/\/ GCLABs are for evacuation so we must be in evacuation phase.\n@@ -98,0 +673,1 @@\n+    case ShenandoahAllocRequest::_alloc_shared_gc: {\n@@ -99,7 +675,7 @@\n-      for (size_t c = _collector_rightmost + 1; c > _collector_leftmost; c--) {\n-        size_t idx = c - 1;\n-        if (is_collector_free(idx)) {\n-          HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n-          if (result != nullptr) {\n-            return result;\n-          }\n+      idx_t leftmost_collector = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+      for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx >= leftmost_collector; ) {\n+        assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n+               \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n+        HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n+        if (result != nullptr) {\n+          return result;\n@@ -107,0 +683,1 @@\n+        idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Collector, idx - 1);\n@@ -114,11 +691,12 @@\n-      \/\/ Try to steal the empty region from the mutator view\n-      for (size_t c = _mutator_rightmost + 1; c > _mutator_leftmost; c--) {\n-        size_t idx = c - 1;\n-        if (is_mutator_free(idx)) {\n-          ShenandoahHeapRegion* r = _heap->get_region(idx);\n-          if (can_allocate_from(r)) {\n-            flip_to_gc(r);\n-            HeapWord *result = try_allocate_in(r, req, in_new_region);\n-            if (result != nullptr) {\n-              return result;\n-            }\n+      \/\/ Try to steal an empty region from the mutator view.\n+      idx_t leftmost_mutator_empty = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+      for (idx_t idx = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost_mutator_empty; ) {\n+        assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n+               \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n+        ShenandoahHeapRegion* r = _heap->get_region(idx);\n+        if (can_allocate_from(r)) {\n+          flip_to_gc(r);\n+          HeapWord *result = try_allocate_in(r, req, in_new_region);\n+          if (result != nullptr) {\n+            log_debug(gc)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n+            return result;\n@@ -127,0 +705,1 @@\n+        idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n@@ -129,4 +708,2 @@\n-      \/\/ No dice. Do not try to mix mutator and GC allocations, because\n-      \/\/ URWM moves due to GC allocations would expose unparsable mutator\n-      \/\/ allocations.\n-\n+      \/\/ No dice. Do not try to mix mutator and GC allocations, because adjusting region UWM\n+      \/\/ due to GC allocations would expose unparsable mutator allocations.\n@@ -138,1 +715,0 @@\n-\n@@ -143,4 +719,2 @@\n-  assert (!has_no_alloc_capacity(r), \"Performance: should avoid full regions on this path: \" SIZE_FORMAT, r->index());\n-\n-  if (_heap->is_concurrent_weak_root_in_progress() &&\n-      r->is_trash()) {\n+  assert (has_alloc_capacity(r), \"Performance: should avoid full regions on this path: \" SIZE_FORMAT, r->index());\n+  if (_heap->is_concurrent_weak_root_in_progress() && r->is_trash()) {\n@@ -150,0 +724,1 @@\n+  HeapWord* result = nullptr;\n@@ -151,1 +726,0 @@\n-\n@@ -154,2 +728,4 @@\n-  HeapWord* result = nullptr;\n-  size_t size = req.size();\n+  if (in_new_region) {\n+    log_debug(gc)(\"Using new region (\" SIZE_FORMAT \") for %s (\" PTR_FORMAT \").\",\n+                       r->index(), ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(&req));\n+  }\n@@ -157,0 +733,1 @@\n+  \/\/ req.size() is in words, r->free() is in bytes.\n@@ -158,0 +735,2 @@\n+    \/\/ This is a GCLAB or a TLAB allocation\n+    size_t adjusted_size = req.size();\n@@ -159,2 +738,2 @@\n-    if (size > free) {\n-      size = free;\n+    if (adjusted_size > free) {\n+      adjusted_size = free;\n@@ -162,3 +741,11 @@\n-    if (size >= req.min_size()) {\n-      result = r->allocate(size, req.type());\n-      assert (result != nullptr, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, size);\n+    if (adjusted_size >= req.min_size()) {\n+      result = r->allocate(adjusted_size, req.type());\n+      log_debug(gc)(\"Allocated \" SIZE_FORMAT \" words (adjusted from \" SIZE_FORMAT \") for %s @\" PTR_FORMAT\n+                          \" from %s region \" SIZE_FORMAT \", free bytes remaining: \" SIZE_FORMAT,\n+                          adjusted_size, req.size(), ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(result),\n+                          _partitions.partition_membership_name(r->index()), r->index(), r->free());\n+      assert (result != nullptr, \"Allocation must succeed: free \" SIZE_FORMAT \", actual \" SIZE_FORMAT, free, adjusted_size);\n+      req.set_actual_size(adjusted_size);\n+    } else {\n+      log_trace(gc, free)(\"Failed to shrink TLAB or GCLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+                          \" because min_size() is \" SIZE_FORMAT, req.size(), r->index(), adjusted_size, req.min_size());\n@@ -167,0 +754,1 @@\n+    size_t size = req.size();\n@@ -168,0 +756,8 @@\n+    if (result != nullptr) {\n+      \/\/ Record actual allocation size\n+      log_debug(gc)(\"Allocated \" SIZE_FORMAT \" words for %s @\" PTR_FORMAT\n+                          \" from %s region \" SIZE_FORMAT \", free bytes remaining: \" SIZE_FORMAT,\n+                          size, ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(result),\n+                          _partitions.partition_membership_name(r->index()),  r->index(), r->free());\n+      req.set_actual_size(size);\n+    }\n@@ -173,5 +769,3 @@\n-      increase_used(size * HeapWordSize);\n-    }\n-\n-    \/\/ Record actual allocation size\n-    req.set_actual_size(size);\n+      _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, req.actual_size() * HeapWordSize);\n+    } else {\n+      assert(req.is_gc_alloc(), \"Should be gc_alloc since req wasn't mutator alloc\");\n@@ -179,1 +773,2 @@\n-    if (req.is_gc_alloc()) {\n+      \/\/ For GC allocations, we advance update_watermark because the objects relocated into this memory during\n+      \/\/ evacuation are not updated during evacuation.\n@@ -184,32 +779,2 @@\n-  if (result == nullptr || has_no_alloc_capacity(r)) {\n-    \/\/ Region cannot afford this or future allocations. Retire it.\n-    \/\/\n-    \/\/ While this seems a bit harsh, especially in the case when this large allocation does not\n-    \/\/ fit, but the next small one would, we are risking to inflate scan times when lots of\n-    \/\/ almost-full regions precede the fully-empty region where we want allocate the entire TLAB.\n-    \/\/ TODO: Record first fully-empty region, and use that for large allocations\n-\n-    \/\/ Record the remainder as allocation waste\n-    if (req.is_mutator_alloc()) {\n-      size_t waste = r->free();\n-      if (waste > 0) {\n-        increase_used(waste);\n-        _heap->notify_mutator_alloc_words(waste >> LogHeapWordSize, true);\n-      }\n-    }\n-\n-    size_t num = r->index();\n-    _collector_free_bitmap.clear_bit(num);\n-    _mutator_free_bitmap.clear_bit(num);\n-    \/\/ Touched the bounds? Need to update:\n-    if (touches_bounds(num)) {\n-      adjust_bounds();\n-    }\n-    assert_bounds();\n-  }\n-  return result;\n-}\n-\n-bool ShenandoahFreeSet::touches_bounds(size_t num) const {\n-  return num == _collector_leftmost || num == _collector_rightmost || num == _mutator_leftmost || num == _mutator_rightmost;\n-}\n+  static const size_t min_capacity = (size_t) (ShenandoahHeapRegion::region_size_bytes() * (1.0 - 1.0 \/ ShenandoahEvacWaste));\n+  size_t ac = alloc_capacity(r);\n@@ -217,6 +782,3 @@\n-void ShenandoahFreeSet::recompute_bounds() {\n-  \/\/ Reset to the most pessimistic case:\n-  _mutator_rightmost = _max - 1;\n-  _mutator_leftmost = 0;\n-  _collector_rightmost = _max - 1;\n-  _collector_leftmost = 0;\n+  if (((result == nullptr) && (ac < min_capacity)) || (alloc_capacity(r) < PLAB::min_size() * HeapWordSize)) {\n+    \/\/ Regardless of whether this allocation succeeded, if the remaining memory is less than PLAB:min_size(), retire this region.\n+    \/\/ Note that retire_from_partition() increases used to account for waste.\n@@ -224,3 +786,2 @@\n-  \/\/ ...and adjust from there\n-  adjust_bounds();\n-}\n+    \/\/ Also, if this allocation request failed and the consumed within this region * ShenandoahEvacWaste > region size,\n+    \/\/ then retire the region so that subsequent searches can find available memory more quickly.\n@@ -228,14 +789,5 @@\n-void ShenandoahFreeSet::adjust_bounds() {\n-  \/\/ Rewind both mutator bounds until the next bit.\n-  while (_mutator_leftmost < _max && !is_mutator_free(_mutator_leftmost)) {\n-    _mutator_leftmost++;\n-  }\n-  while (_mutator_rightmost > 0 && !is_mutator_free(_mutator_rightmost)) {\n-    _mutator_rightmost--;\n-  }\n-  \/\/ Rewind both collector bounds until the next bit.\n-  while (_collector_leftmost < _max && !is_collector_free(_collector_leftmost)) {\n-    _collector_leftmost++;\n-  }\n-  while (_collector_rightmost > 0 && !is_collector_free(_collector_rightmost)) {\n-    _collector_rightmost--;\n+    size_t idx = r->index();\n+    _partitions.retire_from_partition(req.is_mutator_alloc()?\n+                                      ShenandoahFreeSetPartitionId::Mutator: ShenandoahFreeSetPartitionId::Collector,\n+                                      idx, r->used());\n+    _partitions.assert_bounds();\n@@ -243,0 +795,1 @@\n+  return result;\n@@ -246,0 +799,1 @@\n+  assert(req.is_mutator_alloc(), \"All humongous allocations are performed by mutator\");\n@@ -249,1 +803,1 @@\n-  size_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n+  idx_t num = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);\n@@ -251,2 +805,2 @@\n-  \/\/ No regions left to satisfy allocation, bye.\n-  if (num > mutator_count()) {\n+  \/\/ Check if there are enough regions left to satisfy allocation.\n+  if (num > (idx_t) _partitions.count(ShenandoahFreeSetPartitionId::Mutator)) {\n@@ -256,0 +810,4 @@\n+  idx_t start_range = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n+  idx_t end_range = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator) + 1;\n+  idx_t last_possible_start = end_range - num;\n+\n@@ -258,3 +816,7 @@\n-\n-  size_t beg = _mutator_leftmost;\n-  size_t end = beg;\n+  idx_t beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator,\n+                                                                            start_range, num);\n+  if (beg > last_possible_start) {\n+    \/\/ Hit the end, goodbye\n+    return nullptr;\n+  }\n+  idx_t end = beg;\n@@ -263,11 +825,26 @@\n-    if (end >= _max) {\n-      \/\/ Hit the end, goodbye\n-      return nullptr;\n-    }\n-\n-    \/\/ If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.\n-    \/\/ If region is not completely free, the current [beg; end] is useless, and we may fast-forward.\n-    if (!is_mutator_free(end) || !can_allocate_from(_heap->get_region(end))) {\n-      end++;\n-      beg = end;\n-      continue;\n+    \/\/ We've confirmed num contiguous regions belonging to Mutator partition, so no need to confirm membership.\n+    \/\/ If region is not completely free, the current [beg; end] is useless, and we may fast-forward.  If we can extend\n+    \/\/ the existing range, we can exploit that certain regions are already known to be in the Mutator free set.\n+    while (!can_allocate_from(_heap->get_region(end))) {\n+      \/\/ region[end] is not empty, so we restart our search after region[end]\n+      idx_t slide_delta = end + 1 - beg;\n+      if (beg + slide_delta > last_possible_start) {\n+        \/\/ no room to slide\n+        return nullptr;\n+      }\n+      for (idx_t span_end = beg + num; slide_delta > 0; slide_delta--) {\n+        if (!_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, span_end)) {\n+          beg = _partitions.find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId::Mutator,\n+                                                                            span_end + 1, num);\n+          break;\n+        } else {\n+          beg++;\n+          span_end++;\n+        }\n+      }\n+      \/\/ Here, either beg identifies a range of num regions all of which are in the Mutator free set, or beg > last_possible_start\n+      if (beg > last_possible_start) {\n+        \/\/ Hit the end, goodbye\n+        return nullptr;\n+      }\n+      end = beg;\n@@ -285,1 +862,0 @@\n-\n@@ -287,1 +863,1 @@\n-  for (size_t i = beg; i <= end; i++) {\n+  for (idx_t i = beg; i <= end; i++) {\n@@ -309,2 +885,0 @@\n-\n-    _mutator_free_bitmap.clear_bit(r->index());\n@@ -313,4 +887,0 @@\n-  \/\/ While individual regions report their true use, all humongous regions are\n-  \/\/ marked used in the free set.\n-  increase_used(ShenandoahHeapRegion::region_size_bytes() * num);\n-\n@@ -322,5 +892,2 @@\n-  \/\/ Allocated at left\/rightmost? Move the bounds appropriately.\n-  if (beg == _mutator_leftmost || end == _mutator_rightmost) {\n-    adjust_bounds();\n-  }\n-  assert_bounds();\n+  \/\/ retire_range_from_partition() will adjust bounds on Mutator free set if appropriate\n+  _partitions.retire_range_from_partition(ShenandoahFreeSetPartitionId::Mutator, beg, end);\n@@ -328,0 +895,3 @@\n+  size_t total_humongous_size = ShenandoahHeapRegion::region_size_bytes() * num;\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, total_humongous_size);\n+  _partitions.assert_bounds();\n@@ -332,17 +902,0 @@\n-bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) {\n-  return r->is_empty() || (r->is_trash() && !_heap->is_concurrent_weak_root_in_progress());\n-}\n-\n-size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {\n-  if (r->is_trash()) {\n-    \/\/ This would be recycled on allocation path\n-    return ShenandoahHeapRegion::region_size_bytes();\n-  } else {\n-    return r->free();\n-  }\n-}\n-\n-bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) {\n-  return alloc_capacity(r) == 0;\n-}\n-\n@@ -373,1 +926,1 @@\n-  assert(_mutator_free_bitmap.at(idx), \"Should be in mutator view\");\n+  assert(_partitions.partition_id_matches(idx, ShenandoahFreeSetPartitionId::Mutator), \"Should be in mutator view\");\n@@ -376,6 +929,4 @@\n-  _mutator_free_bitmap.clear_bit(idx);\n-  _collector_free_bitmap.set_bit(idx);\n-  _collector_leftmost = MIN2(idx, _collector_leftmost);\n-  _collector_rightmost = MAX2(idx, _collector_rightmost);\n-\n-  _capacity -= alloc_capacity(r);\n+  size_t ac = alloc_capacity(r);\n+  _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                               ShenandoahFreeSetPartitionId::Collector, ac);\n+  _partitions.assert_bounds();\n@@ -383,4 +934,2 @@\n-  if (touches_bounds(idx)) {\n-    adjust_bounds();\n-  }\n-  assert_bounds();\n+  \/\/ We do not ensure that the region is no longer trash, relying on try_allocate_in(), which always comes next,\n+  \/\/ to recycle trash before attempting to allocate anything in the region.\n@@ -395,8 +944,1 @@\n-  _mutator_free_bitmap.clear();\n-  _collector_free_bitmap.clear();\n-  _mutator_leftmost = _max;\n-  _mutator_rightmost = 0;\n-  _collector_leftmost = _max;\n-  _collector_rightmost = 0;\n-  _capacity = 0;\n-  _used = 0;\n+  _partitions.make_all_regions_unavailable();\n@@ -405,3 +947,14 @@\n-void ShenandoahFreeSet::rebuild() {\n-  shenandoah_assert_heaplocked();\n-  clear();\n+void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &cset_regions) {\n+\n+  cset_regions = 0;\n+  clear_internal();\n+  size_t region_size_bytes = _partitions.region_size_bytes();\n+  size_t max_regions = _partitions.max_regions();\n+\n+  size_t mutator_leftmost = max_regions;\n+  size_t mutator_rightmost = 0;\n+  size_t mutator_leftmost_empty = max_regions;\n+  size_t mutator_rightmost_empty = 0;\n+\n+  size_t mutator_regions = 0;\n+  size_t mutator_used = 0;\n@@ -411,0 +964,5 @@\n+    if (region->is_trash()) {\n+      \/\/ Trashed regions represent regions that had been in the collection partition but have not yet been \"cleaned up\".\n+      \/\/ The cset regions are not \"trashed\" until we have finished update refs.\n+      cset_regions++;\n+    }\n@@ -412,1 +970,0 @@\n-      assert(!region->is_cset(), \"Shouldn't be adding those to the free set\");\n@@ -414,2 +971,4 @@\n-      \/\/ Do not add regions that would surely fail allocation\n-      if (has_no_alloc_capacity(region)) continue;\n+      \/\/ Do not add regions that would almost surely fail allocation\n+      size_t ac = alloc_capacity(region);\n+      if (ac > PLAB::min_size() * HeapWordSize) {\n+        _partitions.raw_assign_membership(idx, ShenandoahFreeSetPartitionId::Mutator);\n@@ -417,2 +976,16 @@\n-      _capacity += alloc_capacity(region);\n-      assert(_used <= _capacity, \"must not use more than we have\");\n+        if (idx < mutator_leftmost) {\n+          mutator_leftmost = idx;\n+        }\n+        if (idx > mutator_rightmost) {\n+          mutator_rightmost = idx;\n+        }\n+        if (ac == region_size_bytes) {\n+          if (idx < mutator_leftmost_empty) {\n+            mutator_leftmost_empty = idx;\n+          }\n+          if (idx > mutator_rightmost_empty) {\n+            mutator_rightmost_empty = idx;\n+          }\n+        }\n+        mutator_regions++;\n+        mutator_used += (region_size_bytes - ac);\n@@ -420,2 +993,5 @@\n-      assert(!is_mutator_free(idx), \"We are about to add it, it shouldn't be there already\");\n-      _mutator_free_bitmap.set_bit(idx);\n+        log_debug(gc)(\n+          \"  Adding Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to mutator partition\",\n+          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n+          byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n+      }\n@@ -424,0 +1000,3 @@\n+  _partitions.establish_mutator_intervals(mutator_leftmost, mutator_rightmost, mutator_leftmost_empty, mutator_rightmost_empty,\n+                                          mutator_regions, mutator_used);\n+}\n@@ -425,3 +1004,25 @@\n-  \/\/ Evac reserve: reserve trailing space for evacuations\n-  size_t to_reserve = _heap->max_capacity() \/ 100 * ShenandoahEvacReserve;\n-  size_t reserved = 0;\n+void ShenandoahFreeSet::move_regions_from_collector_to_mutator(size_t max_xfer_regions) {\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t collector_empty_xfer = 0;\n+  size_t collector_not_empty_xfer = 0;\n+\n+  \/\/ Process empty regions within the Collector free partition\n+  if ((max_xfer_regions > 0) &&\n+      (_partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector)\n+       <= _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector))) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    idx_t rightmost = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Collector);\n+    for (idx_t idx = _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Collector);\n+         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n+             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+      \/\/ Note: can_allocate_from() denotes that region is entirely empty\n+      if (can_allocate_from(idx)) {\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n+                                                     ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n+        max_xfer_regions--;\n+        collector_empty_xfer += region_size_bytes;\n+      }\n+      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n+    }\n+  }\n@@ -429,2 +1030,19 @@\n-  for (size_t idx = _heap->num_regions() - 1; idx > 0; idx--) {\n-    if (reserved >= to_reserve) break;\n+  \/\/ If there are any non-empty regions within Collector partition, we can also move them to the Mutator free partition\n+  if ((max_xfer_regions > 0) && (_partitions.leftmost(ShenandoahFreeSetPartitionId::Collector)\n+                                 <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector))) {\n+    ShenandoahHeapLocker locker(_heap->lock());\n+    idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n+    for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+         (max_xfer_regions > 0) && (idx <= rightmost); ) {\n+      assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx),\n+             \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+      size_t ac = alloc_capacity(idx);\n+      if (ac > 0) {\n+        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Collector,\n+                                                     ShenandoahFreeSetPartitionId::Mutator, ac);\n+        max_xfer_regions--;\n+        collector_not_empty_xfer += ac;\n+      }\n+      idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n+    }\n+  }\n@@ -432,7 +1050,71 @@\n-    ShenandoahHeapRegion* region = _heap->get_region(idx);\n-    if (_mutator_free_bitmap.at(idx) && can_allocate_from(region)) {\n-      _mutator_free_bitmap.clear_bit(idx);\n-      _collector_free_bitmap.set_bit(idx);\n-      size_t ac = alloc_capacity(region);\n-      _capacity -= ac;\n-      reserved += ac;\n+  size_t collector_xfer = collector_empty_xfer + collector_not_empty_xfer;\n+  log_info(gc)(\"At start of update refs, moving \" SIZE_FORMAT \"%s to Mutator free partition from Collector Reserve\",\n+               byte_size_in_proper_unit(collector_xfer), proper_unit_for_byte_size(collector_xfer));\n+}\n+\n+void ShenandoahFreeSet::prepare_to_rebuild(size_t &cset_regions) {\n+  shenandoah_assert_heaplocked();\n+\n+  log_debug(gc)(\"Rebuilding FreeSet\");\n+\n+  \/\/ This places regions that have alloc_capacity into the mutator partition.\n+  find_regions_with_alloc_capacity(cset_regions);\n+}\n+\n+void ShenandoahFreeSet::finish_rebuild(size_t cset_regions) {\n+  shenandoah_assert_heaplocked();\n+\n+  \/\/ Our desire is to reserve this much memory for future evacuation.  We may end up reserving less, if\n+  \/\/ memory is in short supply.\n+\n+  size_t reserve = _heap->max_capacity() * ShenandoahEvacReserve \/ 100;\n+  size_t available_in_collector_partition = (_partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector)\n+                                             - _partitions.used_by(ShenandoahFreeSetPartitionId::Collector));\n+  size_t additional_reserve;\n+  if (available_in_collector_partition < reserve) {\n+    additional_reserve = reserve - available_in_collector_partition;\n+  } else {\n+    additional_reserve = 0;\n+  }\n+\n+  reserve_regions(reserve);\n+  _partitions.assert_bounds();\n+  log_status();\n+}\n+\n+void ShenandoahFreeSet::rebuild() {\n+  size_t cset_regions;\n+  prepare_to_rebuild(cset_regions);\n+  finish_rebuild(cset_regions);\n+}\n+\n+void ShenandoahFreeSet::reserve_regions(size_t to_reserve) {\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    size_t idx = i - 1;\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+\n+    if (!_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n+      continue;\n+    }\n+\n+    size_t ac = alloc_capacity(r);\n+    assert (ac > 0, \"Membership in free partition implies has capacity\");\n+\n+    bool move_to_collector = _partitions.available_in(ShenandoahFreeSetPartitionId::Collector) < to_reserve;\n+    if (!move_to_collector) {\n+      \/\/ We've satisfied to_reserve\n+      break;\n+    }\n+\n+    if (move_to_collector) {\n+      \/\/ Note: In a previous implementation, regions were only placed into the survivor space (collector_is_free) if\n+      \/\/ they were entirely empty.  This has the effect of causing new Mutator allocation to reside next to objects\n+      \/\/ that have already survived at least one GC, mixing ephemeral with longer-lived objects in the same region.\n+      \/\/ Any objects that have survived a GC are less likely to immediately become garbage, so a region that contains\n+      \/\/ survivor objects is less likely to be selected for the collection set.  This alternative implementation allows\n+      \/\/ survivor regions to continue accumulating other survivor objects, and makes it more likely that ephemeral objects\n+      \/\/ occupy regions comprised entirely of ephemeral objects.  These regions are highly likely to be included in the next\n+      \/\/ collection set, and they are easily evacuated because they have low density of live objects.\n+      _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                   ShenandoahFreeSetPartitionId::Collector, ac);\n+      log_debug(gc)(\"  Shifting region \" SIZE_FORMAT \" from mutator_free to collector_free\", idx);\n@@ -442,2 +1124,7 @@\n-  recompute_bounds();\n-  assert_bounds();\n+  if (LogTarget(Info, gc, free)::is_enabled()) {\n+    size_t reserve = _partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector);\n+    if (reserve < to_reserve) {\n+      log_debug(gc)(\"Wanted \" PROPERFMT \" for young reserve, but only reserved: \" PROPERFMT,\n+                    PROPERFMTARGS(to_reserve), PROPERFMTARGS(reserve));\n+    }\n+  }\n@@ -449,1 +1136,55 @@\n-  LogTarget(Info, gc, ergo) lt;\n+#ifdef ASSERT\n+  \/\/ Dump of the FreeSet details is only enabled if assertions are enabled\n+  if (LogTarget(Debug, gc, free)::is_enabled()) {\n+#define BUFFER_SIZE 80\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    size_t consumed_collector = 0;\n+    size_t available_collector = 0;\n+    size_t consumed_mutator = 0;\n+    size_t available_mutator = 0;\n+\n+    char buffer[BUFFER_SIZE];\n+    for (uint i = 0; i < BUFFER_SIZE; i++) {\n+      buffer[i] = '\\0';\n+    }\n+    log_debug(gc)(\"FreeSet map legend: M:mutator_free C:collector_free H:humongous _:retired\");\n+    log_debug(gc)(\" mutator free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"],\"\n+                  \" collector free range [\" SIZE_FORMAT \"..\" SIZE_FORMAT \"]\",\n+                  _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                  _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                  _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector),\n+                  _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector));\n+\n+    for (uint i = 0; i < _heap->num_regions(); i++) {\n+      ShenandoahHeapRegion *r = _heap->get_region(i);\n+      uint idx = i % 64;\n+      if ((i != 0) && (idx == 0)) {\n+        log_debug(gc)(\" %6u: %s\", i-64, buffer);\n+      }\n+      if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, i)) {\n+        size_t capacity = alloc_capacity(r);\n+        available_mutator += capacity;\n+        consumed_mutator += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'M': 'm';\n+      } else if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, i)) {\n+        size_t capacity = alloc_capacity(r);\n+        available_collector += capacity;\n+        consumed_collector += region_size_bytes - capacity;\n+        buffer[idx] = (capacity == region_size_bytes)? 'C': 'c';\n+      } else if (r->is_humongous()) {\n+        buffer[idx] = 'h';\n+      } else {\n+        buffer[idx] = '_';\n+      }\n+    }\n+    uint remnant = _heap->num_regions() % 64;\n+    if (remnant > 0) {\n+      buffer[remnant] = '\\0';\n+    } else {\n+      remnant = 64;\n+    }\n+    log_debug(gc)(\" %6u: %s\", (uint) (_heap->num_regions() - remnant), buffer);\n+  }\n+#endif\n+\n+  LogTarget(Info, gc, free) lt;\n@@ -455,1 +1196,1 @@\n-      size_t last_idx = 0;\n+      idx_t last_idx = 0;\n@@ -464,2 +1205,3 @@\n-      for (size_t idx = _mutator_leftmost; idx <= _mutator_rightmost; idx++) {\n-        if (is_mutator_free(idx)) {\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n+           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n@@ -468,1 +1210,0 @@\n-\n@@ -470,1 +1211,0 @@\n-\n@@ -481,1 +1221,0 @@\n-\n@@ -484,1 +1223,0 @@\n-\n@@ -493,0 +1231,5 @@\n+      \/\/ Since certain regions that belonged to the Mutator free partition at the time of most recent rebuild may have been\n+      \/\/ retired, the sum of used and capacities within regions that are still in the Mutator free partition may not match\n+      \/\/ my internally tracked values of used() and free().\n+      assert(free == total_free, \"Free memory should match\");\n+\n@@ -494,1 +1237,1 @@\n-               byte_size_in_proper_unit(total_free),    proper_unit_for_byte_size(total_free),\n+               byte_size_in_proper_unit(free),          proper_unit_for_byte_size(free),\n@@ -509,2 +1252,3 @@\n-      if (mutator_count() > 0) {\n-        frag_int = (100 * (total_used \/ mutator_count()) \/ ShenandoahHeapRegion::region_size_bytes());\n+      if (_partitions.count(ShenandoahFreeSetPartitionId::Mutator) > 0) {\n+        frag_int = (100 * (total_used \/ _partitions.count(ShenandoahFreeSetPartitionId::Mutator))\n+                    \/ ShenandoahHeapRegion::region_size_bytes());\n@@ -515,0 +1259,3 @@\n+      ls.print(\"Used: \" SIZE_FORMAT \"%s, Mutator Free: \" SIZE_FORMAT,\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used),\n+               _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n@@ -520,0 +1267,1 @@\n+      size_t total_used = 0;\n@@ -521,2 +1269,3 @@\n-      for (size_t idx = _collector_leftmost; idx <= _collector_rightmost; idx++) {\n-        if (is_collector_free(idx)) {\n+      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n+           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx++) {\n+        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx)) {\n@@ -527,0 +1276,1 @@\n+          total_used += r->used();\n@@ -529,4 +1279,4 @@\n-\n-      ls.print_cr(\"Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s\",\n-                  byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n-                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max));\n+      ls.print(\" Collector Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s; Used: \" SIZE_FORMAT \"%s\",\n+               byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n+               byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n@@ -539,2 +1289,0 @@\n-  assert_bounds();\n-\n@@ -562,16 +1310,0 @@\n-size_t ShenandoahFreeSet::unsafe_peek_free() const {\n-  \/\/ Deliberately not locked, this method is unsafe when free set is modified.\n-\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (index < _max && is_mutator_free(index)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      if (r->free() >= MinTLABSize) {\n-        return r->free();\n-      }\n-    }\n-  }\n-\n-  \/\/ It appears that no regions left\n-  return 0;\n-}\n-\n@@ -579,5 +1311,7 @@\n-  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", mutator_count());\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (is_mutator_free(index)) {\n-      _heap->get_region(index)->print_on(out);\n-    }\n+  out->print_cr(\"Mutator Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    _heap->get_region(index)->print_on(out);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -585,5 +1319,7 @@\n-  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", collector_count());\n-  for (size_t index = _collector_leftmost; index <= _collector_rightmost; index++) {\n-    if (is_collector_free(index)) {\n-      _heap->get_region(index)->print_on(out);\n-    }\n+  out->print_cr(\"Collector Free Set: \" SIZE_FORMAT \"\", _partitions.count(ShenandoahFreeSetPartitionId::Collector));\n+  rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    _heap->get_region(index)->print_on(out);\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, index + 1);\n@@ -593,21 +1329,0 @@\n-\/*\n- * Internal fragmentation metric: describes how fragmented the heap regions are.\n- *\n- * It is derived as:\n- *\n- *               sum(used[i]^2, i=0..k)\n- *   IF = 1 - ------------------------------\n- *              C * sum(used[i], i=0..k)\n- *\n- * ...where k is the number of regions in computation, C is the region capacity, and\n- * used[i] is the used space in the region.\n- *\n- * The non-linearity causes IF to be lower for the cases where the same total heap\n- * used is densely packed. For example:\n- *   a) Heap is completely full  => IF = 0\n- *   b) Heap is half full, first 50% regions are completely full => IF = 0\n- *   c) Heap is half full, each region is 50% full => IF = 1\/2\n- *   d) Heap is quarter full, first 50% regions are completely full => IF = 0\n- *   e) Heap is quarter full, each region is 25% full => IF = 3\/4\n- *   f) Heap has one small object per each region => IF =~ 1\n- *\/\n@@ -619,8 +1334,10 @@\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (is_mutator_free(index)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      size_t used = r->used();\n-      squared += used * used;\n-      linear += used;\n-      count++;\n-    }\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    ShenandoahHeapRegion* r = _heap->get_region(index);\n+    size_t used = r->used();\n+    squared += used * used;\n+    linear += used;\n+    count++;\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -637,13 +1354,0 @@\n-\/*\n- * External fragmentation metric: describes how fragmented the heap is.\n- *\n- * It is derived as:\n- *\n- *   EF = 1 - largest_contiguous_free \/ total_free\n- *\n- * For example:\n- *   a) Heap is completely empty => EF = 0\n- *   b) Heap is completely full => EF = 0\n- *   c) Heap is first-half full => EF = 1\/2\n- *   d) Heap is half full, full and empty regions interleave => EF =~ 1\n- *\/\n@@ -651,1 +1355,1 @@\n-  size_t last_idx = 0;\n+  idx_t last_idx = 0;\n@@ -657,10 +1361,9 @@\n-  for (size_t index = _mutator_leftmost; index <= _mutator_rightmost; index++) {\n-    if (is_mutator_free(index)) {\n-      ShenandoahHeapRegion* r = _heap->get_region(index);\n-      if (r->is_empty()) {\n-        free += ShenandoahHeapRegion::region_size_bytes();\n-        if (last_idx + 1 == index) {\n-          empty_contig++;\n-        } else {\n-          empty_contig = 1;\n-        }\n+  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n+    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n+           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+    ShenandoahHeapRegion* r = _heap->get_region(index);\n+    if (r->is_empty()) {\n+      free += ShenandoahHeapRegion::region_size_bytes();\n+      if (last_idx + 1 == index) {\n+        empty_contig++;\n@@ -668,1 +1371,1 @@\n-        empty_contig = 0;\n+        empty_contig = 1;\n@@ -670,3 +1373,2 @@\n-\n-      max_contig = MAX2(max_contig, empty_contig);\n-      last_idx = index;\n+    } else {\n+      empty_contig = 0;\n@@ -674,0 +1376,3 @@\n+    max_contig = MAX2(max_contig, empty_contig);\n+    last_idx = index;\n+    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -683,27 +1388,0 @@\n-#ifdef ASSERT\n-void ShenandoahFreeSet::assert_bounds() const {\n-  \/\/ Performance invariants. Failing these would not break the free set, but performance\n-  \/\/ would suffer.\n-  assert (_mutator_leftmost <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, _mutator_leftmost,  _max);\n-  assert (_mutator_rightmost < _max, \"rightmost in bounds: \" SIZE_FORMAT \" < \" SIZE_FORMAT, _mutator_rightmost, _max);\n-\n-  assert (_mutator_leftmost == _max || is_mutator_free(_mutator_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _mutator_leftmost);\n-  assert (_mutator_rightmost == 0   || is_mutator_free(_mutator_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _mutator_rightmost);\n-\n-  size_t beg_off = _mutator_free_bitmap.find_first_set_bit(0);\n-  size_t end_off = _mutator_free_bitmap.find_first_set_bit(_mutator_rightmost + 1);\n-  assert (beg_off >= _mutator_leftmost, \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, _mutator_leftmost);\n-  assert (end_off == _max,      \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, _mutator_rightmost);\n-\n-  assert (_collector_leftmost <= _max, \"leftmost in bounds: \"  SIZE_FORMAT \" < \" SIZE_FORMAT, _collector_leftmost,  _max);\n-  assert (_collector_rightmost < _max, \"rightmost in bounds: \" SIZE_FORMAT \" < \" SIZE_FORMAT, _collector_rightmost, _max);\n-\n-  assert (_collector_leftmost == _max || is_collector_free(_collector_leftmost),  \"leftmost region should be free: \" SIZE_FORMAT,  _collector_leftmost);\n-  assert (_collector_rightmost == 0   || is_collector_free(_collector_rightmost), \"rightmost region should be free: \" SIZE_FORMAT, _collector_rightmost);\n-\n-  beg_off = _collector_free_bitmap.find_first_set_bit(0);\n-  end_off = _collector_free_bitmap.find_first_set_bit(_collector_rightmost + 1);\n-  assert (beg_off >= _collector_leftmost, \"free regions before the leftmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT, beg_off, _collector_leftmost);\n-  assert (end_off == _max,      \"free regions past the rightmost: \" SIZE_FORMAT \", bound \" SIZE_FORMAT,  end_off, _collector_rightmost);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1028,"deletions":350,"binary":false,"changes":1378,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,225 @@\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+\n+\/\/ Each ShenandoahHeapRegion is associated with a ShenandoahFreeSetPartitionId.\n+enum class ShenandoahFreeSetPartitionId : uint8_t {\n+  Mutator,                      \/\/ Region is in the Mutator free set: available memory is available to mutators.\n+  Collector,                    \/\/ Region is in the Collector free set: available memory is reserved for evacuations.\n+  NotFree                       \/\/ Region is in no free set: it has no available memory\n+};\n+\n+\/\/ We do not maintain counts, capacity, or used for regions that are not free.  Informally, if a region is NotFree, it is\n+\/\/ in no partition.  NumPartitions represents the size of an array that may be indexed by Mutator or Collector.\n+#define NumPartitions           (ShenandoahFreeSetPartitionId::NotFree)\n+#define IntNumPartitions     int(ShenandoahFreeSetPartitionId::NotFree)\n+#define UIntNumPartitions   uint(ShenandoahFreeSetPartitionId::NotFree)\n+\n+\/\/ ShenandoahRegionPartitions provides an abstraction to help organize the implementation of ShenandoahFreeSet.  This\n+\/\/ class implements partitioning of regions into distinct sets.  Each ShenandoahHeapRegion is either in the Mutator free set,\n+\/\/ the Collector free set, or in neither free set (NotFree).  When we speak of a \"free partition\", we mean partitions that\n+\/\/ for which the ShenandoahFreeSetPartitionId is not equal to NotFree.\n+class ShenandoahRegionPartitions {\n+\n+private:\n+  const ssize_t _max;           \/\/ The maximum number of heap regions\n+  const size_t _region_size_bytes;\n+  const ShenandoahFreeSet* _free_set;\n+  \/\/ For each partition, we maintain a bitmap of which regions are affiliated with his partition.\n+  ShenandoahSimpleBitMap _membership[UIntNumPartitions];\n+\n+  \/\/ For each partition, we track an interval outside of which a region affiliated with that partition is guaranteed\n+  \/\/ not to be found. This makes searches for free space more efficient.  For each partition p, _leftmosts[p]\n+  \/\/ represents its least index, and its _rightmosts[p] its greatest index. Empty intervals are indicated by the\n+  \/\/ canonical [_max, -1].\n+  ssize_t _leftmosts[UIntNumPartitions];\n+  ssize_t _rightmosts[UIntNumPartitions];\n+\n+  \/\/ Allocation for humongous objects needs to find regions that are entirely empty.  For each partion p, _leftmosts_empty[p]\n+  \/\/ represents the first region belonging to this partition that is completely empty and _rightmosts_empty[p] represents the\n+  \/\/ last region that is completely empty.  If there is no completely empty region in this partition, this is represented\n+  \/\/ by the canonical [_max, -1].\n+  ssize_t _leftmosts_empty[UIntNumPartitions];\n+  ssize_t _rightmosts_empty[UIntNumPartitions];\n+\n+  \/\/ For each partition p, _capacity[p] represents the total amount of memory within the partition at the time\n+  \/\/ of the most recent rebuild, _used[p] represents the total amount of memory that has been allocated within this\n+  \/\/ partition (either already allocated as of the rebuild, or allocated since the rebuild).  _capacity[p] and _used[p]\n+  \/\/ are denoted in bytes.  Note that some regions that had been assigned to a particular partition at rebuild time\n+  \/\/ may have been retired following the rebuild.  The tallies for these regions are still reflected in _capacity[p]\n+  \/\/ and _used[p], even though the region may have been removed from the free set.\n+  size_t _capacity[UIntNumPartitions];\n+  size_t _used[UIntNumPartitions];\n+  size_t _region_counts[UIntNumPartitions];\n+\n+  \/\/ Shrink the intervals associated with partition when region idx is removed from this free set\n+  inline void shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx);\n+\n+  \/\/ Shrink the intervals associated with partition when regions low_idx through high_idx inclusive are removed from this free set\n+  inline void shrink_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId partition,\n+                                                                ssize_t low_idx, ssize_t high_idx);\n+  inline void expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx, size_t capacity);\n+\n+#ifndef PRODUCT\n+  void dump_bitmap_row(ssize_t region_idx) const;\n+  void dump_bitmap_range(ssize_t start_region_idx, ssize_t end_region_idx) const;\n+  void dump_bitmap() const;\n+#endif\n+public:\n+  ShenandoahRegionPartitions(size_t max_regions, ShenandoahFreeSet* free_set);\n+  ~ShenandoahRegionPartitions() {}\n+\n+  \/\/ Remove all regions from all partitions and reset all bounds\n+  void make_all_regions_unavailable();\n+\n+  \/\/ Set the partition id for a particular region without adjusting interval bounds or usage\/capacity tallies\n+  inline void raw_assign_membership(size_t idx, ShenandoahFreeSetPartitionId p) {\n+    _membership[int(p)].set_bit(idx);\n+  }\n+\n+  \/\/ Set the Mutator intervals, usage, and capacity according to arguments.  Reset the Collector intervals, used, capacity\n+  \/\/ to represent empty Collector free set.  We use this at the end of rebuild_free_set() to avoid the overhead of making\n+  \/\/ many redundant incremental adjustments to the mutator intervals as the free set is being rebuilt.\n+  void establish_mutator_intervals(ssize_t mutator_leftmost, ssize_t mutator_rightmost,\n+                                   ssize_t mutator_leftmost_empty, ssize_t mutator_rightmost_empty,\n+                                   size_t mutator_region_count, size_t mutator_used);\n+\n+  \/\/ Retire region idx from within partition, , leaving its capacity and used as part of the original free partition's totals.\n+  \/\/ Requires that region idx is in in the Mutator or Collector partitions.  Hereafter, identifies this region as NotFree.\n+  \/\/ Any remnant of available memory at the time of retirement is added to the original partition's total of used bytes.\n+  void retire_from_partition(ShenandoahFreeSetPartitionId p, ssize_t idx, size_t used_bytes);\n+\n+  \/\/ Retire all regions between low_idx and high_idx inclusive from within partition.  Requires that each region idx is\n+  \/\/ in the same Mutator or Collector partition.  Hereafter, identifies each region as NotFree.   Assumes that each region\n+  \/\/ is now considered fully used, since the region is presumably used to represent a humongous object.\n+  void retire_range_from_partition(ShenandoahFreeSetPartitionId partition, ssize_t low_idx, ssize_t high_idx);\n+\n+  \/\/ Place region idx into free set which_partition.  Requires that idx is currently NotFree.\n+  void make_free(ssize_t idx, ShenandoahFreeSetPartitionId which_partition, size_t region_capacity);\n+\n+  \/\/ Place region idx into free partition new_partition, adjusting used and capacity totals for the original and new partition\n+  \/\/ given that available bytes can still be allocated within this region.  Requires that idx is currently not NotFree.\n+  void move_from_partition_to_partition(ssize_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                        ShenandoahFreeSetPartitionId new_partition, size_t available);\n+\n+  const char* partition_membership_name(ssize_t idx) const;\n+\n+  \/\/ Return the index of the next available region >= start_index, or maximum_regions if not found.\n+  inline ssize_t find_index_of_next_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t start_index) const;\n+\n+  \/\/ Return the index of the previous available region <= last_index, or -1 if not found.\n+  inline ssize_t find_index_of_previous_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t last_index) const;\n+\n+  \/\/ Return the index of the next available cluster of cluster_size regions >= start_index, or maximum_regions if not found.\n+  inline ssize_t find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                                 ssize_t start_index, size_t cluster_size) const;\n+\n+  \/\/ Return the index of the previous available cluster of cluster_size regions <= last_index, or -1 if not found.\n+  inline ssize_t find_index_of_previous_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                                     ssize_t last_index, size_t cluster_size) const;\n+\n+  inline bool in_free_set(ShenandoahFreeSetPartitionId which_partition, ssize_t idx) const {\n+    return _membership[int(which_partition)].is_set(idx);\n+  }\n+\n+  \/\/ Returns the ShenandoahFreeSetPartitionId affiliation of region idx, NotFree if this region is not currently in any partition.\n+  \/\/ This does not enforce that free_set membership implies allocation capacity.\n+  inline ShenandoahFreeSetPartitionId membership(ssize_t idx) const;\n+\n+#ifdef ASSERT\n+  \/\/ Returns true iff region idx's membership is which_partition.  If which_partition represents a free set, asserts\n+  \/\/ that the region has allocation capacity.\n+  inline bool partition_id_matches(ssize_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n+#endif\n+\n+  inline size_t max_regions() const { return _max; }\n+\n+  inline size_t region_size_bytes() const { return _region_size_bytes; };\n+\n+  \/\/ The following four methods return the left-most and right-most bounds on ranges of regions representing\n+  \/\/ the requested set.  The _empty variants represent bounds on the range that holds completely empty\n+  \/\/ regions, which are required for humongous allocations and desired for \"very large\" allocations.\n+  \/\/   if the requested which_partition is empty:\n+  \/\/     leftmost() and leftmost_empty() return _max, rightmost() and rightmost_empty() return 0\n+  \/\/   otherwise, expect the following:\n+  \/\/     0 <= leftmost <= leftmost_empty <= rightmost_empty <= rightmost < _max\n+  inline ssize_t leftmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  inline ssize_t rightmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  ssize_t leftmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+  ssize_t rightmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+\n+  inline bool is_empty(ShenandoahFreeSetPartitionId which_partition) const;\n+\n+  inline void increase_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n+\n+  inline size_t capacity_of(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _capacity[int(which_partition)];\n+  }\n+\n+  inline size_t used_by(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _used[int(which_partition)];\n+  }\n+\n+  inline size_t available_in(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _capacity[int(which_partition)] - _used[int(which_partition)];\n+  }\n+\n+  inline void set_capacity_of(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    _capacity[int(which_partition)] = value;\n+  }\n+\n+  inline void set_used_by(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    _used[int(which_partition)] = value;\n+  }\n+\n+  inline size_t count(ShenandoahFreeSetPartitionId which_partition) const { return _region_counts[int(which_partition)]; }\n+\n+  \/\/ Assure leftmost, rightmost, leftmost_empty, and rightmost_empty bounds are valid for all free sets.\n+  \/\/ Valid bounds honor all of the following (where max is the number of heap regions):\n+  \/\/   if the set is empty, leftmost equals max and rightmost equals 0\n+  \/\/   Otherwise (the set is not empty):\n+  \/\/     0 <= leftmost < max and 0 <= rightmost < max\n+  \/\/     the region at leftmost is in the set\n+  \/\/     the region at rightmost is in the set\n+  \/\/     rightmost >= leftmost\n+  \/\/     for every idx that is in the set {\n+  \/\/       idx >= leftmost &&\n+  \/\/       idx <= rightmost\n+  \/\/     }\n+  \/\/   if the set has no empty regions, leftmost_empty equals max and rightmost_empty equals 0\n+  \/\/   Otherwise (the region has empty regions):\n+  \/\/     0 <= leftmost_empty < max and 0 <= rightmost_empty < max\n+  \/\/     rightmost_empty >= leftmost_empty\n+  \/\/     for every idx that is in the set and is empty {\n+  \/\/       idx >= leftmost &&\n+  \/\/       idx <= rightmost\n+  \/\/     }\n+  void assert_bounds() NOT_DEBUG_RETURN;\n+};\n+\n+\/\/ Publicly, ShenandoahFreeSet represents memory that is available to mutator threads.  The public capacity(), used(),\n+\/\/ and available() methods represent this public notion of memory that is under control of the mutator.  Separately,\n+\/\/ ShenandoahFreeSet also represents memory available to garbage collection activities for compaction purposes.\n+\/\/\n+\/\/ The Shenandoah garbage collector evacuates live objects out of specific regions that are identified as members of the\n+\/\/ collection set (cset).\n+\/\/\n+\/\/ The ShenandoahFreeSet endeavors to congregrate survivor objects (objects that have been evacuated at least once) at the\n+\/\/ high end of memory.  New mutator allocations are taken from the low end of memory.  Within the mutator's range of regions,\n+\/\/ humongous allocations are taken from the lowest addresses, and LAB (local allocation buffers) and regular shared allocations\n+\/\/ are taken from the higher address of the mutator's range of regions.  This approach allows longer lasting survivor regions\n+\/\/ to congregate at the top of the heap and longer lasting humongous regions to congregate at the bottom of the heap, with\n+\/\/ short-lived frequently evacuated regions occupying the middle of the heap.\n+\/\/\n+\/\/ Mutator and garbage collection activities tend to scramble the content of regions.  Twice, during each GC pass, we rebuild\n+\/\/ the free set in an effort to restore the efficient segregation of Collector and Mutator regions:\n+\/\/\n+\/\/  1. At the start of evacuation, we know exactly how much memory is going to be evacuated, and this guides our\n+\/\/     sizing of the Collector free set.\n+\/\/\n+\/\/  2. At the end of GC, we have reclaimed all of the memory that was spanned by the cset.  We rebuild here to make\n+\/\/     sure there is enough memory reserved at the high end of memory to hold the objects that might need to be evacuated\n+\/\/     during the next GC pass.\n@@ -34,8 +260,1 @@\n-  CHeapBitMap _mutator_free_bitmap;\n-  CHeapBitMap _collector_free_bitmap;\n-  size_t _max;\n-\n-  \/\/ Left-most and right-most region indexes. There are no free regions outside\n-  \/\/ of [left-most; right-most] index intervals\n-  size_t _mutator_leftmost, _mutator_rightmost;\n-  size_t _collector_leftmost, _collector_rightmost;\n+  ShenandoahRegionPartitions _partitions;\n@@ -43,2 +262,4 @@\n-  size_t _capacity;\n-  size_t _used;\n+  \/\/ Mutator allocations are biased from left-to-right or from right-to-left based on which end of mutator range\n+  \/\/ is most likely to hold partially used regions.  In general, we want to finish consuming partially used\n+  \/\/ regions and retire them in order to reduce the regions that must be searched for each allocation request.\n+  bool _right_to_left_bias;\n@@ -46,1 +267,4 @@\n-  void assert_bounds() const NOT_DEBUG_RETURN;\n+  \/\/ We re-evaluate the left-to-right allocation bias whenever _alloc_bias_weight is less than zero.  Each time\n+  \/\/ we allocate an object, we decrement the count of this value.  Each time we re-evaluate whether to allocate\n+  \/\/ from right-to-left or left-to-right, we reset the value of this counter to _InitialAllocBiasWeight.\n+  ssize_t _alloc_bias_weight;\n@@ -48,2 +272,1 @@\n-  bool is_mutator_free(size_t idx) const;\n-  bool is_collector_free(size_t idx) const;\n+  const ssize_t _InitialAllocBiasWeight = 256;\n@@ -52,0 +275,5 @@\n+\n+  \/\/ While holding the heap lock, allocate memory for a single object or LAB  which is to be entirely contained\n+  \/\/ within a single HeapRegion as characterized by req.\n+  \/\/\n+  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n@@ -53,0 +281,6 @@\n+\n+  \/\/ While holding the heap lock, allocate memory for a humongous object which spans one or more regions that\n+  \/\/ were previously empty.  Regions that represent humongous objects are entirely dedicated to the humongous\n+  \/\/ object.  No other objects are packed into these regions.\n+  \/\/\n+  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n@@ -55,0 +289,4 @@\n+  \/\/ Change region r from the Mutator partition to the GC's Collector partition.  This requires that the region is entirely empty.\n+  \/\/ Typical usage: During evacuation, the GC may find it needs more memory than had been reserved at the start of evacuation to\n+  \/\/ hold evacuated objects.  If this occurs and memory is still available in the Mutator's free set, we will flip a region from\n+  \/\/ the Mutator free set into the Collector free set.\n@@ -56,0 +294,2 @@\n+  void clear_internal();\n+  void try_recycle_trashed(ShenandoahHeapRegion *r);\n@@ -57,3 +297,5 @@\n-  void recompute_bounds();\n-  void adjust_bounds();\n-  bool touches_bounds(size_t num) const;\n+  \/\/ Returns true iff this region is entirely available, either because it is empty() or because it has been found to represent\n+  \/\/ immediate trash and we'll be able to immediately recycle it.  Note that we cannot recycle immediate trash if\n+  \/\/ concurrent weak root processing is in progress.\n+  inline bool can_allocate_from(ShenandoahHeapRegion *r) const;\n+  inline bool can_allocate_from(size_t idx) const;\n@@ -61,2 +303,1 @@\n-  void increase_used(size_t amount);\n-  void clear_internal();\n+  inline bool has_alloc_capacity(ShenandoahHeapRegion *r) const;\n@@ -64,2 +305,5 @@\n-  size_t collector_count() const { return _collector_free_bitmap.count_one_bits(); }\n-  size_t mutator_count()   const { return _mutator_free_bitmap.count_one_bits();   }\n+  \/\/ This function places all regions that have allocation capacity into the mutator_partition, identifying regions\n+  \/\/ that have no allocation capacity as NotFree.  Subsequently, we will move some of the mutator regions into the\n+  \/\/ collector partition with the intent of packing collector memory into the highest (rightmost) addresses of the\n+  \/\/ heap, with mutator memory consuming the lowest addresses of the heap.\n+  void find_regions_with_alloc_capacity(size_t &cset_regions);\n@@ -67,1 +311,4 @@\n-  void try_recycle_trashed(ShenandoahHeapRegion *r);\n+  \/\/ Having placed all regions that have allocation capacity into the mutator partition, move some of these regions from\n+  \/\/ the mutator partition into the collector partition in order to assure that the memory available for allocations within\n+  \/\/ the collector partition is at least to_reserve.\n+  void reserve_regions(size_t to_reserve);\n@@ -69,3 +316,4 @@\n-  bool can_allocate_from(ShenandoahHeapRegion *r);\n-  size_t alloc_capacity(ShenandoahHeapRegion *r);\n-  bool has_no_alloc_capacity(ShenandoahHeapRegion *r);\n+  \/\/ Overwrite arguments to represent the number of regions to be reclaimed from the cset\n+  void prepare_to_rebuild(size_t &cset_regions);\n+\n+  void finish_rebuild(size_t cset_regions);\n@@ -76,0 +324,4 @@\n+  \/\/ Public because ShenandoahRegionPartitions assertions require access.\n+  inline size_t alloc_capacity(ShenandoahHeapRegion *r) const;\n+  inline size_t alloc_capacity(size_t idx) const;\n+\n@@ -79,1 +331,10 @@\n-  void recycle_trash();\n+  \/\/ Move up to cset_regions number of regions from being available to the collector to being available to the mutator.\n+  \/\/\n+  \/\/ Typical usage: At the end of evacuation, when the collector no longer needs the regions that had been reserved\n+  \/\/ for evacuation, invoke this to make regions available for mutator allocations.\n+  \/\/\n+  \/\/ Note that we plan to replenish the Collector reserve at the end of update refs, at which time all\n+  \/\/ of the regions recycled from the collection set will be available.  If the very unlikely event that there\n+  \/\/ are fewer regions in the collection set than remain in the collector set, we limit the transfer in order\n+  \/\/ to assure that the replenished Collector reserve can be sufficiently large.\n+  void move_regions_from_collector_to_mutator(size_t cset_regions);\n@@ -81,0 +342,1 @@\n+  void recycle_trash();\n@@ -83,5 +345,5 @@\n-  size_t capacity()  const { return _capacity; }\n-  size_t used()      const { return _used;     }\n-  size_t available() const {\n-    assert(_used <= _capacity, \"must use less than capacity\");\n-    return _capacity - _used;\n+  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator); }\n+  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);     }\n+  inline size_t available() const {\n+    assert(used() <= capacity(), \"must use less than capacity\");\n+    return capacity() - used();\n@@ -93,0 +355,21 @@\n+  \/*\n+   * Internal fragmentation metric: describes how fragmented the heap regions are.\n+   *\n+   * It is derived as:\n+   *\n+   *               sum(used[i]^2, i=0..k)\n+   *   IF = 1 - ------------------------------\n+   *              C * sum(used[i], i=0..k)\n+   *\n+   * ...where k is the number of regions in computation, C is the region capacity, and\n+   * used[i] is the used space in the region.\n+   *\n+   * The non-linearity causes IF to be lower for the cases where the same total heap\n+   * used is densely packed. For example:\n+   *   a) Heap is completely full  => IF = 0\n+   *   b) Heap is half full, first 50% regions are completely full => IF = 0\n+   *   c) Heap is half full, each region is 50% full => IF = 1\/2\n+   *   d) Heap is quarter full, first 50% regions are completely full => IF = 0\n+   *   e) Heap is quarter full, each region is 25% full => IF = 3\/4\n+   *   f) Heap has one small object per each region => IF =~ 1\n+   *\/\n@@ -94,0 +377,14 @@\n+\n+  \/*\n+   * External fragmentation metric: describes how fragmented the heap is.\n+   *\n+   * It is derived as:\n+   *\n+   *   EF = 1 - largest_contiguous_free \/ total_free\n+   *\n+   * For example:\n+   *   a) Heap is completely empty => EF = 0\n+   *   b) Heap is completely full => EF = 0\n+   *   c) Heap is first-half full => EF = 1\/2\n+   *   d) Heap is half full, full and empty regions interleave => EF =~ 1\n+   *\/\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":327,"deletions":30,"binary":false,"changes":357,"status":"modified"},{"patch":"@@ -915,1 +915,0 @@\n-    _heap->free_set()->clear();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1122,0 +1122,77 @@\n+oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n+    \/\/ This thread went through the OOM during evac protocol and it is safe to return\n+    \/\/ the forward pointer. It must not attempt to evacuate any more.\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  assert(ShenandoahThreadLocalData::is_evac_allowed(thread), \"must be enclosed in oom-evac scope\");\n+\n+  size_t size = p->size();\n+\n+  assert(!heap_region_containing(p)->is_humongous(), \"never evacuate humongous objects\");\n+\n+  bool alloc_from_gclab = true;\n+  HeapWord* copy = nullptr;\n+\n+#ifdef ASSERT\n+  if (ShenandoahOOMDuringEvacALot &&\n+      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n+    copy = nullptr;\n+  } else {\n+#endif\n+    if (UseTLAB) {\n+      copy = allocate_from_gclab(thread, size);\n+    }\n+    if (copy == nullptr) {\n+      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);\n+      copy = allocate_memory(req);\n+      alloc_from_gclab = false;\n+    }\n+#ifdef ASSERT\n+  }\n+#endif\n+\n+  if (copy == nullptr) {\n+    control_thread()->handle_alloc_failure_evac(size);\n+\n+    _oom_evac_handler.handle_out_of_memory_during_evacuation();\n+\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  \/\/ Copy the object:\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n+\n+  \/\/ Try to install the new forwarding pointer.\n+  oop copy_val = cast_to_oop(copy);\n+  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+\n+  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n+  if (result == copy_val) {\n+    \/\/ Successfully evacuated. Our copy is now the public one!\n+    shenandoah_assert_correct(nullptr, copy_val);\n+    return copy_val;\n+  }  else {\n+    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n+    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n+    \/\/ But if it happens to contain references to evacuated regions, those references would\n+    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n+    \/\/ it the next cycle.\n+    \/\/\n+    \/\/ For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next\n+    \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n+    \/\/ do this. For non-GCLAB allocations, we have no way to retract the allocation, and\n+    \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n+    \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n+    if (alloc_from_gclab) {\n+      ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n+    } else {\n+      fill_with_object(copy, size);\n+      shenandoah_assert_correct(nullptr, copy_val);\n+    }\n+    shenandoah_assert_correct(nullptr, result);\n+    return result;\n+  }\n+}\n+\n@@ -1294,1 +1371,8 @@\n-  tcl->do_thread(_control_thread);\n+  if (_shenandoah_policy->is_at_shutdown()) {\n+    return;\n+  }\n+\n+  if (_control_thread != nullptr) {\n+    tcl->do_thread(_control_thread);\n+  }\n+\n@@ -1640,23 +1724,0 @@\n-class ShenandoahInitMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-public:\n-  ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-    if (r->is_active()) {\n-      \/\/ Check if region needs updating its TAMS. We have updated it already during concurrent\n-      \/\/ reset, so it is very likely we don't need to do another write here.\n-      if (_ctx->top_at_mark_start(r) != r->top()) {\n-        _ctx->capture_top_at_mark_start(r);\n-      }\n-    } else {\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should already have correct TAMS\", r->index());\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n@@ -1874,1 +1935,1 @@\n-  \/\/ Step 0. Notify policy to disable event recording.\n+  \/\/ Step 0. Notify policy to disable event recording and prevent visiting gc threads during shutdown\n@@ -2122,1 +2183,1 @@\n-      do_work<ShenandoahConcUpdateRefsClosure>();\n+      do_work<ShenandoahConcUpdateRefsClosure>(worker_id);\n@@ -2125,1 +2186,1 @@\n-      do_work<ShenandoahSTWUpdateRefsClosure>();\n+      do_work<ShenandoahSTWUpdateRefsClosure>(worker_id);\n@@ -2131,1 +2192,1 @@\n-  void do_work() {\n+  void do_work(uint worker_id) {\n@@ -2133,0 +2194,10 @@\n+    if (CONCURRENT && (worker_id == 0)) {\n+      \/\/ We ask the first worker to replenish the Mutator free set by moving regions previously reserved to hold the\n+      \/\/ results of evacuation.  These reserves are no longer necessary because evacuation has completed.\n+      size_t cset_regions = _heap->collection_set()->count();\n+      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled because\n+      \/\/ we need the reclaimed collection set regions to replenish the collector reserves\n+      _heap->free_set()->move_regions_from_collector_to_mutator(cset_regions);\n+    }\n+    \/\/ If !CONCURRENT, there's no value in expanding Mutator free set\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":99,"deletions":28,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-  inline oop evacuate_object(oop src, Thread* thread);\n+  oop evacuate_object(oop src, Thread* thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -290,77 +290,0 @@\n-inline oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {\n-  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n-    \/\/ This thread went through the OOM during evac protocol and it is safe to return\n-    \/\/ the forward pointer. It must not attempt to evacuate any more.\n-    return ShenandoahBarrierSet::resolve_forwarded(p);\n-  }\n-\n-  assert(ShenandoahThreadLocalData::is_evac_allowed(thread), \"must be enclosed in oom-evac scope\");\n-\n-  size_t size = p->size();\n-\n-  assert(!heap_region_containing(p)->is_humongous(), \"never evacuate humongous objects\");\n-\n-  bool alloc_from_gclab = true;\n-  HeapWord* copy = nullptr;\n-\n-#ifdef ASSERT\n-  if (ShenandoahOOMDuringEvacALot &&\n-      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n-        copy = nullptr;\n-  } else {\n-#endif\n-    if (UseTLAB) {\n-      copy = allocate_from_gclab(thread, size);\n-    }\n-    if (copy == nullptr) {\n-      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);\n-      copy = allocate_memory(req);\n-      alloc_from_gclab = false;\n-    }\n-#ifdef ASSERT\n-  }\n-#endif\n-\n-  if (copy == nullptr) {\n-    control_thread()->handle_alloc_failure_evac(size);\n-\n-    _oom_evac_handler.handle_out_of_memory_during_evacuation();\n-\n-    return ShenandoahBarrierSet::resolve_forwarded(p);\n-  }\n-\n-  \/\/ Copy the object:\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n-\n-  \/\/ Try to install the new forwarding pointer.\n-  oop copy_val = cast_to_oop(copy);\n-  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n-\n-  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n-  if (result == copy_val) {\n-    \/\/ Successfully evacuated. Our copy is now the public one!\n-    shenandoah_assert_correct(nullptr, copy_val);\n-    return copy_val;\n-  }  else {\n-    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n-    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n-    \/\/ But if it happens to contain references to evacuated regions, those references would\n-    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n-    \/\/ it the next cycle.\n-    \/\/\n-    \/\/ For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next\n-    \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n-    \/\/ do this. For non-GCLAB allocations, we have no way to retract the allocation, and\n-    \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n-    \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n-    if (alloc_from_gclab) {\n-      ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n-    } else {\n-      fill_with_object(copy, size);\n-      shenandoah_assert_correct(nullptr, copy_val);\n-    }\n-    shenandoah_assert_correct(nullptr, result);\n-    return result;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-  while (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+  while (Atomic::load(&_state) == locked ||\n+         Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+\n+ShenandoahSimpleBitMap::ShenandoahSimpleBitMap(size_t num_bits) :\n+    _num_bits(num_bits),\n+    _num_words(align_up(num_bits, BitsPerWord) \/ BitsPerWord),\n+    _bitmap(NEW_C_HEAP_ARRAY(uintx, _num_words, mtGC))\n+{\n+  clear_all();\n+}\n+\n+ShenandoahSimpleBitMap::~ShenandoahSimpleBitMap() {\n+  if (_bitmap != nullptr) {\n+    FREE_C_HEAP_ARRAY(uintx, _bitmap);\n+  }\n+}\n+\n+size_t ShenandoahSimpleBitMap::count_leading_ones(idx_t start_idx) const {\n+  assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition\");\n+  size_t array_idx = start_idx >> LogBitsPerWord;\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+  uintx mask = ~right_n_bits(bit_number);\n+  size_t counted_ones = 0;\n+  while ((element_bits & mask) == mask) {\n+    \/\/ All bits numbered >= bit_number are set\n+    size_t found_ones = BitsPerWord - bit_number;\n+    counted_ones += found_ones;\n+    \/\/ Dead code: do not need to compute: start_idx += found_ones;\n+    \/\/ Strength reduction:                array_idx = (start_idx >> LogBitsPerWord)\n+    array_idx++;\n+    element_bits = _bitmap[array_idx];\n+    \/\/ Constant folding:                  bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    bit_number = 0;\n+    \/\/ Constant folding:                  mask = ~right_n_bits(bit_number);\n+    mask = ~0;\n+  }\n+\n+  \/\/ Add in number of consecutive ones starting with the_bit and including more significant bits and return result\n+  uintx aligned = element_bits >> bit_number;\n+  uintx complement = ~aligned;\n+  return counted_ones + count_trailing_zeros<uintx>(complement);\n+}\n+\n+size_t ShenandoahSimpleBitMap::count_trailing_ones(idx_t last_idx) const {\n+  assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+  size_t array_idx = last_idx >> LogBitsPerWord;\n+  uintx element_bits = _bitmap[array_idx];\n+  uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+  \/\/ All ones from bit 0 to the_bit\n+  uintx mask = right_n_bits(bit_number + 1);\n+  size_t counted_ones = 0;\n+  while ((element_bits & mask) == mask) {\n+    \/\/ All bits numbered <= bit_number are set\n+    size_t found_ones = bit_number + 1;\n+    counted_ones += found_ones;\n+    \/\/ Dead code: do not need to compute: last_idx -= found_ones;\n+    array_idx--;\n+    element_bits = _bitmap[array_idx];\n+    \/\/ Constant folding:                  bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    bit_number = BitsPerWord - 1;\n+    \/\/ Constant folding:                  mask = right_n_bits(bit_number + 1);\n+    mask = ~0;\n+  }\n+\n+  \/\/ Add in number of consecutive ones starting with the_bit and including less significant bits and return result\n+  uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n+  uintx complement = ~aligned;\n+  return counted_ones + count_leading_zeros<uintx>(complement);\n+}\n+\n+bool ShenandoahSimpleBitMap::is_forward_consecutive_ones(idx_t start_idx, idx_t count) const {\n+  while (count > 0) {\n+    assert((start_idx >= 0) && (start_idx < _num_bits), \"precondition: start_idx: \" SSIZE_FORMAT \", count: \" SSIZE_FORMAT,\n+           start_idx, count);\n+    assert(start_idx + count <= (idx_t) _num_bits, \"precondition\");\n+    size_t array_idx = start_idx >> LogBitsPerWord;\n+    uintx bit_number = start_idx & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    uintx bits_to_examine  = BitsPerWord - bit_number;\n+    element_bits >>= bit_number;\n+    uintx complement = ~element_bits;\n+    uintx trailing_ones;\n+    if (complement != 0) {\n+      trailing_ones = count_trailing_zeros<uintx>(complement);\n+    } else {\n+      trailing_ones = bits_to_examine;\n+    }\n+    if (trailing_ones >= (uintx) count) {\n+      return true;\n+    } else if (trailing_ones == bits_to_examine) {\n+      start_idx += bits_to_examine;\n+      count -= bits_to_examine;\n+      \/\/ Repeat search with smaller goal\n+    } else {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool ShenandoahSimpleBitMap::is_backward_consecutive_ones(idx_t last_idx, idx_t count) const {\n+  while (count > 0) {\n+    assert((last_idx >= 0) && (last_idx < _num_bits), \"precondition\");\n+    assert(last_idx - count >= -1, \"precondition\");\n+    size_t array_idx = last_idx >> LogBitsPerWord;\n+    uintx bit_number = last_idx & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    uintx bits_to_examine = bit_number + 1;\n+    element_bits <<= (BitsPerWord - bits_to_examine);\n+    uintx complement = ~element_bits;\n+    uintx leading_ones;\n+    if (complement != 0) {\n+      leading_ones = count_leading_zeros<uintx>(complement);\n+    } else {\n+      leading_ones = bits_to_examine;\n+    }\n+    if (leading_ones >= (uintx) count) {\n+      return true;\n+    } else if (leading_ones == bits_to_examine) {\n+      last_idx -= leading_ones;\n+      count -= leading_ones;\n+      \/\/ Repeat search with smaller goal\n+    } else {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+idx_t ShenandoahSimpleBitMap::find_first_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  idx_t start_boundary = end - num_bits;\n+  if (beg > start_boundary) {\n+    return end;\n+  }\n+  uintx array_idx = beg >> LogBitsPerWord;\n+  uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  if (bit_number > 0) {\n+    uintx mask_out = right_n_bits(bit_number);\n+    element_bits &= ~mask_out;\n+  }\n+\n+  \/\/ The following loop minimizes the number of spans probed in order to find num_bits consecutive bits.\n+  \/\/ For example, if bit_number = beg = 0, num_bits = 8, and element bits equals 00111111_11000000_00000000_10011000B,\n+  \/\/ we need only 3 probes to find the match at bit offset 22.\n+  \/\/\n+  \/\/ Let beg = 0\n+  \/\/ element_bits = 00111111_11000000_00000000_10011000B;\n+  \/\/                                           ________   (the searched span)\n+  \/\/                                           ^   ^  ^- bit_number = beg = 0\n+  \/\/                                           |   +-- next_start_candidate_1 (where next 1 is found)\n+  \/\/                                           +------ next_start_candidate_2 (start of the trailing 1s within span)\n+  \/\/ Let beg = 7\n+  \/\/ element_bits = 00111111_11000000_00000000_10011000B;\n+  \/\/                          ^       ^_________   (the searched span)\n+  \/\/                          |       |        ^- bit_number = beg = 7\n+  \/\/                          |       +---------- next_start_candidate_2 (there are no trailing 1s within span)\n+  \/\/                          +------------------ next_start_candidate_1 (where next 1 is found)\n+  \/\/ Let beg = 22\n+  \/\/ Let beg = 22\n+  \/\/ element_bits = 00111111_11000001_11111100_10011000B;\n+  \/\/                  _________   (the searched span)\n+  \/\/                          ^- bit_number = beg = 18\n+  \/\/ Here, is_forward_consecutive_ones(22, 8) succeeds and we report the match\n+\n+  while (true) {\n+    if (element_bits == 0) {\n+      \/\/ move to the next element\n+      beg += BitsPerWord - bit_number;\n+      if (beg > start_boundary) {\n+        \/\/ No match found.\n+        return end;\n+      }\n+      array_idx++;\n+      bit_number = 0;\n+      element_bits = _bitmap[array_idx];\n+    } else if (is_forward_consecutive_ones(beg, num_bits)) {\n+      return beg;\n+    } else {\n+      \/\/ There is at least one non-zero bit within the masked element_bits. Arrange to skip over bits that\n+      \/\/ cannot be part of a consecutive-ones match.\n+      uintx next_set_bit = count_trailing_zeros<uintx>(element_bits);\n+      uintx next_start_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n+      \/\/ There is at least one zero bit in this span. Align the next probe at the start of trailing ones for probed span,\n+      \/\/ or align at end of span if this span has no trailing ones.\n+      size_t trailing_ones = count_trailing_ones(beg + num_bits - 1);\n+      uintx next_start_candidate_2 = beg + num_bits - trailing_ones;\n+\n+      beg = MAX2(next_start_candidate_1, next_start_candidate_2);\n+      if (beg > start_boundary) {\n+        \/\/ No match found.\n+        return end;\n+      }\n+      array_idx = beg >> LogBitsPerWord;\n+      element_bits = _bitmap[array_idx];\n+      bit_number = beg & right_n_bits(LogBitsPerWord);\n+      if (bit_number > 0) {\n+        size_t mask_out = right_n_bits(bit_number);\n+        element_bits &= ~mask_out;\n+      }\n+    }\n+  }\n+}\n+\n+idx_t ShenandoahSimpleBitMap::find_last_consecutive_set_bits(const idx_t beg, idx_t end, const size_t num_bits) const {\n+\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+\n+  \/\/ Stop looking if there are not num_bits remaining in probe space.\n+  idx_t last_boundary = beg + num_bits;\n+  if (end < last_boundary) {\n+    return beg;\n+  }\n+\n+  size_t array_idx = end >> LogBitsPerWord;\n+  uintx bit_number = end & right_n_bits(LogBitsPerWord);\n+  uintx element_bits = _bitmap[array_idx];\n+  if (bit_number < BitsPerWord - 1) {\n+    uintx mask_in = right_n_bits(bit_number + 1);\n+    element_bits &= mask_in;\n+  }\n+\n+  \/\/ See comment in find_first_consecutive_set_bits to understand how this loop works.\n+  while (true) {\n+    if (element_bits == 0) {\n+      \/\/ move to the previous element\n+      end -= bit_number + 1;\n+      if (end < last_boundary) {\n+        \/\/ No match found.\n+        return beg;\n+      }\n+      array_idx--;\n+      bit_number = BitsPerWord - 1;\n+      element_bits = _bitmap[array_idx];\n+    } else if (is_backward_consecutive_ones(end, num_bits)) {\n+      return end + 1 - num_bits;\n+    } else {\n+      \/\/ There is at least one non-zero bit within the masked element_bits. Arrange to skip over bits that\n+      \/\/ cannot be part of a consecutive-ones match.\n+      uintx next_set_bit = BitsPerWord - (1 + count_leading_zeros<uintx>(element_bits));\n+      uintx next_last_candidate_1 = (array_idx << LogBitsPerWord) + next_set_bit;\n+\n+      \/\/ There is at least one zero bit in this span.  Align the next probe at the end of leading ones for probed span,\n+      \/\/ or align before start of span if this span has no leading ones.\n+      size_t leading_ones = count_leading_ones(end - (num_bits - 1));\n+      uintx next_last_candidate_2 = end - (num_bits - leading_ones);\n+\n+      end = MIN2(next_last_candidate_1, next_last_candidate_2);\n+      if (end < last_boundary) {\n+        \/\/ No match found.\n+        return beg;\n+      }\n+      array_idx = end >> LogBitsPerWord;\n+      bit_number = end & right_n_bits(LogBitsPerWord);\n+      element_bits = _bitmap[array_idx];\n+      if (bit_number < BitsPerWord - 1){\n+        size_t mask_in = right_n_bits(bit_number + 1);\n+        element_bits &= mask_in;\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.cpp","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n+\n+#include <cstddef>\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+\n+\/\/ TODO: Merge the enhanced capabilities of ShenandoahSimpleBitMap into src\/hotspot\/share\/utilities\/bitMap.hpp\n+\/\/       and deprecate ShenandoahSimpleBitMap.  The key enhanced capabilities to be integrated include:\n+\/\/\n+\/\/   1. Allow searches from high to low memory (when biasing allocations towards the top of the heap)\n+\/\/   2. Allow searches for clusters of contiguous set bits (to expedite allocation for humongous objects)\n+\/\/\n+\/\/ idx_t is defined here as ssize_t.  In src\/hotspot\/share\/utiliities\/bitMap.hpp, idx is defined as size_t.\n+\/\/ This is a significant incompatibility.\n+\/\/\n+\/\/ The API and internal implementation of ShenandoahSimpleBitMap and ShenandoahRegionPartitions use idx_t to\n+\/\/ represent index, even though index is \"inherently\" unsigned.  There are two reasons for this choice:\n+\/\/  1. We use -1 as a sentinel value to represent empty partitions.  This same value may be used to represent\n+\/\/     failure to find a previous set bit or previous range of set bits.\n+\/\/  2. Certain loops are written most naturally if the iterator, which may hold the sentinel -1 value, can be\n+\/\/     declared as signed and the terminating condition can be < 0.\n+\n+typedef ssize_t idx_t;\n+\n+\/\/ ShenandoahSimpleBitMap resembles CHeapBitMap but adds missing support for find_first_consecutive_set_bits() and\n+\/\/ find_last_consecutive_set_bits.  An alternative refactoring of code would subclass CHeapBitMap, but this might\n+\/\/ break abstraction rules, because efficient implementation requires assumptions about superclass internals that\n+\/\/ might be violatee through future software maintenance.\n+class ShenandoahSimpleBitMap {\n+  const idx_t _num_bits;\n+  const size_t _num_words;\n+  uintx* const _bitmap;\n+\n+public:\n+  ShenandoahSimpleBitMap(size_t num_bits);\n+\n+  ~ShenandoahSimpleBitMap();\n+\n+  void clear_all() {\n+    for (size_t i = 0; i < _num_words; i++) {\n+      _bitmap[i] = 0;\n+    }\n+  }\n+\n+private:\n+\n+  \/\/ Count consecutive ones in forward order, starting from start_idx.  Requires that there is at least one zero\n+  \/\/ between start_idx and index value (_num_bits - 1), inclusive.\n+  size_t count_leading_ones(idx_t start_idx) const;\n+\n+  \/\/ Count consecutive ones in reverse order, starting from last_idx.  Requires that there is at least one zero\n+  \/\/ between last_idx and index value zero, inclusive.\n+  size_t count_trailing_ones(idx_t last_idx) const;\n+\n+  bool is_forward_consecutive_ones(idx_t start_idx, idx_t count) const;\n+  bool is_backward_consecutive_ones(idx_t last_idx, idx_t count) const;\n+\n+public:\n+\n+  inline idx_t aligned_index(idx_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    idx_t array_idx = idx & ~right_n_bits(LogBitsPerWord);\n+    return array_idx;\n+  }\n+\n+  inline constexpr idx_t alignment() const {\n+    return BitsPerWord;\n+  }\n+\n+  \/\/ For testing\n+  inline idx_t size() const {\n+    return _num_bits;\n+  }\n+\n+  \/\/ Return the word that holds idx bit and its neighboring bits.\n+  inline uintx bits_at(idx_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    idx_t array_idx = idx >> LogBitsPerWord;\n+    return _bitmap[array_idx];\n+  }\n+\n+  inline void set_bit(idx_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    _bitmap[array_idx] |= the_bit;\n+  }\n+\n+  inline void clear_bit(idx_t idx) {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    _bitmap[array_idx] &= ~the_bit;\n+  }\n+\n+  inline bool is_set(idx_t idx) const {\n+    assert((idx >= 0) && (idx < _num_bits), \"precondition\");\n+    assert(idx >= 0, \"precondition\");\n+    size_t array_idx = idx >> LogBitsPerWord;\n+    uintx bit_number = idx & right_n_bits(LogBitsPerWord);\n+    uintx the_bit = nth_bit(bit_number);\n+    return (_bitmap[array_idx] & the_bit)? true: false;\n+  }\n+\n+  \/\/ Return the index of the first set bit in the range [beg, size()), or size() if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_first_set_bit(idx_t beg) const;\n+\n+  \/\/ Return the index of the first set bit in the range [beg, end), or end if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_first_set_bit(idx_t beg, idx_t end) const;\n+\n+  \/\/ Return the index of the last set bit in the range (-1, end], or -1 if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_last_set_bit(idx_t end) const;\n+\n+  \/\/ Return the index of the last set bit in the range (beg, end], or beg if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  inline idx_t find_last_set_bit(idx_t beg, idx_t end) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the first set bit is within\n+  \/\/   the range [beg, size()), or size() if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg is within the valid range for the bitmap.\n+  inline idx_t find_first_consecutive_set_bits(idx_t beg, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the first set bit is within\n+  \/\/   the range [beg, end), or end if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  idx_t find_first_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the last run of <num_bits> consecutive set bits for which the entire run of set bits is within\n+  \/\/ the range (-1, end], or -1 if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: end is within the valid range for the bitmap.\n+  inline idx_t find_last_consecutive_set_bits(idx_t end, size_t num_bits) const;\n+\n+  \/\/ Return the start index of the first run of <num_bits> consecutive set bits for which the entire run of set bits is within\n+  \/\/ the range (beg, end], or beg if the run of <num_bits> is not found within this range.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  idx_t find_last_consecutive_set_bits(idx_t beg, idx_t end, size_t num_bits) const;\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.hpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+\n+inline idx_t ShenandoahSimpleBitMap::find_first_set_bit(idx_t beg, idx_t end) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+  assert((end > beg) && (end <= _num_bits), \"precondition\");\n+  do {\n+    size_t array_idx = beg >> LogBitsPerWord;\n+    uintx bit_number = beg & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    if (bit_number > 0) {\n+      uintx mask_out = right_n_bits(bit_number);\n+      element_bits &= ~mask_out;\n+    }\n+    if (element_bits) {\n+      \/\/ The next set bit is here.  Find first set bit >= bit_number;\n+      uintx aligned = element_bits >> bit_number;\n+      uintx first_set_bit = count_trailing_zeros<uintx>(aligned);\n+      idx_t candidate_result = (array_idx * BitsPerWord) + bit_number + first_set_bit;\n+      return (candidate_result < end)? candidate_result: end;\n+    } else {\n+      \/\/ Next bit is not here.  Try the next array element\n+      beg += BitsPerWord - bit_number;\n+    }\n+  } while (beg < end);\n+  return end;\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_first_set_bit(idx_t beg) const {\n+  assert((beg >= 0) && (beg < size()), \"precondition\");\n+  return find_first_set_bit(beg, size());\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_last_set_bit(idx_t beg, idx_t end) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  assert((beg >= -1) && (beg < end), \"precondition\");\n+  do {\n+    idx_t array_idx = end >> LogBitsPerWord;\n+    uintx bit_number = end & right_n_bits(LogBitsPerWord);\n+    uintx element_bits = _bitmap[array_idx];\n+    if (bit_number < BitsPerWord - 1){\n+      uintx mask_in = right_n_bits(bit_number + 1);\n+      element_bits &= mask_in;\n+    }\n+    if (element_bits) {\n+      \/\/ The prev set bit is here.  Find the first set bit <= bit_number\n+      uintx aligned = element_bits << (BitsPerWord - (bit_number + 1));\n+      uintx first_set_bit = count_leading_zeros<uintx>(aligned);\n+      idx_t candidate_result = array_idx * BitsPerWord + (bit_number - first_set_bit);\n+      return (candidate_result > beg)? candidate_result: beg;\n+    } else {\n+      \/\/ Next bit is not here.  Try the previous array element\n+      end -= (bit_number + 1);\n+    }\n+  } while (end > beg);\n+  return beg;\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_last_set_bit(idx_t end) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  return find_last_set_bit(-1, end);\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_first_consecutive_set_bits(idx_t beg, size_t num_bits) const {\n+  assert((beg >= 0) && (beg < _num_bits), \"precondition\");\n+  return find_first_consecutive_set_bits(beg, size(), num_bits);\n+}\n+\n+inline idx_t ShenandoahSimpleBitMap::find_last_consecutive_set_bits(idx_t end, size_t num_bits) const {\n+  assert((end >= 0) && (end < _num_bits), \"precondition\");\n+  return find_last_consecutive_set_bits((idx_t) -1, end, num_bits);\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSIMPLEBITMAP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2016, 2024, Red Hat, Inc. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  const IsGCActiveMark          _is_gc_active_mark;\n+  const IsSTWGCActiveMark       _is_gc_active_mark;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+  \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+  \/\/ might have created lots of old entries. Trigger the cleanup now.\n+  OopMapCache::trigger_cleanup();\n@@ -55,1 +58,0 @@\n-  OopMapCache::cleanup_old_entries();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  warning(\"Non-generational ZGC is deprecated.\");\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xArguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -119,1 +120,1 @@\n-    IsGCActiveMark gc_active_mark;\n+    IsSTWGCActiveMark gc_active_mark;\n@@ -133,0 +134,4 @@\n+\n+    \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+    \/\/ might have created lots of old entries. Trigger the cleanup now.\n+    OopMapCache::trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/x\/xDriver.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  log_info(gc, init)(\"Using legacy single-generation mode\");\n+  log_info(gc, init)(\"Using deprecated non-generational mode\");\n","filename":"src\/hotspot\/share\/gc\/x\/xInitialize.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,0 +145,4 @@\n+  bool needs_livein_data() const {\n+    return true;\n+  }\n+\n@@ -203,0 +207,3 @@\n+  \/\/ The runtime call updates the value of ref, so we should not spill and\n+  \/\/ reload its outdated value.\n+  dont_preserve(ref);\n@@ -213,4 +220,0 @@\n-Register ZLoadBarrierStubC2::result() const {\n-  return ref();\n-}\n-\n@@ -275,4 +278,0 @@\n-Register ZStoreBarrierStubC2::result() const {\n-  return noreg;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-  virtual Register result() const = 0;\n@@ -73,1 +72,0 @@\n-  virtual Register result() const;\n@@ -97,1 +95,0 @@\n-  virtual Register result() const;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-ZActivatedArray<T>::~ZActivatedArray<T>() {\n+ZActivatedArray<T>::~ZActivatedArray() {\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -441,1 +442,1 @@\n-    IsGCActiveMark gc_active_mark;\n+    IsSTWGCActiveMark gc_active_mark;\n@@ -455,0 +456,4 @@\n+\n+    \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+    \/\/ might have created lots of old entries. Trigger the cleanup now.\n+    OopMapCache::trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zNMT.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,13 +53,0 @@\n-  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n-\n-  \/\/ Clear leading 32 bits, if necessary.\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n-  if (!is_aligned(base_offset, HeapWordSize)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n-    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n-    base_offset += BytesPerInt;\n-  }\n-  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n-\n-  const size_t header = heap_word_size(base_offset);\n-  const size_t payload_size = _word_size - header;\n@@ -67,1 +54,1 @@\n-  if (payload_size <= segment_max || ArrayKlass::cast(_klass)->is_flatArray_klass()) {\n+  if (_word_size <= segment_max || ArrayKlass::cast(_klass)->is_flatArray_klass()) {\n@@ -92,0 +79,16 @@\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t process_start_offset_in_bytes = align_up(base_offset_in_bytes, BytesPerWord);\n+\n+  if (process_start_offset_in_bytes != base_offset_in_bytes) {\n+    \/\/ initialize_memory can only fill word aligned memory,\n+    \/\/ fill the first 4 bytes here.\n+    assert(process_start_offset_in_bytes - base_offset_in_bytes == 4, \"Must be 4-byte aligned\");\n+    assert(!is_reference_type(element_type), \"Only TypeArrays can be 4-byte aligned\");\n+    *reinterpret_cast<int*>(reinterpret_cast<char*>(mem) + base_offset_in_bytes) = 0;\n+  }\n+\n+  \/\/ Note: initialize_memory may clear padding bytes at the end\n+  const size_t process_start_offset = ZUtils::bytes_to_words(process_start_offset_in_bytes);\n+  const size_t process_size = _word_size - process_start_offset;\n+\n@@ -104,1 +107,1 @@\n-    for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    for (size_t processed = 0; processed < process_size; processed += segment_max) {\n@@ -106,2 +109,2 @@\n-      uintptr_t* const start = (uintptr_t*)(mem + header + processed);\n-      const size_t remaining = payload_size - processed;\n+      uintptr_t* const start = (uintptr_t*)(mem + process_start_offset + processed);\n+      const size_t remaining = process_size - processed;\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -486,3 +486,0 @@\n-    \/\/ Workaround OopMapCacheAlloc_lock reordering with the StackWatermark_lock\n-    DisableIsGCActiveMark mark;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -497,2 +498,1 @@\n-\/\/ Called by GC for thread root scan during a safepoint only.  The other interpreted frame oopmaps\n-\/\/ are generated locally and not cached.\n+\/\/ Lookup or compute\/cache the entry.\n@@ -502,1 +502,0 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"called by GC in a safepoint\");\n@@ -504,2 +503,0 @@\n-  int i;\n-  OopMapCacheEntry* entry = nullptr;\n@@ -515,8 +512,12 @@\n-  \/\/ Search hashtable for match\n-  for(i = 0; i < _probe_depth; i++) {\n-    entry = entry_at(probe + i);\n-    if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n-      entry_for->resource_copy(entry);\n-      assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n-      log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n-      return;\n+  \/\/ Search hashtable for match.\n+  \/\/ Need a critical section to avoid race against concurrent reclamation.\n+  {\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+    for (int i = 0; i < _probe_depth; i++) {\n+      OopMapCacheEntry *entry = entry_at(probe + i);\n+      if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n+        entry_for->resource_copy(entry);\n+        assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n+        log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n+        return;\n+      }\n@@ -544,2 +545,2 @@\n-  for(i = 0; i < _probe_depth; i++) {\n-    entry = entry_at(probe + i);\n+  for (int i = 0; i < _probe_depth; i++) {\n+    OopMapCacheEntry* entry = entry_at(probe + i);\n@@ -560,0 +561,4 @@\n+    \/\/ Cannot deallocate old entry on the spot: it can still be used by readers\n+    \/\/ that got a reference to it before we were able to replace it in the map.\n+    \/\/ Instead of synchronizing on GlobalCounter here and incurring heavy thread\n+    \/\/ walk, we do this clean up out of band.\n@@ -570,4 +575,2 @@\n-  bool success = false;\n-  OopMapCacheEntry* head;\n-  do {\n-    head = _old_entries;\n+  while (true) {\n+    OopMapCacheEntry* head = Atomic::load(&_old_entries);\n@@ -575,2 +578,5 @@\n-    success = Atomic::cmpxchg(&_old_entries, head, entry) == head;\n-  } while (!success);\n+    if (Atomic::cmpxchg(&_old_entries, head, entry) == head) {\n+      \/\/ Enqueued successfully.\n+      break;\n+    }\n+  }\n@@ -585,5 +591,22 @@\n-\/\/ This is called after GC threads are done and nothing is accessing the old_entries\n-\/\/ list, so no synchronization needed.\n-void OopMapCache::cleanup_old_entries() {\n-  OopMapCacheEntry* entry = _old_entries;\n-  _old_entries = nullptr;\n+bool OopMapCache::has_cleanup_work() {\n+  return Atomic::load(&_old_entries) != nullptr;\n+}\n+\n+void OopMapCache::trigger_cleanup() {\n+  if (has_cleanup_work()) {\n+    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    Service_lock->notify_all();\n+  }\n+}\n+\n+void OopMapCache::cleanup() {\n+  OopMapCacheEntry* entry = Atomic::xchg(&_old_entries, (OopMapCacheEntry*)nullptr);\n+  if (entry == nullptr) {\n+    \/\/ No work.\n+    return;\n+  }\n+\n+  \/\/ About to delete the entries than might still be accessed by other threads\n+  \/\/ on lookup path. Need to sync up with them before proceeding.\n+  GlobalCounter::write_synchronize();\n+\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -182,1 +182,9 @@\n-  static void cleanup_old_entries();\n+\n+  \/\/ Check if we need to clean up old entries\n+  static bool has_cleanup_work();\n+\n+  \/\/ Request cleanup if work is needed\n+  static void trigger_cleanup();\n+\n+  \/\/ Clean up the old entries\n+  static void cleanup();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-     print_java_help(\"printStartupHelp\");\n+     print_java_help(\"getStartupHelp\");\n@@ -249,1 +249,1 @@\n-void JfrDCmd::print_java_help(const char* help_method) const {\n+void JfrDCmd::print_java_help(const char* get_help_method) const {\n@@ -253,2 +253,2 @@\n-  JfrJavaArguments printHelp(&result, javaClass(), help_method, signature, thread);\n-  invoke(printHelp, thread);\n+  JfrJavaArguments java_method(&result, javaClass(), get_help_method, signature, thread);\n+  invoke(java_method, thread);\n@@ -259,1 +259,1 @@\n-  print_java_help(\"printHelp\");\n+  print_java_help(\"getHelp\");\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/jfrbitset.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,6 +251,0 @@\n-    \/\/ Traverse the monitor chunks\n-    MonitorChunk* chunk = jt->monitor_chunks();\n-    for (; chunk != nullptr; chunk = chunk->next()) {\n-      chunk->oops_do(&rcl);\n-    }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrNativeMemoryEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -774,5 +774,2 @@\n-    \/\/ We would like to be strict about the nmethod entry barrier but there are various test\n-    \/\/ configurations which generate assembly without being a full compiler. So for now we enforce\n-    \/\/ that JIT compiled methods must have an nmethod barrier.\n-    bool install_default = JVMCIENV->get_HotSpotNmethod_isDefault(installed_code) != 0;\n-    if (_nmethod_entry_patch_offset == -1 && install_default) {\n+    \/\/ Enforce that compiled methods have an nmethod barrier.\n+    if (_nmethod_entry_patch_offset == -1) {\n@@ -819,2 +816,1 @@\n-      if (_nmethod_entry_patch_offset != -1) {\n-        BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n@@ -822,5 +818,4 @@\n-        \/\/ an empty error buffer for use by the verify_barrier code\n-        err_msg msg(\"\");\n-        if (!bs_nm->verify_barrier(nm, msg)) {\n-          JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n-        }\n+      \/\/ an empty error buffer for use by the verify_barrier code\n+      err_msg msg(\"\");\n+      if (!bs_nm->verify_barrier(nm, msg)) {\n+        JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -178,4 +178,14 @@\n-  Universe_narrow_oop_base = CompressedOops::base();\n-  Universe_narrow_oop_shift = CompressedOops::shift();\n-  Universe_narrow_klass_base = CompressedKlassPointers::base();\n-  Universe_narrow_klass_shift = CompressedKlassPointers::shift();\n+  if (UseCompressedOops) {\n+    Universe_narrow_oop_base = CompressedOops::base();\n+    Universe_narrow_oop_shift = CompressedOops::shift();\n+  } else {\n+    Universe_narrow_oop_base = nullptr;\n+    Universe_narrow_oop_shift = 0;\n+  }\n+  if (UseCompressedClassPointers) {\n+    Universe_narrow_klass_base = CompressedKlassPointers::base();\n+    Universe_narrow_klass_shift = CompressedKlassPointers::shift();\n+  } else {\n+    Universe_narrow_klass_base = nullptr;\n+    Universe_narrow_klass_shift = 0;\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -95,1 +96,1 @@\n-\/\/ If there is a pending nonasync exception upon closing the scope and the runtime\n+\/\/ If there is a pending OutOfMemoryError upon closing the scope and the runtime\n@@ -98,1 +99,1 @@\n-\/\/   1. The pending nonasync exception is cleared\n+\/\/   1. The pending OutOfMemoryError is cleared\n@@ -100,2 +101,1 @@\n-\/\/   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().\n-class RetryableAllocationMark: public StackObj {\n+class RetryableAllocationMark {\n@@ -103,1 +103,1 @@\n-  JavaThread* _thread;\n+   InternalOOMEMark _iom;\n@@ -105,9 +105,1 @@\n-  RetryableAllocationMark(JavaThread* thread, bool activate) {\n-    if (activate) {\n-      assert(!thread->in_retryable_allocation(), \"retryable allocation scope is non-reentrant\");\n-      _thread = thread;\n-      _thread->set_in_retryable_allocation(true);\n-    } else {\n-      _thread = nullptr;\n-    }\n-  }\n+  RetryableAllocationMark(JavaThread* thread) : _iom(thread) {}\n@@ -115,3 +107,2 @@\n-    if (_thread != nullptr) {\n-      _thread->set_in_retryable_allocation(false);\n-      JavaThread* THREAD = _thread; \/\/ For exception macros.\n+    JavaThread* THREAD = _iom.thread(); \/\/ For exception macros.\n+    if (THREAD != nullptr) {\n@@ -120,6 +111,3 @@\n-        \/\/ Do not clear probable async exceptions.\n-        CLEAR_PENDING_NONASYNC_EXCEPTION;\n-        oop retry_oome = Universe::out_of_memory_error_retry();\n-        if (ex->is_a(retry_oome->klass()) && retry_oome != ex) {\n-          ResourceMark rm;\n-          fatal(\"Unexpected exception in scope of retryable allocation: \" INTPTR_FORMAT \" of type %s\", p2i(ex), ex->klass()->external_name());\n+        THREAD->set_vm_result(nullptr);\n+        if (ex->is_a(vmClasses::OutOfMemoryError_klass())) {\n+          CLEAR_PENDING_EXCEPTION;\n@@ -127,1 +115,0 @@\n-        _thread->set_vm_result(nullptr);\n@@ -133,1 +120,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_or_null(JavaThread* current, Klass* klass))\n@@ -139,1 +126,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -141,10 +128,5 @@\n-    oop obj;\n-    if (null_on_fail) {\n-      if (!h->is_initialized()) {\n-        \/\/ Cannot re-execute class initialization without side effects\n-        \/\/ so return without attempting the initialization\n-        return;\n-      }\n-    } else {\n-      \/\/ make sure klass is initialized\n-      h->initialize(CHECK);\n+    if (!h->is_initialized()) {\n+      \/\/ Cannot re-execute class initialization without side effects\n+      \/\/ so return without attempting the initialization\n+      current->set_vm_result(nullptr);\n+      return;\n@@ -153,1 +135,1 @@\n-    obj = h->allocate_instance(CHECK);\n+    oop obj = h->allocate_instance(CHECK);\n@@ -160,1 +142,1 @@\n-JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* current, Klass* array_klass, jint length, bool null_on_fail))\n+JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_or_null(JavaThread* current, Klass* array_klass, jint length))\n@@ -169,1 +151,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -174,1 +156,1 @@\n-    RetryableAllocationMark ram(current, null_on_fail);\n+    RetryableAllocationMark ram(current);\n@@ -181,1 +163,0 @@\n-    \/\/ Alternate between deoptimizing and raising an error (which will also cause a deopt)\n@@ -183,7 +164,2 @@\n-      if (null_on_fail) {\n-        \/\/ Drop the allocation\n-        obj = nullptr;\n-      } else {\n-        ResourceMark rm(current);\n-        THROW(vmSymbols::java_lang_OutOfMemoryError());\n-      }\n+      \/\/ Drop the allocation\n+      obj = nullptr;\n@@ -199,1 +175,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::new_multi_array_or_null(JavaThread* current, Klass* klass, int rank, jint* dims))\n@@ -203,1 +179,1 @@\n-  RetryableAllocationMark ram(current, null_on_fail);\n+  RetryableAllocationMark ram(current);\n@@ -208,2 +184,2 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail))\n-  RetryableAllocationMark ram(current, null_on_fail);\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_or_null(JavaThread* current, oopDesc* element_mirror, jint length))\n+  RetryableAllocationMark ram(current);\n@@ -214,1 +190,1 @@\n-JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail))\n+JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_or_null(JavaThread* current, oopDesc* type_mirror))\n@@ -221,1 +197,1 @@\n-  RetryableAllocationMark ram(current, null_on_fail);\n+  RetryableAllocationMark ram(current);\n@@ -226,9 +202,5 @@\n-  if (null_on_fail) {\n-    if (!klass->is_initialized()) {\n-      \/\/ Cannot re-execute class initialization without side effects\n-      \/\/ so return without attempting the initialization\n-      return;\n-    }\n-  } else {\n-    \/\/ Make sure klass gets initialized\n-    klass->initialize(CHECK);\n+  if (!klass->is_initialized()) {\n+    \/\/ Cannot re-execute class initialization without side effects\n+    \/\/ so return without attempting the initialization\n+    current->set_vm_result(nullptr);\n+    return;\n@@ -790,0 +762,1 @@\n+  guarantee(nmethod_entry_patch_offset != -1, \"missing entry barrier\");\n@@ -881,1 +854,1 @@\n-  assert(!Universe::heap()->is_gc_active(), \"can't extend the root set during GC\");\n+  assert(!Universe::heap()->is_stw_gc_active(), \"can't extend the root set during GC pause\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":37,"deletions":64,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -57,4 +57,2 @@\n-  \/\/ This is the offset of the patchable part of the nmethod entry barrier sequence.  The meaning is\n-  \/\/ somewhat platform dependent as the way patching is done varies by architecture.  Older JVMCI\n-  \/\/ based compilers didn't emit the entry barrier so having a positive value for this offset\n-  \/\/ confirms that the installed code supports the entry barrier.\n+  \/\/ This is the offset of the patchable part of the nmethod entry barrier sequence. The meaning is\n+  \/\/ somewhat platform dependent as the way patching is done varies by architecture.\n@@ -132,4 +130,0 @@\n-  bool has_entry_barrier() {\n-    return _nmethod_entry_patch_offset != -1;\n-  }\n-\n@@ -137,1 +131,0 @@\n-    guarantee(_nmethod_entry_patch_offset != -1, \"missing entry barrier\");\n@@ -514,6 +507,0 @@\n-  static void new_instance_common(JavaThread* current, Klass* klass, bool null_on_fail);\n-  static void new_array_common(JavaThread* current, Klass* klass, jint length, bool null_on_fail);\n-  static void new_multi_array_common(JavaThread* current, Klass* klass, int rank, jint* dims, bool null_on_fail);\n-  static void dynamic_new_array_common(JavaThread* current, oopDesc* element_mirror, jint length, bool null_on_fail);\n-  static void dynamic_new_instance_common(JavaThread* current, oopDesc* type_mirror, bool null_on_fail);\n-\n@@ -522,20 +509,8 @@\n-  \/\/ When allocation fails, these stubs:\n-  \/\/ 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also\n-  \/\/    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError\n-  \/\/ 2. Return null with a pending exception.\n-  \/\/ Compiled code must ensure these stubs are not called twice for the same allocation\n-  \/\/ site due to the non-repeatable side effects in the case of OOME.\n-  static void new_instance(JavaThread* current, Klass* klass) { new_instance_common(current, klass, false); }\n-  static void new_array(JavaThread* current, Klass* klass, jint length) { new_array_common(current, klass, length, false); }\n-  static void new_multi_array(JavaThread* current, Klass* klass, int rank, jint* dims) { new_multi_array_common(current, klass, rank, dims, false); }\n-  static void dynamic_new_array(JavaThread* current, oopDesc* element_mirror, jint length) { dynamic_new_array_common(current, element_mirror, length, false); }\n-  static void dynamic_new_instance(JavaThread* current, oopDesc* type_mirror) { dynamic_new_instance_common(current, type_mirror, false); }\n-\n-  \/\/ When allocation fails, these stubs return null and have no pending exception. Compiled code\n-  \/\/ can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and\n-  \/\/ re-executing in the interpreter).\n-  static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }\n-  static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }\n-  static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }\n-  static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }\n-  static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }\n+  \/\/ When allocation fails, these stubs return null and have no pending OutOfMemoryError exception.\n+  \/\/ Compiled code can use these stubs if a failed allocation will be retried (e.g., by deoptimizing\n+  \/\/ and re-executing in the interpreter).\n+  static void new_instance_or_null(JavaThread* thread, Klass* klass);\n+  static void new_array_or_null(JavaThread* thread, Klass* klass, jint length);\n+  static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims);\n+  static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length);\n+  static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":10,"deletions":35,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+  nonstatic_field(Klass,                       _bitmap,                                       uintx)                                 \\\n+  nonstatic_field(Klass,                       _hash_slot,                                    uint8_t)                               \\\n@@ -362,0 +364,2 @@\n+  static_field(StubRoutines,                _intpoly_montgomeryMult_P256,                     address)                               \\\n+  static_field(StubRoutines,                _intpoly_assign,                                  address)                               \\\n@@ -384,0 +388,1 @@\n+  static_field(StubRoutines,                _lookup_secondary_supers_table_slow_path_stub,    address)                               \\\n@@ -806,33 +811,27 @@\n-  declare_function(JVMCIRuntime::new_instance) \\\n-  declare_function(JVMCIRuntime::new_array) \\\n-  declare_function(JVMCIRuntime::new_multi_array) \\\n-  declare_function(JVMCIRuntime::dynamic_new_array) \\\n-  declare_function(JVMCIRuntime::dynamic_new_instance) \\\n-  \\\n-  declare_function(JVMCIRuntime::new_instance_or_null) \\\n-  declare_function(JVMCIRuntime::new_array_or_null) \\\n-  declare_function(JVMCIRuntime::new_multi_array_or_null) \\\n-  declare_function(JVMCIRuntime::dynamic_new_array_or_null) \\\n-  declare_function(JVMCIRuntime::dynamic_new_instance_or_null) \\\n-  \\\n-  declare_function(JVMCIRuntime::invoke_static_method_one_arg) \\\n-  \\\n-  declare_function(JVMCIRuntime::vm_message) \\\n-  declare_function(JVMCIRuntime::identity_hash_code) \\\n-  declare_function(JVMCIRuntime::exception_handler_for_pc) \\\n-  declare_function(JVMCIRuntime::monitorenter) \\\n-  declare_function(JVMCIRuntime::monitorexit) \\\n-  declare_function(JVMCIRuntime::object_notify) \\\n-  declare_function(JVMCIRuntime::object_notifyAll) \\\n-  declare_function(JVMCIRuntime::throw_and_post_jvmti_exception) \\\n-  declare_function(JVMCIRuntime::throw_klass_external_name_exception) \\\n-  declare_function(JVMCIRuntime::throw_class_cast_exception) \\\n-  declare_function(JVMCIRuntime::log_primitive) \\\n-  declare_function(JVMCIRuntime::log_object) \\\n-  declare_function(JVMCIRuntime::log_printf) \\\n-  declare_function(JVMCIRuntime::vm_error) \\\n-  declare_function(JVMCIRuntime::load_and_clear_exception) \\\n-  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_pre)) \\\n-  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_post)) \\\n-  declare_function(JVMCIRuntime::validate_object) \\\n-  \\\n+  declare_function(JVMCIRuntime::new_instance_or_null)                    \\\n+  declare_function(JVMCIRuntime::new_array_or_null)                       \\\n+  declare_function(JVMCIRuntime::new_multi_array_or_null)                 \\\n+  declare_function(JVMCIRuntime::dynamic_new_array_or_null)               \\\n+  declare_function(JVMCIRuntime::dynamic_new_instance_or_null)            \\\n+                                                                          \\\n+  declare_function(JVMCIRuntime::invoke_static_method_one_arg)            \\\n+                                                                          \\\n+  declare_function(JVMCIRuntime::vm_message)                              \\\n+  declare_function(JVMCIRuntime::identity_hash_code)                      \\\n+  declare_function(JVMCIRuntime::exception_handler_for_pc)                \\\n+  declare_function(JVMCIRuntime::monitorenter)                            \\\n+  declare_function(JVMCIRuntime::monitorexit)                             \\\n+  declare_function(JVMCIRuntime::object_notify)                           \\\n+  declare_function(JVMCIRuntime::object_notifyAll)                        \\\n+  declare_function(JVMCIRuntime::throw_and_post_jvmti_exception)          \\\n+  declare_function(JVMCIRuntime::throw_klass_external_name_exception)     \\\n+  declare_function(JVMCIRuntime::throw_class_cast_exception)              \\\n+  declare_function(JVMCIRuntime::log_primitive)                           \\\n+  declare_function(JVMCIRuntime::log_object)                              \\\n+  declare_function(JVMCIRuntime::log_printf)                              \\\n+  declare_function(JVMCIRuntime::vm_error)                                \\\n+  declare_function(JVMCIRuntime::load_and_clear_exception)                \\\n+  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_pre))            \\\n+  G1GC_ONLY(declare_function(JVMCIRuntime::write_barrier_post))           \\\n+  declare_function(JVMCIRuntime::validate_object)                         \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":32,"deletions":33,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"nmt\/memflags.hpp\"\n@@ -102,57 +103,0 @@\n-#define MEMORY_TYPES_DO(f)                                                           \\\n-  \/* Memory type by sub systems. It occupies lower byte. *\/                          \\\n-  f(mtJavaHeap,       \"Java Heap\")   \/* Java heap                                 *\/ \\\n-  f(mtClass,          \"Class\")       \/* Java classes                              *\/ \\\n-  f(mtThread,         \"Thread\")      \/* thread objects                            *\/ \\\n-  f(mtThreadStack,    \"Thread Stack\")                                                \\\n-  f(mtCode,           \"Code\")        \/* generated code                            *\/ \\\n-  f(mtGC,             \"GC\")                                                          \\\n-  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n-  f(mtCompiler,       \"Compiler\")                                                    \\\n-  f(mtJVMCI,          \"JVMCI\")                                                       \\\n-  f(mtInternal,       \"Internal\")    \/* memory used by VM, but does not belong to *\/ \\\n-                                     \/* any of above categories, and not used by  *\/ \\\n-                                     \/* NMT                                       *\/ \\\n-  f(mtOther,          \"Other\")       \/* memory not used by VM                     *\/ \\\n-  f(mtSymbol,         \"Symbol\")                                                      \\\n-  f(mtNMT,            \"Native Memory Tracking\")  \/* memory used by NMT            *\/ \\\n-  f(mtClassShared,    \"Shared class space\")      \/* class data sharing            *\/ \\\n-  f(mtChunk,          \"Arena Chunk\") \/* chunk that holds content of arenas        *\/ \\\n-  f(mtTest,           \"Test\")        \/* Test type for verifying NMT               *\/ \\\n-  f(mtTracing,        \"Tracing\")                                                     \\\n-  f(mtLogging,        \"Logging\")                                                     \\\n-  f(mtStatistics,     \"Statistics\")                                                  \\\n-  f(mtArguments,      \"Arguments\")                                                   \\\n-  f(mtModule,         \"Module\")                                                      \\\n-  f(mtSafepoint,      \"Safepoint\")                                                   \\\n-  f(mtSynchronizer,   \"Synchronization\")                                             \\\n-  f(mtServiceability, \"Serviceability\")                                              \\\n-  f(mtMetaspace,      \"Metaspace\")                                                   \\\n-  f(mtStringDedup,    \"String Deduplication\")                                        \\\n-  f(mtObjectMonitor,  \"Object Monitors\")                                             \\\n-  f(mtNone,           \"Unknown\")                                                     \\\n-  \/\/end\n-\n-#define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \\\n-  type,\n-\n-\/*\n- * Memory types\n- *\/\n-enum class MEMFLAGS : uint8_t  {\n-  MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)\n-  mt_number_of_types   \/\/ number of memory types (mtDontTrack\n-                       \/\/ is not included as validate type)\n-};\n-\/\/ Extra insurance that MEMFLAGS truly has the same size as uint8_t.\n-STATIC_ASSERT(sizeof(MEMFLAGS) == sizeof(uint8_t));\n-\n-#define MEMORY_TYPE_SHORTNAME(type, human_readable) \\\n-  constexpr MEMFLAGS type = MEMFLAGS::type;\n-\n-\/\/ Generate short aliases for the enum values. E.g. mtGC instead of MEMFLAGS::mtGC.\n-MEMORY_TYPES_DO(MEMORY_TYPE_SHORTNAME)\n-\n-\/\/ Make an int version of the sentinel end value.\n-constexpr int mt_number_of_types = static_cast<int>(MEMFLAGS::mt_number_of_types);\n-\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":2,"deletions":58,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n@@ -28,0 +26,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/memory\/padded.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,0 @@\n-                           _oom_retry,\n@@ -661,0 +660,4 @@\n+oop Universe::out_of_memory_error_java_heap_without_backtrace() {\n+  return out_of_memory_errors()->obj_at(_oom_java_heap);\n+}\n+\n@@ -685,3 +688,0 @@\n-\/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-oop Universe::out_of_memory_error_retry()              { return out_of_memory_errors()->obj_at(_oom_retry);  }\n-\n@@ -791,3 +791,0 @@\n-  msg = java_lang_String::create_from_str(\"Java heap space: failed retryable allocation\", CHECK);\n-  java_lang_Throwable::set_message(oom_array->obj_at(_oom_retry), msg());\n-\n@@ -1360,2 +1357,2 @@\n-bool Universe::is_gc_active() {\n-  return heap()->is_gc_active();\n+bool Universe::is_stw_gc_active() {\n+  return heap()->is_stw_gc_active();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+  static oop out_of_memory_error_java_heap_without_backtrace();\n@@ -286,2 +287,0 @@\n-  \/\/ Throw default _out_of_memory_error_retry object as it will never propagate out of the VM\n-  static oop out_of_memory_error_retry();\n@@ -302,1 +301,1 @@\n-  DEBUG_ONLY(static bool is_gc_active();)\n+  DEBUG_ONLY(static bool is_stw_gc_active();)\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/allocationSite.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memflags.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -34,0 +36,4 @@\n+\/\/ The malloc header, as well as the coming VMATree implementation, rely on MEMFLAGS\n+\/\/ fitting into eight bits.\n+STATIC_ASSERT(sizeof(MEMFLAGS) == sizeof(uint8_t));\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,5 +151,0 @@\n-    return false;\n-  }\n-\n-  \/\/ Walk simple thread stacks\n-  if (!ThreadStackTracker::walk_simple_thread_stack_site(&malloc_walker)) {\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +29,2 @@\n-#include \"memory\/allocation.hpp\" \/\/ for mt_number_of_types\n+#include \"nmt\/memflags.hpp\"\n+#include \"utilities\/debug.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memFlagBitmap.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -29,1 +29,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"nmt\/memflags.hpp\"\n@@ -196,11 +196,4 @@\n-    if (ThreadStackTracker::track_as_vm()) {\n-      const VirtualMemory* thread_stack_usage =\n-        (const VirtualMemory*)_vm_snapshot->by_type(mtThreadStack);\n-      reserved_amount  += thread_stack_usage->reserved();\n-      committed_amount += thread_stack_usage->committed();\n-    } else {\n-      const MallocMemory* thread_stack_usage =\n-        (const MallocMemory*)_malloc_snapshot->by_type(mtThreadStack);\n-      reserved_amount += thread_stack_usage->malloc_size();\n-      committed_amount += thread_stack_usage->malloc_size();\n-    }\n+    const VirtualMemory* thread_stack_usage =\n+      (const VirtualMemory*)_vm_snapshot->by_type(mtThreadStack);\n+    reserved_amount  += thread_stack_usage->reserved();\n+    committed_amount += thread_stack_usage->committed();\n@@ -243,15 +236,6 @@\n-    if (ThreadStackTracker::track_as_vm()) {\n-      const VirtualMemory* thread_stack_usage =\n-       _vm_snapshot->by_type(mtThreadStack);\n-      \/\/ report thread count\n-      out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", ThreadStackTracker::thread_count());\n-      out->print(\"%27s (stack: \", \" \");\n-      print_total(thread_stack_usage->reserved(), thread_stack_usage->committed(), thread_stack_usage->peak_size());\n-    } else {\n-      MallocMemory* thread_stack_memory = _malloc_snapshot->by_type(mtThreadStack);\n-      const char* scale = current_scale();\n-      \/\/ report thread count\n-      out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", thread_stack_memory->malloc_count());\n-      out->print(\"%27s (Stack: \" SIZE_FORMAT \"%s\", \" \",\n-        amount_in_current_scale(thread_stack_memory->malloc_size()), scale);\n-    }\n+    const VirtualMemory* thread_stack_usage =\n+     _vm_snapshot->by_type(mtThreadStack);\n+    \/\/ report thread count\n+    out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", ThreadStackTracker::thread_count());\n+    out->print(\"%27s (stack: \", \" \");\n+    print_total(thread_stack_usage->reserved(), thread_stack_usage->committed(), thread_stack_usage->peak_size());\n@@ -630,18 +614,9 @@\n-      if (ThreadStackTracker::track_as_vm()) {\n-        \/\/ report thread stack\n-        const VirtualMemory* current_thread_stack =\n-          _current_baseline.virtual_memory(mtThreadStack);\n-        const VirtualMemory* early_thread_stack =\n-          _early_baseline.virtual_memory(mtThreadStack);\n-\n-        print_virtual_memory_diff(current_thread_stack->reserved(), current_thread_stack->committed(),\n-          early_thread_stack->reserved(), early_thread_stack->committed());\n-      } else {\n-        const MallocMemory* current_thread_stack =\n-          _current_baseline.malloc_memory(mtThreadStack);\n-        const MallocMemory* early_thread_stack =\n-          _early_baseline.malloc_memory(mtThreadStack);\n-\n-        print_malloc_diff(current_thread_stack->malloc_size(), current_thread_stack->malloc_count(),\n-          early_thread_stack->malloc_size(), early_thread_stack->malloc_count(), flag);\n-      }\n+      \/\/ report thread stack\n+      const VirtualMemory* current_thread_stack =\n+        _current_baseline.virtual_memory(mtThreadStack);\n+      const VirtualMemory* early_thread_stack =\n+        _early_baseline.virtual_memory(mtThreadStack);\n+\n+      print_virtual_memory_diff(current_thread_stack->reserved(), current_thread_stack->committed(),\n+        early_thread_stack->reserved(), early_thread_stack->committed());\n+\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":21,"deletions":46,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,1 @@\n-        !VirtualMemoryTracker::initialize(level) ||\n-        !ThreadStackTracker::initialize(level)) {\n+        !VirtualMemoryTracker::initialize(level)) {\n@@ -149,6 +148,11 @@\n-  out->print_cr(\"State: %s\", NMTUtil::tracking_level_to_string(_tracking_level));\n-  out->print_cr(\"Malloc allocation site table size: %d\", MallocSiteTable::hash_buckets());\n-  out->print_cr(\"             Tracking stack depth: %d\", NMT_TrackingStackDepth);\n-  out->cr();\n-  MallocSiteTable::print_tuning_statistics(out);\n-  out->cr();\n+  out->print_cr(\"State: %s\",\n+                NMTUtil::tracking_level_to_string(_tracking_level));\n+  if (_tracking_level == NMT_detail) {\n+    out->print_cr(\"Malloc allocation site table size: %d\",\n+                  MallocSiteTable::hash_buckets());\n+    out->print_cr(\"             Tracking stack depth: %d\",\n+                  NMT_TrackingStackDepth);\n+    out->cr();\n+    MallocSiteTable::print_tuning_statistics(out);\n+    out->cr();\n+  }\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMFLAGS_HPP\n+#define SHARE_NMT_MEMFLAGS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define MEMORY_TYPES_DO(f)                                                           \\\n+  \/* Memory type by sub systems. It occupies lower byte. *\/                          \\\n+  f(mtJavaHeap,       \"Java Heap\")   \/* Java heap                                 *\/ \\\n+  f(mtClass,          \"Class\")       \/* Java classes                              *\/ \\\n+  f(mtThread,         \"Thread\")      \/* thread objects                            *\/ \\\n+  f(mtThreadStack,    \"Thread Stack\")                                                \\\n+  f(mtCode,           \"Code\")        \/* generated code                            *\/ \\\n+  f(mtGC,             \"GC\")                                                          \\\n+  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n+  f(mtCompiler,       \"Compiler\")                                                    \\\n+  f(mtJVMCI,          \"JVMCI\")                                                       \\\n+  f(mtInternal,       \"Internal\")    \/* memory used by VM, but does not belong to *\/ \\\n+                                     \/* any of above categories, and not used by  *\/ \\\n+                                     \/* NMT                                       *\/ \\\n+  f(mtOther,          \"Other\")       \/* memory not used by VM                     *\/ \\\n+  f(mtSymbol,         \"Symbol\")                                                      \\\n+  f(mtNMT,            \"Native Memory Tracking\")  \/* memory used by NMT            *\/ \\\n+  f(mtClassShared,    \"Shared class space\")      \/* class data sharing            *\/ \\\n+  f(mtChunk,          \"Arena Chunk\") \/* chunk that holds content of arenas        *\/ \\\n+  f(mtTest,           \"Test\")        \/* Test type for verifying NMT               *\/ \\\n+  f(mtTracing,        \"Tracing\")                                                     \\\n+  f(mtLogging,        \"Logging\")                                                     \\\n+  f(mtStatistics,     \"Statistics\")                                                  \\\n+  f(mtArguments,      \"Arguments\")                                                   \\\n+  f(mtModule,         \"Module\")                                                      \\\n+  f(mtSafepoint,      \"Safepoint\")                                                   \\\n+  f(mtSynchronizer,   \"Synchronization\")                                             \\\n+  f(mtServiceability, \"Serviceability\")                                              \\\n+  f(mtMetaspace,      \"Metaspace\")                                                   \\\n+  f(mtStringDedup,    \"String Deduplication\")                                        \\\n+  f(mtObjectMonitor,  \"Object Monitors\")                                             \\\n+  f(mtNone,           \"Unknown\")                                                     \\\n+  \/\/end\n+\n+#define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \\\n+  type,\n+\n+enum class MEMFLAGS : uint8_t  {\n+  MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)\n+  mt_number_of_types   \/\/ number of memory types (mtDontTrack\n+                       \/\/ is not included as validate type)\n+};\n+\n+#define MEMORY_TYPE_SHORTNAME(type, human_readable) \\\n+  constexpr MEMFLAGS type = MEMFLAGS::type;\n+\n+\/\/ Generate short aliases for the enum values. E.g. mtGC instead of MEMFLAGS::mtGC.\n+MEMORY_TYPES_DO(MEMORY_TYPE_SHORTNAME)\n+\n+\/\/ Make an int version of the sentinel end value.\n+constexpr int mt_number_of_types = static_cast<int>(MEMFLAGS::mt_number_of_types);\n+\n+#endif \/\/ SHARE_NMT_MEMFLAGS_HPP\n","filename":"src\/hotspot\/share\/nmt\/memflags.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-#include \"memory\/allocation.hpp\" \/\/ for MEMFLAGS only\n+#include \"memory\/allStatic.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/nmtCommon.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-    if (check_detail_tracking_level(output())) {\n+    if (MemTracker::enabled()) {\n@@ -142,0 +142,2 @@\n+    } else {\n+      output()->print_cr(\"Native memory tracking is not enabled\");\n","filename":"src\/hotspot\/share\/nmt\/nmtDCmd.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,7 +46,5 @@\n-  \/\/ If backed by virtual memory, snapping the thread stacks involves walking\n-  \/\/ them to to figure out how much memory is committed if they are backed by\n-  \/\/ virtual memory. This needs ot happen before we take the snapshot of the\n-  \/\/ virtual memory since it will update this information.\n-  if (ThreadStackTracker::track_as_vm()) {\n-    VirtualMemoryTracker::snapshot_thread_stacks();\n-  }\n+  \/\/ Snapping the thread stacks involves walking the areas to figure out how\n+  \/\/ much memory had been committed if they are backed by virtual memory. This\n+  \/\/ needs to happen before we take the snapshot of the virtual memory since it\n+  \/\/ will update this information.\n+  VirtualMemoryTracker::snapshot_thread_stacks();\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,0 @@\n-#include \"nmt\/mallocTracker.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -32,0 +33,3 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -34,1 +38,0 @@\n-SortedLinkedList<SimpleThreadStackSite, ThreadStackTracker::compare_thread_stack_base>* ThreadStackTracker::_simple_thread_stacks = nullptr;\n@@ -36,11 +39,10 @@\n-bool ThreadStackTracker::initialize(NMT_TrackingLevel level) {\n-  if (level == NMT_detail && !track_as_vm()) {\n-    _simple_thread_stacks = new (std::nothrow, mtNMT)\n-      SortedLinkedList<SimpleThreadStackSite, ThreadStackTracker::compare_thread_stack_base>();\n-    return (_simple_thread_stacks != nullptr);\n-  }\n-  return true;\n-}\n-\n-int ThreadStackTracker::compare_thread_stack_base(const SimpleThreadStackSite& s1, const SimpleThreadStackSite& s2) {\n-  return primitive_compare(s1.base(), s2.base());\n+static void align_thread_stack_boundaries_inward(void*& base, size_t& size) {\n+  \/\/ Thread stack boundaries don't have to be aligned to page boundaries. For cases where they\n+  \/\/ are not aligned (e.g. AIX, Alpine), this function corrects boundaries inward to the next\n+  \/\/ page boundaries. This ensures that we can track thread stacks piggybacking on the virtual\n+  \/\/ memory tracker.\n+  void* const base_aligned = align_up(base, os::vm_page_size());\n+  const size_t size_aligned = align_down(size, os::vm_page_size());\n+  assert(size_aligned > 0, \"stack size less than a page?\");\n+  base = base_aligned;\n+  size = size_aligned;\n@@ -50,1 +52,1 @@\n-  assert(MemTracker::tracking_level() >= NMT_summary, \"Must be\");\n+  assert(MemTracker::enabled(), \"Must be\");\n@@ -52,0 +54,2 @@\n+  align_thread_stack_boundaries_inward(base, size);\n+\n@@ -53,11 +57,1 @@\n-  if (track_as_vm()) {\n-    VirtualMemoryTracker::add_reserved_region((address)base, size, stack, mtThreadStack);\n-  } else {\n-    \/\/ Use a slot in mallocMemorySummary for thread stack bookkeeping\n-    MallocMemorySummary::record_malloc(size, mtThreadStack);\n-    if (MemTracker::tracking_level() == NMT_detail) {\n-      assert(_simple_thread_stacks != nullptr, \"Must be initialized\");\n-      SimpleThreadStackSite site((address)base, size, stack);\n-      _simple_thread_stacks->add(site);\n-    }\n-  }\n+  VirtualMemoryTracker::add_reserved_region((address)base, size, stack, mtThreadStack);\n@@ -68,1 +62,1 @@\n-  assert(MemTracker::tracking_level() >= NMT_summary, \"Must be\");\n+  assert(MemTracker::enabled(), \"Must be\");\n@@ -70,0 +64,2 @@\n+  align_thread_stack_boundaries_inward(base, size);\n+\n@@ -71,12 +67,1 @@\n-  if(track_as_vm()) {\n-    VirtualMemoryTracker::remove_released_region((address)base, size);\n-  } else {\n-    \/\/ Use a slot in mallocMemorySummary for thread stack bookkeeping\n-    MallocMemorySummary::record_free(size, mtThreadStack);\n-    if (MemTracker::tracking_level() == NMT_detail) {\n-      assert(_simple_thread_stacks != nullptr, \"Must be initialized\");\n-      SimpleThreadStackSite site((address)base, size, NativeCallStack::empty_stack()); \/\/ Fake object just to serve as compare target for delete\n-      bool removed = _simple_thread_stacks->remove(site);\n-      assert(removed, \"Must exist\");\n-    }\n-  }\n+  VirtualMemoryTracker::remove_released_region((address)base, size);\n@@ -86,33 +71,0 @@\n-bool ThreadStackTracker::walk_simple_thread_stack_site(MallocSiteWalker* walker) {\n-  if (!track_as_vm()) {\n-    LinkedListImpl<MallocSite> _sites;\n-    {\n-      ThreadCritical tc;\n-      assert(_simple_thread_stacks != nullptr, \"Must be initialized\");\n-      LinkedListIterator<SimpleThreadStackSite> itr(_simple_thread_stacks->head());\n-      const SimpleThreadStackSite* ts = itr.next();\n-      \/\/ Consolidate sites and convert to MallocSites, so we can piggyback into\n-      \/\/ malloc snapshot\n-      while (ts != nullptr) {\n-        MallocSite site(*ts->call_stack(), mtThreadStack);\n-        MallocSite* exist = _sites.find(site);\n-        if (exist != nullptr) {\n-          exist->allocate(ts->size());\n-        } else {\n-          site.allocate(ts->size());\n-          _sites.add(site);\n-        }\n-        ts = itr.next();\n-      }\n-    }\n-\n-    \/\/ Piggyback to malloc snapshot\n-    LinkedListIterator<MallocSite> site_itr(_sites.head());\n-    const MallocSite* s = site_itr.next();\n-    while (s != nullptr) {\n-      walker->do_malloc_site(s);\n-      s = site_itr.next();\n-    }\n-  }\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/nmt\/threadStackTracker.cpp","additions":24,"deletions":72,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2019, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +29,2 @@\n-#include \"nmt\/allocationSite.hpp\"\n-#include \"nmt\/mallocSiteTable.hpp\"\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"utilities\/linkedlist.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -34,31 +33,0 @@\n-class SimpleThreadStackSite : public AllocationSite {\n-  const address _base;\n-  const size_t  _size;\n-public:\n-  SimpleThreadStackSite(address base, size_t size, const NativeCallStack& stack) :\n-    AllocationSite(stack, mtThreadStack),\n-    _base(base),\n-    _size(size) {}\n-\n-  bool equals(const SimpleThreadStackSite& mts) const {\n-    bool eq = base() == mts.base();\n-    assert(!eq || size() == mts.size(), \"Must match\");\n-    return eq;\n-  }\n-\n-  size_t  size() const { return _size; }\n-  address base() const { return _base; }\n-};\n-\n-  \/*\n-   * Most of platforms, that hotspot support, have their thread stacks backed by\n-   * virtual memory by default. For these cases, thread stack tracker simply\n-   * delegates tracking to virtual memory tracker.\n-   * However, there are exceptions, (e.g. AIX), that platforms can provide stacks\n-   * that are not page aligned. A hypothetical VM implementation, it can provide\n-   * it own stacks. In these case, track_as_vm() should return false and manage\n-   * stack tracking by this tracker internally.\n-   * During memory snapshot, tracked thread stacks memory data is walked and stored\n-   * along with malloc'd data inside baseline. The regions are not scanned and assumed\n-   * all committed for now. Can add scanning phase when there is a need.\n-   *\/\n@@ -68,3 +36,0 @@\n-\n-  static int compare_thread_stack_base(const SimpleThreadStackSite& s1, const SimpleThreadStackSite& s2);\n-  static SortedLinkedList<SimpleThreadStackSite, compare_thread_stack_base>* _simple_thread_stacks;\n@@ -72,2 +37,0 @@\n-  static bool initialize(NMT_TrackingLevel level);\n-\n@@ -76,2 +39,0 @@\n-\n-  static bool   track_as_vm()  { return AIX_ONLY(false) NOT_AIX(true); }\n@@ -79,4 +40,0 @@\n-\n-  \/\/ Snapshot support. Piggyback thread stack data in malloc slot, NMT always handles\n-  \/\/ thread stack slot specially since beginning.\n-  static bool walk_simple_thread_stack_site(MallocSiteWalker* walker);\n","filename":"src\/hotspot\/share\/nmt\/threadStackTracker.hpp","additions":4,"deletions":47,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,5 +50,2 @@\n-  \/\/ Only if thread stack is backed by virtual memory\n-  if (ThreadStackTracker::track_as_vm()) {\n-    \/\/ Snapshot current thread stacks\n-    VirtualMemoryTracker::snapshot_thread_stacks();\n-  }\n+  \/\/ Snapshot current thread stacks\n+  VirtualMemoryTracker::snapshot_thread_stacks();\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1861,2 +1861,2 @@\n-  \/\/ Lazily create the _oop_map_cache at first request\n-  \/\/ Lock-free access requires load_acquire.\n+  \/\/ Lazily create the _oop_map_cache at first request.\n+  \/\/ Load_acquire is needed to safely get instance published with CAS by another thread.\n@@ -1865,6 +1865,7 @@\n-    MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);\n-    \/\/ Check if _oop_map_cache was allocated while we were waiting for this lock\n-    if ((oop_map_cache = _oop_map_cache) == nullptr) {\n-      oop_map_cache = new OopMapCache();\n-      \/\/ Ensure _oop_map_cache is stable, since it is examined without a lock\n-      Atomic::release_store(&_oop_map_cache, oop_map_cache);\n+    \/\/ Try to install new instance atomically.\n+    oop_map_cache = new OopMapCache();\n+    OopMapCache* other = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n+    if (other != nullptr) {\n+      \/\/ Someone else managed to install before us, ditch local copy and use the existing one.\n+      delete oop_map_cache;\n+      oop_map_cache = other;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -253,2 +253,2 @@\n-  st->print_cr(\"       size: %d argsize: %d max_size: %d sp: %d pc: \" PTR_FORMAT,\n-               c->stack_size(), c->argsize(), c->max_thawing_size(), c->sp(), p2i(c->pc()));\n+  st->print_cr(\"       size: %d bottom: %d max_size: %d sp: %d pc: \" PTR_FORMAT,\n+               c->stack_size(), c->bottom(), c->max_thawing_size(), c->sp(), p2i(c->pc()));\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -877,1 +877,1 @@\n-    if (!THREAD->in_retryable_allocation()) {\n+    if (!THREAD->is_in_internal_oome_mark()) {\n@@ -882,1 +882,1 @@\n-      THROW_OOP(Universe::out_of_memory_error_retry());\n+      THROW_OOP(Universe::out_of_memory_error_java_heap_without_backtrace());\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -323,8 +323,1 @@\n-  \/\/ Only GC uses the OopMapCache during thread stack root scanning\n-  \/\/ any other uses generate an oopmap but do not save it in the cache.\n-  if (Universe::heap()->is_gc_active()) {\n-    method_holder()->mask_for(h_this, bci, mask);\n-  } else {\n-    OopMapCache::compute_one_oop_map(h_this, bci, mask);\n-  }\n-  return;\n+  mask_for(h_this, bci, mask);\n@@ -333,0 +326,4 @@\n+void Method::mask_for(const methodHandle& this_mh, int bci, InterpreterOopMap* mask) {\n+  assert(this_mh() == this, \"Sanity\");\n+  method_holder()->mask_for(this_mh, bci, mask);\n+}\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -463,1 +463,2 @@\n-  \/\/ Interpreter oopmap support\n+  \/\/ Interpreter oopmap support.\n+  \/\/ If handle is already available, call with it for better performance.\n@@ -465,0 +466,1 @@\n+  void mask_for(const methodHandle& this_mh, int bci, InterpreterOopMap* mask);\n@@ -836,8 +838,0 @@\n-  \/\/ Clear the flags related to compiler directives that were set by the compilerBroker,\n-  \/\/ because the directives can be updated.\n-  void clear_directive_flags() {\n-    set_has_matching_directives(false);\n-    clear_is_not_c1_compilable();\n-    clear_is_not_c2_compilable();\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,3 +61,2 @@\n-   status(has_matching_directives     , 1 << 16) \/* Temporary mark, used only when methods are to be refreshed to reflect a compiler directives update *\/ \\\n-   status(has_scalarized_args         , 1 << 17) \\\n-   status(has_scalarized_return       , 1 << 18) \\\n+   status(has_scalarized_args         , 1 << 16) \\\n+   status(has_scalarized_return       , 1 << 17) \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  return Universe::heap()->is_gc_active() && is_objArray() && is_forwarded() && (UseParallelGC || UseG1GC);\n+  return Universe::heap()->is_stw_gc_active() && is_objArray() && is_forwarded() && (UseParallelGC || UseG1GC);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,0 +224,2 @@\n+  jint int_field_relaxed(int offset) const;\n+  void int_field_put_relaxed(int offset, jint contents);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,0 +256,2 @@\n+inline jint oopDesc::int_field_relaxed(int offset) const            { return Atomic::load(field_addr<jint>(offset)); }\n+inline void oopDesc::int_field_put_relaxed(int offset, jint value)  { Atomic::store(field_addr<jint>(offset), value); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -536,1 +536,0 @@\n-  assert(argsize() >= 0, \"\");\n@@ -540,1 +539,0 @@\n-    assert(argsize() == 0, \"\");\n@@ -542,0 +540,2 @@\n+  } else {\n+    assert(argsize() >= 0, \"\");\n@@ -550,1 +550,1 @@\n-  int size = stack_size() - argsize() - sp();\n+  int size = bottom() - sp();\n@@ -573,6 +573,9 @@\n-    assert(closure._size <= size + argsize() + frame::metadata_words,\n-           \"size: %d argsize: %d closure.size: %d end sp: \" PTR_FORMAT \" start sp: %d chunk size: %d\",\n-           size, argsize(), closure._size, closure._sp - start_address(), sp(), stack_size());\n-    assert(argsize() == closure._argsize - (closure._num_frames > 0 ? frame::metadata_words_at_top : 0),\n-           \"argsize(): %d closure.argsize: %d closure.callee_interpreted: %d\",\n-           argsize(), closure._argsize, closure._callee_interpreted);\n+    assert(closure._size <= size + (stack_size() - bottom()),\n+           \"size: %d bottom: %d closure.size: %d end sp: \" PTR_FORMAT \" start sp: %d chunk size: %d\",\n+           size, bottom(), closure._size, closure._sp - start_address(), sp(), stack_size());\n+    if (closure._num_frames > 0) {\n+      assert(closure._argsize >= frame::metadata_words_at_top, \"should be set up\");\n+      assert(argsize() == closure._argsize - frame::metadata_words_at_top,\n+             \"argsize(): %d closure.argsize: %d closure.callee_interpreted: %d\",\n+             argsize(), closure._argsize, closure._callee_interpreted);\n+    }\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+  inline void set_bottom(int value);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+inline int stackChunkOopDesc::bottom() const            { return jdk_internal_vm_StackChunk::bottom(as_oop()); }\n+inline void stackChunkOopDesc::set_bottom(int value)    { jdk_internal_vm_StackChunk::set_bottom(this, value); }\n+\n@@ -69,3 +72,0 @@\n-inline int stackChunkOopDesc::argsize() const           { return jdk_internal_vm_StackChunk::argsize(as_oop()); }\n-inline void stackChunkOopDesc::set_argsize(int value)   { jdk_internal_vm_StackChunk::set_argsize(as_oop(), value); }\n-\n@@ -111,1 +111,4 @@\n-inline int stackChunkOopDesc::bottom() const { return stack_size() - argsize() - frame::metadata_words_at_top; }\n+inline int stackChunkOopDesc::argsize() const {\n+  assert(!is_empty(), \"should not ask for argsize in empty chunk\");\n+  return stack_size() - bottom() - frame::metadata_words_at_top;\n+}\n@@ -135,4 +138,2 @@\n-  assert(sp() <= stack_size(), \"\");\n-  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize() - frame::metadata_words_at_top),\n-    \"sp: %d size: %d argsize: %d\", sp(), stack_size(), argsize());\n-  return sp() == stack_size();\n+  assert(sp() <= bottom(), \"\");\n+  return sp() == bottom();\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -796,0 +796,2 @@\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+  case vmIntrinsics::_intpoly_assign:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1168,15 +1168,0 @@\n-static void cast_argument(int nargs, int arg_nb, ciType* t, GraphKit& kit) {\n-  PhaseGVN& gvn = kit.gvn();\n-  Node* arg = kit.argument(arg_nb);\n-  const Type* arg_type = arg->bottom_type();\n-  const Type* sig_type = TypeOopPtr::make_from_klass(t->as_klass());\n-  if (arg_type->isa_oopptr() && !arg_type->higher_equal(sig_type)) {\n-    const Type* narrowed_arg_type = arg_type->filter_speculative(sig_type); \/\/ keep speculative part\n-    arg = gvn.transform(new CheckCastPPNode(kit.control(), arg, narrowed_arg_type));\n-    kit.set_argument(arg_nb, arg);\n-  }\n-  if (sig_type->is_inlinetypeptr()) {\n-    arg = InlineTypeNode::make_from_oop(&kit, arg, sig_type->inline_klass(), !kit.gvn().type(arg)->maybe_null());\n-    kit.set_argument(arg_nb, arg);\n-  }\n-}\n@@ -1257,1 +1242,9 @@\n-          cast_argument(nargs, 0, signature->accessing_klass(), kit);\n+          Node* recv = kit.argument(0);\n+          Node* casted_recv = kit.maybe_narrow_object_type(recv, signature->accessing_klass());\n+          if (casted_recv->is_top()) {\n+            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n+                                   \"argument types mismatch\");\n+            return nullptr; \/\/ FIXME: effectively dead; issue a halt node instead\n+          } else if (casted_recv != recv) {\n+            kit.set_argument(0, casted_recv);\n+          }\n@@ -1263,1 +1256,9 @@\n-            cast_argument(nargs, receiver_skip + j, t, kit);\n+            Node* arg = kit.argument(receiver_skip + j);\n+            Node* casted_arg = kit.maybe_narrow_object_type(arg, t->as_klass());\n+            if (casted_arg->is_top()) {\n+              print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n+                                     \"argument types mismatch\");\n+              return nullptr; \/\/ FIXME: effectively dead; issue a halt node instead\n+            } else if (casted_arg != arg) {\n+              kit.set_argument(receiver_skip + j, casted_arg);\n+            }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -236,7 +236,1 @@\n-  \/\/ But here we have to pay extra attention:\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (!_range_check_dependency) {\n-    res = widen_type(phase, res, T_INT);\n-  }\n+  res = widen_type(phase, res, T_INT);\n@@ -262,1 +256,1 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n@@ -266,1 +260,1 @@\n-  if (!_range_check_dependency) {\n+  if (!_type->is_int()->empty()) {\n@@ -277,7 +271,0 @@\n-  if (_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      return this->in(1);\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -507,0 +507,5 @@\n+  \/\/ Return the uncommon trap If projection of this Parse Predicate.\n+  ParsePredicateUncommonProj* uncommon_proj() const {\n+    return proj_out(0)->as_IfFalse();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -860,2 +860,0 @@\n-  \/\/ If any phase is randomized for stress testing, seed random number\n-  \/\/ generation and log the seed for repeatability.\n@@ -864,9 +862,1 @@\n-    if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && directive->RepeatCompilationOption)) {\n-      _stress_seed = static_cast<uint>(Ticks::now().nanoseconds());\n-      FLAG_SET_ERGO(StressSeed, _stress_seed);\n-    } else {\n-      _stress_seed = StressSeed;\n-    }\n-    if (_log != nullptr) {\n-      _log->elem(\"stress_test seed='%u'\", _stress_seed);\n-    }\n+    initialize_stress_seed(directive);\n@@ -1010,0 +1000,5 @@\n+\n+  if (StressLCM || StressGCM) {\n+    initialize_stress_seed(directive);\n+  }\n+\n@@ -3985,0 +3980,4 @@\n+  case Op_CastII: {\n+    remove_range_check_cast(n->as_CastII());\n+  }\n+  break;\n@@ -4136,10 +4135,0 @@\n-#ifdef ASSERT\n-  case Op_CastII:\n-    \/\/ Verify that all range check dependent CastII nodes were removed.\n-    if (n->isa_CastII()->has_range_check()) {\n-      n->dump(3);\n-      assert(false, \"Range check dependent CastII node was not removed\");\n-    }\n-    break;\n-#endif\n-\n@@ -4154,0 +4143,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -4174,0 +4165,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -4194,0 +4187,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -4214,0 +4209,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -4422,0 +4419,28 @@\n+void Compile::remove_range_check_cast(CastIINode* cast) {\n+  if (cast->has_range_check()) {\n+    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n+    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n+    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n+    \/\/ range check or a null divisor check.\n+    assert(cast->in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n+    ResourceMark rm;\n+    Unique_Node_List wq;\n+    wq.push(cast);\n+    for (uint next = 0; next < wq.size(); ++next) {\n+      Node* m = wq.at(next);\n+      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+        Node* use = m->fast_out(i);\n+        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n+          use->ensure_control_or_add_prec(cast->in(0));\n+        } else if (!use->is_CFG() && !use->is_Phi()) {\n+          wq.push(use);\n+        }\n+      }\n+    }\n+    cast->subsume_by(cast->in(1), this);\n+    if (cast->outcnt() == 0) {\n+      cast->disconnect_inputs(this);\n+    }\n+  }\n+}\n+\n@@ -5620,0 +5645,12 @@\n+void Compile::initialize_stress_seed(const DirectiveSet* directive) {\n+  if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && directive->RepeatCompilationOption)) {\n+    _stress_seed = static_cast<uint>(Ticks::now().nanoseconds());\n+    FLAG_SET_ERGO(StressSeed, _stress_seed);\n+  } else {\n+    _stress_seed = StressSeed;\n+  }\n+  if (_log != nullptr) {\n+    _log->elem(\"stress_test seed='%u'\", _stress_seed);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":58,"deletions":21,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+class CastIINode;\n@@ -1309,0 +1310,3 @@\n+  \/\/ seed random number generation and log the seed for repeatability.\n+  void initialize_stress_seed(const DirectiveSet* directive);\n+\n@@ -1342,0 +1346,2 @@\n+\n+  void remove_range_check_cast(CastIINode* cast);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -562,2 +562,2 @@\n-        } else if (nesting > 0 && load_type->isa_narrowklass()) {\n-          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Nested NarrowKlass Load: %s\", n->_idx, _invocation, use_use->Name());)\n+        } else if (load_type->isa_narrowklass() || load_type->isa_klassptr()) {\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. [Narrow] Klass Load: %s\", n->_idx, _invocation, use_use->Name());)\n@@ -745,3 +745,16 @@\n-  Node* nsr_value       = _igvn->zerocon(load_type->basic_type());\n-  Node* data_phi        = _igvn->transform(PhiNode::make(region, nsr_value, load_type));\n-  Node* memory          = curr_load->in(MemNode::Memory);\n+  Node* nsr_value = _igvn->zerocon(load_type->basic_type());\n+  Node* memory = curr_load->in(MemNode::Memory);\n+\n+  \/\/ The data_phi merging the loads needs to be nullable if\n+  \/\/ we are loading pointers.\n+  if (load_type->make_ptr() != nullptr) {\n+    if (load_type->isa_narrowoop()) {\n+      load_type = load_type->meet(TypeNarrowOop::NULL_PTR);\n+    } else if (load_type->isa_ptr()) {\n+      load_type = load_type->meet(TypePtr::NULL_PTR);\n+    } else {\n+      assert(false, \"Unexpected load ptr type.\");\n+    }\n+  }\n+\n+  Node* data_phi = PhiNode::make(region, nsr_value, load_type);\n@@ -761,1 +774,1 @@\n-      Node* load = _igvn->transform(curr_load->clone());\n+      Node* load = curr_load->clone();\n@@ -767,2 +780,2 @@\n-        Node* intermediate_phi = _igvn->transform(PhiNode::make(cmp_region, nsr_value, load_type));\n-        intermediate_phi->set_req(1, load);\n+        Node* intermediate_phi = PhiNode::make(cmp_region, nsr_value, load_type);\n+        intermediate_phi->set_req(1, _igvn->transform(load));\n@@ -772,1 +785,1 @@\n-      data_phi->set_req(i, load);\n+      data_phi->set_req(i, _igvn->transform(load));\n@@ -778,2 +791,2 @@\n-  \/\/ Takes care of updating CG and split_unique_types worklists due to cloned\n-  \/\/ AddP->Load.\n+  \/\/ Takes care of updating CG and split_unique_types worklists due\n+  \/\/ to cloned AddP->Load.\n@@ -782,1 +795,1 @@\n-  return data_phi;\n+  return _igvn->transform(data_phi);\n@@ -2199,0 +2212,2 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"intpoly_montgomeryMult_P256\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"intpoly_assign\") == 0 ||\n@@ -2226,1 +2241,2 @@\n-                  strcmp(call->as_CallLeaf()->_name, \"get_class_id_intrinsic\") == 0)\n+                  strcmp(call->as_CallLeaf()->_name, \"get_class_id_intrinsic\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"unsafe_setmemory\") == 0)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":29,"deletions":13,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1534,0 +1534,3 @@\n+  if (!tst->is_Con()) {\n+    record_for_igvn(iff);\n+  }\n@@ -4757,0 +4760,14 @@\n+\n+Node* GraphKit::maybe_narrow_object_type(Node* obj, ciKlass* type) {\n+  const Type* obj_type = obj->bottom_type();\n+  const TypeOopPtr* sig_type = TypeOopPtr::make_from_klass(type);\n+  if (obj_type->isa_oopptr() && sig_type->is_loaded() && !obj_type->higher_equal(sig_type)) {\n+    const Type* narrow_obj_type = obj_type->filter_speculative(sig_type); \/\/ keep speculative part\n+    Node* casted_obj = gvn().transform(new CheckCastPPNode(control(), obj, narrow_obj_type));\n+    obj = casted_obj;\n+  }\n+  if (sig_type->is_inlinetypeptr()) {\n+    obj = InlineTypeNode::make_from_oop(this, obj, sig_type->inline_klass(), !gvn().type(obj)->maybe_null());\n+  }\n+  return obj;\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -455,0 +455,2 @@\n+  Node* maybe_narrow_object_type(Node* obj, ciKlass* type);\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -612,17 +612,1 @@\n-    if (caller != nullptr) {\n-      stringStream bciStream;\n-      ciMethod* last = nullptr;\n-      int last_bci;\n-      while(caller) {\n-        if (caller->has_method()) {\n-          last = caller->method();\n-          last_bci = caller->bci();\n-        }\n-        bciStream.print(\"%d \", caller->bci());\n-        caller = caller->caller();\n-      }\n-      print_prop(\"bci\", bciStream.freeze());\n-      if (last != nullptr && last->has_linenumber_table() && last_bci >= 0) {\n-        print_prop(\"line\", last->line_number_from_bci(last_bci));\n-      }\n-    }\n+    print_bci_and_line_number(caller);\n@@ -657,0 +641,29 @@\n+void IdealGraphPrinter::print_bci_and_line_number(JVMState* caller) {\n+  if (caller != nullptr) {\n+    ResourceMark rm;\n+    stringStream bciStream;\n+    stringStream lineStream;\n+\n+    \/\/ Print line and bci numbers for the callee and all entries in the call stack until we reach the root method.\n+    while (caller) {\n+      const int bci = caller->bci();\n+      bool appended_line = false;\n+      if (caller->has_method()) {\n+        ciMethod* method = caller->method();\n+        if (method->has_linenumber_table() && bci >= 0) {\n+          lineStream.print(\"%d \", method->line_number_from_bci(bci));\n+          appended_line = true;\n+        }\n+      }\n+      if (!appended_line) {\n+        lineStream.print(\"%s \", \"_\");\n+      }\n+      bciStream.print(\"%d \", bci);\n+      caller = caller->caller();\n+    }\n+\n+    print_prop(\"bci\", bciStream.freeze());\n+    print_prop(\"line\", lineStream.freeze());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":30,"deletions":17,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class JVMState;\n@@ -99,3 +100,4 @@\n-  void print_method(ciMethod *method, int bci, InlineTree *tree);\n-  void print_inline_tree(InlineTree *tree);\n-  void visit_node(Node *n, bool edges, VectorSet* temp_set);\n+  void print_method(ciMethod* method, int bci, InlineTree* tree);\n+  void print_inline_tree(InlineTree* tree);\n+  void visit_node(Node* n, bool edges, VectorSet* temp_set);\n+  void print_bci_and_line_number(JVMState* caller);\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -648,1 +648,4 @@\n-\n+  case vmIntrinsics::_intpoly_montgomeryMult_P256:\n+    return inline_intpoly_montgomeryMult_P256();\n+  case vmIntrinsics::_intpoly_assign:\n+    return inline_intpoly_assign();\n@@ -7959,0 +7962,63 @@\n+bool LibraryCallKit::inline_intpoly_montgomeryMult_P256() {\n+  address stubAddr;\n+  const char *stubName;\n+  assert(UseIntPolyIntrinsics, \"need intpoly intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"intpoly_montgomeryMult_P256 has %d parameters\", callee()->signature()->size());\n+  stubAddr = StubRoutines::intpoly_montgomeryMult_P256();\n+  stubName = \"intpoly_montgomeryMult_P256\";\n+\n+  if (!stubAddr) return false;\n+  null_check_receiver();  \/\/ null-check receiver\n+  if (stopped())  return true;\n+\n+  Node* a = argument(1);\n+  Node* b = argument(2);\n+  Node* r = argument(3);\n+\n+  a = must_be_not_null(a, true);\n+  b = must_be_not_null(b, true);\n+  r = must_be_not_null(r, true);\n+\n+  Node* a_start = array_element_address(a, intcon(0), T_LONG);\n+  assert(a_start, \"a array is NULL\");\n+  Node* b_start = array_element_address(b, intcon(0), T_LONG);\n+  assert(b_start, \"b array is NULL\");\n+  Node* r_start = array_element_address(r, intcon(0), T_LONG);\n+  assert(r_start, \"r array is NULL\");\n+\n+  Node* call = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                 OptoRuntime::intpoly_montgomeryMult_P256_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 a_start, b_start, r_start);\n+  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+  set_result(result);\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_intpoly_assign() {\n+  assert(UseIntPolyIntrinsics, \"need intpoly intrinsics support\");\n+  assert(callee()->signature()->size() == 3, \"intpoly_assign has %d parameters\", callee()->signature()->size());\n+  const char *stubName = \"intpoly_assign\";\n+  address stubAddr = StubRoutines::intpoly_assign();\n+  if (!stubAddr) return false;\n+\n+  Node* set = argument(0);\n+  Node* a = argument(1);\n+  Node* b = argument(2);\n+  Node* arr_length = load_array_length(a);\n+\n+  a = must_be_not_null(a, true);\n+  b = must_be_not_null(b, true);\n+\n+  Node* a_start = array_element_address(a, intcon(0), T_LONG);\n+  assert(a_start, \"a array is NULL\");\n+  Node* b_start = array_element_address(b, intcon(0), T_LONG);\n+  assert(b_start, \"b array is NULL\");\n+\n+  Node* call = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                 OptoRuntime::intpoly_assign_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 set, a_start, b_start, arr_length);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -335,0 +335,2 @@\n+  bool inline_intpoly_montgomeryMult_P256();\n+  bool inline_intpoly_assign();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-IfProjNode* PhaseIdealLoop::create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                                        Deoptimization::DeoptReason reason,\n+IfTrueNode* PhaseIdealLoop::create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_success_proj,\n+                                                        Node* new_entry, const Deoptimization::DeoptReason reason,\n@@ -105,6 +105,4 @@\n-  assert(parse_predicate_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n-  ParsePredicateNode* parse_predicate = parse_predicate_proj->in(0)->as_ParsePredicate();\n-\n-  ProjNode* uncommon_proj = parse_predicate->proj_out(false);\n-  Node* uct_region = uncommon_proj->unique_ctrl_out();\n-  assert(uct_region->is_Region() || uct_region->is_Call(), \"must be a region or call uct\");\n+  assert(parse_predicate_success_proj->is_uncommon_trap_if_pattern(reason), \"must be a uct if pattern!\");\n+  ParsePredicateNode* parse_predicate = parse_predicate_success_proj->in(0)->as_ParsePredicate();\n+  ParsePredicateUncommonProj* uncommon_proj = parse_predicate->uncommon_proj();\n+  Node* uncommon_trap = parse_predicate->uncommon_trap();\n@@ -113,3 +111,3 @@\n-  if (!uct_region->is_Region()) { \/\/ create a region to guard the call\n-    assert(uct_region->is_Call(), \"must be call uct\");\n-    CallNode* call = uct_region->as_Call();\n+  if (!uncommon_trap->is_Region()) { \/\/ create a region to guard the call\n+    assert(uncommon_trap->is_Call(), \"must be call uct\");\n+    CallNode* call = uncommon_trap->as_Call();\n@@ -117,1 +115,1 @@\n-    uct_region = new RegionNode(1);\n+    uncommon_trap = new RegionNode(1);\n@@ -119,1 +117,1 @@\n-    uncommon_proj = uncommon_proj->clone()->as_Proj();\n+    uncommon_proj = uncommon_proj->clone()->as_IfFalse();\n@@ -121,3 +119,3 @@\n-    uct_region->add_req(uncommon_proj);\n-    register_control(uct_region, loop, uncommon_proj);\n-    _igvn.replace_input_of(call, 0, uct_region);\n+    uncommon_trap->add_req(uncommon_proj);\n+    register_control(uncommon_trap, loop, uncommon_proj);\n+    _igvn.replace_input_of(call, 0, uncommon_trap);\n@@ -126,1 +124,1 @@\n-      set_idom(call, uct_region, dom_depth(uct_region));\n+      set_idom(call, uncommon_trap, dom_depth(uncommon_trap));\n@@ -130,1 +128,1 @@\n-    lazy_replace(uncommon_proj_orig, uct_region);\n+    lazy_replace(uncommon_proj_orig, uncommon_trap);\n@@ -133,3 +131,3 @@\n-    for (; proj_index < uct_region->req(); proj_index++)\n-      if (uct_region->in(proj_index) == uncommon_proj) break;\n-    assert(proj_index < uct_region->req(), \"sanity\");\n+    for (; proj_index < uncommon_trap->req(); proj_index++)\n+      if (uncommon_trap->in(proj_index) == uncommon_proj) break;\n+    assert(proj_index < uncommon_trap->req(), \"sanity\");\n@@ -160,2 +158,3 @@\n-  IfProjNode* if_cont = new IfTrueNode(new_iff);\n-  IfProjNode* if_uct  = new IfFalseNode(new_iff);\n+\n+  IfTrueNode* if_cont = new IfTrueNode(new_iff);\n+  IfFalseNode* if_uct = new IfFalseNode(new_iff);\n@@ -164,1 +163,1 @@\n-  register_control(if_uct, get_loop(uct_region), new_iff);\n+  register_control(if_uct, get_loop(uncommon_trap), new_iff);\n@@ -166,1 +165,1 @@\n-  _igvn.add_input_to(uct_region, if_uct);\n+  _igvn.add_input_to(uncommon_trap, if_uct);\n@@ -170,1 +169,1 @@\n-  assert(uct_region->in(uct_region->req() - 1) == if_uct, \"new edge should be last\");\n+  assert(uncommon_trap->in(uncommon_trap->req() - 1) == if_uct, \"new edge should be last\");\n@@ -172,2 +171,2 @@\n-  for (DUIterator_Fast imax, i = uct_region->fast_outs(imax); i < imax; i++) {\n-    Node* use = uct_region->fast_out(i);\n+  for (DUIterator_Fast imax, i = uncommon_trap->fast_outs(imax); i < imax; i++) {\n+    Node* use = uncommon_trap->fast_out(i);\n@@ -175,1 +174,1 @@\n-      assert(use->in(0) == uct_region, \"\");\n+      assert(use->in(0) == uncommon_trap, \"\");\n@@ -196,1 +195,1 @@\n-  assert(!has_phi || uct_region->req() > 3, \"no phis when region is created\");\n+  assert(!has_phi || uncommon_trap->req() > 3, \"no phis when region is created\");\n@@ -208,1 +207,1 @@\n-    Node* ridom = idom(uct_region);\n+    Node* ridom = idom(uncommon_trap);\n@@ -210,1 +209,1 @@\n-    set_idom(uct_region, nrdom, dom_depth(uct_region));\n+    set_idom(uncommon_trap, nrdom, dom_depth(uncommon_trap));\n@@ -213,1 +212,1 @@\n-  return if_cont->as_IfProj();\n+  return if_cont;\n@@ -760,2 +759,2 @@\n-BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init,\n-                                       Node* limit, jint stride, Node* range, bool upper, bool& overflow) {\n+BoolNode* PhaseIdealLoop::rc_predicate(Node* ctrl, const int scale, Node* offset, Node* init, Node* limit,\n+                                       const jint stride, Node* range, const bool upper, bool& overflow) {\n@@ -1168,1 +1167,1 @@\n-    BoolNode* new_predicate_bol = invar.clone(bol, ctrl)->as_Bool();\n+    BoolNode* hoisted_check_predicate_bool = invar.clone(bol, ctrl)->as_Bool();\n@@ -1173,2 +1172,3 @@\n-      new_predicate_bol = new BoolNode(new_predicate_bol->in(1), new_predicate_bol->_test.negate());\n-      register_new_node(new_predicate_bol, ctrl);\n+      hoisted_check_predicate_bool = new BoolNode(hoisted_check_predicate_bool->in(1),\n+                                                  hoisted_check_predicate_bool->_test.negate());\n+      register_new_node(hoisted_check_predicate_bool, ctrl);\n@@ -1179,1 +1179,1 @@\n-    new_predicate_iff->set_req(1, new_predicate_bol);\n+    new_predicate_iff->set_req(1, hoisted_check_predicate_bool);\n@@ -1223,1 +1223,2 @@\n-    Node* ctrl = parse_predicate_proj->in(0)->as_If()->in(0);\n+    ParsePredicateNode* parse_predicate = parse_predicate_proj->in(0)->as_ParsePredicate();\n+    Node* ctrl = parse_predicate->in(0);\n@@ -1232,1 +1233,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n+    BoolNode* lower_bound_bol = rc_predicate(ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n@@ -1239,1 +1240,3 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) {\n+      tty->print_cr(\"lower bound check if: %d\", lower_bound_iff->_idx);\n+    }\n@@ -1242,2 +1245,1 @@\n-    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true,\n-                                             overflow);\n+    BoolNode* upper_bound_bol = rc_predicate(lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);\n@@ -1250,1 +1252,3 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %d\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) {\n+      tty->print_cr(\"upper bound check if: %d\", upper_bound_iff->_idx);\n+    }\n@@ -1297,1 +1301,1 @@\n-  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n+  BoolNode* bol = rc_predicate(upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n@@ -1320,1 +1324,1 @@\n-  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n+  bol = rc_predicate(new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n@@ -1343,4 +1347,0 @@\n-  if (head->is_OuterStripMinedLoop()) {\n-    return false;\n-  }\n-\n@@ -1517,1 +1517,1 @@\n-bool IdealLoopTree::loop_predication( PhaseIdealLoop *phase) {\n+bool IdealLoopTree::loop_predication(PhaseIdealLoop* phase) {\n@@ -1524,1 +1524,1 @@\n-  \/\/ self\n+  \/\/ Self\n@@ -1529,1 +1529,2 @@\n-  if (_next) { \/\/sibling\n+  \/\/ Sibling\n+  if (_next) {\n@@ -1537,1 +1538,5 @@\n-  return _head->is_Loop() && !_irreducible && !tail()->is_top();\n+  return !_head->is_Root() &&\n+         _head->is_Loop() &&\n+         !_head->is_OuterStripMinedLoop() &&\n+         !_irreducible &&\n+         !tail()->is_top();\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":60,"deletions":55,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2775,1 +2775,1 @@\n-  BoolNode* bol = rc_predicate(loop, ctrl, scale_con, offset, value, nullptr, stride_con,\n+  BoolNode* bol = rc_predicate(ctrl, scale_con, offset, value, nullptr, stride_con,\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4323,1 +4323,1 @@\n-  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n@@ -4362,1 +4362,1 @@\n-  Node* entry = loop->_head->in(LoopNode::EntryControl);\n+  Node* entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1345,1 +1345,1 @@\n-  IfProjNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n+  IfTrueNode* create_new_if_for_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n@@ -1368,1 +1368,1 @@\n-  BoolNode* rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n+  BoolNode* rc_predicate(Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,3 @@\n-  if (n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::LONG) {\n-    \/\/ ConvI2L may have type information on it which is unsafe to push up\n+  if ((n->Opcode() == Op_ConvI2L && n->bottom_type() != TypeLong::LONG) ||\n+      (n->Opcode() == Op_ConvL2I && n->bottom_type() != TypeInt::INT)) {\n+    \/\/ ConvI2L\/ConvL2I may have type information on it which is unsafe to push up\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -635,0 +635,3 @@\n+    } else if (!res_type->klass_is_exact()) {\n+      NOT_PRODUCT(fail_eliminate = \"Not an exact type.\";)\n+      can_eliminate = false;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3024,1 +3024,5 @@\n-  const TypeAryPtr* aryptr_t = _store->adr_type()->isa_aryptr();\n+  const TypePtr* ptr_t = _store->adr_type();\n+  if (ptr_t == nullptr) {\n+    return nullptr;\n+  }\n+  const TypeAryPtr* aryptr_t = ptr_t->isa_aryptr();\n@@ -3069,0 +3073,1 @@\n+      other_store->adr_type() == nullptr ||\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2888,0 +2888,9 @@\n+void Node::add_prec_from(Node* n) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    Node* prec = n->in(i);\n+    if (prec != nullptr) {\n+      add_prec(prec);\n+    }\n+  }\n+}\n+\n@@ -2911,0 +2920,3 @@\n+bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n+                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1160,0 +1160,1 @@\n+  void add_prec_from(Node* n);\n@@ -1271,0 +1272,2 @@\n+  bool is_div_or_mod(BasicType bt) const;\n+\n@@ -1586,1 +1589,0 @@\n-  DUIterator_Fast i;\n@@ -1588,0 +1590,1 @@\n+  DUIterator_Fast i;\n@@ -2040,0 +2043,4 @@\n+Op_IL(Div)\n+Op_IL(Mod)\n+Op_IL(UDiv)\n+Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1350,1 +1350,0 @@\n-  _method_size = 0;\n@@ -1394,0 +1393,1 @@\n+  \/\/ GC barrier stubs are generated in code section\n@@ -1395,1 +1395,1 @@\n-  stub_req += bs->estimate_stub_size();\n+  code_req += bs->estimate_stub_size();\n@@ -1404,1 +1404,1 @@\n-  if (StressCodeBuffers)\n+  if (StressCodeBuffers) {\n@@ -1406,1 +1406,1 @@\n-\n+  }\n@@ -1415,3 +1415,4 @@\n-  if (C->has_method_handle_invokes())\n-    total_req += deopt_handler_req;  \/\/ deopt MH handler\n-\n+  if (C->has_method_handle_invokes()) {\n+    total_req += deopt_handler_req;        \/\/ deopt MH handler\n+    stub_req  += deopt_handler_req;\n+  }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  int                    _method_size;           \/\/ Size of nmethod code segment in bytes\n@@ -169,1 +168,0 @@\n-  int               code_size()                 { return _method_size; }\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1410,0 +1410,39 @@\n+\/\/ MontgomeryIntegerPolynomialP256 multiply function\n+const TypeFunc* OptoRuntime::intpoly_montgomeryMult_P256_Type() {\n+  int argcnt = 3;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ a array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ b array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ r(esult) array\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n+\/\/ IntegerPolynomial constant time assignment function\n+const TypeFunc* OptoRuntime::intpoly_assign_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypeInt::INT;        \/\/ set flag\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ a array (result)\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ b array (if set is set)\n+  fields[argp++] = TypeInt::INT;        \/\/ array length\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -303,0 +303,2 @@\n+  static const TypeFunc* intpoly_montgomeryMult_P256_Type();\n+  static const TypeFunc* intpoly_assign_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  _align_to_ref(nullptr),                                   \/\/ memory reference to align vectors to\n@@ -54,0 +53,2 @@\n+  _mem_ref_for_main_loop_alignment(nullptr),\n+  _aw_for_main_loop_alignment(0),\n@@ -519,5 +520,0 @@\n-  \/\/ Take the first mem_ref as the reference to align to. The pre-loop trip count is\n-  \/\/ modified to align this reference to a vector-aligned address. If strict alignment\n-  \/\/ is required, we may change the reference later (see filter_packs_for_alignment()).\n-  MemNode* align_to_mem_ref = nullptr;\n-\n@@ -530,5 +526,0 @@\n-    if (align_to_mem_ref == nullptr) {\n-      align_to_mem_ref = mem_ref;\n-      set_align_to_ref(align_to_mem_ref);\n-    }\n-\n@@ -576,3 +567,0 @@\n-  assert(_pairset.is_empty() || align_to_mem_ref != nullptr,\n-         \"pairset empty or we find the alignment reference\");\n-\n@@ -1726,1 +1714,5 @@\n-    set_align_to_ref(current->as_constrained()->mem_ref());\n+    MemNode const* mem = current->as_constrained()->mem_ref();\n+    Node_List* pack = get_pack(mem);\n+    assert(pack != nullptr, \"memop of final solution must still be packed\");\n+    _mem_ref_for_main_loop_alignment = mem;\n+    _aw_for_main_loop_alignment = pack->size() * mem->memory_size();\n@@ -3400,0 +3392,26 @@\n+\/\/ Find the memop pack with the maximum vector width, unless they were already\n+\/\/ determined by SuperWord::filter_packs_for_alignment().\n+void SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n+  if (_mem_ref_for_main_loop_alignment != nullptr) {\n+    assert(vectors_should_be_aligned(), \"mem_ref only set if filtered for alignment\");\n+    return;\n+  }\n+\n+  MemNode const* mem_ref = nullptr;\n+  int max_aw = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    MemNode* first = pack->at(0)->isa_Mem();\n+    if (first == nullptr) { continue; }\n+\n+    int vw = first->memory_size() * pack->size();\n+    if (vw > max_aw) {\n+      max_aw = vw;\n+      mem_ref = first;\n+    }\n+  }\n+  assert(mem_ref != nullptr && max_aw > 0, \"found mem_ref and aw\");\n+  _mem_ref_for_main_loop_alignment = mem_ref;\n+  _aw_for_main_loop_alignment = max_aw;\n+}\n+\n@@ -3410,2 +3428,3 @@\n-\/\/ the address of \"align_to_ref\" to the maximal possible vector width. We adjust the pre-loop\n-\/\/ iteration count by adjusting the pre-loop limit.\n+\/\/ the address of \"_mem_ref_for_main_loop_alignment\" to \"_aw_for_main_loop_alignment\", which is a\n+\/\/ sufficiently large alignment width. We adjust the pre-loop iteration count by adjusting the\n+\/\/ pre-loop limit.\n@@ -3413,2 +3432,4 @@\n-  const MemNode* align_to_ref = _align_to_ref;\n-  assert(align_to_ref != nullptr, \"align_to_ref must be set\");\n+  determine_mem_ref_and_aw_for_main_loop_alignment();\n+  const MemNode* align_to_ref = _mem_ref_for_main_loop_alignment;\n+  const int aw                = _aw_for_main_loop_alignment;\n+  assert(align_to_ref != nullptr && aw > 0, \"must have alignment reference and aw\");\n@@ -3559,4 +3580,1 @@\n-\n-  \/\/ We chose an aw that is the maximal possible vector width for the type of\n-  \/\/ align_to_ref.\n-  const int aw       = vector_width_in_bytes(align_to_ref);\n+  \/\/\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -414,1 +414,0 @@\n-  MemNode const* _align_to_ref;          \/\/ Memory reference that pre-loop will align to\n@@ -419,0 +418,5 @@\n+  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ by adjusting the pre-loop limit.\n+  MemNode const* _mem_ref_for_main_loop_alignment;\n+  int _aw_for_main_loop_alignment;\n+\n@@ -566,2 +570,0 @@\n-  const MemNode* align_to_ref() const { return _align_to_ref; }\n-  void set_align_to_ref(const MemNode* m) { _align_to_ref = m; }\n@@ -673,0 +675,1 @@\n+  void determine_mem_ref_and_aw_for_main_loop_alignment();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4336,1 +4336,1 @@\n-    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n+    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded->with_speculative(speculative); }\n@@ -4338,1 +4338,1 @@\n-    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n+    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM->with_speculative(speculative); }\n@@ -4340,2 +4340,2 @@\n-      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n-      else                                       { return TypeInstPtr::NOTNULL; }\n+      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM->with_speculative(speculative);  }\n+      else                                       { return TypeInstPtr::NOTNULL->with_speculative(speculative); }\n@@ -4343,1 +4343,1 @@\n-    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n+    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded->with_speculative(speculative); }\n@@ -4345,1 +4345,1 @@\n-    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr()->with_speculative(speculative);\n@@ -4351,1 +4351,1 @@\n-    return TypeInstPtr::NOTNULL;\n+    return TypeInstPtr::NOTNULL->with_speculative(speculative);\n@@ -4353,1 +4353,1 @@\n-  return TypeInstPtr::BOTTOM;\n+  return TypeInstPtr::BOTTOM->with_speculative(speculative);\n@@ -4790,0 +4790,4 @@\n+const TypeInstPtr* TypeInstPtr::with_speculative(const TypePtr* speculative) const {\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_in_array(), _instance_id, speculative, _inline_depth);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1413,0 +1413,1 @@\n+  const TypeInstPtr* with_speculative(const TypePtr* speculative) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,11 @@\n+#define log_if_needed(...)        \\\n+  if (C->print_intrinsics()) {    \\\n+    tty->print_cr(__VA_ARGS__);   \\\n+  }\n+\n+#ifndef PRODUCT\n+#define non_product_log_if_needed(...) log_if_needed(__VA_ARGS__)\n+#else\n+#define non_product_log_if_needed(...)\n+#endif\n+\n@@ -88,6 +99,2 @@\n-      #ifndef PRODUCT\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n-                        NodeClassNames[Op_VectorLoadMask], type2name(elem_bt), num_elem);\n-        }\n-      #endif\n+        non_product_log_if_needed(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n+                                  NodeClassNames[Op_VectorLoadMask], type2name(elem_bt), num_elem);\n@@ -101,6 +108,2 @@\n-      #ifndef PRODUCT\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n-                        NodeClassNames[opc], type2name(elem_bt), num_elem);\n-        }\n-      #endif\n+        non_product_log_if_needed(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n+                                  NodeClassNames[opc], type2name(elem_bt), num_elem);\n@@ -188,5 +191,1 @@\n-#ifndef PRODUCT\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** Rejected intrinsification because no valid vector op could be extracted\");\n-    }\n-#endif\n+    non_product_log_if_needed(\"  ** Rejected intrinsification because no valid vector op could be extracted\");\n@@ -198,6 +197,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -208,6 +203,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support integral vector negate\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support integral vector negate\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -219,6 +210,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -233,6 +220,2 @@\n-#ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector mask op (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-#endif\n+      non_product_log_if_needed(\"  ** Rejected vector mask op (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -244,6 +227,2 @@\n-#ifndef PRODUCT\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Not a svml call or load\/store vector op (%s,%s,%d)\",\n-                        NodeClassNames[sopc], type2name(type), num_elem);\n-        }\n-#endif\n+        non_product_log_if_needed(\"  ** Not a svml call or load\/store vector op (%s,%s,%d)\",\n+                                  NodeClassNames[sopc], type2name(type), num_elem);\n@@ -257,4 +236,2 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n-                    NodeClassNames[sopc], type2name(type), num_elem);\n-    }\n+    log_if_needed(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n+                  NodeClassNames[sopc], type2name(type), num_elem);\n@@ -270,6 +247,2 @@\n-    #ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[Op_VectorLoadMask], type2name(type), num_elem);\n-      }\n-    #endif\n+      non_product_log_if_needed(\"  ** Rejected vector mask loading (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[Op_VectorLoadMask], type2name(type), num_elem);\n@@ -286,6 +259,2 @@\n-    #ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"Rejected vector mask storing (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[Op_VectorStoreMask], type2name(type), num_elem);\n-      }\n-    #endif\n+      non_product_log_if_needed(\"Rejected vector mask storing (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[Op_VectorStoreMask], type2name(type), num_elem);\n@@ -308,6 +277,2 @@\n-    #ifndef PRODUCT\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n-                      NodeClassNames[sopc], type2name(type), num_elem);\n-      }\n-    #endif\n+      non_product_log_if_needed(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n+                                NodeClassNames[sopc], type2name(type), num_elem);\n@@ -363,2 +328,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n@@ -369,1 +333,0 @@\n-    }\n@@ -375,3 +338,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -381,3 +342,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -393,3 +352,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n@@ -400,3 +357,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -407,3 +362,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -419,3 +372,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n@@ -426,2 +377,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n+      log_if_needed(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n@@ -429,1 +379,0 @@\n-      }\n@@ -442,3 +391,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** vector stubs support is disabled\");\n-      }\n+      log_if_needed(\"  ** vector stubs support is disabled\");\n@@ -448,3 +395,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** no vector calling conventions supported\");\n-      }\n+      log_if_needed(\"  ** no vector calling conventions supported\");\n@@ -454,2 +399,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n+      log_if_needed(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n@@ -457,1 +401,0 @@\n-      }\n@@ -466,2 +409,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d is_masked_op=%d\",\n+    log_if_needed(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d is_masked_op=%d\",\n@@ -470,1 +412,0 @@\n-    }\n@@ -477,2 +418,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=0 is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=0 is_masked_op=1\",\n@@ -480,1 +420,0 @@\n-    }\n@@ -489,2 +428,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** unbox failed v3=%s\",\n+        log_if_needed(\"  ** unbox failed v3=%s\",\n@@ -492,1 +430,0 @@\n-        }\n@@ -500,2 +437,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** unbox failed v2=%s\",\n+        log_if_needed(\"  ** unbox failed v2=%s\",\n@@ -503,1 +439,0 @@\n-        }\n@@ -511,2 +446,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** unbox failed v1=%s\",\n+        log_if_needed(\"  ** unbox failed v1=%s\",\n@@ -514,1 +448,0 @@\n-        }\n@@ -529,2 +462,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+      log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -532,1 +464,0 @@\n-      }\n@@ -542,2 +473,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** svml call failed for %s_%s_%d\",\n+      log_if_needed(\"  ** svml call failed for %s_%s_%d\",\n@@ -547,1 +477,0 @@\n-      }\n@@ -602,3 +531,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -711,3 +638,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -723,2 +648,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+    log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n@@ -726,1 +650,0 @@\n-    }\n@@ -735,2 +658,1 @@\n-    if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+    log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -738,1 +660,0 @@\n-    }\n@@ -777,3 +698,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -794,2 +713,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+    log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n@@ -797,1 +715,0 @@\n-    }\n@@ -841,2 +758,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s\",\n@@ -847,1 +763,0 @@\n-    }\n@@ -852,3 +767,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -859,3 +772,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -875,2 +786,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n+    log_if_needed(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n@@ -880,1 +790,0 @@\n-    }\n@@ -976,2 +885,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s from_ms=%s\",\n@@ -982,1 +890,0 @@\n-    }\n@@ -986,3 +893,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -994,3 +899,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1004,2 +907,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ismask=no\",\n@@ -1008,1 +910,0 @@\n-    }\n@@ -1049,3 +950,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** non-primitive array element type\");\n-    }\n+    log_if_needed(\"  ** non-primitive array element type\");\n@@ -1056,2 +955,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n@@ -1060,1 +958,0 @@\n-    }\n@@ -1071,2 +968,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n+        log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n@@ -1075,1 +971,0 @@\n-        }\n@@ -1083,2 +978,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n+        log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d*8 etype=%s\/8 ismask=no\",\n@@ -1087,1 +981,0 @@\n-        }\n@@ -1201,2 +1094,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s from_ms=%s\",\n@@ -1208,1 +1100,0 @@\n-    }\n@@ -1212,3 +1103,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1219,3 +1108,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** mask klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -1227,3 +1114,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1251,2 +1136,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s\",\n@@ -1255,1 +1139,0 @@\n-    }\n@@ -1277,2 +1160,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** missing constant: offsetInRange=%s\",\n+        log_if_needed(\"  ** missing constant: offsetInRange=%s\",\n@@ -1280,1 +1162,0 @@\n-        }\n@@ -1289,2 +1170,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: op=%s vlen=%d etype=%s mismatched_ms=%d\",\n+      log_if_needed(\"  ** not supported: op=%s vlen=%d etype=%s mismatched_ms=%d\",\n@@ -1293,1 +1173,0 @@\n-      }\n@@ -1304,2 +1183,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: op=loadMasked vlen=%d etype=%s mismatched_ms=%d\",\n+    log_if_needed(\"  ** not supported: op=loadMasked vlen=%d etype=%s mismatched_ms=%d\",\n@@ -1307,1 +1185,0 @@\n-    }\n@@ -1317,2 +1194,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s mismatched_ms=1\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s mismatched_ms=1\",\n@@ -1321,1 +1197,0 @@\n-      }\n@@ -1331,2 +1206,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s\",\n@@ -1335,1 +1209,0 @@\n-    }\n@@ -1355,2 +1228,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** unbox failed mask=%s\",\n+    log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -1359,1 +1231,0 @@\n-    }\n@@ -1368,2 +1239,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed vector=%s\",\n+      log_if_needed(\"  ** unbox failed vector=%s\",\n@@ -1371,1 +1241,0 @@\n-      }\n@@ -1463,2 +1332,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n@@ -1469,1 +1337,0 @@\n-    }\n@@ -1474,3 +1341,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1482,3 +1347,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1495,3 +1358,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(1)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(1)->Opcode()]);\n@@ -1502,3 +1363,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -1509,3 +1368,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -1518,2 +1375,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=1\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=1\",\n@@ -1522,1 +1378,0 @@\n-      }\n@@ -1528,2 +1383,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=0\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=0\",\n@@ -1532,1 +1386,0 @@\n-      }\n@@ -1540,2 +1393,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n+      log_if_needed(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n@@ -1544,1 +1396,0 @@\n-      }\n@@ -1562,2 +1413,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s ismask=no\",\n@@ -1566,1 +1416,0 @@\n-    }\n@@ -1598,2 +1447,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+      log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -1602,1 +1450,0 @@\n-      }\n@@ -1672,2 +1519,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n@@ -1678,1 +1524,0 @@\n-    }\n@@ -1682,3 +1527,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1689,3 +1532,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1699,3 +1540,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n@@ -1706,3 +1545,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -1713,3 +1550,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -1727,2 +1562,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=%d\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=%d\",\n@@ -1730,1 +1564,0 @@\n-    }\n@@ -1737,2 +1570,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%d\/reduce vlen=%d etype=%s is_masked_op=1\",\n@@ -1740,1 +1572,0 @@\n-    }\n@@ -1759,2 +1590,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n+      log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -1762,1 +1592,0 @@\n-      }\n@@ -1825,2 +1654,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: cond=%s vclass=%s etype=%s vlen=%s\",\n@@ -1831,1 +1659,0 @@\n-    }\n@@ -1835,3 +1662,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1842,3 +1667,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1854,2 +1677,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=test\/%d vlen=%d etype=%s ismask=%d\",\n+    log_if_needed(\"  ** not supported: arity=2 op=test\/%d vlen=%d etype=%s ismask=%d\",\n@@ -1858,1 +1680,0 @@\n-    }\n@@ -1903,2 +1724,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s mclass=%s etype=%s vlen=%s\",\n@@ -1909,1 +1729,0 @@\n-    }\n@@ -1913,3 +1732,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1920,3 +1737,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -1930,2 +1745,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=blend vlen=%d etype=%s ismask=useload\",\n+    log_if_needed(\"  ** not supported: arity=2 op=blend vlen=%d etype=%s ismask=useload\",\n@@ -1933,1 +1747,0 @@\n-    }\n@@ -1977,2 +1790,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: cond=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n@@ -1984,1 +1796,0 @@\n-    }\n@@ -1988,3 +1799,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -1995,3 +1804,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2007,2 +1814,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+      log_if_needed(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n@@ -2010,1 +1816,0 @@\n-      }\n@@ -2016,2 +1821,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+    log_if_needed(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n@@ -2019,1 +1823,0 @@\n-    }\n@@ -2035,2 +1838,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: mask = null arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: mask = null arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n@@ -2038,1 +1840,0 @@\n-    }\n@@ -2044,2 +1845,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n+    log_if_needed(\"  ** not supported: arity=2 op=comp\/%d vlen=%d etype=%s ismask=usestore is_masked_op=1\",\n@@ -2047,1 +1847,0 @@\n-    }\n@@ -2100,2 +1899,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s sclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s sclass=%s etype=%s vlen=%s\",\n@@ -2106,1 +1904,0 @@\n-    }\n@@ -2111,3 +1908,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2118,3 +1913,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2128,2 +1921,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=0 op=load\/shuffle vlen=%d etype=%s ismask=no\",\n@@ -2131,1 +1923,0 @@\n-    }\n@@ -2141,3 +1932,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** mask_klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** mask_klass argument not initialized\");\n@@ -2152,2 +1941,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=2 op=shuffle\/rearrange vlen=%d etype=%s ismask=no\",\n+      log_if_needed(\"  ** not supported: arity=2 op=shuffle\/rearrange vlen=%d etype=%s ismask=no\",\n@@ -2155,1 +1943,0 @@\n-      }\n@@ -2178,2 +1965,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=3 op=shuffle\/rearrange vlen=%d etype=%s ismask=useload is_masked_op=1\",\n+      log_if_needed(\"  ** not supported: arity=3 op=shuffle\/rearrange vlen=%d etype=%s ismask=useload is_masked_op=1\",\n@@ -2181,1 +1967,0 @@\n-      }\n@@ -2283,2 +2068,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s\",\n@@ -2289,1 +2073,0 @@\n-    }\n@@ -2293,3 +2076,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2303,3 +2084,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n@@ -2310,3 +2089,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** mask klass argument not initialized\");\n-      }\n+      log_if_needed(\"  ** mask klass argument not initialized\");\n@@ -2317,3 +2094,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** null mask values are not allowed for masked op\");\n-      }\n+      log_if_needed(\"  ** null mask values are not allowed for masked op\");\n@@ -2326,3 +2101,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2340,3 +2113,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** operation not supported: op=%d bt=%s\", opr->get_con(), type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** operation not supported: op=%d bt=%s\", opr->get_con(), type2name(elem_bt));\n@@ -2348,3 +2119,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n@@ -2373,2 +2142,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s is_masked_op=%d\",\n+      log_if_needed(\"  ** not supported: arity=0 op=int\/%d vlen=%d etype=%s is_masked_op=%d\",\n@@ -2376,1 +2144,0 @@\n-      }\n@@ -2407,3 +2174,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\", NodeClassNames[argument(7)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(7)->Opcode()]);\n@@ -2459,2 +2224,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass_from=%s etype_from=%s vlen_from=%s vclass_to=%s etype_to=%s vlen_to=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass_from=%s etype_from=%s vlen_from=%s vclass_to=%s etype_to=%s vlen_to=%s\",\n@@ -2468,1 +2232,0 @@\n-    }\n@@ -2472,3 +2235,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2511,2 +2272,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%s\/1 vlen1=%d etype1=%s ismask=%d\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%s\/1 vlen1=%d etype1=%s ismask=%d\",\n@@ -2515,1 +2275,0 @@\n-    }\n@@ -2524,2 +2283,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=%s\/2 vlen2=%d etype2=%s ismask=%d\",\n+    log_if_needed(\"  ** not supported: arity=1 op=%s\/2 vlen2=%d etype2=%s ismask=%d\",\n@@ -2528,1 +2286,0 @@\n-    }\n@@ -2568,2 +2325,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s ismask=%d\",\n+      log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s ismask=%d\",\n@@ -2571,1 +2327,0 @@\n-      }\n@@ -2583,2 +2338,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/4 vlen1=%d etype2=%s ismask=%d\",\n+        log_if_needed(\"  ** not supported: arity=1 op=cast#%d\/4 vlen1=%d etype2=%s ismask=%d\",\n@@ -2587,1 +2341,0 @@\n-        }\n@@ -2605,2 +2358,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** not supported: arity=1 op=cast\/5 vlen2=%d etype1=%s ismask=%d\",\n+        log_if_needed(\"  ** not supported: arity=1 op=cast\/5 vlen2=%d etype1=%s ismask=%d\",\n@@ -2608,1 +2360,0 @@\n-        }\n@@ -2619,2 +2370,1 @@\n-          if (C->print_intrinsics()) {\n-            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+          log_if_needed(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n@@ -2622,1 +2372,0 @@\n-          }\n@@ -2660,2 +2409,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n@@ -2666,1 +2414,0 @@\n-    }\n@@ -2670,3 +2417,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2677,3 +2422,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2685,2 +2428,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=insert vlen=%d etype=%s ismask=no\",\n+    log_if_needed(\"  ** not supported: arity=1 op=insert vlen=%d etype=%s ismask=no\",\n@@ -2688,1 +2430,0 @@\n-    }\n@@ -2754,2 +2495,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n@@ -2759,1 +2499,0 @@\n-    }\n@@ -2763,3 +2502,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2770,3 +2507,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2810,3 +2545,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** Rejected mask extraction because architecture does not support it\");\n-      }\n+      log_if_needed(\"  ** Rejected mask extraction because architecture does not support it\");\n@@ -2818,3 +2551,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n-      }\n+      log_if_needed(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n@@ -2826,2 +2557,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n+      log_if_needed(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n@@ -2829,1 +2559,0 @@\n-      }\n@@ -2885,2 +2614,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n@@ -2892,1 +2620,0 @@\n-    }\n@@ -2897,3 +2624,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2905,3 +2630,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -2916,2 +2639,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+    log_if_needed(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n@@ -2919,1 +2641,0 @@\n-    }\n@@ -2930,2 +2651,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed vector=%s\",\n+      log_if_needed(\"  ** unbox failed vector=%s\",\n@@ -2933,1 +2653,0 @@\n-      }\n@@ -2944,2 +2663,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** unbox failed mask=%s\",\n+    log_if_needed(\"  ** unbox failed mask=%s\",\n@@ -2947,1 +2665,0 @@\n-    }\n@@ -2978,2 +2695,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n@@ -2983,1 +2699,0 @@\n-    }\n@@ -2988,3 +2703,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -2996,3 +2709,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -3007,3 +2718,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-    }\n+    log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3024,3 +2733,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-      }\n+      log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3035,2 +2742,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Rejected op (%s) because architecture does not support it\",\n+        log_if_needed(\"  ** Rejected op (%s) because architecture does not support it\",\n@@ -3038,1 +2744,0 @@\n-        }\n@@ -3048,2 +2753,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** unbox failed vector=%s\",\n+    log_if_needed(\"  ** unbox failed vector=%s\",\n@@ -3051,1 +2755,0 @@\n-    }\n@@ -3064,3 +2767,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-      }\n+      log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3127,2 +2828,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** missing constant: mclass=%s etype=%s vlen=%s\",\n+    log_if_needed(\"  ** missing constant: mclass=%s etype=%s vlen=%s\",\n@@ -3132,1 +2832,0 @@\n-    }\n@@ -3137,3 +2836,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n+    log_if_needed(\"  ** klass argument not initialized\");\n@@ -3145,3 +2842,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n-    }\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n@@ -3160,3 +2855,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n-      }\n+      log_if_needed(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n@@ -3171,2 +2864,1 @@\n-        if (C->print_intrinsics()) {\n-          tty->print_cr(\"  ** Rejected op (%s) because architecture does not support it\",\n+        log_if_needed(\"  ** Rejected op (%s) because architecture does not support it\",\n@@ -3174,1 +2866,0 @@\n-        }\n@@ -3183,3 +2874,1 @@\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** offset or limit argument is null\");\n-    }\n+    log_if_needed(\"  ** offset or limit argument is null\");\n@@ -3241,0 +2930,3 @@\n+\n+#undef non_product_log_if_needed\n+#undef log_if_needed\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":175,"deletions":483,"binary":false,"changes":658,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-  if (Universe::heap()->is_gc_active()) {\n+  if (Universe::heap()->is_stw_gc_active()) {\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -932,1 +932,3 @@\n-    assert(!_thread->is_in_any_VTMS_transition(), \"CFLH events are not allowed in any VTMS transition\");\n+    if (_thread->is_in_any_VTMS_transition()) {\n+      return; \/\/ no events should be posted if thread is in any VTMS transition\n+    }\n@@ -1369,2 +1371,2 @@\n-  if (thread->is_in_tmp_VTMS_transition()) {\n-    return; \/\/ skip ClassLoad events in tmp VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1372,1 +1374,0 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"class load events are not allowed in any VTMS transition\");\n@@ -1407,2 +1408,2 @@\n-  if (thread->is_in_tmp_VTMS_transition()) {\n-    return; \/\/ skip ClassPrepare events in tmp VTMS transition\n+  if (thread->is_in_any_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in any VTMS transition\n@@ -1410,1 +1411,0 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"class prepare events are not allowed in any VTMS transition\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,7 +163,3 @@\n-  jlong byte_offset = field_offset_to_byte_offset(field_offset);\n-\n-  if (sizeof(char*) == sizeof(jint)) {   \/\/ (this constant folds!)\n-    return cast_from_oop<address>(p) + (jint) byte_offset;\n-  } else {\n-    return cast_from_oop<address>(p) +        byte_offset;\n-  }\n+  uintptr_t base_address = cast_from_oop<uintptr_t>(p);\n+  uintptr_t byte_offset  = (uintptr_t)field_offset_to_byte_offset(field_offset);\n+  return (void*)(base_address + byte_offset);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -500,0 +500,1 @@\n+  { \"ZGenerational\",                JDK_Version::jdk(23), JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -506,0 +507,1 @@\n+  { \"OldSize\",                      JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-  virtual stackChunkOop allocate_chunk_slow(size_t stack_size) = 0;\n+  virtual stackChunkOop allocate_chunk_slow(size_t stack_size, int argsize_md) = 0;\n@@ -441,8 +441,0 @@\n-\n-#ifdef ASSERT\n-  bool is_empty(stackChunkOop chunk) {\n-    \/\/ during freeze, the chunk is in an intermediate state (after setting the chunk's argsize but before setting its\n-    \/\/ ultimate sp) so we use this instead of stackChunkOopDesc::is_empty\n-    return chunk->sp() >= chunk->stack_size() - chunk->argsize() - frame::metadata_words_at_top;\n-  }\n-#endif\n@@ -454,1 +446,1 @@\n-  stackChunkOop allocate_chunk(size_t stack_size);\n+  stackChunkOop allocate_chunk(size_t stack_size, int argsize_md);\n@@ -463,1 +455,1 @@\n-  virtual stackChunkOop allocate_chunk_slow(size_t stack_size) override { return allocate_chunk(stack_size); }\n+  virtual stackChunkOop allocate_chunk_slow(size_t stack_size, int argsize_md) override { return allocate_chunk(stack_size, argsize_md); }\n@@ -546,1 +538,1 @@\n-  stackChunkOop chunk = allocate_chunk(cont_size() + frame::metadata_words);\n+  stackChunkOop chunk = allocate_chunk(cont_size() + frame::metadata_words, _cont.argsize() + frame::metadata_words_at_top);\n@@ -575,1 +567,1 @@\n-  if (chunk_sp < chunk->stack_size()) {\n+  if (!chunk->is_empty()) {\n@@ -588,1 +580,0 @@\n-  DEBUG_ONLY(_orig_chunk_sp = chunk->sp_address();)\n@@ -593,1 +584,1 @@\n-  if (chunk->sp() < chunk->stack_size()) { \/\/ we are copying into a non-empty chunk\n+  if (!chunk->is_empty()) { \/\/ we are copying into a non-empty chunk\n@@ -595,1 +586,1 @@\n-    assert(chunk->sp() < (chunk->stack_size() - chunk->argsize()), \"\");\n+    DEBUG_ONLY(_orig_chunk_sp = chunk->sp_address();)\n@@ -633,2 +624,1 @@\n-    DEBUG_ONLY(_empty = true;)\n-    const int chunk_start_sp = chunk->sp();\n+    const int chunk_start_sp = chunk->stack_size();\n@@ -636,1 +626,2 @@\n-    assert(chunk_start_sp == chunk->stack_size(), \"\");\n+    DEBUG_ONLY(_empty = true;)\n+    DEBUG_ONLY(_orig_chunk_sp = chunk->start_address() + chunk_start_sp;)\n@@ -639,1 +630,2 @@\n-    chunk->set_argsize(_cont.argsize());\n+    chunk->set_bottom(chunk_start_sp - _cont.argsize() - frame::metadata_words_at_top);\n+    chunk->set_sp(chunk->bottom());\n@@ -657,1 +649,0 @@\n-  chunk->set_argsize(_cont.argsize());\n@@ -934,1 +925,0 @@\n-    unextended_sp = chunk->sp();\n@@ -942,0 +932,2 @@\n+    } else {\n+      unextended_sp = chunk->stack_size() - frame::metadata_words_at_top;\n@@ -979,1 +971,1 @@\n-    chunk = allocate_chunk_slow(_freeze_size);\n+    chunk = allocate_chunk_slow(_freeze_size, argsize_md);\n@@ -986,5 +978,1 @@\n-\n-    int sp = chunk->stack_size() - argsize_md;\n-    chunk->set_sp(sp);\n-    chunk->set_argsize(argsize);\n-    assert(is_empty(chunk), \"\");\n+    assert(chunk->is_empty(), \"\");\n@@ -997,1 +985,1 @@\n-      chunk->set_argsize(argsize);\n+      chunk->set_bottom(sp);\n@@ -1007,1 +995,1 @@\n-  assert(!_barriers || is_empty(chunk), \"\");\n+  assert(!_barriers || chunk->is_empty(), \"\");\n@@ -1009,2 +997,2 @@\n-  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n-  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n+  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n+  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n@@ -1056,1 +1044,1 @@\n-    assert((last_pc == nullptr) == is_empty(_cont.tail()), \"\");\n+    assert((last_pc == nullptr) == _cont.tail()->is_empty(), \"\");\n@@ -1309,0 +1297,1 @@\n+  int                                          _argsize_md;\n@@ -1324,0 +1313,2 @@\n+    int bottom = (int)_stack_size - _argsize_md;\n+\n@@ -1325,1 +1316,2 @@\n-    jdk_internal_vm_StackChunk::set_sp(mem, (int)_stack_size);\n+    jdk_internal_vm_StackChunk::set_bottom(mem, bottom);\n+    jdk_internal_vm_StackChunk::set_sp(mem, bottom);\n@@ -1349,0 +1341,1 @@\n+                      int argsize_md,\n@@ -1353,0 +1346,1 @@\n+      _argsize_md(argsize_md),\n@@ -1386,1 +1380,1 @@\n-stackChunkOop Freeze<ConfigT>::allocate_chunk(size_t stack_size) {\n+stackChunkOop Freeze<ConfigT>::allocate_chunk(size_t stack_size, int argsize_md) {\n@@ -1408,1 +1402,1 @@\n-  StackChunkAllocator allocator(klass, size_in_words, current, stack_size, _cont, _jvmti_event_collector);\n+  StackChunkAllocator allocator(klass, size_in_words, current, stack_size, argsize_md, _cont, _jvmti_event_collector);\n@@ -1418,1 +1412,1 @@\n-  assert(chunk->sp() == chunk->stack_size(), \"\");\n+  assert(chunk->sp() == chunk->bottom(), \"\");\n@@ -1422,1 +1416,1 @@\n-  assert(chunk->argsize() == 0, \"\");\n+  assert(chunk->is_empty(), \"\");\n@@ -1855,2 +1849,1 @@\n-  chunk->set_sp(chunk->stack_size());\n-  chunk->set_argsize(0);\n+  chunk->set_sp(chunk->bottom());\n@@ -1860,1 +1853,1 @@\n- int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n+int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n@@ -2107,2 +2100,1 @@\n-    chunk->set_argsize(0);\n-    chunk->set_sp(chunk->stack_size());\n+    chunk->set_sp(chunk->bottom());\n@@ -2380,1 +2372,0 @@\n-    assert(chunk->argsize() == 0, \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":35,"deletions":44,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-int jdk_internal_vm_StackChunk::_argsize_offset;\n+int jdk_internal_vm_StackChunk::_bottom_offset;\n@@ -96,1 +96,1 @@\n-  macro(_argsize_offset, k, vmSymbols::argsize_name(), int_signature,        false);\n+  macro(_bottom_offset,  k, vmSymbols::bottom_name(),  int_signature,        false);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  static int _argsize_offset;\n+  static int _bottom_offset;\n@@ -115,2 +115,3 @@\n-  static inline int argsize(oop chunk);\n-  static inline void set_argsize(oop chunk, int value);\n+  static inline int bottom(oop chunk);\n+  static inline void set_bottom(oop chunk, int value);\n+  static inline void set_bottom(HeapWord* chunk, int value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,0 +118,7 @@\n+inline void jdk_internal_vm_StackChunk::set_bottom(HeapWord* chunk, int value) {\n+  \/\/ Used by StackChunkAllocator before the Object has been finished,\n+  \/\/ so don't cast too oop and use int_field_put in this function.\n+  assert(_bottom_offset != 0, \"must be set\");\n+  *(int*)(((char*)chunk) + _bottom_offset) = (int)value;\n+}\n+\n@@ -119,1 +126,1 @@\n-  return chunk->int_field(_sp_offset);\n+  return chunk->int_field_relaxed(_sp_offset);\n@@ -123,1 +130,1 @@\n-  chunk->int_field_put(_sp_offset, value);\n+  chunk->int_field_put_relaxed(_sp_offset, value);\n@@ -141,2 +148,2 @@\n-inline int jdk_internal_vm_StackChunk::argsize(oop chunk) {\n-  return chunk->int_field(_argsize_offset);\n+inline int jdk_internal_vm_StackChunk::bottom(oop chunk) {\n+  return chunk->int_field(_bottom_offset);\n@@ -145,2 +152,2 @@\n-inline void jdk_internal_vm_StackChunk::set_argsize(oop chunk, int value) {\n-  chunk->int_field_put(_argsize_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_bottom(oop chunk, int value) {\n+  chunk->int_field_put(_bottom_offset, value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/memAllocator.hpp\"\n@@ -565,1 +566,1 @@\n-    bool unused;\n+    bool unused = false;\n@@ -1276,0 +1277,1 @@\n+        InternalOOMEMark iom(THREAD);\n@@ -1294,0 +1296,1 @@\n+      InternalOOMEMark iom(THREAD);\n@@ -1297,0 +1300,1 @@\n+      InternalOOMEMark iom(THREAD);\n@@ -1825,1 +1829,1 @@\n-      array->element(i)->free_monitors(thread);\n+      array->element(i)->free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-JVMFlag::Error AllocatePrefetchStepSizeConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error AllocatePrefetchStepSizeConstraintFunc(int value, bool verbose) {\n@@ -74,1 +74,1 @@\n-                          \"AllocatePrefetchStepSize (\" INTX_FORMAT \") must be multiple of %d\\n\",\n+                          \"AllocatePrefetchStepSize (%d) must be multiple of %d\\n\",\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  f(intx,  AllocatePrefetchStepSizeConstraintFunc)      \\\n+  f(int,   AllocatePrefetchStepSizeConstraintFunc)      \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -980,1 +980,1 @@\n-    m->mask_for(bci, &mask);\n+    m->mask_for(m, bci, &mask);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,0 +236,2 @@\n+  product(bool, UseIntPolyIntrinsics, false, DIAGNOSTIC,                   \\\n+          \"Use intrinsics for sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256\") \\\n@@ -476,3 +478,0 @@\n-  develop(bool, CheckZapUnusedHeapArea, false,                              \\\n-          \"Check zapping of unused heap space\")                             \\\n-                                                                            \\\n@@ -545,1 +544,1 @@\n-          \"(also see FullGCHeapDumpLimit)\")                                 \\\n+          \"(also see FullGCHeapDumpLimit, HeapDumpPath, HeapDumpGzipLevel)\")\\\n@@ -549,1 +548,1 @@\n-          \"(also see FullGCHeapDumpLimit)\")                                 \\\n+          \"(also see FullGCHeapDumpLimit, HeapDumpPath, HeapDumpGzipLevel)\")\\\n@@ -558,1 +557,2 @@\n-          \"from JVM\")                                                       \\\n+          \"from JVM \"                                                       \\\n+          \"(also see HeapDumpPath, HeapDumpGzipLevel)\")                     \\\n@@ -561,1 +561,2 @@\n-          \"When HeapDumpOnOutOfMemoryError is on, the path (filename or \"   \\\n+          \"When HeapDumpOnOutOfMemoryError, HeapDumpBeforeFullGC \"          \\\n+          \"or HeapDumpAfterFullGC is on, the path (filename or \"            \\\n@@ -566,1 +567,2 @@\n-          \"When HeapDumpOnOutOfMemoryError is on, the gzip compression \"    \\\n+          \"When HeapDumpOnOutOfMemoryError, HeapDumpBeforeFullGC \"          \\\n+          \"or HeapDumpAfterFullGC is on, the gzip compression \"             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -434,2 +434,0 @@\n-  _monitor_chunks(nullptr),\n-\n@@ -460,0 +458,1 @@\n+  _is_in_internal_oome_mark(false),\n@@ -464,1 +463,0 @@\n-  _in_retryable_allocation(false),\n@@ -1054,7 +1052,1 @@\n-  if (Thread::is_lock_owned(adr)) return true;\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) return true;\n-  }\n-\n-  return false;\n+  return is_in_full_stack(adr);\n@@ -1071,16 +1063,0 @@\n-void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {\n-  chunk->set_next(monitor_chunks());\n-  set_monitor_chunks(chunk);\n-}\n-\n-void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {\n-  guarantee(monitor_chunks() != nullptr, \"must be non empty\");\n-  if (monitor_chunks() == chunk) {\n-    set_monitor_chunks(chunk->next());\n-  } else {\n-    MonitorChunk* prev = monitor_chunks();\n-    while (prev->next() != chunk) prev = prev->next();\n-    prev->set_next(chunk->next());\n-  }\n-}\n-\n@@ -1412,7 +1388,0 @@\n-  if (has_last_Java_frame()) {\n-    \/\/ Traverse the monitor chunks\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n-      chunk->oops_do(f);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":33,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+class InternalOOMEMark;\n@@ -196,4 +197,0 @@\n-  MonitorChunk* _monitor_chunks;              \/\/ Contains the off stack monitors\n-                                              \/\/ allocated during deoptimization\n-                                              \/\/ and by JNI_MonitorEnter\/Exit\n-\n@@ -339,0 +336,2 @@\n+  \/\/ In scope of an InternalOOMEMark?\n+  bool _is_in_internal_oome_mark;\n@@ -354,4 +353,0 @@\n-  \/\/ True if in a runtime call from compiled code that will deoptimize\n-  \/\/ and re-execute a failed heap allocation in the interpreter.\n-  bool      _in_retryable_allocation;\n-\n@@ -684,1 +679,1 @@\n-  \/\/ Fast-locking support\n+  \/\/ Stack-locking support (not for LM_LIGHTWEIGHT)\n@@ -725,0 +720,4 @@\n+  \/\/ Is thread in scope of an InternalOOMEMark?\n+  bool is_in_internal_oome_mark() const          { return _is_in_internal_oome_mark; }\n+  void set_is_in_internal_oome_mark(bool b)      { _is_in_internal_oome_mark = b;    }\n+\n@@ -734,3 +733,0 @@\n-  virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }\n-  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n-\n@@ -889,3 +885,0 @@\n- private:\n-  void set_monitor_chunks(MonitorChunk* monitor_chunks) { _monitor_chunks = monitor_chunks; }\n-\n@@ -893,3 +886,0 @@\n-  MonitorChunk* monitor_chunks() const           { return _monitor_chunks; }\n-  void add_monitor_chunk(MonitorChunk* chunk);\n-  void remove_monitor_chunk(MonitorChunk* chunk);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  assert(!Universe::heap()->is_gc_active(), \"can't extend the root set during GC\");\n+  assert(!Universe::heap()->is_stw_gc_active(), \"can't extend the root set during GC pause\");\n@@ -110,1 +110,1 @@\n-  assert(!Universe::heap()->is_gc_active(), \"can't extend the root set during GC\");\n+  assert(!Universe::heap()->is_stw_gc_active(), \"can't extend the root set during GC pause\");\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-  _next               = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  MonitorChunk*    _next;\n@@ -47,4 +46,0 @@\n-  \/\/ link operations\n-  MonitorChunk* next() const                { return _next; }\n-  void set_next(MonitorChunk* next)         { _next = next; }\n-\n@@ -57,1 +52,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-Mutex*   OopMapCacheAlloc_lock        = nullptr;\n@@ -272,0 +271,1 @@\n+  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint);\n@@ -329,1 +329,0 @@\n-  MUTEX_DEFL(DirectivesStack_lock           , PaddedMutex  , CodeCache_lock);\n@@ -352,1 +351,0 @@\n-  MUTEX_DEFL(OopMapCacheAlloc_lock          , PaddedMutex  ,  Threads_lock, true);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-extern Mutex*   OopMapCacheAlloc_lock;           \/\/ protects allocation of oop_map caches\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -832,1 +832,0 @@\n-  int nWakeups = 0;\n@@ -875,0 +874,1 @@\n+\n@@ -879,1 +879,0 @@\n-\n@@ -883,1 +882,0 @@\n-    ++nWakeups;\n@@ -984,1 +982,0 @@\n-  int nWakeups = 0;\n@@ -990,0 +987,7 @@\n+    \/\/ This thread has been notified so try to reacquire the lock.\n+    if (TryLock(current) == TryLockResult::Success) {\n+      break;\n+    }\n+\n+    \/\/ If that fails, spin again.  Note that spin count may be zero so the above TryLock\n+    \/\/ is necessary.\n@@ -1014,5 +1018,0 @@\n-    \/\/ Keep a tally of the # of futile wakeups.\n-    \/\/ Note that the counter is not protected by a lock or updated by atomics.\n-    \/\/ That is by design - we trade \"lossy\" counters which are exposed to\n-    \/\/ races during updates for a lower probe effect.\n-    ++nWakeups;\n@@ -1028,0 +1027,4 @@\n+    \/\/ Keep a tally of the # of futile wakeups.\n+    \/\/ Note that the counter is not protected by a lock or updated by atomics.\n+    \/\/ That is by design - we trade \"lossy\" counters which are exposed to\n+    \/\/ races during updates for a lower probe effect.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1714,0 +1714,7 @@\n+\/\/ create binary file, rewriting existing file if required\n+int os::create_binary_file(const char* path, bool rewrite_existing) {\n+  int oflags = O_WRONLY | O_CREAT WINDOWS_ONLY(| O_BINARY);\n+  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n+  return ::open(path, oflags, S_IREAD | S_IWRITE);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-  ATTRIBUTE_NORETURN static void infinite_sleep();\n+  [[noreturn]] static void infinite_sleep();\n@@ -633,1 +633,1 @@\n-  ATTRIBUTE_NORETURN static void exit(int num);\n+  [[noreturn]] static void exit(int num);\n@@ -637,1 +637,1 @@\n-  ATTRIBUTE_NORETURN static void _exit(int num);\n+  [[noreturn]] static void _exit(int num);\n@@ -644,2 +644,2 @@\n-  ATTRIBUTE_NORETURN static void abort(bool dump_core, void *siginfo, const void *context);\n-  ATTRIBUTE_NORETURN static void abort(bool dump_core = true);\n+  [[noreturn]] static void abort(bool dump_core, void *siginfo, const void *context);\n+  [[noreturn]] static void abort(bool dump_core = true);\n@@ -652,1 +652,1 @@\n-  ATTRIBUTE_NORETURN static void die();\n+  [[noreturn]] static void die();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -98,0 +99,1 @@\n+    bool oopmap_cache_work = false;\n@@ -127,1 +129,2 @@\n-              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset())\n+              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset()) |\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n@@ -199,0 +202,4 @@\n+\n+    if (oopmap_cache_work) {\n+      OopMapCache::cleanup();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+address StubRoutines::_intpoly_montgomeryMult_P256         = nullptr;\n+address StubRoutines::_intpoly_assign                      = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,0 +218,2 @@\n+  static address _intpoly_montgomeryMult_P256;\n+  static address _intpoly_assign;\n@@ -415,0 +417,2 @@\n+  static address intpoly_montgomeryMult_P256()          { return _intpoly_montgomeryMult_P256; }\n+  static address intpoly_assign()        { return _intpoly_assign; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1101,1 +1101,3 @@\n-    } else if (LockingMode == LM_LEGACY && mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+    } else if (LockingMode == LM_LEGACY && mark.has_locker()\n+               && current->is_Java_thread()\n+               && JavaThread::cast(current)->is_lock_owned((address)mark.locker())) {\n@@ -1122,3 +1124,5 @@\n-    \/\/ An async deflation can race after the inflate() call and before we\n-    \/\/ can update the ObjectMonitor's header with the hash value below.\n-    monitor = inflate(current, obj, inflate_cause_hash_code);\n+    \/\/ There's no need to inflate if the mark has already got a monitor.\n+    \/\/ NOTE: an async deflation can race after we get the monitor and\n+    \/\/ before we can update the ObjectMonitor's header with the hash\n+    \/\/ value below.\n+    monitor = mark.has_monitor() ? mark.monitor() : inflate(current, obj, inflate_cause_hash_code);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -106,1 +107,4 @@\n-  _hashStateX = os::random();\n+  \/\/ If we are dumping, keep ihashes constant. Note that during dumping we only\n+  \/\/ ever run one java thread, and no other thread should generate ihashes either,\n+  \/\/ so using a constant seed should work fine.\n+  _hashStateX = CDSConfig::is_dumping_static_archive() ? 0x12345678 : os::random();\n@@ -530,10 +534,0 @@\n-\/\/ We had to move these methods here, because vm threads get into ObjectSynchronizer::enter\n-\/\/ However, there is a note in JavaThread::is_lock_owned() about the VM threads not being\n-\/\/ used for compilation in the future. If that change is made, the need for these methods\n-\/\/ should be revisited, and they should be removed if possible.\n-\n-bool Thread::is_lock_owned(address adr) const {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n-  return is_in_full_stack(adr);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -213,8 +213,0 @@\n-  \/\/ Determines if a heap allocation failure will be retried\n-  \/\/ (e.g., by deoptimizing and re-executing in the interpreter).\n-  \/\/ In this case, the failed allocation must raise\n-  \/\/ Universe::out_of_memory_error_retry() and omit side effects\n-  \/\/ such as JVMTI events and handling -XX:+HeapDumpOnOutOfMemoryError\n-  \/\/ and -XX:OnOutOfMemoryError.\n-  virtual bool in_retryable_allocation() const { return false; }\n-\n@@ -486,3 +478,0 @@\n-  \/\/ Used by fast lock support\n-  virtual bool is_lock_owned(address adr) const;\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -51,1 +52,1 @@\n-void vframeArrayElement::free_monitors(JavaThread* jt) {\n+void vframeArrayElement::free_monitors() {\n@@ -55,1 +56,0 @@\n-     jt->remove_monitor_chunk(chunk);\n@@ -75,1 +75,1 @@\n-    Thread* current_thread = Thread::current();\n+    JavaThread* current_thread = JavaThread::current();\n@@ -88,1 +88,0 @@\n-      vf->thread()->add_monitor_chunk(_monitors);\n@@ -98,1 +97,2 @@\n-          assert(monitor->owner() == nullptr || !monitor->owner()->is_unlocked(), \"object must be null or locked\");\n+          assert(monitor->owner() != nullptr, \"monitor owner must not be null\");\n+          assert(!monitor->owner()->is_unlocked(), \"monitor must be locked\");\n@@ -100,0 +100,3 @@\n+          assert(ObjectSynchronizer::current_thread_holds_lock(current_thread, Handle(current_thread, dest->obj())),\n+                 \"should be held, before move_to\");\n+\n@@ -101,0 +104,3 @@\n+\n+          assert(ObjectSynchronizer::current_thread_holds_lock(current_thread, Handle(current_thread, dest->obj())),\n+                 \"should be held, after move_to\");\n@@ -311,0 +317,2 @@\n+    assert(src->obj() != nullptr || ObjectSynchronizer::current_thread_holds_lock(thread, Handle(thread, src->obj())),\n+           \"should be held, before move_to\");\n@@ -312,0 +320,2 @@\n+    assert(src->obj() != nullptr || ObjectSynchronizer::current_thread_holds_lock(thread, Handle(thread, src->obj())),\n+           \"should be held, after move_to\");\n@@ -652,1 +662,0 @@\n-  JavaThread* jt = JavaThread::current();\n@@ -654,1 +663,1 @@\n-     element(index)->free_monitors(jt);\n+     element(index)->free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  void free_monitors(JavaThread* jt);\n+  void free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-  template(GenCollectFull)                        \\\n-  template(GenCollectForAllocation)               \\\n+  template(SerialCollectForAllocation)            \\\n+  template(SerialGCCollect)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+  volatile_nonstatic_field(InstanceKlass,      _methods_jmethod_ids,                          jmethodID*)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-    dumper.dump(path, out, level, false, HeapDumper::default_num_of_dump_threads());\n+    dumper.dump(path, out, level);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesReplaceDCmd>(full_export, true, false));\n@@ -927,3 +926,1 @@\n-  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n+  _filename(\"filename\",\"Name of the directives file\", \"STRING\",true) {\n@@ -931,1 +928,0 @@\n-  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -936,37 +932,0 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches(true);\n-    CodeCache::recompile_marked_directives_matches();\n-  }\n-}\n-\n-CompilerDirectivesReplaceDCmd::CompilerDirectivesReplaceDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_argument(&_filename);\n-  _dcmdparser.add_dcmd_option(&_refresh);\n-}\n-\n-void CompilerDirectivesReplaceDCmd::execute(DCmdSource source, TRAPS) {\n-  \/\/ Need to mark the methods twice, to account for the method that doesn't match\n-  \/\/ the directives anymore\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches();\n-\n-    DirectivesStack::clear();\n-    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n-\n-    CodeCache::mark_directives_matches();\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::clear();\n-    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n-  }\n-}\n-\n-CompilerDirectivesRemoveDCmd::CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -976,14 +935,1 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches(true);\n-    DirectivesStack::pop(1);\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::pop(1);\n-  }\n-}\n-\n-CompilerDirectivesClearDCmd::CompilerDirectivesClearDCmd(outputStream* output, bool heap) :\n-                           DCmdWithParser(output, heap),\n-  _refresh(\"-r\", \"Refresh affected methods\", \"BOOLEAN\", false, \"false\") {\n-\n-  _dcmdparser.add_dcmd_option(&_refresh);\n+  DirectivesStack::pop(1);\n@@ -993,7 +939,1 @@\n-  if (_refresh.value()) {\n-    CodeCache::mark_directives_matches();\n-    DirectivesStack::clear();\n-    CodeCache::recompile_marked_directives_matches();\n-  } else {\n-    DirectivesStack::clear();\n-  }\n+  DirectivesStack::clear();\n@@ -1001,1 +941,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":64,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -716,3 +716,1 @@\n-class CompilerDirectivesRemoveDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+class CompilerDirectivesRemoveDCmd : public DCmd {\n@@ -720,2 +718,1 @@\n-  static int num_arguments() { return 1; }\n-  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap);\n+  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -742,1 +739,0 @@\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -744,1 +740,1 @@\n-  static int num_arguments() { return 2; }\n+  static int num_arguments() { return 1; }\n@@ -763,27 +759,1 @@\n-class CompilerDirectivesReplaceDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<char*> _filename;\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n-public:\n-  static int num_arguments() { return 2; }\n-  CompilerDirectivesReplaceDCmd(outputStream* output, bool heap);\n-  static const char* name() {\n-    return \"Compiler.directives_replace\";\n-  }\n-  static const char* description() {\n-    return \"Clear directives stack, and load new compiler directives from file.\";\n-  }\n-  static const char* impact() {\n-    return \"Low\";\n-  }\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", NULL};\n-    return p;\n-  }\n-  virtual void execute(DCmdSource source, TRAPS);\n-};\n-\n-class CompilerDirectivesClearDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+class CompilerDirectivesClearDCmd : public DCmd {\n@@ -791,2 +761,1 @@\n-  static int num_arguments() { return 1; }\n-  CompilerDirectivesClearDCmd(outputStream* output, bool heap);\n+  CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3127,0 +3127,12 @@\n+\n+  if (_oome && num_dump_threads > 1) {\n+    \/\/ Each additional parallel writer requires several MB of internal memory\n+    \/\/ (DumpWriter buffer, DumperClassCacheTable, GZipCompressor buffers).\n+    \/\/ For the OOM handling we may already be limited in memory.\n+    \/\/ Lets ensure we have at least 20MB per thread.\n+    julong max_threads = os::free_memory() \/ (20 * M);\n+    if (num_dump_threads > max_threads) {\n+      num_dump_threads = MAX2<uint>(1, (uint)max_threads);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,2 @@\n-  \/\/ parallel_thread_num >= 0 indicates thread numbers of parallel object dump\n-  int dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, uint parallel_thread_num = 1);\n+  \/\/ parallel_thread_num >= 0 indicates thread numbers of parallel object dump.\n+  int dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, uint parallel_thread_num = default_num_of_dump_threads());\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/services\/mallocLimit.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/services\/mallocLimit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n-#define SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n-\n-\/\/ Provide a (temporary) macro for the [[noreturn]] attribute.\n-\/\/\n-\/\/ Unfortunately, some older (though still in use) compilers have bugs when\n-\/\/ using [[noreturn]].  For them we use an empty definition for the attribute.\n-\/\/\n-\/\/ Note: This can't be placed in globalDefinitions_xxx.hpp because the\n-\/\/ attribute is used in debug.hpp, which can't include globalDefinitions.hpp.\n-\n-\/\/ clang 12 (and possibly prior) crashes during build if we use [[noreturn]]\n-\/\/ for assertion failure reporting functions.  The problem seems to be fixed\n-\/\/ in clang 13.\n-#ifdef __clang__\n-#if __clang_major__ < 13\n-#define ATTRIBUTE_NORETURN\n-#endif\n-#endif\n-\n-\/\/ All other platforms can use [[noreturn]].\n-#ifndef ATTRIBUTE_NORETURN\n-#define ATTRIBUTE_NORETURN [[noreturn]]\n-#endif\n-\n-#endif \/\/ SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n","filename":"src\/hotspot\/share\/utilities\/attributeNoreturn.hpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memflags.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  ChunkedList<T, F>() : _top(_values), _next_used(nullptr), _next_free(nullptr) {}\n+  ChunkedList() : _top(_values), _next_used(nullptr), _next_free(nullptr) {}\n","filename":"src\/hotspot\/share\/utilities\/chunkedList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/attributeNoreturn.hpp\"\n@@ -257,1 +256,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -260,1 +259,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -265,1 +264,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -269,1 +268,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -273,1 +272,1 @@\n-ATTRIBUTE_NORETURN\n+[[noreturn]]\n@@ -278,3 +277,3 @@\n-ATTRIBUTE_NORETURN void report_should_not_call(const char* file, int line);\n-ATTRIBUTE_NORETURN void report_should_not_reach_here(const char* file, int line);\n-ATTRIBUTE_NORETURN void report_unimplemented(const char* file, int line);\n+[[noreturn]] void report_should_not_call(const char* file, int line);\n+[[noreturn]] void report_should_not_reach_here(const char* file, int line);\n+[[noreturn]] void report_unimplemented(const char* file, int line);\n@@ -282,1 +281,1 @@\n-\/\/ NOT ATTRIBUTE_NORETURN\n+\/\/ NOT [[noreturn]]\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  EventLogBase<T>(const char* name, const char* handle, int length = LogEventsBufferEntries):\n+  EventLogBase(const char* name, const char* handle, int length = LogEventsBufferEntries):\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/attributeNoreturn.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include <alloca.h>\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -293,0 +293,1 @@\n+    if (_data == nullptr) return;\n@@ -297,0 +298,1 @@\n+    if (_data == nullptr) return;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,368 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"utilities\/istream.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/xmlstream.hpp\"\n+\n+#ifndef ASSERT\n+#define COV(casen) {}\n+#else \/\/ASSERT\n+\/\/ Support for coverage testing.  Used by the gtest.\n+\/* $ sed < istream.cpp '\/^.* COV(\\([A-Z][^)]*\\)).*$\/!d;s\/\/COV_FN(\\1)\/' |\n+     tr '\\12' ' ' | fold -sw72 | sed 's| $||;s|.*|  & \\\\|'\n+  *\/\n+#define DO_COV_CASES(COV_FN) \\\n+  COV_FN(NXT_L) COV_FN(NXT_N) COV_FN(FIB_P) COV_FN(FIB_E) COV_FN(FIB_N) \\\n+  COV_FN(FIB_L) COV_FN(PFB_C) COV_FN(PFB_P) COV_FN(PFB_A) \\\n+  COV_FN(PFB_G) COV_FN(PFB_H) COV_FN(SBC_C) COV_FN(SBC_B) COV_FN(SBC_N) \\\n+  COV_FN(SBC_L) COV_FN(EXB_R) COV_FN(EXB_A)\n+  \/**\/\n+#define COV_COUNT(casename) coverage_case_##casename\n+#define DECLARE_COV_CASE(casename) static int COV_COUNT(casename);\n+DO_COV_CASES(DECLARE_COV_CASE)\n+#undef DECLARE_COV_CASE\n+\n+static int current_coverage_mode = 0;\n+#define COV(casename) {                                 \\\n+    if (current_coverage_mode != 0) {                   \\\n+      COV_COUNT(casename)++;                            \\\n+    }                                                  }\n+#endif \/\/ASSERT\n+\n+bool inputStream::next() {\n+  \/\/ We have to look at the current line first, just in case nobody\n+  \/\/ actually called current_line() or done().\n+  preload();\n+  if (definitely_done()) {\n+    return false;         \/\/ OK to call this->next() after done is true\n+  }\n+  \/\/ current line is at buffer[beg..end]; now skip past its '\\0'\n+  assert(have_current_line(), \"\");\n+\n+  set_buffer_content(_next, _content_end);\n+  if (!need_to_read()) {  \/\/ any next line was already in the buffer\n+    COV(NXT_L);\n+    assert(have_current_line(), \"\");\n+    return true;\n+  } else {                \/\/ go back to the source for more\n+    COV(NXT_N);\n+    return fill_buffer();\n+  }\n+}\n+\n+void inputStream::set_done() {\n+  size_t end = _beg = _end = _content_end;\n+  _next = end + NEXT_PHANTOM;\n+  _line_ending = 0;\n+  assert(definitely_done(), \"\");\n+}\n+\n+void inputStream::set_error(bool error_condition) {\n+  if (error_condition) {\n+    set_done();\n+    _input_state = IState::ERR_STATE;\n+    assert(error(), \"\");\n+  } else if (error()) {\n+    _input_state = definitely_done() ? IState::EOF_STATE : IState::NTR_STATE;\n+  }\n+}\n+\n+void inputStream::clear_buffer() {\n+  _content_end = _beg = _end = _next = 0;\n+  _line_ending = 0;\n+}\n+\n+const char* inputStream::next_content(size_t& next_content_length) const {\n+  assert(is_sane(), \"\");\n+  size_t len = buffered_content_length(false);\n+  next_content_length = len;\n+  return len == 0 ? \"\" : &_buffer[_next];\n+}\n+\n+void inputStream::set_input(inputStream::Input* input) {\n+  clear_buffer();\n+  _input = input;\n+  _input_state = IState::NTR_STATE;\n+}\n+\n+bool inputStream::fill_buffer() {\n+  size_t fill_offset, fill_length;\n+  assert(!definitely_done(), \"\");  \/\/ caller responsibility\n+  while (need_to_read()) {\n+    prepare_to_fill_buffer(fill_offset, fill_length);\n+    if (error())  return false;\n+    assert(fill_length > 0, \"\");\n+    assert(fill_offset < _buffer_size, \"\");\n+    assert(fill_offset + fill_length <= _buffer_size, \"\");\n+    size_t nr = 0;\n+    if (_input != nullptr && _input_state == IState::NTR_STATE) {\n+      nr = _input->read(&_buffer[fill_offset], fill_length);\n+      if (nr == 0)  _input_state = IState::EOF_STATE;  \/\/ do not get EOF twice\n+    }\n+    bool last_partial = false;\n+    if (nr > 0) {\n+      fill_offset += nr;\n+    } else if (_beg == _end) {  \/\/ no partial line, so end it now\n+      \/\/ we hit the end of the file (or there was never anything there)\n+      COV(FIB_P);\n+      assert(!definitely_done(), \"\");\n+      set_done();\n+      assert(definitely_done(), \"\");\n+      return false;\n+    } else {\n+      \/\/ pretend to read a newline, to complete the last partial line\n+      COV(FIB_E);\n+      _buffer[fill_offset++] = '\\n';  \/\/ insert phantom newline\n+      last_partial = true;\n+    }\n+    set_buffer_content(_beg, fill_offset);\n+    assert(!definitely_done(), \"\");\n+    if (need_to_read()) { COV(FIB_N); }\n+    else                { COV(FIB_L); }\n+    if (last_partial) {\n+      assert(have_current_line(), \"\");\n+      _line_ending = 0;\n+      _content_end -= 1;  \/\/ reverse insertion of phantom newline\n+      assert(_next == _content_end + NEXT_PHANTOM, \"\");\n+      assert(have_current_line(), \"\");\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Find some space in the buffer for reading.  If there is already a\n+\/\/ partial line in the buffer, new space must follow it immediately.\n+\/\/ The partial line is between _beg and _end, and no other parts of\n+\/\/ the buffer are in use.\n+void inputStream::prepare_to_fill_buffer(size_t& fill_offset,\n+                                         size_t& fill_length) {\n+  assert(need_to_read(), \"\");  \/\/ _next pointer out of the way\n+  size_t end = _content_end;\n+  if (_beg == end) { \/\/ if no partial line present...\n+    COV(PFB_C);\n+    clear_buffer();\n+    fill_offset = 0;\n+    fill_length = _buffer_size;\n+    return;   \/\/ use the whole buffer\n+  }\n+  \/\/ at this point we have a pending line that needs more input\n+  if (_beg > 0 && (_input != nullptr || end == _buffer_size)) {\n+    COV(PFB_P);\n+    \/\/ compact the buffer by overwriting characters from previous lines\n+    size_t shift_left = _beg;\n+    ::memmove(_buffer, _buffer + shift_left, _content_end - _beg);\n+    _beg -= shift_left;\n+    _end -= shift_left;\n+    _next -= shift_left;\n+    _content_end -= shift_left;\n+    end = _content_end;\n+  }\n+  if (end < _buffer_size) {\n+    COV(PFB_A);\n+    fill_offset = end;\n+    fill_length = _buffer_size - end;\n+    return;   \/\/ use the whole buffer except partial line at the beginning\n+  }\n+  \/\/ the whole buffer contains a partial line, which means we must expand\n+  COV(PFB_G);\n+  size_t new_size = (_buffer_size < BIG_SIZE ? BIG_SIZE\n+                     : _buffer_size + _buffer_size \/ 2);\n+  assert(new_size > _buffer_size, \"\");\n+  if (expand_buffer(new_size)) {\n+    COV(PFB_H);\n+    fill_offset = end;\n+    fill_length = _buffer_size - end;\n+    return;   \/\/ use the expanded buffer, except the partial line\n+  }\n+  \/\/ no recovery from failed allocation; just set the error state and bail\n+  set_error();\n+}\n+\n+\/\/ The only buffer content is between the given offsets.\n+\/\/ Set _beg, _end, _next, and _content_end appropriately.\n+void inputStream::set_buffer_content(size_t content_start,\n+                                     size_t content_end) {\n+  assert(content_end <= _buffer_size, \"\");\n+  assert(content_start <= content_end + NEXT_PHANTOM, \"\");\n+  if (content_start >= content_end) {   \/\/ empty content; clear buffer\n+    COV(SBC_C);\n+    clear_buffer();\n+    return;\n+  }\n+  COV(SBC_B);\n+  size_t content_len = content_end - content_start;\n+  _beg = content_start;\n+  _content_end = content_end;\n+\n+  \/\/ this is where we scan for newlines\n+  char* nl = (char*) memchr(&_buffer[content_start], '\\n', content_len);\n+  if (nl == nullptr) {\n+    COV(SBC_N);\n+    _next = _end = content_end;\n+    _line_ending = 0;\n+    assert(need_to_read(), \"\");\n+  } else {\n+    COV(SBC_L);\n+    *nl = '\\0';  \/\/ so that this->current_line() will work\n+    ++_line_count;\n+    size_t end = nl - &_buffer[0];\n+    _next = end + 1;\n+    assert(_next != _content_end + NEXT_PHANTOM, \"\");\n+    if (end > content_start && nl[-1] == '\\r') { \/\/ yuck\n+      \/\/ again, for this->current_line(), remove '\\r' before '\\n'\n+      nl[-1] = '\\0';\n+      --end;\n+      \/\/ Note: we could treat '\\r' alone as a line ending on some\n+      \/\/ platforms, but that is way too much work.  Newline '\\n' is\n+      \/\/ supported everywhere, and some tools insist on accompanying\n+      \/\/ it with return as well, so we remove that.  But return '\\r'\n+      \/\/ by itself is an obsolete format, and also inconsistent with\n+      \/\/ outputStream, which standarizes on '\\n' and never emits '\\r'.\n+      \/\/ Postel's law suggests that we write '\\n' only and grudgingly\n+      \/\/ accept '\\r' before '\\n'.\n+    }\n+    _end = end;  \/\/ now this->current_line() points to buf[beg..end]\n+    _line_ending = (int)(_next - end);\n+    assert(have_current_line(), \"\");\n+    assert(current_line() == &_buffer[_beg], \"\");\n+    assert(current_line_length() == _end - _beg, \"\");\n+  }\n+}\n+\n+\/\/ Return true iff we expanded the buffer to the given length.\n+bool inputStream::expand_buffer(size_t new_length) {\n+  assert(new_length > _buffer_size, \"\");\n+  char* new_buf = nullptr;\n+  assert(new_length > sizeof(_small_buffer), \"\");\n+  if (_buffer == &_small_buffer[0]) {\n+    \/\/ fresh alloc from c-heap\n+    COV(EXB_A);\n+    new_buf = NEW_C_HEAP_ARRAY(char, new_length, mtInternal);\n+    assert(new_buf != nullptr, \"would have exited VM if OOM\");\n+    if (_content_end > 0) {\n+      assert(_content_end <= _buffer_size, \"\");\n+      ::memcpy(new_buf, _buffer, _content_end);  \/\/ copy only the active content\n+    }\n+  } else {\n+    \/\/ realloc\n+    COV(EXB_R);\n+    new_buf = REALLOC_C_HEAP_ARRAY(char, _buffer, new_length, mtInternal);\n+    assert(new_buf != nullptr, \"would have exited VM if OOM\");\n+  }\n+\n+  if (new_buf == nullptr) {\n+    return false;   \/\/ do not further update _buffer etc.\n+  }\n+  _buffer = new_buf;\n+  _buffer_size = new_length;\n+  return true;\n+}\n+\n+inputStream::~inputStream() {\n+  if (has_c_heap_buffer()) {\n+    FreeHeap(_buffer);\n+    DEBUG_ONLY(_buffer = (char*)((uintptr_t)0xdeadbeef)); \/\/ sanity\n+  }\n+}\n+\n+#ifdef ASSERT\n+void inputStream::dump(const char* what) {\n+  int diff = (int)(_end - _beg);\n+  if (!_buffer || _beg > _buffer_size || _end > _buffer_size)\n+    diff = 0;\n+\n+  bool ntr = (_next == _end),\n+       hcl = (_beg < _content_end && _end < _next),\n+       ddn = (_beg == _content_end && _next > _content_end);\n+  tty->print_cr(\"%s%sistream %s%s%s%s%s [%d<%.*s>%d\/%d..%d] LE=%d,\"\n+                \" B=%llx%s[%d], LN=%d, CH=%d\",\n+                what ? what : \"\", what ? \": \" : \"\",\n+                _buffer == nullptr ? \"U\" : \"\",\n+                ntr ? \"R\" : \"\",\n+                hcl ? \"L\" : \"\",\n+                ddn ? \"D\" : \"\",\n+                (_next < _content_end ? \"\" :\n+                 _next == _content_end ? \"N\" : \"P\"),\n+                (int)_beg,\n+                diff < 0 ? 0 : diff > 10 ? 10 : diff,\n+                _buffer ? &_buffer[_beg] : \"\",\n+                (int)_end, (int)_next, (int)_content_end,\n+                _line_ending,\n+                (unsigned long long)(intptr_t)_buffer,\n+                _buffer == _small_buffer ? \"(SB)\" : \"\",\n+                (int)_buffer_size,\n+                (int)_line_count,\n+                has_c_heap_buffer());\n+  assert(is_sane(), \"\");\n+}\n+#endif\n+\n+#ifdef ASSERT\n+\/\/ More support for coverage testing.\n+int inputStream::coverage_mode(int start,\n+                               int& cases, int& total, int& zeroes) {\n+  int old_mode = current_coverage_mode;\n+  current_coverage_mode = start;\n+  int num_cases = 0, zero_count = 0, case_count = 0;\n+#define COUNT_COV_CASE(casename) {              \\\n+    int tem = COV_COUNT(casename);              \\\n+    case_count += tem;                          \\\n+    if (tem == 0)  ++zero_count;                \\\n+    num_cases++;                                \\\n+  }\n+  DO_COV_CASES(COUNT_COV_CASE)\n+#undef COUNT_COV_CASE\n+  if (start < 0) {\n+    tty->print(\"istream coverage:\");\n+    #define PRINT_COV_CASE(casename) \\\n+      tty->print(\" %s:%d\", #casename, COV_COUNT(casename));\n+    DO_COV_CASES(PRINT_COV_CASE)\n+    tty->cr();\n+    #undef PRINT_COV_CASE\n+    if (zero_count != 0) {\n+      case_count = -case_count;\n+      #define ZERO_COV_CASE(casename)                  \\\n+        if (COV_COUNT(casename) == 0)                  \\\n+          tty->print_cr(\"%s: no coverage for %s\",      \\\n+                        __FILE__, #casename);          \\\n+      DO_COV_CASES(ZERO_COV_CASE)\n+      #undef ZERO_COV_CASE\n+    }\n+  }\n+  if (start >= 2 || start < 0) {\n+    #define CLEAR_COV_CASE(casename) \\\n+       COV_COUNT(casename) = 0;\n+    DO_COV_CASES(CLEAR_COV_CASE)\n+    #undef CLEAR_COV_CASE\n+  }\n+  cases  = num_cases;\n+  total  = case_count;\n+  zeroes = zero_count;\n+  return old_mode;\n+}\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/utilities\/istream.cpp","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -0,0 +1,386 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ISTREAM_HPP\n+#define SHARE_UTILITIES_ISTREAM_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Input streams for reading line-oriented textual data. These streams\n+\/\/ treat newline '\\n' very differently from all other bytes.  Carriage\n+\/\/ return '\\r' is just another bit of whitespace, although it is\n+\/\/ removed just before newline.\n+\/\/\n+\/\/ Null '\\0' is just a data byte, although it also terminates C\n+\/\/ strings; the `current_line` function adds a null after removing any\n+\/\/ line terminator but does not specially process any nulls embedded\n+\/\/ in the line.\n+\/\/\n+\/\/ There are sizing access functions which allow lines to contain\n+\/\/ null, but the simpler function assumes null termination, and thus\n+\/\/ lines containing null will \"look\" shorter when viewed as C strings.\n+\/\/ Use the sizing access functions if you care about this.\n+\/\/\n+\/\/ Formatting guidelines:\n+\/\/\n+\/\/ Configuration data should be line-oriented.  It should be readable\n+\/\/ by humans (though perhaps with difficulty).  It should be easily\n+\/\/ processed by text editors and by widely available text processing\n+\/\/ tools such as grep, sed, and awk.\n+\/\/\n+\/\/ Configuration data should not require \"compilers\" to generate, if\n+\/\/ possible.  It should be editable by hand, if possible.  In cases\n+\/\/ where binary data is strongly required, pick a binary format\n+\/\/ already native to Hotspot, such as classfile, jar, or jmod.\n+\/\/\n+\/\/ Each line should be separately parseable; the parsing can be ad\n+\/\/ hoc.  For constructs inherently larger than single lines (such as\n+\/\/ complex method configuration information), try to use a structuring\n+\/\/ principle that allows \"leaf\" data to be line-oriented, and delimits\n+\/\/ that data with markup lines of some sort.  Try to pick a\n+\/\/ line-friendly version of a standard format like XML or Markdown.\n+\/\/ JSON is somewhat problematic because there is no line-friendly leaf\n+\/\/ syntax: everything at the leaves must be a quoted string in JSON.\n+\/\/\n+\/\/ Use simple parsing via scanf-like formats for simple applications.\n+\/\/ But, keep in mind that these formats may lose data when applied to\n+\/\/ unusual strings, such as class names that contain spaces, or method\n+\/\/ names that contain punctuation.  For more robust transmission of\n+\/\/ potentially unusual names, consider wrapping them in XML-flavored\n+\/\/ lines like <tag attr='pay load'\/>.\n+\/\/\n+\/\/ Note: Input streams are never MT-safe.\n+\n+class inputStream : public CHeapObjBase {\n+ public:\n+  class Input;\n+\n+ private:\n+  NONCOPYABLE(inputStream);\n+\n+  static constexpr size_t SMALL_SIZE =  240 DEBUG_ONLY(*0 + 10);\n+  static constexpr size_t BIG_SIZE   = 2048 DEBUG_ONLY(*0 + 20);\n+\n+ protected:\n+  \/\/ Values for _input_state, to distinguish some phases of history:\n+  \/\/ Do we need to read more input (NTR)?  Did we see EOF already?\n+  \/\/ Was there an error getting input or allocating buffer space?\n+  enum class IState : int { NTR_STATE, EOF_STATE, ERR_STATE };\n+\n+  \/\/ Named offset for _next relative to _content_end, of phantom '\\n'.\n+  static const int NEXT_PHANTOM = 1;\n+\n+  Input* _input;   \/\/ where the input comes from or else nullptr\n+  IState _input_state;  \/\/ one of {NTR,EOF,ERR}_STATE\n+  char   _line_ending;  \/\/ one of {0,1,2} for \"\", \"\\n\", \"\\r\\n\"\n+  char*  _buffer;       \/\/ scratch buffer holding at least the current line\n+  size_t _buffer_size;  \/\/ allocated size of buffer\n+  size_t _content_end;  \/\/ offset to end of valid contents of buffer\n+  size_t _beg;          \/\/ offset in buffer to start of current line\n+  size_t _end;          \/\/ offset to end of known current line (else content_end)\n+  size_t _next;         \/\/ offset to known start of next line (else =end)\n+  size_t _line_count;   \/\/ increasing non-resettable count of lines read\n+  char   _small_buffer[SMALL_SIZE];  \/\/ stack-allocated buffer for holding lines;\n+                                     \/\/ will switch to C_HEAP allocation when necessary.\n+\n+  bool has_c_heap_buffer() {\n+    return _buffer != &_small_buffer[0];\n+  }\n+\n+  \/\/ Buffer states\n+  \/\/\n+  \/\/ The current line (less any line ending) is always [beg..end).\n+  \/\/ It is always the case that 0 <= beg <= end <= con_end <= buffer_size.\n+  \/\/ When there is a current line buffered, end < next <= 1+con_end.\n+  \/\/ In that case, the value of next is end + max(1, strlen(lend)),\n+  \/\/ where lend is \"\\n\", \"\\r\\n\", or (for a last partial line) \"\".\n+  \/\/ But if next == end, we need to read more input, or observe an EOF.\n+  \/\/\n+  \/\/   beg ==end ==next ==  con_end => nothing buffered, we need to read\n+  \/\/   beg <=end < next <=  con_end => have current line, with terminator\n+  \/\/   beg < end < next ==1+con_end => have partial current line (saw EOF)\n+  \/\/   beg < end ==next ==  con_end => partial line, we need to read\n+  \/\/   beg ==end < next ==1+con_end => definitely done; no more I\/O\n+  \/\/\n+  \/\/ These states are in three mutually exclusive groups:\n+  \/\/   need_to_read()      <= nothing or partial line in buffer\n+  \/\/   have_current_line() <= beg\/end point to valid line (partial only if EOF)\n+  \/\/   definitely_done()   <= consumed all lines && (hit EOF || hit error)\n+  \/\/ These states are internal; the user can only look at next\/done\/error.\n+  \/\/\n+  \/\/ Relative to these states, everything already read from the input\n+  \/\/ before the first byte of the current line is logically present\n+  \/\/ (but not accessible) before _beg, while everything not yet read\n+  \/\/ from the input is after _content_end.  The difference between\n+  \/\/ these two pointers is constant, except when characters change\n+  \/\/ from being in the current line to being (logically) before it,\n+  \/\/ when next is called.\n+\n+  bool is_sane() const {\n+    assert(_buffer != nullptr, \"\");\n+    assert(_content_end <= _buffer_size, \"\");\n+    assert(_beg <= _end && _end <= _content_end, \"\");\n+    assert(_end <= _next && _next <= _content_end + NEXT_PHANTOM, \"\");\n+    assert(_buffer_size == 0 || _next <= _buffer_size, \"\");\n+    return true;\n+  }\n+\n+  bool need_to_read() const {\n+    assert(is_sane(), \"\");\n+    return _next == _end;\n+  }\n+  bool have_current_line() const {\n+    assert(is_sane(), \"\");\n+    \/\/ _beg < _content_end because there is an \\0 (was \\n) at _end,\n+    \/\/ or else it is a non-empty partial line and the \\0 is at\n+    \/\/ _content_end.  In either case, if _end == _next we are\n+    \/\/ still searching for more input.\n+    return (_beg < _content_end && _end < _next);\n+  }\n+  bool definitely_done() const {\n+    assert(is_sane(), \"\");\n+    \/\/ If _beg < _content_end we still have a line of some sort.\n+    \/\/ Otherwise, if _next > _content_end, we have seen EOF or error.\n+    return (_beg == _content_end && _next > _content_end);\n+  }\n+\n+  \/\/ Reset indexes within the buffer to point to no content.\n+  void clear_buffer();\n+\n+  \/\/ Reset indexes within the buffer to point to the given content.\n+  \/\/ This is where we scan for newlines as well.\n+  void set_buffer_content(size_t content_start, size_t content_end);\n+\n+  \/\/ Try to make the buffer bigger.  This may be necessary in order to\n+  \/\/ buffer a very long line.  Returns false if there was an\n+  \/\/ allocation failure.\n+  \/\/\n+  \/\/ On allocation failure, just make do with whatever buffer there\n+  \/\/ was to start with; the caller must check for this condition and\n+  \/\/ avoid buffering more data in the non-expanded buffer.  However,\n+  \/\/ the buffer will always be non-null, so at least one line can be\n+  \/\/ buffered, if it is of normal size.\n+  bool expand_buffer(size_t new_length);\n+\n+  \/\/ Make sure there is at least one line in the buffer, and set\n+  \/\/ _beg\/_end to indicate where it is.  Any content before _beg can\n+  \/\/ be overwritten to make more room in the buffer.  If there is no\n+  \/\/ more input, set the state up to indicate we are done.\n+  bool fill_buffer();\n+\n+  \/\/ Find some room in the buffer so we can call read on it.\n+  \/\/ This might call expand_buffer but will try not to.\n+  \/\/ The assumption is that read already buffers slow I\/O calls.\n+  \/\/ The purpose for the small buffer managed here is to store whole lines,\n+  \/\/ and perhaps edit them in-place.\n+  void prepare_to_fill_buffer(size_t& fill_offset, size_t& fill_length);\n+\n+  \/\/ Quick check for an initially incomplete buffer...\n+  void preload() const {\n+    if (need_to_read()) {\n+      const_cast<inputStream*>(this)->fill_buffer();\n+    }\n+  }\n+\n+  \/\/ How much content is buffered (if any) after the current line?\n+  size_t buffered_content_length(bool include_current) const {\n+    return (include_current       ? _content_end - _beg :\n+            _content_end >= _next ? _content_end - _next : 0);\n+  }\n+\n+  \/\/ Returns a pointer and count to characters buffered after the\n+  \/\/ current line, but not yet read from my input source.  Only useful\n+  \/\/ if you are trying to stack input streams on top of each other\n+  \/\/ somehow.  You can also ask the input source if it thinks it has\n+  \/\/ more bytes.\n+  const char* next_content(size_t& next_content_length) const;\n+\n+ public:\n+  \/\/ Create an empty input stream.\n+  \/\/ Call push_back_input or set_input to configure.\n+  inputStream() :\n+    _input(nullptr),\n+    _input_state(IState::NTR_STATE),\n+    _line_ending(0),\n+    _buffer(&_small_buffer[0]),\n+    _buffer_size(sizeof(_small_buffer)),\n+    _content_end(0),\n+    _beg(0),\n+    _end(0),\n+    _next(0),\n+    _line_count(0) {}\n+\n+  \/\/ Take input from the given source.  Buffer only a modest amount.\n+  inputStream(Input* input)\n+    : inputStream()\n+  {\n+    set_input(input);\n+  }\n+\n+  virtual ~inputStream();\n+\n+  \/\/ Discards any previous input and sets the given input source.\n+  void set_input(Input* input);\n+\n+  \/\/ Returns a pointer to a null terminated mutable copy of the current line.\n+  \/\/ Note that embedded nulls may make the line appear shorter than it really is.\n+  \/\/ This may trigger input activity if there is not enough data buffered.\n+  \/\/ If there are no more lines, return an empty line, statically allocated.\n+  char* current_line() const {\n+    preload();\n+    if (definitely_done())\n+      return (char*)\"\";\n+    return &_buffer[_beg];\n+  }\n+\n+  \/\/ Return the size of the current line, exclusive of any line terminator.\n+  \/\/ If no lines have been read yet, or there are none remaining, return zero.\n+  size_t current_line_length() const {\n+    preload();\n+    return _end - _beg;\n+  }\n+\n+  \/\/ Reports my current input source, if any, else a null pointer.\n+  Input* input() const { return _input; }\n+\n+  \/\/ Discards the current line, gets ready to report the next line.\n+  \/\/ Returns true if there is one, which is always the opposite of done().\n+  \/\/ Fetches input if necessary.\n+  bool next();\n+\n+  \/\/ Reports if there are no more lines.  Fetches input if necessary.\n+  bool done() const  {\n+    preload();\n+    return definitely_done();\n+  }\n+\n+  \/\/ Discard pending input and do not read any more.\n+  \/\/ Takes no action if already done, whether in an error state or not.\n+  void set_done();\n+\n+  \/\/ Reports if this stream has had an error was reported on it.\n+  bool error() const {\n+    return _input_state == IState::ERR_STATE;\n+  }\n+\n+  \/\/ Set this stream done with an error, if the argument is true.\n+  \/\/ If it is false but there is an error condition, clear the error.\n+  \/\/ Otherwise do nothing.\n+  void set_error(bool error_condition = true);\n+\n+  \/\/ lineno is the 1-based ordinal of the current line; it starts at one\n+  size_t lineno() const         { preload(); return _line_count; }\n+\n+  \/\/ Copy the current line to the given output stream.\n+  void print_on(outputStream* out);\n+\n+  \/\/ Copy the current line to the given output stream, and also call cr().\n+  void print_cr_on(outputStream* out) {\n+    print_on(out); out->cr();\n+  }\n+\n+#ifdef ASSERT\n+  void dump(const char* what = nullptr);\n+  static int coverage_mode(int mode, int& cases, int& total, int& zeroes);\n+#else\n+  void dump(const char* what = nullptr) { }\n+#endif\n+\n+\n+  \/\/ Block-oriented input, which treats all bytes equally.\n+  class Input : public CHeapObjBase {\n+  public:\n+    \/\/ Read some characters from an external source into the line buffer.\n+    \/\/ If there are no more, return zero, otherwise return non-zero.\n+    \/\/ It must be OK to call read even after it returns zero.\n+    virtual size_t read(char* buf, size_t size) = 0;\n+    \/\/ Example: read(b,s) { return fread(b, 1, s, _my_fp); }\n+    \/\/ Example: read(b,s) { return 0; } \/\/ never more than the initial buffer\n+  };\n+};\n+\n+\/\/ for reading lines from files\n+class FileInput : public inputStream::Input {\n+  NONCOPYABLE(FileInput);\n+\n+ protected:\n+  fileStream& _fs;\n+  fileStream _private_fs;\n+\n+  \/\/ it does not seem likely there are such file streams around\n+  FileInput(fileStream& fs)\n+    : _fs(fs)\n+  { }\n+\n+ public:\n+  \/\/ just forward all the constructor arguments to the wrapped line-input class\n+  template<typename... Arg>\n+  FileInput(Arg... arg)\n+    : _fs(_private_fs), _private_fs(arg...)\n+  { }\n+\n+  FileInput(const char* file_name)\n+    : FileInput(file_name, \"rt\")\n+  { }\n+\n+  bool is_open() const { return _fs.is_open(); }\n+\n+ protected:\n+  size_t read(char* buf, size_t size) override {\n+    return _fs.read(buf, size);\n+  }\n+};\n+\n+class MemoryInput : public inputStream::Input {\n+  const void* _base;\n+  const size_t _limit;\n+  size_t      _offset;\n+\n+ public:\n+  MemoryInput(const void* base, size_t size,\n+              size_t offset = 0)\n+    : _base(base), _limit(size), _offset(offset) {}\n+\n+  MemoryInput(const char* start)\n+    : MemoryInput(start, 0, strlen(start))\n+  { }\n+\n+ protected:\n+  size_t read(char* buf, size_t size) override {\n+    size_t nr = size;\n+    if (nr > _limit - _offset) {\n+      nr = _limit - _offset;\n+    }\n+    if (nr > 0) {\n+      ::memcpy(buf, (char*)_base + _offset, nr);\n+      _offset += nr;\n+    }\n+    return nr;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_ISTREAM_HPP\n","filename":"src\/hotspot\/share\/utilities\/istream.hpp","additions":386,"deletions":0,"binary":false,"changes":386,"status":"added"},{"patch":"@@ -85,1 +85,1 @@\n-  NONCOPYABLE(LinkedList<E>);\n+  NONCOPYABLE(LinkedList);\n","filename":"src\/hotspot\/share\/utilities\/linkedlist.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-  copy[_written] = 0;  \/\/ terminating null\n+  copy[_written] = '\\0';  \/\/ terminating null\n@@ -593,13 +593,0 @@\n-char* fileStream::readln(char *data, int count ) {\n-  char * ret = nullptr;\n-  if (_file != nullptr) {\n-    ret = ::fgets(data, count, _file);\n-    \/\/ Get rid of annoying \\n char only if it is present.\n-    size_t len = ::strlen(data);\n-    if (len > 0 && data[len - 1] == '\\n') {\n-      data[len - 1] = '\\0';\n-    }\n-  }\n-  return ret;\n-}\n-\n@@ -608,2 +595,2 @@\n-    if (_need_close) fclose(_file);\n-    _file      = nullptr;\n+    close();\n+    _file = nullptr;\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,3 +245,13 @@\n-  size_t read(void *data, size_t size, size_t count) { return _file != nullptr ? ::fread(data, size, count, _file) : 0; }\n-  char* readln(char *data, int count);\n-  int eof() { return _file != nullptr ? feof(_file) : -1; }\n+  \/\/ unlike other classes in this file, fileStream can perform input as well as output\n+  size_t read(void* data, size_t size) {\n+    if (_file == nullptr)  return 0;\n+    return ::fread(data, 1, size, _file);\n+  }\n+  size_t read(void *data, size_t size, size_t count) {\n+    return read(data, size * count);\n+  }\n+  void close() {\n+    if (_file == nullptr || !_need_close)  return;\n+    fclose(_file);\n+    _need_close = false;\n+  }\n@@ -249,1 +259,0 @@\n-  void rewind() { if (_file != nullptr) ::rewind(_file); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -172,1 +172,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -177,1 +177,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -183,1 +183,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -187,1 +187,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n@@ -192,1 +192,1 @@\n-  ATTRIBUTE_NORETURN\n+  [[noreturn]]\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+ * Operations that format strings are locale sensitive, using either the\n+ * specified {@code Locale}, or the\n+ * {@link Locale##default_locale default format Locale} to produce localized\n+ * formatted strings.\n+ * <p>\n@@ -150,1 +155,37 @@\n-     * the specified format string and arguments.\n+     * the specified format string and arguments with the\n+     * {@link Locale##default_locale default format locale}.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section\n+     *          of the formatter class specification.\n+     *\n+     * @return  This console\n+     *\/\n+    public Console format(String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Writes a formatted string to this console's output stream using\n+     * the specified format string and arguments with the specified\n+     * {@code locale}.\n@@ -152,3 +193,7 @@\n-     * @param  fmt\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>.\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n@@ -163,3 +208,3 @@\n-     *         The behaviour on a\n-     *         {@code null} argument depends on the <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">conversion<\/a>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -172,2 +217,2 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a> section\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section\n@@ -177,0 +222,1 @@\n+     * @since   23\n@@ -178,1 +224,1 @@\n-    public Console format(String fmt, Object ...args) {\n+    public Console format(Locale locale, String format, Object ... args) {\n@@ -184,1 +230,2 @@\n-     * output stream using the specified format string and arguments.\n+     * output stream using the specified format string and arguments with\n+     * the {@link Locale##default_locale default format locale}.\n@@ -186,6 +233,1 @@\n-     * <p> An invocation of this method of the form\n-     * {@code con.printf(format, args)} behaves in exactly the same way\n-     * as the invocation of\n-     * {@snippet lang=java :\n-     *     con.format(format, args)\n-     * }\n+     * @implSpec This is the same as calling {@code format(format, args)}.\n@@ -194,2 +236,2 @@\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>.\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n@@ -204,3 +246,3 @@\n-     *         The behaviour on a\n-     *         {@code null} argument depends on the <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">conversion<\/a>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -213,2 +255,2 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a> section of the\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n@@ -224,2 +266,46 @@\n-     * Provides a formatted prompt, then reads a single line of text from the\n-     * console.\n+     * A convenience method to write a formatted string to this console's\n+     * output stream using the specified format string and arguments with\n+     * the specified {@code locale}.\n+     *\n+     * @implSpec This is the same as calling\n+     *         {@code format(locale, format, args)}.\n+     *\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n+     *\n+     * @return  This console\n+     * @since   23\n+     *\/\n+    public Console printf(Locale locale, String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Provides a formatted prompt using the\n+     * {@link Locale##default_locale default format locale}, then reads a\n+     * single line of text from the console.\n@@ -227,3 +313,3 @@\n-     * @param  fmt\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>.\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n@@ -234,1 +320,2 @@\n-     *         extra arguments are ignored.  The maximum number of arguments is\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n@@ -237,0 +324,3 @@\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -243,3 +333,3 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a> section\n-     *          of the formatter class specification.\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n@@ -254,1 +344,45 @@\n-    public String readLine(String fmt, Object ... args) {\n+    public String readLine(String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Provides a formatted prompt using the specified {@code locale}, then\n+     * reads a single line of text from the console.\n+     *\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n+     *\n+     * @throws IOError\n+     *         If an I\/O error occurs.\n+     *\n+     * @return  A string containing the line read from the console, not\n+     *          including any line-termination characters, or {@code null}\n+     *          if an end of stream has been reached.\n+     * @since   23\n+     *\/\n+    public String readLine(Locale locale, String format, Object ... args) {\n@@ -273,2 +407,3 @@\n-     * Provides a formatted prompt, then reads a password or passphrase from\n-     * the console with echoing disabled.\n+     * Provides a formatted prompt using the\n+     * {@link Locale##default_locale default format locale}, then reads a\n+     * password or passphrase from the console with echoing disabled.\n@@ -276,3 +411,3 @@\n-     * @param  fmt\n-     *         A format string as described in <a\n-     *         href=\"..\/util\/Formatter.html#syntax\">Format string syntax<\/a>\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}\n@@ -284,1 +419,2 @@\n-     *         extra arguments are ignored.  The maximum number of arguments is\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n@@ -287,0 +423,3 @@\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n@@ -293,3 +432,47 @@\n-     *          formatting errors, see the <a\n-     *          href=\"..\/util\/Formatter.html#detail\">Details<\/a>\n-     *          section of the formatter class specification.\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n+     *\n+     * @throws IOError\n+     *         If an I\/O error occurs.\n+     *\n+     * @return  A character array containing the password or passphrase read\n+     *          from the console, not including any line-termination characters,\n+     *          or {@code null} if an end of stream has been reached.\n+     *\/\n+    public char[] readPassword(String format, Object ... args) {\n+        throw newUnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Provides a formatted prompt using the specified {@code locale}, then\n+     * reads a password or passphrase from the console with echoing disabled.\n+     *\n+     * @param  locale The {@linkplain Locale locale} to apply during\n+     *         formatting.  If {@code locale} is {@code null} then no localization\n+     *         is applied.\n+     *\n+     * @param  format\n+     *         A format string as described in {@link\n+     *         Formatter##syntax Format string syntax}\n+     *         for the prompt text.\n+     *\n+     * @param  args\n+     *         Arguments referenced by the format specifiers in the format\n+     *         string.  If there are more arguments than format specifiers, the\n+     *         extra arguments are ignored.  The number of arguments is\n+     *         variable and may be zero.  The maximum number of arguments is\n+     *         limited by the maximum dimension of a Java array as defined by\n+     *         <cite>The Java Virtual Machine Specification<\/cite>.\n+     *         The behavior on a\n+     *         {@code null} argument depends on the {@link\n+     *         Formatter##syntax conversion}.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format string contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          insufficient arguments given the format string, or other\n+     *          illegal conditions.  For specification of all possible\n+     *          formatting errors, see the {@link\n+     *          Formatter##detail Details} section of the\n+     *          formatter class specification.\n@@ -303,0 +486,1 @@\n+     * @since   23\n@@ -304,1 +488,1 @@\n-    public char[] readPassword(String fmt, Object ... args) {\n+    public char[] readPassword(Locale locale, String format, Object ... args) {\n@@ -409,1 +593,2 @@\n-             * name of the implementation, and which defaults to \"java.base\". If no\n+             * name of the implementation, and which defaults to the value of\n+             * {@code JdkConsoleProvider.DEFAULT_PROVIDER_MODULE_NAME}. If no\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":230,"deletions":45,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -2388,1 +2388,7 @@\n-    \/** Reads a record. *\/\n+    \/**\n+     * Reads and returns a record.\n+     * If an exception is marked for any of the fields, the dependency\n+     * mechanism marks the record as having an exception.\n+     * Null is returned from readRecord and later the exception is thrown at\n+     * the exit of {@link #readObject(Class)}.\n+     **\/\n@@ -2401,0 +2407,3 @@\n+        if (handles.lookupException(passHandle) != null) {\n+            return null;     \/\/ slot marked with exception, don't create record\n+        }\n@@ -2494,2 +2503,5 @@\n-                        values.defaultCheckFieldValues(obj);\n-                        values.defaultSetFieldValues(obj);\n+                        if (handles.lookupException(passHandle) == null) {\n+                            \/\/ passHandle NOT marked with an exception; set field values\n+                            values.defaultCheckFieldValues(obj);\n+                            values.defaultSetFieldValues(obj);\n+                        }\n@@ -2514,1 +2526,2 @@\n-        if (obj != null && slotValues != null) {\n+        if (obj != null && slotValues != null && handles.lookupException(passHandle) == null) {\n+            \/\/ passHandle NOT marked with an exception\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Locale;\n+\n@@ -86,1 +88,9 @@\n-    public Console format(String fmt, Object ... args) {\n+    public Console format(String format, Object ... args) {\n+        return format(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console format(Locale locale, String format, Object ... args) {\n@@ -88,1 +98,1 @@\n-            delegate.format(fmt, args);\n+            delegate.format(locale, format, args);\n@@ -98,0 +108,8 @@\n+        return printf(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public Console printf(Locale locale, String format, Object ... args) {\n@@ -99,1 +117,1 @@\n-            delegate.printf(format, args);\n+            delegate.format(locale, format, args);\n@@ -108,1 +126,9 @@\n-    public String readLine(String fmt, Object ... args) {\n+    public String readLine(String format, Object ... args) {\n+        return readLine(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String readLine(Locale locale, String format, Object ... args) {\n@@ -111,1 +137,1 @@\n-                return delegate.readLine(fmt, args);\n+                return delegate.readLine(locale, format, args);\n@@ -130,1 +156,9 @@\n-    public char[] readPassword(String fmt, Object ... args) {\n+    public char[] readPassword(String format, Object ... args) {\n+        return readPassword(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public char[] readPassword(Locale locale, String format, Object ... args) {\n@@ -133,1 +167,1 @@\n-                return delegate.readPassword(fmt, args);\n+                return delegate.readPassword(locale, format, args);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ProxyingConsole.java","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -195,2 +195,3 @@\n-    \/\/ Holder for the initial value of `in`, set within `initPhase1()`.\n-    private static InputStream initialIn;\n+    \/\/ Initial values of System.in and System.err, set in initPhase1().\n+    private static @Stable InputStream initialIn;\n+    private static @Stable PrintStream initialErr;\n@@ -359,3 +360,0 @@\n-    \/\/ Remember initial System.err. setSecurityManager() warning goes here\n-    private static volatile @Stable PrintStream initialErrStream;\n-\n@@ -421,1 +419,1 @@\n-                initialErrStream.printf(\"\"\"\n+                initialErr.printf(\"\"\"\n@@ -2204,1 +2202,2 @@\n-        setErr0(newPrintStream(fdErr, props.getProperty(\"stderr.encoding\")));\n+        initialErr = newPrintStream(fdErr, props.getProperty(\"stderr.encoding\"));\n+        setErr0(initialErr);\n@@ -2410,2 +2409,0 @@\n-        initialErrStream = System.err;\n-\n@@ -2602,0 +2599,4 @@\n+            public PrintStream initialSystemErr() {\n+                return initialErr;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -195,5 +194,0 @@\n-    \/**\n-     * {@return a {@link java.nio.ByteBuffer ByteBuffer} view of the bytes in the buffer}\n-     *\/\n-    ByteBuffer asByteBuffer();\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/BufWriter.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+     * @since 23\n@@ -68,0 +69,1 @@\n+     * @since 23\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,2 +215,1 @@\n-        labelBinding(breakLabel);\n-        return this;\n+        return labelBinding(breakLabel);\n@@ -256,1 +255,1 @@\n-        branchInstruction(BytecodeHelpers.reverseBranchOpcode(opcode), thenBlock.endLabel());\n+        branch(BytecodeHelpers.reverseBranchOpcode(opcode), thenBlock.endLabel());\n@@ -260,2 +259,1 @@\n-        labelBinding(breakLabel);\n-        return this;\n+        return labelBinding(breakLabel);\n@@ -308,1 +306,1 @@\n-        branchInstruction(BytecodeHelpers.reverseBranchOpcode(opcode), elseBlock.startLabel());\n+        branch(BytecodeHelpers.reverseBranchOpcode(opcode), elseBlock.startLabel());\n@@ -312,1 +310,1 @@\n-            thenBlock.branchInstruction(Opcode.GOTO, thenBlock.breakLabel());\n+            thenBlock.branch(Opcode.GOTO, thenBlock.breakLabel());\n@@ -317,2 +315,1 @@\n-        labelBinding(breakLabel);\n-        return this;\n+        return labelBinding(breakLabel);\n@@ -419,0 +416,1 @@\n+     * @since 23\n@@ -420,3 +418,2 @@\n-    default CodeBuilder loadInstruction(TypeKind tk, int slot) {\n-        with(LoadInstruction.of(tk, slot));\n-        return this;\n+    default CodeBuilder loadLocal(TypeKind tk, int slot) {\n+        return with(LoadInstruction.of(tk, slot));\n@@ -430,0 +427,1 @@\n+     * @since 23\n@@ -431,14 +429,2 @@\n-    default CodeBuilder storeInstruction(TypeKind tk, int slot) {\n-        with(StoreInstruction.of(tk, slot));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to increment a local variable by a constant\n-     * @param slot the local variable slot\n-     * @param val the increment value\n-     * @return this builder\n-     *\/\n-    default CodeBuilder incrementInstruction(int slot, int val) {\n-        with(IncrementInstruction.of(slot, val));\n-        return this;\n+    default CodeBuilder storeLocal(TypeKind tk, int slot) {\n+        return with(StoreInstruction.of(tk, slot));\n@@ -453,0 +439,1 @@\n+     * @since 23\n@@ -454,27 +441,2 @@\n-    default CodeBuilder branchInstruction(Opcode op, Label target) {\n-        with(BranchInstruction.of(op, target));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to access a jump table by key match and jump\n-     * @param defaultTarget the default jump target\n-     * @param cases the switch cases\n-     * @return this builder\n-     *\/\n-    default CodeBuilder lookupSwitchInstruction(Label defaultTarget, List<SwitchCase> cases) {\n-        with(LookupSwitchInstruction.of(defaultTarget, cases));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to access a jump table by index and jump\n-     * @param lowValue the low key value\n-     * @param highValue the high key value\n-     * @param defaultTarget the default jump target\n-     * @param cases the switch cases\n-     * @return this builder\n-     *\/\n-    default CodeBuilder tableSwitchInstruction(int lowValue, int highValue, Label defaultTarget, List<SwitchCase> cases) {\n-        with(TableSwitchInstruction.of(lowValue, highValue, defaultTarget, cases));\n-        return this;\n+    default CodeBuilder branch(Opcode op, Label target) {\n+        return with(BranchInstruction.of(op, target));\n@@ -487,0 +449,1 @@\n+     * @since 23\n@@ -488,12 +451,2 @@\n-    default CodeBuilder returnInstruction(TypeKind tk) {\n-        with(ReturnInstruction.of(tk));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to throw an exception or error\n-     * @return this builder\n-     *\/\n-    default CodeBuilder throwInstruction() {\n-        with(ThrowInstruction.of());\n-        return this;\n+    default CodeBuilder return_(TypeKind tk) {\n+        return with(ReturnInstruction.of(tk));\n@@ -508,0 +461,1 @@\n+     * @since 23\n@@ -509,3 +463,2 @@\n-    default CodeBuilder fieldInstruction(Opcode opcode, FieldRefEntry ref) {\n-        with(FieldInstruction.of(opcode, ref));\n-        return this;\n+    default CodeBuilder fieldAccess(Opcode opcode, FieldRefEntry ref) {\n+        return with(FieldInstruction.of(opcode, ref));\n@@ -522,0 +475,1 @@\n+     * @since 23\n@@ -523,2 +477,2 @@\n-    default CodeBuilder fieldInstruction(Opcode opcode, ClassDesc owner, String name, ClassDesc type) {\n-        return fieldInstruction(opcode, constantPool().fieldRefEntry(owner, name, type));\n+    default CodeBuilder fieldAccess(Opcode opcode, ClassDesc owner, String name, ClassDesc type) {\n+        return fieldAccess(opcode, constantPool().fieldRefEntry(owner, name, type));\n@@ -533,0 +487,1 @@\n+     * @since 23\n@@ -534,1 +489,1 @@\n-    default CodeBuilder invokeInstruction(Opcode opcode, MemberRefEntry ref) {\n+    default CodeBuilder invoke(Opcode opcode, MemberRefEntry ref) {\n@@ -547,0 +502,1 @@\n+     * @since 23\n@@ -548,2 +504,2 @@\n-    default CodeBuilder invokeInstruction(Opcode opcode, ClassDesc owner, String name, MethodTypeDesc desc, boolean isInterface) {\n-        return invokeInstruction(opcode,\n+    default CodeBuilder invoke(Opcode opcode, ClassDesc owner, String name, MethodTypeDesc desc, boolean isInterface) {\n+        return invoke(opcode,\n@@ -554,101 +510,0 @@\n-    \/**\n-     * Generate an instruction to invoke a dynamically-computed call site\n-     * @param ref the dynamic call site\n-     * @return this builder\n-     *\/\n-    default CodeBuilder invokeDynamicInstruction(InvokeDynamicEntry ref) {\n-        with(InvokeDynamicInstruction.of(ref));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to invoke a dynamically-computed call site\n-     * @param desc the dynamic call site\n-     * @return this builder\n-     *\/\n-    default CodeBuilder invokeDynamicInstruction(DynamicCallSiteDesc desc) {\n-        MethodHandleEntry bsMethod = handleDescToHandleInfo(constantPool(), (DirectMethodHandleDesc) desc.bootstrapMethod());\n-        var cpArgs = desc.bootstrapArgs();\n-        List<LoadableConstantEntry> bsArguments = new ArrayList<>(cpArgs.length);\n-        for (var constantValue : cpArgs) {\n-            bsArguments.add(BytecodeHelpers.constantEntry(constantPool(), constantValue));\n-        }\n-        BootstrapMethodEntry bm = constantPool().bsmEntry(bsMethod, bsArguments);\n-        NameAndTypeEntry nameAndType = constantPool().nameAndTypeEntry(desc.invocationName(), desc.invocationType());\n-        invokeDynamicInstruction(constantPool().invokeDynamicEntry(bm, nameAndType));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to create a new object\n-     * @param type the object type\n-     * @return this builder\n-     *\/\n-    default CodeBuilder newObjectInstruction(ClassEntry type) {\n-        with(NewObjectInstruction.of(type));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to create a new object\n-     * @param type the object type\n-     * @return this builder\n-     * @throws IllegalArgumentException if {@code type} represents a primitive type\n-     *\/\n-    default CodeBuilder newObjectInstruction(ClassDesc type) {\n-        return newObjectInstruction(constantPool().classEntry(type));\n-    }\n-\n-    \/**\n-     * Generate an instruction to create a new array of a primitive type\n-     * @param typeKind the primitive component type\n-     * @return this builder\n-     *\/\n-    default CodeBuilder newPrimitiveArrayInstruction(TypeKind typeKind) {\n-        with(NewPrimitiveArrayInstruction.of(typeKind));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to create a new array of reference\n-     * @param type the component type\n-     * @return this builder\n-     *\/\n-    default CodeBuilder newReferenceArrayInstruction(ClassEntry type) {\n-        with(NewReferenceArrayInstruction.of(type));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to create a new array of reference\n-     * @param type the component type\n-     * @return this builder\n-     * @throws IllegalArgumentException if {@code type} represents a primitive type\n-     *\/\n-    default CodeBuilder newReferenceArrayInstruction(ClassDesc type) {\n-        return newReferenceArrayInstruction(constantPool().classEntry(type));\n-    }\n-\n-    \/**\n-     * Generate an instruction to create a new multidimensional array\n-     * @param dimensions the number of dimensions\n-     * @param type the array type\n-     * @return this builder\n-     *\/\n-    default CodeBuilder newMultidimensionalArrayInstruction(int dimensions,\n-                                                            ClassEntry type) {\n-        with(NewMultiArrayInstruction.of(type, dimensions));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an instruction to create a new multidimensional array\n-     * @param dimensions the number of dimensions\n-     * @param type the array type\n-     * @return this builder\n-     *\/\n-    default CodeBuilder newMultidimensionalArrayInstruction(int dimensions,\n-                                                            ClassDesc type) {\n-        return newMultidimensionalArrayInstruction(dimensions, constantPool().classEntry(type));\n-    }\n-\n@@ -659,0 +514,1 @@\n+     * @since 23\n@@ -660,1 +516,1 @@\n-    default CodeBuilder arrayLoadInstruction(TypeKind tk) {\n+    default CodeBuilder arrayLoad(TypeKind tk) {\n@@ -662,2 +518,1 @@\n-        with(ArrayLoadInstruction.of(opcode));\n-        return this;\n+        return with(ArrayLoadInstruction.of(opcode));\n@@ -670,0 +525,1 @@\n+     * @since 23\n@@ -671,1 +527,1 @@\n-    default CodeBuilder arrayStoreInstruction(TypeKind tk) {\n+    default CodeBuilder arrayStore(TypeKind tk) {\n@@ -673,26 +529,1 @@\n-        with(ArrayStoreInstruction.of(opcode));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate a type checking instruction\n-     * @see Opcode.Kind#TYPE_CHECK\n-     * @param opcode the type check instruction opcode\n-     * @param type the type\n-     * @return this builder\n-     *\/\n-    default CodeBuilder typeCheckInstruction(Opcode opcode,\n-                                             ClassEntry type) {\n-        with(TypeCheckInstruction.of(opcode, type));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate a type checking instruction\n-     * @see Opcode.Kind#TYPE_CHECK\n-     * @param opcode the type check instruction opcode\n-     * @param type the type\n-     * @return this builder\n-     *\/\n-    default CodeBuilder typeCheckInstruction(Opcode opcode, ClassDesc type) {\n-        return typeCheckInstruction(opcode, constantPool().classEntry(type));\n+        return with(ArrayStoreInstruction.of(opcode));\n@@ -702,1 +533,1 @@\n-     * Generate a type converting instruction\n+     * Generate instruction(s) to convert {@code fromType} to {@code toType}\n@@ -706,26 +537,60 @@\n-     *\/\n-    default CodeBuilder convertInstruction(TypeKind fromType, TypeKind toType) {\n-        with(ConvertInstruction.of(fromType, toType));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate a stack manipulating instruction\n-     * @param opcode the stack instruction opcode\n-     * @see Opcode.Kind#STACK\n-     * @return this builder\n-     *\/\n-    default CodeBuilder stackInstruction(Opcode opcode) {\n-        with(StackInstruction.of(opcode));\n-        return this;\n-    }\n-\n-    \/**\n-     * Generate an operator instruction\n-     * @see Opcode.Kind#OPERATOR\n-     * @param opcode the operator instruction opcode\n-     * @return this builder\n-     *\/\n-    default CodeBuilder operatorInstruction(Opcode opcode) {\n-        with(OperatorInstruction.of(opcode));\n-        return this;\n+     * @throws IllegalArgumentException for conversions of {@code VoidType} or {@code ReferenceType}\n+     * @since 23\n+     *\/\n+    default CodeBuilder conversion(TypeKind fromType, TypeKind toType) {\n+        return switch (fromType) {\n+            case IntType, ByteType, CharType, ShortType, BooleanType ->\n+                    switch (toType) {\n+                        case IntType -> this;\n+                        case LongType -> i2l();\n+                        case DoubleType -> i2d();\n+                        case FloatType -> i2f();\n+                        case ByteType -> i2b();\n+                        case CharType -> i2c();\n+                        case ShortType -> i2s();\n+                        case BooleanType -> iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case LongType ->\n+                    switch (toType) {\n+                        case IntType -> l2i();\n+                        case LongType -> this;\n+                        case DoubleType -> l2d();\n+                        case FloatType -> l2f();\n+                        case ByteType -> l2i().i2b();\n+                        case CharType -> l2i().i2c();\n+                        case ShortType -> l2i().i2s();\n+                        case BooleanType -> l2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case DoubleType ->\n+                    switch (toType) {\n+                        case IntType -> d2i();\n+                        case LongType -> d2l();\n+                        case DoubleType -> this;\n+                        case FloatType -> d2f();\n+                        case ByteType -> d2i().i2b();\n+                        case CharType -> d2i().i2c();\n+                        case ShortType -> d2i().i2s();\n+                        case BooleanType -> d2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case FloatType ->\n+                    switch (toType) {\n+                        case IntType -> f2i();\n+                        case LongType -> f2l();\n+                        case DoubleType -> f2d();\n+                        case FloatType -> this;\n+                        case ByteType -> f2i().i2b();\n+                        case CharType -> f2i().i2c();\n+                        case ShortType -> f2i().i2s();\n+                        case BooleanType -> f2i().iconst_1().iand();\n+                        case VoidType, ReferenceType ->\n+                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+                    };\n+            case VoidType, ReferenceType ->\n+                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n+        };\n@@ -740,0 +605,1 @@\n+     * @since 23\n@@ -741,1 +607,1 @@\n-    default CodeBuilder constantInstruction(Opcode opcode, ConstantDesc value) {\n+    default CodeBuilder loadConstant(Opcode opcode, ConstantDesc value) {\n@@ -754,0 +620,1 @@\n+     * @since 23\n@@ -755,1 +622,1 @@\n-    default CodeBuilder constantInstruction(ConstantDesc value) {\n+    default CodeBuilder loadConstant(ConstantDesc value) {\n@@ -788,20 +655,0 @@\n-    \/**\n-     * Generate a monitor instruction\n-     * @see Opcode.Kind#MONITOR\n-     * @param opcode the monitor instruction opcode\n-     * @return this builder\n-     *\/\n-    default CodeBuilder monitorInstruction(Opcode opcode) {\n-        with(MonitorInstruction.of(opcode));\n-        return null;\n-    }\n-\n-    \/**\n-     * Generate a do nothing instruction\n-     * @return this builder\n-     *\/\n-    default CodeBuilder nopInstruction() {\n-        with(NopInstruction.of());\n-        return this;\n-    }\n-\n@@ -813,1 +660,1 @@\n-        return nopInstruction();\n+        return with(NopInstruction.of());\n@@ -834,2 +681,1 @@\n-        with((LabelImpl) label);\n-        return this;\n+        return with((LabelImpl) label);\n@@ -844,2 +690,1 @@\n-        with(LineNumber.of(line));\n-        return this;\n+        return with(LineNumber.of(line));\n@@ -857,2 +702,1 @@\n-        with(ExceptionCatch.of(handler, start, end, Optional.of(catchType)));\n-        return this;\n+        return with(ExceptionCatch.of(handler, start, end, Optional.of(catchType)));\n@@ -870,2 +714,1 @@\n-        with(ExceptionCatch.of(handler, start, end, catchType));\n-        return this;\n+        return with(ExceptionCatch.of(handler, start, end, catchType));\n@@ -895,2 +738,1 @@\n-        with(ExceptionCatch.of(handler, start, end));\n-        return this;\n+        return with(ExceptionCatch.of(handler, start, end));\n@@ -909,2 +751,1 @@\n-        with(CharacterRange.of(startScope, endScope, characterRangeStart, characterRangeEnd, flags));\n-        return this;\n+        return with(CharacterRange.of(startScope, endScope, characterRangeStart, characterRangeEnd, flags));\n@@ -923,2 +764,1 @@\n-        with(LocalVariable.of(slot, nameEntry, descriptorEntry, startScope, endScope));\n-        return this;\n+        return with(LocalVariable.of(slot, nameEntry, descriptorEntry, startScope, endScope));\n@@ -953,2 +793,1 @@\n-        with(LocalVariableType.of(slot, nameEntry, signatureEntry, startScope, endScope));\n-        return this;\n+        return with(LocalVariableType.of(slot, nameEntry, signatureEntry, startScope, endScope));\n@@ -988,1 +827,1 @@\n-        return arrayLoadInstruction(TypeKind.ReferenceType);\n+        return arrayLoad(TypeKind.ReferenceType);\n@@ -996,1 +835,1 @@\n-        return arrayStoreInstruction(TypeKind.ReferenceType);\n+        return arrayStore(TypeKind.ReferenceType);\n@@ -1005,1 +844,1 @@\n-        return loadInstruction(TypeKind.ReferenceType, slot);\n+        return loadLocal(TypeKind.ReferenceType, slot);\n@@ -1014,1 +853,1 @@\n-        return newReferenceArrayInstruction(classEntry);\n+        return with(NewReferenceArrayInstruction.of(classEntry));\n@@ -1024,1 +863,1 @@\n-        return newReferenceArrayInstruction(constantPool().classEntry(className));\n+        return anewarray(constantPool().classEntry(className));\n@@ -1032,1 +871,1 @@\n-        return returnInstruction(TypeKind.ReferenceType);\n+        return return_(TypeKind.ReferenceType);\n@@ -1040,1 +879,1 @@\n-        return operatorInstruction(Opcode.ARRAYLENGTH);\n+        return with(OperatorInstruction.of(Opcode.ARRAYLENGTH));\n@@ -1049,1 +888,1 @@\n-        return storeInstruction(TypeKind.ReferenceType, slot);\n+        return storeLocal(TypeKind.ReferenceType, slot);\n@@ -1057,1 +896,1 @@\n-        return throwInstruction();\n+        return with(ThrowInstruction.of());\n@@ -1065,1 +904,1 @@\n-        return arrayLoadInstruction(TypeKind.ByteType);\n+        return arrayLoad(TypeKind.ByteType);\n@@ -1073,1 +912,1 @@\n-        return arrayStoreInstruction(TypeKind.ByteType);\n+        return arrayStore(TypeKind.ByteType);\n@@ -1082,1 +921,1 @@\n-        return constantInstruction(Opcode.BIPUSH, b);\n+        return loadConstant(Opcode.BIPUSH, b);\n@@ -1090,1 +929,1 @@\n-        return arrayLoadInstruction(TypeKind.CharType);\n+        return arrayLoad(TypeKind.CharType);\n@@ -1098,1 +937,1 @@\n-        return arrayStoreInstruction(TypeKind.CharType);\n+        return arrayStore(TypeKind.CharType);\n@@ -1107,1 +946,1 @@\n-        return typeCheckInstruction(Opcode.CHECKCAST, type);\n+        return with(TypeCheckInstruction.of(Opcode.CHECKCAST, type));\n@@ -1117,1 +956,1 @@\n-        return typeCheckInstruction(Opcode.CHECKCAST, type);\n+        return checkcast(constantPool().classEntry(type));\n@@ -1125,1 +964,1 @@\n-        return convertInstruction(TypeKind.DoubleType, TypeKind.FloatType);\n+        return with(ConvertInstruction.of(Opcode.D2F));\n@@ -1133,1 +972,1 @@\n-        return convertInstruction(TypeKind.DoubleType, TypeKind.IntType);\n+        return with(ConvertInstruction.of(Opcode.D2I));\n@@ -1141,1 +980,1 @@\n-        return convertInstruction(TypeKind.DoubleType, TypeKind.LongType);\n+        return with(ConvertInstruction.of(Opcode.D2L));\n@@ -1149,1 +988,1 @@\n-        return operatorInstruction(Opcode.DADD);\n+        return with(OperatorInstruction.of(Opcode.DADD));\n@@ -1157,1 +996,1 @@\n-        return arrayLoadInstruction(TypeKind.DoubleType);\n+        return arrayLoad(TypeKind.DoubleType);\n@@ -1165,1 +1004,1 @@\n-        return arrayStoreInstruction(TypeKind.DoubleType);\n+        return arrayStore(TypeKind.DoubleType);\n@@ -1173,1 +1012,1 @@\n-        return operatorInstruction(Opcode.DCMPG);\n+        return with(OperatorInstruction.of(Opcode.DCMPG));\n@@ -1181,1 +1020,1 @@\n-        return operatorInstruction(Opcode.DCMPL);\n+        return with(OperatorInstruction.of(Opcode.DCMPL));\n@@ -1205,1 +1044,1 @@\n-        return operatorInstruction(Opcode.DDIV);\n+        return with(OperatorInstruction.of(Opcode.DDIV));\n@@ -1214,1 +1053,1 @@\n-        return loadInstruction(TypeKind.DoubleType, slot);\n+        return loadLocal(TypeKind.DoubleType, slot);\n@@ -1222,1 +1061,1 @@\n-        return operatorInstruction(Opcode.DMUL);\n+        return with(OperatorInstruction.of(Opcode.DMUL));\n@@ -1230,1 +1069,1 @@\n-        return operatorInstruction(Opcode.DNEG);\n+        return with(OperatorInstruction.of(Opcode.DNEG));\n@@ -1238,1 +1077,1 @@\n-        return operatorInstruction(Opcode.DREM);\n+        return with(OperatorInstruction.of(Opcode.DREM));\n@@ -1246,1 +1085,1 @@\n-        return returnInstruction(TypeKind.DoubleType);\n+        return return_(TypeKind.DoubleType);\n@@ -1255,1 +1094,1 @@\n-        return storeInstruction(TypeKind.DoubleType, slot);\n+        return storeLocal(TypeKind.DoubleType, slot);\n@@ -1263,1 +1102,1 @@\n-        return operatorInstruction(Opcode.DSUB);\n+        return with(OperatorInstruction.of(Opcode.DSUB));\n@@ -1271,1 +1110,1 @@\n-        return stackInstruction(Opcode.DUP);\n+        return with(StackInstruction.of(Opcode.DUP));\n@@ -1279,1 +1118,1 @@\n-        return stackInstruction(Opcode.DUP2);\n+        return with(StackInstruction.of(Opcode.DUP2));\n@@ -1288,1 +1127,1 @@\n-        return stackInstruction(Opcode.DUP2_X1);\n+        return with(StackInstruction.of(Opcode.DUP2_X1));\n@@ -1297,1 +1136,1 @@\n-        return stackInstruction(Opcode.DUP2_X2);\n+        return with(StackInstruction.of(Opcode.DUP2_X2));\n@@ -1305,1 +1144,1 @@\n-        return stackInstruction(Opcode.DUP_X1);\n+        return with(StackInstruction.of(Opcode.DUP_X1));\n@@ -1313,1 +1152,1 @@\n-        return stackInstruction(Opcode.DUP_X2);\n+        return with(StackInstruction.of(Opcode.DUP_X2));\n@@ -1321,1 +1160,1 @@\n-        return convertInstruction(TypeKind.FloatType, TypeKind.DoubleType);\n+        return with(ConvertInstruction.of(Opcode.F2D));\n@@ -1329,1 +1168,1 @@\n-        return convertInstruction(TypeKind.FloatType, TypeKind.IntType);\n+        return with(ConvertInstruction.of(Opcode.F2I));\n@@ -1337,1 +1176,1 @@\n-        return convertInstruction(TypeKind.FloatType, TypeKind.LongType);\n+        return with(ConvertInstruction.of(Opcode.F2L));\n@@ -1345,1 +1184,1 @@\n-        return operatorInstruction(Opcode.FADD);\n+        return with(OperatorInstruction.of(Opcode.FADD));\n@@ -1353,1 +1192,1 @@\n-        return arrayLoadInstruction(TypeKind.FloatType);\n+        return arrayLoad(TypeKind.FloatType);\n@@ -1361,1 +1200,1 @@\n-        return arrayStoreInstruction(TypeKind.FloatType);\n+        return arrayStore(TypeKind.FloatType);\n@@ -1369,1 +1208,1 @@\n-        return operatorInstruction(Opcode.FCMPG);\n+        return with(OperatorInstruction.of(Opcode.FCMPG));\n@@ -1377,1 +1216,1 @@\n-        return operatorInstruction(Opcode.FCMPL);\n+        return with(OperatorInstruction.of(Opcode.FCMPL));\n@@ -1409,1 +1248,1 @@\n-        return operatorInstruction(Opcode.FDIV);\n+        return with(OperatorInstruction.of(Opcode.FDIV));\n@@ -1418,1 +1257,1 @@\n-        return loadInstruction(TypeKind.FloatType, slot);\n+        return loadLocal(TypeKind.FloatType, slot);\n@@ -1426,1 +1265,1 @@\n-        return operatorInstruction(Opcode.FMUL);\n+        return with(OperatorInstruction.of(Opcode.FMUL));\n@@ -1434,1 +1273,1 @@\n-        return operatorInstruction(Opcode.FNEG);\n+        return with(OperatorInstruction.of(Opcode.FNEG));\n@@ -1442,1 +1281,1 @@\n-        return operatorInstruction(Opcode.FREM);\n+        return with(OperatorInstruction.of(Opcode.FREM));\n@@ -1450,1 +1289,1 @@\n-        return returnInstruction(TypeKind.FloatType);\n+        return return_(TypeKind.FloatType);\n@@ -1459,1 +1298,1 @@\n-        return storeInstruction(TypeKind.FloatType, slot);\n+        return storeLocal(TypeKind.FloatType, slot);\n@@ -1467,1 +1306,1 @@\n-        return operatorInstruction(Opcode.FSUB);\n+        return with(OperatorInstruction.of(Opcode.FSUB));\n@@ -1476,1 +1315,1 @@\n-        return fieldInstruction(Opcode.GETFIELD, ref);\n+        return fieldAccess(Opcode.GETFIELD, ref);\n@@ -1488,1 +1327,1 @@\n-        return fieldInstruction(Opcode.GETFIELD, owner, name, type);\n+        return fieldAccess(Opcode.GETFIELD, owner, name, type);\n@@ -1497,1 +1336,1 @@\n-        return fieldInstruction(Opcode.GETSTATIC, ref);\n+        return fieldAccess(Opcode.GETSTATIC, ref);\n@@ -1509,1 +1348,1 @@\n-        return fieldInstruction(Opcode.GETSTATIC, owner, name, type);\n+        return fieldAccess(Opcode.GETSTATIC, owner, name, type);\n@@ -1518,1 +1357,1 @@\n-        return branchInstruction(Opcode.GOTO, target);\n+        return branch(Opcode.GOTO, target);\n@@ -1527,1 +1366,1 @@\n-        return branchInstruction(Opcode.GOTO_W, target);\n+        return branch(Opcode.GOTO_W, target);\n@@ -1535,1 +1374,1 @@\n-        return convertInstruction(TypeKind.IntType, TypeKind.ByteType);\n+        return with(ConvertInstruction.of(Opcode.I2B));\n@@ -1543,1 +1382,1 @@\n-        return convertInstruction(TypeKind.IntType, TypeKind.CharType);\n+        return with(ConvertInstruction.of(Opcode.I2C));\n@@ -1551,1 +1390,1 @@\n-        return convertInstruction(TypeKind.IntType, TypeKind.DoubleType);\n+        return with(ConvertInstruction.of(Opcode.I2D));\n@@ -1559,1 +1398,1 @@\n-        return convertInstruction(TypeKind.IntType, TypeKind.FloatType);\n+        return with(ConvertInstruction.of(Opcode.I2F));\n@@ -1567,1 +1406,1 @@\n-        return convertInstruction(TypeKind.IntType, TypeKind.LongType);\n+        return with(ConvertInstruction.of(Opcode.I2L));\n@@ -1575,1 +1414,1 @@\n-        return convertInstruction(TypeKind.IntType, TypeKind.ShortType);\n+        return with(ConvertInstruction.of(Opcode.I2S));\n@@ -1583,1 +1422,1 @@\n-        return operatorInstruction(Opcode.IADD);\n+        return with(OperatorInstruction.of(Opcode.IADD));\n@@ -1591,1 +1430,1 @@\n-        return arrayLoadInstruction(TypeKind.IntType);\n+        return arrayLoad(TypeKind.IntType);\n@@ -1599,1 +1438,1 @@\n-        return operatorInstruction(Opcode.IAND);\n+        return with(OperatorInstruction.of(Opcode.IAND));\n@@ -1607,1 +1446,1 @@\n-        return arrayStoreInstruction(TypeKind.IntType);\n+        return arrayStore(TypeKind.IntType);\n@@ -1671,1 +1510,1 @@\n-        return operatorInstruction(Opcode.IDIV);\n+        return with(OperatorInstruction.of(Opcode.IDIV));\n@@ -1680,1 +1519,1 @@\n-        return branchInstruction(Opcode.IF_ACMPEQ, target);\n+        return branch(Opcode.IF_ACMPEQ, target);\n@@ -1689,1 +1528,1 @@\n-        return branchInstruction(Opcode.IF_ACMPNE, target);\n+        return branch(Opcode.IF_ACMPNE, target);\n@@ -1698,1 +1537,1 @@\n-        return branchInstruction(Opcode.IF_ICMPEQ, target);\n+        return branch(Opcode.IF_ICMPEQ, target);\n@@ -1707,1 +1546,1 @@\n-        return branchInstruction(Opcode.IF_ICMPGE, target);\n+        return branch(Opcode.IF_ICMPGE, target);\n@@ -1716,1 +1555,1 @@\n-        return branchInstruction(Opcode.IF_ICMPGT, target);\n+        return branch(Opcode.IF_ICMPGT, target);\n@@ -1725,1 +1564,1 @@\n-        return branchInstruction(Opcode.IF_ICMPLE, target);\n+        return branch(Opcode.IF_ICMPLE, target);\n@@ -1734,1 +1573,1 @@\n-        return branchInstruction(Opcode.IF_ICMPLT, target);\n+        return branch(Opcode.IF_ICMPLT, target);\n@@ -1743,1 +1582,1 @@\n-        return branchInstruction(Opcode.IF_ICMPNE, target);\n+        return branch(Opcode.IF_ICMPNE, target);\n@@ -1752,1 +1591,1 @@\n-        return branchInstruction(Opcode.IFNONNULL, target);\n+        return branch(Opcode.IFNONNULL, target);\n@@ -1761,1 +1600,1 @@\n-        return branchInstruction(Opcode.IFNULL, target);\n+        return branch(Opcode.IFNULL, target);\n@@ -1770,1 +1609,1 @@\n-        return branchInstruction(Opcode.IFEQ, target);\n+        return branch(Opcode.IFEQ, target);\n@@ -1779,1 +1618,1 @@\n-        return branchInstruction(Opcode.IFGE, target);\n+        return branch(Opcode.IFGE, target);\n@@ -1788,1 +1627,1 @@\n-        return branchInstruction(Opcode.IFGT, target);\n+        return branch(Opcode.IFGT, target);\n@@ -1797,1 +1636,1 @@\n-        return branchInstruction(Opcode.IFLE, target);\n+        return branch(Opcode.IFLE, target);\n@@ -1806,1 +1645,1 @@\n-        return branchInstruction(Opcode.IFLT, target);\n+        return branch(Opcode.IFLT, target);\n@@ -1815,1 +1654,1 @@\n-        return branchInstruction(Opcode.IFNE, target);\n+        return branch(Opcode.IFNE, target);\n@@ -1825,1 +1664,1 @@\n-        return incrementInstruction(slot, val);\n+        return with(IncrementInstruction.of(slot, val));\n@@ -1834,1 +1673,1 @@\n-        return loadInstruction(TypeKind.IntType, slot);\n+        return loadLocal(TypeKind.IntType, slot);\n@@ -1842,1 +1681,1 @@\n-        return operatorInstruction(Opcode.IMUL);\n+        return with(OperatorInstruction.of(Opcode.IMUL));\n@@ -1850,1 +1689,1 @@\n-        return operatorInstruction(Opcode.INEG);\n+        return with(OperatorInstruction.of(Opcode.INEG));\n@@ -1857,0 +1696,1 @@\n+     * @since 23\n@@ -1858,2 +1698,2 @@\n-    default CodeBuilder instanceof_(ClassEntry target) {\n-        return typeCheckInstruction(Opcode.INSTANCEOF, target);\n+    default CodeBuilder instanceOf(ClassEntry target) {\n+        return with(TypeCheckInstruction.of(Opcode.INSTANCEOF, target));\n@@ -1867,0 +1707,1 @@\n+     * @since 23\n@@ -1868,2 +1709,2 @@\n-    default CodeBuilder instanceof_(ClassDesc target) {\n-        return typeCheckInstruction(Opcode.INSTANCEOF, constantPool().classEntry(target));\n+    default CodeBuilder instanceOf(ClassDesc target) {\n+        return instanceOf(constantPool().classEntry(target));\n@@ -1878,1 +1719,1 @@\n-        return invokeDynamicInstruction(ref);\n+        return with(InvokeDynamicInstruction.of(ref));\n@@ -1887,1 +1728,9 @@\n-        return invokeDynamicInstruction(ref);\n+        MethodHandleEntry bsMethod = handleDescToHandleInfo(constantPool(), (DirectMethodHandleDesc) ref.bootstrapMethod());\n+        var cpArgs = ref.bootstrapArgs();\n+        List<LoadableConstantEntry> bsArguments = new ArrayList<>(cpArgs.length);\n+        for (var constantValue : cpArgs) {\n+            bsArguments.add(BytecodeHelpers.constantEntry(constantPool(), constantValue));\n+        }\n+        BootstrapMethodEntry bm = constantPool().bsmEntry(bsMethod, bsArguments);\n+        NameAndTypeEntry nameAndType = constantPool().nameAndTypeEntry(ref.invocationName(), ref.invocationType());\n+        return invokedynamic(constantPool().invokeDynamicEntry(bm, nameAndType));\n@@ -1896,1 +1745,1 @@\n-        return invokeInstruction(Opcode.INVOKEINTERFACE, ref);\n+        return invoke(Opcode.INVOKEINTERFACE, ref);\n@@ -1908,1 +1757,1 @@\n-        return invokeInstruction(Opcode.INVOKEINTERFACE, constantPool().interfaceMethodRefEntry(owner, name, type));\n+        return invoke(Opcode.INVOKEINTERFACE, constantPool().interfaceMethodRefEntry(owner, name, type));\n@@ -1918,1 +1767,1 @@\n-        return invokeInstruction(Opcode.INVOKESPECIAL, ref);\n+        return invoke(Opcode.INVOKESPECIAL, ref);\n@@ -1928,1 +1777,1 @@\n-        return invokeInstruction(Opcode.INVOKESPECIAL, ref);\n+        return invoke(Opcode.INVOKESPECIAL, ref);\n@@ -1941,1 +1790,1 @@\n-        return invokeInstruction(Opcode.INVOKESPECIAL, owner, name, type, false);\n+        return invoke(Opcode.INVOKESPECIAL, owner, name, type, false);\n@@ -1955,1 +1804,1 @@\n-        return invokeInstruction(Opcode.INVOKESPECIAL, owner, name, type, isInterface);\n+        return invoke(Opcode.INVOKESPECIAL, owner, name, type, isInterface);\n@@ -1964,1 +1813,1 @@\n-        return invokeInstruction(Opcode.INVOKESTATIC, ref);\n+        return invoke(Opcode.INVOKESTATIC, ref);\n@@ -1973,1 +1822,1 @@\n-        return invokeInstruction(Opcode.INVOKESTATIC, ref);\n+        return invoke(Opcode.INVOKESTATIC, ref);\n@@ -1985,1 +1834,1 @@\n-        return invokeInstruction(Opcode.INVOKESTATIC, owner, name, type, false);\n+        return invoke(Opcode.INVOKESTATIC, owner, name, type, false);\n@@ -1998,1 +1847,1 @@\n-        return invokeInstruction(Opcode.INVOKESTATIC, owner, name, type, isInterface);\n+        return invoke(Opcode.INVOKESTATIC, owner, name, type, isInterface);\n@@ -2007,1 +1856,1 @@\n-        return invokeInstruction(Opcode.INVOKEVIRTUAL, ref);\n+        return invoke(Opcode.INVOKEVIRTUAL, ref);\n@@ -2019,1 +1868,1 @@\n-        return invokeInstruction(Opcode.INVOKEVIRTUAL, owner, name, type, false);\n+        return invoke(Opcode.INVOKEVIRTUAL, owner, name, type, false);\n@@ -2027,1 +1876,1 @@\n-        return operatorInstruction(Opcode.IOR);\n+        return with(OperatorInstruction.of(Opcode.IOR));\n@@ -2035,1 +1884,1 @@\n-        return operatorInstruction(Opcode.IREM);\n+        return with(OperatorInstruction.of(Opcode.IREM));\n@@ -2043,1 +1892,1 @@\n-        return returnInstruction(TypeKind.IntType);\n+        return return_(TypeKind.IntType);\n@@ -2051,1 +1900,1 @@\n-        return operatorInstruction(Opcode.ISHL);\n+        return with(OperatorInstruction.of(Opcode.ISHL));\n@@ -2059,1 +1908,1 @@\n-        return operatorInstruction(Opcode.ISHR);\n+        return with(OperatorInstruction.of(Opcode.ISHR));\n@@ -2068,1 +1917,1 @@\n-        return storeInstruction(TypeKind.IntType, slot);\n+        return storeLocal(TypeKind.IntType, slot);\n@@ -2076,1 +1925,1 @@\n-        return operatorInstruction(Opcode.ISUB);\n+        return with(OperatorInstruction.of(Opcode.ISUB));\n@@ -2084,1 +1933,1 @@\n-        return operatorInstruction(Opcode.IUSHR);\n+        return with(OperatorInstruction.of(Opcode.IUSHR));\n@@ -2092,1 +1941,1 @@\n-        return operatorInstruction(Opcode.IXOR);\n+        return with(OperatorInstruction.of(Opcode.IXOR));\n@@ -2102,1 +1951,1 @@\n-        return lookupSwitchInstruction(defaultTarget, cases);\n+        return with(LookupSwitchInstruction.of(defaultTarget, cases));\n@@ -2110,1 +1959,1 @@\n-        return convertInstruction(TypeKind.LongType, TypeKind.DoubleType);\n+        return with(ConvertInstruction.of(Opcode.L2D));\n@@ -2118,1 +1967,1 @@\n-        return convertInstruction(TypeKind.LongType, TypeKind.FloatType);\n+        return with(ConvertInstruction.of(Opcode.L2F));\n@@ -2126,1 +1975,1 @@\n-        return convertInstruction(TypeKind.LongType, TypeKind.IntType);\n+        return with(ConvertInstruction.of(Opcode.L2I));\n@@ -2134,1 +1983,1 @@\n-        return operatorInstruction(Opcode.LADD);\n+        return with(OperatorInstruction.of(Opcode.LADD));\n@@ -2142,1 +1991,1 @@\n-        return arrayLoadInstruction(TypeKind.LongType);\n+        return arrayLoad(TypeKind.LongType);\n@@ -2150,1 +1999,1 @@\n-        return operatorInstruction(Opcode.LAND);\n+        return with(OperatorInstruction.of(Opcode.LAND));\n@@ -2158,1 +2007,1 @@\n-        return arrayStoreInstruction(TypeKind.LongType);\n+        return arrayStore(TypeKind.LongType);\n@@ -2166,1 +2015,1 @@\n-        return operatorInstruction(Opcode.LCMP);\n+        return with(OperatorInstruction.of(Opcode.LCMP));\n@@ -2211,1 +2060,1 @@\n-        return operatorInstruction(Opcode.LDIV);\n+        return with(OperatorInstruction.of(Opcode.LDIV));\n@@ -2220,1 +2069,1 @@\n-        return loadInstruction(TypeKind.LongType, slot);\n+        return loadLocal(TypeKind.LongType, slot);\n@@ -2228,1 +2077,1 @@\n-        return operatorInstruction(Opcode.LMUL);\n+        return with(OperatorInstruction.of(Opcode.LMUL));\n@@ -2236,1 +2085,1 @@\n-        return operatorInstruction(Opcode.LNEG);\n+        return with(OperatorInstruction.of(Opcode.LNEG));\n@@ -2244,1 +2093,1 @@\n-        return operatorInstruction(Opcode.LOR);\n+        return with(OperatorInstruction.of(Opcode.LOR));\n@@ -2252,1 +2101,1 @@\n-        return operatorInstruction(Opcode.LREM);\n+        return with(OperatorInstruction.of(Opcode.LREM));\n@@ -2260,1 +2109,1 @@\n-        return returnInstruction(TypeKind.LongType);\n+        return return_(TypeKind.LongType);\n@@ -2268,1 +2117,1 @@\n-        return operatorInstruction(Opcode.LSHL);\n+        return with(OperatorInstruction.of(Opcode.LSHL));\n@@ -2276,1 +2125,1 @@\n-        return operatorInstruction(Opcode.LSHR);\n+        return with(OperatorInstruction.of(Opcode.LSHR));\n@@ -2285,1 +2134,1 @@\n-        return storeInstruction(TypeKind.LongType, slot);\n+        return storeLocal(TypeKind.LongType, slot);\n@@ -2293,1 +2142,1 @@\n-        return operatorInstruction(Opcode.LSUB);\n+        return with(OperatorInstruction.of(Opcode.LSUB));\n@@ -2301,1 +2150,1 @@\n-        return operatorInstruction(Opcode.LUSHR);\n+        return with(OperatorInstruction.of(Opcode.LUSHR));\n@@ -2309,1 +2158,1 @@\n-        return operatorInstruction(Opcode.LXOR);\n+        return with(OperatorInstruction.of(Opcode.LXOR));\n@@ -2317,1 +2166,1 @@\n-        return monitorInstruction(Opcode.MONITORENTER);\n+        return with(MonitorInstruction.of(Opcode.MONITORENTER));\n@@ -2325,1 +2174,1 @@\n-        return monitorInstruction(Opcode.MONITOREXIT);\n+        return with(MonitorInstruction.of(Opcode.MONITOREXIT));\n@@ -2335,1 +2184,1 @@\n-        return newMultidimensionalArrayInstruction(dims, array);\n+        return with(NewMultiArrayInstruction.of(array, dims));\n@@ -2346,1 +2195,1 @@\n-        return newMultidimensionalArrayInstruction(dims, constantPool().classEntry(array));\n+        return multianewarray(constantPool().classEntry(array), dims);\n@@ -2355,1 +2204,1 @@\n-        return newObjectInstruction(clazz);\n+        return with(NewObjectInstruction.of(clazz));\n@@ -2365,1 +2214,1 @@\n-        return newObjectInstruction(constantPool().classEntry(clazz));\n+        return new_(constantPool().classEntry(clazz));\n@@ -2374,1 +2223,1 @@\n-        return newPrimitiveArrayInstruction(typeKind);\n+        return with(NewPrimitiveArrayInstruction.of(typeKind));\n@@ -2382,1 +2231,1 @@\n-        return stackInstruction(Opcode.POP);\n+        return with(StackInstruction.of(Opcode.POP));\n@@ -2390,1 +2239,1 @@\n-        return stackInstruction(Opcode.POP2);\n+        return with(StackInstruction.of(Opcode.POP2));\n@@ -2399,1 +2248,1 @@\n-        return fieldInstruction(Opcode.PUTFIELD, ref);\n+        return fieldAccess(Opcode.PUTFIELD, ref);\n@@ -2411,1 +2260,1 @@\n-        return fieldInstruction(Opcode.PUTFIELD, owner, name, type);\n+        return fieldAccess(Opcode.PUTFIELD, owner, name, type);\n@@ -2420,1 +2269,1 @@\n-        return fieldInstruction(Opcode.PUTSTATIC, ref);\n+        return fieldAccess(Opcode.PUTSTATIC, ref);\n@@ -2432,1 +2281,1 @@\n-        return fieldInstruction(Opcode.PUTSTATIC, owner, name, type);\n+        return fieldAccess(Opcode.PUTSTATIC, owner, name, type);\n@@ -2440,1 +2289,1 @@\n-        return returnInstruction(TypeKind.VoidType);\n+        return return_(TypeKind.VoidType);\n@@ -2448,1 +2297,1 @@\n-        return arrayLoadInstruction(TypeKind.ShortType);\n+        return arrayLoad(TypeKind.ShortType);\n@@ -2456,1 +2305,1 @@\n-        return arrayStoreInstruction(TypeKind.ShortType);\n+        return arrayStore(TypeKind.ShortType);\n@@ -2465,1 +2314,1 @@\n-        return constantInstruction(Opcode.SIPUSH, s);\n+        return loadConstant(Opcode.SIPUSH, s);\n@@ -2473,1 +2322,1 @@\n-        return stackInstruction(Opcode.SWAP);\n+        return with(StackInstruction.of(Opcode.SWAP));\n@@ -2485,1 +2334,1 @@\n-        return tableSwitchInstruction(low, high, defaultTarget, cases);\n+        return with(TableSwitchInstruction.of(low, high, defaultTarget, cases));\n@@ -2502,1 +2351,1 @@\n-        return tableSwitchInstruction(low, high, defaultTarget, cases);\n+        return tableswitch(low, high, defaultTarget, cases);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":279,"deletions":430,"binary":false,"changes":709,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+     * @sealedGraph\n@@ -191,2 +192,1 @@\n-    public sealed interface TypeArg\n-            permits SignaturesImpl.TypeArgImpl {\n+    public sealed interface TypeArg {\n@@ -195,4 +195,2 @@\n-         * Indicator for whether a wildcard has default bound, no bound,\n-         * an upper bound, or a lower bound\n-         *\n-         * @since 22\n+         * Models an unbounded type argument {@code *}.\n+         * @since 23\n@@ -201,11 +199,2 @@\n-        public enum WildcardIndicator {\n-\n-            \/**\n-             * default bound wildcard (empty)\n-             *\/\n-            DEFAULT,\n-\n-            \/**\n-             * unbounded indicator {@code *}\n-             *\/\n-            UNBOUNDED,\n+        public sealed interface Unbounded extends TypeArg permits SignaturesImpl.UnboundedTypeArgImpl {\n+        }\n@@ -213,4 +202,6 @@\n-            \/**\n-             * upper-bounded indicator {@code +}\n-             *\/\n-            EXTENDS,\n+        \/**\n+         * Models a type argument with an explicit bound type.\n+         * @since 23\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+        public sealed interface Bounded extends TypeArg permits SignaturesImpl.TypeArgImpl {\n@@ -219,1 +210,2 @@\n-             * lower-bounded indicator {@code -}\n+             * Models a type argument's wildcard indicator.\n+             * @since 23\n@@ -221,1 +213,27 @@\n-            SUPER;\n+            @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+            public enum WildcardIndicator {\n+\n+                \/**\n+                 * No wildcard (empty), an exact type. Also known as\n+                 * {@index invariant}.\n+                 *\/\n+                NONE,\n+\n+                \/**\n+                 * Upper-bound indicator {@code +}. Also known as\n+                 * {@index covariant}.\n+                 *\/\n+                EXTENDS,\n+\n+                \/**\n+                 * Lower-bound indicator {@code -}. Also known as\n+                 * {@index contravariant}.\n+                 *\/\n+                SUPER;\n+            }\n+\n+            \/** {@return the kind of wildcard} *\/\n+            WildcardIndicator wildcardIndicator();\n+\n+            \/** {@return the signature of the type bound} *\/\n+            RefTypeSig boundType();\n@@ -224,6 +242,0 @@\n-        \/** {@return the wildcard indicator} *\/\n-        WildcardIndicator wildcardIndicator();\n-\n-        \/** {@return the signature of the type bound, if any} *\/\n-        Optional<RefTypeSig> boundType();\n-\n@@ -233,0 +245,1 @@\n+         * @since 23\n@@ -234,1 +247,1 @@\n-        public static TypeArg of(RefTypeSig boundType) {\n+        public static TypeArg.Bounded of(RefTypeSig boundType) {\n@@ -236,1 +249,1 @@\n-            return of(WildcardIndicator.DEFAULT, Optional.of(boundType));\n+            return bounded(Bounded.WildcardIndicator.NONE, boundType);\n@@ -241,0 +254,1 @@\n+         * @since 23\n@@ -242,2 +256,2 @@\n-        public static TypeArg unbounded() {\n-            return of(WildcardIndicator.UNBOUNDED, Optional.empty());\n+        public static TypeArg.Unbounded unbounded() {\n+            return SignaturesImpl.UnboundedTypeArgImpl.INSTANCE;\n@@ -249,0 +263,1 @@\n+         * @since 23\n@@ -250,1 +265,1 @@\n-        public static TypeArg extendsOf(RefTypeSig boundType) {\n+        public static TypeArg.Bounded extendsOf(RefTypeSig boundType) {\n@@ -252,1 +267,1 @@\n-            return of(WildcardIndicator.EXTENDS, Optional.of(boundType));\n+            return bounded(Bounded.WildcardIndicator.EXTENDS, boundType);\n@@ -258,0 +273,1 @@\n+         * @since 23\n@@ -259,1 +275,1 @@\n-        public static TypeArg superOf(RefTypeSig boundType) {\n+        public static TypeArg.Bounded superOf(RefTypeSig boundType) {\n@@ -261,1 +277,1 @@\n-            return of(WildcardIndicator.SUPER, Optional.of(boundType));\n+            return bounded(Bounded.WildcardIndicator.SUPER, boundType);\n@@ -268,0 +284,1 @@\n+         * @since 23\n@@ -269,1 +286,3 @@\n-        public static TypeArg of(WildcardIndicator wildcard, Optional<RefTypeSig> boundType) {\n+        public static TypeArg.Bounded bounded(Bounded.WildcardIndicator wildcard, RefTypeSig boundType) {\n+            requireNonNull(wildcard);\n+            requireNonNull(boundType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":57,"deletions":38,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-    private final int newarraycode;\n+    private final int newarrayCode;\n@@ -69,3 +69,6 @@\n-    \/** {@return the code used by the {@code newarray} opcode corresponding to this type} *\/\n-    public int newarraycode() {\n-        return newarraycode;\n+    \/**\n+     * {@return the code used by the {@code newarray} opcode corresponding to this type}\n+     * @since 23\n+     *\/\n+    public int newarrayCode() {\n+        return newarrayCode;\n@@ -97,1 +100,1 @@\n-    TypeKind(String name, String descriptor, int newarraycode) {\n+    TypeKind(String name, String descriptor, int newarrayCode) {\n@@ -100,1 +103,1 @@\n-        this.newarraycode = newarraycode;\n+        this.newarrayCode = newarrayCode;\n@@ -106,1 +109,3 @@\n-     * @param newarraycode the operand of the {@code newarray} instruction\n+     * @param newarrayCode the operand of the {@code newarray} instruction\n+     * @throws IllegalArgumentException if the code is invalid\n+     * @since 23\n@@ -108,2 +113,2 @@\n-    public static TypeKind fromNewArrayCode(int newarraycode) {\n-        return switch (newarraycode) {\n+    public static TypeKind fromNewarrayCode(int newarrayCode) {\n+        return switch (newarrayCode) {\n@@ -118,1 +123,1 @@\n-            default -> throw new IllegalArgumentException(\"Bad new array code: \" + newarraycode);\n+            default -> throw new IllegalArgumentException(\"Bad newarray code: \" + newarrayCode);\n@@ -125,0 +130,1 @@\n+     * @throws IllegalArgumentException only if the descriptor is not valid\n@@ -127,0 +133,3 @@\n+        if (s.isEmpty()) { \/\/ implicit null check\n+            throw new IllegalArgumentException(\"Empty descriptor\");\n+        }\n@@ -147,1 +156,3 @@\n-        return fromDescriptor(descriptor.descriptorString());\n+        return descriptor.isPrimitive() \/\/ implicit null check\n+                ? fromDescriptor(descriptor.descriptorString())\n+                : TypeKind.ReferenceType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        if (typeKind.newarraycode() < 0) {\n+        if (typeKind.newarrayCode() < 0) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n- * java.lang.classfile.CodeBuilder#invokeInstruction(java.lang.classfile.Opcode,\n+ * java.lang.classfile.CodeBuilder#invoke(java.lang.classfile.Opcode,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-                        b.invokeInstruction(i.opcode(), CD_Bar, i.name().stringValue(), i.typeSymbol(), i.isInterface());\n+                        b.invoke(i.opcode(), CD_Bar, i.name().stringValue(), i.typeSymbol(), i.isInterface());\n@@ -330,1 +330,1 @@\n-                                                              codeBuilder.invokeInstruction(i.opcode(), CD_Bar,\n+                                                              codeBuilder.invoke(i.opcode(), CD_Bar,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n@@ -33,5 +35,0 @@\n-import static java.lang.constant.ConstantUtils.binaryToInternal;\n-import static java.lang.constant.ConstantUtils.dropLastChar;\n-import static java.lang.constant.ConstantUtils.internalToBinary;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n-import static java.util.Objects.requireNonNull;\n@@ -39,0 +36,8 @@\n+import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+import static jdk.internal.constant.ConstantUtils.arrayDepth;\n+import static jdk.internal.constant.ConstantUtils.binaryToInternal;\n+import static jdk.internal.constant.ConstantUtils.dropFirstAndLastChar;\n+import static jdk.internal.constant.ConstantUtils.internalToBinary;\n+import static jdk.internal.constant.ConstantUtils.validateBinaryClassName;\n+import static jdk.internal.constant.ConstantUtils.validateInternalClassName;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n@@ -80,1 +85,1 @@\n-        ConstantUtils.validateBinaryClassName(requireNonNull(name));\n+        validateBinaryClassName(name);\n@@ -106,1 +111,1 @@\n-        ConstantUtils.validateInternalClassName(requireNonNull(name));\n+        validateInternalClassName(name);\n@@ -125,1 +130,1 @@\n-        ConstantUtils.validateBinaryClassName(requireNonNull(packageName));\n+        validateBinaryClassName(packageName);\n@@ -129,1 +134,1 @@\n-        validateMemberName(requireNonNull(className), false);\n+        validateMemberName(className, false);\n@@ -165,1 +170,1 @@\n-               : new ClassDescImpl(descriptor);\n+               : ClassDescImpl.of(descriptor);\n@@ -178,2 +183,3 @@\n-        int depth = ConstantUtils.arrayDepth(descriptorString());\n-        if (depth >= ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+        String desc = descriptorString();\n+        int depth = arrayDepth(desc);\n+        if (depth >= MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n@@ -182,1 +188,1 @@\n-                    ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n+                    MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n@@ -184,1 +190,5 @@\n-        return arrayType(1);\n+        String newDesc = \"[\".concat(desc);\n+        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n+        }\n+        return ClassDescImpl.ofValidated(newDesc);\n@@ -199,1 +209,0 @@\n-        int netRank;\n@@ -203,10 +212,11 @@\n-        try {\n-            int currentDepth = ConstantUtils.arrayDepth(descriptorString());\n-            netRank = Math.addExact(currentDepth, rank);\n-            if (netRank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                throw new IllegalArgumentException(\"rank: \" + netRank +\n-                                                   \" exceeds maximum supported dimension of \" +\n-                                                   ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n-            }\n-        } catch (ArithmeticException ae) {\n-            throw new IllegalArgumentException(\"Integer overflow in rank computation\");\n+        String desc = descriptorString();\n+        long currentDepth = arrayDepth(desc);\n+        long netRank = currentDepth + rank;\n+        if (netRank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+            throw new IllegalArgumentException(\"rank: \" + netRank +\n+                    \" exceeds maximum supported dimension of \" +\n+                    MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n+        }\n+        String newDesc = new StringBuilder(desc.length() + rank).repeat('[', rank).append(desc).toString();\n+        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n@@ -214,1 +224,1 @@\n-        return ClassDesc.ofDescriptor(\"[\".repeat(rank) + descriptorString());\n+        return ClassDescImpl.ofValidated(newDesc);\n@@ -238,1 +248,4 @@\n-        return ClassDesc.ofDescriptor(dropLastChar(descriptorString()) + \"$\" + nestedName + \";\");\n+        String desc = descriptorString();\n+        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n+        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n+        return ClassDescImpl.ofValidated(sb.toString());\n@@ -258,1 +271,1 @@\n-        requireNonNull(moreNestedNames);\n+        \/\/ implicit null-check\n@@ -302,1 +315,9 @@\n-        return isArray() ? ClassDesc.ofDescriptor(descriptorString().substring(1)) : null;\n+        if (isArray()) {\n+            String desc = descriptorString();\n+            if (desc.length() == 2) {\n+                return Wrapper.forBasicType(desc.charAt(1)).classDescriptor();\n+            } else {\n+                return ClassDescImpl.ofValidated(desc.substring(1));\n+            }\n+        }\n+        return null;\n@@ -315,3 +336,3 @@\n-        String className = internalToBinary(ConstantUtils.dropFirstAndLastChar(descriptorString()));\n-        int index = className.lastIndexOf('.');\n-        return (index == -1) ? \"\" : className.substring(0, index);\n+        String desc = descriptorString();\n+        int index = desc.lastIndexOf('\/');\n+        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index));\n@@ -335,2 +356,2 @@\n-            return descriptorString().substring(Math.max(1, descriptorString().lastIndexOf('\/') + 1),\n-                                                descriptorString().length() - 1);\n+            String desc = descriptorString();\n+            return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n@@ -339,1 +360,1 @@\n-            int depth = ConstantUtils.arrayDepth(descriptorString());\n+            int depth = arrayDepth(descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":56,"deletions":35,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static java.lang.constant.ConstantUtils.*;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n- * interface, or array type.  A {@linkplain ClassDescImpl} corresponds to a\n- * {@code Constant_Class_info} entry in the constant pool of a classfile.\n- *\/\n-final class ClassDescImpl implements ClassDesc {\n-    private final String descriptor;\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n-     * interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @throws IllegalArgumentException if the descriptor string is not a valid\n-     * field descriptor string, or does not describe a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    ClassDescImpl(String descriptor) {\n-        int dLen = descriptor.length();\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n-        if (len <= 1 || len != dLen)\n-            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n-        this.descriptor = descriptor;\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        if (isArray()) {\n-            if (isPrimitiveArray()) {\n-                return lookup.findClass(descriptor);\n-            }\n-            \/\/ Class.forName is slow on class or interface arrays\n-            int depth = ConstantUtils.arrayDepth(descriptor);\n-            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n-            for (int i = 0; i < depth; i++)\n-                clazz = clazz.arrayType();\n-            return clazz;\n-        }\n-        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n-    }\n-\n-    \/**\n-     * Whether the descriptor is one of a primitive array, given this is\n-     * already a valid reference type descriptor.\n-     *\/\n-    private boolean isPrimitiveArray() {\n-        \/\/ All L-type descriptors must end with a semicolon; same for reference\n-        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n-        return descriptor.charAt(descriptor.length() - 1) != ';';\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@linkplain ClassDescImpl} is\n-     * equal to another {@linkplain ClassDescImpl}.  Equality is\n-     * determined by the two class descriptors having equal class descriptor\n-     * strings.\n-     *\n-     * @param o the {@code ClassDesc} to compare to this\n-     *       {@code ClassDesc}\n-     * @return {@code true} if the specified {@code ClassDesc}\n-     *      is equal to this {@code ClassDesc}.\n-     *\/\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        ClassDesc constant = (ClassDesc) o;\n-        return descriptor.equals(constant.descriptorString());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return descriptor.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDescImpl.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n+\n@@ -67,1 +70,1 @@\n-    public static final ClassDesc CD_Object = new ClassDescImpl(\"Ljava\/lang\/Object;\");\n+    public static final ClassDesc CD_Object = ClassDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n@@ -70,1 +73,1 @@\n-    public static final ClassDesc CD_String = new ClassDescImpl(\"Ljava\/lang\/String;\");\n+    public static final ClassDesc CD_String = ClassDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n@@ -73,1 +76,1 @@\n-    public static final ClassDesc CD_Class = new ClassDescImpl(\"Ljava\/lang\/Class;\");\n+    public static final ClassDesc CD_Class = ClassDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n@@ -76,1 +79,1 @@\n-    public static final ClassDesc CD_Number = new ClassDescImpl(\"Ljava\/lang\/Number;\");\n+    public static final ClassDesc CD_Number = ClassDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n@@ -79,1 +82,1 @@\n-    public static final ClassDesc CD_Integer = new ClassDescImpl(\"Ljava\/lang\/Integer;\");\n+    public static final ClassDesc CD_Integer = ClassDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n@@ -82,1 +85,1 @@\n-    public static final ClassDesc CD_Long = new ClassDescImpl(\"Ljava\/lang\/Long;\");\n+    public static final ClassDesc CD_Long = ClassDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n@@ -85,1 +88,1 @@\n-    public static final ClassDesc CD_Float = new ClassDescImpl(\"Ljava\/lang\/Float;\");\n+    public static final ClassDesc CD_Float = ClassDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n@@ -88,1 +91,1 @@\n-    public static final ClassDesc CD_Double = new ClassDescImpl(\"Ljava\/lang\/Double;\");\n+    public static final ClassDesc CD_Double = ClassDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n@@ -91,1 +94,1 @@\n-    public static final ClassDesc CD_Short = new ClassDescImpl(\"Ljava\/lang\/Short;\");\n+    public static final ClassDesc CD_Short = ClassDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n@@ -94,1 +97,1 @@\n-    public static final ClassDesc CD_Byte = new ClassDescImpl(\"Ljava\/lang\/Byte;\");\n+    public static final ClassDesc CD_Byte = ClassDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n@@ -97,1 +100,1 @@\n-    public static final ClassDesc CD_Character = new ClassDescImpl(\"Ljava\/lang\/Character;\");\n+    public static final ClassDesc CD_Character = ClassDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n@@ -100,1 +103,1 @@\n-    public static final ClassDesc CD_Boolean = new ClassDescImpl(\"Ljava\/lang\/Boolean;\");\n+    public static final ClassDesc CD_Boolean = ClassDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n@@ -103,1 +106,1 @@\n-    public static final ClassDesc CD_Void = new ClassDescImpl(\"Ljava\/lang\/Void;\");\n+    public static final ClassDesc CD_Void = ClassDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n@@ -106,1 +109,1 @@\n-    public static final ClassDesc CD_Throwable = new ClassDescImpl(\"Ljava\/lang\/Throwable;\");\n+    public static final ClassDesc CD_Throwable = ClassDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n@@ -109,1 +112,1 @@\n-    public static final ClassDesc CD_Exception = new ClassDescImpl(\"Ljava\/lang\/Exception;\");\n+    public static final ClassDesc CD_Exception = ClassDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n@@ -112,1 +115,1 @@\n-    public static final ClassDesc CD_Enum = new ClassDescImpl(\"Ljava\/lang\/Enum;\");\n+    public static final ClassDesc CD_Enum = ClassDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n@@ -115,1 +118,1 @@\n-    public static final ClassDesc CD_VarHandle = new ClassDescImpl(\"Ljava\/lang\/invoke\/VarHandle;\");\n+    public static final ClassDesc CD_VarHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n@@ -118,1 +121,1 @@\n-    public static final ClassDesc CD_MethodHandles = new ClassDescImpl(\"Ljava\/lang\/invoke\/MethodHandles;\");\n+    public static final ClassDesc CD_MethodHandles = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n@@ -121,1 +124,1 @@\n-    public static final ClassDesc CD_MethodHandles_Lookup = new ClassDescImpl(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n+    public static final ClassDesc CD_MethodHandles_Lookup = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n@@ -124,1 +127,1 @@\n-    public static final ClassDesc CD_MethodHandle = new ClassDescImpl(\"Ljava\/lang\/invoke\/MethodHandle;\");\n+    public static final ClassDesc CD_MethodHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n@@ -127,1 +130,1 @@\n-    public static final ClassDesc CD_MethodType = new ClassDescImpl(\"Ljava\/lang\/invoke\/MethodType;\");\n+    public static final ClassDesc CD_MethodType = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n@@ -130,1 +133,1 @@\n-    public static final ClassDesc CD_CallSite = new ClassDescImpl(\"Ljava\/lang\/invoke\/CallSite;\");\n+    public static final ClassDesc CD_CallSite = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n@@ -133,1 +136,1 @@\n-    public static final ClassDesc CD_Collection = new ClassDescImpl(\"Ljava\/util\/Collection;\");\n+    public static final ClassDesc CD_Collection = ClassDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n@@ -136,1 +139,1 @@\n-    public static final ClassDesc CD_List = new ClassDescImpl(\"Ljava\/util\/List;\");\n+    public static final ClassDesc CD_List = ClassDescImpl.ofValidated(\"Ljava\/util\/List;\");\n@@ -139,1 +142,1 @@\n-    public static final ClassDesc CD_Set = new ClassDescImpl(\"Ljava\/util\/Set;\");\n+    public static final ClassDesc CD_Set = ClassDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n@@ -142,1 +145,1 @@\n-    public static final ClassDesc CD_Map = new ClassDescImpl(\"Ljava\/util\/Map;\");\n+    public static final ClassDesc CD_Map = ClassDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n@@ -145,1 +148,1 @@\n-    public static final ClassDesc CD_ConstantDesc = new ClassDescImpl(\"Ljava\/lang\/constant\/ConstantDesc;\");\n+    public static final ClassDesc CD_ConstantDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n@@ -148,1 +151,1 @@\n-    public static final ClassDesc CD_ClassDesc = new ClassDescImpl(\"Ljava\/lang\/constant\/ClassDesc;\");\n+    public static final ClassDesc CD_ClassDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n@@ -151,1 +154,1 @@\n-    public static final ClassDesc CD_EnumDesc = new ClassDescImpl(\"Ljava\/lang\/Enum$EnumDesc;\");\n+    public static final ClassDesc CD_EnumDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n@@ -154,1 +157,1 @@\n-    public static final ClassDesc CD_MethodTypeDesc = new ClassDescImpl(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n+    public static final ClassDesc CD_MethodTypeDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n@@ -157,1 +160,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc = new ClassDescImpl(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n+    public static final ClassDesc CD_MethodHandleDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n@@ -160,1 +163,1 @@\n-    public static final ClassDesc CD_DirectMethodHandleDesc = new ClassDescImpl(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n+    public static final ClassDesc CD_DirectMethodHandleDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n@@ -163,1 +166,1 @@\n-    public static final ClassDesc CD_VarHandleDesc = new ClassDescImpl(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n+    public static final ClassDesc CD_VarHandleDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n@@ -166,1 +169,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc_Kind = new ClassDescImpl(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n+    public static final ClassDesc CD_MethodHandleDesc_Kind = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n@@ -169,1 +172,1 @@\n-    public static final ClassDesc CD_DynamicConstantDesc = new ClassDescImpl(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n+    public static final ClassDesc CD_DynamicConstantDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n@@ -172,1 +175,1 @@\n-    public static final ClassDesc CD_DynamicCallSiteDesc = new ClassDescImpl(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n+    public static final ClassDesc CD_DynamicCallSiteDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n@@ -175,1 +178,1 @@\n-    public static final ClassDesc CD_ConstantBootstraps = new ClassDescImpl(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n+    public static final ClassDesc CD_ConstantBootstraps = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":40,"deletions":37,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,315 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import sun.invoke.util.Wrapper;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * Helper methods for the implementation of {@code java.lang.constant}.\n- *\/\n-class ConstantUtils {\n-    \/** an empty constant descriptor *\/\n-    public static final ConstantDesc[] EMPTY_CONSTANTDESC = new ConstantDesc[0];\n-    static final ClassDesc[] EMPTY_CLASSDESC = new ClassDesc[0];\n-    static final Constable[] EMPTY_CONSTABLE = new Constable[0];\n-    static final int MAX_ARRAY_TYPE_DESC_DIMENSIONS = 255;\n-\n-    private static final Set<String> pointyNames = Set.of(ConstantDescs.INIT_NAME, ConstantDescs.CLASS_INIT_NAME);\n-\n-    \/**\n-     * Validates the correctness of a binary class name. In particular checks for the presence of\n-     * invalid characters in the name.\n-     *\n-     * @param name the class name\n-     * @return the class name passed if valid\n-     * @throws IllegalArgumentException if the class name is invalid\n-     *\/\n-    static String validateBinaryClassName(String name) {\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-      * Validates the correctness of an internal class name.\n-      * In particular checks for the presence of invalid characters in the name.\n-      *\n-      * @param name the class name\n-      * @return the class name passed if valid\n-      * @throws IllegalArgumentException if the class name is invalid\n-      *\/\n-     static String validateInternalClassName(String name) {\n-         for (int i=0; i<name.length(); i++) {\n-             char ch = name.charAt(i);\n-             if (ch == ';' || ch == '[' || ch == '.')\n-                 throw new IllegalArgumentException(\"Invalid class name: \" + name);\n-         }\n-         return name;\n-     }\n-\n-    \/**\n-     * Validates the correctness of a binary package name.\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n-     *\n-     * @param name the package name\n-     * @return the package name passed if valid\n-     * @throws IllegalArgumentException if the package name is invalid\n-     * @throws NullPointerException if the package name is {@code null}\n-     *\/\n-    public static String validateBinaryPackageName(String name) {\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-     * Validates the correctness of an internal package name.\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty package name is allowed.\n-     *\n-     * @param name the package name\n-     * @return the package name passed if valid\n-     * @throws IllegalArgumentException if the package name is invalid\n-     * @throws NullPointerException if the package name is {@code null}\n-     *\/\n-    public static String validateInternalPackageName(String name) {\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == ';' || ch == '[' || ch == '.')\n-                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-     * Validates the correctness of a module name.\n-     * In particular checks for the presence of invalid characters in the name.\n-     * Empty module name is allowed.\n-     *\n-     * {@jvms 4.2.3} Module and Package Names\n-     *\n-     * @param name the module name\n-     * @return the module name passed if valid\n-     * @throws IllegalArgumentException if the module name is invalid\n-     * @throws NullPointerException if the module name is {@code null}\n-     *\/\n-    public static String validateModuleName(String name) {\n-        for (int i=name.length() - 1; i >= 0; i--) {\n-            char ch = name.charAt(i);\n-            if ((ch >= '\\u0000' && ch <= '\\u001F')\n-            || ((ch == '\\\\' || ch == ':' || ch =='@') && (i == 0 || name.charAt(--i) != '\\\\')))\n-                throw new IllegalArgumentException(\"Invalid module name: \" + name);\n-        }\n-        return name;\n-    }\n-\n-    \/**\n-     * Validates a member name\n-     *\n-     * @param name the name of the member\n-     * @return the name passed if valid\n-     * @throws IllegalArgumentException if the member name is invalid\n-     *\/\n-    public static String validateMemberName(String name, boolean method) {\n-        if (name.length() == 0)\n-            throw new IllegalArgumentException(\"zero-length member name\");\n-        for (int i=0; i<name.length(); i++) {\n-            char ch = name.charAt(i);\n-            if (ch == '.' || ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid member name: \" + name);\n-            if (method && (ch == '<' || ch == '>')) {\n-                if (!pointyNames.contains(name))\n-                    throw new IllegalArgumentException(\"Invalid member name: \" + name);\n-            }\n-        }\n-        return name;\n-    }\n-\n-    static void validateClassOrInterface(ClassDesc classDesc) {\n-        if (!classDesc.isClassOrInterface())\n-            throw new IllegalArgumentException(\"not a class or interface type: \" + classDesc);\n-    }\n-\n-    static int arrayDepth(String descriptorString) {\n-        int depth = 0;\n-        while (descriptorString.charAt(depth) == '[')\n-            depth++;\n-        return depth;\n-    }\n-\n-    static String binaryToInternal(String name) {\n-        return name.replace('.', '\/');\n-    }\n-\n-    static String internalToBinary(String name) {\n-        return name.replace('\/', '.');\n-    }\n-\n-    static String dropLastChar(String s) {\n-        return s.substring(0, s.length() - 1);\n-    }\n-\n-    static String dropFirstAndLastChar(String s) {\n-        return s.substring(1, s.length() - 1);\n-    }\n-\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/ placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(resolveClassDesc(descriptor, cur, len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n-        return ptypes;\n-    }\n-\n-    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n-        if (len == 1) {\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).classDescriptor();\n-        }\n-        return ClassDesc.ofDescriptor(descriptor.substring(start, start + len));\n-    }\n-\n-    private static final char JVM_SIGNATURE_ARRAY = '[';\n-    private static final char JVM_SIGNATURE_BYTE = 'B';\n-    private static final char JVM_SIGNATURE_CHAR = 'C';\n-    private static final char JVM_SIGNATURE_CLASS = 'L';\n-    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n-    private static final char JVM_SIGNATURE_ENUM = 'E';\n-    private static final char JVM_SIGNATURE_FLOAT = 'F';\n-    private static final char JVM_SIGNATURE_DOUBLE = 'D';\n-    private static final char JVM_SIGNATURE_FUNC = '(';\n-    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n-    private static final char JVM_SIGNATURE_INT = 'I';\n-    private static final char JVM_SIGNATURE_LONG = 'J';\n-    private static final char JVM_SIGNATURE_SHORT = 'S';\n-    private static final char JVM_SIGNATURE_VOID = 'V';\n-    private static final char JVM_SIGNATURE_BOOLEAN = 'Z';\n-\n-    \/**\n-     * Validates that the characters at [start, end) within the provided string\n-     * describe a valid field type descriptor.\n-     * @param descriptor the descriptor string\n-     * @param start the starting index into the string\n-     * @param end the ending index within the string\n-     * @param voidOK is void acceptable?\n-     * @return the length of the descriptor, or 0 if it is not a descriptor\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    @SuppressWarnings(\"fallthrough\")\n-    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n-        int arrayDim = 0;\n-        int index = start;\n-        while (index < end) {\n-            switch (descriptor.charAt(index)) {\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n-                case JVM_SIGNATURE_BOOLEAN:\n-                case JVM_SIGNATURE_BYTE:\n-                case JVM_SIGNATURE_CHAR:\n-                case JVM_SIGNATURE_SHORT:\n-                case JVM_SIGNATURE_INT:\n-                case JVM_SIGNATURE_FLOAT:\n-                case JVM_SIGNATURE_LONG:\n-                case JVM_SIGNATURE_DOUBLE:\n-                    return index - start + 1;\n-                case JVM_SIGNATURE_CLASS:\n-                    \/\/ state variable for detection of illegal states, such as:\n-                    \/\/ empty unqualified name, '\/\/', leading '\/', or trailing '\/'\n-                    boolean legal = false;\n-                    while (++index < end) {\n-                        switch (descriptor.charAt(index)) {\n-                            case ';' -> {\n-                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n-                                return legal ? index - start + 1 : 0;\n-                            }\n-                            case '.', '[' -> {\n-                                \/\/ do not permit '.' or '['\n-                                return 0;\n-                            }\n-                            case '\/' -> {\n-                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n-                                if (!legal) return 0;\n-                                legal = false;\n-                            }\n-                            default ->\n-                                legal = true;\n-                        }\n-                    }\n-                    return 0;\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    voidOK = false;\n-                    break;\n-                default:\n-                    return 0;\n-            }\n-        }\n-        return 0;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":0,"deletions":315,"binary":false,"changes":315,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.util.OptionalInt;\n-import java.util.stream.Stream;\n@@ -32,0 +30,1 @@\n+import jdk.internal.constant.DirectMethodHandleDescImpl;\n@@ -92,1 +91,1 @@\n-            this(refKind, false);\n+            this.refKind = refKind; this.isInterface = false;\n@@ -182,17 +181,0 @@\n-\n-        \/**\n-         * Does this {@code Kind} correspond to a virtual method invocation?\n-         *\n-         * @return if this {@code Kind} corresponds to a virtual method invocation\n-         *\/\n-        boolean isVirtualMethod() {\n-            switch (this) {\n-                case VIRTUAL:\n-                case SPECIAL:\n-                case INTERFACE_VIRTUAL:\n-                case INTERFACE_SPECIAL:\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDesc.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import static java.lang.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n@@ -39,0 +37,2 @@\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicCallSiteDesc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n-import static java.lang.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n@@ -46,0 +44,2 @@\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CONSTANTDESC;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicConstantDesc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jdk.internal.constant.DirectMethodHandleDescImpl;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,5 @@\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+\n+import static java.util.Objects.requireNonNull;\n+\n@@ -67,1 +72,1 @@\n-        return MethodTypeDescImpl.ofTrusted(returnDesc, ConstantUtils.EMPTY_CLASSDESC);\n+        return MethodTypeDescImpl.ofValidated(requireNonNull(returnDesc), ConstantUtils.EMPTY_CLASSDESC);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,242 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n- * {@link MethodType}.  A {@linkplain MethodTypeDescImpl} corresponds to a\n- * {@code Constant_MethodType_info} entry in the constant pool of a classfile.\n- *\/\n-final class MethodTypeDescImpl implements MethodTypeDesc {\n-    private final ClassDesc returnType;\n-    private final @Stable ClassDesc[] argTypes;\n-    private @Stable String cachedDescriptorString;\n-\n-    \/**\n-     * Constructs a {@linkplain MethodTypeDesc} with the specified return type\n-     * and a trusted and already-validated parameter types array.\n-     *\n-     * @param returnType a {@link ClassDesc} describing the return type\n-     * @param validatedArgTypes {@link ClassDesc}s describing the trusted and validated parameter types\n-     *\/\n-    private MethodTypeDescImpl(ClassDesc returnType, ClassDesc[] validatedArgTypes) {\n-        this.returnType = returnType;\n-        this.argTypes = validatedArgTypes;\n-    }\n-\n-    \/**\n-     * Constructs a {@linkplain MethodTypeDesc} with the specified return type\n-     * and a trusted parameter types array, which will be validated.\n-     *\n-     * @param returnType a {@link ClassDesc} describing the return type\n-     * @param trustedArgTypes {@link ClassDesc}s describing the trusted parameter types\n-     *\/\n-    static MethodTypeDescImpl ofTrusted(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n-        requireNonNull(returnType);\n-        if (trustedArgTypes.length == 0) \/\/ implicit null check\n-            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n-\n-        for (ClassDesc cd : trustedArgTypes)\n-            if (cd.descriptorString().charAt(0) == 'V') \/\/ implicit null check\n-                throw new IllegalArgumentException(\"Void parameters not permitted\");\n-\n-        return new MethodTypeDescImpl(returnType, trustedArgTypes);\n-    }\n-\n-    \/**\n-     * Creates a {@linkplain MethodTypeDescImpl} given a method descriptor string.\n-     *\n-     * @param descriptor the method descriptor string\n-     * @return a {@linkplain MethodTypeDescImpl} describing the desired method type\n-     * @throws IllegalArgumentException if the descriptor string is not a valid\n-     * method descriptor\n-     * @jvms 4.3.3 Method Descriptors\n-     *\/\n-    static MethodTypeDescImpl ofDescriptor(String descriptor) {\n-        \/\/ Implicit null-check of descriptor\n-        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n-        int args = ptypes.size() - 1;\n-        ClassDesc[] paramTypes = args > 0\n-                ? ptypes.subList(1, args + 1).toArray(ConstantUtils.EMPTY_CLASSDESC)\n-                : ConstantUtils.EMPTY_CLASSDESC;\n-\n-        MethodTypeDescImpl result = ofTrusted(ptypes.get(0), paramTypes);\n-        result.cachedDescriptorString = descriptor;\n-        return result;\n-    }\n-\n-\n-    @Override\n-    public ClassDesc returnType() {\n-        return returnType;\n-    }\n-\n-    @Override\n-    public int parameterCount() {\n-        return argTypes.length;\n-    }\n-\n-    @Override\n-    public ClassDesc parameterType(int index) {\n-        return argTypes[index];\n-    }\n-\n-    @Override\n-    public List<ClassDesc> parameterList() {\n-        return List.of(argTypes);\n-    }\n-\n-    @Override\n-    public ClassDesc[] parameterArray() {\n-        return argTypes.clone();\n-    }\n-\n-    @Override\n-    public MethodTypeDesc changeReturnType(ClassDesc returnType) {\n-        return new MethodTypeDescImpl(requireNonNull(returnType), argTypes);\n-    }\n-\n-    @Override\n-    public MethodTypeDesc changeParameterType(int index, ClassDesc paramType) {\n-        ClassDesc[] newArgs = argTypes.clone();\n-        newArgs[index] = paramType;\n-        return ofTrusted(returnType, newArgs);\n-    }\n-\n-    @Override\n-    public MethodTypeDesc dropParameterTypes(int start, int end) {\n-        Objects.checkIndex(start, argTypes.length);\n-        Objects.checkFromToIndex(start, end, argTypes.length);\n-\n-        ClassDesc[] newArgs = new ClassDesc[argTypes.length - (end - start)];\n-        if (start > 0) {\n-            System.arraycopy(argTypes, 0, newArgs, 0, start);\n-        }\n-        if (end < argTypes.length) {\n-            System.arraycopy(argTypes, end, newArgs, start, argTypes.length - end);\n-        }\n-        return ofTrusted(returnType, newArgs);\n-    }\n-\n-    @Override\n-    public MethodTypeDesc insertParameterTypes(int pos, ClassDesc... paramTypes) {\n-        if (pos < 0 || pos > argTypes.length)\n-            throw new IndexOutOfBoundsException(pos);\n-\n-        ClassDesc[] newArgs = new ClassDesc[argTypes.length + paramTypes.length];\n-        if (pos > 0) {\n-            System.arraycopy(argTypes, 0, newArgs, 0, pos);\n-        }\n-        System.arraycopy(paramTypes, 0, newArgs, pos, paramTypes.length);\n-        if (pos < argTypes.length) {\n-            System.arraycopy(argTypes, pos, newArgs, pos + paramTypes.length, argTypes.length - pos);\n-        }\n-        return ofTrusted(returnType, newArgs);\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        var desc = this.cachedDescriptorString;\n-        if (desc != null)\n-            return desc;\n-\n-        int len = 2 + returnType.descriptorString().length();\n-        for (ClassDesc argType : argTypes) {\n-            len += argType.descriptorString().length();\n-        }\n-        StringBuilder sb = new StringBuilder(len).append('(');\n-        for (ClassDesc argType : argTypes) {\n-            sb.append(argType.descriptorString());\n-        }\n-        desc = sb.append(')').append(returnType.descriptorString()).toString();\n-        cachedDescriptorString = desc;\n-        return desc;\n-    }\n-\n-    @Override\n-    public MethodType resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException {\n-        @SuppressWarnings(\"removal\")\n-        MethodType mtype = AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public MethodType run() {\n-                return MethodType.fromMethodDescriptorString(descriptorString(),\n-                                                             lookup.lookupClass().getClassLoader());\n-            }\n-        });\n-\n-        \/\/ let's check that the lookup has access to all the types in the method type\n-        lookup.accessClass(mtype.returnType());\n-        for (Class<?> paramType: mtype.parameterArray()) {\n-            lookup.accessClass(paramType);\n-        }\n-        return mtype;\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@linkplain MethodTypeDescImpl} is\n-     * equal to another {@linkplain MethodTypeDescImpl}.  Equality is\n-     * determined by the two descriptors having equal return types and argument\n-     * types.\n-     *\n-     * @param o the {@code MethodTypeDescImpl} to compare to this\n-     *       {@code MethodTypeDescImpl}\n-     * @return {@code true} if the specified {@code MethodTypeDescImpl}\n-     *      is equal to this {@code MethodTypeDescImpl}.\n-     *\/\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        MethodTypeDescImpl constant = (MethodTypeDescImpl) o;\n-\n-        return returnType.equals(constant.returnType)\n-               && Arrays.equals(argTypes, constant.argTypes);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = returnType.hashCode();\n-        result = 31 * result + Arrays.hashCode(argTypes);\n-        return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"MethodTypeDesc[%s]\", displayDescriptor());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":0,"deletions":242,"binary":false,"changes":242,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.ModuleDescImpl;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ModuleDesc.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-\/*\n- * Implementation of {@code ModuleDesc}\n- * @param name must have been validated\n- *\/\n-record ModuleDescImpl(String name) implements ModuleDesc {\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ModuleDesc[%s]\", name());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ModuleDescImpl.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.PackageDescImpl;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PackageDesc.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-\/*\n- * Implementation of {@code PackageDesc}\n- * @param internalName must have been validated\n- *\/\n-record PackageDescImpl(String internalName) implements PackageDesc {\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"PackageDesc[%s]\", name());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PackageDescImpl.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import sun.invoke.util.Wrapper;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for the class\n- * constant corresponding to a primitive type (e.g., {@code int.class}).\n- *\/\n-final class PrimitiveClassDescImpl\n-        extends DynamicConstantDesc<Class<?>> implements ClassDesc {\n-\n-    private final String descriptor;\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} given a descriptor string for a primitive\n-     * type.\n-     *\n-     * @param descriptor the descriptor string, which must be a one-character\n-     * string corresponding to one of the nine base types\n-     * @throws IllegalArgumentException if the descriptor string does not\n-     * describe a valid primitive type\n-     * @jvms 4.3 Descriptors\n-     *\/\n-    PrimitiveClassDescImpl(String descriptor) {\n-        super(ConstantDescs.BSM_PRIMITIVE_CLASS, requireNonNull(descriptor), ConstantDescs.CD_Class);\n-        if (descriptor.length() != 1\n-            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n-            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n-        this.descriptor = descriptor;\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) {\n-        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"PrimitiveClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PrimitiveClassDescImpl.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -574,0 +574,4 @@\n+     * <p>\n+     * For any given dynamic argument {@code x_i}, it must be that {@code 0 <= x_i < size_i},\n+     * where {@code size_i} is the size of the open path element associated with {@code x_i}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n@@ -612,1 +616,1 @@\n-     * O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(B, I1, I2, ... In);\n@@ -630,0 +634,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n@@ -731,1 +738,1 @@\n-     * O = this.offsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n@@ -734,1 +741,1 @@\n-     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)},\n+     * More formally, the method handle returned by this method is obtained from {@link #varHandle(PathElement...)},\n@@ -739,0 +746,29 @@\n+     * <p>\n+     * Accessing a memory segment using the var handle returned by this method is subject\n+     * to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be\n+     *     <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     *     {@linkplain #byteAlignment() alignment constraint} of the root layout\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n+     *     that the alignment constraint of the root layout can be more strict\n+     *     (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside\n+     *     the spatial bounds of the accessed memory segment, or an\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n+     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n+     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n+     *     accessed memory segment.<\/li>\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n+     *     <li>The accessed memory segment must be\n+     *     {@link MemorySegment#isAccessibleBy(Thread) accessible} from the thread\n+     *     performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>For write operations, the accessed memory segment must not be\n+     *     {@link MemorySegment#isReadOnly() read only}, or an\n+     *     {@link IllegalArgumentException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed\n+     *     segment must be {@linkplain MemorySegment.Scope#isAlive() alive}, or an\n+     *     {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -795,0 +831,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n@@ -841,1 +880,2 @@\n-     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>.\n+     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>. The <em>size<\/em>\n+     * of an open path element determines the number of element layouts that can be selected by it.\n@@ -909,0 +949,1 @@\n+         * That is, the size of the returned open path element is {@code B}.\n@@ -927,1 +968,1 @@\n-         * {@code 0 <= I < C}.\n+         * {@code 0 <= I < C}. That is, {@code C} is the size of the returned open path element.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.util.logging.PlatformLogger;\n@@ -76,0 +75,1 @@\n+        private final TreeSet<String> linkerTypes = new TreeSet<>();\n@@ -90,0 +90,6 @@\n+        HolderClassBuilder addLinkerType(String methodType) {\n+            validateMethodType(methodType);\n+            linkerTypes.add(methodType);\n+            return this;\n+        }\n+\n@@ -133,1 +139,1 @@\n-            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ The linker type to ask for is retrieved by removing the first\n@@ -135,0 +141,16 @@\n+            MethodType[] linkerMethodTypes = new MethodType[linkerTypes.size()];\n+            index = 0;\n+            for (String linkerType : linkerTypes) {\n+                MethodType mt = asMethodType(linkerType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (!checkLinkerTypeParams(mt)) {\n+                    throw new RuntimeException(\n+                            \"Linker type parameter must start and end with Object: \" + linkerType);\n+                }\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                linkerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                index++;\n+            }\n+\n+            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ argument, which needs to be of Object.class\n@@ -139,1 +161,0 @@\n-                final int lastParam = mt.parameterCount() - 1;\n@@ -142,1 +163,1 @@\n-                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n+                            \"Invoker type parameter must start with 2 Objects: \" + invokerType);\n@@ -144,2 +165,1 @@\n-                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 2);\n@@ -174,1 +194,1 @@\n-                            invokerMethodTypes, callSiteMethodTypes));\n+                            linkerMethodTypes, invokerMethodTypes, callSiteMethodTypes));\n@@ -210,0 +230,6 @@\n+            return (mt.parameterCount() >= 2 &&\n+                    mt.parameterType(0) == Object.class &&\n+                    mt.parameterType(1) == Object.class);\n+        }\n+\n+        public static boolean checkLinkerTypeParams(MethodType mt) {\n@@ -323,0 +349,3 @@\n+                                } else if (parts[2].endsWith(\"nvoker\")) {\n+                                    \/\/ MH.exactInvoker exactInvoker MH.invoker invoker\n+                                    builder.addInvokerType(methodType);\n@@ -324,8 +353,1 @@\n-                                    MethodType mt = HolderClassBuilder.asMethodType(methodType);\n-                                    \/\/ Work around JDK-8327499\n-                                    if (HolderClassBuilder.checkInvokerTypeParams(mt)) {\n-                                        builder.addInvokerType(methodType);\n-                                    } else {\n-                                        PlatformLogger.getLogger(\"java.lang.invoke\")\n-                                                .warning(\"Invalid LF_RESOLVE \" + parts[1] + \" \" + parts[2] + \" \" + parts[3]);\n-                                    }\n+                                    builder.addLinkerType(methodType);\n@@ -468,2 +490,2 @@\n-     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n-     * and {@code callSiteMethodTypes}.\n+     * the invoker forms for the set of supplied {@code linkerMethodTypes}\n+     * {@code invokerMethodTypes}, and {@code callSiteMethodTypes}.\n@@ -472,1 +494,2 @@\n-            MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {\n+            MethodType[] linkerMethodTypes, MethodType[] invokerMethodTypes,\n+            MethodType[] callSiteMethodTypes) {\n@@ -477,2 +500,2 @@\n-        int[] types = {\n-            MethodTypeForm.LF_EX_LINKER,\n+\n+        int[] invokerTypes = {\n@@ -480,2 +503,1 @@\n-            MethodTypeForm.LF_GEN_LINKER,\n-            MethodTypeForm.LF_GEN_INVOKER\n+            MethodTypeForm.LF_GEN_INVOKER,\n@@ -484,1 +506,1 @@\n-        for (int i = 0; i < invokerMethodTypes.length; i++) {\n+        for (MethodType methodType : invokerMethodTypes) {\n@@ -486,3 +508,3 @@\n-            if (dedupSet.add(invokerMethodTypes[i])) {\n-                for (int type : types) {\n-                    LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],\n+            if (dedupSet.add(methodType)) {\n+                for (int type : invokerTypes) {\n+                    LambdaForm invokerForm = Invokers.invokeHandleForm(methodType,\n@@ -496,0 +518,18 @@\n+        int[] linkerTypes = {\n+                MethodTypeForm.LF_EX_LINKER,\n+                MethodTypeForm.LF_GEN_LINKER,\n+        };\n+\n+        dedupSet = new HashSet<>();\n+        for (MethodType methodType : linkerMethodTypes) {\n+            \/\/ generate methods representing linkers of the specified type\n+            if (dedupSet.add(methodType)) {\n+                for (int type : linkerTypes) {\n+                    LambdaForm linkerForm = Invokers.invokeHandleForm(methodType,\n+                            \/*customized*\/false, type);\n+                    forms.add(linkerForm);\n+                    names.add(linkerForm.kind.defaultLambdaName);\n+                }\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":66,"deletions":26,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-                cob.constantInstruction(ifaceDesc);\n+                cob.loadConstant(ifaceDesc);\n@@ -410,1 +410,1 @@\n-                    cob.constantInstruction(mi.desc);\n+                    cob.loadConstant(mi.desc);\n@@ -427,1 +427,1 @@\n-                cob.constantInstruction(proxyDesc);\n+                cob.loadConstant(proxyDesc);\n@@ -432,1 +432,1 @@\n-                cob.constantInstruction(Lookup.ORIGINAL);\n+                cob.loadConstant(Lookup.ORIGINAL);\n@@ -456,1 +456,1 @@\n-                                        bcb.loadInstruction(TypeKind.from(mi.desc.parameterType(j)),\n+                                        bcb.loadLocal(TypeKind.from(mi.desc.parameterType(j)),\n@@ -460,1 +460,1 @@\n-                                    bcb.returnInstruction(TypeKind.from(mi.desc.returnType()));\n+                                    bcb.return_(TypeKind.from(mi.desc.returnType()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1127,1 +1127,1 @@\n-                    cb.constantInstruction(len);\n+                    cb.loadConstant(len);\n@@ -1140,1 +1140,1 @@\n-                            cb.loadInstruction(kind, off);\n+                            cb.loadLocal(kind, off);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -698,1 +698,1 @@\n-                                    .constantInstruction(Opcode.LDC, CD_Proxy)\n+                                    .ldc(CD_Proxy)\n@@ -772,1 +772,1 @@\n-                            cob.constantInstruction(parameterTypes.length)\n+                            cob.loadConstant(parameterTypes.length)\n@@ -776,1 +776,1 @@\n-                                   .constantInstruction(i);\n+                                   .loadConstant(i);\n@@ -820,1 +820,1 @@\n-                cob.loadInstruction(TypeKind.from(type).asLoadable(), slot);\n+                cob.loadLocal(TypeKind.from(type).asLoadable(), slot);\n@@ -839,1 +839,1 @@\n-                   .returnInstruction(TypeKind.from(type).asLoadable());\n+                   .return_(TypeKind.from(type).asLoadable());\n@@ -856,1 +856,1 @@\n-               .constantInstruction(parameterTypes.length)\n+               .loadConstant(parameterTypes.length)\n@@ -862,1 +862,1 @@\n-                   .constantInstruction(i);\n+                   .loadConstant(i);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-                cb.constantInstruction(0)\n+                cb.loadConstant(0)\n@@ -457,1 +457,1 @@\n-                            cb.instanceof_(Wrapper.forBasicType(classLabel)\n+                            cb.instanceOf(Wrapper.forBasicType(classLabel)\n@@ -467,1 +467,1 @@\n-                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            cb.instanceOf(ConstantDescs.CD_Number);\n@@ -496,1 +496,1 @@\n-                                cb.instanceof_(ConstantDescs.CD_Character);\n+                                cb.instanceOf(ConstantDescs.CD_Character);\n@@ -517,1 +517,1 @@\n-                            cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+                            cb.instanceOf(classLabelConstableOpt.orElseThrow());\n@@ -521,1 +521,1 @@\n-                            cb.constantInstruction(extraClassLabels.size());\n+                            cb.loadConstant(extraClassLabels.size());\n@@ -540,1 +540,1 @@\n-                    cb.constantInstruction(enumIdx);\n+                    cb.loadConstant(enumIdx);\n@@ -564,1 +564,1 @@\n-                    cb.instanceof_(ConstantDescs.CD_Number);\n+                    cb.instanceOf(ConstantDescs.CD_Number);\n@@ -574,1 +574,1 @@\n-                    cb.instanceof_(ConstantDescs.CD_Character);\n+                    cb.instanceOf(ConstantDescs.CD_Character);\n@@ -590,1 +590,1 @@\n-                        cb.constantInstruction(c ? 1 : 0);\n+                        cb.loadConstant(c ? 1 : 0);\n@@ -592,1 +592,1 @@\n-                        cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                        cb.loadConstant((ConstantDesc) element.caseLabel());\n@@ -608,1 +608,1 @@\n-                cb.constantInstruction(idx);\n+                cb.loadConstant(idx);\n@@ -612,1 +612,1 @@\n-            cb.constantInstruction(cases.size());\n+            cb.loadConstant(cases.size());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5683,12 +5683,2 @@\n-        long q1, r_tmp;\n-        if (v1 == 1) {\n-            q1 = tmp;\n-            r_tmp = 0;\n-        } else if (tmp >= 0) {\n-            q1 = tmp \/ v1;\n-            r_tmp = tmp - q1 * v1;\n-        } else {\n-            long[] rq = divRemNegativeLong(tmp, v1);\n-            q1 = rq[1];\n-            r_tmp = rq[0];\n-        }\n+        long q1 = Long.divideUnsigned(tmp, v1);\n+        long r_tmp = Long.remainderUnsigned(tmp, v1);\n@@ -5705,12 +5695,2 @@\n-        long q0;\n-        if (v1 == 1) {\n-            q0 = tmp;\n-            r_tmp = 0;\n-        } else if (tmp >= 0) {\n-            q0 = tmp \/ v1;\n-            r_tmp = tmp - q0 * v1;\n-        } else {\n-            long[] rq = divRemNegativeLong(tmp, v1);\n-            q0 = rq[1];\n-            r_tmp = rq[0];\n-        }\n+        long q0 = Long.divideUnsigned(tmp, v1);\n+        r_tmp = Long.remainderUnsigned(tmp, v1);\n@@ -5796,31 +5776,0 @@\n-    \/**\n-     * Calculate the quotient and remainder of dividing a negative long by\n-     * another long.\n-     *\n-     * @param n the numerator; must be negative\n-     * @param d the denominator; must not be unity\n-     * @return a two-element {@code long} array with the remainder and quotient in\n-     *         the initial and final elements, respectively\n-     *\/\n-    private static long[] divRemNegativeLong(long n, long d) {\n-        assert n < 0 : \"Non-negative numerator \" + n;\n-        assert d != 1 : \"Unity denominator\";\n-\n-        \/\/ Approximate the quotient and remainder\n-        long q = (n >>> 1) \/ (d >>> 1);\n-        long r = n - q * d;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += d;\n-            q--;\n-        }\n-        while (r >= d) {\n-            r -= d;\n-            q++;\n-        }\n-\n-        \/\/ n - q*d == r && 0 <= r < d, hence we're done.\n-        return new long[] {r, q};\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":5,"deletions":56,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1095,3 +1095,3 @@\n-            long dividendValue = value[offset] & LONG_MASK;\n-            int q = (int) (dividendValue \/ divisorLong);\n-            int r = (int) (dividendValue - q * divisorLong);\n+            int dividendValue = value[offset];\n+            int q = Integer.divideUnsigned(dividendValue, divisor);\n+            int r = Integer.remainderUnsigned(dividendValue, divisor);\n@@ -1109,15 +1109,3 @@\n-        \/\/ Normalize the divisor\n-        int shift = Integer.numberOfLeadingZeros(divisor);\n-\n-        int rem = value[offset];\n-        long remLong = rem & LONG_MASK;\n-        if (remLong < divisorLong) {\n-            quotient.value[0] = 0;\n-        } else {\n-            quotient.value[0] = (int)(remLong \/ divisorLong);\n-            rem = (int) (remLong - (quotient.value[0] * divisorLong));\n-            remLong = rem & LONG_MASK;\n-        }\n-        int xlen = intLen;\n-        while (--xlen > 0) {\n-            long dividendEstimate = (remLong << 32) |\n+        long rem = 0;\n+        for (int xlen = intLen; xlen > 0; xlen--) {\n+            long dividendEstimate = (rem << 32) |\n@@ -1125,9 +1113,2 @@\n-            int q;\n-            if (dividendEstimate >= 0) {\n-                q = (int) (dividendEstimate \/ divisorLong);\n-                rem = (int) (dividendEstimate - q * divisorLong);\n-            } else {\n-                long tmp = divWord(dividendEstimate, divisor);\n-                q = (int) (tmp & LONG_MASK);\n-                rem = (int) (tmp >>> 32);\n-            }\n+            int q = (int) Long.divideUnsigned(dividendEstimate, divisorLong);\n+            rem = Long.remainderUnsigned(dividendEstimate, divisorLong);\n@@ -1135,1 +1116,0 @@\n-            remLong = rem & LONG_MASK;\n@@ -1139,5 +1119,1 @@\n-        \/\/ Unnormalize\n-        if (shift > 0)\n-            return rem % divisor;\n-        else\n-            return rem;\n+        return (int)rem;\n@@ -1560,8 +1536,2 @@\n-                if (nChunk >= 0) {\n-                    qhat = (int) (nChunk \/ dhLong);\n-                    qrem = (int) (nChunk - (qhat * dhLong));\n-                } else {\n-                    long tmp = divWord(nChunk, dh);\n-                    qhat = (int) (tmp & LONG_MASK);\n-                    qrem = (int) (tmp >>> 32);\n-                }\n+                qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+                qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1619,8 +1589,2 @@\n-            if (nChunk >= 0) {\n-                qhat = (int) (nChunk \/ dhLong);\n-                qrem = (int) (nChunk - (qhat * dhLong));\n-            } else {\n-                long tmp = divWord(nChunk, dh);\n-                qhat = (int) (tmp & LONG_MASK);\n-                qrem = (int) (tmp >>> 32);\n-            }\n+            qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+            qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1735,8 +1699,2 @@\n-                if (nChunk >= 0) {\n-                    qhat = (int) (nChunk \/ dhLong);\n-                    qrem = (int) (nChunk - (qhat * dhLong));\n-                } else {\n-                    long tmp = divWord(nChunk, dh);\n-                    qhat =(int)(tmp & LONG_MASK);\n-                    qrem = (int)(tmp>>>32);\n-                }\n+                qhat = (int) Long.divideUnsigned(nChunk, dhLong);\n+                qrem = (int) Long.remainderUnsigned(nChunk, dhLong);\n@@ -1837,34 +1795,0 @@\n-    \/**\n-     * This method divides a long quantity by an int to estimate\n-     * qhat for two multi precision numbers. It is used when\n-     * the signed value of n is less than zero.\n-     * Returns long value where high 32 bits contain remainder value and\n-     * low 32 bits contain quotient value.\n-     *\/\n-    static long divWord(long n, int d) {\n-        long dLong = d & LONG_MASK;\n-        long r;\n-        long q;\n-        if (dLong == 1) {\n-            q = (int)n;\n-            r = 0;\n-            return (r << 32) | (q & LONG_MASK);\n-        }\n-\n-        \/\/ Approximate the quotient and remainder\n-        q = (n >>> 1) \/ (dLong >>> 1);\n-        r = n - q*dLong;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += dLong;\n-            q--;\n-        }\n-        while (r >= dLong) {\n-            r -= dLong;\n-            q++;\n-        }\n-        \/\/ n - q*dlong == r && 0 <= r <dLong, hence we're done.\n-        return (r << 32) | (q & LONG_MASK);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":16,"deletions":92,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,1 @@\n-    @Deprecated\n+    @Deprecated(forRemoval = true, since = \"1.2\")\n@@ -186,1 +186,1 @@\n-    @Deprecated\n+    @Deprecated(forRemoval = true, since = \"1.2\")\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-    @Deprecated\n+    @Deprecated(forRemoval = true, since = \"1.2\")\n@@ -274,1 +274,1 @@\n-    @Deprecated\n+    @Deprecated(forRemoval = true, since = \"1.2\")\n@@ -564,1 +564,1 @@\n-    @Deprecated\n+    @Deprecated(forRemoval = true, since = \"1.4\")\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -653,1 +653,0 @@\n-    @Deprecated\n@@ -655,0 +654,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -671,1 +671,0 @@\n-    @Deprecated\n@@ -673,0 +672,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -887,1 +887,0 @@\n-    @Deprecated\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetMulticastSocket.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -193,0 +193,7 @@\n+     * <p>\n+     * Set the value to {@code Boolean.FALSE} or an integer less than {@code 0} with\n+     * {@link #setOption(int, Object)} to disable this option. An integer greater than or equal to\n+     * {@code 0} will enable the option and will represent the linger interval.\n+     * <p>\n+     * If this option is enabled then {@link #getOption(int)} will return an integer value\n+     * representing the linger interval, else the return value will be {@code Boolean.FALSE}.\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketOptions.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,14 @@\n+ * @implNote\n+ * The JDK's {@code WatchService} implementations buffer up to 512 pending\n+ * events for each registered watchable object. If this limit is exceeded,\n+ * pending events are discarded and the special\n+ * {@link StandardWatchEventKinds#OVERFLOW OVERFLOW} event is queued. This\n+ * special event is the trigger to re-examine the state of the object, e.g.\n+ * scan a watched directory to get an updated list of the files in the\n+ * directory. The limit for the pending events can be changed from its default\n+ * with the system property\n+ * {@systemProperty jdk.nio.file.WatchService.maxEventsPerPoll}\n+ * set to a value that parses as a positive integer. This may be useful in\n+ * environments where there is a high volume of changes and where the impact\n+ * of discarded events is high.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/WatchService.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -152,4 +151,0 @@\n-@RandomGeneratorProperties(\n-        name = \"SecureRandom\",\n-        isStochastic = true\n-)\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/DSAPrivateKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/DSAPublicKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/ECPrivateKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/ECPublicKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/EdECPrivateKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/EdECPublicKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-     * @since 22\n+     * @since 11\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/RSAPrivateKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-     * @since 22\n+     * @since 11\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/RSAPublicKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/XECPrivateKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/XECPublicKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1166,0 +1166,24 @@\n+    \/**\n+     * Calculates the {@code Duration} until another {@code Instant}.\n+     * <p>\n+     * The start and end points are {@code this} and the specified instant.\n+     * The result will be negative if the end is before the start. Calling\n+     * this method is equivalent to\n+     * {@link Duration#between(Temporal, Temporal) Duration.between(this,\n+     * endExclusive)}.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param endExclusive the end {@code Instant}, exclusive, not null\n+     * @return the {@code Duration} from this {@code Instant} until the\n+     *      specified {@code endExclusive} {@code Instant}\n+     * @see Duration#between(Temporal, Temporal)\n+     * @since 23\n+     *\/\n+    public Duration until(Instant endExclusive) {\n+        Objects.requireNonNull(endExclusive, \"endExclusive\");\n+        long secsDiff = Math.subtractExact(endExclusive.seconds, seconds);\n+        int nanosDiff = endExclusive.nanos - nanos;\n+        return Duration.ofSeconds(secsDiff, nanosDiff);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.function.Function;\n@@ -983,0 +984,1 @@\n+\n@@ -989,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, Locale::createLocale);\n+            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_CREATOR);\n@@ -992,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, Locale::createLocale);\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n@@ -996,4 +998,11 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n-    private static Locale createLocale(Object key) {\n-        if (key instanceof BaseLocale base) {\n-            return new Locale(base, null);\n+    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n+        @Override\n+        public Locale apply(Object key) {\n+            if (key instanceof BaseLocale base) {\n+                return new Locale(base, null);\n+            }\n+            LocaleKey lk = (LocaleKey)key;\n+            return new Locale(lk.base, lk.exts);\n@@ -1001,3 +1010,1 @@\n-        LocaleKey lk = (LocaleKey)key;\n-        return new Locale(lk.base, lk.exts);\n-    }\n+    };\n@@ -1006,0 +1013,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import jdk.internal.util.random.RandomSupport.*;\n-\n@@ -80,5 +78,0 @@\n-@RandomGeneratorProperties(\n-        name = \"Random\",\n-        i = 48, j = 0, k = 0,\n-        equidistribution = 0\n-)\n","filename":"src\/java.base\/share\/classes\/java\/util\/Random.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -90,5 +89,0 @@\n-@RandomGeneratorProperties(\n-        name = \"SplittableRandom\",\n-        i = 64, j = 0, k = 0,\n-        equidistribution = 1\n-)\n","filename":"src\/java.base\/share\/classes\/java\/util\/SplittableRandom.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,12 @@\n+\n+    \/**\n+     * Only intended for in-package usage.\n+     * Constructs a {@code CancellationException} with the specified detail\n+     * message and CancellationException cause.\n+     *\n+     * @param message the detail message\n+     * @param cause the underlying cancellation exception\n+     *\/\n+    CancellationException(String message, CancellationException cause) {\n+        super(message, cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CancellationException.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    private static Object reportGet(Object r)\n+    private static Object reportGet(Object r, String details)\n@@ -392,1 +392,1 @@\n-                throw (CancellationException)x;\n+                throw new CancellationException(details, (CancellationException)x);\n@@ -404,1 +404,1 @@\n-    private static Object reportJoin(Object r) {\n+    private static Object reportJoin(Object r, String details) {\n@@ -410,1 +410,1 @@\n-                throw (CancellationException)x;\n+                throw new CancellationException(details, (CancellationException)x);\n@@ -2073,1 +2073,1 @@\n-        return (T) reportGet(r);\n+        return (T) reportGet(r, \"get\");\n@@ -2096,1 +2096,1 @@\n-        return (T) reportGet(r);\n+        return (T) reportGet(r, \"get\");\n@@ -2118,1 +2118,1 @@\n-        return (T) reportJoin(r);\n+        return (T) reportJoin(r, \"join\");\n@@ -2134,1 +2134,1 @@\n-        return ((r = result) == null) ? valueIfAbsent : (T) reportJoin(r);\n+        return ((r = result) == null) ? valueIfAbsent : (T) reportJoin(r, \"getNow\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -197,0 +197,2 @@\n+                    else if (m != null)\n+                        s.selfLinkItem();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SynchronousQueue.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,6 +88,0 @@\n-\n-@RandomGeneratorProperties(\n-        name = \"ThreadLocalRandom\",\n-        i = 64, j = 0, k = 0,\n-        equidistribution = 1\n-)\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n- * l.lock();\n+ * l.lock(); \/\/ lock() as the last statement before the try block\n@@ -87,1 +87,1 @@\n- *   l.unlock();\n+ *   l.unlock(); \/\/ unlock() as the first statement in the finally block\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/Lock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,2 +74,3 @@\n- * follow a call to {@code lock} with a {@code try} block, most\n- * typically in a before\/after construction such as:\n+ * follow a call to {@code lock} with a {@code try} block, and\n+ * to <em>always<\/em> immediately call {@code unlock} as the\n+ * first statement in the finally block, as follows:\n@@ -83,1 +84,1 @@\n- *     lock.lock();  \/\/ block until condition holds\n+ *     lock.lock();  \/\/ lock() as the last statement before the try block\n@@ -87,1 +88,1 @@\n- *       lock.unlock();\n+ *       lock.unlock(); \/\/ unlock() as the first statement in the finally block\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantLock.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+ *     \/\/ Code between the lock() above, and the unlock() below must not throw\n@@ -161,1 +162,1 @@\n- *\n+ *     \/\/ Make sure that code that could throw is executed inside the try block\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,11 @@\n-import java.lang.reflect.Constructor;\n+import jdk.internal.random.L128X1024MixRandom;\n+import jdk.internal.random.L128X128MixRandom;\n+import jdk.internal.random.L128X256MixRandom;\n+import jdk.internal.random.L32X64MixRandom;\n+import jdk.internal.random.L64X1024MixRandom;\n+import jdk.internal.random.L64X128MixRandom;\n+import jdk.internal.random.L64X128StarStarRandom;\n+import jdk.internal.random.L64X256MixRandom;\n+import jdk.internal.random.Xoroshiro128PlusPlus;\n+import jdk.internal.random.Xoshiro256PlusPlus;\n+\n@@ -30,3 +40,1 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n+import java.security.SecureRandom;\n@@ -34,1 +42,0 @@\n-import java.util.function.Function;\n@@ -36,0 +43,3 @@\n+import java.util.Random;\n+import java.util.SplittableRandom;\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -41,3 +51,0 @@\n-import java.util.ServiceLoader;\n-import java.util.ServiceLoader.Provider;\n-import java.util.stream.Collectors;\n@@ -45,1 +52,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -110,9 +116,0 @@\n-    \/**\n-     * Instance provider class of random number algorithm.\n-     *\/\n-    private final Provider<? extends RandomGenerator> provider;\n-\n-    \/**\n-     * Provider RandomGeneratorProperties annotation.\n-     *\/\n-    private volatile RandomGeneratorProperties properties;\n@@ -120,4 +117,1 @@\n-    \/**\n-     * Default provider constructor.\n-     *\/\n-    private volatile Constructor<T> ctor;\n+    private static final String DEFAULT_ALGORITHM = \"L32X64MixRandom\";\n@@ -125,4 +119,9 @@\n-    \/**\n-     * Provider constructor with long seed.\n-     *\/\n-    private Constructor<T> ctorLong;\n+    private record RandomGeneratorProperties(\n+            Class<? extends RandomGenerator> rgClass,\n+            String name,\n+            String group,\n+            int i,\n+            int j,\n+            int k,\n+            int equidistribution,\n+            int flags) {\n@@ -130,4 +129,7 @@\n-    \/**\n-     * Provider constructor with byte[] seed.\n-     *\/\n-    private Constructor<T> ctorBytes;\n+        \/* single bit masks composable with operator | *\/\n+        private static final int INSTANTIABLE       = 1 << 0;\n+        private static final int LONG_SEED          = 1 << 1;\n+        private static final int BYTE_ARRAY_SEED    = 1 << 2;\n+        private static final int STOCHASTIC         = 1 << 3;\n+        private static final int HARDWARE           = 1 << 4;\n+        private static final int DEPRECATED         = 1 << 5;\n@@ -135,0 +137,1 @@\n+        private static final int ALL_CONSTRUCTORS = INSTANTIABLE | LONG_SEED | BYTE_ARRAY_SEED;\n@@ -136,2 +139,1 @@\n-    private static class FactoryMapHolder {\n-        static final Map<String, Provider<? extends RandomGenerator>> FACTORY_MAP = createFactoryMap();\n+        private static final Map<String, RandomGeneratorProperties> FACTORY_MAP = createFactoryMap();\n@@ -140,1 +142,6 @@\n-         * Returns the factory map, lazily constructing map on first use.\n+         * Returns the factory map, lazily constructing it on first use.\n+         * <p> Although {@link ThreadLocalRandom} can only be accessed via\n+         * {@link ThreadLocalRandom#current()}, a map entry is added nevertheless\n+         * to record its properties that are otherwise not documented\n+         * anywhere else.\n+         * <p> Currently, no algorithm is deprecated.\n@@ -142,1 +149,1 @@\n-         * @return Map of RandomGeneratorFactory classes.\n+         * @return Map of RandomGeneratorProperties.\n@@ -144,6 +151,151 @@\n-        private static Map<String, Provider<? extends RandomGenerator>> createFactoryMap() {\n-            return ServiceLoader\n-                .load(RandomGenerator.class)\n-                .stream()\n-                .filter(p -> !p.type().isInterface())\n-                .collect(Collectors.toMap(p -> p.type().getSimpleName(), Function.identity()));\n+        private static Map<String, RandomGeneratorProperties> createFactoryMap() {\n+            return Map.ofEntries(\n+                    entry(SecureRandom.class, \"SecureRandom\", \"Legacy\",\n+                            0, 0, 0, Integer.MAX_VALUE,\n+                            INSTANTIABLE | BYTE_ARRAY_SEED | STOCHASTIC | deprecationBit(SecureRandom.class)),\n+                    entry(Random.class, \"Random\", \"Legacy\",\n+                            48, 0, 0, 0,\n+                            INSTANTIABLE | LONG_SEED | deprecationBit(Random.class)),\n+                    entry(SplittableRandom.class, \"SplittableRandom\", \"Legacy\",\n+                            64, 0, 0, 1,\n+                            INSTANTIABLE | LONG_SEED | deprecationBit(SplittableRandom.class)),\n+                    entry(L32X64MixRandom.class, \"L32X64MixRandom\", \"LXM\",\n+                            64, 1, 32, 1,\n+                            ALL_CONSTRUCTORS),\n+                    entry(L64X128MixRandom.class, \"L64X128MixRandom\", \"LXM\",\n+                            128, 1, 64, 2,\n+                            ALL_CONSTRUCTORS),\n+                    entry(L64X128StarStarRandom.class, \"L64X128StarStarRandom\", \"LXM\",\n+                            128, 1, 64, 2,\n+                            ALL_CONSTRUCTORS),\n+                    entry(L64X256MixRandom.class, \"L64X256MixRandom\", \"LXM\",\n+                            256, 1, 64, 4,\n+                            ALL_CONSTRUCTORS),\n+                    entry(L64X1024MixRandom.class, \"L64X1024MixRandom\", \"LXM\",\n+                            1024, 1, 64, 16,\n+                            ALL_CONSTRUCTORS),\n+                    entry(L128X128MixRandom.class, \"L128X128MixRandom\", \"LXM\",\n+                            128, 1, 128, 1,\n+                            ALL_CONSTRUCTORS),\n+                    entry(L128X256MixRandom.class, \"L128X256MixRandom\", \"LXM\",\n+                            256, 1, 128, 1,\n+                            ALL_CONSTRUCTORS),\n+                    entry(L128X1024MixRandom.class, \"L128X1024MixRandom\", \"LXM\",\n+                            1024, 1, 128, 1,\n+                            ALL_CONSTRUCTORS),\n+                    entry(Xoroshiro128PlusPlus.class, \"Xoroshiro128PlusPlus\", \"Xoroshiro\",\n+                            128, 1, 0, 1,\n+                            ALL_CONSTRUCTORS),\n+                    entry(Xoshiro256PlusPlus.class, \"Xoshiro256PlusPlus\", \"Xoshiro\",\n+                            256, 1, 0, 3,\n+                            ALL_CONSTRUCTORS),\n+                    entry(ThreadLocalRandom.class, \"ThreadLocalRandom\", \"Legacy\",\n+                            64, 0, 0, 1,\n+                            deprecationBit(ThreadLocalRandom.class))\n+            );\n+        }\n+\n+        private static Map.Entry<String, RandomGeneratorProperties> entry(\n+                Class<? extends RandomGenerator> rgClass, String name, String group,\n+                int i, int j, int k, int equidistribution,\n+                int flags) {\n+            return Map.entry(name,\n+                    new RandomGeneratorProperties(rgClass, name, group,\n+                            i, j, k, equidistribution,\n+                            flags));\n+        }\n+\n+        private static int deprecationBit(Class<? extends RandomGenerator> rgClass) {\n+            return rgClass.isAnnotationPresent(Deprecated.class) ? DEPRECATED : 0;\n+        }\n+\n+        private RandomGenerator create() {\n+            return switch (name) {\n+                case \"Random\" ->                new Random();\n+                case \"SecureRandom\" ->          new SecureRandom();\n+                case \"SplittableRandom\" ->      new SplittableRandom();\n+                case \"L32X64MixRandom\" ->       new L32X64MixRandom();\n+                case \"L64X128MixRandom\" ->      new L64X128MixRandom();\n+                case \"L64X128StarStarRandom\" -> new L64X128StarStarRandom();\n+                case \"L64X256MixRandom\" ->      new L64X256MixRandom();\n+                case \"L64X1024MixRandom\" ->     new L64X1024MixRandom();\n+                case \"L128X128MixRandom\" ->     new L128X128MixRandom();\n+                case \"L128X256MixRandom\" ->     new L128X256MixRandom();\n+                case \"L128X1024MixRandom\" ->    new L128X1024MixRandom();\n+                case \"Xoroshiro128PlusPlus\" ->  new Xoroshiro128PlusPlus();\n+                case \"Xoshiro256PlusPlus\" ->    new Xoshiro256PlusPlus();\n+                default -> throw new InternalError(\"should not happen\");\n+            };\n+        }\n+\n+        private RandomGenerator create(long seed) {\n+            if (isInstantiable() && (flags & LONG_SEED) == 0) {\n+                throw new UnsupportedOperationException(\"Random algorithm \"\n+                        + name + \" does not support a long seed\");\n+            }\n+            return switch (name) {\n+                case \"Random\" ->                new Random(seed);\n+                case \"SplittableRandom\" ->      new SplittableRandom(seed);\n+                case \"L32X64MixRandom\" ->       new L32X64MixRandom(seed);\n+                case \"L64X128MixRandom\" ->      new L64X128MixRandom(seed);\n+                case \"L64X128StarStarRandom\" -> new L64X128StarStarRandom(seed);\n+                case \"L64X256MixRandom\" ->      new L64X256MixRandom(seed);\n+                case \"L64X1024MixRandom\" ->     new L64X1024MixRandom(seed);\n+                case \"L128X128MixRandom\" ->     new L128X128MixRandom(seed);\n+                case \"L128X256MixRandom\" ->     new L128X256MixRandom(seed);\n+                case \"L128X1024MixRandom\" ->    new L128X1024MixRandom(seed);\n+                case \"Xoroshiro128PlusPlus\" ->  new Xoroshiro128PlusPlus(seed);\n+                case \"Xoshiro256PlusPlus\" ->    new Xoshiro256PlusPlus(seed);\n+                default -> throw new InternalError(\"should not happen\");\n+            };\n+        }\n+\n+        private RandomGenerator create(byte[] seed) {\n+            if (isInstantiable() && (flags & BYTE_ARRAY_SEED) == 0) {\n+                throw new UnsupportedOperationException(\"Random algorithm \"\n+                        + name + \" does not support a byte[] seed\");\n+            }\n+            return switch (name) {\n+                case \"SecureRandom\" ->          new SecureRandom(seed);\n+                case \"L32X64MixRandom\" ->       new L32X64MixRandom(seed);\n+                case \"L64X128MixRandom\" ->      new L64X128MixRandom(seed);\n+                case \"L64X128StarStarRandom\" -> new L64X128StarStarRandom(seed);\n+                case \"L64X256MixRandom\" ->      new L64X256MixRandom(seed);\n+                case \"L64X1024MixRandom\" ->     new L64X1024MixRandom(seed);\n+                case \"L128X128MixRandom\" ->     new L128X128MixRandom(seed);\n+                case \"L128X256MixRandom\" ->     new L128X256MixRandom(seed);\n+                case \"L128X1024MixRandom\" ->    new L128X1024MixRandom(seed);\n+                case \"Xoroshiro128PlusPlus\" ->  new Xoroshiro128PlusPlus(seed);\n+                case \"Xoshiro256PlusPlus\" ->    new Xoshiro256PlusPlus(seed);\n+                default -> throw new InternalError(\"should not happen\");\n+            };\n+        }\n+\n+        private boolean isStochastic() {\n+            return (flags & STOCHASTIC) != 0;\n+        }\n+\n+        private boolean isHardware() {\n+            return (flags & HARDWARE) != 0;\n+        }\n+\n+        private boolean isInstantiable() {\n+            return (flags & INSTANTIABLE) != 0;\n+        }\n+\n+        private boolean isDeprecated() {\n+            return (flags & DEPRECATED) != 0;\n+        }\n+\n+        private BigInteger period() {\n+            \/*\n+             * 0                if i = j = k = 0\n+             * (2^i - j) 2^k    otherwise\n+             *\/\n+            return i == 0 && j == 0 && k == 0\n+                    ? BigInteger.ZERO\n+                    : BigInteger.ONE.shiftLeft(i).subtract(BigInteger.valueOf(j)).shiftLeft(k);\n+        }\n+\n+        private int stateBits() {\n+            return i == 0 && k == 0 ? Integer.MAX_VALUE : i + k;\n@@ -154,3 +306,1 @@\n-     * Private constructor.\n-     *\n-     * @param provider  Provider class to wrap.\n+     * Random generator properties.\n@@ -158,3 +308,1 @@\n-    private RandomGeneratorFactory(Provider<? extends RandomGenerator> provider) {\n-        this.provider = provider;\n-    }\n+    private final RandomGeneratorProperties properties;\n@@ -163,1 +311,1 @@\n-     * Returns the factory map, lazily constructing map on first call.\n+     * Private constructor.\n@@ -165,1 +313,1 @@\n-     * @return Map of RandomGeneratorFactory classes.\n+     * @param properties Random generator properties.\n@@ -167,2 +315,2 @@\n-    private static Map<String, Provider<? extends RandomGenerator>> getFactoryMap() {\n-        return FactoryMapHolder.FACTORY_MAP;\n+    private RandomGeneratorFactory(RandomGeneratorProperties properties) {\n+        this.properties = properties;\n@@ -172,1 +320,1 @@\n-     * Return the annotation for the specified provider.\n+     * Returns the factory map, lazily constructing the map on first call.\n@@ -174,1 +322,1 @@\n-     * @return RandomGeneratorProperties annotation for the specified provider.\n+     * @return Map of random generator classes.\n@@ -176,11 +324,2 @@\n-     private RandomGeneratorProperties getProperties() {\n-        if (properties == null) {\n-            synchronized (provider) {\n-                if (properties == null) {\n-                    properties = provider.type().getDeclaredAnnotation(RandomGeneratorProperties.class);\n-                    Objects.requireNonNull(properties, provider.type() + \" missing annotation\");\n-                }\n-            }\n-        }\n-\n-        return properties;\n+    private static Map<String, RandomGeneratorProperties> getFactoryMap() {\n+        return RandomGeneratorProperties.FACTORY_MAP;\n@@ -190,1 +329,1 @@\n-     * Return true if the provider is a subclass of the category.\n+     * Return true if the random generator class is a subclass of the category.\n@@ -194,1 +333,1 @@\n-     * @return true if the provider is a subclass of the category.\n+     * @return true if the random generator class is a subclass of the category.\n@@ -197,1 +336,1 @@\n-        return isSubclass(category, provider);\n+        return isSubclass(category, properties.rgClass());\n@@ -201,1 +340,1 @@\n-     * Return true if the provider is a subclass of the category.\n+     * Return true if rgClass is a subclass of the category.\n@@ -204,1 +343,1 @@\n-     * @param provider Provider that is being filtered.\n+     * @param rgClass Class that is being filtered.\n@@ -206,1 +345,1 @@\n-     * @return true if the provider is a subclass of the category.\n+     * @return true if rgClass is a subclass of the category.\n@@ -209,2 +348,2 @@\n-                                      Provider<? extends RandomGenerator> provider) {\n-        return provider != null && category.isAssignableFrom(provider.type());\n+            Class<? extends RandomGenerator> rgClass) {\n+        return rgClass != null && category.isAssignableFrom(rgClass);\n@@ -214,1 +353,1 @@\n-     * Returns the provider matching name and category.\n+     * Returns a RandomGeneratorProperties instance matching name and category.\n@@ -216,13 +355,11 @@\n-     * @param name      Name of RandomGenerator\n-     * @param category  Interface category, sub-interface of {@link RandomGenerator}.\n-     *\n-     * @return A provider matching name and category.\n-     *\n-     * @throws IllegalArgumentException if provider is not a subclass of category.\n-     *\/\n-    private static Provider<? extends RandomGenerator> findProvider(String name,\n-                                                                    Class<? extends RandomGenerator> category)\n-            throws IllegalArgumentException {\n-        Map<String, Provider<? extends RandomGenerator>> fm = getFactoryMap();\n-        Provider<? extends RandomGenerator> provider = fm.get(name);\n-        if (provider == null) {\n+     * @param name     Name of RandomGenerator\n+     * @param category Interface category, sub-interface of {@link RandomGenerator}.\n+     * @return A RandomGeneratorProperties instance matching name and category.\n+     * @throws IllegalArgumentException if the resulting type is not a subclass of category.\n+     *\/\n+    private static RandomGeneratorProperties findClass(String name,\n+            Class<? extends RandomGenerator> category) throws IllegalArgumentException {\n+        RandomGeneratorProperties properties = name != null\n+                ? getFactoryMap().get(name)\n+                : null;\n+        if (properties == null || !properties.isInstantiable()) {\n@@ -230,3 +367,4 @@\n-                                                name +\n-                                                \"\\\" is available\");\n-        } else if (!isSubclass(category, provider)) {\n+                    name +\n+                    \"\\\" is available\");\n+        }\n+        if (!isSubclass(category, properties.rgClass())) {\n@@ -234,4 +372,4 @@\n-                                                name +\n-                                                \"\\\" is not implemented with the interface \\\"\" +\n-                                                category.getSimpleName() +\n-                                                \"\\\"\");\n+                    name +\n+                    \"\\\" is not implemented with the interface \\\"\" +\n+                    category.getSimpleName() +\n+                    \"\\\"\");\n@@ -239,1 +377,1 @@\n-        return provider;\n+        return properties;\n@@ -257,2 +395,2 @@\n-        T uncheckedRandomGenerator = (T)findProvider(name, category).get();\n-        return uncheckedRandomGenerator;\n+        T instance = (T) findClass(name, category).create();\n+        return instance;\n@@ -275,62 +413,1 @@\n-        Provider<? extends RandomGenerator> uncheckedProvider = findProvider(name, category);\n-        return new RandomGeneratorFactory<>(uncheckedProvider);\n-    }\n-\n-    \/**\n-     * Fetch the required constructors for class of random number algorithm.\n-     *\n-     * @param randomGeneratorClass class of random number algorithm (provider)\n-     *\/\n-    private void getConstructors(Class<? extends RandomGenerator> randomGeneratorClass) {\n-        if (ctor == null) {\n-            synchronized (provider) {\n-                if (ctor == null) {\n-                    PrivilegedExceptionAction<Constructor<?>[]> ctorAction = randomGeneratorClass::getConstructors;\n-                    try {\n-                        @SuppressWarnings(\"removal\")\n-                        Constructor<?>[] ctors = AccessController.doPrivileged(ctorAction);\n-\n-                        Constructor<T> tmpCtor = null;\n-                        Constructor<T> tmpCtorLong = null;\n-                        Constructor<T> tmpCtorBytes = null;\n-\n-\n-                        for (Constructor<?> ctorGeneric : ctors) {\n-                            @SuppressWarnings(\"unchecked\")\n-                            Constructor<T> ctorSpecific = (Constructor<T>) ctorGeneric;\n-                            final Class<?>[] parameterTypes = ctorSpecific.getParameterTypes();\n-\n-                            if (parameterTypes.length == 0) {\n-                                tmpCtor = ctorSpecific;\n-                            } else if (parameterTypes.length == 1) {\n-                                Class<?> argType = parameterTypes[0];\n-\n-                                if (argType == long.class) {\n-                                    tmpCtorLong = ctorSpecific;\n-                                } else if (argType == byte[].class) {\n-                                    tmpCtorBytes = ctorSpecific;\n-                                }\n-                            }\n-                        }\n-\n-                        if (tmpCtor == null) {\n-                            throw new IllegalStateException(\"Random algorithm \" + name() + \" is missing a default constructor\");\n-                        }\n-\n-                        \/\/ Store specialized constructors first, guarded by ctor\n-                        ctorBytes = tmpCtorBytes;\n-                        ctorLong = tmpCtorLong;\n-                        ctor = tmpCtor;\n-                    } catch (PrivilegedActionException ex) {\n-                        \/\/ Do nothing\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Ensure all the required constructors are fetched.\n-     *\/\n-    private void ensureConstructors() {\n-        getConstructors(provider.type());\n+        return new RandomGeneratorFactory<>(findClass(name, category));\n@@ -344,3 +421,0 @@\n-     * @implSpec Availability is determined by RandomGeneratorFactory using the\n-     * service provider API to locate implementations of the RandomGenerator interface.\n-     *\n@@ -360,1 +434,1 @@\n-                (RandomGeneratorFactory<T>)factoryOf(name, RandomGenerator.class);\n+                (RandomGeneratorFactory<T>) factoryOf(name, RandomGenerator.class);\n@@ -374,1 +448,1 @@\n-        return factoryOf(\"L32X64MixRandom\", RandomGenerator.class);\n+        return factoryOf(DEFAULT_ALGORITHM, RandomGenerator.class);\n@@ -382,3 +456,0 @@\n-     * @implSpec Availability is determined by RandomGeneratorFactory using the service provider API\n-     * to locate implementations of the RandomGenerator interface.\n-     *\n@@ -388,6 +459,4 @@\n-        Map<String, Provider<? extends RandomGenerator>> fm = getFactoryMap();\n-        return fm.values()\n-                 .stream()\n-                 .filter(p -> !p.type().isAnnotationPresent(Deprecated.class) &&\n-                              p.type().isAnnotationPresent(RandomGeneratorProperties.class))\n-                 .map(RandomGeneratorFactory::new);\n+        return getFactoryMap().values()\n+                .stream()\n+                .filter(p -> p.isInstantiable() && !p.isDeprecated())\n+                .map(RandomGeneratorFactory::new);\n@@ -403,1 +472,1 @@\n-        return provider.type().getSimpleName();\n+        return properties.name();\n@@ -413,1 +482,1 @@\n-        return getProperties().group();\n+        return properties.group();\n@@ -424,5 +493,1 @@\n-        RandomGeneratorProperties properties = getProperties();\n-        int i = properties.i();\n-        int k = properties.k();\n-\n-        return i == 0 && k == 0 ? Integer.MAX_VALUE : i + k;\n+        return properties.stateBits();\n@@ -437,1 +502,1 @@\n-        return getProperties().equidistribution();\n+        return properties.equidistribution();\n@@ -448,10 +513,1 @@\n-        RandomGeneratorProperties properties = getProperties();\n-        int i = properties.i();\n-        int j = properties.j();\n-        int k = properties.k();\n-\n-        if (i == 0 && j == 0 && k == 0) {\n-            return BigInteger.ZERO;\n-        } else {\n-            return BigInteger.ONE.shiftLeft(i).subtract(BigInteger.valueOf(j)).shiftLeft(k);\n-        }\n+        return properties.period();\n@@ -468,1 +524,1 @@\n-        return !getProperties().isStochastic();\n+        return !properties.isStochastic();\n@@ -478,1 +534,1 @@\n-        return getProperties().isStochastic();\n+        return properties.isStochastic();\n@@ -488,1 +544,1 @@\n-        return getProperties().isHardware();\n+        return properties.isHardware();\n@@ -555,1 +611,1 @@\n-        return provider.type().isAnnotationPresent(Deprecated.class);\n+        return properties.isDeprecated();\n@@ -559,1 +615,1 @@\n-     * Create an instance of {@link RandomGenerator} based on\n+     * Create an instance of {@link RandomGenerator} based on the\n@@ -562,2 +618,1 @@\n-     * @return new in instance of {@link RandomGenerator}.\n-     *\n+     * @return new instance of {@link RandomGenerator}.\n@@ -566,7 +621,3 @@\n-        try {\n-            ensureConstructors();\n-            return ctor.newInstance();\n-        } catch (Exception ex) {\n-            \/\/ Should never happen.\n-            throw new IllegalStateException(\"Random algorithm \" + name() + \" is missing a default constructor\", ex);\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        T instance = (T) properties.create();\n+        return instance;\n@@ -576,4 +627,6 @@\n-     * Create an instance of {@link RandomGenerator} based on\n-     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen\n-     * providing a starting long seed. If long seed is not supported by an\n-     * algorithm then the no argument form of create is used.\n+     * Create an instance of {@link RandomGenerator} based on the\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen,\n+     * and the provided {@code seed}.\n+     * If the {@link RandomGenerator} doesn't support instantiation through\n+     * a {@code seed} of type {@code long} then this method throws\n+     * an {@link UnsupportedOperationException}.\n@@ -583,1 +636,4 @@\n-     * @return new in instance of {@link RandomGenerator}.\n+     * @return new instance of {@link RandomGenerator}.\n+     *\n+     * @throws UnsupportedOperationException\n+     *      if a {@code seed} of type {@code long} in not supported.\n@@ -586,6 +642,3 @@\n-        try {\n-            ensureConstructors();\n-            return ctorLong.newInstance(seed);\n-        } catch (Exception ex) {\n-            return create();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        T instance = (T) properties.create(seed);\n+        return instance;\n@@ -595,5 +648,6 @@\n-     * Create an instance of {@link RandomGenerator} based on\n-     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen\n-     * providing a starting byte[] seed. If byte[] seed is not supported by an\n-     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> then the no\n-     * argument form of create is used.\n+     * Create an instance of {@link RandomGenerator} based on the\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen,\n+     * and the provided {@code seed}.\n+     * If the {@link RandomGenerator} doesn't support instantiation through\n+     * a {@code seed} of type {@code byte[]} then this method throws\n+     * an {@link UnsupportedOperationException}.\n@@ -603,1 +657,4 @@\n-     * @return new in instance of {@link RandomGenerator}.\n+     * @return new instance of {@link RandomGenerator}.\n+     *\n+     * @throws UnsupportedOperationException\n+     *      if a {@code seed} of type {@code byte[]} in not supported.\n@@ -609,6 +666,3 @@\n-        try {\n-            ensureConstructors();\n-            return ctorBytes.newInstance(seed);\n-        } catch (Exception ex) {\n-            return create();\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        T instance = (T) properties.create(seed);\n+        return instance;\n@@ -618,2 +672,0 @@\n-\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGeneratorFactory.java","additions":281,"deletions":229,"binary":false,"changes":510,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,1 @@\n- * selecting random number generator algorithms. RandomGeneratorFactory\n- * registers implementations of {@link RandomGenerator} interface using the\n- * service provider API.\n+ * selecting random number generator algorithms.\n@@ -86,2 +84,2 @@\n- * algorithm to the static method {@link RandomGenerator#of}, in which case the\n- * no-arguments constructor for that implementation is used:\n+ * algorithm to the static method {@link RandomGenerator#of}, in which case\n+ * a {@link RandomGenerator} is constructed without any seed value:\n@@ -130,2 +128,2 @@\n- * <p> There are three groups of random number generator algorithm provided\n- * in Java: the Legacy group, the LXM group, and the Xoroshiro\/Xoshiro group.\n+ * <p> Random number generator algorithms are organized in groups,\n+ * as described {@linkplain java.util.random##algorithms below}.\n@@ -309,0 +307,7 @@\n+ *      <th scope=\"row\" style=\"text-align:left\">SecureRandom<\/th>\n+ *      <td style=\"text-align:left\">Legacy<\/td>\n+ *      <td style=\"text-align:left\">BigInteger.ZERO<\/td>\n+ *      <td style=\"text-align:right\">Integer.MAX_VALUE<\/td>\n+ *      <td style=\"text-align:right\">Integer.MAX_VALUE<\/td>\n+ *  <\/tr>\n+ *  <tr>\n@@ -639,1 +644,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -155,0 +155,5 @@\n+ * Note that the CLDR locale data are subject to change. Users should not assume\n+ * that the locale data remain the same across CLDR versions. Otherwise, unexpected\n+ * incompatible behaviors may occur, such as an exception on parsing a date.\n+ * Refer to <a href=\"https:\/\/cldr.unicode.org\/index\/downloads\">CLDR Releases<\/a>\n+ * for the deltas between their releases.\n@@ -267,1 +272,1 @@\n-}\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/spi\/LocaleServiceProvider.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,0 +251,5 @@\n+            \/\/ It's not allowed for a Spliterator to report SORTED if not also ORDERED\n+            if ((c & Spliterator.SORTED) != 0 && (c & Spliterator.ORDERED) == 0) {\n+                c &= ~(Spliterator.SORTED);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamSpliterators.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/interfaces\/DHPrivateKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,0 @@\n-     * @since 22\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/interfaces\/DHPublicKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.PrintStream;\n@@ -405,0 +406,5 @@\n+    \/**\n+     * Returns the initial value of System.err.\n+     *\/\n+    PrintStream initialSystemErr();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -265,0 +265,3 @@\n+            if (npairs < 0 || npairs > code.codeLength >> 3) {\n+                throw new IllegalArgumentException(\"Invalid lookupswitch npairs value: \" + npairs);\n+            }\n@@ -317,0 +320,3 @@\n+            if (high < low || high - low > code.codeLength >> 2) {\n+                throw new IllegalArgumentException(\"Invalid tableswitch values low: \" + low + \" high: \" + high);\n+            }\n@@ -554,1 +560,1 @@\n-            return TypeKind.fromNewArrayCode(code.classReader.readU1(pos + 1));\n+            return TypeKind.fromNewarrayCode(code.classReader.readU1(pos + 1));\n@@ -1146,1 +1152,1 @@\n-            writer.writeNewPrimitiveArray(typeKind.newarraycode());\n+            writer.writeNewPrimitiveArray(typeKind.newarrayCode());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,0 @@\n-    @Override\n@@ -176,1 +175,1 @@\n-        return ByteBuffer.wrap(elems, 0, offset);\n+        return ByteBuffer.wrap(elems, 0, offset).slice();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                b.branchInstruction(Opcode.GOTO, tryCatchEnd);\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n@@ -79,1 +79,1 @@\n-                b.branchInstruction(Opcode.GOTO, tryCatchEnd);\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -394,13 +394,2 @@\n-        if (index <= 0 || index >= constantPoolCount) {\n-            throw new ConstantPoolException(\"Bad CP UTF8 index: \" + index);\n-        }\n-        PoolEntry info = cp[index];\n-        if (info == null) {\n-            int offset = cpOffset[index];\n-            int tag = readU1(offset);\n-            final int q = offset + 1;\n-            if (tag != TAG_UTF8) throw new ConstantPoolException(\"Not a UTF8 - index: \" + index);\n-            AbstractPoolEntry.Utf8EntryImpl uinfo\n-                    = new AbstractPoolEntry.Utf8EntryImpl(this, index, buffer, q + 2, readU2(q));\n-            cp[index] = uinfo;\n-            return uinfo;\n+        if (entryByIndex(index, TAG_UTF8, TAG_UTF8) instanceof AbstractPoolEntry.Utf8EntryImpl utf8) {\n+            return utf8;\n@@ -408,1 +397,1 @@\n-        return (AbstractPoolEntry.Utf8EntryImpl) info;\n+        throw new ConstantPoolException(\"Not a UTF8 - index: \" + index);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-                    cob.fieldInstruction(fai.opcode(), map(fai.owner().asSymbol()),\n+                    cob.fieldAccess(fai.opcode(), map(fai.owner().asSymbol()),\n@@ -240,1 +240,1 @@\n-                    cob.invokeInstruction(ii.opcode(), map(ii.owner().asSymbol()),\n+                    cob.invoke(ii.opcode(), map(ii.owner().asSymbol()),\n@@ -244,1 +244,1 @@\n-                    cob.invokeDynamicInstruction(DynamicCallSiteDesc.of(\n+                    cob.invokedynamic(DynamicCallSiteDesc.of(\n@@ -249,1 +249,1 @@\n-                    cob.newObjectInstruction(map(c.className().asSymbol()));\n+                    cob.new_(map(c.className().asSymbol()));\n@@ -255,1 +255,1 @@\n-                    cob.typeCheckInstruction(c.opcode(), map(c.type().asSymbol()));\n+                    cob.with(TypeCheckInstruction.of(c.opcode(), map(c.type().asSymbol())));\n@@ -266,1 +266,1 @@\n-                    cob.constantInstruction(ldc.opcode(),\n+                    cob.loadConstant(ldc.opcode(),\n@@ -375,5 +375,5 @@\n-                        cts.typeArgs().stream()\n-                                .map(ta -> Signature.TypeArg.of(\n-                                        ta.wildcardIndicator(),\n-                                        ta.boundType().map(this::mapSignature)))\n-                                .toArray(Signature.TypeArg[]::new));\n+                        cts.typeArgs().stream().map(ta -> switch (ta) {\n+                            case Signature.TypeArg.Unbounded u -> u;\n+                            case Signature.TypeArg.Bounded bta -> Signature.TypeArg.bounded(\n+                                    bta.wildcardIndicator(), mapSignature(bta.boundType()));\n+                        }).toArray(Signature.TypeArg[]::new));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,3 @@\n+        if (bci < 0 || bci > codeLength)\n+            throw new IllegalArgumentException(String.format(\"Bytecode offset out of range; bci=%d, codeLength=%d\",\n+                                                             bci, codeLength));\n@@ -240,0 +243,4 @@\n+                    if (startPc > codeLength) {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Line number start_pc out of range; start_pc=%d, codeLength=%d\", startPc, codeLength));\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-                cob.loadInstruction(\n+                cob.loadLocal(\n@@ -57,1 +57,1 @@\n-                cob.storeInstruction(\n+                cob.storeLocal(\n@@ -61,1 +61,1 @@\n-                cob.incrementInstruction(\n+                cob.iinc(\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                cob.branchInstruction(\n+                cob.branch(\n@@ -58,1 +58,1 @@\n-                cob.lookupSwitchInstruction(\n+                cob.lookupswitch(\n@@ -65,1 +65,1 @@\n-                cob.tableSwitchInstruction(\n+                cob.tableswitch(\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeRelabelerImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -283,2 +283,12 @@\n-                for (var ta : typeArgs)\n-                    sb.append(((TypeArgImpl)ta).signatureString());\n+                for (var ta : typeArgs) {\n+                    switch (ta) {\n+                        case TypeArg.Bounded b -> {\n+                            switch (b.wildcardIndicator()) {\n+                                case SUPER -> sb.append('-');\n+                                case EXTENDS -> sb.append('+');\n+                            }\n+                            sb.append(b.boundType().signatureString());\n+                        }\n+                        case TypeArg.Unbounded _ -> sb.append('*');\n+                    }\n+                }\n@@ -291,1 +301,3 @@\n-    public static record TypeArgImpl(WildcardIndicator wildcardIndicator, Optional<RefTypeSig> boundType) implements Signature.TypeArg {\n+    public static enum UnboundedTypeArgImpl implements TypeArg.Unbounded {\n+        INSTANCE;\n+    }\n@@ -293,8 +305,1 @@\n-        public String signatureString() {\n-            return switch (wildcardIndicator) {\n-                case DEFAULT -> boundType.get().signatureString();\n-                case EXTENDS -> \"+\" + boundType.get().signatureString();\n-                case SUPER -> \"-\" + boundType.get().signatureString();\n-                case UNBOUNDED -> \"*\";\n-            };\n-        }\n+    public static record TypeArgImpl(WildcardIndicator wildcardIndicator, RefTypeSig boundType) implements Signature.TypeArg.Bounded {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                dcb.bytecodesBufWriter.asByteBuffer().slice(0, dcb.bytecodesBufWriter.size()),\n+                ((BufWriterImpl) dcb.bytecodesBufWriter).asByteBuffer(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-                dcb.bytecodesBufWriter.asByteBuffer().slice(0, dcb.bytecodesBufWriter.size()),\n+                ((BufWriterImpl) dcb.bytecodesBufWriter).asByteBuffer(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,1 +288,0 @@\n-            e.printStackTrace();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import static jdk.internal.constant.ConstantUtils.*;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n+ * interface, or array type.  A {@linkplain ClassDescImpl} corresponds to a\n+ * {@code Constant_Class_info} entry in the constant pool of a classfile.\n+ *\/\n+public final class ClassDescImpl implements ClassDesc {\n+    private final String descriptor;\n+\n+    private ClassDescImpl(String descriptor) {\n+        this.descriptor = descriptor;\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n+     * interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @throws IllegalArgumentException if the descriptor string is not a valid\n+     * field descriptor string, or does not describe a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDescImpl of(String descriptor) {\n+        int dLen = descriptor.length();\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        if (len <= 1 || len != dLen)\n+            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n+        return new ClassDescImpl(descriptor);\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDescImpl ofValidated(String descriptor) {\n+        return new ClassDescImpl(descriptor);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        if (isArray()) {\n+            if (isPrimitiveArray()) {\n+                return lookup.findClass(descriptor);\n+            }\n+            \/\/ Class.forName is slow on class or interface arrays\n+            int depth = ConstantUtils.arrayDepth(descriptor);\n+            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n+            for (int i = 0; i < depth; i++)\n+                clazz = clazz.arrayType();\n+            return clazz;\n+        }\n+        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n+    }\n+\n+    \/**\n+     * Whether the descriptor is one of a primitive array, given this is\n+     * already a valid reference type descriptor.\n+     *\/\n+    private boolean isPrimitiveArray() {\n+        \/\/ All L-type descriptors must end with a semicolon; same for reference\n+        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n+        return descriptor.charAt(descriptor.length() - 1) != ';';\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@linkplain ClassDescImpl} is\n+     * equal to another {@linkplain ClassDescImpl}.  Equality is\n+     * determined by the two class descriptors having equal class descriptor\n+     * strings.\n+     *\n+     * @param o the {@code ClassDesc} to compare to this\n+     *       {@code ClassDesc}\n+     * @return {@code true} if the specified {@code ClassDesc}\n+     *      is equal to this {@code ClassDesc}.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        ClassDesc constant = (ClassDesc) o;\n+        return descriptor.equals(constant.descriptorString());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptor.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassDescImpl.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import sun.invoke.util.Wrapper;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * Helper methods for the implementation of {@code java.lang.constant}.\n+ *\/\n+public final class ConstantUtils {\n+    \/** an empty constant descriptor *\/\n+    public static final ConstantDesc[] EMPTY_CONSTANTDESC = new ConstantDesc[0];\n+    public static final ClassDesc[] EMPTY_CLASSDESC = new ClassDesc[0];\n+    public static final int MAX_ARRAY_TYPE_DESC_DIMENSIONS = 255;\n+\n+    private static final Set<String> pointyNames = Set.of(ConstantDescs.INIT_NAME, ConstantDescs.CLASS_INIT_NAME);\n+\n+    \/** No instantiation *\/\n+    private ConstantUtils() {}\n+\n+    \/**\n+     * Validates the correctness of a binary class name. In particular checks for the presence of\n+     * invalid characters in the name.\n+     *\n+     * @param name the class name\n+     * @return the class name passed if valid\n+     * @throws IllegalArgumentException if the class name is invalid\n+     * @throws NullPointerException if class name is {@code null}\n+     *\/\n+    public static String validateBinaryClassName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '\/')\n+                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of an internal class name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     *\n+     * @param name the class name\n+     * @return the class name passed if valid\n+     * @throws IllegalArgumentException if the class name is invalid\n+     * @throws NullPointerException if class name is {@code null}\n+     *\/\n+    public static String validateInternalClassName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '.')\n+                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of a binary package name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     * Empty package name is allowed.\n+     *\n+     * @param name the package name\n+     * @return the package name passed if valid\n+     * @throws IllegalArgumentException if the package name is invalid\n+     * @throws NullPointerException if the package name is {@code null}\n+     *\/\n+    public static String validateBinaryPackageName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '\/')\n+                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of an internal package name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     * Empty package name is allowed.\n+     *\n+     * @param name the package name\n+     * @return the package name passed if valid\n+     * @throws IllegalArgumentException if the package name is invalid\n+     * @throws NullPointerException if the package name is {@code null}\n+     *\/\n+    public static String validateInternalPackageName(String name) {\n+        for (int i = 0; i < name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '.')\n+                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of a module name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     * Empty module name is allowed.\n+     *\n+     * {@jvms 4.2.3} Module and Package Names\n+     *\n+     * @param name the module name\n+     * @return the module name passed if valid\n+     * @throws IllegalArgumentException if the module name is invalid\n+     * @throws NullPointerException if the module name is {@code null}\n+     *\/\n+    public static String validateModuleName(String name) {\n+        for (int i = name.length() - 1; i >= 0; i--) {\n+            char ch = name.charAt(i);\n+            if ((ch >= '\\u0000' && ch <= '\\u001F')\n+            || ((ch == '\\\\' || ch == ':' || ch =='@') && (i == 0 || name.charAt(--i) != '\\\\')))\n+                throw new IllegalArgumentException(\"Invalid module name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates a member name\n+     *\n+     * @param name the name of the member\n+     * @return the name passed if valid\n+     * @throws IllegalArgumentException if the member name is invalid\n+     * @throws NullPointerException if the member name is {@code null}\n+     *\/\n+    public static String validateMemberName(String name, boolean method) {\n+        int len = name.length();\n+        if (len == 0)\n+            throw new IllegalArgumentException(\"zero-length member name\");\n+        for (int i = 0; i < len; i++) {\n+            char ch = name.charAt(i);\n+            if (ch == '.' || ch == ';' || ch == '[' || ch == '\/')\n+                throw new IllegalArgumentException(\"Invalid member name: \" + name);\n+            if (method && (ch == '<' || ch == '>')) {\n+                if (!pointyNames.contains(name))\n+                    throw new IllegalArgumentException(\"Invalid member name: \" + name);\n+            }\n+        }\n+        return name;\n+    }\n+\n+    public static void validateClassOrInterface(ClassDesc classDesc) {\n+        if (!classDesc.isClassOrInterface())\n+            throw new IllegalArgumentException(\"not a class or interface type: \" + classDesc);\n+    }\n+\n+    public static int arrayDepth(String descriptorString) {\n+        int depth = 0;\n+        while (descriptorString.charAt(depth) == '[')\n+            depth++;\n+        return depth;\n+    }\n+\n+    public static String binaryToInternal(String name) {\n+        return name.replace('.', '\/');\n+    }\n+\n+    public static String internalToBinary(String name) {\n+        return name.replace('\/', '.');\n+    }\n+\n+    public static String dropFirstAndLastChar(String s) {\n+        return s.substring(1, s.length() - 1);\n+    }\n+\n+    \/**\n+     * Parses a method descriptor string, and return a list of field descriptor\n+     * strings, return type first, then parameter types\n+     *\n+     * @param descriptor the descriptor string\n+     * @return the list of types\n+     * @throws IllegalArgumentException if the descriptor string is not valid\n+     *\/\n+    public static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n+        int cur = 0, end = descriptor.length();\n+        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n+        ptypes.add(null); \/\/ placeholder for return type\n+\n+        if (cur >= end || descriptor.charAt(cur) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+\n+        ++cur;  \/\/ skip '('\n+        while (cur < end && descriptor.charAt(cur) != ')') {\n+            int len = skipOverFieldSignature(descriptor, cur, end, false);\n+            if (len == 0)\n+                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+            ptypes.add(resolveClassDesc(descriptor, cur, len));\n+            cur += len;\n+        }\n+        if (cur >= end)\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        ++cur;  \/\/ skip ')'\n+\n+        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n+        if (rLen == 0 || cur + rLen != end)\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n+        return ptypes;\n+    }\n+\n+    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+        if (len == 1) {\n+            return Wrapper.forPrimitiveType(descriptor.charAt(start)).classDescriptor();\n+        }\n+        \/\/ Pre-verified in parseMethodDescriptor; avoid redundant verification\n+        return ClassDescImpl.ofValidated(descriptor.substring(start, start + len));\n+    }\n+\n+    private static final char JVM_SIGNATURE_ARRAY = '[';\n+    private static final char JVM_SIGNATURE_BYTE = 'B';\n+    private static final char JVM_SIGNATURE_CHAR = 'C';\n+    private static final char JVM_SIGNATURE_CLASS = 'L';\n+    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n+    private static final char JVM_SIGNATURE_ENUM = 'E';\n+    private static final char JVM_SIGNATURE_FLOAT = 'F';\n+    private static final char JVM_SIGNATURE_DOUBLE = 'D';\n+    private static final char JVM_SIGNATURE_FUNC = '(';\n+    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n+    private static final char JVM_SIGNATURE_INT = 'I';\n+    private static final char JVM_SIGNATURE_LONG = 'J';\n+    private static final char JVM_SIGNATURE_SHORT = 'S';\n+    private static final char JVM_SIGNATURE_VOID = 'V';\n+    private static final char JVM_SIGNATURE_BOOLEAN = 'Z';\n+\n+    \/**\n+     * Validates that the characters at [start, end) within the provided string\n+     * describe a valid field type descriptor.\n+     * @param descriptor the descriptor string\n+     * @param start the starting index into the string\n+     * @param end the ending index within the string\n+     * @param voidOK is void acceptable?\n+     * @return the length of the descriptor, or 0 if it is not a descriptor\n+     * @throws IllegalArgumentException if the descriptor string is not valid\n+     *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n+        int arrayDim = 0;\n+        int index = start;\n+        while (index < end) {\n+            switch (descriptor.charAt(index)) {\n+                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n+                case JVM_SIGNATURE_BOOLEAN:\n+                case JVM_SIGNATURE_BYTE:\n+                case JVM_SIGNATURE_CHAR:\n+                case JVM_SIGNATURE_SHORT:\n+                case JVM_SIGNATURE_INT:\n+                case JVM_SIGNATURE_FLOAT:\n+                case JVM_SIGNATURE_LONG:\n+                case JVM_SIGNATURE_DOUBLE:\n+                    return index - start + 1;\n+                case JVM_SIGNATURE_CLASS:\n+                    \/\/ state variable for detection of illegal states, such as:\n+                    \/\/ empty unqualified name, '\/\/', leading '\/', or trailing '\/'\n+                    boolean legal = false;\n+                    while (++index < end) {\n+                        switch (descriptor.charAt(index)) {\n+                            case ';' -> {\n+                                \/\/ illegal state on parser exit indicates empty unqualified name or trailing '\/'\n+                                return legal ? index - start + 1 : 0;\n+                            }\n+                            case '.', '[' -> {\n+                                \/\/ do not permit '.' or '['\n+                                return 0;\n+                            }\n+                            case '\/' -> {\n+                                \/\/ illegal state when received '\/' indicates '\/\/' or leading '\/'\n+                                if (!legal) return 0;\n+                                legal = false;\n+                            }\n+                            default ->\n+                                legal = true;\n+                        }\n+                    }\n+                    return 0;\n+                case JVM_SIGNATURE_ARRAY:\n+                    arrayDim++;\n+                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n+                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+                    }\n+                    \/\/ The rest of what's there better be a legal descriptor\n+                    index++;\n+                    voidOK = false;\n+                    break;\n+                default:\n+                    return 0;\n+            }\n+        }\n+        return 0;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package java.lang.constant;\n+package jdk.internal.constant;\n@@ -27,0 +27,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -33,2 +36,0 @@\n-import static java.lang.constant.ConstantUtils.validateClassOrInterface;\n-import static java.lang.constant.ConstantUtils.validateMemberName;\n@@ -37,0 +38,2 @@\n+import static jdk.internal.constant.ConstantUtils.validateClassOrInterface;\n+import static jdk.internal.constant.ConstantUtils.validateMemberName;\n@@ -43,1 +46,1 @@\n-final class DirectMethodHandleDescImpl implements DirectMethodHandleDesc {\n+public final class DirectMethodHandleDescImpl implements DirectMethodHandleDesc {\n@@ -65,1 +68,1 @@\n-    DirectMethodHandleDescImpl(Kind kind, ClassDesc owner, String name, MethodTypeDesc type) {\n+    public DirectMethodHandleDescImpl(Kind kind, ClassDesc owner, String name, MethodTypeDesc type) {\n@@ -85,6 +88,5 @@\n-        if (kind.isVirtualMethod())\n-            this.invocationType = type.insertParameterTypes(0, owner);\n-        else if (kind == CONSTRUCTOR)\n-            this.invocationType = type.changeReturnType(owner);\n-        else\n-            this.invocationType = type;\n+        this.invocationType = switch (kind) {\n+            case VIRTUAL, SPECIAL, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> type.insertParameterTypes(0, owner);\n+            case CONSTRUCTOR -> type.changeReturnType(owner);\n+            default -> type;\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/DirectMethodHandleDescImpl.java","additions":14,"deletions":12,"binary":false,"changes":26,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","status":"renamed"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n+ * {@link MethodType}.  A {@linkplain MethodTypeDescImpl} corresponds to a\n+ * {@code Constant_MethodType_info} entry in the constant pool of a classfile.\n+ *\/\n+public final class MethodTypeDescImpl implements MethodTypeDesc {\n+    private final ClassDesc returnType;\n+    private final @Stable ClassDesc[] argTypes;\n+    private @Stable String cachedDescriptorString;\n+\n+    \/**\n+     * Constructs a {@linkplain MethodTypeDesc} with the specified return type\n+     * and a trusted and already-validated parameter types array.\n+     *\n+     * @param returnType a {@link ClassDesc} describing the return type\n+     * @param validatedArgTypes {@link ClassDesc}s describing the trusted and validated parameter types\n+     *\/\n+    private MethodTypeDescImpl(ClassDesc returnType, ClassDesc[] validatedArgTypes) {\n+        this.returnType = returnType;\n+        this.argTypes = validatedArgTypes;\n+    }\n+\n+    \/**\n+     * Constructs a {@linkplain MethodTypeDesc} with the specified return type\n+     * and a trusted parameter types array, which will be validated.\n+     *\n+     * @param returnType a {@link ClassDesc} describing the return type\n+     * @param trustedArgTypes {@link ClassDesc}s describing the trusted parameter types\n+     *\/\n+    public static MethodTypeDescImpl ofTrusted(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n+        requireNonNull(returnType);\n+        \/\/ implicit null checks of trustedArgTypes and all elements\n+        for (ClassDesc cd : trustedArgTypes) {\n+            validateArgument(cd);\n+        }\n+        return ofValidated(returnType, trustedArgTypes);\n+    }\n+\n+    private static ClassDesc validateArgument(ClassDesc arg) {\n+        if (arg.descriptorString().charAt(0) == 'V') \/\/ implicit null check\n+            throw new IllegalArgumentException(\"Void parameters not permitted\");\n+        return arg;\n+    }\n+\n+    \/**\n+     * Constructs a {@linkplain MethodTypeDesc} with the specified pre-validated return type\n+     * and a pre-validated trusted parameter types array.\n+     *\n+     * @param returnType a {@link ClassDesc} describing the return type\n+     * @param trustedArgTypes {@link ClassDesc}s describing the trusted parameter types\n+     *\/\n+    public static MethodTypeDescImpl ofValidated(ClassDesc returnType, ClassDesc[] trustedArgTypes) {\n+        if (trustedArgTypes.length == 0)\n+            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n+        return new MethodTypeDescImpl(returnType, trustedArgTypes);\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain MethodTypeDescImpl} given a method descriptor string.\n+     *\n+     * @param descriptor the method descriptor string\n+     * @return a {@linkplain MethodTypeDescImpl} describing the desired method type\n+     * @throws IllegalArgumentException if the descriptor string is not a valid\n+     * method descriptor\n+     * @jvms 4.3.3 Method Descriptors\n+     *\/\n+    public static MethodTypeDescImpl ofDescriptor(String descriptor) {\n+        \/\/ Implicit null-check of descriptor\n+        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n+        int args = ptypes.size() - 1;\n+        ClassDesc[] paramTypes = args > 0\n+                ? ptypes.subList(1, args + 1).toArray(ConstantUtils.EMPTY_CLASSDESC)\n+                : ConstantUtils.EMPTY_CLASSDESC;\n+\n+        MethodTypeDescImpl result = ofValidated(ptypes.get(0), paramTypes);\n+        result.cachedDescriptorString = descriptor;\n+        return result;\n+    }\n+\n+\n+    @Override\n+    public ClassDesc returnType() {\n+        return returnType;\n+    }\n+\n+    @Override\n+    public int parameterCount() {\n+        return argTypes.length;\n+    }\n+\n+    @Override\n+    public ClassDesc parameterType(int index) {\n+        return argTypes[index];\n+    }\n+\n+    @Override\n+    public List<ClassDesc> parameterList() {\n+        return List.of(argTypes);\n+    }\n+\n+    @Override\n+    public ClassDesc[] parameterArray() {\n+        return argTypes.clone();\n+    }\n+\n+    @Override\n+    public MethodTypeDesc changeReturnType(ClassDesc returnType) {\n+        return ofValidated(requireNonNull(returnType), argTypes);\n+    }\n+\n+    @Override\n+    public MethodTypeDesc changeParameterType(int index, ClassDesc paramType) {\n+        ClassDesc[] newArgs = argTypes.clone();\n+        newArgs[index] = validateArgument(paramType);\n+        return ofValidated(returnType, newArgs);\n+    }\n+\n+    @Override\n+    public MethodTypeDesc dropParameterTypes(int start, int end) {\n+        Objects.checkIndex(start, argTypes.length);\n+        Objects.checkFromToIndex(start, end, argTypes.length);\n+\n+        ClassDesc[] newArgs = new ClassDesc[argTypes.length - (end - start)];\n+        if (start > 0) {\n+            System.arraycopy(argTypes, 0, newArgs, 0, start);\n+        }\n+        if (end < argTypes.length) {\n+            System.arraycopy(argTypes, end, newArgs, start, argTypes.length - end);\n+        }\n+        return ofValidated(returnType, newArgs);\n+    }\n+\n+    @Override\n+    public MethodTypeDesc insertParameterTypes(int pos, ClassDesc... paramTypes) {\n+        if (pos < 0 || pos > argTypes.length)\n+            throw new IndexOutOfBoundsException(pos);\n+\n+        ClassDesc[] newArgs = new ClassDesc[argTypes.length + paramTypes.length];\n+        if (pos > 0) {\n+            System.arraycopy(argTypes, 0, newArgs, 0, pos);\n+        }\n+        System.arraycopy(paramTypes, 0, newArgs, pos, paramTypes.length);\n+        int destPos = pos + paramTypes.length;\n+        if (pos < argTypes.length) {\n+            System.arraycopy(argTypes, pos, newArgs, destPos, argTypes.length - pos);\n+        }\n+        \/\/ Validate after copying to avoid TOCTOU\n+        for (int i = pos; i < destPos; i++) {\n+            validateArgument(newArgs[i]);\n+        }\n+\n+        return ofValidated(returnType, newArgs);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        var desc = this.cachedDescriptorString;\n+        if (desc != null)\n+            return desc;\n+\n+        int len = 2 + returnType.descriptorString().length();\n+        for (ClassDesc argType : argTypes) {\n+            len += argType.descriptorString().length();\n+        }\n+        StringBuilder sb = new StringBuilder(len).append('(');\n+        for (ClassDesc argType : argTypes) {\n+            sb.append(argType.descriptorString());\n+        }\n+        desc = sb.append(')').append(returnType.descriptorString()).toString();\n+        cachedDescriptorString = desc;\n+        return desc;\n+    }\n+\n+    @Override\n+    public MethodType resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException {\n+        @SuppressWarnings(\"removal\")\n+        MethodType mtype = AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public MethodType run() {\n+                return MethodType.fromMethodDescriptorString(descriptorString(),\n+                                                             lookup.lookupClass().getClassLoader());\n+            }\n+        });\n+\n+        \/\/ let's check that the lookup has access to all the types in the method type\n+        lookup.accessClass(mtype.returnType());\n+        for (Class<?> paramType: mtype.parameterArray()) {\n+            lookup.accessClass(paramType);\n+        }\n+        return mtype;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@linkplain MethodTypeDescImpl} is\n+     * equal to another {@linkplain MethodTypeDescImpl}.  Equality is\n+     * determined by the two descriptors having equal return types and argument\n+     * types.\n+     *\n+     * @param o the {@code MethodTypeDescImpl} to compare to this\n+     *       {@code MethodTypeDescImpl}\n+     * @return {@code true} if the specified {@code MethodTypeDescImpl}\n+     *      is equal to this {@code MethodTypeDescImpl}.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        MethodTypeDescImpl constant = (MethodTypeDescImpl) o;\n+\n+        return returnType.equals(constant.returnType)\n+               && Arrays.equals(argTypes, constant.argTypes);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = returnType.hashCode();\n+        result = 31 * result + Arrays.hashCode(argTypes);\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"MethodTypeDesc[%s]\", displayDescriptor());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ModuleDesc;\n+\n+\/*\n+ * Implementation of {@code ModuleDesc}\n+ * @param name must have been validated\n+ *\/\n+public record ModuleDescImpl(String name) implements ModuleDesc {\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ModuleDesc[%s]\", name());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ModuleDescImpl.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.PackageDesc;\n+\n+\/*\n+ * Implementation of {@code PackageDesc}\n+ * @param internalName must have been validated\n+ *\/\n+public record PackageDescImpl(String internalName) implements PackageDesc {\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"PackageDesc[%s]\", name());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PackageDescImpl.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import sun.invoke.util.Wrapper;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for the class\n+ * constant corresponding to a primitive type (e.g., {@code int.class}).\n+ *\/\n+public final class PrimitiveClassDescImpl\n+        extends DynamicConstantDesc<Class<?>> implements ClassDesc {\n+\n+    private final String descriptor;\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} given a descriptor string for a primitive\n+     * type.\n+     *\n+     * @param descriptor the descriptor string, which must be a one-character\n+     * string corresponding to one of the nine base types\n+     * @throws IllegalArgumentException if the descriptor string does not\n+     * describe a valid primitive type\n+     * @jvms 4.3 Descriptors\n+     *\/\n+    public PrimitiveClassDescImpl(String descriptor) {\n+        super(ConstantDescs.BSM_PRIMITIVE_CLASS, requireNonNull(descriptor), ConstantDescs.CD_Class);\n+        if (descriptor.length() != 1\n+            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n+            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n+        this.descriptor = descriptor;\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) {\n+        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"PrimitiveClassDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -207,4 +208,1 @@\n-        \/\/ If we have an enclosing layout, drop the alignment check for the accessed element,\n-        \/\/ we check the root layout instead\n-        ValueLayout accessedLayout = enclosing != null ? valueLayout.withByteAlignment(1) : valueLayout;\n-        VarHandle handle = accessedLayout.varHandle();\n+        VarHandle handle = valueLayout.varHandle();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -277,2 +277,2 @@\n-                    cb.constantInstruction(null);\n-                    cb.storeInstruction(ReferenceType, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                    cb.loadConstant(null);\n+                    cb.storeLocal(ReferenceType, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n@@ -287,1 +287,1 @@\n-            cb.constantInstruction(callingSequence.allocationSize());\n+            cb.loadConstant(callingSequence.allocationSize());\n@@ -295,1 +295,1 @@\n-        cb.storeInstruction(ReferenceType, contextIdx);\n+        cb.storeLocal(ReferenceType, contextIdx);\n@@ -303,1 +303,1 @@\n-            cb.storeInstruction(ReferenceType, returnBufferIdx);\n+            cb.storeLocal(ReferenceType, returnBufferIdx);\n@@ -326,1 +326,1 @@\n-                    cb.loadInstruction(ReferenceType, returnBufferIdx);\n+                    cb.loadLocal(ReferenceType, returnBufferIdx);\n@@ -342,1 +342,1 @@\n-                    cb.storeInstruction(ReferenceType, returnBufferIdx);\n+                    cb.storeLocal(ReferenceType, returnBufferIdx);\n@@ -355,1 +355,1 @@\n-            cb.constantInstruction(CLASS_DATA_DESC);\n+            cb.loadConstant(CLASS_DATA_DESC);\n@@ -357,1 +357,1 @@\n-            cb.loadInstruction(ReferenceType, 0); \/\/ load target arg\n+            cb.loadLocal(ReferenceType, 0); \/\/ load target arg\n@@ -362,1 +362,1 @@\n-            cb.loadInstruction(TypeKind.from(leafArgTypes.get(i)), leafArgSlots[i]);\n+            cb.loadLocal(TypeKind.from(leafArgTypes.get(i)), leafArgSlots[i]);\n@@ -399,1 +399,1 @@\n-                cb.returnInstruction(TypeKind.from(callerMethodType.returnType()));\n+                cb.return_(TypeKind.from(callerMethodType.returnType()));\n@@ -414,1 +414,1 @@\n-            cb.throwInstruction();\n+            cb.athrow();\n@@ -420,1 +420,1 @@\n-                cb.returnInstruction(returnTypeKind);\n+                cb.return_(returnTypeKind);\n@@ -480,1 +480,1 @@\n-        cb.storeInstruction(TypeKind.from(storeType), leafArgSlots[leafArgTypes.size()]);\n+        cb.storeLocal(TypeKind.from(storeType), leafArgSlots[leafArgTypes.size()]);\n@@ -486,1 +486,1 @@\n-        cb.loadInstruction(TypeKind.from(highLevelType), cb.parameterSlot(paramIndex));\n+        cb.loadLocal(TypeKind.from(highLevelType), cb.parameterSlot(paramIndex));\n@@ -508,1 +508,1 @@\n-            cb.loadInstruction(ReferenceType, scopeSlots[i]);\n+            cb.loadLocal(ReferenceType, scopeSlots[i]);\n@@ -517,1 +517,1 @@\n-        cb.storeInstruction(ReferenceType, nextScopeLocal); \/\/ store off one to release later\n+        cb.storeLocal(ReferenceType, nextScopeLocal); \/\/ store off one to release later\n@@ -531,1 +531,1 @@\n-            cb.loadInstruction(ReferenceType, scopeLocal);\n+            cb.loadLocal(ReferenceType, scopeLocal);\n@@ -533,1 +533,1 @@\n-                ifCb.loadInstruction(ReferenceType, scopeLocal);\n+                ifCb.loadLocal(ReferenceType, scopeLocal);\n@@ -542,1 +542,1 @@\n-        cb.storeInstruction(typeKind, retValIdx);\n+        cb.storeLocal(typeKind, retValIdx);\n@@ -547,1 +547,1 @@\n-        cb.loadInstruction(TypeKind.from(loadType), retValIdx);\n+        cb.loadLocal(TypeKind.from(loadType), retValIdx);\n@@ -553,1 +553,1 @@\n-        cb.loadInstruction(ReferenceType, contextIdx);\n+        cb.loadLocal(ReferenceType, contextIdx);\n@@ -561,1 +561,1 @@\n-        cb.loadInstruction(ReferenceType, contextIdx);\n+        cb.loadLocal(ReferenceType, contextIdx);\n@@ -566,1 +566,1 @@\n-        cb.loadInstruction(ReferenceType, contextIdx);\n+        cb.loadLocal(ReferenceType, contextIdx);\n@@ -573,2 +573,2 @@\n-        cb.constantInstruction(boxAddress.size());\n-        cb.constantInstruction(boxAddress.align());\n+        cb.loadConstant(boxAddress.size());\n+        cb.loadConstant(boxAddress.align());\n@@ -587,1 +587,1 @@\n-            cb.loadInstruction(ReferenceType, returnAllocatorIdx);\n+            cb.loadLocal(ReferenceType, returnAllocatorIdx);\n@@ -606,1 +606,1 @@\n-            cb.storeInstruction(storeTypeKind, valueIdx);\n+            cb.storeLocal(storeTypeKind, valueIdx);\n@@ -609,2 +609,2 @@\n-            cb.constantInstruction(offset);\n-            cb.loadInstruction(storeTypeKind, valueIdx);\n+            cb.loadConstant(offset);\n+            cb.loadLocal(storeTypeKind, valueIdx);\n@@ -621,1 +621,1 @@\n-            cb.storeInstruction(LongType, longValueIdx);\n+            cb.storeLocal(LongType, longValueIdx);\n@@ -623,1 +623,1 @@\n-            cb.storeInstruction(ReferenceType, writeAddrIdx);\n+            cb.storeLocal(ReferenceType, writeAddrIdx);\n@@ -650,2 +650,2 @@\n-                cb.loadInstruction(LongType, longValueIdx);\n-                cb.constantInstruction(mask);\n+                cb.loadLocal(LongType, longValueIdx);\n+                cb.loadConstant(mask);\n@@ -654,1 +654,1 @@\n-                    cb.constantInstruction(shiftAmount);\n+                    cb.loadConstant(shiftAmount);\n@@ -660,1 +660,1 @@\n-                cb.storeInstruction(chunkStoreTypeKind, chunkIdx);\n+                cb.storeLocal(chunkStoreTypeKind, chunkIdx);\n@@ -664,1 +664,1 @@\n-                cb.loadInstruction(ReferenceType, writeAddrIdx);\n+                cb.loadLocal(ReferenceType, writeAddrIdx);\n@@ -667,2 +667,2 @@\n-                cb.constantInstruction(writeOffset);\n-                cb.loadInstruction(chunkStoreTypeKind, chunkIdx);\n+                cb.loadConstant(writeOffset);\n+                cb.loadLocal(chunkStoreTypeKind, chunkIdx);\n@@ -693,1 +693,1 @@\n-                cb.storeInstruction(storeTypeKind, valueIdx); \/\/ store away the stored value, need it later\n+                cb.storeLocal(storeTypeKind, valueIdx); \/\/ store away the stored value, need it later\n@@ -696,1 +696,1 @@\n-                cb.loadInstruction(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(ReferenceType, returnBufferIdx);\n@@ -698,2 +698,2 @@\n-                cb.constantInstruction(retBufOffset);\n-                cb.loadInstruction(storeTypeKind, valueIdx);\n+                cb.loadConstant(retBufOffset);\n+                cb.loadLocal(storeTypeKind, valueIdx);\n@@ -716,1 +716,1 @@\n-                cb.loadInstruction(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(ReferenceType, returnBufferIdx);\n@@ -718,1 +718,1 @@\n-                cb.constantInstruction(retBufOffset);\n+                cb.loadConstant(retBufOffset);\n@@ -738,1 +738,1 @@\n-        cb.constantInstruction(shiftLeft.shiftAmount() * Byte.SIZE);\n+        cb.loadConstant(shiftLeft.shiftAmount() * Byte.SIZE);\n@@ -745,1 +745,1 @@\n-        cb.constantInstruction(shiftRight.shiftAmount() * Byte.SIZE);\n+        cb.loadConstant(shiftRight.shiftAmount() * Byte.SIZE);\n@@ -760,1 +760,1 @@\n-                cb.constantInstruction(0xFF);\n+                cb.loadConstant(0xFF);\n@@ -811,1 +811,1 @@\n-            cb.constantInstruction(offset);\n+            cb.loadConstant(offset);\n@@ -817,1 +817,1 @@\n-            cb.storeInstruction(ReferenceType, readAddrIdx);\n+            cb.storeLocal(ReferenceType, readAddrIdx);\n@@ -819,1 +819,1 @@\n-            cb.constantInstruction(0L); \/\/ result\n+            cb.loadConstant(0L); \/\/ result\n@@ -821,1 +821,1 @@\n-            cb.storeInstruction(LongType, resultIdx);\n+            cb.storeLocal(LongType, resultIdx);\n@@ -850,1 +850,1 @@\n-                cb.loadInstruction(ReferenceType, readAddrIdx);\n+                cb.loadLocal(ReferenceType, readAddrIdx);\n@@ -854,1 +854,1 @@\n-                cb.constantInstruction(readOffset);\n+                cb.loadConstant(readOffset);\n@@ -861,1 +861,1 @@\n-                    cb.constantInstruction(shiftAmount);\n+                    cb.loadConstant(shiftAmount);\n@@ -865,1 +865,1 @@\n-                cb.loadInstruction(LongType, resultIdx);\n+                cb.loadLocal(LongType, resultIdx);\n@@ -867,1 +867,1 @@\n-                cb.storeInstruction(LongType, resultIdx);\n+                cb.storeLocal(LongType, resultIdx);\n@@ -873,1 +873,1 @@\n-            cb.loadInstruction(LongType, resultIdx);\n+            cb.loadLocal(LongType, resultIdx);\n@@ -893,1 +893,1 @@\n-        cb.constantInstruction(0L);\n+        cb.loadConstant(0L);\n@@ -900,3 +900,3 @@\n-        cb.storeInstruction(ReferenceType, storeIdx);\n-        cb.constantInstruction(0L);\n-        cb.constantInstruction(size);\n+        cb.storeLocal(ReferenceType, storeIdx);\n+        cb.loadConstant(0L);\n+        cb.loadConstant(size);\n@@ -905,1 +905,1 @@\n-        cb.loadInstruction(ReferenceType, storeIdx);\n+        cb.loadLocal(ReferenceType, storeIdx);\n@@ -910,2 +910,2 @@\n-        cb.constantInstruction(size);\n-        cb.constantInstruction(alignment);\n+        cb.loadConstant(size);\n+        cb.loadConstant(alignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Locale;\n@@ -40,3 +41,2 @@\n-    JdkConsole format(String fmt, Object ... args);\n-    JdkConsole printf(String format, Object ... args);\n-    String readLine(String fmt, Object ... args);\n+    JdkConsole format(Locale locale, String format, Object ... args);\n+    String readLine(Locale locale, String format, Object ... args);\n@@ -44,1 +44,1 @@\n-    char[] readPassword(String fmt, Object ... args);\n+    char[] readPassword(Locale locale, String format, Object ... args);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsole.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.Locale;\n@@ -60,2 +61,2 @@\n-    public JdkConsole format(String fmt, Object ... args) {\n-        formatter.format(fmt, args).flush();\n+    public JdkConsole format(Locale locale, String format, Object ... args) {\n+        formatter.format(locale, format, args).flush();\n@@ -66,6 +67,1 @@\n-    public JdkConsole printf(String format, Object ... args) {\n-        return format(format, args);\n-    }\n-\n-    @Override\n-    public String readLine(String fmt, Object ... args) {\n+    public String readLine(Locale locale, String format, Object ... args) {\n@@ -75,2 +71,2 @@\n-                if (!fmt.isEmpty())\n-                    pw.format(fmt, args);\n+                if (!format.isEmpty())\n+                    pw.format(locale, format, args);\n@@ -91,1 +87,1 @@\n-        return readLine(\"\");\n+        return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n@@ -95,1 +91,1 @@\n-    public char[] readPassword(String fmt, Object ... args) {\n+    public char[] readPassword(Locale locale, String format, Object ... args) {\n@@ -107,2 +103,2 @@\n-                    if (!fmt.isEmpty())\n-                        pw.format(fmt, args);\n+                    if (!format.isEmpty())\n+                        pw.format(locale, format, args);\n@@ -167,1 +163,1 @@\n-        return readPassword(\"\");\n+        return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleImpl.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+        @JEP(number=476, title=\"Module Import Declarations\", status=\"Preview\")\n+        MODULE_IMPORTS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    \/\/\/\/\/\/\/\/\/ basic attributes \/\/\/\/\/\/\/\/\/\/\/\n+    \/\/-------- basic attributes --------\n@@ -95,1 +95,1 @@\n-    \/\/\/\/\/\/\/\/\/ jrtfs specific attributes \/\/\/\/\/\/\/\/\/\/\/\n+    \/\/-------- jrtfs specific attributes --------\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileAttributes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.io.PrintStream;\n@@ -499,0 +500,7 @@\n+\n+    \/**\n+     * Return the initial value of System.err that was set during VM initialization.\n+     *\/\n+    public static PrintStream initialErr() {\n+        return SharedSecrets.getJavaLangAccess().initialSystemErr();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L128X1024MixRandom\",\n-        group = \"LXM\",\n-        i = 1024, j = 1, k = 128,\n-        equidistribution = 1\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L128X1024MixRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L128X1024MixRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L128X128MixRandom\",\n-        group = \"LXM\",\n-        i = 128, j = 1, k = 128,\n-        equidistribution = 1\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L128X128MixRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L128X128MixRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L128X256MixRandom\",\n-        group = \"LXM\",\n-        i = 256, j = 1, k = 128,\n-        equidistribution = 1\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L128X256MixRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L128X256MixRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L32X64MixRandom\",\n-        group = \"LXM\",\n-        i = 64, j = 1, k = 32,\n-        equidistribution = 1\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L32X64MixRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L32X64MixRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L64X1024MixRandom\",\n-        group = \"LXM\",\n-        i = 1024, j = 1, k = 64,\n-        equidistribution = 16\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L64X1024MixRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X1024MixRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L64X128MixRandom\",\n-        group = \"LXM\",\n-        i = 128, j = 1, k = 64,\n-        equidistribution = 2\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L64X128MixRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X128MixRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L64X128StarStarRandom\",\n-        group = \"LXM\",\n-        i = 128, j = 1, k = 64,\n-        equidistribution = 2\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L64X128StarStarRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X128StarStarRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -78,6 +77,0 @@\n-@RandomGeneratorProperties(\n-        name = \"L64X256MixRandom\",\n-        group = \"LXM\",\n-        i = 256, j = 1, k = 64,\n-        equidistribution = 4\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/L64X256MixRandom.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L64X256MixRandom.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -75,6 +74,0 @@\n-@RandomGeneratorProperties(\n-        name = \"Xoroshiro128PlusPlus\",\n-        group = \"Xoroshiro\",\n-        i = 128, j = 1, k = 0,\n-        equidistribution = 1\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/Xoroshiro128PlusPlus.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/Xoroshiro128PlusPlus.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.random;\n+package jdk.internal.random;\n@@ -32,1 +32,0 @@\n-import jdk.internal.util.random.RandomSupport.RandomGeneratorProperties;\n@@ -90,6 +89,0 @@\n-@RandomGeneratorProperties(\n-        name = \"Xoshiro256PlusPlus\",\n-        group = \"Xoshiro\",\n-        i = 256, j = 1, k = 0,\n-        equidistribution = 3\n-)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/random\/Xoshiro256PlusPlus.java","additions":2,"deletions":9,"binary":false,"changes":11,"previous_filename":"src\/jdk.random\/share\/classes\/jdk\/random\/Xoshiro256PlusPlus.java","status":"renamed"},{"patch":"@@ -103,0 +103,15 @@\n+    \/**\n+     * @return a supplier to create a {@code ConcurrentHashMap} appropriate for use in the\n+     *         create methods.\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    public static <K, V> Supplier<Map<ReferenceKey<K>, V>> concurrentHashMapSupplier() {\n+        return new Supplier<>() {\n+            @Override\n+            public Map<ReferenceKey<K>, V> get() {\n+                return new ConcurrentHashMap<>();\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,9 @@\n+    \/**\n+     * @return a supplier to create a {@code ConcurrentHashMap} appropriate for use in the\n+     *         create methods.\n+     * @param <E> the type of elements maintained by this set\n+     *\/\n+    public static <E> Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> concurrentHashMapSupplier() {\n+        return ReferencedKeyMap.concurrentHashMapSupplier();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.lang.annotation.*;\n-import java.math.BigInteger;\n@@ -31,1 +29,0 @@\n-import java.util.Random;\n@@ -56,43 +53,0 @@\n-    \/**\n-     * Annotation providing RandomGenerator properties.\n-     *\/\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface RandomGeneratorProperties {\n-        \/**\n-         * Name of algorithm.\n-         *\/\n-        String name();\n-\n-        \/**\n-         * Category of algorithm.\n-         *\/\n-        String group() default \"Legacy\";\n-\n-        \/**\n-         * Algorithm period defined as:\n-         *\n-         * BigInteger.ONE.shiftLeft(i)\n-         *               .subtract(j)\n-         *               .shiftLeft(k)\n-         *\/\n-        int i() default 0;\n-        int j() default 0;\n-        int k() default 0;\n-\n-        \/**\n-         * The equidistribution of the algorithm.\n-         *\/\n-        int equidistribution() default Integer.MAX_VALUE;\n-\n-        \/**\n-         * Is the algorithm based on entropy (true random.)\n-         *\/\n-        boolean isStochastic() default false;\n-\n-        \/**\n-         * Is the algorithm assisted by hardware (fast true random.)\n-         *\/\n-        boolean isHardware() default false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":1,"deletions":47,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    private int argsize; \/\/ bottom stack-passed arguments, in words\n+    private int bottom;  \/\/ in words\n@@ -39,1 +39,1 @@\n-    public boolean isEmpty()   { return sp >= (size - argsize); }\n+    public boolean isEmpty()   { return sp == bottom; }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/StackChunk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,2 +270,0 @@\n-    exports jdk.internal.util.random to\n-        jdk.random;\n@@ -400,1 +398,0 @@\n-    uses java.util.random.RandomGenerator;\n@@ -426,5 +423,0 @@\n-    provides java.util.random.RandomGenerator with\n-        java.security.SecureRandom,\n-        java.util.Random,\n-        java.util.SplittableRandom;\n-\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -404,1 +404,1 @@\n-    @Deprecated\n+    @SuppressWarnings(\"removal\")\n@@ -420,1 +420,1 @@\n-    @Deprecated\n+    @SuppressWarnings(\"removal\")\n@@ -595,1 +595,1 @@\n-    @Deprecated\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+import jdk.internal.util.ArraysSupport;\n+import sun.security.action.GetPropertyAction;\n+\n@@ -37,0 +40,2 @@\n+    private static final int DEFAULT_MAX_EVENT_LIST_SIZE = 512;\n+\n@@ -38,1 +43,1 @@\n-     * Maximum size of event list (in the future this may be tunable)\n+     * Maximum size of event list before dropping events and signalling OVERFLOW\n@@ -40,1 +45,18 @@\n-    static final int MAX_EVENT_LIST_SIZE    = 512;\n+    static final int MAX_EVENT_LIST_SIZE;\n+    static {\n+        String rawValue = GetPropertyAction.privilegedGetProperty(\n+            \"jdk.nio.file.WatchService.maxEventsPerPoll\",\n+            String.valueOf(DEFAULT_MAX_EVENT_LIST_SIZE));\n+        int intValue;\n+        try {\n+            \/\/ Clamp to max array length to signal OVERFLOW and drop events\n+            \/\/ before OOMing.\n+            intValue = Math.clamp(\n+                Long.decode(rawValue),\n+                1,\n+                ArraysSupport.SOFT_MAX_ARRAY_LENGTH);\n+        } catch (NumberFormatException e) {\n+            intValue = DEFAULT_MAX_EVENT_LIST_SIZE;\n+        }\n+        MAX_EVENT_LIST_SIZE = intValue;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractWatchKey.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n@@ -268,0 +269,5 @@\n+        if (field instanceof IntegerMontgomeryFieldModuloP) {\n+            \/\/ No point of doing a single SmallValue operation in Montgomery domain\n+            field = ((IntegerMontgomeryFieldModuloP)field).residueField();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-        ecOps.setSum(p1, p2.asAffine());\n+        ecOps.setSum(p1, p2);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-\n@@ -51,4 +50,0 @@\n-    private static final ECOperations secp256r1Ops =\n-        new ECOperations(IntegerPolynomialP256.ONE.getElement(\n-                CurveDB.lookup(KnownOIDs.secp256r1.value()).getCurve().getB()),\n-                P256OrderField.ONE);\n@@ -67,1 +62,1 @@\n-        IntegerPolynomialP256.MODULUS, IntegerPolynomialP256.ONE,\n+        IntegerPolynomialP256.MODULUS, MontgomeryIntegerPolynomialP256.ONE,\n@@ -210,1 +205,10 @@\n-        return PointMultiplier.of(this, affineP).pointMultiply(s);\n+        PointMultiplier multiplier = null;\n+        if (getField() instanceof IntegerMontgomeryFieldModuloP\n+                && affineP.equals(Secp256R1GeneratorMontgomeryMultiplier.generator)) {\n+            \/\/ Lazy class loading here\n+            multiplier = Secp256R1GeneratorMontgomeryMultiplier.multiplier;\n+        } else {\n+            multiplier = new DefaultMultiplier(this, affineP);\n+        }\n+\n+        return multiplier.pointMultiply(s);\n@@ -213,0 +217,8 @@\n+    \/**\n+     * Multiply an affine ecpoint point by a scalar and return the result as a\n+     * mutable point.\n+     *\n+     * @param ecPoint the point\n+     * @param s the scalar as a little-endian array\n+     * @return the product\n+     *\/\n@@ -214,1 +226,1 @@\n-        return PointMultiplier.of(this, ecPoint).pointMultiply(s);\n+        return multiply(AffinePoint.fromECPoint(ecPoint, getField()), s);\n@@ -267,4 +279,9 @@\n-    \/*\n-     * Mixed point addition. This method constructs new temporaries each time\n-     * it is called. For better efficiency, the method that reuses temporaries\n-     * should be used if more than one sum will be computed.\n+    \/**\n+     * Adds second Mutable (Projective) point to first.\n+     *\n+     * Used by ECDSAOperations. This method constructs new temporaries each time\n+     * it is called. For better efficiency, the (private) method that reuses\n+     * temporaries should be used if more than one sum will be computed.\n+     *\n+     * @param p first point and result\n+     * @param p2 second point to add\n@@ -272,2 +289,1 @@\n-    public void setSum(MutablePoint p, AffinePoint p2) {\n-\n+    public void setSum(MutablePoint p, MutablePoint p2) {\n@@ -280,1 +296,0 @@\n-        setSum((ProjectivePoint.Mutable) p, p2, t0, t1, t2, t3, t4);\n@@ -282,0 +297,2 @@\n+        setSum((ProjectivePoint.Mutable) p, (ProjectivePoint.Mutable) p2,\n+            t0, t1, t2, t3, t4);\n@@ -292,3 +309,3 @@\n-        t0.setValue(p.getX()).setProduct(p2.getX());\n-        t1.setValue(p.getY()).setProduct(p2.getY());\n-        t3.setValue(p2.getX()).setSum(p2.getY());\n+        t0.setValue(p.getX()).setProduct(p2.getX(false));\n+        t1.setValue(p.getY()).setProduct(p2.getY(false));\n+        t3.setValue(p2.getX(false)).setSum(p2.getY(false));\n@@ -300,1 +317,1 @@\n-        t4.setValue(p2.getY()).setProduct(p.getZ());\n+        t4.setValue(p2.getY(false)).setProduct(p.getZ());\n@@ -303,1 +320,1 @@\n-        p.getY().setValue(p2.getX()).setProduct(p.getZ());\n+        p.getY().setValue(p2.getX(false)).setProduct(p.getZ());\n@@ -415,5 +432,2 @@\n-    sealed interface PointMultiplier {\n-        Map<ECPoint, PointMultiplier> multipliers = Map.of(\n-                Secp256R1GeneratorMultiplier.generator,\n-                Secp256R1GeneratorMultiplier.multiplier);\n-\n+    sealed interface PointMultiplier\n+        permits DefaultMultiplier, Secp256R1GeneratorMontgomeryMultiplier {\n@@ -432,20 +446,0 @@\n-        static PointMultiplier of(ECOperations ecOps, AffinePoint affPoint) {\n-            PointMultiplier multiplier = multipliers.get(affPoint.toECPoint());\n-            if (multiplier == null) {\n-                multiplier = new Default(ecOps, affPoint);\n-            }\n-\n-            return multiplier;\n-        }\n-\n-        static PointMultiplier of(ECOperations ecOps, ECPoint ecPoint) {\n-            PointMultiplier multiplier = multipliers.get(ecPoint);\n-            if (multiplier == null) {\n-                AffinePoint affPoint =\n-                        AffinePoint.fromECPoint(ecPoint, ecOps.getField());\n-                multiplier = new Default(ecOps, affPoint);\n-            }\n-\n-            return multiplier;\n-        }\n-\n@@ -468,0 +462,1 @@\n+    }\n@@ -469,3 +464,3 @@\n-        final class Default implements PointMultiplier {\n-            private final AffinePoint affineP;\n-            private final ECOperations ecOps;\n+    final static class DefaultMultiplier implements PointMultiplier {\n+        private final ECOperations ecOps;\n+        private final ProjectivePoint.Immutable[] pointMultiples;\n@@ -473,4 +468,2 @@\n-            private Default(ECOperations ecOps, AffinePoint affineP) {\n-                this.ecOps = ecOps;\n-                this.affineP = affineP;\n-            }\n+        DefaultMultiplier(ECOperations ecOps, AffinePoint affineP) {\n+            this.ecOps = ecOps;\n@@ -478,34 +471,2 @@\n-            @Override\n-            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-                \/\/ 4-bit windowed multiply with branchless lookup.\n-                \/\/ The mixed addition is faster, so it is used to construct\n-                \/\/ the array at the beginning of the operation.\n-\n-                IntegerFieldModuloP field = affineP.getX().getField();\n-                ImmutableIntegerModuloP zero = field.get0();\n-                \/\/ temporaries\n-                MutableIntegerModuloP t0 = zero.mutable();\n-                MutableIntegerModuloP t1 = zero.mutable();\n-                MutableIntegerModuloP t2 = zero.mutable();\n-                MutableIntegerModuloP t3 = zero.mutable();\n-                MutableIntegerModuloP t4 = zero.mutable();\n-\n-                ProjectivePoint.Mutable result =\n-                        new ProjectivePoint.Mutable(field);\n-                result.getY().setValue(field.get1().mutable());\n-\n-                ProjectivePoint.Immutable[] pointMultiples =\n-                        new ProjectivePoint.Immutable[16];\n-                \/\/ 0P is neutral---same as initial result value\n-                pointMultiples[0] = result.fixed();\n-\n-                ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);\n-                ps.setValue(affineP);\n-                \/\/ 1P = P\n-                pointMultiples[1] = ps.fixed();\n-\n-                \/\/ the rest are calculated using mixed point addition\n-                for (int i = 2; i < 16; i++) {\n-                    ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n-                    pointMultiples[i] = ps.fixed();\n-                }\n+            \/\/ Precompute and cache point multiples\n+            this.pointMultiples = new ProjectivePoint.Immutable[16];\n@@ -513,1 +474,8 @@\n-                ProjectivePoint.Mutable lookupResult = ps.mutable();\n+            IntegerFieldModuloP field = ecOps.getField();\n+            ImmutableIntegerModuloP zero = field.get0();\n+            \/\/ temporaries\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n@@ -515,2 +483,3 @@\n-                for (int i = s.length - 1; i >= 0; i--) {\n-                    double4(result, t0, t1, t2, t3, t4);\n+            ProjectivePoint.Mutable ps =\n+                new ProjectivePoint.Mutable(field);\n+            ps.getY().setValue(field.get1().mutable());\n@@ -518,3 +487,2 @@\n-                    int high = (0xFF & s[i]) >>> 4;\n-                    lookup(pointMultiples, high, lookupResult);\n-                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+            \/\/ 0P is neutral---same as initial result value\n+            pointMultiples[0] = ps.fixed();\n@@ -522,1 +490,3 @@\n-                    double4(result, t0, t1, t2, t3, t4);\n+            ps.setValue(affineP);\n+            \/\/ 1P = P\n+            pointMultiples[1] = ps.fixed();\n@@ -524,4 +494,6 @@\n-                    int low = 0xF & s[i];\n-                    lookup(pointMultiples, low, lookupResult);\n-                    ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n-                }\n+            \/\/ the rest are calculated using mixed point addition\n+            for (int i = 2; i < 16; i++) {\n+                ecOps.setSum(ps, affineP, t0, t1, t2, t3, t4);\n+                pointMultiples[i] = ps.fixed();\n+            }\n+        }\n@@ -529,1 +501,31 @@\n-                return result;\n+        @Override\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            \/\/ 4-bit windowed multiply with branchless lookup.\n+            \/\/ The mixed addition is faster, so it is used to construct\n+            \/\/ the array at the beginning of the operation.\n+\n+            IntegerFieldModuloP field = ecOps.getField();\n+            ImmutableIntegerModuloP zero = field.get0();\n+            \/\/ temporaries\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable result = new ProjectivePoint.Mutable(field);\n+            result.getY().setValue(field.get1().mutable());\n+            ProjectivePoint.Mutable lookupResult = new ProjectivePoint.Mutable(field);\n+\n+            for (int i = s.length - 1; i >= 0; i--) {\n+                double4(result, t0, t1, t2, t3, t4);\n+\n+                int high = (0xFF & s[i]) >>> 4;\n+                PointMultiplier.lookup(pointMultiples, high, lookupResult);\n+                ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n+\n+                double4(result, t0, t1, t2, t3, t4);\n+\n+                int low = 0xF & s[i];\n+                PointMultiplier.lookup(pointMultiples, low, lookupResult);\n+                ecOps.setSum(result, lookupResult, t0, t1, t2, t3, t4);\n@@ -532,7 +534,37 @@\n-            private void double4(ProjectivePoint.Mutable p,\n-                    MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n-                    MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n-                    MutableIntegerModuloP t4) {\n-                for (int i = 0; i < 4; i++) {\n-                    ecOps.setDouble(p, t0, t1, t2, t3, t4);\n-                }\n+            return result;\n+        }\n+\n+        private void double4(ProjectivePoint.Mutable p,\n+                MutableIntegerModuloP t0, MutableIntegerModuloP t1,\n+                MutableIntegerModuloP t2, MutableIntegerModuloP t3,\n+                MutableIntegerModuloP t4) {\n+            for (int i = 0; i < 4; i++) {\n+                ecOps.setDouble(p, t0, t1, t2, t3, t4);\n+            }\n+        }\n+    }\n+\n+    \/\/ Represents a multiplier with a larger precomputed table. Intended to be\n+    \/\/ used for Basepoint multiplication\n+    final static class Secp256R1GeneratorMontgomeryMultiplier\n+        implements PointMultiplier {\n+        private static final ECOperations secp256r1Ops = new ECOperations(\n+            MontgomeryIntegerPolynomialP256.ONE.getElement(\n+                    CurveDB.P_256.getCurve().getB()), P256OrderField.ONE);\n+        public static final AffinePoint generator = AffinePoint.fromECPoint(\n+            CurveDB.P_256.getGenerator(), secp256r1Ops.getField());\n+        public static final PointMultiplier multiplier =\n+            new Secp256R1GeneratorMontgomeryMultiplier();\n+\n+        private final ImmutableIntegerModuloP zero;\n+        private final ImmutableIntegerModuloP one;\n+        private final ProjectivePoint.Immutable[][] points;\n+        private final BigInteger[] base;\n+\n+        private Secp256R1GeneratorMontgomeryMultiplier() {\n+            this(MontgomeryIntegerPolynomialP256.ONE,\n+                new DefaultMultiplier(secp256r1Ops, generator));\n+\n+            \/\/ Check that the tables are correctly generated.\n+            if (ECOperations.class.desiredAssertionStatus()) {\n+                verifyTables(this);\n@@ -542,35 +574,52 @@\n-        final class Secp256R1GeneratorMultiplier implements PointMultiplier {\n-            private static final ECPoint generator =\n-                    CurveDB.P_256.getGenerator();\n-            private static final PointMultiplier multiplier =\n-                    new Secp256R1GeneratorMultiplier();\n-\n-            private static final ImmutableIntegerModuloP zero =\n-                    IntegerPolynomialP256.ONE.get0();\n-            private static final ImmutableIntegerModuloP one =\n-                    IntegerPolynomialP256.ONE.get1();\n-\n-            @Override\n-            public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n-                MutableIntegerModuloP t0 = zero.mutable();\n-                MutableIntegerModuloP t1 = zero.mutable();\n-                MutableIntegerModuloP t2 = zero.mutable();\n-                MutableIntegerModuloP t3 = zero.mutable();\n-                MutableIntegerModuloP t4 = zero.mutable();\n-\n-                ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n-                        zero.mutable(),\n-                        one.mutable(),\n-                        zero.mutable());\n-                ProjectivePoint.Mutable r = d.mutable();\n-                for (int i = 15; i >= 0; i--) {\n-                    secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n-                    for (int j = 3; j >= 0; j--) {\n-                        int pos = i + j * 16;\n-                        int index = (bit(s, pos + 192) << 3) |\n-                                    (bit(s, pos + 128) << 2) |\n-                                    (bit(s, pos +  64) << 1) |\n-                                     bit(s, pos);\n-\n-                        lookup(P256.points[j], index, r);\n-                        secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+        private Secp256R1GeneratorMontgomeryMultiplier(\n+            IntegerFieldModuloP field, PointMultiplier smallTableMultiplier) {\n+            zero = field.get0();\n+            one = field.get1();\n+\n+            \/\/ Pre-computed table to speed up the point multiplication.\n+            \/\/\n+            \/\/ This is a 4x16 array of ProjectivePoint.Immutable elements.\n+            \/\/ The first row contains the following multiples of the\n+            \/\/ generator.\n+            \/\/\n+            \/\/ index   |    point\n+            \/\/ --------+----------------\n+            \/\/ 0x0000  | 0G\n+            \/\/ 0x0001  | 1G\n+            \/\/ 0x0002  | (2^64)G\n+            \/\/ 0x0003  | (2^64 + 1)G\n+            \/\/ 0x0004  | 2^128G\n+            \/\/ 0x0005  | (2^128 + 1)G\n+            \/\/ 0x0006  | (2^128 + 2^64)G\n+            \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n+            \/\/ 0x0008  | 2^192G\n+            \/\/ 0x0009  | (2^192 + 1)G\n+            \/\/ 0x000A  | (2^192 + 2^64)G\n+            \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n+            \/\/ 0x000C  | (2^192 + 2^128)G\n+            \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n+            \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n+            \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n+            \/\/\n+            \/\/ For the other 3 rows, points[i][j] = 2^16 * (points[i-1][j].\n+\n+            \/\/ Generate the pre-computed tables.  This block may be\n+            \/\/ replaced with hard-coded tables in order to speed up\n+            \/\/ the class loading.\n+            points = new ProjectivePoint.Immutable[4][16];\n+            BigInteger[] factors = new BigInteger[] {\n+                    BigInteger.ONE,\n+                    BigInteger.TWO.pow(64),\n+                    BigInteger.TWO.pow(128),\n+                    BigInteger.TWO.pow(192)\n+            };\n+\n+            base = new BigInteger[16];\n+            base[0] = BigInteger.ZERO;\n+            base[1] = BigInteger.ONE;\n+            base[2] = factors[1];\n+            for (int i = 3; i < 16; i++) {\n+                base[i] = BigInteger.ZERO;\n+                for (int k = 0; k < 4; k++) {\n+                    if (((i >>> k) & 0x01) != 0) {\n+                        base[i] = base[i].add(factors[k]);\n@@ -579,0 +628,1 @@\n+            }\n@@ -580,1 +630,16 @@\n-                return d;\n+            for (int d = 0; d < 4; d++) {\n+                for (int w = 0; w < 16; w++) {\n+                    BigInteger bi = base[w];\n+                    if (d != 0) {\n+                        bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n+                    }\n+                    if (w == 0) {\n+                        points[d][0] = new ProjectivePoint.Immutable(\n+                            zero.fixed(), one.fixed(), zero.fixed());\n+                    } else {\n+                        byte[] s = bi.toByteArray();\n+                        ArrayUtil.reverse(s);\n+                        ProjectivePoint.Mutable m = smallTableMultiplier.pointMultiply(s);\n+                        points[d][w] = m.fixed();\n+                    }\n+                }\n@@ -582,0 +647,1 @@\n+        }\n@@ -583,2 +649,24 @@\n-            private static int bit(byte[] k, int i) {\n-                return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+        public ProjectivePoint.Mutable pointMultiply(byte[] s) {\n+            MutableIntegerModuloP t0 = zero.mutable();\n+            MutableIntegerModuloP t1 = zero.mutable();\n+            MutableIntegerModuloP t2 = zero.mutable();\n+            MutableIntegerModuloP t3 = zero.mutable();\n+            MutableIntegerModuloP t4 = zero.mutable();\n+\n+            ProjectivePoint.Mutable d = new ProjectivePoint.Mutable(\n+                    zero.mutable(),\n+                    one.mutable(),\n+                    zero.mutable());\n+            ProjectivePoint.Mutable r = d.mutable();\n+            for (int i = 15; i >= 0; i--) {\n+                secp256r1Ops.setDouble(d, t0, t1, t2, t3, t4);\n+                for (int j = 3; j >= 0; j--) {\n+                    int pos = i + j * 16;\n+                    int index = (bit(s, pos + 192) << 3) |\n+                                (bit(s, pos + 128) << 2) |\n+                                (bit(s, pos +  64) << 1) |\n+                                    bit(s, pos);\n+\n+                    PointMultiplier.lookup(points[j], index, r);\n+                    secp256r1Ops.setSum(d, r, t0, t1, t2, t3, t4);\n+                }\n@@ -587,54 +675,2 @@\n-            \/\/ Lazy loading of the tables.\n-            private static final class P256 {\n-                \/\/ Pre-computed table to speed up the point multiplication.\n-                \/\/\n-                \/\/ This is a 4x16 array of ProjectivePoint.Immutable elements.\n-                \/\/ The first row contains the following multiples of the\n-                \/\/ generator.\n-                \/\/\n-                \/\/ index   |    point\n-                \/\/ --------+----------------\n-                \/\/ 0x0000  | 0G\n-                \/\/ 0x0001  | 1G\n-                \/\/ 0x0002  | (2^64)G\n-                \/\/ 0x0003  | (2^64 + 1)G\n-                \/\/ 0x0004  | 2^128G\n-                \/\/ 0x0005  | (2^128 + 1)G\n-                \/\/ 0x0006  | (2^128 + 2^64)G\n-                \/\/ 0x0007  | (2^128 + 2^64 + 1)G\n-                \/\/ 0x0008  | 2^192G\n-                \/\/ 0x0009  | (2^192 + 1)G\n-                \/\/ 0x000A  | (2^192 + 2^64)G\n-                \/\/ 0x000B  | (2^192 + 2^64 + 1)G\n-                \/\/ 0x000C  | (2^192 + 2^128)G\n-                \/\/ 0x000D  | (2^192 + 2^128 + 1)G\n-                \/\/ 0x000E  | (2^192 + 2^128 + 2^64)G\n-                \/\/ 0x000F  | (2^192 + 2^128 + 2^64 + 1)G\n-                \/\/\n-                \/\/ For the other 3 rows, points[i][j] = 2^16 * (points[i-1][j].\n-                private static final ProjectivePoint.Immutable[][] points;\n-\n-                \/\/ Generate the pre-computed tables.  This block may be\n-                \/\/ replaced with hard-coded tables in order to speed up\n-                \/\/ the class loading.\n-                static {\n-                    points = new ProjectivePoint.Immutable[4][16];\n-                    BigInteger[] factors = new BigInteger[] {\n-                            BigInteger.ONE,\n-                            BigInteger.TWO.pow(64),\n-                            BigInteger.TWO.pow(128),\n-                            BigInteger.TWO.pow(192)\n-                    };\n-\n-                    BigInteger[] base = new BigInteger[16];\n-                    base[0] = BigInteger.ZERO;\n-                    base[1] = BigInteger.ONE;\n-                    base[2] = factors[1];\n-                    for (int i = 3; i < 16; i++) {\n-                        base[i] = BigInteger.ZERO;\n-                        for (int k = 0; k < 4; k++) {\n-                            if (((i >>> k) & 0x01) != 0) {\n-                                base[i] = base[i].add(factors[k]);\n-                            }\n-                        }\n-                    }\n+            return d;\n+        }\n@@ -642,21 +678,3 @@\n-                    for (int d = 0; d < 4; d++) {\n-                        for (int w = 0; w < 16; w++) {\n-                            BigInteger bi = base[w];\n-                            if (d != 0) {\n-                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                            }\n-                            if (w == 0) {\n-                                points[d][0] = new ProjectivePoint.Immutable(\n-                                    zero.fixed(), one.fixed(), zero.fixed());\n-                            } else {\n-                                PointMultiplier multiplier = new Default(\n-                                    secp256r1Ops, AffinePoint.fromECPoint(\n-                                        generator, zero.getField()));\n-                                byte[] s = bi.toByteArray();\n-                                ArrayUtil.reverse(s);\n-                                ProjectivePoint.Mutable m =\n-                                        multiplier.pointMultiply(s);\n-                                points[d][w] = m.setValue(m.asAffine()).fixed();\n-                            }\n-                        }\n-                    }\n+        private static int bit(byte[] k, int i) {\n+            return (k[i >> 3] >> (i & 0x07)) & 0x01;\n+        }\n@@ -664,3 +682,6 @@\n-                    \/\/ Check that the tables are correctly generated.\n-                    if (ECOperations.class.desiredAssertionStatus()) {\n-                        verifyTables(base);\n+        protected void verifyTables(PointMultiplier multiplier) {\n+            for (int d = 0; d < 4; d++) {\n+                for (int w = 0; w < 16; w++) {\n+                    BigInteger bi = base[w];\n+                    if (d != 0) {\n+                        bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n@@ -668,26 +689,16 @@\n-                }\n-\n-                private static void verifyTables(BigInteger[] base) {\n-                    for (int d = 0; d < 4; d++) {\n-                        for (int w = 0; w < 16; w++) {\n-                            BigInteger bi = base[w];\n-                            if (d != 0) {\n-                                bi = bi.multiply(BigInteger.TWO.pow(d * 16));\n-                            }\n-                            if (w != 0) {\n-                                byte[] s = new byte[32];\n-                                byte[] b = bi.toByteArray();\n-                                ArrayUtil.reverse(b);\n-                                System.arraycopy(b, 0, s, 0, b.length);\n-\n-                                ProjectivePoint.Mutable m =\n-                                        multiplier.pointMultiply(s);\n-                                ProjectivePoint.Immutable v =\n-                                        m.setValue(m.asAffine()).fixed();\n-                                if (!v.getX().asBigInteger().equals(\n-                                        points[d][w].getX().asBigInteger()) ||\n-                                    !v.getY().asBigInteger().equals(\n-                                        points[d][w].getY().asBigInteger())) {\n-                                    throw new RuntimeException();\n-                                }\n-                            }\n+                    if (w != 0) {\n+                        byte[] s = new byte[32];\n+                        byte[] b = bi.toByteArray();\n+                        ArrayUtil.reverse(b);\n+                        System.arraycopy(b, 0, s, 0, b.length);\n+\n+                        \/\/ Compare this multiplier to the table\n+                        \/\/ (generated by Default multiplier)\n+                        AffinePoint m = multiplier.pointMultiply(s).asAffine();\n+                        AffinePoint v = points[d][w].asAffine();\n+                        if (!m.equals(v)) {\n+                            java.util.HexFormat hex = java.util.HexFormat.of();\n+                            throw new RuntimeException(\n+                                \"Bad multiple found at [\" +d+\"][\"+w+\"]\" +\n+                                hex.formatHex(s) + \" \" + m.getX().asBigInteger()\n+                            );\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":259,"deletions":248,"binary":false,"changes":507,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n@@ -57,1 +58,1 @@\n-        return new ECPoint(x.asBigInteger(), y.asBigInteger());\n+        return new ECPoint(getX().asBigInteger(), getY().asBigInteger());\n@@ -61,0 +62,8 @@\n+        return getX(true);\n+    }\n+\n+    public ImmutableIntegerModuloP getX(boolean fieldCheck) {\n+        IntegerFieldModuloP field = x.getField();\n+        if (fieldCheck && field instanceof IntegerMontgomeryFieldModuloP) {\n+            return ((IntegerMontgomeryFieldModuloP)field).fromMontgomery(x);\n+        }\n@@ -65,0 +74,8 @@\n+        return getY(true);\n+    }\n+\n+    public ImmutableIntegerModuloP getY(boolean fieldCheck) {\n+        IntegerFieldModuloP field = y.getField();\n+        if (fieldCheck && field instanceof IntegerMontgomeryFieldModuloP) {\n+            return ((IntegerMontgomeryFieldModuloP)field).fromMontgomery(y);\n+        }\n@@ -74,2 +91,24 @@\n-        boolean xEquals = x.asBigInteger().equals(p.x.asBigInteger());\n-        boolean yEquals = y.asBigInteger().equals(p.y.asBigInteger());\n+        boolean xEquals, yEquals;\n+        boolean thisMont = x.getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean objMont = p.x.getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (thisMont ^ objMont == false) {\n+            \/\/ both fields same\n+            xEquals = x.asBigInteger().equals(p.x.asBigInteger());\n+            yEquals = y.asBigInteger().equals(p.y.asBigInteger());\n+        } else if (thisMont) {\n+            \/\/ mismatched fields should not happen in production, but useful in\n+            \/\/ testing\n+            IntegerMontgomeryFieldModuloP field =\n+                (IntegerMontgomeryFieldModuloP)x.getField();\n+            xEquals = x.asBigInteger().equals(\n+                field.getElement(p.x.asBigInteger()).asBigInteger());\n+            yEquals = y.asBigInteger().equals(\n+                field.getElement(p.y.asBigInteger()).asBigInteger());\n+        } else {\n+            IntegerMontgomeryFieldModuloP field =\n+                (IntegerMontgomeryFieldModuloP)p.x.getField();\n+            xEquals = field.getElement(\n+                x.asBigInteger()).asBigInteger().equals(p.x.asBigInteger());\n+            yEquals = field.getElement(\n+                y.asBigInteger()).asBigInteger().equals(p.y.asBigInteger());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -148,0 +149,1 @@\n+        @ForceInline\n@@ -160,3 +162,3 @@\n-            x.setValue(p.getX());\n-            y.setValue(p.getY());\n-            z.setValue(p.getX().getField().get1());\n+            x.setValue(p.getX(false));\n+            y.setValue(p.getY(false));\n+            z.setValue(p.getX(false).getField().get1());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/ProjectivePoint.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -372,2 +372,2 @@\n-        if (preferredPropList != null &&\n-                (pList = preferredPropList.getAll(type, name)) != null) {\n+        if (preferredPropList != null) {\n+            pList = preferredPropList.getAll(type, name);\n@@ -376,0 +376,3 @@\n+                if (p == null) {\n+                    continue;\n+                }\n@@ -382,1 +385,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderList.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util.math;\n+\n+import java.math.BigInteger;\n+\n+\/**\n+ * An interface for the field of integers modulo a prime number. An\n+ * implementation of this interface can be used to get properties of the\n+ * field and to produce field elements of type ImmutableIntegerModuloP from\n+ * other objects and representations of field elements.\n+ *\/\n+\n+public interface IntegerMontgomeryFieldModuloP extends IntegerFieldModuloP {\n+    ImmutableIntegerModuloP fromMontgomery(ImmutableIntegerModuloP m);\n+    IntegerFieldModuloP residueField();\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/IntegerMontgomeryFieldModuloP.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n@@ -65,4 +68,3 @@\n-            IntegerPolynomialP384, IntegerPolynomialP521,\n-            IntegerPolynomialModBinP, P256OrderField,\n-            P384OrderField, P521OrderField,\n-            Curve25519OrderField,\n+            MontgomeryIntegerPolynomialP256, IntegerPolynomialP384,\n+            IntegerPolynomialP521, IntegerPolynomialModBinP, P256OrderField,\n+            P384OrderField, P521OrderField, Curve25519OrderField,\n@@ -77,1 +79,2 @@\n-    private final int maxAdds;\n+    private final int maxAddsMul; \/\/ max additions before a multiplication\n+    private final int maxAddsAdd; \/\/ max additions before an addition\n@@ -90,1 +93,1 @@\n-    protected void multByInt(long[] a, long b) {\n+    protected int multByInt(long[] a, long b) {\n@@ -95,0 +98,1 @@\n+        return 0;\n@@ -103,1 +107,1 @@\n-    protected abstract void mult(long[] a, long[] b, long[] r);\n+    protected abstract int mult(long[] a, long[] b, long[] r);\n@@ -111,1 +115,1 @@\n-    protected abstract void square(long[] a, long[] r);\n+    protected abstract int square(long[] a, long[] r);\n@@ -115,1 +119,1 @@\n-                      int maxAdds,\n+                      int maxAddsMul,\n@@ -122,2 +126,6 @@\n-        this.maxAdds = maxAdds;\n-\n+        this.maxAddsMul = maxAddsMul;\n+        if (bitsPerLimb>32) {\n+            this.maxAddsAdd = 64 - bitsPerLimb;\n+        } else {\n+            this.maxAddsAdd = 32 - bitsPerLimb;\n+        }\n@@ -138,1 +146,1 @@\n-        return maxAdds;\n+        return maxAddsMul;\n@@ -330,1 +338,0 @@\n-        assert bitsPerLimb < 32;\n@@ -333,1 +340,1 @@\n-            limbs[i] = v.intValue() & limbMask;\n+            limbs[i] = v.longValue() & limbMask;\n@@ -452,0 +459,2 @@\n+    @ForceInline\n+    @IntrinsicCandidate\n@@ -560,2 +569,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -566,2 +574,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -589,1 +596,1 @@\n-            return new ImmutableElement(newLimbs, numAdds);\n+            return new ImmutableElement(newLimbs, numAdds+1);\n@@ -607,1 +614,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -612,1 +619,1 @@\n-            if (b.numAdds > maxAdds) {\n+            if (b.numAdds > maxAddsMul) {\n@@ -618,2 +625,2 @@\n-            mult(limbs, b.limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, 0);\n+            int numAdds = mult(limbs, b.limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, numAdds);\n@@ -625,1 +632,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -631,2 +638,2 @@\n-            IntegerPolynomial.this.square(limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, 0);\n+            int numAdds = IntegerPolynomial.this.square(limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, numAdds);\n@@ -640,1 +647,1 @@\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -645,1 +652,1 @@\n-            if (other.numAdds > 32 - bitsPerLimb) {\n+            if (other.numAdds > maxAddsAdd) {\n@@ -737,1 +744,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -742,1 +749,1 @@\n-            if (b.numAdds > maxAdds) {\n+            if (b.numAdds > maxAddsMul) {\n@@ -747,2 +754,1 @@\n-            mult(limbs, b.limbs, limbs);\n-            numAdds = 0;\n+            numAdds = mult(limbs, b.limbs, limbs);\n@@ -755,1 +761,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -761,2 +767,1 @@\n-            multByInt(limbs, value);\n-            numAdds = 0;\n+            numAdds += multByInt(limbs, value);\n@@ -772,2 +777,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -778,2 +782,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -798,2 +801,1 @@\n-            \/\/ if (numAdds >= maxAdds) {\n-            if (numAdds > 32 - bitsPerLimb) {\n+            if (numAdds > maxAddsAdd) {\n@@ -804,2 +806,1 @@\n-            \/\/ if (b.numAdds >= maxAdds) {\n-            if (b.numAdds > 32 - bitsPerLimb) {\n+            if (b.numAdds > maxAddsAdd) {\n@@ -821,1 +822,1 @@\n-            if (numAdds > maxAdds) {\n+            if (numAdds > maxAddsMul) {\n@@ -826,2 +827,1 @@\n-            IntegerPolynomial.this.square(limbs, limbs);\n-            numAdds = 0;\n+            numAdds = IntegerPolynomial.this.square(limbs, limbs);;\n@@ -836,0 +836,1 @@\n+            numAdds++;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":48,"deletions":47,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    protected void mult(long[] a, long[] b, long[] r) {\n+    protected int mult(long[] a, long[] b, long[] r) {\n@@ -76,0 +76,1 @@\n+        return 0;\n@@ -102,1 +103,1 @@\n-    protected void square(long[] a, long[] r) {\n+    protected int square(long[] a, long[] r) {\n@@ -125,0 +126,1 @@\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-    protected void mult(long[] a, long[] b, long[] r) {\n+    protected int mult(long[] a, long[] b, long[] r) {\n@@ -139,0 +139,1 @@\n+        return 0;\n@@ -191,1 +192,1 @@\n-    protected void square(long[] a, long[] r) {\n+    protected int square(long[] a, long[] r) {\n@@ -202,1 +203,1 @@\n-\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialModBinP.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,560 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util.math.intpoly;\n+\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.SmallValue;\n+import sun.security.util.math.IntegerFieldModuloP;\n+import java.lang.Math;\n+import java.math.BigInteger;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/\/ Reference:\n+\/\/ - [1] Shay Gueron and Vlad Krasnov \"Fast Prime Field Elliptic Curve\n+\/\/       Cryptography with 256 Bit Primes\"\n+\/\/\n+public final class MontgomeryIntegerPolynomialP256 extends IntegerPolynomial\n+        implements IntegerMontgomeryFieldModuloP {\n+    private static final int BITS_PER_LIMB = 52;\n+    private static final int NUM_LIMBS = 5;\n+    private static final int MAX_ADDS = 0;\n+    public static final BigInteger MODULUS = evaluateModulus();\n+    private static final long LIMB_MASK = -1L >>> (64 - BITS_PER_LIMB);\n+\n+    public static final MontgomeryIntegerPolynomialP256 ONE = new MontgomeryIntegerPolynomialP256();\n+\n+    \/\/ h = 2^(2*260)%p = 0x4fffffffdfffffffffffffffefffffffbffffffff000000000000000300\n+    \/\/ oneActual = 1\n+    \/\/ oneMont = (1*2^260) mod p\n+    \/\/ modulus = p\n+    private static final long[] h = new long[] {\n+        0x0000000000000300L, 0x000ffffffff00000L, 0x000ffffefffffffbL,\n+        0x000fdfffffffffffL, 0x0000000004ffffffL };\n+    private static final long[] oneActual = new long[] {\n+        0x0000000000000001L, 0x0000000000000000L, 0x0000000000000000L,\n+        0x0000000000000000L, 0x0000000000000000L };\n+    private static final long[] oneMont = new long[] {\n+        0x0000000000000010L, 0x000f000000000000L, 0x000fffffffffffffL,\n+        0x000ffeffffffffffL, 0x00000000000fffffL };\n+    private static final long[] zero = new long[] {\n+        0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,\n+        0x0000000000000000L, 0x0000000000000000L };\n+    private static final long[] modulus = new long[] {\n+        0x000fffffffffffffL, 0x00000fffffffffffL, 0x0000000000000000L,\n+        0x0000001000000000L, 0x0000ffffffff0000L };\n+\n+    private MontgomeryIntegerPolynomialP256() {\n+        super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);\n+    }\n+\n+    public IntegerFieldModuloP residueField() {\n+        return IntegerPolynomialP256.ONE;\n+    }\n+\n+    \/\/ (224%nat,-1)::(192%nat,1)::(96%nat,1)::(0%nat,-1)::nil.\n+    private static BigInteger evaluateModulus() {\n+        BigInteger result = BigInteger.valueOf(2).pow(256);\n+        result = result.subtract(BigInteger.valueOf(1).shiftLeft(224));\n+        result = result.add(BigInteger.valueOf(1).shiftLeft(192));\n+        result = result.add(BigInteger.valueOf(1).shiftLeft(96));\n+        result = result.subtract(BigInteger.valueOf(1));\n+        return result;\n+    }\n+\n+    @Override\n+    public ImmutableElement get0() {\n+        return new ImmutableElement(zero, 0);\n+    }\n+\n+    \/\/ One in montgomery domain: (1*2^260) mod p\n+    @Override\n+    public ImmutableElement get1() {\n+        return new ImmutableElement(oneMont, 0);\n+    }\n+\n+    \/\/ Convert v to Montgomery domain\n+    @Override\n+    public ImmutableElement getElement(BigInteger v) {\n+        long[] vLimbs = new long[NUM_LIMBS];\n+        long[] montLimbs = new long[NUM_LIMBS];\n+        setLimbsValuePositive(v, vLimbs);\n+\n+        \/\/ Convert to Montgomery domain\n+        int numAdds = mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, numAdds);\n+    }\n+\n+    @Override\n+    public SmallValue getSmallValue(int value) {\n+        \/\/ Explicitely here as reminder that SmallValue stays in residue domain\n+        \/\/ See multByInt below for how this is used\n+        return super.getSmallValue(value);\n+    }\n+\n+    \/*\n+     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n+     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n+     * montgomery conversion followed by a montgomery multiplication, just use\n+     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n+     * Section 4 )\n+     *\n+     * Will return an unreduced value\n+     *\/\n+    @Override\n+    protected int multByInt(long[] a, long b) {\n+        assert (b < (1 << BITS_PER_LIMB));\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] *= b;\n+        }\n+        return (int) (b - 1);\n+    }\n+\n+    @Override\n+    public ImmutableIntegerModuloP fromMontgomery(ImmutableIntegerModuloP n) {\n+        assert n.getField() == MontgomeryIntegerPolynomialP256.ONE;\n+\n+        ImmutableElement nn = (ImmutableElement) n;\n+        long[] r1 = new long[NUM_LIMBS];\n+        long[] r2 = new long[2 * NUM_LIMBS];\n+        long[] limbs = nn.getLimbs();\n+        reduce(limbs);\n+        MontgomeryIntegerPolynomialP256.ONE.mult(limbs, oneActual, r1);\n+        reduce(r1);\n+        halfLimbs(r1, r2);\n+        return IntegerPolynomialP256.ONE.new ImmutableElement(r2, 0);\n+    }\n+\n+    private void halfLimbs(long[] a, long[] r) {\n+        final long HALF_BITS_LIMB = BITS_PER_LIMB \/ 2;\n+        final long HALF_LIMB_MASK = -1L >>> (64 - HALF_BITS_LIMB);\n+        r[0] = a[0] & HALF_LIMB_MASK;\n+        r[1] = a[0] >> HALF_BITS_LIMB;\n+        r[2] = a[1] & HALF_LIMB_MASK;\n+        r[3] = a[1] >> HALF_BITS_LIMB;\n+        r[4] = a[2] & HALF_LIMB_MASK;\n+        r[5] = a[2] >> HALF_BITS_LIMB;\n+        r[6] = a[3] & HALF_LIMB_MASK;\n+        r[7] = a[3] >> HALF_BITS_LIMB;\n+        r[8] = a[4] & HALF_LIMB_MASK;\n+        r[9] = a[4] >> HALF_BITS_LIMB;\n+    }\n+\n+    @Override\n+    protected int square(long[] a, long[] r) {\n+        return mult(a, a, r);\n+    }\n+\n+    \/**\n+     * Unrolled Word-by-Word Montgomery Multiplication r = a * b * 2^-260 (mod P)\n+     *\n+     * See [1] Figure 5. \"Algorithm 2: Word-by-Word Montgomery Multiplication\n+     * for a Montgomery Friendly modulus p\". Note: Step 6. Skipped; Instead use\n+     * numAdds to reuse existing overflow logic.\n+     *\/\n+    @IntrinsicCandidate\n+    protected int mult(long[] a, long[] b, long[] r) {\n+        long aa0 = a[0];\n+        long aa1 = a[1];\n+        long aa2 = a[2];\n+        long aa3 = a[3];\n+        long aa4 = a[4];\n+\n+        long bb0 = b[0];\n+        long bb1 = b[1];\n+        long bb2 = b[2];\n+        long bb3 = b[3];\n+        long bb4 = b[4];\n+\n+        final long shift1 = 64 - BITS_PER_LIMB; \/\/ 12\n+        final long shift2 = BITS_PER_LIMB; \/\/ 40\n+\n+        long d0, d1, d2, d3, d4;      \/\/ low digits from multiplication\n+        long dd0, dd1, dd2, dd3, dd4; \/\/ high digits from multiplication\n+        long n, n0, n1, n2, n3, n4,\n+            nn0, nn1, nn2, nn3, nn4; \/\/ modulus multiple digits\n+        long c0, c1, c2, c3, c4, c5, c6, c7, c8, c9; \/\/ multiplication result\n+                                                     \/\/ digits for each column\n+\n+        \/\/ Row 0 - multiply by aa0 and reduce out c0\n+        d0 = aa0 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa0, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        n = d0;\n+        d1 = aa0 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa0, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa0 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa0, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa0 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa0, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa0 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa0, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        nn0 = Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        n0 &= LIMB_MASK;\n+        n1 = n * modulus[1];\n+        nn1 = Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        n1 &= LIMB_MASK;\n+        n2 = n * modulus[2];\n+        nn2 = Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        n2 &= LIMB_MASK;\n+        n3 = n * modulus[3];\n+        nn3 = Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        n3 &= LIMB_MASK;\n+        n4 = n * modulus[4];\n+        nn4 = Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        n4 &= LIMB_MASK;\n+\n+        dd0 += nn0;\n+        d0 += n0;\n+        dd1 += nn1;\n+        d1 += n1;\n+        dd2 += nn2;\n+        d2 += n2;\n+        dd3 += nn3;\n+        d3 += n3;\n+        dd4 += nn4;\n+        d4 += n4;\n+\n+        c1 = d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c2 = d2 + dd1;\n+        c3 = d3 + dd2;\n+        c4 = d4 + dd3;\n+        c5 = dd4;\n+\n+        \/\/ Row 1 - multiply by aa1 and reduce out c1\n+        d0 = aa1 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa1, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c1;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa1 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa1, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa1 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa1, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa1 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa1, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa1 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa1, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c2 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c3 += d2 + dd1;\n+        c4 += d3 + dd2;\n+        c5 += d4 + dd3;\n+        c6 = dd4;\n+\n+        \/\/ Row 2 - multiply by aa2 and reduce out c2\n+        d0 = aa2 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa2, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c2;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa2 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa2, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa2 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa2, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa2 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa2, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa2 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa2, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c3 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c4 += d2 + dd1;\n+        c5 += d3 + dd2;\n+        c6 += d4 + dd3;\n+        c7 = dd4;\n+\n+        \/\/ Row 3 - multiply by aa3 and reduce out c3\n+        d0 = aa3 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa3, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c3;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa3 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa3, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa3 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa3, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa3 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa3, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa3 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa3, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c4 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c5 += d2 + dd1;\n+        c6 += d3 + dd2;\n+        c7 += d4 + dd3;\n+        c8 = dd4;\n+\n+        \/\/ Row 4 - multiply by aa3 and reduce out c4\n+        d0 = aa4 * bb0;\n+        dd0 = Math.unsignedMultiplyHigh(aa4, bb0) << shift1 | (d0 >>> shift2);\n+        d0 &= LIMB_MASK;\n+        d0 += c4;\n+        n = d0 & LIMB_MASK;\n+        d1 = aa4 * bb1;\n+        dd1 = Math.unsignedMultiplyHigh(aa4, bb1) << shift1 | (d1 >>> shift2);\n+        d1 &= LIMB_MASK;\n+        d2 = aa4 * bb2;\n+        dd2 = Math.unsignedMultiplyHigh(aa4, bb2) << shift1 | (d2 >>> shift2);\n+        d2 &= LIMB_MASK;\n+        d3 = aa4 * bb3;\n+        dd3 = Math.unsignedMultiplyHigh(aa4, bb3) << shift1 | (d3 >>> shift2);\n+        d3 &= LIMB_MASK;\n+        d4 = aa4 * bb4;\n+        dd4 = Math.unsignedMultiplyHigh(aa4, bb4) << shift1 | (d4 >>> shift2);\n+        d4 &= LIMB_MASK;\n+\n+        n0 = n * modulus[0];\n+        dd0 += Math.unsignedMultiplyHigh(n, modulus[0]) << shift1 | (n0 >>> shift2);\n+        d0 += n0 & LIMB_MASK;\n+        n1 = n * modulus[1];\n+        dd1 += Math.unsignedMultiplyHigh(n, modulus[1]) << shift1 | (n1 >>> shift2);\n+        d1 += n1 & LIMB_MASK;\n+        n2 = n * modulus[2];\n+        dd2 += Math.unsignedMultiplyHigh(n, modulus[2]) << shift1 | (n2 >>> shift2);\n+        d2 += n2 & LIMB_MASK;\n+        n3 = n * modulus[3];\n+        dd3 += Math.unsignedMultiplyHigh(n, modulus[3]) << shift1 | (n3 >>> shift2);\n+        d3 += n3 & LIMB_MASK;\n+        n4 = n * modulus[4];\n+        dd4 += Math.unsignedMultiplyHigh(n, modulus[4]) << shift1 | (n4 >>> shift2);\n+        d4 += n4 & LIMB_MASK;\n+\n+        c5 += d1 + dd0 + (d0 >>> BITS_PER_LIMB);\n+        c6 += d2 + dd1 + (c5 >>> BITS_PER_LIMB);\n+        c7 += d3 + dd2 + (c6 >>> BITS_PER_LIMB);\n+        c8 += d4 + dd3 + (c7 >>> BITS_PER_LIMB);\n+        c9 = dd4 + (c8 >>> BITS_PER_LIMB);\n+\n+        c5 &= LIMB_MASK;\n+        c6 &= LIMB_MASK;\n+        c7 &= LIMB_MASK;\n+        c8 &= LIMB_MASK;\n+\n+        \/\/ At this point, the result could overflow by one modulus.\n+        c0 = c5 - modulus[0];\n+        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB);\n+        c0 &= LIMB_MASK;\n+        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        c1 &= LIMB_MASK;\n+        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB);\n+        c2 &= LIMB_MASK;\n+        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB);\n+        c3 &= LIMB_MASK;\n+\n+        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        r[0] = ((c5 & mask) | (c0 & ~mask));\n+        r[1] = ((c6 & mask) | (c1 & ~mask));\n+        r[2] = ((c7 & mask) | (c2 & ~mask));\n+        r[3] = ((c8 & mask) | (c3 & ~mask));\n+        r[4] = ((c9 & mask) | (c4 & ~mask));\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void finalCarryReduceLast(long[] limbs) {\n+        reduce(limbs);\n+    }\n+\n+    @Override\n+    protected long carryValue(long x) {\n+        return x >> BITS_PER_LIMB;\n+    }\n+\n+    @Override\n+    protected void postEncodeCarry(long[] v) {\n+        \/\/ not needed because carry is unsigned\n+    }\n+\n+    \/\/ Proof:\n+    \/\/ carry * 2^256 (mod p) ==  carry * [2^256 - p] (mod p)\n+    \/\/                       ==  carry * [2^256 - (2^256 -2^224 +2^192 +2^96 -1)] (mod p)\n+    \/\/                       ==  carry * [2^224 -2^192 -2^96 +1] (mod p)\n+    @Override\n+    protected void reduce(long[] limbs) {\n+        long b0 = limbs[0];\n+        long b1 = limbs[1];\n+        long b2 = limbs[2];\n+        long b3 = limbs[3];\n+        long b4 = limbs[4];\n+        long carry = b4 >> 48; \/\/ max 16-bits\n+        b4 -= carry << 48;\n+\n+        \/\/ 2^0 position\n+        b0 += carry;\n+        \/\/ -2^96\n+        b1 -= carry << 44;\n+        \/\/ -2^192\n+        b3 -= carry << 36;\n+        \/\/ 2^224\n+        b4 += carry << 16;\n+\n+        b1 += b0 >> BITS_PER_LIMB;\n+        b2 += b1 >> BITS_PER_LIMB;\n+        b3 += b2 >> BITS_PER_LIMB;\n+        b4 += b3 >> BITS_PER_LIMB;\n+\n+        b0 &= LIMB_MASK;\n+        b1 &= LIMB_MASK;\n+        b2 &= LIMB_MASK;\n+        b3 &= LIMB_MASK;\n+\n+        long c0, c1, c2, c3, c4;\n+        c0 = modulus[0] + b0;\n+        c1 = modulus[1] + b1 + (c0 >> BITS_PER_LIMB);\n+        c0 &= LIMB_MASK;\n+        c2 = modulus[2] + b2 + (c1 >> BITS_PER_LIMB);\n+        c1 &= LIMB_MASK;\n+        c3 = modulus[3] + b3 + (c2 >> BITS_PER_LIMB);\n+        c2 &= LIMB_MASK;\n+        c4 = modulus[4] + b4 + (c3 >> BITS_PER_LIMB);\n+        c3 &= LIMB_MASK;\n+\n+        long mask = b4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        limbs[0] = (b0 & ~mask) | (c0 & mask);\n+        limbs[1] = (b1 & ~mask) | (c1 & mask);\n+        limbs[2] = (b2 & ~mask) | (c2 & mask);\n+        limbs[3] = (b3 & ~mask) | (c3 & mask);\n+        limbs[4] = (b4 & ~mask) | (c4 & mask);\n+    }\n+\n+    public ImmutableElement getElement(byte[] v, int offset, int length,\n+            byte highByte) {\n+\n+        long[] vLimbs = new long[NUM_LIMBS];\n+        long[] montLimbs = new long[NUM_LIMBS];\n+        super.encode(v, offset, length, highByte, vLimbs);\n+\n+        \/\/ Convert to Montgomery domain\n+        int numAdds = mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, numAdds);\n+    }\n+\n+    \/*\n+     * This function 'moves\/reduces' digit 'v' to the 'lower' limbs\n+     *\n+     * The result is not reduced further. Carry propagation is not performed\n+     * (see IntegerPolynomial.reduceHigh() for how this method is used)\n+     *\n+     * Proof:\n+     *   v * 2^(i*52) (mod p) ==  v * 2^(52i) - v * 2^(52i-256) * p                               (mod p)\n+     *                        ==  v * 2^(52i) - v * 2^(52i-256) * (2^256 -2^224 +2^192 +2^96 -1)  (mod p)\n+     *                        ==  v * 2^(52i) - v * [2^(52i-256+256) -2^(52i-256+224) +2^(52i-256+192) +2^(52i-256+96) -2^(52i-256)] (mod p)\n+     *                        ==  v * 2^(52i) - v * [2^(52i) -2^(52i-32) +2^(52i-64) +2^(52i-160) -2^(52i-256)]                      (mod p)\n+     *\n+     *                        ==  v * [2^(52i-32) +2^(52i-52-12) +2^(52i-3*52-4) -2^(52i-4*52-48)] (mod p)\n+     *\/\n+    @Override\n+    protected void reduceIn(long[] limbs, long v, int i) {\n+        \/\/ Since top term (2^(52i-32)) will leave top 20 bits back in the same\n+        \/\/ position i,\n+        \/\/ \"repeat same reduction on top 20 bits\"\n+        v += v >> 32;\n+\n+        \/\/ 2^(52i-32)\n+        limbs[i - 1] += (v << 20) & LIMB_MASK;\n+\n+        \/\/ 2^(52i-52-12)\n+        limbs[i - 2] -= (v << 40) & LIMB_MASK;\n+        limbs[i - 1] -= v >> 12;\n+\n+        \/\/ 2^(52i-3*52-4)\n+        limbs[i - 4] -= (v << 48) & LIMB_MASK;\n+        limbs[i - 3] -= v >> 4;\n+\n+        \/\/ 2^(52i-4*52-48)\n+        limbs[i - 5] += (v << 4) & LIMB_MASK;\n+        limbs[i - 4] += v >> 48;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":560,"deletions":0,"binary":false,"changes":560,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,0 +262,18 @@\n+\n+            if (parent == null) {\n+                \/\/ check nonlikelyScript locales\n+                if (CLDRBaseLocaleDataMetaInfo.nonlikelyScript && locale.getCountry().isEmpty()) {\n+                    var lang = \" \" + locale.getLanguage() + \" \";\n+                    var script= locale.getScript();\n+                    if (!script.isEmpty()) {\n+                        parent = baseMetaInfo.likelyScriptMap().entrySet().stream()\n+                            .filter(e -> e.getValue().contains(lang))\n+                            .findAny()\n+                            .map(Map.Entry::getKey)\n+                            .map(likely -> likely.equals(script) ? null : Locale.ROOT)\n+                            .orElse(null);\n+                    }\n+                }\n+            }\n+\n+            \/\/ no parent found\n","filename":"src\/java.base\/share\/classes\/sun\/util\/cldr\/CLDRLocaleProviderAdapter.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.UnaryOperator;\n@@ -96,1 +96,1 @@\n-            ReferencedKeySet.create(true, ConcurrentHashMap::new);\n+            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -167,5 +167,2 @@\n-            (b) -> new BaseLocale(\n-                LocaleUtils.toLowerString(b.language).intern(),\n-                LocaleUtils.toTitleString(b.script).intern(),\n-                LocaleUtils.toUpperString(b.region).intern(),\n-                b.variant.intern()));\n+                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n+                INTERNER);\n@@ -174,0 +171,11 @@\n+    public static final UnaryOperator<BaseLocale> INTERNER = new UnaryOperator<>() {\n+        @Override\n+        public BaseLocale apply(BaseLocale b) {\n+            return new BaseLocale(\n+                    LocaleUtils.toLowerString(b.language).intern(),\n+                    LocaleUtils.toTitleString(b.script).intern(),\n+                    LocaleUtils.toUpperString(b.region).intern(),\n+                    b.variant.intern());\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+Owner: CN=GlobalSign Root E46, O=GlobalSign nv-sa, C=BE\n+Issuer: CN=GlobalSign Root E46, O=GlobalSign nv-sa, C=BE\n+Serial number: 11d2bbba336ed4bce62468c50d841d98e843\n+Valid from: Wed Mar 20 00:00:00 GMT 2019 until: Tue Mar 20 00:00:00 GMT 2046\n+Signature algorithm name: SHA384withECDSA\n+Subject Public Key Algorithm: 384-bit EC (secp384r1) key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\r\n+MIICCzCCAZGgAwIBAgISEdK7ujNu1LzmJGjFDYQdmOhDMAoGCCqGSM49BAMDMEYx\r\n+CzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYDVQQD\r\n+ExNHbG9iYWxTaWduIFJvb3QgRTQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMyMDAw\r\n+MDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2Ex\r\n+HDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBFNDYwdjAQBgcqhkjOPQIBBgUrgQQA\r\n+IgNiAAScDrHPt+ieUnd1NPqlRqetMhkytAepJ8qUuwzSChDH2omwlwxwEwkBjtjq\r\n+R+q+soArzfwoDdusvKSGN+1wCAB16pMLey5SnCNoIwZD7JIvU4Tb+0cUB+hflGdd\r\n+yXqBPCCjQjBAMA4GA1UdDwEB\/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH\/MB0GA1Ud\r\n+DgQWBBQxCpCPtsad0kRLgLWi5h+xEk8blTAKBggqhkjOPQQDAwNoADBlAjEA31SQ\r\n+7Zvvi5QCkxeCmb6zniz2C5GMn0oUsfZkvLtoURMMA\/cVi4RguYv\/Uo7njLwcAjA8\r\n++RHUjE7AwWHCFUyqqx0LMV87HOIAl0Qx5v5zli\/altP+CAezNIm8BZ\/3Hobui3A=\r\n+-----END CERTIFICATE-----\r\n","filename":"src\/java.base\/share\/data\/cacerts\/globalsigne46","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+Owner: CN=GlobalSign Root R46, O=GlobalSign nv-sa, C=BE\n+Issuer: CN=GlobalSign Root R46, O=GlobalSign nv-sa, C=BE\n+Serial number: 11d2bbb9d723189e405f0a9d2dd0df2567d1\n+Valid from: Wed Mar 20 00:00:00 GMT 2019 until: Tue Mar 20 00:00:00 GMT 2046\n+Signature algorithm name: SHA384withRSA\n+Subject Public Key Algorithm: 4096-bit RSA key\n+Version: 3\n+-----BEGIN CERTIFICATE-----\r\n+MIIFWjCCA0KgAwIBAgISEdK7udcjGJ5AXwqdLdDfJWfRMA0GCSqGSIb3DQEBDAUA\r\n+MEYxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYD\r\n+VQQDExNHbG9iYWxTaWduIFJvb3QgUjQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMy\r\n+MDAwMDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYt\r\n+c2ExHDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBSNDYwggIiMA0GCSqGSIb3DQEB\r\n+AQUAA4ICDwAwggIKAoICAQCsrHQy6LNl5brtQyYdpokNRbopiLKkHWPd08EsCVeJ\r\n+OaFV6Wc0dwxu5FUdUiXSE2te4R2pt32JMl8Nnp8semNgQB+msLZ4j5lUlghYruQG\r\n+vGIFAha\/r6gjA7aUD7xubMLL1aa7DOn2wQL7Id5m3RerdELv8HQvJfTqa1VbkNud\r\n+316HCkD7rRlr+\/fKYIje2sGP1q7Vf9Q8g+7XFkyDRTNrJ9CG0Bwta\/OrffGFqfUo\r\n+0q3v84RLHIf8E6M6cqJaESvWJ3En7YEtbWaBkoe0G1h6zD8K+kZPTXhc+CtI4wSE\r\n+y132tGqzZfxCnlEmIyDLPRT5ge1lFgBPGmSXZgjPjHvjK8Cd+RTyG\/FWaha\/LIWF\r\n+zXg4mutCagI0GIMXTpRW+LaCtfOW3T3zvn8gdz57GSNrLNRyc0NXfeD412lPFzYE\r\n++cCQYDdF3uYM2HSNrpyibXRdQr4G9dlkbgIQrImwTDsHTUB+JMWKmIJ5jqSngiCN\r\n+I\/onccnfxkF0oE32kRbcRoxfKWMxWXEM2G\/CtjJ9++ZdU6Z+Ffy7dXxd7Pj2Fxzs\r\n+x2sZy\/N78CsHpdlseVR2bJ0cpm4O6XkMqCNqo98bMDGfsVR7\/mrLZqrcZdCinkqa\r\n+ByFrgY\/bxFn63iLABJzjqls2k+g9vXqhnQt2sQvHnf3PmKgGwvgqo6GDoLclcqUC\r\n+4wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH\/BAUwAwEB\/zAdBgNV\r\n+HQ4EFgQUA1yrc4GHqMywptWU4jaWSf8FmSwwDQYJKoZIhvcNAQEMBQADggIBAHx4\r\n+7PYCLLtbfpIrXTncvtgdokIzTfnvpCo7RGkerNlFo048p9gkUbJUHJNOxO97k4Vg\r\n+JuoJSOD1u8fpaNK7ajFxzHmuEajwmf3lH7wvqMxX63bEIaZHU1VNaL8FpO7XJqti\r\n+2kM3S+LGteWygxk6x9PbTZ4IevPuzz5i+6zoYMzRx6Fcg0XERczzF2sUyQQCPtIk\r\n+pnnpHs6i58FZFZ8d4kuaPp92CC1r2LpXFNqD6v6MVenQTqnMdzGxRBF6XLE+0xRF\r\n+FRhiJBPSy03OXIPBNvIQtQ6IbbjhVp+J3pZmOUdkLG5NrmJ7v2B0GbhWrJKsFjLt\r\n+rWhV\/pi60zTe9Mlhww6G9kuEYO4Ne7UyWHmRVSyBQ7N0H3qqJZ4d16GLuc1CLgSk\r\n+ZoNNiTW2bKg2SnkheCLQQrzRQDGQob4Ez8pn7fXwgNNgyYMqIgXQBztSvwyeqiv5\r\n+u+YfjyW6hY0XHgL+XVAEV8\/+LbzvXMAaq7afJMbfc2hIkCwU9D9SGuTSyxTDYWnP\r\n+4vkYxboznxSjBF25cfe1lNj2M8FawTSLfJvdkzrnE6JwYZ+vj+vYxXX4M2bUdGc6\r\n+N3ec592kD3ZDZopD8p\/7DEJ4Y9HiD2971KE9dJeFt0g5QdYg\/NA6s\/rob8SKunE3\r\n+vouXsXgxT7PntgMTzlSdriVZzH81Xwj3QEUxeCp6\r\n+-----END CERTIFICATE-----\r\n","filename":"src\/java.base\/share\/data\/cacerts\/globalsignr46","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -1,2 +1,2 @@\n-Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/b5bf572c52988dbe9d865b8f090ea819024a9936\/public_suffix_list.dat\n-Date: 2023-11-09\n+Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/1cbd6e71a9b83620b1d0b11e49d3d9ff48c27e22\/public_suffix_list.dat\n+Date: 2024-05-07\n","filename":"src\/java.base\/share\/data\/publicsuffixlist\/VERSION","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6713,1 +6713,1 @@\n-\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2023-11-03T15:13:18Z\n+\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2024-05-04T15:12:50Z\n@@ -6899,1 +6899,1 @@\n-\/\/ aol : Oath Inc.\n+\/\/ aol : Yahoo Inc.\n@@ -6991,4 +6991,0 @@\n-\/\/ avianca : Avianca Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/avianca.html\n-avianca\n-\n@@ -7019,4 +7015,0 @@\n-\/\/ bananarepublic : The Gap, Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/bananarepublic.html\n-bananarepublic\n-\n@@ -7547,4 +7539,0 @@\n-\/\/ comcast : Comcast IP Holdings I, LLC\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/comcast.html\n-comcast\n-\n@@ -7755,0 +7743,4 @@\n+\/\/ desi\n+\/\/ https:\/\/www.iana.org\/domains\/root\/db\/desi.html\n+desi\n+\n@@ -7799,1 +7791,1 @@\n-\/\/ diy : Lifestyle Domain Holdings, Inc.\n+\/\/ diy : Internet Naming Company LLC\n@@ -7931,4 +7923,0 @@\n-\/\/ etisalat : Emirates Telecommunications Corporation (trading as Etisalat)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/etisalat.html\n-etisalat\n-\n@@ -8107,1 +8095,1 @@\n-\/\/ food : Lifestyle Domain Holdings, Inc.\n+\/\/ food : Internet Naming Company LLC\n@@ -8167,1 +8155,1 @@\n-\/\/ fun : Radix FZC DMCC\n+\/\/ fun : Radix Technologies Inc.\n@@ -8315,1 +8303,1 @@\n-\/\/ goo : NTT Resonant Inc.\n+\/\/ goo : NTT DOCOMO, INC.\n@@ -8367,4 +8355,0 @@\n-\/\/ guardian : The Guardian Life Insurance Company of America\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/guardian.html\n-guardian\n-\n@@ -8503,1 +8487,1 @@\n-\/\/ host : Radix FZC DMCC\n+\/\/ host : Radix Technologies Inc.\n@@ -8723,1 +8707,1 @@\n-\/\/ juegos : Internet Naming Company LLC\n+\/\/ juegos : Dog Beach, LLC\n@@ -8911,1 +8895,1 @@\n-\/\/ lifestyle : Lifestyle Domain Holdings, Inc.\n+\/\/ lifestyle : Internet Naming Company LLC\n@@ -8951,1 +8935,1 @@\n-\/\/ living : Lifestyle Domain Holdings, Inc.\n+\/\/ living : Internet Naming Company LLC\n@@ -9395,4 +9379,0 @@\n-\/\/ oldnavy : The Gap, Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/oldnavy.html\n-oldnavy\n-\n@@ -9419,1 +9399,1 @@\n-\/\/ online : Radix FZC DMCC\n+\/\/ online : Radix Technologies Inc.\n@@ -9623,1 +9603,1 @@\n-\/\/ press : Radix FZC DMCC\n+\/\/ press : Radix Technologies Inc.\n@@ -9931,4 +9911,0 @@\n-\/\/ sca : SVENSKA CELLULOSA AKTIEBOLAGET SCA (publ)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/sca.html\n-sca\n-\n@@ -10079,1 +10055,1 @@\n-\/\/ site : Radix FZC DMCC\n+\/\/ site : Radix Technologies Inc.\n@@ -10159,1 +10135,1 @@\n-\/\/ space : Radix FZC DMCC\n+\/\/ space : Radix Technologies Inc.\n@@ -10211,1 +10187,1 @@\n-\/\/ store : Radix FZC DMCC\n+\/\/ store : Radix Technologies Inc.\n@@ -10327,1 +10303,1 @@\n-\/\/ tech : Radix FZC DMCC\n+\/\/ tech : Radix Technologies Inc.\n@@ -10511,1 +10487,1 @@\n-\/\/ uno : Radix FZC DMCC\n+\/\/ uno : Radix Technologies Inc.\n@@ -10527,1 +10503,1 @@\n-\/\/ vana : Lifestyle Domain Holdings, Inc.\n+\/\/ vana : Internet Naming Company LLC\n@@ -10611,4 +10587,0 @@\n-\/\/ volkswagen : Volkswagen Group of America Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/volkswagen.html\n-volkswagen\n-\n@@ -10679,1 +10651,1 @@\n-\/\/ website : Radix FZC DMCC\n+\/\/ website : Radix Technologies Inc.\n@@ -10683,0 +10655,4 @@\n+\/\/ wed\n+\/\/ https:\/\/www.iana.org\/domains\/root\/db\/wed.html\n+wed\n+\n@@ -10771,4 +10747,0 @@\n-\/\/ xfinity : Comcast IP Holdings I, LLC\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/xfinity.html\n-xfinity\n-\n@@ -11015,4 +10987,0 @@\n-\/\/ xn--mgbaakc7dvf : Emirates Telecommunications Corporation (trading as Etisalat)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/xn--mgbaakc7dvf.html\n-اتصالات\n-\n@@ -11155,1 +11123,1 @@\n-\/\/ yahoo : Oath Inc.\n+\/\/ yahoo : Yahoo Inc.\n@@ -11220,0 +11188,6 @@\n+\/\/ 12CHARS: https:\/\/12chars.com\n+\/\/ Submitted by Kenny Niehage <psl@12chars.com>\n+12chars.dev\n+12chars.it\n+12chars.pro\n+\n@@ -11229,0 +11203,9 @@\n+\/\/ AAA workspace : https:\/\/aaa.vodka\n+\/\/ Submitted by Kirill Rezraf <admin@aaa.vodka>\n+aaa.vodka\n+\n+\/\/ A2 Hosting\n+\/\/ Submitted by Tyler Hall <sysadmin@a2hosting.com>\n+a2hosted.com\n+cpserver.com\n+\n@@ -11245,0 +11228,4 @@\n+\/\/ Adaptable.io : https:\/\/adaptable.io\n+\/\/ Submitted by Mark Terrel <support@adaptable.io>\n+adaptable.app\n+\n@@ -11249,0 +11236,1 @@\n+aem.live\n@@ -11251,0 +11239,1 @@\n+aem.page\n@@ -11322,1 +11311,1 @@\n-\/\/ Reference: 4d863337-ff98-4501-a6f2-361eba8445d6\n+\/\/ Reference: 9e37648f-a66c-4655-9ab1-5981f8737197\n@@ -11337,0 +11326,1 @@\n+execute-api.ca-west-1.amazonaws.com\n@@ -11363,1 +11353,1 @@\n-\/\/ Reference: 7bee1013-f456-47df-bfe8-03c78d946d61\n+\/\/ Reference: 09588633-91fe-49d8-b4e7-ec36496d11f3\n@@ -11369,0 +11359,1 @@\n+auth.ap-south-2.amazoncognito.com\n@@ -11372,0 +11363,1 @@\n+auth.ap-southeast-4.amazoncognito.com\n@@ -11374,0 +11366,1 @@\n+auth.eu-central-2.amazoncognito.com\n@@ -11376,0 +11369,1 @@\n+auth.eu-south-2.amazoncognito.com\n@@ -11380,0 +11374,1 @@\n+auth.me-central-1.amazoncognito.com\n@@ -11402,1 +11397,1 @@\n-\/\/ Reference: 597f3f8e-9283-4e48-8e32-7ee25a1ff6ab\n+\/\/ Reference: 82f43f9f-bbb8-400e-8349-854f5a62f20d\n@@ -11427,0 +11422,3 @@\n+emrappui-prod.ap-south-2.amazonaws.com\n+emrnotebooks-prod.ap-south-2.amazonaws.com\n+emrstudio-prod.ap-south-2.amazonaws.com\n@@ -11436,0 +11434,3 @@\n+emrappui-prod.ap-southeast-4.amazonaws.com\n+emrnotebooks-prod.ap-southeast-4.amazonaws.com\n+emrstudio-prod.ap-southeast-4.amazonaws.com\n@@ -11439,0 +11440,3 @@\n+emrappui-prod.ca-west-1.amazonaws.com\n+emrnotebooks-prod.ca-west-1.amazonaws.com\n+emrstudio-prod.ca-west-1.amazonaws.com\n@@ -11442,0 +11446,3 @@\n+emrappui-prod.eu-central-2.amazonaws.com\n+emrnotebooks-prod.eu-central-2.amazonaws.com\n+emrstudio-prod.eu-central-2.amazonaws.com\n@@ -11448,0 +11455,3 @@\n+emrappui-prod.eu-south-2.amazonaws.com\n+emrnotebooks-prod.eu-south-2.amazonaws.com\n+emrstudio-prod.eu-south-2.amazonaws.com\n@@ -11457,0 +11467,3 @@\n+emrappui-prod.il-central-1.amazonaws.com\n+emrnotebooks-prod.il-central-1.amazonaws.com\n+emrstudio-prod.il-central-1.amazonaws.com\n@@ -11487,1 +11500,1 @@\n-\/\/ Reference: 4ab55e6f-90c0-4a8d-b6a0-52ca5dbb1c2e\n+\/\/ Reference: 87f24ece-a77e-40e8-bb4a-f6b74fe9f975\n@@ -11490,0 +11503,2 @@\n+*.af-south-1.airflow.amazonaws.com\n+*.ap-east-1.airflow.amazonaws.com\n@@ -11498,0 +11513,1 @@\n+*.eu-south-1.airflow.amazonaws.com\n@@ -11501,0 +11517,1 @@\n+*.me-south-1.airflow.amazonaws.com\n@@ -11504,0 +11521,1 @@\n+*.us-west-1.airflow.amazonaws.com\n@@ -11508,1 +11526,1 @@\n-\/\/ Reference: 0e801048-08f2-4064-9cb8-e7373e0b57f4\n+\/\/ Reference: cd5c8b3a-67b7-4b40-9236-c87ce81a3d10\n@@ -11607,0 +11625,10 @@\n+s3.dualstack.ca-west-1.amazonaws.com\n+s3-accesspoint.dualstack.ca-west-1.amazonaws.com\n+s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com\n+s3-fips.dualstack.ca-west-1.amazonaws.com\n+s3-website.dualstack.ca-west-1.amazonaws.com\n+s3.ca-west-1.amazonaws.com\n+s3-accesspoint.ca-west-1.amazonaws.com\n+s3-accesspoint-fips.ca-west-1.amazonaws.com\n+s3-fips.ca-west-1.amazonaws.com\n+s3-website.ca-west-1.amazonaws.com\n@@ -11787,0 +11815,16 @@\n+\/\/ Amazon SageMaker Ground Truth\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: 98dbfde4-7802-48c3-8751-b60f204e0d9c\n+labeling.ap-northeast-1.sagemaker.aws\n+labeling.ap-northeast-2.sagemaker.aws\n+labeling.ap-south-1.sagemaker.aws\n+labeling.ap-southeast-1.sagemaker.aws\n+labeling.ap-southeast-2.sagemaker.aws\n+labeling.ca-central-1.sagemaker.aws\n+labeling.eu-central-1.sagemaker.aws\n+labeling.eu-west-1.sagemaker.aws\n+labeling.eu-west-2.sagemaker.aws\n+labeling.us-east-1.sagemaker.aws\n+labeling.us-east-2.sagemaker.aws\n+labeling.us-west-2.sagemaker.aws\n+\n@@ -11789,1 +11833,1 @@\n-\/\/ Reference: fe8c9e94-5a22-486d-8750-991a3a9b13c6\n+\/\/ Reference: b5ea56df-669e-43cc-9537-14aa172f5dfc\n@@ -11802,0 +11846,3 @@\n+notebook-fips.ca-central-1.sagemaker.aws\n+notebook.ca-west-1.sagemaker.aws\n+notebook-fips.ca-west-1.sagemaker.aws\n@@ -11823,0 +11870,1 @@\n+notebook-fips.us-west-1.sagemaker.aws\n@@ -11830,1 +11878,1 @@\n-\/\/ Reference: 057ee397-6bf8-4f20-b807-d7bc145ac980\n+\/\/ Reference: 69c723d9-6e1a-4bff-a203-48eecd203183\n@@ -11844,0 +11892,1 @@\n+studio.eu-south-2.sagemaker.aws\n@@ -11888,1 +11937,1 @@\n-\/\/ Reference: 05c44955-977c-4b57-938a-f2af92733f9f\n+\/\/ Reference: 30717f72-4007-4f0f-8ed4-864c6f2efec9\n@@ -11934,0 +11983,2 @@\n+webview-assets.aws-cloud9.il-central-1.amazonaws.com\n+vfs.cloud9.il-central-1.amazonaws.com\n@@ -11953,0 +12004,5 @@\n+\/\/ AWS Directory Service\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: a13203e8-42dc-4045-a0d2-2ee67bed1068\n+awsapps.com\n+\n@@ -11996,0 +12052,5 @@\n+\/\/ AWS re:Post Private\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: 83385945-225f-416e-9aa0-ad0632bfdcee\n+*.private.repost.aws\n+\n@@ -12013,0 +12074,4 @@\n+\/\/ Apis Networks: https:\/\/apisnetworks.com\n+\/\/ Submitted by Matt Saladna <matt@apisnetworks.com>\n+panel.dev\n+\n@@ -12030,0 +12095,4 @@\n+\/\/ Aquapal : https:\/\/aquapal.net\/\n+\/\/ Submitted by Aki Ueno <admin@aquapal.net>\n+f5.si\n+\n@@ -12065,0 +12134,1 @@\n+myfritz.link\n@@ -12124,0 +12194,4 @@\n+\/\/ Besties : https:\/\/besties.house\n+\/\/ Submitted by Hazel Cora <hazy@besties.house>\n+pages.gay\n+\n@@ -12128,0 +12202,4 @@\n+\/\/ University of Bielsko-Biala regional domain: http:\/\/dns.bielsko.pl\/\n+\/\/ Submitted by Marcin <dns@ath.bielsko.pl>\n+bielsko.pl\n+\n@@ -12169,0 +12247,4 @@\n+\/\/ Brave : https:\/\/brave.com\n+\/\/ Submitted by Andrea Brancaleoni <abrancaleoni@brave.com>\n+*.s.brave.io\n+\n@@ -12170,1 +12252,2 @@\n-\/\/ Submitted by Dusan Radovanovic <dusan.radovanovic@brendly.rs>\n+\/\/ Submitted by Dusan Radovanovic <administracija@brendly.rs>\n+shop.brendly.hr\n@@ -12194,0 +12277,1 @@\n+*.my.canvasite.cn\n@@ -12195,0 +12279,1 @@\n+*.my.canva.site\n@@ -12332,0 +12417,6 @@\n+\/\/ cloudscale.ch AG : https:\/\/www.cloudscale.ch\/\n+\/\/ Submitted by Gaudenz Steinlin <support@cloudscale.ch>\n+cust.cloudscale.ch\n+objects.lpg.cloudscale.ch\n+objects.rma.cloudscale.ch\n+\n@@ -12349,1 +12440,2 @@\n-c.cdn77.org\n+cdn77-storage.com\n+rsc.contentproxy9.cz\n@@ -12352,1 +12444,0 @@\n-rsc.cdn77.org\n@@ -12354,0 +12445,2 @@\n+c.cdn77.org\n+rsc.cdn77.org\n@@ -12356,1 +12449,1 @@\n-\/\/ Submitted by Aleksander Hristov <noc@cloudns.net>\n+\/\/ Submitted by Aleksander Hristov <noc@cloudns.net> & Boyan Peychev <boyan@cloudns.net>\n@@ -12358,0 +12451,1 @@\n+cloudns.be\n@@ -12359,1 +12453,0 @@\n-cloudns.club\n@@ -12361,0 +12454,5 @@\n+cloudns.ch\n+cloudns.cl\n+cloudns.club\n+dnsabr.com\n+cloudns.cx\n@@ -12364,0 +12462,3 @@\n+dns-cloud.net\n+dns-dynamic.net\n+cloudns.nz\n@@ -12365,0 +12466,1 @@\n+cloudns.ph\n@@ -12377,0 +12479,5 @@\n+\/\/ CodeSandbox B.V. : https:\/\/codesandbox.io\n+\/\/ Submitted by Ives van Hoorne <abuse@codesandbox.io>\n+csb.app\n+preview.csb.app\n+\n@@ -12386,0 +12493,4 @@\n+\/\/ Convex : https:\/\/convex.dev\/\n+\/\/ Submitted by James Cowling <security@convex.dev>\n+convex.site\n+\n@@ -12407,0 +12518,4 @@\n+\/\/ cPanel L.L.C. : https:\/\/www.cpanel.net\/\n+\/\/ Submitted by Dustin Scherer <public.suffix@cpanel.net>\n+*.cprapid.com\n+\n@@ -12411,0 +12526,4 @@\n+\/\/ Crisp IM SAS : https:\/\/crisp.chat\/\n+\/\/ Submitted by Baptiste Jamin <hostmaster@crisp.chat>\n+on.crisp.email\n+\n@@ -12431,0 +12550,7 @@\n+\/\/ Cyclic Software : https:\/\/www.cyclic.sh\n+\/\/ Submitted by Kam Lasater <dns-admin@cyclic.sh>\n+cyclic.app\n+cyclic.cloud\n+cyclic-app.com\n+cyclic.co.in\n+\n@@ -12476,0 +12602,1 @@\n+darklang.io\n@@ -12874,0 +13001,4 @@\n+\/\/ DigitalPlat : https:\/\/www.digitalplat.org\/\n+\/\/ Submitted by Edward Hsing <contact@digitalplat.org>\n+us.kg\n+\n@@ -12911,0 +13042,12 @@\n+\/\/ EasyWP : https:\/\/www.easywp.com\n+\/\/ Submitted by <infracloudteam@namecheap.com>\n+*.ewp.live\n+\n+\/\/ Electromagnetic Field : https:\/\/www.emfcamp.org\n+\/\/ Submitted by <noc@emfcamp.org>\n+at.emf.camp\n+\n+\/\/ Elefunc, Inc. : https:\/\/elefunc.com\n+\/\/ Submitted by Cetin Sert <domains@elefunc.com>\n+rt.ht\n+\n@@ -13025,4 +13168,0 @@\n-\/\/ Facebook, Inc.\n-\/\/ Submitted by Peter Ruibal <public-suffix@fb.com>\n-apps.fbsbx.com\n-\n@@ -13186,0 +13325,4 @@\n+\/\/ FlutterFlow : https:\/\/flutterflow.io\n+\/\/ Submitted by Anton Emelyanov <anton@flutterflow.io>\n+flutterflow.app\n+\n@@ -13196,1 +13339,1 @@\n-\/\/ Forgerock : https:\/\/www.forgerock.com\n+\/\/ Forgerock : https:\/\/www.forgerock.com\n@@ -13202,1 +13345,2 @@\n-\/\/ Submitted by Koen Rouwhorst <koenrh@framer.com>\n+\/\/ Submitted by Koen Rouwhorst <security@framer.com>\n+framer.ai\n@@ -13243,0 +13387,18 @@\n+\/\/ Future Versatile Group. ：https:\/\/www.fvg-on.net\/\n+\/\/ T.Kabu <webmaster@fvg-on.net>\n+daemon.asia\n+dix.asia\n+mydns.bz\n+0am.jp\n+0g0.jp\n+0j0.jp\n+0t0.jp\n+mydns.jp\n+pgw.jp\n+wjg.jp\n+keyword-on.net\n+live-on.net\n+server-on.net\n+mydns.tw\n+mydns.vc\n+\n@@ -13254,0 +13416,4 @@\n+\/\/ GCom Internet : https:\/\/www.gcom.net.au\n+\/\/ Submitted by Leo Julius <support@gcom.net.au>\n+aliases121.com\n+\n@@ -13282,3 +13448,5 @@\n-\/\/ Ghost Foundation : https:\/\/ghost.org\n-\/\/ Submitted by Matt Hanley <security@ghost.org>\n-ghost.io\n+\/\/ Getlocalcert: https:\/\/www.getlocalcert.net\n+\/\/ Submitted by Robert Alexander <support@getlocalcert.net>\n+localcert.net\n+localhostcert.net\n+corpnet.work\n@@ -13428,0 +13596,4 @@\n+\/\/ GoDaddy Registry : https:\/\/registry.godaddy\n+\/\/ Submitted by Rohan Durrant <tldns@registry.godaddy>\n+graphic.design\n+\n@@ -13437,4 +13609,0 @@\n-\/\/ UKHomeOffice : https:\/\/www.gov.uk\/government\/organisations\/home-office\n-\/\/ Submitted by Jon Shanks <jon.shanks@digital.homeoffice.gov.uk>\n-homeoffice.gov.uk\n-\n@@ -13451,2 +13619,1 @@\n-run.app\n-a.run.app\n+*.run.app\n@@ -13552,0 +13719,4 @@\n+\/\/ GrayJay Web Solutions Inc. : https:\/\/grayjaysports.ca\n+\/\/ Submitted by Matt Yamkowy <info@grayjaysports.ca>\n+grayjayleagues.com\n+\n@@ -13586,0 +13757,5 @@\n+\/\/ Helio Networks : https:\/\/heliohost.org\n+\/\/ Submitted by Ben Frede <admin@heliohost.org>\n+helioho.st\n+heliohost.us\n+\n@@ -13599,1 +13775,0 @@\n-ravendb.me\n@@ -13607,0 +13782,6 @@\n+\/\/ Homebase : https:\/\/homebase.id\/\n+\/\/ Submitted by Jason Babo <info@homebase.id>\n+*.kin.one\n+*.id.pub\n+*.kin.pub\n+\n@@ -13684,1 +13865,1 @@\n-\/\/ Submitted by Jacob Slater <whois@igloo.to>\n+\/\/ Submitted by June Slater <whois@igloo.to>\n@@ -13733,0 +13914,8 @@\n+\/\/ is-a.dev : https:\/\/www.is-a.dev\n+\/\/ Submitted by William Harrison <admin@maintainers.is-a.dev>\n+is-a.dev\n+\n+\/\/ ir.md : https:\/\/nic.ir.md\n+\/\/ Submitted by Ali Soizi <info@nic.ir.md>\n+ir.md\n+\n@@ -13841,0 +14030,5 @@\n+\/\/ JouwWeb B.V. : https:\/\/www.jouwweb.nl\n+\/\/ Submitted by Camilo Sperberg <tech@webador.com>\n+jouwweb.site\n+webadorsite.com\n+\n@@ -13914,0 +14108,4 @@\n+\/\/ Libre IT Ltd : https:\/\/libre.nz\n+\/\/ Submitted by Tomas Maggio <support@libre.nz>\n+runcontainers.dev\n+\n@@ -13924,4 +14122,0 @@\n-\/\/ Lightmaker Property Manager, Inc. : https:\/\/app.lmpm.com\/\n-\/\/ Submitted by Greg Holland <greg.holland@lmpm.com>\n-app.lmpm.com\n-\n@@ -14060,0 +14254,5 @@\n+\/\/ Meta Platforms, Inc. : https:\/\/meta.com\/\n+\/\/ Submitted by Jacob Cordero <public-suffix@meta.com>\n+atmeta.com\n+apps.fbsbx.com\n+\n@@ -14080,0 +14279,2 @@\n+\/\/ Managed by Corporate Domains\n+\/\/ Microsoft Azure : https:\/\/home.azure\n@@ -14081,0 +14282,3 @@\n+azure-api.net\n+azureedge.net\n+azurefd.net\n@@ -14083,1 +14287,0 @@\n-cloudapp.net\n@@ -14097,0 +14300,4 @@\n+cloudapp.net\n+trafficmanager.net\n+blob.core.windows.net\n+servicebus.windows.net\n@@ -14110,0 +14317,4 @@\n+\/\/ MODX Systems LLC : https:\/\/modx.com\n+\/\/ Submitted by Elizabeth Southwell <elizabeth@modx.com>\n+modx.dev\n+\n@@ -14156,0 +14367,4 @@\n+\/\/ NGO.US Registry : https:\/\/nic.ngo.us\n+\/\/ Submitted by Alstra Solutions Ltd. Networking Team <admin@alstra.org>\n+ngo.us\n+\n@@ -14171,0 +14386,1 @@\n+ngrok.pro\n@@ -14176,1 +14392,1 @@\n-\/\/ Submitted by Nicholas Ford <nick@nimbushosting.co.uk>\n+\/\/ Submitted by Nicholas Ford <dev@nimbushosting.co.uk>\n@@ -14178,0 +14394,1 @@\n+nimsite.uk\n@@ -14183,0 +14400,4 @@\n+\/\/ NFT.Storage : https:\/\/nft.storage\/\n+\/\/ Submitted by Vasco Santos <vasco.santos@protocol.ai> or <support@nft.storage>\n+ipfs.nftstorage.link\n+\n@@ -14333,0 +14554,4 @@\n+\/\/ O3O.Foundation : https:\/\/o3o.foundation\/\n+\/\/ Submitted by the prvcy.page Registry Team <psl@registry.prvcy.page>\n+prvcy.page\n+\n@@ -14362,1 +14587,0 @@\n-123sait.ru\n@@ -14380,0 +14604,7 @@\n+\/\/ Open Domains : https:\/\/open-domains.net\n+\/\/ Submitted by William Harrison <admin@open-domains.net>\n+is-cool.dev\n+is-not-a.dev\n+localplayer.dev\n+is-local.org\n+\n@@ -14400,0 +14631,5 @@\n+\/\/ OsSav Technology Ltd. : https:\/\/ossav.com\/\n+\/\/ TLD Nic: http:\/\/nic.can.re - TLD Whois Server: whois.can.re\n+\/\/ Submitted by OsSav Technology Ltd. <support@ossav.com>\n+can.re\n+\n@@ -14450,4 +14686,5 @@\n-bar0.net\n-bar1.net\n-bar2.net\n-rdv.to\n+*.xmit.co\n+xmit.dev\n+srv.us\n+gh.srv.us\n+gl.srv.us\n@@ -14486,1 +14723,2 @@\n-bc.platform.sh\n+*.upsun.app\n+upsunapp.com\n@@ -14505,0 +14743,4 @@\n+\/\/ Pley AB : https:\/\/www.pley.com\/\n+\/\/ Submitted by Henning Pohl <infra@pley.com>\n+pley.games\n+\n@@ -14536,4 +14778,0 @@\n-\/\/ privacytools.io : https:\/\/www.privacytools.io\/\n-\/\/ Submitted by Jonah Aragon <jonah@privacytools.io>\n-prvcy.page\n-\n@@ -14581,0 +14819,2 @@\n+myradweb.net\n+servername.us\n@@ -14604,2 +14844,2 @@\n-\/\/ Submitted by Nick Chang <nickchang@qnap.com>\n-dev-myqnapcloud.com\n+\/\/ Submitted by Nick Chang <cloudadmin@qnap.com>\n+myqnapcloud.cn\n@@ -14607,0 +14847,3 @@\n+dev-myqnapcloud.com\n+mycloudnas.com\n+mynascloud.com\n@@ -14647,1 +14890,3 @@\n-\/\/ Submitted by Lincoln Bergeson <lincoln@replit.com>\n+\/\/ Submitted by Lincoln Bergeson <psl@repl.it>\n+replit.app\n+id.replit.app\n@@ -14652,0 +14897,27 @@\n+replit.dev\n+archer.replit.dev\n+bones.replit.dev\n+canary.replit.dev\n+global.replit.dev\n+hacker.replit.dev\n+id.replit.dev\n+janeway.replit.dev\n+kim.replit.dev\n+kira.replit.dev\n+kirk.replit.dev\n+odo.replit.dev\n+paris.replit.dev\n+picard.replit.dev\n+pike.replit.dev\n+prerelease.replit.dev\n+reed.replit.dev\n+riker.replit.dev\n+sisko.replit.dev\n+spock.replit.dev\n+staging.replit.dev\n+sulu.replit.dev\n+tarpit.replit.dev\n+teams.replit.dev\n+tucker.replit.dev\n+wesley.replit.dev\n+worf.replit.dev\n@@ -14748,1 +15020,1 @@\n-\/\/ Submitted by Michael Biven <mbiven@salesforce.com>\n+\/\/ Submitted by Michael Biven <mbiven@salesforce.com> and Aaron Romeo <aaron.romeo@salesforce.com>\n@@ -14752,0 +15024,1 @@\n+*.001.test.code-builder-stg.platform.salesforce.com\n@@ -14767,0 +15040,1 @@\n+cockpit.fr-par.scw.cloud\n@@ -14777,0 +15051,1 @@\n+cockpit.nl-ams.scw.cloud\n@@ -14782,0 +15057,1 @@\n+cockpit.pl-waw.scw.cloud\n@@ -14803,0 +15079,4 @@\n+\/\/ Scrypted : https:\/\/scrypted.app\n+\/\/ Submitted by Koushik Dutta <public-suffix-list@scrypted.app>\n+client.scrypted.io\n+\n@@ -14842,0 +15122,4 @@\n+\/\/ Sheezy.Art : https:\/\/sheezy.art\n+\/\/ Submitted by Nyoom <admin@sheezy.art>\n+sheezy.games\n+\n@@ -14890,1 +15174,1 @@\n-\/\/ Former AFNIC's SLDs \n+\/\/ Former AFNIC's SLDs\n@@ -14912,3 +15196,3 @@\n-\/\/ Submitted by Faith Olapade <faith.olapade@snowflake.com>\n-snowflake.app\n-privatelink.snowflake.app\n+\/\/ Submitted by Sam Haar <psl@snowflake.com>\n+*.snowflake.app\n+*.privatelink.snowflake.app\n@@ -14926,0 +15210,6 @@\n+\/\/ StackBlitz : https:\/\/stackblitz.com\n+\/\/ Submitted by Dominic Elm <hello@stackblitz.com>\n+w-corp-staticblitz.com\n+w-credentialless-staticblitz.com\n+w-staticblitz.com\n+\n@@ -14930,0 +15220,8 @@\n+\/\/ STACKIT : https:\/\/www.stackit.de\/en\/\n+\/\/ Submitted by STACKIT-DNS Team (Simon Stier) <stackit-dns@mail.schwarz>\n+runs.onstackit.cloud\n+stackit.gg\n+stackit.rocks\n+stackit.run\n+stackit.zone\n+\n@@ -14996,0 +15294,13 @@\n+\/\/ stereosense GmbH : https:\/\/www.involve.me\n+\/\/ Submitted by Florian Burmann <publicsuffix@involve.me>\n+feedback.ac\n+forms.ac\n+assessments.cx\n+calculators.cx\n+funnels.cx\n+paynow.cx\n+quizzes.cx\n+researched.cx\n+tests.cx\n+surveys.so\n+\n@@ -15004,0 +15315,6 @@\n+\/\/ Streak : https:\/\/streak.com\n+\/\/ Submitted by Blake Kadatz <eng@streak.com>\n+streak-link.com\n+streaklinks.com\n+streakusercontent.com\n+\n@@ -15066,0 +15383,1 @@\n+*.c.ts.net\n@@ -15199,0 +15517,4 @@\n+\/\/ Unison Computing, PBC : https:\/\/unison.cloud\n+\/\/ Submitted by Simon Højberg <security@unison.cloud>\n+unison-services.cloud\n+\n@@ -15248,42 +15570,0 @@\n-\/\/ Voxel.sh DNS : https:\/\/voxel.sh\/dns\/\n-\/\/ Submitted by Mia Rehlinger <dns@voxel.sh>\n-neko.am\n-nyaa.am\n-be.ax\n-cat.ax\n-es.ax\n-eu.ax\n-gg.ax\n-mc.ax\n-us.ax\n-xy.ax\n-nl.ci\n-xx.gl\n-app.gp\n-blog.gt\n-de.gt\n-to.gt\n-be.gy\n-cc.hn\n-blog.kg\n-io.kg\n-jp.kg\n-tv.kg\n-uk.kg\n-us.kg\n-de.ls\n-at.md\n-de.md\n-jp.md\n-to.md\n-indie.porn\n-vxl.sh\n-ch.tc\n-me.tc\n-we.tc\n-nyan.to\n-at.vg\n-blog.vu\n-dev.vu\n-me.vu\n-\n@@ -15302,0 +15582,5 @@\n+\/\/ Webflow, Inc. : https:\/\/www.webflow.com\n+\/\/ Submitted by Webflow Security Team <security@webflow.com>\n+webflow.io\n+webflowtest.io\n+\n@@ -15313,0 +15598,4 @@\n+\/\/ WebWaddle Ltd: https:\/\/webwaddle.com\/\n+\/\/ Submitted by Merlin Glander <hostmaster@webwaddle.com>\n+*.wadl.top\n+\n@@ -15421,0 +15710,4 @@\n+\/\/ ZAP-Hosting GmbH & Co. KG : https:\/\/zap-hosting.com\n+\/\/ Submitted by Julian Alker <security@zap-hosting.com>\n+zap.cloud\n+\n","filename":"src\/java.base\/share\/data\/publicsuffixlist\/public_suffix_list.dat","additions":449,"deletions":156,"binary":false,"changes":605,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/b5bf572c52988dbe9d865b8f090ea819024a9936\/public_suffix_list.dat.\n+https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/1cbd6e71a9b83620b1d0b11e49d3d9ff48c27e22\/public_suffix_list.dat.\n","filename":"src\/java.base\/share\/legal\/public_suffix.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1106,2 +1106,1 @@\n-Shows all categories of settings.\n-This is the default value.\n+Shows all categories of settings in \\f[B]verbose\\f[R] detail.\n@@ -1115,0 +1114,15 @@\n+\\f[V]security\\f[R]\n+Shows all settings related to security.\n+.RS\n+.PP\n+sub-category arguments for \\f[V]security\\f[R] include the following:\n+.IP \\[bu] 2\n+\\f[V]security:all\\f[R] : shows all security settings\n+.IP \\[bu] 2\n+\\f[V]security:properties\\f[R] : shows security properties\n+.IP \\[bu] 2\n+\\f[V]security:providers\\f[R] : shows static security provider settings\n+.IP \\[bu] 2\n+\\f[V]security:tls\\f[R] : shows TLS related security settings\n+.RE\n+.TP\n","filename":"src\/java.base\/share\/man\/java.1","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -519,0 +519,11 @@\n+#if defined(AIX)\n+    \/* at least on AIX try also the LD_LIBRARY_PATH \/ LIBPATH *\/\n+    if (GetApplicationHomeFromLibpath(path, pathsize)) {\n+        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+        if (stat(libjava, &s) == 0) {\n+            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            return JNI_TRUE;\n+        }\n+    }\n+#endif\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+jboolean GetApplicationHomeFromLibpath(char *buf, jint bufsize);\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#define JAVA_DLL \"libjava.so\"\n+\n@@ -111,0 +113,41 @@\n+#if defined(AIX)\n+static jboolean\n+LibjavaExists(const char *path)\n+{\n+    char tmp[PATH_MAX + 1];\n+    struct stat statbuf;\n+    JLI_Snprintf(tmp, PATH_MAX, \"%s\/%s\", path, JAVA_DLL);\n+    if (stat(tmp, &statbuf) == 0) {\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\n+\/*\n+ * Retrieves the path to the JRE home by locating libjava.so in\n+ * LIBPATH and then truncating the path to it.\n+ *\/\n+jboolean\n+GetApplicationHomeFromLibpath(char *buf, jint bufsize)\n+{\n+    char *env = getenv(\"LIBPATH\");\n+    char *tmp;\n+    char *save_ptr = NULL;\n+    char *envpath = JLI_StringDup(env);\n+    for (tmp = strtok_r(envpath, \":\", &save_ptr); tmp != NULL; tmp = strtok_r(NULL, \":\", &save_ptr)) {\n+        if (LibjavaExists(tmp)) {\n+            char *path = realpath(tmp, buf);\n+            if (path == buf) {\n+                JLI_StrCat(buf, \"\/\");\n+                if (JNI_TRUE == TruncatePath(buf, JNI_TRUE)) {\n+                    JLI_MemFree(envpath);\n+                    return JNI_TRUE;\n+                }\n+            }\n+        }\n+    }\n+    JLI_MemFree(envpath);\n+    return JNI_FALSE;\n+}\n+#endif\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md_common.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-     * @since 14\n+     * @since 16\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,0 +253,2 @@\n+     *\n+     * @since 14\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner6.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-     * Returns the text of the documentation (&quot;Javadoc&quot;)\n+     * Returns the text of the documentation (&quot;JavaDoc&quot;)\n@@ -283,8 +283,8 @@\n-     * <p> A documentation comment of an element is a comment that\n-     * begins with \"{@code \/**}\", ends with a separate\n-     * \"<code>*&#47;<\/code>\", and immediately precedes the element,\n-     * ignoring white space, annotations, end-of-line-comments ({@code\n-     * \"\/\/\"} comments), and intermediate traditional comments\n-     * (<code>\"\/* ... *&#47;\"<\/code> comments) that are not doc comments.\n-     * Therefore, a documentation comment\n-     * contains at least three \"{@code *}\" characters.  The text\n+     * <p>A documentation comment of an element is a particular kind\n+     * of comment that immediately precedes the element, ignoring\n+     * white space, annotations and any other comments that are\n+     * not themselves documentation comments.\n+     *\n+     * <p>There are two kinds of documentation comments, either based on\n+     * <em>traditional comments<\/em> or based on a series of\n+     * <em>end-of-line comments<\/em>. For both kinds, the text\n@@ -292,1 +292,8 @@\n-     * the comment as it appears in source code:\n+     * the comment as it appears in source code, as described below.\n+     *\n+     * <p>A {@linkplain DocCommentKind#TRADITIONAL traditional\n+     * documentation comment} is a traditional comment that begins\n+     * with \"{@code \/**}\", and ends with a separate \"<code>*&#47;<\/code>\".\n+     * (Therefore, such a comment contains at least three \"{@code *}\"\n+     * characters.)\n+     * The lines of such a comment are processed as follows:\n@@ -300,2 +307,2 @@\n-     * if the lines start with <em>zero<\/em> or more whitespace characters followed by\n-     * <em>one<\/em> or more \"{@code *}\" characters,\n+     * if the lines start with <em>zero<\/em> or more whitespace characters\n+     * followed by <em>one<\/em> or more \"{@code *}\" characters,\n@@ -309,3 +316,25 @@\n-     * space and \"{@code *}\" character removal as described above. If all the characters\n-     * of the line are removed, it makes no contribution to the\n-     * returned comment.\n+     * space and \"{@code *}\" character removal as described above.\n+     * <li>The processed lines are then concatenated together,\n+     * separated by newline (\"{@code \\n}\") characters, and returned.\n+     * <\/ul>\n+     *\n+     * <p>An {@linkplain DocCommentKind#END_OF_LINE end-of-line\n+     * documentation comment} is a series of adjacent end-of-line\n+     * comments, each on a line by itself, ignoring any whitespace\n+     * characters at the beginning of the line, and each beginning\n+     * with \"{@code \/\/\/}\".\n+     * The lines of such a comment are processed as follows:\n+     * <ul>\n+     * <li>Any leading whitespace and the three initial \"{@code \/}\"\n+     * characters are removed from each line.\n+     * <li>The lines are shifted left, by removing leading whitespace\n+     * characters, until the non-blank line with the least leading\n+     * whitespace characters has no remaining leading whitespace\n+     * characters.\n+     * <li>Additional leading whitespace characters and any trailing\n+     * whitespace characters in each line are preserved.\n+     * <li>\n+     * The processed lines are then concatenated together,\n+     * separated by newline (\"{@code \\n}\") characters, and returned.\n+     * If the last line is not blank, the returned value will not be\n+     * terminated by a newline character.\n@@ -313,3 +342,0 @@\n-     * The processed lines are then\n-     * concatenated together (including line terminators) and\n-     * returned.\n@@ -322,0 +348,4 @@\n+     *\n+     * @apiNote\n+     * Documentation comments are processed by the standard doclet\n+     * used by the {@code javadoc} tool to generate API documentation.\n@@ -325,0 +355,43 @@\n+    \/**\n+     * {@return the kind of the documentation comment for the given element,\n+     * or {@code null} if there is no comment or the kind is not known}\n+     *\n+     * @implSpec The default implementation of this method returns\n+     * {@code null}.\n+     *\n+     * @param e the element being examined\n+     * @since 23\n+     *\/\n+    default DocCommentKind getDocCommentKind(Element e) {\n+        return null;\n+    }\n+\n+    \/**\n+     * The kind of documentation comment.\n+     *\n+     * @since 23\n+     *\/\n+    enum DocCommentKind {\n+        \/**\n+         * The kind of comments whose lines are prefixed by {@code \/\/\/}.\n+         *\n+         * @apiNote\n+         * The standard doclet used by the {@code javadoc} tool treats these comments\n+         * as containing Markdown and documentation comment tags.\n+         *\n+         *\n+         * @see <a href=\"https:\/\/openjdk.org\/jeps\/467\">\n+         * JEP 467: Markdown Documentation Comments<\/a>\n+         *\/\n+        END_OF_LINE,\n+\n+        \/**\n+         * The kind of comments that begin with {@code \/**}.\n+         *\n+         * @apiNote\n+         * The standard doclet used by the {@code javadoc} tool treats these comments\n+         * as containing HTML and documentation comment tags.\n+         *\/\n+        TRADITIONAL\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":91,"deletions":18,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -157,0 +157,2 @@\n+     *\n+     * @since 18\n@@ -217,0 +219,2 @@\n+     *\n+     * @since 18\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileManager.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,0 +351,2 @@\n+        Color tabbedPaneBg = new ColorUIResource(238, 238, 238);\n+        Color unselectedTabColor = new ColorUIResource(255, 255, 255);\n@@ -1023,0 +1025,5 @@\n+            \"TabbedPane.selected\", tabbedPaneBg,\n+            \"TabbedPane.contentOpaque\", Boolean.TRUE,\n+            \"TabbedPane.tabsOpaque\", Boolean.TRUE,\n+            \"TabbedPane.contentAreaColor\", tabbedPaneBg,\n+            \"TabbedPane.unselectedBackground\", unselectedTabColor,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -975,0 +975,3 @@\n+        \/\/ Fill the tab rect area\n+        g.fillRect(x, y, w, h);\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKPainter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-            \/\/ reset current status byte to 0 (invalid value).\n+            \/\/ reset current running status byte to 0 (invalid value).\n@@ -319,1 +319,1 @@\n-            int status = 0;\n+            int runningStatus = 0;\n@@ -336,0 +336,1 @@\n+                int status;\n@@ -338,0 +339,5 @@\n+\n+                    \/\/ update running status (only for channel messages)\n+                    if ((status & 0xF0) != 0xF0) {\n+                        runningStatus = status;\n+                    }\n@@ -339,1 +345,2 @@\n-                    data1 = byteValue;\n+                    status = runningStatus;\n+                    data1  = byteValue;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/StandardMidiFileReader.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,1 @@\n+     * @deprecated this method will be removed when java.beans.beancontext is removed\n@@ -106,1 +107,2 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @Deprecated(since = \"23\", forRemoval = true)\n+    @SuppressWarnings({\"deprecation\", \"removal\"})\n@@ -355,1 +357,2 @@\n-    @SuppressWarnings(\"unchecked\")\n+    @Deprecated(since = \"23\", forRemoval = true)\n+    @SuppressWarnings({ \"unchecked\", \"removal\" })\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Beans.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,2 @@\n-@SuppressWarnings(\"rawtypes\")\n+@Deprecated(since = \"23\", forRemoval = true)\n+@SuppressWarnings({\"rawtypes\", \"removal\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextChild.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextChildComponentProxy.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextChildSupport.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextContainerProxy.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextMembershipEvent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextMembershipListener.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextProxy.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since=\"23\", forRemoval=true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServiceAvailableEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServiceProvider.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServiceProviderBeanInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServiceRevokedEvent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServiceRevokedListener.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,3 @@\n+\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServices.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 1014, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServicesListener.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,3 @@\n+\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextServicesSupport.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,0 +62,3 @@\n+\n+@SuppressWarnings(\"removal\")\n+@Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextSupport.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,7 @@\n+ * This package has been deprecated and may be removed in a future version of the Java Platform\n+ * There is no replacement.\n+ *\n+ * All of the classes and interfaces in this package have been terminally deprecated.\n+ *\n+ * Users are advised to migrate their applications to other technologies.\n+ *\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/package-info.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-     * Typically, the return value is true, because is most cases the editing\n+     * Typically, the return value is true, because in most cases the editing\n@@ -90,2 +90,2 @@\n-     * keep the selection from changing for some types of edits.\n-     * eg. A table that contains a column of check boxes, the user might\n+     * keep the selection from changing for some types of edits,\n+     * e.g. in a table that contains a column of check boxes, the user might\n@@ -93,1 +93,1 @@\n-     * selection.  (See Netscape Communicator for just such an example)\n+     * selection.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/CellEditor.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,3 @@\n+      <uiColor name=\"nimbusTabbedPaneContentArea\">\n+         <matte red=\"238\" green=\"238\" blue=\"238\" alpha=\"255\" hueOffset=\"0.0\" saturationOffset=\"0.0\" brightnessOffset=\"0.0\" alphaOffset=\"0\"\/>\n+      <\/uiColor>\n@@ -21649,0 +21652,5 @@\n+               <uiProperty name=\"contentOpaque\" type=\"BOOLEAN\" value=\"true\"\/>\n+               <uiProperty name=\"tabsOpaque\" type=\"BOOLEAN\" value=\"true\"\/>\n+               <uiProperty name=\"contentAreaColor\" type=\"COLOR\">\n+                  <matte red=\"238\" green=\"238\" blue=\"238\" alpha=\"255\" uiDefaultParentName=\"nimbusTabbedPaneContentArea\" hueOffset=\"0.0\" saturationOffset=\"0.0\" brightnessOffset=\"0.0\" alphaOffset=\"0\"\/>\n+               <\/uiProperty>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/skin.laf","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.awt.Color;\n@@ -124,0 +125,7 @@\n+    \/\/ Background color for selected tab and content pane\n+    private Color selectColor;\n+    \/\/ Background color for unselected tabs\n+    private Color unselectedBackground;\n+    private boolean contentOpaque = true;\n+    private boolean tabsOpaque = true;\n+\n@@ -149,0 +157,4 @@\n+        selectColor = UIManager.getColor(\"TabbedPane.selected\");\n+        contentOpaque = UIManager.getBoolean(\"TabbedPane.contentOpaque\");\n+        tabsOpaque = UIManager.getBoolean(\"TabbedPane.tabsOpaque\");\n+        unselectedBackground = UIManager.getColor(\"TabbedPane.unselectedBackground\");\n@@ -639,2 +651,11 @@\n-        tabContext.getPainter().paintTabbedPaneTabBackground(tabContext, g,\n-                x, y, width, height, tabIndex, placement);\n+\n+        if (isSelected) {\n+            g.setColor(selectColor);\n+        } else {\n+            g.setColor(getUnselectedBackgroundAt(tabIndex));\n+        }\n+\n+        if (tabsOpaque || tabPane.isOpaque()) {\n+            tabContext.getPainter().paintTabbedPaneTabBackground(tabContext, g,\n+                    x, y, width, height, tabIndex, placement);\n+        }\n@@ -658,0 +679,2 @@\n+        }\n+    }\n@@ -659,1 +682,4 @@\n-\n+    private Color getUnselectedBackgroundAt(int index) {\n+        Color color = tabPane.getBackgroundAt(index);\n+        if (color instanceof UIResource && unselectedBackground != null) {\n+            return unselectedBackground;\n@@ -661,0 +687,1 @@\n+        return color;\n@@ -740,0 +767,15 @@\n+\n+        if (tabPane.getTabCount() > 0 && (contentOpaque || tabPane.isOpaque())) {\n+            \/\/ Fill region behind content area\n+            Color color = UIManager.getColor(\"TabbedPane.contentAreaColor\");\n+            if (color != null) {\n+                g.setColor(color);\n+            } else if (selectColor == null || selectedIndex == -1) {\n+                g.setColor(tabPane.getBackground());\n+            } else {\n+                g.setColor(selectColor);\n+            }\n+            \/\/ fill content area rect for both GTK and Nimbus LAF here\n+            g.fillRect(x, y, w, h);\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTabbedPaneUI.java","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -59,4 +59,0 @@\n-    public static CodePointIterator create(CharSequence text) {\n-        return new CharSequenceCodePointIterator(text);\n-    }\n-\n@@ -132,51 +128,0 @@\n-final class CharSequenceCodePointIterator extends CodePointIterator {\n-    private CharSequence text;\n-    private int index;\n-\n-    public CharSequenceCodePointIterator(CharSequence text) {\n-        this.text = text;\n-    }\n-\n-    public void setToStart() {\n-        index = 0;\n-    }\n-\n-    public void setToLimit() {\n-        index = text.length();\n-    }\n-\n-    public int next() {\n-        if (index < text.length()) {\n-            char cp1 = text.charAt(index++);\n-            if (Character.isHighSurrogate(cp1) && index < text.length()) {\n-                char cp2 = text.charAt(index+1);\n-                if (Character.isLowSurrogate(cp2)) {\n-                    ++index;\n-                    return Character.toCodePoint(cp1, cp2);\n-                }\n-            }\n-            return cp1;\n-        }\n-        return DONE;\n-    }\n-\n-    public int prev() {\n-        if (index > 0) {\n-            char cp2 = text.charAt(--index);\n-            if (Character.isLowSurrogate(cp2) && index > 0) {\n-                char cp1 = text.charAt(index - 1);\n-                if (Character.isHighSurrogate(cp1)) {\n-                    --index;\n-                    return Character.toCodePoint(cp1, cp2);\n-                }\n-            }\n-            return cp2;\n-        }\n-        return DONE;\n-    }\n-\n-    public int charIndex() {\n-        return index;\n-    }\n-}\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CodePointIterator.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## GIFLIB v5.2.1\n+## GIFLIB v5.2.2\n@@ -27,1 +27,1 @@\n-https:\/\/sourceforge.net\/p\/giflib\/code\/ci\/master\/tree\/openbsd-reallocarray.c\n+tree\/README\n@@ -29,1 +29,19 @@\n-Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>\n+== Authors ==\n+\n+Gershon Elber <gershon[AT]cs.technion.sc.il>\n+original giflib code\n+\n+Toshio Kuratomi <toshio[AT]tiki-lounge.com>\n+uncompressed gif writing code\n+former maintainer\n+\n+Eric Raymond <esr[AT]snark.thyrsus.com>\n+current as well as long time former maintainer of giflib code\n+\n+There have been many other contributors; see the attributions in the\n+version-control history to learn more.\n+\n+\n+tree\/openbsd-reallocarray.c\n+\n+Copyright (C) 2008 Otto Moerbeek <otto@drijf.net>\n@@ -31,0 +49,2 @@\n+\n+```\n","filename":"src\/java.desktop\/share\/legal\/giflib.md","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include <stdlib.h>\n+#include <fcntl.h>\n@@ -40,1 +40,0 @@\n-#include <fcntl.h>\n@@ -42,0 +41,1 @@\n+#include <stdlib.h>\n@@ -58,5 +58,5 @@\n-    \/\/fprintf(stderr, \"### Read: %d\\n\", len);\n-    return\n-    (((GifFilePrivateType*)gif->Private)->Read ?\n-     ((GifFilePrivateType*)gif->Private)->Read(gif,buf,len) :\n-     fread(buf,1,len,((GifFilePrivateType*)gif->Private)->File));\n+    \/\/ fprintf(stderr, \"### Read: %d\\n\", len);\n+    return (((GifFilePrivateType *)gif->Private)->Read\n+                ? ((GifFilePrivateType *)gif->Private)->Read(gif, buf, len)\n+                : fread(buf, 1, len,\n+                        ((GifFilePrivateType *)gif->Private)->File));\n@@ -69,1 +69,2 @@\n-static int DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode);\n+static int DGifGetPrefixChar(const GifPrefixType *Prefix, int Code,\n+                             int ClearCode);\n@@ -79,3 +80,1 @@\n-GifFileType *\n-DGifOpenFileName(const char *FileName, int *Error)\n-{\n+GifFileType *DGifOpenFileName(const char *FileName, int *Error) {\n@@ -86,1 +85,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -88,0 +87,1 @@\n+        }\n@@ -100,3 +100,1 @@\n-GifFileType *\n-DGifOpenFileHandle(int FileHandle, int *Error)\n-{\n+GifFileType *DGifOpenFileHandle(int FileHandle, int *Error) {\n@@ -110,1 +108,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -112,0 +110,1 @@\n+        }\n@@ -116,1 +115,1 @@\n-    \/*@i1@*\/memset(GifFile, '\\0', sizeof(GifFileType));\n+    \/*@i1@*\/ memset(GifFile, '\\0', sizeof(GifFileType));\n@@ -124,1 +123,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -126,0 +125,1 @@\n+        }\n@@ -131,1 +131,1 @@\n-    \/*@i1@*\/memset(Private, '\\0', sizeof(GifFilePrivateType));\n+    \/*@i1@*\/ memset(Private, '\\0', sizeof(GifFilePrivateType));\n@@ -134,2 +134,2 @@\n-    _setmode(FileHandle, O_BINARY);    \/* Make sure it is in binary mode. *\/\n-#endif \/* _WIN32 *\/\n+    _setmode(FileHandle, O_BINARY); \/* Make sure it is in binary mode. *\/\n+#endif                                  \/* _WIN32 *\/\n@@ -137,1 +137,1 @@\n-    f = fdopen(FileHandle, \"rb\");    \/* Make it into a stream: *\/\n+    f = fdopen(FileHandle, \"rb\"); \/* Make it into a stream: *\/\n@@ -144,2 +144,2 @@\n-    Private->Read = NULL;        \/* don't use alternate input method (TVT) *\/\n-    GifFile->UserData = NULL;    \/* TVT *\/\n+    Private->Read = NULL;     \/* don't use alternate input method (TVT) *\/\n+    GifFile->UserData = NULL; \/* TVT *\/\n@@ -150,2 +150,3 @@\n-    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {\n-        if (Error != NULL)\n+    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) !=\n+        GIF_STAMP_LEN) {\n+        if (Error != NULL) {\n@@ -153,0 +154,1 @@\n+        }\n@@ -162,1 +164,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -164,0 +166,1 @@\n+        }\n@@ -180,1 +183,1 @@\n-    Private->gif89 = (Buf[GIF_VERSION_POS] == '9');\n+    Private->gif89 = (Buf[GIF_VERSION_POS + 1] == '9');\n@@ -188,3 +191,1 @@\n-GifFileType *\n-DGifOpen(void *userData, InputFunc readFunc, int *Error)\n-{\n+GifFileType *DGifOpen(void *userData, InputFunc readFunc, int *Error) {\n@@ -197,1 +198,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -199,0 +200,1 @@\n+        }\n@@ -210,1 +212,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -212,0 +214,1 @@\n+        }\n@@ -215,1 +218,1 @@\n-    \/*@i1@*\/memset(Private, '\\0', sizeof(GifFilePrivateType));\n+    \/*@i1@*\/ memset(Private, '\\0', sizeof(GifFilePrivateType));\n@@ -222,2 +225,2 @@\n-    Private->Read = readFunc;    \/* TVT *\/\n-    GifFile->UserData = userData;    \/* TVT *\/\n+    Private->Read = readFunc;     \/* TVT *\/\n+    GifFile->UserData = userData; \/* TVT *\/\n@@ -227,2 +230,3 @@\n-    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {\n-        if (Error != NULL)\n+    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) !=\n+        GIF_STAMP_LEN) {\n+        if (Error != NULL) {\n@@ -230,0 +234,1 @@\n+        }\n@@ -238,1 +243,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -240,0 +245,1 @@\n+        }\n@@ -248,1 +254,1 @@\n-        if (Error != NULL)\n+        if (Error != NULL) {\n@@ -250,0 +256,1 @@\n+        }\n@@ -256,1 +263,1 @@\n-    Private->gif89 = (Buf[GIF_VERSION_POS] == '9');\n+    Private->gif89 = (Buf[GIF_VERSION_POS + 1] == '9');\n@@ -265,3 +272,1 @@\n-int\n-DGifGetScreenDesc(GifFileType *GifFile)\n-{\n+int DGifGetScreenDesc(GifFileType *GifFile) {\n@@ -281,1 +286,1 @@\n-        DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR)\n+        DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR) {\n@@ -283,0 +288,1 @@\n+    }\n@@ -295,1 +301,1 @@\n-    if (Buf[0] & 0x80) {    \/* Do we have global color map? *\/\n+    if (Buf[0] & 0x80) { \/* Do we have global color map? *\/\n@@ -330,4 +336,2 @@\n-const char *\n-DGifGetGifVersion(GifFileType *GifFile)\n-{\n-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n+const char *DGifGetGifVersion(GifFileType *GifFile) {\n+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;\n@@ -335,1 +339,1 @@\n-    if (Private->gif89)\n+    if (Private->gif89) {\n@@ -337,1 +341,1 @@\n-    else\n+    } else {\n@@ -339,0 +343,1 @@\n+    }\n@@ -344,3 +349,1 @@\n-int\n-DGifGetRecordType(GifFileType *GifFile, GifRecordType* Type)\n-{\n+int DGifGetRecordType(GifFileType *GifFile, GifRecordType *Type) {\n@@ -362,1 +365,1 @@\n-    \/\/fprintf(stderr, \"### DGifGetRecordType: %02x\\n\", Buf);\n+    \/\/ fprintf(stderr, \"### DGifGetRecordType: %02x\\n\", Buf);\n@@ -364,13 +367,13 @@\n-      case DESCRIPTOR_INTRODUCER:\n-          *Type = IMAGE_DESC_RECORD_TYPE;\n-          break;\n-      case EXTENSION_INTRODUCER:\n-          *Type = EXTENSION_RECORD_TYPE;\n-          break;\n-      case TERMINATOR_INTRODUCER:\n-          *Type = TERMINATE_RECORD_TYPE;\n-          break;\n-      default:\n-          *Type = UNDEFINED_RECORD_TYPE;\n-          GifFile->Error = D_GIF_ERR_WRONG_RECORD;\n-          return GIF_ERROR;\n+    case DESCRIPTOR_INTRODUCER:\n+        *Type = IMAGE_DESC_RECORD_TYPE;\n+        break;\n+    case EXTENSION_INTRODUCER:\n+        *Type = EXTENSION_RECORD_TYPE;\n+        break;\n+    case TERMINATOR_INTRODUCER:\n+        *Type = TERMINATE_RECORD_TYPE;\n+        break;\n+    default:\n+        *Type = UNDEFINED_RECORD_TYPE;\n+        GifFile->Error = D_GIF_ERR_WRONG_RECORD;\n+        return GIF_ERROR;\n@@ -382,3 +385,1 @@\n-int\n-DGifGetImageHeader(GifFileType *GifFile)\n-{\n+int DGifGetImageHeader(GifFileType *GifFile) {\n@@ -398,1 +399,1 @@\n-        DGifGetWord(GifFile, &GifFile->Image.Height) == GIF_ERROR)\n+        DGifGetWord(GifFile, &GifFile->Image.Height) == GIF_ERROR) {\n@@ -400,0 +401,1 @@\n+    }\n@@ -418,1 +420,2 @@\n-        GifFile->Image.ColorMap = GifMakeMapObject(1 << BitsPerPixel, NULL);\n+        GifFile->Image.ColorMap =\n+            GifMakeMapObject(1 << BitsPerPixel, NULL);\n@@ -439,2 +442,2 @@\n-    Private->PixelCount = (long)GifFile->Image.Width *\n-       (long)GifFile->Image.Height;\n+    Private->PixelCount =\n+        (long)GifFile->Image.Width * (long)GifFile->Image.Height;\n@@ -450,3 +453,1 @@\n-int\n-DGifGetImageDesc(GifFileType *GifFile)\n-{\n+int DGifGetImageDesc(GifFileType *GifFile) {\n@@ -467,3 +468,3 @@\n-        SavedImage* new_saved_images =\n-            (SavedImage *)reallocarray(GifFile->SavedImages,\n-                            (GifFile->ImageCount + 1), sizeof(SavedImage));\n+        SavedImage *new_saved_images = (SavedImage *)reallocarray(\n+            GifFile->SavedImages, (GifFile->ImageCount + 1),\n+            sizeof(SavedImage));\n@@ -477,1 +478,1 @@\n-             (SavedImage *) malloc(sizeof(SavedImage))) == NULL) {\n+                 (SavedImage *)malloc(sizeof(SavedImage))) == NULL) {\n@@ -486,3 +487,3 @@\n-        sp->ImageDesc.ColorMap = GifMakeMapObject(\n-                                 GifFile->Image.ColorMap->ColorCount,\n-                                 GifFile->Image.ColorMap->Colors);\n+        sp->ImageDesc.ColorMap =\n+            GifMakeMapObject(GifFile->Image.ColorMap->ColorCount,\n+                             GifFile->Image.ColorMap->Colors);\n@@ -496,1 +497,1 @@\n-    sp->ExtensionBlocks = (ExtensionBlock *) NULL;\n+    sp->ExtensionBlocks = (ExtensionBlock *)NULL;\n@@ -506,3 +507,1 @@\n-int\n-DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)\n-{\n+int DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen) {\n@@ -510,1 +509,1 @@\n-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;\n@@ -518,1 +517,1 @@\n-    if (!LineLen)\n+    if (!LineLen) {\n@@ -520,0 +519,1 @@\n+    }\n@@ -528,3 +528,3 @@\n-            \/* We probably won't be called any more, so let's clean up\n-             * everything before we return: need to flush out all the\n-             * rest of image until an empty block (size 0)\n+            \/* We probably won't be called any more, so let's clean\n+             * up everything before we return: need to flush out all\n+             * the rest of image until an empty block (size 0)\n@@ -533,2 +533,3 @@\n-            do\n-                if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)\n+            do {\n+                if (DGifGetCodeNext(GifFile, &Dummy) ==\n+                    GIF_ERROR) {\n@@ -536,1 +537,2 @@\n-            while (Dummy != NULL) ;\n+                }\n+            } while (Dummy != NULL);\n@@ -539,1 +541,1 @@\n-    } else\n+    } else {\n@@ -541,0 +543,1 @@\n+    }\n@@ -546,3 +549,1 @@\n-int\n-DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel)\n-{\n+int DGifGetPixel(GifFileType *GifFile, GifPixelType Pixel) {\n@@ -550,1 +551,1 @@\n-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;\n@@ -557,2 +558,1 @@\n-    if (--Private->PixelCount > 0xffff0000UL)\n-    {\n+    if (--Private->PixelCount > 0xffff0000UL) {\n@@ -565,3 +565,3 @@\n-            \/* We probably won't be called any more, so let's clean up\n-             * everything before we return: need to flush out all the\n-             * rest of image until an empty block (size 0)\n+            \/* We probably won't be called any more, so let's clean\n+             * up everything before we return: need to flush out all\n+             * the rest of image until an empty block (size 0)\n@@ -570,2 +570,3 @@\n-            do\n-                if (DGifGetCodeNext(GifFile, &Dummy) == GIF_ERROR)\n+            do {\n+                if (DGifGetCodeNext(GifFile, &Dummy) ==\n+                    GIF_ERROR) {\n@@ -573,1 +574,2 @@\n-            while (Dummy != NULL) ;\n+                }\n+            } while (Dummy != NULL);\n@@ -576,1 +578,1 @@\n-    } else\n+    } else {\n@@ -578,0 +580,1 @@\n+    }\n@@ -587,3 +590,2 @@\n-int\n-DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)\n-{\n+int DGifGetExtension(GifFileType *GifFile, int *ExtCode,\n+                     GifByteType **Extension) {\n@@ -593,1 +595,1 @@\n-    \/\/fprintf(stderr, \"### -> DGifGetExtension:\\n\");\n+    \/\/ fprintf(stderr, \"### -> DGifGetExtension:\\n\");\n@@ -606,1 +608,2 @@\n-    \/\/fprintf(stderr, \"### <- DGifGetExtension: %02x, about to call next\\n\", Buf);\n+    \/\/ fprintf(stderr, \"### <- DGifGetExtension: %02x, about to call\n+    \/\/ next\\n\", Buf);\n@@ -616,3 +619,1 @@\n-int\n-DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)\n-{\n+int DGifGetExtensionNext(GifFileType *GifFile, GifByteType **Extension) {\n@@ -622,1 +623,1 @@\n-    \/\/fprintf(stderr, \"### -> DGifGetExtensionNext\\n\");\n+    \/\/ fprintf(stderr, \"### -> DGifGetExtensionNext\\n\");\n@@ -627,1 +628,1 @@\n-    \/\/fprintf(stderr, \"### DGifGetExtensionNext sees %d\\n\", Buf);\n+    \/\/ fprintf(stderr, \"### DGifGetExtensionNext sees %d\\n\", Buf);\n@@ -630,3 +631,4 @@\n-        *Extension = Private->Buf;    \/* Use private unused buffer. *\/\n-        (*Extension)[0] = Buf;  \/* Pascal strings notation (pos. 0 is len.). *\/\n-        \/* coverity[tainted_data,check_return] *\/\n+        *Extension = Private->Buf; \/* Use private unused buffer. *\/\n+        (*Extension)[0] =\n+            Buf; \/* Pascal strings notation (pos. 0 is len.). *\/\n+                 \/* coverity[tainted_data,check_return] *\/\n@@ -637,1 +639,1 @@\n-    } else\n+    } else {\n@@ -639,1 +641,2 @@\n-    \/\/fprintf(stderr, \"### <- DGifGetExtensionNext: %p\\n\", Extension);\n+    }\n+    \/\/ fprintf(stderr, \"### <- DGifGetExtensionNext: %p\\n\", Extension);\n@@ -650,2 +653,1 @@\n-                       GraphicsControlBlock *GCB)\n-{\n+                       GraphicsControlBlock *GCB) {\n@@ -658,2 +660,3 @@\n-    GCB->DelayTime = UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);\n-    if (GifExtension[0] & 0x01)\n+    GCB->DelayTime =\n+        UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);\n+    if (GifExtension[0] & 0x01) {\n@@ -661,1 +664,1 @@\n-    else\n+    } else {\n@@ -663,0 +666,1 @@\n+    }\n@@ -671,3 +675,2 @@\n-int DGifSavedExtensionToGCB(GifFileType *GifFile,\n-                int ImageIndex, GraphicsControlBlock *GCB)\n-{\n+int DGifSavedExtensionToGCB(GifFileType *GifFile, int ImageIndex,\n+                            GraphicsControlBlock *GCB) {\n@@ -676,1 +679,1 @@\n-    if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1)\n+    if (ImageIndex < 0 || ImageIndex > GifFile->ImageCount - 1) {\n@@ -678,0 +681,1 @@\n+    }\n@@ -684,4 +688,8 @@\n-    for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount; i++) {\n-        ExtensionBlock *ep = &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];\n-        if (ep->Function == GRAPHICS_EXT_FUNC_CODE)\n-            return DGifExtensionToGCB(ep->ByteCount, ep->Bytes, GCB);\n+    for (i = 0; i < GifFile->SavedImages[ImageIndex].ExtensionBlockCount;\n+         i++) {\n+        ExtensionBlock *ep =\n+            &GifFile->SavedImages[ImageIndex].ExtensionBlocks[i];\n+        if (ep->Function == GRAPHICS_EXT_FUNC_CODE) {\n+            return DGifExtensionToGCB(ep->ByteCount, ep->Bytes,\n+                                      GCB);\n+        }\n@@ -696,3 +704,1 @@\n-int\n-DGifCloseFile(GifFileType *GifFile, int *ErrorCode)\n-{\n+int DGifCloseFile(GifFileType *GifFile, int *ErrorCode) {\n@@ -701,1 +707,1 @@\n-    if (GifFile == NULL || GifFile->Private == NULL)\n+    if (GifFile == NULL || GifFile->Private == NULL) {\n@@ -703,0 +709,1 @@\n+    }\n@@ -719,1 +726,2 @@\n-    GifFreeExtensions(&GifFile->ExtensionBlockCount, &GifFile->ExtensionBlocks);\n+    GifFreeExtensions(&GifFile->ExtensionBlockCount,\n+                      &GifFile->ExtensionBlocks);\n@@ -721,1 +729,1 @@\n-    Private = (GifFilePrivateType *) GifFile->Private;\n+    Private = (GifFilePrivateType *)GifFile->Private;\n@@ -725,1 +733,1 @@\n-        if (ErrorCode != NULL)\n+        if (ErrorCode != NULL) {\n@@ -727,0 +735,1 @@\n+        }\n@@ -733,1 +742,1 @@\n-        if (ErrorCode != NULL)\n+        if (ErrorCode != NULL) {\n@@ -735,0 +744,1 @@\n+        }\n@@ -742,1 +752,1 @@\n-    if (ErrorCode != NULL)\n+    if (ErrorCode != NULL) {\n@@ -744,0 +754,1 @@\n+    }\n@@ -750,3 +761,1 @@\n-static int\n-DGifGetWord(GifFileType *GifFile, GifWord *Word)\n-{\n+static int DGifGetWord(GifFileType *GifFile, GifWord *Word) {\n@@ -772,3 +781,1 @@\n-int\n-DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock)\n-{\n+int DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock) {\n@@ -793,3 +800,1 @@\n-int\n-DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock)\n-{\n+int DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock) {\n@@ -808,3 +813,4 @@\n-        *CodeBlock = Private->Buf;    \/* Use private unused buffer. *\/\n-        (*CodeBlock)[0] = Buf;  \/* Pascal strings notation (pos. 0 is len.). *\/\n-        \/* coverity[tainted_data] *\/\n+        *CodeBlock = Private->Buf; \/* Use private unused buffer. *\/\n+        (*CodeBlock)[0] =\n+            Buf; \/* Pascal strings notation (pos. 0 is len.). *\/\n+                 \/* coverity[tainted_data] *\/\n@@ -817,2 +823,3 @@\n-        Private->Buf[0] = 0;    \/* Make sure the buffer is empty! *\/\n-        Private->PixelCount = 0;    \/* And local info. indicate image read. *\/\n+        Private->Buf[0] = 0; \/* Make sure the buffer is empty! *\/\n+        Private->PixelCount =\n+            0; \/* And local info. indicate image read. *\/\n@@ -827,3 +834,1 @@\n-static int\n-DGifSetupDecompress(GifFileType *GifFile)\n-{\n+static int DGifSetupDecompress(GifFileType *GifFile) {\n@@ -836,2 +841,4 @@\n-    if (InternalRead(GifFile, &CodeSize, 1) < 1) {    \/* Read Code size from file. *\/\n-        return GIF_ERROR;    \/* Failed to read Code size. *\/\n+    if (InternalRead(GifFile, &CodeSize, 1) <\n+        1) { \/* Read Code size from file. *\/\n+        GifFile->Error = D_GIF_ERR_READ_FAILED;\n+        return GIF_ERROR; \/* Failed to read Code size. *\/\n@@ -843,2 +850,3 @@\n-        GifFile->Error = D_GIF_ERR_READ_FAILED;    \/* somewhat bogus error code *\/\n-        return GIF_ERROR;    \/* Failed to read Code size. *\/\n+        GifFile->Error =\n+            D_GIF_ERR_READ_FAILED; \/* somewhat bogus error code *\/\n+        return GIF_ERROR;          \/* Failed to read Code size. *\/\n@@ -847,1 +855,1 @@\n-    Private->Buf[0] = 0;    \/* Input Buffer empty. *\/\n+    Private->Buf[0] = 0; \/* Input Buffer empty. *\/\n@@ -852,3 +860,3 @@\n-    Private->RunningBits = BitsPerPixel + 1;    \/* Number of bits per code. *\/\n-    Private->MaxCode1 = 1 << Private->RunningBits;    \/* Max. code + 1. *\/\n-    Private->StackPtr = 0;    \/* No pixels on the pixel stack. *\/\n+    Private->RunningBits = BitsPerPixel + 1; \/* Number of bits per code. *\/\n+    Private->MaxCode1 = 1 << Private->RunningBits; \/* Max. code + 1. *\/\n+    Private->StackPtr = 0; \/* No pixels on the pixel stack. *\/\n@@ -856,1 +864,1 @@\n-    Private->CrntShiftState = 0;    \/* No information in CrntShiftDWord. *\/\n+    Private->CrntShiftState = 0; \/* No information in CrntShiftDWord. *\/\n@@ -860,1 +868,1 @@\n-    for (i = 0; i <= LZ_MAX_CODE; i++)\n+    for (i = 0; i <= LZ_MAX_CODE; i++) {\n@@ -862,0 +870,1 @@\n+    }\n@@ -872,3 +881,2 @@\n-static int\n-DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)\n-{\n+static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,\n+                              int LineLen) {\n@@ -879,1 +887,1 @@\n-    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;\n+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;\n@@ -894,2 +902,3 @@\n-        \/* Let pop the stack off before continueing to read the GIF file: *\/\n-        while (StackPtr != 0 && i < LineLen)\n+        \/* Let pop the stack off before continueing to read the GIF\n+         * file: *\/\n+        while (StackPtr != 0 && i < LineLen) {\n@@ -897,0 +906,1 @@\n+        }\n@@ -899,2 +909,2 @@\n-    while (i < LineLen) {    \/* Decode LineLen items. *\/\n-        if (DGifDecompressInput(GifFile, &CrntCode) == GIF_ERROR)\n+    while (i < LineLen) { \/* Decode LineLen items. *\/\n+        if (DGifDecompressInput(GifFile, &CrntCode) == GIF_ERROR) {\n@@ -902,0 +912,1 @@\n+        }\n@@ -904,3 +915,4 @@\n-            \/* Note however that usually we will not be here as we will stop\n-             * decoding as soon as we got all the pixel, or EOF code will\n-             * not be read at all, and DGifGetLine\/Pixel clean everything.  *\/\n+            \/* Note however that usually we will not be here as we\n+             * will stop decoding as soon as we got all the pixel,\n+             * or EOF code will not be read at all, and\n+             * DGifGetLine\/Pixel clean everything.  *\/\n@@ -911,1 +923,1 @@\n-            for (j = 0; j <= LZ_MAX_CODE; j++)\n+            for (j = 0; j <= LZ_MAX_CODE; j++) {\n@@ -913,0 +925,1 @@\n+            }\n@@ -918,3 +931,3 @@\n-            \/* Its regular code - if in pixel range simply add it to output\n-             * stream, otherwise trace to codes linked list until the prefix\n-             * is in pixel range: *\/\n+            \/* Its regular code - if in pixel range simply add it to\n+             * output stream, otherwise trace to codes linked list\n+             * until the prefix is in pixel range: *\/\n@@ -922,1 +935,2 @@\n-                \/* This is simple - its pixel scalar, so add it to output: *\/\n+                \/* This is simple - its pixel scalar, so add it\n+                 * to output: *\/\n@@ -925,4 +939,5 @@\n-                \/* Its a code to needed to be traced: trace the linked list\n-                 * until the prefix is a pixel, while pushing the suffix\n-                 * pixels on our stack. If we done, pop the stack in reverse\n-                 * (thats what stack is good for!) order to output.  *\/\n+                \/* Its a code to needed to be traced: trace the\n+                 * linked list until the prefix is a pixel,\n+                 * while pushing the suffix pixels on our stack.\n+                 * If we done, pop the stack in reverse (thats\n+                 * what stack is good for!) order to output.  *\/\n@@ -932,9 +947,13 @@\n-                    \/* Only allowed if CrntCode is exactly the running code:\n-                     * In that case CrntCode = XXXCode, CrntCode or the\n-                     * prefix code is last code and the suffix char is\n-                     * exactly the prefix of last code! *\/\n-                    if (CrntCode == Private->RunningCode - 2) {\n-                        Suffix[Private->RunningCode - 2] =\n-                           Stack[StackPtr++] = DGifGetPrefixChar(Prefix,\n-                                                                 LastCode,\n-                                                                 ClearCode);\n+                    \/* Only allowed if CrntCode is exactly\n+                     * the running code: In that case\n+                     * CrntCode = XXXCode, CrntCode or the\n+                     * prefix code is last code and the\n+                     * suffix char is exactly the prefix of\n+                     * last code! *\/\n+                    if (CrntCode ==\n+                        Private->RunningCode - 2) {\n+                        Suffix[Private->RunningCode -\n+                               2] = Stack[StackPtr++] =\n+                            DGifGetPrefixChar(\n+                                Prefix, LastCode,\n+                                ClearCode);\n@@ -942,4 +961,5 @@\n-                        Suffix[Private->RunningCode - 2] =\n-                           Stack[StackPtr++] = DGifGetPrefixChar(Prefix,\n-                                                                 CrntCode,\n-                                                                 ClearCode);\n+                        Suffix[Private->RunningCode -\n+                               2] = Stack[StackPtr++] =\n+                            DGifGetPrefixChar(\n+                                Prefix, CrntCode,\n+                                ClearCode);\n@@ -947,1 +967,1 @@\n-                } else\n+                } else {\n@@ -949,0 +969,1 @@\n+                }\n@@ -950,4 +971,5 @@\n-                \/* Now (if image is O.K.) we should not get a NO_SUCH_CODE\n-                 * during the trace. As we might loop forever, in case of\n-                 * defective image, we use StackPtr as loop counter and stop\n-                 * before overflowing Stack[]. *\/\n+                \/* Now (if image is O.K.) we should not get a\n+                 * NO_SUCH_CODE during the trace. As we might\n+                 * loop forever, in case of defective image, we\n+                 * use StackPtr as loop counter and stop before\n+                 * overflowing Stack[]. *\/\n@@ -955,1 +977,2 @@\n-                       CrntPrefix > ClearCode && CrntPrefix <= LZ_MAX_CODE) {\n+                       CrntPrefix > ClearCode &&\n+                       CrntPrefix <= LZ_MAX_CODE) {\n@@ -959,1 +982,2 @@\n-                if (StackPtr >= LZ_MAX_CODE || CrntPrefix > LZ_MAX_CODE) {\n+                if (StackPtr >= LZ_MAX_CODE ||\n+                    CrntPrefix > LZ_MAX_CODE) {\n@@ -967,1 +991,1 @@\n-                while (StackPtr != 0 && i < LineLen)\n+                while (StackPtr != 0 && i < LineLen) {\n@@ -969,0 +993,1 @@\n+                }\n@@ -970,1 +995,3 @@\n-            if (LastCode != NO_SUCH_CODE && Private->RunningCode - 2 < (LZ_MAX_CODE+1) && Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {\n+            if (LastCode != NO_SUCH_CODE &&\n+                Private->RunningCode - 2 < (LZ_MAX_CODE + 1) &&\n+                Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {\n@@ -974,4 +1001,6 @@\n-                    \/* Only allowed if CrntCode is exactly the running code:\n-                     * In that case CrntCode = XXXCode, CrntCode or the\n-                     * prefix code is last code and the suffix char is\n-                     * exactly the prefix of last code! *\/\n+                    \/* Only allowed if CrntCode is exactly\n+                     * the running code: In that case\n+                     * CrntCode = XXXCode, CrntCode or the\n+                     * prefix code is last code and the\n+                     * suffix char is exactly the prefix of\n+                     * last code! *\/\n@@ -979,1 +1008,2 @@\n-                       DGifGetPrefixChar(Prefix, LastCode, ClearCode);\n+                        DGifGetPrefixChar(Prefix, LastCode,\n+                                          ClearCode);\n@@ -982,1 +1012,2 @@\n-                       DGifGetPrefixChar(Prefix, CrntCode, ClearCode);\n+                        DGifGetPrefixChar(Prefix, CrntCode,\n+                                          ClearCode);\n@@ -1001,3 +1032,2 @@\n-static int\n-DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode)\n-{\n+static int DGifGetPrefixChar(const GifPrefixType *Prefix, int Code,\n+                             int ClearCode) {\n@@ -1019,3 +1049,1 @@\n-int\n-DGifGetLZCodes(GifFileType *GifFile, int *Code)\n-{\n+int DGifGetLZCodes(GifFileType *GifFile, int *Code) {\n@@ -1031,1 +1059,1 @@\n-    if (DGifDecompressInput(GifFile, Code) == GIF_ERROR)\n+    if (DGifDecompressInput(GifFile, Code) == GIF_ERROR) {\n@@ -1033,0 +1061,1 @@\n+    }\n@@ -1035,1 +1064,2 @@\n-        \/* Skip rest of codes (hopefully only NULL terminating block): *\/\n+        \/* Skip rest of codes (hopefully only NULL terminating block):\n+         *\/\n@@ -1037,1 +1067,1 @@\n-            if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR)\n+            if (DGifGetCodeNext(GifFile, &CodeBlock) == GIF_ERROR) {\n@@ -1039,1 +1069,2 @@\n-        } while (CodeBlock != NULL) ;\n+            }\n+        } while (CodeBlock != NULL);\n@@ -1058,3 +1089,1 @@\n-static int\n-DGifDecompressInput(GifFileType *GifFile, int *Code)\n-{\n+static int DGifDecompressInput(GifFileType *GifFile, int *Code) {\n@@ -1062,5 +1091,2 @@\n-        0x0000, 0x0001, 0x0003, 0x0007,\n-        0x000f, 0x001f, 0x003f, 0x007f,\n-        0x00ff, 0x01ff, 0x03ff, 0x07ff,\n-        0x0fff\n-    };\n+        0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f,\n+        0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff};\n@@ -1080,1 +1106,2 @@\n-        if (DGifBufferedInput(GifFile, Private->Buf, &NextByte) == GIF_ERROR) {\n+        if (DGifBufferedInput(GifFile, Private->Buf, &NextByte) ==\n+            GIF_ERROR) {\n@@ -1083,2 +1110,2 @@\n-        Private->CrntShiftDWord |=\n-            ((unsigned long)NextByte) << Private->CrntShiftState;\n+        Private->CrntShiftDWord |= ((unsigned long)NextByte)\n+                                   << Private->CrntShiftState;\n@@ -1112,3 +1139,2 @@\n-static int\n-DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)\n-{\n+static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,\n+                             GifByteType *NextByte) {\n@@ -1123,2 +1149,2 @@\n-         * says the LZW termination code should come first.  Therefore we\n-         * shouldn't be inside this routine at that point.\n+         * says the LZW termination code should come first.  Therefore\n+         * we shouldn't be inside this routine at that point.\n@@ -1135,1 +1161,1 @@\n-        Buf[1] = 2;    \/* We use now the second place as last char read! *\/\n+        Buf[1] = 2; \/* We use now the second place as last char read! *\/\n@@ -1145,0 +1171,20 @@\n+\/******************************************************************************\n+ This routine is called in case of error during parsing image. We need to\n+ decrease image counter and reallocate memory for saved images. Not decreasing\n+ ImageCount may lead to null pointer dereference, because the last element in\n+ SavedImages may point to the spoilt image and null pointer buffers.\n+*******************************************************************************\/\n+void DGifDecreaseImageCounter(GifFileType *GifFile) {\n+    GifFile->ImageCount--;\n+    if (GifFile->SavedImages[GifFile->ImageCount].RasterBits != NULL) {\n+        free(GifFile->SavedImages[GifFile->ImageCount].RasterBits);\n+    }\n+\n+    \/\/ Realloc array according to the new image counter.\n+    SavedImage *correct_saved_images = (SavedImage *)reallocarray(\n+        GifFile->SavedImages, GifFile->ImageCount, sizeof(SavedImage));\n+    if (correct_saved_images != NULL) {\n+        GifFile->SavedImages = correct_saved_images;\n+    }\n+}\n+\n@@ -1150,3 +1196,1 @@\n-int\n-DGifSlurp(GifFileType *GifFile)\n-{\n+int DGifSlurp(GifFileType *GifFile) {\n@@ -1163,1 +1207,1 @@\n-        if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR)\n+        if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR) {\n@@ -1165,0 +1209,1 @@\n+        }\n@@ -1167,86 +1212,112 @@\n-          case IMAGE_DESC_RECORD_TYPE:\n-              if (DGifGetImageDesc(GifFile) == GIF_ERROR)\n-                  return (GIF_ERROR);\n-\n-              sp = &GifFile->SavedImages[GifFile->ImageCount - 1];\n-              \/* Allocate memory for the image *\/\n-              if (sp->ImageDesc.Width <= 0 || sp->ImageDesc.Height <= 0 ||\n-                      sp->ImageDesc.Width > (INT_MAX \/ sp->ImageDesc.Height)) {\n-                  return GIF_ERROR;\n-              }\n-              ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;\n-\n-              if (ImageSize > (SIZE_MAX \/ sizeof(GifPixelType))) {\n-                  return GIF_ERROR;\n-              }\n-              sp->RasterBits = (unsigned char *)reallocarray(NULL, ImageSize,\n-                      sizeof(GifPixelType));\n-\n-              if (sp->RasterBits == NULL) {\n-                  return GIF_ERROR;\n-              }\n-\n-              if (sp->ImageDesc.Interlace) {\n-                  int i, j;\n-                   \/*\n-                    * The way an interlaced image should be read -\n-                    * offsets and jumps...\n-                    *\/\n-                  int InterlacedOffset[] = { 0, 4, 2, 1 };\n-                  int InterlacedJumps[] = { 8, 8, 4, 2 };\n-                  \/* Need to perform 4 passes on the image *\/\n-                  for (i = 0; i < 4; i++)\n-                      for (j = InterlacedOffset[i];\n-                       j < sp->ImageDesc.Height;\n-                       j += InterlacedJumps[i]) {\n-                      if (DGifGetLine(GifFile,\n-                              sp->RasterBits+j*sp->ImageDesc.Width,\n-                              sp->ImageDesc.Width) == GIF_ERROR)\n-                          return GIF_ERROR;\n-                      }\n-              }\n-              else {\n-                  if (DGifGetLine(GifFile,sp->RasterBits,ImageSize)==GIF_ERROR)\n-                      return (GIF_ERROR);\n-              }\n-\n-              if (GifFile->ExtensionBlocks) {\n-                  sp->ExtensionBlocks = GifFile->ExtensionBlocks;\n-                  sp->ExtensionBlockCount = GifFile->ExtensionBlockCount;\n-\n-                  GifFile->ExtensionBlocks = NULL;\n-                  GifFile->ExtensionBlockCount = 0;\n-              }\n-              break;\n-\n-          case EXTENSION_RECORD_TYPE:\n-              if (DGifGetExtension(GifFile,&ExtFunction,&ExtData) == GIF_ERROR)\n-                  return (GIF_ERROR);\n-              \/* Create an extension block with our data *\/\n-              if (ExtData != NULL) {\n-                  if (GifAddExtensionBlock(&GifFile->ExtensionBlockCount,\n-                               &GifFile->ExtensionBlocks,\n-                               ExtFunction, ExtData[0], &ExtData[1])\n-                      == GIF_ERROR)\n-                      return (GIF_ERROR);\n-              }\n-              for (;;) {\n-                  if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)\n-                      return (GIF_ERROR);\n-                  if (ExtData == NULL)\n-                      break;\n-                  \/* Continue the extension block *\/\n-                  if (ExtData != NULL)\n-                      if (GifAddExtensionBlock(&GifFile->ExtensionBlockCount,\n-                                   &GifFile->ExtensionBlocks,\n-                                   CONTINUE_EXT_FUNC_CODE,\n-                                   ExtData[0], &ExtData[1]) == GIF_ERROR)\n-                              return (GIF_ERROR);\n-              }\n-              break;\n-\n-          case TERMINATE_RECORD_TYPE:\n-              break;\n-\n-          default:    \/* Should be trapped by DGifGetRecordType *\/\n-              break;\n+        case IMAGE_DESC_RECORD_TYPE:\n+            if (DGifGetImageDesc(GifFile) == GIF_ERROR) {\n+                return (GIF_ERROR);\n+            }\n+\n+            sp = &GifFile->SavedImages[GifFile->ImageCount - 1];\n+            \/* Allocate memory for the image *\/\n+            if (sp->ImageDesc.Width <= 0 ||\n+                sp->ImageDesc.Height <= 0 ||\n+                sp->ImageDesc.Width >\n+                    (INT_MAX \/ sp->ImageDesc.Height)) {\n+                DGifDecreaseImageCounter(GifFile);\n+                return GIF_ERROR;\n+            }\n+            ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;\n+\n+            if (ImageSize > (SIZE_MAX \/ sizeof(GifPixelType))) {\n+                DGifDecreaseImageCounter(GifFile);\n+                return GIF_ERROR;\n+            }\n+            sp->RasterBits = (unsigned char *)reallocarray(\n+                NULL, ImageSize, sizeof(GifPixelType));\n+\n+            if (sp->RasterBits == NULL) {\n+                DGifDecreaseImageCounter(GifFile);\n+                return GIF_ERROR;\n+            }\n+\n+            if (sp->ImageDesc.Interlace) {\n+                int i, j;\n+                \/*\n+                 * The way an interlaced image should be read -\n+                 * offsets and jumps...\n+                 *\/\n+                static const int InterlacedOffset[] = {0, 4, 2,\n+                                                       1};\n+                static const int InterlacedJumps[] = {8, 8, 4,\n+                                                      2};\n+                \/* Need to perform 4 passes on the image *\/\n+                for (i = 0; i < 4; i++) {\n+                    for (j = InterlacedOffset[i];\n+                         j < sp->ImageDesc.Height;\n+                         j += InterlacedJumps[i]) {\n+                        if (DGifGetLine(\n+                                GifFile,\n+                                sp->RasterBits +\n+                                    j * sp->ImageDesc\n+                                            .Width,\n+                                sp->ImageDesc.Width) ==\n+                            GIF_ERROR) {\n+                            DGifDecreaseImageCounter(\n+                                GifFile);\n+                            return GIF_ERROR;\n+                        }\n+                    }\n+                }\n+            } else {\n+                if (DGifGetLine(GifFile, sp->RasterBits,\n+                                ImageSize) == GIF_ERROR) {\n+                    DGifDecreaseImageCounter(GifFile);\n+                    return GIF_ERROR;\n+                }\n+            }\n+\n+            if (GifFile->ExtensionBlocks) {\n+                sp->ExtensionBlocks = GifFile->ExtensionBlocks;\n+                sp->ExtensionBlockCount =\n+                    GifFile->ExtensionBlockCount;\n+\n+                GifFile->ExtensionBlocks = NULL;\n+                GifFile->ExtensionBlockCount = 0;\n+            }\n+            break;\n+\n+        case EXTENSION_RECORD_TYPE:\n+            if (DGifGetExtension(GifFile, &ExtFunction, &ExtData) ==\n+                GIF_ERROR) {\n+                return (GIF_ERROR);\n+            }\n+            \/* Create an extension block with our data *\/\n+            if (ExtData != NULL) {\n+                if (GifAddExtensionBlock(\n+                        &GifFile->ExtensionBlockCount,\n+                        &GifFile->ExtensionBlocks, ExtFunction,\n+                        ExtData[0], &ExtData[1]) == GIF_ERROR) {\n+                    return (GIF_ERROR);\n+                }\n+            }\n+            for (;;) {\n+                if (DGifGetExtensionNext(GifFile, &ExtData) ==\n+                    GIF_ERROR) {\n+                    return (GIF_ERROR);\n+                }\n+                if (ExtData == NULL) {\n+                    break;\n+                }\n+                \/* Continue the extension block *\/\n+                if (GifAddExtensionBlock(\n+                        &GifFile->ExtensionBlockCount,\n+                        &GifFile->ExtensionBlocks,\n+                        CONTINUE_EXT_FUNC_CODE, ExtData[0],\n+                        &ExtData[1]) == GIF_ERROR) {\n+                    return (GIF_ERROR);\n+                }\n+            }\n+            break;\n+\n+        case TERMINATE_RECORD_TYPE:\n+            break;\n+\n+        default: \/* Should be trapped by DGifGetRecordType *\/\n+            break;\n@@ -1259,1 +1330,1 @@\n-        return(GIF_ERROR);\n+        return (GIF_ERROR);\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/giflib\/dgif_lib.c","additions":413,"deletions":342,"binary":false,"changes":755,"status":"modified"},{"patch":"@@ -41,3 +41,1 @@\n-const char *\n-GifErrorString(int ErrorCode)\n-{\n+const char *GifErrorString(int ErrorCode) {\n@@ -47,1 +45,1 @@\n-      case E_GIF_ERR_OPEN_FAILED:\n+    case E_GIF_ERR_OPEN_FAILED:\n@@ -50,1 +48,1 @@\n-      case E_GIF_ERR_WRITE_FAILED:\n+    case E_GIF_ERR_WRITE_FAILED:\n@@ -53,1 +51,1 @@\n-      case E_GIF_ERR_HAS_SCRN_DSCR:\n+    case E_GIF_ERR_HAS_SCRN_DSCR:\n@@ -56,1 +54,1 @@\n-      case E_GIF_ERR_HAS_IMAG_DSCR:\n+    case E_GIF_ERR_HAS_IMAG_DSCR:\n@@ -59,1 +57,1 @@\n-      case E_GIF_ERR_NO_COLOR_MAP:\n+    case E_GIF_ERR_NO_COLOR_MAP:\n@@ -62,1 +60,1 @@\n-      case E_GIF_ERR_DATA_TOO_BIG:\n+    case E_GIF_ERR_DATA_TOO_BIG:\n@@ -65,1 +63,1 @@\n-      case E_GIF_ERR_NOT_ENOUGH_MEM:\n+    case E_GIF_ERR_NOT_ENOUGH_MEM:\n@@ -68,1 +66,1 @@\n-      case E_GIF_ERR_DISK_IS_FULL:\n+    case E_GIF_ERR_DISK_IS_FULL:\n@@ -71,1 +69,1 @@\n-      case E_GIF_ERR_CLOSE_FAILED:\n+    case E_GIF_ERR_CLOSE_FAILED:\n@@ -74,1 +72,1 @@\n-      case E_GIF_ERR_NOT_WRITEABLE:\n+    case E_GIF_ERR_NOT_WRITEABLE:\n@@ -77,1 +75,1 @@\n-      case D_GIF_ERR_OPEN_FAILED:\n+    case D_GIF_ERR_OPEN_FAILED:\n@@ -80,1 +78,1 @@\n-      case D_GIF_ERR_READ_FAILED:\n+    case D_GIF_ERR_READ_FAILED:\n@@ -83,1 +81,1 @@\n-      case D_GIF_ERR_NOT_GIF_FILE:\n+    case D_GIF_ERR_NOT_GIF_FILE:\n@@ -86,1 +84,1 @@\n-      case D_GIF_ERR_NO_SCRN_DSCR:\n+    case D_GIF_ERR_NO_SCRN_DSCR:\n@@ -89,1 +87,1 @@\n-      case D_GIF_ERR_NO_IMAG_DSCR:\n+    case D_GIF_ERR_NO_IMAG_DSCR:\n@@ -92,1 +90,1 @@\n-      case D_GIF_ERR_NO_COLOR_MAP:\n+    case D_GIF_ERR_NO_COLOR_MAP:\n@@ -95,1 +93,1 @@\n-      case D_GIF_ERR_WRONG_RECORD:\n+    case D_GIF_ERR_WRONG_RECORD:\n@@ -98,1 +96,1 @@\n-      case D_GIF_ERR_DATA_TOO_BIG:\n+    case D_GIF_ERR_DATA_TOO_BIG:\n@@ -101,1 +99,1 @@\n-      case D_GIF_ERR_NOT_ENOUGH_MEM:\n+    case D_GIF_ERR_NOT_ENOUGH_MEM:\n@@ -104,1 +102,1 @@\n-      case D_GIF_ERR_CLOSE_FAILED:\n+    case D_GIF_ERR_CLOSE_FAILED:\n@@ -107,1 +105,1 @@\n-      case D_GIF_ERR_NOT_READABLE:\n+    case D_GIF_ERR_NOT_READABLE:\n@@ -110,1 +108,1 @@\n-      case D_GIF_ERR_IMAGE_DEFECT:\n+    case D_GIF_ERR_IMAGE_DEFECT:\n@@ -113,1 +111,1 @@\n-      case D_GIF_ERR_EOF_TOO_SOON:\n+    case D_GIF_ERR_EOF_TOO_SOON:\n@@ -116,1 +114,1 @@\n-      default:\n+    default:\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/giflib\/gif_err.c","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\/** Begin JDK modifications to support building on Windows **\/\n@@ -39,2 +38,1 @@\n-#endif\n-\/** End JDK modifications to support building on Windows **\/\n+#endif \/* _WIN32 *\/\n@@ -43,5 +41,5 @@\n-#define HT_SIZE         8192    \/* 12bits = 4096 or twice as big! *\/\n-#define HT_KEY_MASK     0x1FFF  \/* 13bits keys *\/\n-#define HT_KEY_NUM_BITS 13      \/* 13bits keys *\/\n-#define HT_MAX_KEY      8191    \/* 13bits - 1, maximal code possible *\/\n-#define HT_MAX_CODE     4095    \/* Biggest code possible in 12 bits. *\/\n+#define HT_SIZE 8192       \/* 12bits = 4096 or twice as big! *\/\n+#define HT_KEY_MASK 0x1FFF \/* 13bits keys *\/\n+#define HT_KEY_NUM_BITS 13 \/* 13bits keys *\/\n+#define HT_MAX_KEY 8191    \/* 13bits - 1, maximal code possible *\/\n+#define HT_MAX_CODE 4095   \/* Biggest code possible in 12 bits. *\/\n@@ -51,1 +49,1 @@\n-\/* 2. The key is 12 bits Prefix code + 8 bit new char or 20 bits.           *\/\n+\/* 2. The key is 12 bits Prefix code + 8 bit new char or 20 bits.        *\/\n@@ -53,4 +51,4 @@\n-#define HT_GET_KEY(l)    (l >> 12)\n-#define HT_GET_CODE(l)   (l & 0x0FFF)\n-#define HT_PUT_KEY(l)    (l << 12)\n-#define HT_PUT_CODE(l)   (l & 0x0FFF)\n+#define HT_GET_KEY(l) (l >> 12)\n+#define HT_GET_CODE(l) (l & 0x0FFF)\n+#define HT_PUT_KEY(l) (l << 12)\n+#define HT_PUT_CODE(l) (l & 0x0FFF)\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/giflib\/gif_hash.h","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define GIFLIB_RELEASE 1\n+#define GIFLIB_RELEASE 2\n@@ -44,2 +44,2 @@\n-#define GIF_ERROR   0\n-#define GIF_OK      1\n+#define GIF_ERROR 0\n+#define GIF_OK 1\n@@ -47,0 +47,1 @@\n+#include <stdbool.h>\n@@ -48,11 +49,2 @@\n-\/** Begin JDK modifications to support building using old compilers**\/\n-\/\/#include <stdbool.h>\n-#ifdef bool\n-#undef bool\n-#endif\n-typedef int bool;\n-#define false 0\n-#define true 1\n-\/** End JDK modifications to support building using old compilers**\/\n-\n-#define GIF_STAMP \"GIFVER\"          \/* First chars in file - GIF stamp.  *\/\n+\n+#define GIF_STAMP \"GIFVER\" \/* First chars in file - GIF stamp.  *\/\n@@ -60,3 +52,3 @@\n-#define GIF_VERSION_POS 3           \/* Version first character in stamp. *\/\n-#define GIF87_STAMP \"GIF87a\"        \/* First chars in file - GIF stamp.  *\/\n-#define GIF89_STAMP \"GIF89a\"        \/* First chars in file - GIF stamp.  *\/\n+#define GIF_VERSION_POS 3    \/* Version first character in stamp. *\/\n+#define GIF87_STAMP \"GIF87a\" \/* First chars in file - GIF stamp.  *\/\n+#define GIF89_STAMP \"GIF89a\" \/* First chars in file - GIF stamp.  *\/\n@@ -78,1 +70,1 @@\n-    GifColorType *Colors;    \/* on malloc(3) heap *\/\n+    GifColorType *Colors; \/* on malloc(3) heap *\/\n@@ -82,3 +74,3 @@\n-    GifWord Left, Top, Width, Height;   \/* Current image dimensions. *\/\n-    bool Interlace;                     \/* Sequential\/Interlaced lines. *\/\n-    ColorMapObject *ColorMap;           \/* The local color map *\/\n+    GifWord Left, Top, Width, Height; \/* Current image dimensions. *\/\n+    bool Interlace;                   \/* Sequential\/Interlaced lines. *\/\n+    ColorMapObject *ColorMap;         \/* The local color map *\/\n@@ -89,7 +81,7 @@\n-    GifByteType *Bytes; \/* on malloc(3) heap *\/\n-    int Function;       \/* The block function code *\/\n-#define CONTINUE_EXT_FUNC_CODE    0x00    \/* continuation subblock *\/\n-#define COMMENT_EXT_FUNC_CODE     0xfe    \/* comment *\/\n-#define GRAPHICS_EXT_FUNC_CODE    0xf9    \/* graphics control (GIF89) *\/\n-#define PLAINTEXT_EXT_FUNC_CODE   0x01    \/* plaintext *\/\n-#define APPLICATION_EXT_FUNC_CODE 0xff    \/* application block (GIF89) *\/\n+    GifByteType *Bytes;            \/* on malloc(3) heap *\/\n+    int Function;                  \/* The block function code *\/\n+#define CONTINUE_EXT_FUNC_CODE 0x00    \/* continuation subblock *\/\n+#define COMMENT_EXT_FUNC_CODE 0xfe     \/* comment *\/\n+#define GRAPHICS_EXT_FUNC_CODE 0xf9    \/* graphics control (GIF89) *\/\n+#define PLAINTEXT_EXT_FUNC_CODE 0x01   \/* plaintext *\/\n+#define APPLICATION_EXT_FUNC_CODE 0xff \/* application block (GIF89) *\/\n@@ -106,9 +98,9 @@\n-    GifWord SWidth, SHeight;         \/* Size of virtual canvas *\/\n-    GifWord SColorResolution;        \/* How many colors can we generate? *\/\n-    GifWord SBackGroundColor;        \/* Background color for virtual canvas *\/\n-    GifByteType AspectByte;          \/* Used to compute pixel aspect ratio *\/\n-    ColorMapObject *SColorMap;       \/* Global colormap, NULL if nonexistent. *\/\n-    int ImageCount;                  \/* Number of current image (both APIs) *\/\n-    GifImageDesc Image;              \/* Current image (low-level API) *\/\n-    SavedImage *SavedImages;         \/* Image sequence (high-level API) *\/\n-    int ExtensionBlockCount;         \/* Count extensions past last image *\/\n+    GifWord SWidth, SHeight;   \/* Size of virtual canvas *\/\n+    GifWord SColorResolution;  \/* How many colors can we generate? *\/\n+    GifWord SBackGroundColor;  \/* Background color for virtual canvas *\/\n+    GifByteType AspectByte;    \/* Used to compute pixel aspect ratio *\/\n+    ColorMapObject *SColorMap; \/* Global colormap, NULL if nonexistent. *\/\n+    int ImageCount;            \/* Number of current image (both APIs) *\/\n+    GifImageDesc Image;        \/* Current image (low-level API) *\/\n+    SavedImage *SavedImages;   \/* Image sequence (high-level API) *\/\n+    int ExtensionBlockCount;   \/* Count extensions past last image *\/\n@@ -121,1 +113,1 @@\n-#define GIF_ASPECT_RATIO(n)    ((n)+15.0\/64.0)\n+#define GIF_ASPECT_RATIO(n) ((n) + 15.0 \/ 64.0)\n@@ -132,1 +124,1 @@\n-typedef int (*InputFunc) (GifFileType *, GifByteType *, int);\n+typedef int (*InputFunc)(GifFileType *, GifByteType *, int);\n@@ -137,1 +129,1 @@\n-typedef int (*OutputFunc) (GifFileType *, const GifByteType *, int);\n+typedef int (*OutputFunc)(GifFileType *, const GifByteType *, int);\n@@ -145,8 +137,8 @@\n-#define DISPOSAL_UNSPECIFIED      0       \/* No disposal specified. *\/\n-#define DISPOSE_DO_NOT            1       \/* Leave image in place *\/\n-#define DISPOSE_BACKGROUND        2       \/* Set area too background color *\/\n-#define DISPOSE_PREVIOUS          3       \/* Restore to previous content *\/\n-    bool UserInputFlag;      \/* User confirmation required before disposal *\/\n-    int DelayTime;           \/* pre-display delay in 0.01sec units *\/\n-    int TransparentColor;    \/* Palette index for transparency, -1 if none *\/\n-#define NO_TRANSPARENT_COLOR    -1\n+#define DISPOSAL_UNSPECIFIED 0 \/* No disposal specified. *\/\n+#define DISPOSE_DO_NOT 1       \/* Leave image in place *\/\n+#define DISPOSE_BACKGROUND 2   \/* Set area too background color *\/\n+#define DISPOSE_PREVIOUS 3     \/* Restore to previous content *\/\n+    bool UserInputFlag;    \/* User confirmation required before disposal *\/\n+    int DelayTime;         \/* pre-display delay in 0.01sec units *\/\n+    int TransparentColor;  \/* Palette index for transparency, -1 if none *\/\n+#define NO_TRANSPARENT_COLOR -1\n@@ -164,1 +156,1 @@\n-int EGifSpew(GifFileType * GifFile);\n+int EGifSpew(GifFileType *GifFile);\n@@ -168,7 +160,7 @@\n-#define E_GIF_SUCCEEDED          0\n-#define E_GIF_ERR_OPEN_FAILED    1    \/* And EGif possible errors. *\/\n-#define E_GIF_ERR_WRITE_FAILED   2\n-#define E_GIF_ERR_HAS_SCRN_DSCR  3\n-#define E_GIF_ERR_HAS_IMAG_DSCR  4\n-#define E_GIF_ERR_NO_COLOR_MAP   5\n-#define E_GIF_ERR_DATA_TOO_BIG   6\n+#define E_GIF_SUCCEEDED 0\n+#define E_GIF_ERR_OPEN_FAILED 1 \/* And EGif possible errors. *\/\n+#define E_GIF_ERR_WRITE_FAILED 2\n+#define E_GIF_ERR_HAS_SCRN_DSCR 3\n+#define E_GIF_ERR_HAS_IMAG_DSCR 4\n+#define E_GIF_ERR_NO_COLOR_MAP 5\n+#define E_GIF_ERR_DATA_TOO_BIG 6\n@@ -176,3 +168,3 @@\n-#define E_GIF_ERR_DISK_IS_FULL   8\n-#define E_GIF_ERR_CLOSE_FAILED   9\n-#define E_GIF_ERR_NOT_WRITEABLE  10\n+#define E_GIF_ERR_DISK_IS_FULL 8\n+#define E_GIF_ERR_CLOSE_FAILED 9\n+#define E_GIF_ERR_NOT_WRITEABLE 10\n@@ -181,3 +173,2 @@\n-int EGifPutScreenDesc(GifFileType *GifFile,\n-                      const int GifWidth, const int GifHeight,\n-                      const int GifColorRes,\n+int EGifPutScreenDesc(GifFileType *GifFile, const int GifWidth,\n+                      const int GifHeight, const int GifColorRes,\n@@ -186,2 +177,1 @@\n-int EGifPutImageDesc(GifFileType *GifFile,\n-                     const int GifLeft, const int GifTop,\n+int EGifPutImageDesc(GifFileType *GifFile, const int GifLeft, const int GifTop,\n@@ -192,2 +182,1 @@\n-int EGifPutLine(GifFileType *GifFile, GifPixelType *GifLine,\n-                int GifLineLen);\n+int EGifPutLine(GifFileType *GifFile, GifPixelType *GifLine, int GifLineLen);\n@@ -197,2 +186,2 @@\n-int EGifPutExtensionBlock(GifFileType *GifFile,\n-                         const int GifExtLen, const void *GifExtension);\n+int EGifPutExtensionBlock(GifFileType *GifFile, const int GifExtLen,\n+                          const void *GifExtension);\n@@ -201,2 +190,1 @@\n-                     const int GifExtLen,\n-                     const void *GifExtension);\n+                     const int GifExtLen, const void *GifExtension);\n@@ -205,2 +193,1 @@\n-int EGifPutCodeNext(GifFileType *GifFile,\n-                    const GifByteType *GifCodeBlock);\n+int EGifPutCodeNext(GifFileType *GifFile, const GifByteType *GifCodeBlock);\n@@ -215,13 +202,14 @@\n-int DGifSlurp(GifFileType * GifFile);\n-GifFileType *DGifOpen(void *userPtr, InputFunc readFunc, int *Error);    \/* new one (TVT) *\/\n-    int DGifCloseFile(GifFileType * GifFile, int *ErrorCode);\n-\n-#define D_GIF_SUCCEEDED          0\n-#define D_GIF_ERR_OPEN_FAILED    101    \/* And DGif possible errors. *\/\n-#define D_GIF_ERR_READ_FAILED    102\n-#define D_GIF_ERR_NOT_GIF_FILE   103\n-#define D_GIF_ERR_NO_SCRN_DSCR   104\n-#define D_GIF_ERR_NO_IMAG_DSCR   105\n-#define D_GIF_ERR_NO_COLOR_MAP   106\n-#define D_GIF_ERR_WRONG_RECORD   107\n-#define D_GIF_ERR_DATA_TOO_BIG   108\n+int DGifSlurp(GifFileType *GifFile);\n+GifFileType *DGifOpen(void *userPtr, InputFunc readFunc,\n+                      int *Error); \/* new one (TVT) *\/\n+int DGifCloseFile(GifFileType *GifFile, int *ErrorCode);\n+\n+#define D_GIF_SUCCEEDED 0\n+#define D_GIF_ERR_OPEN_FAILED 101 \/* And DGif possible errors. *\/\n+#define D_GIF_ERR_READ_FAILED 102\n+#define D_GIF_ERR_NOT_GIF_FILE 103\n+#define D_GIF_ERR_NO_SCRN_DSCR 104\n+#define D_GIF_ERR_NO_IMAG_DSCR 105\n+#define D_GIF_ERR_NO_COLOR_MAP 106\n+#define D_GIF_ERR_WRONG_RECORD 107\n+#define D_GIF_ERR_DATA_TOO_BIG 108\n@@ -229,4 +217,4 @@\n-#define D_GIF_ERR_CLOSE_FAILED   110\n-#define D_GIF_ERR_NOT_READABLE   111\n-#define D_GIF_ERR_IMAGE_DEFECT   112\n-#define D_GIF_ERR_EOF_TOO_SOON   113\n+#define D_GIF_ERR_CLOSE_FAILED 110\n+#define D_GIF_ERR_NOT_READABLE 111\n+#define D_GIF_ERR_IMAGE_DEFECT 112\n+#define D_GIF_ERR_EOF_TOO_SOON 113\n@@ -250,1 +238,0 @@\n-\n@@ -254,1 +241,1 @@\n-extern const char *GifErrorString(int ErrorCode);     \/* new in 2012 - ESR *\/\n+extern const char *GifErrorString(int ErrorCode); \/* new in 2012 - ESR *\/\n@@ -266,1 +253,1 @@\n-                                     const GifColorType *ColorMap);\n+                                        const GifColorType *ColorMap);\n@@ -269,2 +256,2 @@\n-                                     const ColorMapObject *ColorIn2,\n-                                     GifPixelType ColorTransIn2[]);\n+                                        const ColorMapObject *ColorIn2,\n+                                        GifPixelType ColorTransIn2[]);\n@@ -277,1 +264,2 @@\n-extern void GifApplyTranslation(SavedImage *Image, GifPixelType Translation[]);\n+extern void GifApplyTranslation(SavedImage *Image,\n+                                const GifPixelType Translation[]);\n@@ -279,2 +267,1 @@\n-                                ExtensionBlock **ExtensionBlocks,\n-                                int Function,\n+                                ExtensionBlock **ExtensionBlocks, int Function,\n@@ -285,1 +272,1 @@\n-                                  const SavedImage *CopyFrom);\n+                                     const SavedImage *CopyFrom);\n@@ -298,2 +285,1 @@\n-int DGifSavedExtensionToGCB(GifFileType *GifFile,\n-                            int ImageIndex,\n+int DGifSavedExtensionToGCB(GifFileType *GifFile, int ImageIndex,\n@@ -302,2 +288,1 @@\n-                            GifFileType *GifFile,\n-                            int ImageIndex);\n+                            GifFileType *GifFile, int ImageIndex);\n@@ -309,1 +294,1 @@\n-#define GIF_FONT_WIDTH  8\n+#define GIF_FONT_WIDTH 8\n@@ -313,3 +298,2 @@\n-extern void GifDrawText8x8(SavedImage *Image,\n-                     const int x, const int y,\n-                     const char *legend, const int color);\n+extern void GifDrawText8x8(SavedImage *Image, const int x, const int y,\n+                           const char *legend, const int color);\n@@ -317,3 +301,2 @@\n-extern void GifDrawBox(SavedImage *Image,\n-                    const int x, const int y,\n-                    const int w, const int d, const int color);\n+extern void GifDrawBox(SavedImage *Image, const int x, const int y, const int w,\n+                       const int d, const int color);\n@@ -321,3 +304,2 @@\n-extern void GifDrawRectangle(SavedImage *Image,\n-                   const int x, const int y,\n-                   const int w, const int d, const int color);\n+extern void GifDrawRectangle(SavedImage *Image, const int x, const int y,\n+                             const int w, const int d, const int color);\n@@ -325,4 +307,3 @@\n-extern void GifDrawBoxedText8x8(SavedImage *Image,\n-                          const int x, const int y,\n-                          const char *legend,\n-                          const int border, const int bg, const int fg);\n+extern void GifDrawBoxedText8x8(SavedImage *Image, const int x, const int y,\n+                                const char *legend, const int border,\n+                                const int bg, const int fg);\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/giflib\/gif_lib.h","additions":97,"deletions":116,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gif_lib.h\"\n@@ -38,0 +37,1 @@\n+#include \"gif_lib.h\"\n@@ -40,1 +40,1 @@\n-    #define SIZE_MAX     UINTPTR_MAX\n+#define SIZE_MAX UINTPTR_MAX\n@@ -43,3 +43,3 @@\n-#define EXTENSION_INTRODUCER      0x21\n-#define DESCRIPTOR_INTRODUCER     0x2c\n-#define TERMINATOR_INTRODUCER     0x3b\n+#define EXTENSION_INTRODUCER 0x21\n+#define DESCRIPTOR_INTRODUCER 0x2c\n+#define TERMINATOR_INTRODUCER 0x3b\n@@ -47,2 +47,2 @@\n-#define LZ_MAX_CODE         4095    \/* Biggest code possible in 12 bits. *\/\n-#define LZ_BITS             12\n+#define LZ_MAX_CODE 4095 \/* Biggest code possible in 12 bits. *\/\n+#define LZ_BITS 12\n@@ -50,3 +50,3 @@\n-#define FLUSH_OUTPUT        4096    \/* Impossible code, to signal flush. *\/\n-#define FIRST_CODE          4097    \/* Impossible code, to signal first. *\/\n-#define NO_SUCH_CODE        4098    \/* Impossible code, to signal empty. *\/\n+#define FLUSH_OUTPUT 4096 \/* Impossible code, to signal flush. *\/\n+#define FIRST_CODE 4097   \/* Impossible code, to signal first. *\/\n+#define NO_SUCH_CODE 4098 \/* Impossible code, to signal empty. *\/\n@@ -54,4 +54,4 @@\n-#define FILE_STATE_WRITE    0x01\n-#define FILE_STATE_SCREEN   0x02\n-#define FILE_STATE_IMAGE    0x04\n-#define FILE_STATE_READ     0x08\n+#define FILE_STATE_WRITE 0x01\n+#define FILE_STATE_SCREEN 0x02\n+#define FILE_STATE_IMAGE 0x04\n+#define FILE_STATE_READ 0x08\n@@ -59,2 +59,2 @@\n-#define IS_READABLE(Private)    (Private->FileState & FILE_STATE_READ)\n-#define IS_WRITEABLE(Private)   (Private->FileState & FILE_STATE_WRITE)\n+#define IS_READABLE(Private) (Private->FileState & FILE_STATE_READ)\n+#define IS_WRITEABLE(Private) (Private->FileState & FILE_STATE_WRITE)\n@@ -63,17 +63,19 @@\n-    GifWord FileState, FileHandle,  \/* Where all this data goes to! *\/\n-      BitsPerPixel,     \/* Bits per pixel (Codes uses at least this + 1). *\/\n-      ClearCode,   \/* The CLEAR LZ code. *\/\n-      EOFCode,     \/* The EOF LZ code. *\/\n-      RunningCode, \/* The next code algorithm can generate. *\/\n-      RunningBits, \/* The number of bits required to represent RunningCode. *\/\n-      MaxCode1,    \/* 1 bigger than max. possible code, in RunningBits bits. *\/\n-      LastCode,    \/* The code before the current code. *\/\n-      CrntCode,    \/* Current algorithm code. *\/\n-      StackPtr,    \/* For character stack (see below). *\/\n-      CrntShiftState;    \/* Number of bits in CrntShiftDWord. *\/\n-    unsigned long CrntShiftDWord;   \/* For bytes decomposition into codes. *\/\n-    unsigned long PixelCount;   \/* Number of pixels in image. *\/\n-    FILE *File;    \/* File as stream. *\/\n-    InputFunc Read;     \/* function to read gif input (TVT) *\/\n-    OutputFunc Write;   \/* function to write gif output (MRB) *\/\n-    GifByteType Buf[256];   \/* Compressed input is buffered here. *\/\n+    GifWord FileState, FileHandle, \/* Where all this data goes to! *\/\n+        BitsPerPixel, \/* Bits per pixel (Codes uses at least this + 1). *\/\n+        ClearCode,    \/* The CLEAR LZ code. *\/\n+        EOFCode,      \/* The EOF LZ code. *\/\n+        RunningCode,  \/* The next code algorithm can generate. *\/\n+        RunningBits,  \/* The number of bits required to represent\n+                         RunningCode. *\/\n+        MaxCode1, \/* 1 bigger than max. possible code, in RunningBits bits.\n+                   *\/\n+        LastCode, \/* The code before the current code. *\/\n+        CrntCode, \/* Current algorithm code. *\/\n+        StackPtr, \/* For character stack (see below). *\/\n+        CrntShiftState;           \/* Number of bits in CrntShiftDWord. *\/\n+    unsigned long CrntShiftDWord; \/* For bytes decomposition into codes. *\/\n+    unsigned long PixelCount;     \/* Number of pixels in image. *\/\n+    FILE *File;                   \/* File as stream. *\/\n+    InputFunc Read;               \/* function to read gif input (TVT) *\/\n+    OutputFunc Write;             \/* function to write gif output (MRB) *\/\n+    GifByteType Buf[256];         \/* Compressed input is buffered here. *\/\n@@ -81,1 +83,1 @@\n-    GifByteType Suffix[LZ_MAX_CODE + 1];    \/* So we can trace the codes. *\/\n+    GifByteType Suffix[LZ_MAX_CODE + 1]; \/* So we can trace the codes. *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/giflib\/gif_lib_private.h","additions":36,"deletions":34,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include <stdlib.h>\n@@ -35,0 +34,1 @@\n+#include <stdlib.h>\n@@ -40,1 +40,1 @@\n-#define MAX(x, y)    (((x) > (y)) ? (x) : (y))\n+#define MAX(x, y) (((x) > (y)) ? (x) : (y))\n@@ -47,3 +47,1 @@\n-int\n-GifBitSize(int n)\n-{\n+int GifBitSize(int n) {\n@@ -52,2 +50,2 @@\n-    for (i = 1; i <= 8; i++)\n-        if ((1 << i) >= n)\n+    for (i = 1; i <= 8; i++) {\n+        if ((1 << i) >= n) {\n@@ -55,0 +53,2 @@\n+        }\n+    }\n@@ -59,1 +59,1 @@\n-  Color map object functions\n+ Color map object functions\n@@ -66,3 +66,1 @@\n-ColorMapObject *\n-GifMakeMapObject(int ColorCount, const GifColorType *ColorMap)\n-{\n+ColorMapObject *GifMakeMapObject(int ColorCount, const GifColorType *ColorMap) {\n@@ -72,1 +70,2 @@\n-     * make the user know that or should we automatically round up instead? *\/\n+     * make the user know that or should we automatically round up instead?\n+     *\/\n@@ -74,1 +73,1 @@\n-        return ((ColorMapObject *) NULL);\n+        return ((ColorMapObject *)NULL);\n@@ -78,2 +77,2 @@\n-    if (Object == (ColorMapObject *) NULL) {\n-        return ((ColorMapObject *) NULL);\n+    if (Object == (ColorMapObject *)NULL) {\n+        return ((ColorMapObject *)NULL);\n@@ -82,2 +81,3 @@\n-    Object->Colors = (GifColorType *)calloc(ColorCount, sizeof(GifColorType));\n-    if (Object->Colors == (GifColorType *) NULL) {\n+    Object->Colors =\n+        (GifColorType *)calloc(ColorCount, sizeof(GifColorType));\n+    if (Object->Colors == (GifColorType *)NULL) {\n@@ -85,1 +85,1 @@\n-        return ((ColorMapObject *) NULL);\n+        return ((ColorMapObject *)NULL);\n@@ -93,2 +93,2 @@\n-        memcpy((char *)Object->Colors,\n-               (char *)ColorMap, ColorCount * sizeof(GifColorType));\n+        memcpy((char *)Object->Colors, (char *)ColorMap,\n+               ColorCount * sizeof(GifColorType));\n@@ -101,1 +101,1 @@\n-Free a color map object\n+ Free a color map object\n@@ -103,3 +103,1 @@\n-void\n-GifFreeMapObject(ColorMapObject *Object)\n-{\n+void GifFreeMapObject(ColorMapObject *Object) {\n@@ -113,4 +111,1 @@\n-void\n-DumpColorMap(ColorMapObject *Object,\n-             FILE * fp)\n-{\n+void DumpColorMap(ColorMapObject *Object, FILE *fp) {\n@@ -122,2 +117,2 @@\n-                (void)fprintf(fp, \"%3d: %02x %02x %02x   \", i + j,\n-                              Object->Colors[i + j].Red,\n+                (void)fprintf(fp, \"%3d: %02x %02x %02x   \",\n+                              i + j, Object->Colors[i + j].Red,\n@@ -140,5 +135,3 @@\n-ColorMapObject *\n-GifUnionColorMap(const ColorMapObject *ColorIn1,\n-              const ColorMapObject *ColorIn2,\n-              GifPixelType ColorTransIn2[])\n-{\n+ColorMapObject *GifUnionColorMap(const ColorMapObject *ColorIn1,\n+                                 const ColorMapObject *ColorIn2,\n+                                 GifPixelType ColorTransIn2[]) {\n@@ -155,2 +148,2 @@\n-    ColorUnion = GifMakeMapObject(MAX(ColorIn1->ColorCount,\n-                               ColorIn2->ColorCount) * 2, NULL);\n+    ColorUnion = GifMakeMapObject(\n+        MAX(ColorIn1->ColorCount, ColorIn2->ColorCount) * 2, NULL);\n@@ -158,1 +151,1 @@\n-    if (ColorUnion == NULL)\n+    if (ColorUnion == NULL) {\n@@ -160,0 +153,1 @@\n+    }\n@@ -164,1 +158,1 @@\n-    for (i = 0; i < ColorIn1->ColorCount; i++)\n+    for (i = 0; i < ColorIn1->ColorCount; i++) {\n@@ -166,0 +160,1 @@\n+    }\n@@ -175,3 +170,3 @@\n-    while (ColorIn1->Colors[CrntSlot - 1].Red == 0\n-           && ColorIn1->Colors[CrntSlot - 1].Green == 0\n-           && ColorIn1->Colors[CrntSlot - 1].Blue == 0)\n+    while (ColorIn1->Colors[CrntSlot - 1].Red == 0 &&\n+           ColorIn1->Colors[CrntSlot - 1].Green == 0 &&\n+           ColorIn1->Colors[CrntSlot - 1].Blue == 0) {\n@@ -179,0 +174,1 @@\n+    }\n@@ -183,3 +179,3 @@\n-        for (j = 0; j < ColorIn1->ColorCount; j++)\n-            if (memcmp (&ColorIn1->Colors[j], &ColorIn2->Colors[i],\n-                        sizeof(GifColorType)) == 0)\n+        for (j = 0; j < ColorIn1->ColorCount; j++) {\n+            if (memcmp(&ColorIn1->Colors[j], &ColorIn2->Colors[i],\n+                       sizeof(GifColorType)) == 0) {\n@@ -187,0 +183,2 @@\n+            }\n+        }\n@@ -188,3 +186,3 @@\n-        if (j < ColorIn1->ColorCount)\n-            ColorTransIn2[i] = j;    \/* color exists in Color1 *\/\n-        else {\n+        if (j < ColorIn1->ColorCount) {\n+            ColorTransIn2[i] = j; \/* color exists in Color1 *\/\n+        } else {\n@@ -199,1 +197,1 @@\n-        return ((ColorMapObject *) NULL);\n+        return ((ColorMapObject *)NULL);\n@@ -213,1 +211,1 @@\n-        for (j = CrntSlot; j < RoundUpTo; j++)\n+        for (j = CrntSlot; j < RoundUpTo; j++) {\n@@ -215,0 +213,1 @@\n+        }\n@@ -218,3 +217,3 @@\n-            GifColorType *new_map = (GifColorType *)reallocarray(Map,\n-                                 RoundUpTo, sizeof(GifColorType));\n-            if( new_map == NULL ) {\n+            GifColorType *new_map = (GifColorType *)reallocarray(\n+                Map, RoundUpTo, sizeof(GifColorType));\n+            if (new_map == NULL) {\n@@ -222,1 +221,1 @@\n-                return ((ColorMapObject *) NULL);\n+                return ((ColorMapObject *)NULL);\n@@ -237,3 +236,1 @@\n-void\n-GifApplyTranslation(SavedImage *Image, GifPixelType Translation[])\n-{\n+void GifApplyTranslation(SavedImage *Image, const GifPixelType Translation[]) {\n@@ -241,1 +238,2 @@\n-    register int RasterSize = Image->ImageDesc.Height * Image->ImageDesc.Width;\n+    register int RasterSize =\n+        Image->ImageDesc.Height * Image->ImageDesc.Width;\n@@ -243,1 +241,1 @@\n-    for (i = 0; i < RasterSize; i++)\n+    for (i = 0; i < RasterSize; i++) {\n@@ -245,0 +243,1 @@\n+    }\n@@ -250,7 +249,3 @@\n-int\n-GifAddExtensionBlock(int *ExtensionBlockCount,\n-                     ExtensionBlock **ExtensionBlocks,\n-                     int Function,\n-                     unsigned int Len,\n-                     unsigned char ExtData[])\n-{\n+int GifAddExtensionBlock(int *ExtensionBlockCount,\n+                         ExtensionBlock **ExtensionBlocks, int Function,\n+                         unsigned int Len, unsigned char ExtData[]) {\n@@ -259,7 +254,8 @@\n-    if (*ExtensionBlocks == NULL)\n-        *ExtensionBlocks=(ExtensionBlock *)malloc(sizeof(ExtensionBlock));\n-    else {\n-        ExtensionBlock* ep_new = (ExtensionBlock *)reallocarray\n-                                      (*ExtensionBlocks, (*ExtensionBlockCount + 1),\n-                                      sizeof(ExtensionBlock));\n-        if( ep_new == NULL )\n+    if (*ExtensionBlocks == NULL) {\n+        *ExtensionBlocks =\n+            (ExtensionBlock *)malloc(sizeof(ExtensionBlock));\n+    } else {\n+        ExtensionBlock *ep_new = (ExtensionBlock *)reallocarray(\n+            *ExtensionBlocks, (*ExtensionBlockCount + 1),\n+            sizeof(ExtensionBlock));\n+        if (ep_new == NULL) {\n@@ -267,0 +263,1 @@\n+        }\n@@ -270,1 +267,1 @@\n-    if (*ExtensionBlocks == NULL)\n+    if (*ExtensionBlocks == NULL) {\n@@ -272,0 +269,1 @@\n+    }\n@@ -276,1 +274,1 @@\n-    ep->ByteCount=Len;\n+    ep->ByteCount = Len;\n@@ -278,1 +276,1 @@\n-    if (ep->Bytes == NULL)\n+    if (ep->Bytes == NULL) {\n@@ -280,0 +278,1 @@\n+    }\n@@ -288,4 +287,2 @@\n-void\n-GifFreeExtensions(int *ExtensionBlockCount,\n-                  ExtensionBlock **ExtensionBlocks)\n-{\n+void GifFreeExtensions(int *ExtensionBlockCount,\n+                       ExtensionBlock **ExtensionBlocks) {\n@@ -294,1 +291,1 @@\n-    if (*ExtensionBlocks == NULL)\n+    if (*ExtensionBlocks == NULL) {\n@@ -296,0 +293,1 @@\n+    }\n@@ -298,2 +296,1 @@\n-         ep < (*ExtensionBlocks + *ExtensionBlockCount);\n-         ep++)\n+         ep < (*ExtensionBlocks + *ExtensionBlockCount); ep++) {\n@@ -301,0 +298,1 @@\n+    }\n@@ -307,1 +305,1 @@\n- Image block allocation functions\n+   Image block allocation functions\n@@ -313,3 +311,1 @@\n-void\n-FreeLastSavedImage(GifFileType *GifFile)\n-{\n+void FreeLastSavedImage(GifFileType *GifFile) {\n@@ -318,1 +314,1 @@\n-    if ((GifFile == NULL) || (GifFile->SavedImages == NULL))\n+    if ((GifFile == NULL) || (GifFile->SavedImages == NULL)) {\n@@ -320,0 +316,1 @@\n+    }\n@@ -332,1 +329,1 @@\n-    if (sp->RasterBits != NULL)\n+    if (sp->RasterBits != NULL) {\n@@ -334,0 +331,1 @@\n+    }\n@@ -340,3 +338,4 @@\n-     * time.  If this is used in GifFreeSavedImages then it would be inefficient\n-     * (The whole array is going to be deallocated.)  If we just use it when\n-     * we want to free the last Image it's convenient to do it here.\n+     * time.  If this is used in GifFreeSavedImages then it would be\n+     * inefficient (The whole array is going to be deallocated.)  If we just\n+     * use it when we want to free the last Image it's convenient to do it\n+     * here.\n@@ -349,4 +348,4 @@\n-SavedImage *\n-GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)\n-{\n-    if (GifFile->SavedImages == NULL)\n+SavedImage *GifMakeSavedImage(GifFileType *GifFile,\n+                              const SavedImage *CopyFrom) {\n+    \/\/ cppcheck-suppress ctunullpointer\n+    if (GifFile->SavedImages == NULL) {\n@@ -354,4 +353,5 @@\n-    else {\n-        SavedImage* newSavedImages = (SavedImage *)reallocarray(GifFile->SavedImages,\n-                               (GifFile->ImageCount + 1), sizeof(SavedImage));\n-        if( newSavedImages == NULL)\n+    } else {\n+        SavedImage *newSavedImages = (SavedImage *)reallocarray(\n+            GifFile->SavedImages, (GifFile->ImageCount + 1),\n+            sizeof(SavedImage));\n+        if (newSavedImages == NULL) {\n@@ -359,0 +359,1 @@\n+        }\n@@ -361,1 +362,1 @@\n-    if (GifFile->SavedImages == NULL)\n+    if (GifFile->SavedImages == NULL) {\n@@ -363,1 +364,1 @@\n-    else {\n+    } else {\n@@ -370,3 +371,3 @@\n-             * Make our own allocated copies of the heap fields in the\n-             * copied record.  This guards against potential aliasing\n-             * problems.\n+             * Make our own allocated copies of the heap fields in\n+             * the copied record.  This guards against potential\n+             * aliasing problems.\n@@ -378,2 +379,2 @@\n-                                         CopyFrom->ImageDesc.ColorMap->ColorCount,\n-                                         CopyFrom->ImageDesc.ColorMap->Colors);\n+                    CopyFrom->ImageDesc.ColorMap->ColorCount,\n+                    CopyFrom->ImageDesc.ColorMap->Colors);\n@@ -387,4 +388,5 @@\n-            sp->RasterBits = (unsigned char *)reallocarray(NULL,\n-                                                  (CopyFrom->ImageDesc.Height *\n-                                                  CopyFrom->ImageDesc.Width),\n-                                                  sizeof(GifPixelType));\n+            sp->RasterBits = (unsigned char *)reallocarray(\n+                NULL,\n+                (CopyFrom->ImageDesc.Height *\n+                 CopyFrom->ImageDesc.Width),\n+                sizeof(GifPixelType));\n@@ -396,2 +398,3 @@\n-                   sizeof(GifPixelType) * CopyFrom->ImageDesc.Height *\n-                   CopyFrom->ImageDesc.Width);\n+                   sizeof(GifPixelType) *\n+                       CopyFrom->ImageDesc.Height *\n+                       CopyFrom->ImageDesc.Width);\n@@ -401,3 +404,4 @@\n-                sp->ExtensionBlocks = (ExtensionBlock *)reallocarray(NULL,\n-                                      CopyFrom->ExtensionBlockCount,\n-                                      sizeof(ExtensionBlock));\n+                sp->ExtensionBlocks =\n+                    (ExtensionBlock *)reallocarray(\n+                        NULL, CopyFrom->ExtensionBlockCount,\n+                        sizeof(ExtensionBlock));\n@@ -408,2 +412,4 @@\n-                memcpy(sp->ExtensionBlocks, CopyFrom->ExtensionBlocks,\n-                       sizeof(ExtensionBlock) * CopyFrom->ExtensionBlockCount);\n+                memcpy(sp->ExtensionBlocks,\n+                       CopyFrom->ExtensionBlocks,\n+                       sizeof(ExtensionBlock) *\n+                           CopyFrom->ExtensionBlockCount);\n@@ -411,2 +417,1 @@\n-        }\n-        else {\n+        } else {\n@@ -420,3 +425,1 @@\n-void\n-GifFreeSavedImages(GifFileType *GifFile)\n-{\n+void GifFreeSavedImages(GifFileType *GifFile) {\n@@ -435,1 +438,1 @@\n-        if (sp->RasterBits != NULL)\n+        if (sp->RasterBits != NULL) {\n@@ -437,0 +440,1 @@\n+        }\n@@ -438,1 +442,2 @@\n-        GifFreeExtensions(&sp->ExtensionBlockCount, &sp->ExtensionBlocks);\n+        GifFreeExtensions(&sp->ExtensionBlockCount,\n+                          &sp->ExtensionBlocks);\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/giflib\/gifalloc.c","additions":130,"deletions":125,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include <sys\/types.h>\n@@ -35,0 +34,1 @@\n+#include <sys\/types.h>\n@@ -37,1 +37,1 @@\n-    #define SIZE_MAX     UINTPTR_MAX\n+#define SIZE_MAX UINTPTR_MAX\n@@ -44,1 +44,1 @@\n-#define MUL_NO_OVERFLOW    ((size_t)1 << (sizeof(size_t) * 4))\n+#define MUL_NO_OVERFLOW ((size_t)1 << (sizeof(size_t) * 4))\n@@ -46,3 +46,1 @@\n-void *\n-openbsd_reallocarray(void *optr, size_t nmemb, size_t size)\n-{\n+void *openbsd_reallocarray(void *optr, size_t nmemb, size_t size) {\n@@ -96,1 +94,1 @@\n-    if (size == 0 || nmemb == 0)\n+    if (size == 0 || nmemb == 0) {\n@@ -98,0 +96,1 @@\n+    }\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/giflib\/openbsd-reallocarray.c","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -61,0 +63,1 @@\n+@SuppressWarnings(\"removal\")\n@@ -72,0 +75,10 @@\n+    private static void doPrivilegedRunnable(Runnable runnable) {\n+        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+            @Override\n+            public Void run() {\n+                runnable.run();\n+                return null;\n+            }\n+        });\n+    }\n+\n@@ -73,1 +86,7 @@\n-        PROPS_PATH = setupPath();\n+        PROPS_PATH = AccessController.doPrivileged(new PrivilegedAction<Path>() {\n+            @Override\n+            public Path run() {\n+                return setupPath();\n+            }\n+        });\n+\n@@ -195,1 +214,1 @@\n-                        setFilePermission(PROPS_PATH);\n+                        doPrivilegedRunnable(() -> setFilePermission(PROPS_PATH));\n@@ -197,1 +216,1 @@\n-                        readTokens(PROPS_PATH);\n+                        doPrivilegedRunnable(() -> readTokens(PROPS_PATH));\n@@ -210,0 +229,2 @@\n+    private static WatchService watchService;\n+\n@@ -211,3 +232,4 @@\n-        try {\n-            WatchService watchService =\n-                    FileSystems.getDefault().newWatchService();\n+        doPrivilegedRunnable(() -> {\n+            try {\n+                watchService =\n+                        FileSystems.getDefault().newWatchService();\n@@ -215,6 +237,6 @@\n-            PROPS_PATH\n-                    .getParent()\n-                    .register(watchService,\n-                            ENTRY_CREATE,\n-                            ENTRY_DELETE,\n-                            ENTRY_MODIFY);\n+                PROPS_PATH\n+                        .getParent()\n+                        .register(watchService,\n+                                ENTRY_CREATE,\n+                                ENTRY_DELETE,\n+                                ENTRY_MODIFY);\n@@ -222,5 +244,5 @@\n-            new WatcherThread(watchService).start();\n-        } catch (Exception e) {\n-            if (SCREENCAST_DEBUG) {\n-                System.err.printf(\"Token storage: failed to setup \" +\n-                        \"file watch %s\\n\", e);\n+            } catch (Exception e) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.printf(\"Token storage: failed to setup \" +\n+                            \"file watch %s\\n\", e);\n+                }\n@@ -228,0 +250,4 @@\n+        });\n+\n+        if (watchService != null) {\n+            new WatcherThread(watchService).start();\n@@ -279,1 +305,1 @@\n-                store(\"save tokens\");\n+                doPrivilegedRunnable(() -> store(\"save tokens\"));\n@@ -334,1 +360,1 @@\n-        removeMalformedRecords(malformed);\n+        doPrivilegedRunnable(() -> removeMalformedRecords(malformed));\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":46,"deletions":20,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,15 +105,17 @@\n-    * Name of the attribute that specifies an\n-    * {@link ObjectInputFilter} pattern string to filter classes acceptable\n-    * for {@link RMIServer#newClient(java.lang.Object) RMIServer.newClient()}\n-    * remote method call.\n-    * <p>\n-    * The filter pattern must be in same format as used in\n-    * {@link java.io.ObjectInputFilter.Config#createFilter}\n-    * <p>\n-    * This list of classes allowed by filter should correspond to the\n-    * transitive closure of the credentials class (or classes) used by the\n-    * installed {@linkplain JMXAuthenticator} associated with the\n-    * {@linkplain RMIServer} implementation.\n-    * If the attribute is not set then any class is deemed acceptable.\n-    * @see ObjectInputFilter\n-    *\/\n+     * Name of the attribute that specifies an\n+     * {@link ObjectInputFilter} pattern string to filter classes acceptable\n+     * for {@link RMIServer#newClient(java.lang.Object) RMIServer.newClient()}\n+     * remote method call.\n+     * <p>\n+     * The filter pattern must be in same format as used in\n+     * {@link java.io.ObjectInputFilter.Config#createFilter}\n+     * <p>\n+     * This list of classes allowed by filter should correspond to the\n+     * transitive closure of the credentials class (or classes) used by the\n+     * installed {@linkplain JMXAuthenticator} associated with the\n+     * {@linkplain RMIServer} implementation.\n+     * If the attribute is not set then any class is deemed acceptable.\n+     * @see ObjectInputFilter\n+     *\n+     * @since 10\n+     *\/\n@@ -155,0 +157,2 @@\n+     *\n+     * @since 10\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectorServer.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,326 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ *    <p>The RMI connector is a connector for the JMX Remote API that\n+ *      uses RMI to transmit client requests to a remote MBean server.\n+ *      This package defines the classes that the user of an RMI\n+ *      connector needs to reference directly, for both the client and\n+ *      server sides.  It also defines certain classes that the user\n+ *      will not usually reference directly, but that must be defined so\n+ *      that different implementations of the RMI connector can\n+ *      interoperate.<\/p>\n+ *\n+ *    <p>The RMI connector supports the JRMP transport for RMI.<\/p>\n+ *\n+ *    <p>Like most connectors in the JMX Remote API, an RMI connector\n+ *      usually has an address, which\n+ *      is a {@link javax.management.remote.JMXServiceURL\n+ *      JMXServiceURL}.  The protocol part of this address is\n+ *      <code>rmi<\/code> for a connector that uses the default RMI\n+ *      transport (JRMP).<\/p>\n+ *\n+ *    <p>There are two forms for RMI connector addresses:<\/p>\n+ *\n+ *    <ul>\n+ *      <li>\n+ *  In the <em>JNDI form<\/em>, the URL indicates <em>where to find\n+ *  an RMI stub for the connector<\/em>.  This RMI stub is a Java\n+ *  object of type {@link javax.management.remote.rmi.RMIServer\n+ *  RMIServer} that gives remote access to the connector server.\n+ *  With this address form, the RMI stub is obtained from an\n+ *  external directory entry included in the URL.  An external\n+ *  directory is any directory recognized by {@link javax.naming\n+ *  JNDI}, typically the RMI registry, LDAP, or COS Naming.\n+ *\n+ *      <li>\n+ *  In the <em>encoded form<\/em>, the URL directly includes the\n+ *  information needed to connect to the connector server.  When\n+ *  using RMI\/JRMP, the encoded form is the serialized RMI stub\n+ *  for the server object, encoded using BASE64 without embedded\n+ *  newlines.\n+ *    <\/ul>\n+ *\n+ *    <p>Addresses are covered in more detail below.<\/p>\n+ *\n+ *\n+ *    <h2>Creating an RMI connector server<\/h2>\n+ *\n+ *    <p>The usual way to create an RMI connector server is to supply an\n+ *      RMI connector address to the method {@link\n+ *      javax.management.remote.JMXConnectorServerFactory#newJMXConnectorServer\n+ *      JMXConnectorServerFactory.newJMXConnectorServer}.  The MBean\n+ *      server to which the connector server is attached can be\n+ *      specified as a parameter to that method.  Alternatively, the\n+ *      connector server can be registered as an MBean in that MBean\n+ *      server.<\/p>\n+ *\n+ *    <p>An RMI connector server can also be created by constructing an\n+ *      instance of {@link\n+ *      javax.management.remote.rmi.RMIConnectorServer\n+ *      RMIConnectorServer}, explicitly or through the MBean server's\n+ *      <code>createMBean<\/code> method.<\/p>\n+ *\n+ *    <h3>Choosing the RMI transport<\/h3>\n+ *\n+ *    <p>You can choose the RMI transport by specifying\n+ *      <code>rmi<\/code> in the <code><em>protocol<\/em><\/code> part of the\n+ *      <code>serviceURL<\/code> when creating the connector server.  You\n+ *      can also create specialized connector servers by instantiating\n+ *      an appropriate subclass of {@link\n+ *      javax.management.remote.rmi.RMIServerImpl RMIServerImpl} and\n+ *      supplying it to the <code>RMIConnectorServer<\/code>\n+ *      constructor.<\/p>\n+ *\n+ *\n+ *    <h3><a id=\"servergen\">Connector addresses generated by the\n+ *  server<\/a><\/h3>\n+ *\n+ *    <p>If the <code>serviceURL<\/code> you specify has an empty URL\n+ *      path (after the optional host and port), or if you do not\n+ *      specify a <code>serviceURL<\/code>, then the connector server\n+ *      will fabricate a new <code>JMXServiceURL<\/code> that clients can\n+ *      use to connect:<\/p>\n+ *\n+ *    <ul>\n+ *\n+ *      <li><p>If the <code>serviceURL<\/code> looks like:<\/p>\n+ *\n+ *  <pre>\n+ *  <code>service:jmx:rmi:\/\/<em>host<\/em>:<em>port<\/em><\/code>\n+ *  <\/pre>\n+ *\n+ *  <p>then the connector server will generate an {@link\n+ *  javax.management.remote.rmi.RMIJRMPServerImpl\n+ *  RMIJRMPServerImpl} and the returned <code>JMXServiceURL<\/code>\n+ *  looks like:<\/p>\n+ *\n+ *  <pre>\n+ *  <code>service:jmx:rmi:\/\/<em>host<\/em>:<em>port<\/em>\/stub\/<em>XXXX<\/em><\/code>\n+ *  <\/pre>\n+ *\n+ *  <p>where <code><em>XXXX<\/em><\/code> is the serialized form of the\n+ *  stub for the generated object, encoded in BASE64 without\n+ *  newlines.<\/p>\n+ *\n+ *      <li><p>If there is no <code>serviceURL<\/code>, there must be a\n+ *  user-provided <code>RMIServerImpl<\/code>.  The connector server\n+ *        will generate a <code>JMXServiceURL<\/code> using the <code>rmi<\/code>\n+ *  form.<\/p>\n+ *\n+ *    <\/ul>\n+ *\n+ *    <p>The <code><em>host<\/em><\/code> in a user-provided\n+ *      <code>serviceURL<\/code> is optional.  If present, it is copied\n+ *      into the generated <code>JMXServiceURL<\/code> but otherwise\n+ *      ignored.  If absent, the generated <code>JXMServiceURL<\/code>\n+ *      will have the local host name.<\/p>\n+ *\n+ *    <p>The <code><em>port<\/em><\/code> in a user-provided\n+ *      <code>serviceURL<\/code> is also optional.  If present, it is\n+ *      also copied into the generated <code>JMXServiceURL<\/code>;\n+ *      otherwise, the generated <code>JMXServiceURL<\/code> has no port.\n+ *      For an <code>serviceURL<\/code> using the <code>rmi<\/code>\n+ *      protocol, the <code><em>port<\/em><\/code>, if present, indicates\n+ *      what port the generated remote object should be exported on.  It\n+ *      has no other effect.<\/p>\n+ *\n+ *    <p>If the user provides an <code>RMIServerImpl<\/code> rather than a\n+ *      <code>JMXServiceURL<\/code>, then the generated\n+ *      <code>JMXServiceURL<\/code> will have the local host name in its\n+ *      <code><em>host<\/em><\/code> part and no\n+ *      <code><em>port<\/em><\/code>.<\/p>\n+ *\n+ *\n+ *    <h3><a id=\"directory\">Connector addresses based on directory\n+ *  entries<\/a><\/h3>\n+ *\n+ *    <p>As an alternative to the generated addresses just described,\n+ *      the <code>serviceURL<\/code> address supplied when creating a\n+ *      connector server can specify a <em>directory address<\/em> in\n+ *      which to store the provided or generated <code>RMIServer<\/code>\n+ *      stub.  This directory address is then used by both client and\n+ *      server.<\/p>\n+ *\n+ *    <p>In this case, the <code>serviceURL<\/code> has the following form:<\/p>\n+ *\n+ *    <pre>\n+ *    <code>service:jmx:rmi:\/\/<em>host<\/em>:<em>port<\/em>\/jndi\/<em>jndi-name<\/em><\/code>\n+ *    <\/pre>\n+ *\n+ *    <p>Here, <code><em>jndi-name<\/em><\/code> is a string that can be\n+ *      supplied to {@link javax.naming.InitialContext#bind\n+ *      javax.naming.InitialContext.bind}.<\/p>\n+ *\n+ *    <p>As usual, the <code><em>host<\/em><\/code> and\n+ *      <code>:<em>port<\/em><\/code> can be omitted.<\/p>\n+ *\n+ *    <p>The connector server will generate an\n+ *      <code>RMIServerImpl<\/code> based on the protocol\n+ *      (<code>rmi<\/code>) and the <code><em>port<\/em><\/code> if any.  When\n+ *      the connector server is started, it will derive a stub from this\n+ *      object using its {@link\n+ *      javax.management.remote.rmi.RMIServerImpl#toStub toStub} method\n+ *      and store the object using the given\n+ *      <code><em>jndi-name<\/em><\/code>.  The properties defined by the\n+ *      JNDI API are consulted as usual.<\/p>\n+ *\n+ *    <p>For example, if the <code>JMXServiceURL<\/code> is:\n+ *\n+ *      <pre>\n+ *      <code>service:jmx:rmi:\/\/ignoredhost\/jndi\/rmi:\/\/myhost\/myname<\/code>\n+ *      <\/pre>\n+ *\n+ *      then the connector server will generate an\n+ *      <code>RMIJRMPServerImpl<\/code> and store its stub using the JNDI\n+ *      name\n+ *\n+ *      <pre>\n+ *      <code>rmi:\/\/myhost\/myname<\/code>\n+ *      <\/pre>\n+ *\n+ *      which means entry <code>myname<\/code> in the RMI registry\n+ *      running on the default port of host <code>myhost<\/code>.  Note\n+ *      that the RMI registry only allows registration from the local\n+ *      host.  So, in this case, <code>myhost<\/code> must be the name\n+ *      (or a name) of the host that the connector server is running\n+ *      on.\n+ *\n+ *    <p>In this <code>JMXServiceURL<\/code>, the first <code>rmi:<\/code>\n+ *      specifies the RMI\n+ *      connector, while the second <code>rmi:<\/code> specifies the RMI\n+ *      registry.\n+ *\n+ *    <p>As another example, if the <code>JMXServiceURL<\/code> is:\n+ *\n+ *      <pre>\n+ *      <code>service:jmx:rmi:\/\/ignoredhost\/jndi\/ldap:\/\/dirhost:9999\/cn=this,ou=that<\/code>\n+ *      <\/pre>\n+ *\n+ *      then the connector server will generate an\n+ *      <code>RMIJRMPServerImpl<\/code> and store its stub using the JNDI\n+ *      name\n+ *\n+ *      <pre>\n+ *      <code>ldap:\/\/dirhost:9999\/cn=this,ou=that<\/code>\n+ *      <\/pre>\n+ *\n+ *      which means entry <code>cn=this,ou=that<\/code> in the LDAP\n+ *      directory running on port 9999 of host <code>dirhost<\/code>.\n+ *\n+ *    <p>If the <code>JMXServiceURL<\/code> is:\n+ *\n+ *      <pre>\n+ *      <code>service:jmx:rmi:\/\/ignoredhost\/jndi\/cn=this,ou=that<\/code>\n+ *      <\/pre>\n+ *\n+ *      then the connector server will generate an\n+ *      <code>RMIJRMPServerImpl<\/code> and store its stub using the JNDI\n+ *      name\n+ *\n+ *      <pre>\n+ *      <code>cn=this,ou=that<\/code>\n+ *      <\/pre>\n+ *\n+ *      For this case to work, the JNDI API must have been configured\n+ *      appropriately to supply the information about what directory to\n+ *      use.\n+ *\n+ *    <p>In these examples, the host name <code>ignoredhost<\/code> is\n+ *      not used by the connector server or its clients.  It can be\n+ *      omitted, for example:<\/p>\n+ *\n+ *      <pre>\n+ *      <code>service:jmx:rmi:\/\/\/jndi\/cn=this,ou=that<\/code>\n+ *      <\/pre>\n+ *\n+ *    <p>However, it is good practice to use the name of the host\n+ *      where the connector server is running.  This is often different\n+ *      from the name of the directory host.<\/p>\n+ *\n+ *\n+ *    <h3>Connector server attributes<\/h3>\n+ *\n+ *    <p>When using the default JRMP transport, RMI socket factories can\n+ *      be specified using the attributes\n+ *      <code>jmx.remote.rmi.client.socket.factory<\/code> and\n+ *      <code>jmx.remote.rmi.server.socket.factory<\/code> in the\n+ *      <code>environment<\/code> given to the\n+ *      <code>RMIConnectorServer<\/code> constructor.  The values of these\n+ *      attributes must be of type {@link\n+ *      java.rmi.server.RMIClientSocketFactory} and {@link\n+ *      java.rmi.server.RMIServerSocketFactory}, respectively.  These\n+ *      factories are used when creating the RMI objects associated with\n+ *      the connector.<\/p>\n+ *\n+ *    <h2>Creating an RMI connector client<\/h2>\n+ *\n+ *    <p>An RMI connector client is usually constructed using {@link\n+ *      javax.management.remote.JMXConnectorFactory}, with a\n+ *      <code>JMXServiceURL<\/code> that has <code>rmi<\/code> as its protocol.<\/p>\n+ *\n+ *    <p>If the <code>JMXServiceURL<\/code> was generated by the server,\n+ *      as described above under <a href=\"#servergen\">\"connector\n+ *      addresses generated by the server\"<\/a>, then the client will\n+ *      need to obtain it directly or indirectly from the server.\n+ *      Typically, the server makes the <code>JMXServiceURL<\/code>\n+ *      available by storing it in a file or a lookup service.<\/p>\n+ *\n+ *    <p>If the <code>JMXServiceURL<\/code> uses the directory syntax, as\n+ *      described above under <a href=\"#directory\">\"connector addresses\n+ *      based on directory entries\"<\/a>, then the client may obtain it\n+ *      as just explained, or client and server may both know the\n+ *      appropriate directory entry to use.  For example, if the\n+ *      connector server for the Whatsit agent uses the entry\n+ *      <code>whatsit-agent-connector<\/code> in the RMI registry on host\n+ *      <code>myhost<\/code>, then client and server can both know\n+ *      that the appropriate <code>JMXServiceURL<\/code> is:<\/p>\n+ *\n+ *    <pre>\n+ *    <code>service:jmx:rmi:\/\/\/jndi\/rmi:\/\/myhost\/whatsit-agent-connector<\/code>\n+ *    <\/pre>\n+ *\n+ *    <p>If you have an RMI stub of type {@link\n+ *      javax.management.remote.rmi.RMIServer RMIServer}, you can\n+ *      construct an RMI connection directly by using the appropriate\n+ *      constructor of {@link javax.management.remote.rmi.RMIConnector\n+ *      RMIConnector}.<\/p>\n+ *\n+ *    <h2>Dynamic code downloading<\/h2>\n+ *\n+ *    <p>If an RMI connector client or server receives from its peer an\n+ *      instance of a class that it does not know, and if dynamic code\n+ *      downloading is active for the RMI connection, then the class can\n+ *      be downloaded from a codebase specified by the peer.\n+ *      {@extLink rmi_guide Java RMI Guide} explains this in more detail.<\/p>\n+ *\n+ *    @see <a href=\"http:\/\/www.ietf.org\/rfc\/rfc2045.txt\">RFC 2045,\n+ *    section 6.8, \"Base64 Content-Transfer-Encoding\"<\/a>\n+ *\n+ *\n+ *    @since 1.5\n+ *\n+ *\/\n+package javax.management.remote.rmi;\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/package-info.java","additions":326,"deletions":0,"binary":false,"changes":326,"status":"added"},{"patch":"@@ -1,329 +0,0 @@\n-<html>\n-<head>\n-    <title>RMI connector<\/title>\n-<!--\n-Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n--->\n-<\/head>\n-<body bgcolor=\"white\">\n-    <p>The RMI connector is a connector for the JMX Remote API that\n-      uses RMI to transmit client requests to a remote MBean server.\n-      This package defines the classes that the user of an RMI\n-      connector needs to reference directly, for both the client and\n-      server sides.  It also defines certain classes that the user\n-      will not usually reference directly, but that must be defined so\n-      that different implementations of the RMI connector can\n-      interoperate.<\/p>\n-\n-    <p>The RMI connector supports the JRMP transport for RMI.<\/p>\n-\n-    <p>Like most connectors in the JMX Remote API, an RMI connector\n-      usually has an address, which\n-      is a {@link javax.management.remote.JMXServiceURL\n-      JMXServiceURL}.  The protocol part of this address is\n-      <code>rmi<\/code> for a connector that uses the default RMI\n-      transport (JRMP).<\/p>\n-\n-    <p>There are two forms for RMI connector addresses:<\/p>\n-\n-    <ul>\n-      <li>\n-\tIn the <em>JNDI form<\/em>, the URL indicates <em>where to find\n-\tan RMI stub for the connector<\/em>.  This RMI stub is a Java\n-\tobject of type {@link javax.management.remote.rmi.RMIServer\n-\tRMIServer} that gives remote access to the connector server.\n-\tWith this address form, the RMI stub is obtained from an\n-\texternal directory entry included in the URL.  An external\n-\tdirectory is any directory recognized by {@link javax.naming\n-\tJNDI}, typically the RMI registry, LDAP, or COS Naming.\n-\n-      <li>\n-\tIn the <em>encoded form<\/em>, the URL directly includes the\n-\tinformation needed to connect to the connector server.  When\n-\tusing RMI\/JRMP, the encoded form is the serialized RMI stub\n-\tfor the server object, encoded using BASE64 without embedded\n-\tnewlines.\n-    <\/ul>\n-\n-    <p>Addresses are covered in more detail below.<\/p>\n-\n-\n-    <h2>Creating an RMI connector server<\/h2>\n-\n-    <p>The usual way to create an RMI connector server is to supply an\n-      RMI connector address to the method {@link\n-      javax.management.remote.JMXConnectorServerFactory#newJMXConnectorServer\n-      JMXConnectorServerFactory.newJMXConnectorServer}.  The MBean\n-      server to which the connector server is attached can be\n-      specified as a parameter to that method.  Alternatively, the\n-      connector server can be registered as an MBean in that MBean\n-      server.<\/p>\n-\n-    <p>An RMI connector server can also be created by constructing an\n-      instance of {@link\n-      javax.management.remote.rmi.RMIConnectorServer\n-      RMIConnectorServer}, explicitly or through the MBean server's\n-      <code>createMBean<\/code> method.<\/p>\n-\n-    <h3>Choosing the RMI transport<\/h3>\n-\n-    <p>You can choose the RMI transport by specifying\n-      <code>rmi<\/code> in the <code><em>protocol<\/em><\/code> part of the\n-      <code>serviceURL<\/code> when creating the connector server.  You\n-      can also create specialized connector servers by instantiating\n-      an appropriate subclass of {@link\n-      javax.management.remote.rmi.RMIServerImpl RMIServerImpl} and\n-      supplying it to the <code>RMIConnectorServer<\/code>\n-      constructor.<\/p>\n-\n-\n-    <h3><a id=\"servergen\">Connector addresses generated by the\n-\tserver<\/a><\/h3>\n-\n-    <p>If the <code>serviceURL<\/code> you specify has an empty URL\n-      path (after the optional host and port), or if you do not\n-      specify a <code>serviceURL<\/code>, then the connector server\n-      will fabricate a new <code>JMXServiceURL<\/code> that clients can\n-      use to connect:<\/p>\n-\n-    <ul>\n-\n-      <li><p>If the <code>serviceURL<\/code> looks like:<\/p>\n-\n-\t<pre>\n-\t<code>service:jmx:rmi:\/\/<em>host<\/em>:<em>port<\/em><\/code>\n-\t<\/pre>\n-\n-\t<p>then the connector server will generate an {@link\n-\tjavax.management.remote.rmi.RMIJRMPServerImpl\n-\tRMIJRMPServerImpl} and the returned <code>JMXServiceURL<\/code>\n-\tlooks like:<\/p>\n-\n-\t<pre>\n-\t<code>service:jmx:rmi:\/\/<em>host<\/em>:<em>port<\/em>\/stub\/<em>XXXX<\/em><\/code>\n-\t<\/pre>\n-\n-\t<p>where <code><em>XXXX<\/em><\/code> is the serialized form of the\n-\tstub for the generated object, encoded in BASE64 without\n-\tnewlines.<\/p>\n-\n-      <li><p>If there is no <code>serviceURL<\/code>, there must be a\n-\tuser-provided <code>RMIServerImpl<\/code>.  The connector server\n-        will generate a <code>JMXServiceURL<\/code> using the <code>rmi<\/code>\n-\tform.<\/p>\n-\n-    <\/ul>\n-\n-    <p>The <code><em>host<\/em><\/code> in a user-provided\n-      <code>serviceURL<\/code> is optional.  If present, it is copied\n-      into the generated <code>JMXServiceURL<\/code> but otherwise\n-      ignored.  If absent, the generated <code>JXMServiceURL<\/code>\n-      will have the local host name.<\/p>\n-\n-    <p>The <code><em>port<\/em><\/code> in a user-provided\n-      <code>serviceURL<\/code> is also optional.  If present, it is\n-      also copied into the generated <code>JMXServiceURL<\/code>;\n-      otherwise, the generated <code>JMXServiceURL<\/code> has no port.\n-      For an <code>serviceURL<\/code> using the <code>rmi<\/code>\n-      protocol, the <code><em>port<\/em><\/code>, if present, indicates\n-      what port the generated remote object should be exported on.  It\n-      has no other effect.<\/p>\n-\n-    <p>If the user provides an <code>RMIServerImpl<\/code> rather than a\n-      <code>JMXServiceURL<\/code>, then the generated\n-      <code>JMXServiceURL<\/code> will have the local host name in its\n-      <code><em>host<\/em><\/code> part and no\n-      <code><em>port<\/em><\/code>.<\/p>\n-\n-\n-    <h3><a id=\"directory\">Connector addresses based on directory\n-\tentries<\/a><\/h3>\n-\n-    <p>As an alternative to the generated addresses just described,\n-      the <code>serviceURL<\/code> address supplied when creating a\n-      connector server can specify a <em>directory address<\/em> in\n-      which to store the provided or generated <code>RMIServer<\/code>\n-      stub.  This directory address is then used by both client and\n-      server.<\/p>\n-\n-    <p>In this case, the <code>serviceURL<\/code> has the following form:<\/p>\n-\n-    <pre>\n-    <code>service:jmx:rmi:\/\/<em>host<\/em>:<em>port<\/em>\/jndi\/<em>jndi-name<\/em><\/code>\n-    <\/pre>\n-\n-    <p>Here, <code><em>jndi-name<\/em><\/code> is a string that can be\n-      supplied to {@link javax.naming.InitialContext#bind\n-      javax.naming.InitialContext.bind}.<\/p>\n-\n-    <p>As usual, the <code><em>host<\/em><\/code> and\n-      <code>:<em>port<\/em><\/code> can be omitted.<\/p>\n-\n-    <p>The connector server will generate an\n-      <code>RMIServerImpl<\/code> based on the protocol\n-      (<code>rmi<\/code>) and the <code><em>port<\/em><\/code> if any.  When\n-      the connector server is started, it will derive a stub from this\n-      object using its {@link\n-      javax.management.remote.rmi.RMIServerImpl#toStub toStub} method\n-      and store the object using the given\n-      <code><em>jndi-name<\/em><\/code>.  The properties defined by the\n-      JNDI API are consulted as usual.<\/p>\n-\n-    <p>For example, if the <code>JMXServiceURL<\/code> is:\n-\n-      <pre>\n-      <code>service:jmx:rmi:\/\/ignoredhost\/jndi\/rmi:\/\/myhost\/myname<\/code>\n-      <\/pre>\n-\n-      then the connector server will generate an\n-      <code>RMIJRMPServerImpl<\/code> and store its stub using the JNDI\n-      name\n-\n-      <pre>\n-      <code>rmi:\/\/myhost\/myname<\/code>\n-      <\/pre>\n-\n-      which means entry <code>myname<\/code> in the RMI registry\n-      running on the default port of host <code>myhost<\/code>.  Note\n-      that the RMI registry only allows registration from the local\n-      host.  So, in this case, <code>myhost<\/code> must be the name\n-      (or a name) of the host that the connector server is running\n-      on.\n-\n-    <p>In this <code>JMXServiceURL<\/code>, the first <code>rmi:<\/code>\n-      specifies the RMI\n-      connector, while the second <code>rmi:<\/code> specifies the RMI\n-      registry.\n-\n-    <p>As another example, if the <code>JMXServiceURL<\/code> is:\n-\n-      <pre>\n-      <code>service:jmx:rmi:\/\/ignoredhost\/jndi\/ldap:\/\/dirhost:9999\/cn=this,ou=that<\/code>\n-      <\/pre>\n-\n-      then the connector server will generate an\n-      <code>RMIJRMPServerImpl<\/code> and store its stub using the JNDI\n-      name\n-\n-      <pre>\n-      <code>ldap:\/\/dirhost:9999\/cn=this,ou=that<\/code>\n-      <\/pre>\n-\n-      which means entry <code>cn=this,ou=that<\/code> in the LDAP\n-      directory running on port 9999 of host <code>dirhost<\/code>.\n-\n-    <p>If the <code>JMXServiceURL<\/code> is:\n-\n-      <pre>\n-      <code>service:jmx:rmi:\/\/ignoredhost\/jndi\/cn=this,ou=that<\/code>\n-      <\/pre>\n-\n-      then the connector server will generate an\n-      <code>RMIJRMPServerImpl<\/code> and store its stub using the JNDI\n-      name\n-\n-      <pre>\n-      <code>cn=this,ou=that<\/code>\n-      <\/pre>\n-\n-      For this case to work, the JNDI API must have been configured\n-      appropriately to supply the information about what directory to\n-      use.\n-\n-    <p>In these examples, the host name <code>ignoredhost<\/code> is\n-      not used by the connector server or its clients.  It can be\n-      omitted, for example:<\/p>\n-\n-      <pre>\n-      <code>service:jmx:rmi:\/\/\/jndi\/cn=this,ou=that<\/code>\n-      <\/pre>\n-\n-    <p>However, it is good practice to use the name of the host\n-      where the connector server is running.  This is often different\n-      from the name of the directory host.<\/p>\n-\n-\n-    <h3>Connector server attributes<\/h3>\n-\n-    <p>When using the default JRMP transport, RMI socket factories can\n-      be specified using the attributes\n-      <code>jmx.remote.rmi.client.socket.factory<\/code> and\n-      <code>jmx.remote.rmi.server.socket.factory<\/code> in the\n-      <code>environment<\/code> given to the\n-      <code>RMIConnectorServer<\/code> constructor.  The values of these\n-      attributes must be of type {@link\n-      java.rmi.server.RMIClientSocketFactory} and {@link\n-      java.rmi.server.RMIServerSocketFactory}, respectively.  These\n-      factories are used when creating the RMI objects associated with\n-      the connector.<\/p>\n-\n-    <h2>Creating an RMI connector client<\/h2>\n-\n-    <p>An RMI connector client is usually constructed using {@link\n-      javax.management.remote.JMXConnectorFactory}, with a\n-      <code>JMXServiceURL<\/code> that has <code>rmi<\/code> as its protocol.<\/p>\n-\n-    <p>If the <code>JMXServiceURL<\/code> was generated by the server,\n-      as described above under <a href=\"#servergen\">\"connector\n-      addresses generated by the server\"<\/a>, then the client will\n-      need to obtain it directly or indirectly from the server.\n-      Typically, the server makes the <code>JMXServiceURL<\/code>\n-      available by storing it in a file or a lookup service.<\/p>\n-\n-    <p>If the <code>JMXServiceURL<\/code> uses the directory syntax, as\n-      described above under <a href=\"#directory\">\"connector addresses\n-      based on directory entries\"<\/a>, then the client may obtain it\n-      as just explained, or client and server may both know the\n-      appropriate directory entry to use.  For example, if the\n-      connector server for the Whatsit agent uses the entry\n-      <code>whatsit-agent-connector<\/code> in the RMI registry on host\n-      <code>myhost<\/code>, then client and server can both know\n-      that the appropriate <code>JMXServiceURL<\/code> is:<\/p>\n-\n-    <pre>\n-    <code>service:jmx:rmi:\/\/\/jndi\/rmi:\/\/myhost\/whatsit-agent-connector<\/code>\n-    <\/pre>\n-\n-    <p>If you have an RMI stub of type {@link\n-      javax.management.remote.rmi.RMIServer RMIServer}, you can\n-      construct an RMI connection directly by using the appropriate\n-      constructor of {@link javax.management.remote.rmi.RMIConnector\n-      RMIConnector}.<\/p>\n-\n-    <h2>Dynamic code downloading<\/h2>\n-\n-    <p>If an RMI connector client or server receives from its peer an\n-      instance of a class that it does not know, and if dynamic code\n-      downloading is active for the RMI connection, then the class can\n-      be downloaded from a codebase specified by the peer.\n-      {@extLink rmi_guide Java RMI Guide} explains this in more detail.<\/p>\n-\n-    @see <a href=\"http:\/\/www.ietf.org\/rfc\/rfc2045.txt\">RFC 2045,\n-    section 6.8, \"Base64 Content-Transfer-Encoding\"<\/a>\n-\n-\n-    @since 1.5\n-\n-  <\/body>\n-<\/html>\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/package.html","additions":0,"deletions":329,"binary":false,"changes":329,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,2 @@\n+     *\n+     * @since 13\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/keyinfo\/KeyValue.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,0 +164,8 @@\n+        \/**\n+         * Used for instances of {@link RawTextTree}\n+         * representing a fragment of Markdown content.\n+         *\n+         * @since 23\n+         *\/\n+        MARKDOWN,\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTree.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -250,0 +250,16 @@\n+    \/**\n+     * Visits a {@code RawTextTree} node.\n+     *\n+     * @implSpec Visits the provided {@code RawTextTree} node\n+     * by calling {@code visitOther(node, p)}.\n+     *\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\n+     * @since 23\n+     *\/\n+    default R visitRawText(RawTextTree node, P p) {\n+        return visitOther(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTreeVisitor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,5 @@\n+ * @apiNote\n+ * There is no requirement that the comment containing the tag and the comment\n+ * containing the inherited documentation should either be both Markdown comments\n+ * or both traditional (not Markdown) comments.\n+ *\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/InheritDocTree.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.doctree;\n+\n+\/**\n+ * A tree node for a fragment of uninterpreted raw text content.\n+ *\n+ * <p>\n+ * The content may contain any text except that for\n+ * {@linkplain InlineTagTree inline tags}.\n+ *\n+ * <p>The format of the content is indicated by the {@linkplain #getKind() kind}\n+ * of the tree node.\n+ *\n+ * @apiNote\n+ * This class may be used to represent tree nodes containing\n+ * {@linkplain DocTree.Kind#MARKDOWN Markdown} text.\n+ * Such nodes will typically exist in a list of {@code DocTree} nodes,\n+ * along with other kinds of {@code DocTree} nodes, such as for inline tags.\n+ * When processing any such list, any non-Markdown nodes will be processed\n+ * recursively first, and then treated as opaque objects within the remaining\n+ * stream of Markdown nodes. Thus, the content of any non-Markdown nodes will\n+ * not affect how the Markdown nodes will be processed.\n+ *\n+ * @since 23\n+ *\/\n+public interface RawTextTree extends DocTree {\n+    \/**\n+     * {@return the content}\n+     *\/\n+    String getContent();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/RawTextTree.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Jonathan Gibbons\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/package-info.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-     * @since 12\n+     *\n+     * @since 14\n@@ -101,1 +102,2 @@\n-     * @since 12\n+     *\n+     * @since 14\n@@ -111,1 +113,2 @@\n-     * @since 12\n+     *\n+     * @since 14\n@@ -124,1 +127,1 @@\n-     * @since 12\n+     * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/CaseTree.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -50,0 +52,6 @@\n+    \/**\n+     * {@return true if this is an module import declaration.}\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.MODULE_IMPORTS, reflective=true)\n+    boolean isModule();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ImportTree.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @since 12\n+ * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/SwitchExpressionTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-         * @since 12\n+         * @since 14\n@@ -705,1 +705,1 @@\n-         * @since 13\n+         * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -416,1 +416,2 @@\n-     * @since 12\n+     *\n+     * @since 14\n@@ -611,1 +612,2 @@\n-     * @since 13\n+     *\n+     * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @since 13\n+ * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/YieldTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import com.sun.source.doctree.RawTextTree;\n@@ -292,0 +293,12 @@\n+    \/**\n+     * Creates a new {@code RawTextTree} object, to represent a fragment of uninterpreted raw text.\n+     *\n+     * @param kind the kind of text\n+     * @param code the code\n+     * @return a {@code RawTextTree} object\n+     * @throws IllegalArgumentException if the kind is not a recognized kind for raw text\n+     *\n+     * @since 23\n+     *\/\n+    RawTextTree newRawTextTree(DocTree.Kind kind, String code);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,0 +232,2 @@\n+     *\n+     * @since 10\n@@ -416,0 +418,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\n+     * @since 23\n+     *\/\n+    @Override\n+    public R visitRawText(RawTextTree node, P p) {\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+\n@@ -35,0 +36,1 @@\n+import javax.lang.model.util.Elements.DocCommentKind;\n@@ -87,0 +89,10 @@\n+    \/**\n+     * {@return the style of the documentation comment associated with a tree node}\n+     *\n+     * @param path the path for the tree node\n+     *\n+     * @see Trees#getPath(Element)\n+     * @since 23\n+     *\/\n+    public abstract DocCommentKind getDocCommentKind(TreePath path);\n+\n@@ -116,4 +128,8 @@\n-     * Returns the doc comment tree of the given file. The file must be\n-     * an HTML file, in which case the doc comment tree represents the\n-     * entire contents of the file.\n-     * Returns {@code null} if no doc comment was found.\n+     * Returns the doc comment tree of the given file, which must\n+     * be of one of the supported file types.\n+     *\n+     * <p>The supported file types are:\n+     * <ul>\n+     * <li>HTML files, identified by a file name ending in {@code .html},\n+     * <li>Markdown files, identified by a file name ending in {@code .md}.\n+     * <\/ul>\n@@ -127,0 +143,2 @@\n+     * @throws IllegalArgumentException if the file type is not supported\n+     *\n@@ -132,5 +150,9 @@\n-     * Returns the doc comment tree of the given file whose path is\n-     * specified relative to the given element. The file must be an HTML\n-     * file, in which case the doc comment tree represents the contents\n-     * of the &lt;body&gt; tag, and any enclosing tags are ignored.\n-     * Returns {@code null} if no doc comment was found.\n+     * Returns the doc comment tree of the given file, which must\n+     * be of one of the supported file types, and whose path is\n+     * specified relative to the given element.\n+     *\n+     * <p>The supported file types are:\n+     * <ul>\n+     * <li>HTML files, identified by a file name ending in {@code .html},\n+     * <li>Markdown files, identified by a file name ending in {@code .md}.\n+     * <\/ul>\n@@ -145,1 +167,2 @@\n-     * @throws java.io.IOException if an exception occurs\n+     * @throws IOException if an exception occurs\n+     * @throws IllegalArgumentException if the file type is not supported\n@@ -152,3 +175,6 @@\n-     * Returns a doc tree path containing the doc comment tree of the given file.\n-     * The file must be an HTML file, in which case the doc comment tree represents\n-     * the contents of the {@code <body>} tag, and any enclosing tags are ignored.\n+     * Returns a doc tree path containing the doc comment tree of the given file,\n+     * which must be of one of the supported file types.\n+     *\n+     * Supported file types are HTML files and Markdown files.\n+     * Future releases may support additional file types.\n+     *\n@@ -164,1 +190,1 @@\n-     * @throws IllegalArgumentException if the fileObject is not an HTML file\n+     * @throws IllegalArgumentException if the file type is not supported\n@@ -253,0 +279,2 @@\n+     *\n+     * @since 16\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTrees.java","additions":43,"deletions":15,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+     *\n+     * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/Plugin.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -369,0 +369,16 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\n+     * @since 23\n+     *\/\n+    @Override\n+    public R visitRawText(RawTextTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleDocTreeVisitor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -300,0 +300,2 @@\n+     *\n+     * @since 14\n@@ -1048,0 +1050,2 @@\n+     *\n+     * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -377,0 +377,2 @@\n+     *\n+     * @since 14\n@@ -1201,0 +1203,2 @@\n+     *\n+     * @since 14\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.ServiceLoader;\n@@ -51,0 +52,1 @@\n+import javax.lang.model.util.Elements.DocCommentKind;\n@@ -70,1 +72,0 @@\n-import com.sun.source.util.DocTreeScanner;\n@@ -103,0 +104,1 @@\n+import com.sun.tools.javac.parser.ReferenceParser;\n@@ -172,1 +174,0 @@\n-    private final ParserFactory parser;\n@@ -176,0 +177,3 @@\n+    private final ParserFactory parserFactory;\n+\n+    private DocCommentTreeTransformer docCommentTreeTransformer;\n@@ -217,1 +221,1 @@\n-        parser = ParserFactory.instance(context);\n+        parserFactory = ParserFactory.instance(context);\n@@ -264,14 +268,0 @@\n-    private DocTree getLastChild(DocTree tree) {\n-        final DocTree[] last = new DocTree[] {null};\n-\n-        tree.accept(new DocTreeScanner<Void, Void>() {\n-            @Override @DefinedBy(Api.COMPILER_TREE)\n-            public Void scan(DocTree node, Void p) {\n-                if (node != null) last[0] = node;\n-                return null;\n-            }\n-        }, null);\n-\n-        return last[0];\n-    }\n-\n@@ -726,2 +716,2 @@\n-        Tree t = path.getLeaf();\n-        Type ty = ((JCTree)t).type;\n+        Tree leaf = path.getLeaf();\n+        Type ty = ((JCTree) leaf).type;\n@@ -736,0 +726,16 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DocCommentKind getDocCommentKind(TreePath path) {\n+        var compUnit = path.getCompilationUnit();\n+        var leaf = path.getLeaf();\n+        if (compUnit instanceof JCTree.JCCompilationUnit cu && leaf instanceof JCTree l\n+                && cu.docComments != null) {\n+            Comment c = cu.docComments.getComment(l);\n+            return (c == null) ? null : switch (c.getStyle()) {\n+                case JAVADOC_BLOCK -> DocCommentKind.TRADITIONAL;\n+                case JAVADOC_LINE -> DocCommentKind.END_OF_LINE;\n+                default -> null;\n+            };\n+        }\n+        return null;\n+    }\n+\n@@ -738,6 +744,5 @@\n-        CompilationUnitTree t = path.getCompilationUnit();\n-        Tree leaf = path.getLeaf();\n-        if (t instanceof JCTree.JCCompilationUnit compilationUnit && leaf instanceof JCTree tree) {\n-            if (compilationUnit.docComments != null) {\n-                return compilationUnit.docComments.getCommentText(tree);\n-            }\n+        var compUnit = path.getCompilationUnit();\n+        var leaf = path.getLeaf();\n+        if (compUnit instanceof JCTree.JCCompilationUnit cu && leaf instanceof JCTree l\n+                && cu.docComments != null) {\n+            return cu.docComments.getCommentText(l);\n@@ -750,6 +755,5 @@\n-        CompilationUnitTree t = path.getCompilationUnit();\n-        Tree leaf = path.getLeaf();\n-        if (t instanceof JCTree.JCCompilationUnit compilationUnit && leaf instanceof JCTree tree) {\n-            if (compilationUnit.docComments != null) {\n-                return compilationUnit.docComments.getCommentTree(tree);\n-            }\n+        var compUnit = path.getCompilationUnit();\n+        var leaf = path.getLeaf();\n+        if (compUnit instanceof JCTree.JCCompilationUnit cu && leaf instanceof JCTree l\n+                && cu.docComments != null) {\n+            return cu.docComments.getCommentTree(l);\n@@ -993,11 +997,2 @@\n-    static JavaFileObject asJavaFileObject(FileObject fileObject) {\n-        JavaFileObject jfo = null;\n-\n-        if (fileObject instanceof JavaFileObject javaFileObject) {\n-            checkHtmlKind(fileObject, Kind.HTML);\n-            return javaFileObject;\n-        }\n-\n-        checkHtmlKind(fileObject);\n-        jfo = new HtmlFileObject(fileObject);\n-        return jfo;\n+    private static boolean isHtmlFile(FileObject fo) {\n+        return fo.getName().endsWith(\".html\");\n@@ -1006,2 +1001,2 @@\n-    private static void checkHtmlKind(FileObject fileObject) {\n-        checkHtmlKind(fileObject, BaseFileManager.getKind(fileObject.getName()));\n+    private static boolean isMarkdownFile(FileObject fo) {\n+        return fo.getName().endsWith(\".md\");\n@@ -1010,3 +1005,17 @@\n-    private static void checkHtmlKind(FileObject fileObject, JavaFileObject.Kind kind) {\n-        if (kind != JavaFileObject.Kind.HTML) {\n-            throw new IllegalArgumentException(\"HTML file expected:\" + fileObject.getName());\n+\n+    static JavaFileObject asDocFileObject(FileObject fo) {\n+        if (fo instanceof JavaFileObject jfo) {\n+            switch (jfo.getKind()) {\n+                case HTML -> {\n+                    return jfo;\n+                }\n+                case OTHER -> {\n+                    if (isMarkdownFile(jfo)) {\n+                        return jfo;\n+                    }\n+                }\n+            }\n+        } else {\n+            if (isHtmlFile(fo) || isMarkdownFile(fo)) {\n+                return new DocFileObject(fo);\n+            }\n@@ -1014,0 +1023,2 @@\n+\n+        throw new IllegalArgumentException((\"Not a documentation file: \" + fo.getName()));\n@@ -1016,1 +1027,1 @@\n-    private static class HtmlFileObject extends ForwardingFileObject<FileObject>\n+    private static class DocFileObject extends ForwardingFileObject<FileObject>\n@@ -1019,1 +1030,1 @@\n-        public HtmlFileObject(FileObject fileObject) {\n+        public DocFileObject(FileObject fileObject) {\n@@ -1046,1 +1057,1 @@\n-        JavaFileObject jfo = asJavaFileObject(fileObject);\n+        JavaFileObject jfo = asDocFileObject(fileObject);\n@@ -1074,1 +1085,3 @@\n-                throw new UnsupportedOperationException();\n+                return isHtmlFile(fileObject) ? CommentStyle.JAVADOC_BLOCK\n+                        : isMarkdownFile(fileObject) ? CommentStyle.JAVADOC_LINE\n+                        : null;\n@@ -1079,1 +1092,1 @@\n-                throw new UnsupportedOperationException();\n+                return false;\n@@ -1083,1 +1096,4 @@\n-        return new DocCommentParser(parser, diagSource, comment, true).parse();\n+        boolean isHtmlFile = jfo.getKind() == Kind.HTML;\n+\n+        var dct = new DocCommentParser(parserFactory, diagSource, comment, isHtmlFile).parse();\n+        return transform(dct);\n@@ -1088,1 +1104,1 @@\n-        JavaFileObject jfo = asJavaFileObject(fileObject);\n+        JavaFileObject jfo = asDocFileObject(fileObject);\n@@ -1106,0 +1122,97 @@\n+    \/**\n+     * {@return the doc comment tree for a given comment}\n+     *\n+     * @param diagSource the source containing the comment, used when displaying any diagnostics\n+     * @param c the comment\n+     *\/\n+    public DocCommentTree getDocCommentTree(DiagnosticSource diagSource, Comment c) {\n+        var dct = new DocCommentParser(parserFactory, diagSource, c).parse();\n+        return transform(dct);\n+    }\n+\n+    \/**\n+     * An interface for transforming a {@code DocCommentTree}.\n+     * It is primarily used as the service-provider interface for an implementation\n+     * that embodies the JDK extensions to CommonMark, such as reference links to\n+     * program elements.\n+     *\/\n+    public interface DocCommentTreeTransformer {\n+        \/**\n+         * The name used by the implementation that embodies the JDK extensions to CommonMark.\n+         *\/\n+        public final String STANDARD = \"standard\";\n+\n+        \/**\n+         * {@return the name of this transformer}\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Transforms a documentation comment tree.\n+         *\n+         * @param trees an instance of the {@link DocTrees} utility interface.\n+         * @param tree the tree to be transformed\n+         * @return the transformed tree\n+         *\/\n+        DocCommentTree transform(DocTrees trees, DocCommentTree tree);\n+    }\n+\n+    \/**\n+     * A class that provides the identity transform on instances of {@code DocCommentTree}.\n+     *\/\n+    public static class IdentityTransformer implements DocCommentTreeTransformer {\n+        @Override\n+        public String name() {\n+            return \"identity\";\n+        }\n+\n+        @Override\n+        public DocCommentTree transform(DocTrees trees, DocCommentTree tree) {\n+            return tree;\n+        }\n+    }\n+\n+    public DocCommentTreeTransformer getDocCommentTreeTransformer() {\n+        return docCommentTreeTransformer;\n+    }\n+\n+    public void setDocCommentTreeTransformer(DocCommentTreeTransformer transformer) {\n+        docCommentTreeTransformer = transformer;\n+    }\n+\n+    \/**\n+     * Initialize {@link #docCommentTreeTransformer} if it is {@code null},\n+     * using a service provider to look up an implementation with the name \"standard\".\n+     * If none is found, an identity transformer is used, with the name \"identity\".\n+     *\/\n+    public void initDocCommentTreeTransformer() {\n+        if (docCommentTreeTransformer == null) {\n+            var sl = ServiceLoader.load(DocCommentTreeTransformer.class);\n+            docCommentTreeTransformer = sl.stream()\n+                    .map(ServiceLoader.Provider::get)\n+                    .filter(t -> t.name().equals(DocCommentTreeTransformer.STANDARD))\n+                    .findFirst()\n+                    .orElseGet(() -> new IdentityTransformer());\n+        }\n+    }\n+\n+    \/**\n+     * Transforms the given tree using the current {@linkplain #getDocCommentTreeTransformer() transformer},\n+     * after ensuring it has been {@linkplain #initDocCommentTreeTransformer() initialized}.\n+     *\n+     * @param tree the tree\n+     * @return the transformed tree\n+     *\/\n+    private DocCommentTree transform(DocCommentTree tree) {\n+        initDocCommentTreeTransformer();\n+        return docCommentTreeTransformer.transform(this, tree);\n+    }\n+\n+    \/**\n+     * {@return the {@linkplain ParserFactory} parser factory}\n+     * The factory can be used to create a {@link ReferenceParser}, to parse link references.\n+     *\/\n+    public ParserFactory getParserFactory() {\n+        return parserFactory;\n+    }\n+\n@@ -1209,14 +1322,4 @@\n-            case ERROR:\n-                log.error(DiagnosticFlag.API, pos, Errors.ProcMessager(msg.toString()));\n-                break;\n-\n-            case WARNING:\n-                log.warning(pos, Warnings.ProcMessager(msg.toString()));\n-                break;\n-\n-            case MANDATORY_WARNING:\n-                log.mandatoryWarning(pos, Warnings.ProcMessager(msg.toString()));\n-                break;\n-\n-            default:\n-                log.note(pos, Notes.ProcMessager(msg.toString()));\n+                case ERROR ->             log.error(DiagnosticFlag.API, pos, Errors.ProcMessager(msg.toString()));\n+                case WARNING ->           log.warning(pos, Warnings.ProcMessager(msg.toString()));\n+                case MANDATORY_WARNING -> log.mandatoryWarning(pos, Warnings.ProcMessager(msg.toString()));\n+                default ->                log.note(pos, Notes.ProcMessager(msg.toString()));\n@@ -1272,0 +1375,5 @@\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public DocCommentKind getCommentKind(JCTree tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":176,"deletions":68,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,0 +214,1 @@\n+            case MODULE_IMPORTS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+        MODULE_IMPORTS(JDK23, Fragments.FeatureModuleImports, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1562,1 +1562,3 @@\n-                 * case we need to use the position to disambiguate\n+                 * case we need to use the position to disambiguate, but if we loaded the record from a class file\n+                 * all positions will be -1, in that case we have to ignore the position and match only based on the\n+                 * name\n@@ -1564,1 +1566,1 @@\n-                if (rc.name == var.name && var.pos == rc.pos) {\n+                if (rc.name == var.name && (var.pos == rc.pos || rc.pos == -1)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4750,0 +4750,4 @@\n+        \/\/ map to avoid visiting same type argument twice, like in Foo<T>.Bar<T>\n+        Map<Type, Type> argMap = new HashMap<>();\n+        \/\/ cycle detection within an argument, see JDK-8324809\n+        Set<Type> seen = new HashSet<>();\n@@ -4761,1 +4765,4 @@\n-                Type bound = visit(arg);\n+                Type bound = argMap.get(arg);\n+                if (bound == null) {\n+                    argMap.put(arg, bound = visit(arg));\n+                }\n@@ -4790,5 +4797,9 @@\n-            if (rewriteTypeVars) {\n-                Type bound = t.getUpperBound().contains(t) ?\n-                        erasure(t.getUpperBound()) :\n-                        visit(t.getUpperBound());\n-                return rewriteAsWildcardType(bound, t, EXTENDS);\n+            if (seen.add(t)) {\n+                if (rewriteTypeVars) {\n+                    Type bound = t.getUpperBound().contains(t) ?\n+                            erasure(t.getUpperBound()) :\n+                            visit(t.getUpperBound());\n+                    return rewriteAsWildcardType(bound, t, EXTENDS);\n+                } else {\n+                    return t;\n+                }\n@@ -4796,1 +4807,1 @@\n-                return t;\n+                return rewriteTypeVars ? makeExtendsWildcard(syms.objectType, t) : t;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4495,1 +4495,3 @@\n-        for (final JCImport imp : toplevel.getImports()) {\n+        for (final JCImportBase impBase : toplevel.getImports()) {\n+            if (!(impBase instanceof JCImport imp))\n+                continue;\n@@ -4519,2 +4521,3 @@\n-        OUTER: for (JCImport imp : toplevel.getImports()) {\n-            if (!imp.staticImport && TreeInfo.name(imp.qualid) == names.asterisk) {\n+        OUTER: for (JCImportBase impBase : toplevel.getImports()) {\n+            if (impBase instanceof JCImport imp && !imp.staticImport &&\n+                TreeInfo.name(imp.qualid) == names.asterisk) {\n@@ -4524,1 +4527,1 @@\n-                    log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));\n+                    log.error(DiagnosticFlag.RESOLVE_ERROR, imp.qualid.selected.pos(), Errors.DoesntExist(tsym));\n@@ -4914,1 +4917,0 @@\n-                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n@@ -4929,5 +4931,0 @@\n-                    \/\/ Domination can occur even when we have not an unconditional pair between case labels.\n-                    if (unconditionalFound && unconditionalCaseLabel != label) {\n-                        dominated = true;\n-                    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2991,1 +2991,1 @@\n-                    tree.expr.type,\n+                    types.erasure(tree.expr.type),\n@@ -2994,1 +2994,1 @@\n-                    .VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+                    .VarDef(dollar_s, instanceOfExpr);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -461,1 +461,3 @@\n-            cases = processCases(tree, newCases.toList());\n+            cases = newCases.toList();\n+            patchCompletingNormallyCases(cases);\n+            cases = processCases(tree, cases);\n@@ -526,2 +528,0 @@\n-            patchCompletingNormallyCases(cases);\n-\n@@ -688,1 +688,1 @@\n-                cases.tail.head.guard != null) {\n+                (cases.tail.head.guard != null || cases.tail.head.labels.stream().anyMatch(cl -> cl instanceof JCPatternCaseLabel p && p.syntheticGuard != null))) {\n@@ -703,0 +703,1 @@\n+                currentCase.completesNormally = false;\n@@ -951,0 +952,1 @@\n+        boolean previousCompletesNormally = false;\n@@ -955,0 +957,1 @@\n+            boolean currentCompletesNormally = c.head.completesNormally;\n@@ -989,0 +992,2 @@\n+                       !previousCompletesNormally &&\n+                       !currentCompletesNormally &&\n@@ -1004,0 +1009,1 @@\n+            previousCompletesNormally = currentCompletesNormally;\n@@ -1476,2 +1482,2 @@\n-                if (!e.getKey().isPreserved() ||\n-                    !parent.tryPrepend(e.getKey(), decl)) {\n+                if (!e.getValue().isUnnamedVariable() &&\n+                        (!e.getKey().isPreserved() || !parent.tryPrepend(e.getKey(), decl))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCModuleImport;\n@@ -413,0 +414,6 @@\n+    @Override\n+    public void visitModuleImport(JCModuleImport tree) {\n+        JCModuleImport that = (JCModuleImport) parameter;\n+        result = scan(tree.module, that.module);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import com.sun.tools.javac.code.Directive.ExportsDirective;\n+import com.sun.tools.javac.code.Directive.RequiresDirective;\n@@ -42,2 +44,0 @@\n-import com.sun.tools.javac.parser.Parser;\n-import com.sun.tools.javac.parser.ParserFactory;\n@@ -116,2 +116,0 @@\n-    private final ParserFactory parserFactory;\n-    private final Preview preview;\n@@ -145,2 +143,0 @@\n-        parserFactory = ParserFactory.instance(context);\n-        preview = Preview.instance(context);\n@@ -372,3 +368,1 @@\n-                for (JCImport imp : tree.getImports()) {\n-                    doImport(imp);\n-                }\n+                handleImports(tree.getImports());\n@@ -396,0 +390,10 @@\n+        private void handleImports(List<JCImportBase> imports) {\n+            for (JCImportBase imp : imports) {\n+                if (imp instanceof JCModuleImport mimp) {\n+                    doModuleImport(mimp);\n+                } else {\n+                    doImport((JCImport) imp);\n+                }\n+            }\n+        }\n+\n@@ -447,0 +451,51 @@\n+        private void doModuleImport(JCModuleImport tree) {\n+            Name moduleName = TreeInfo.fullName(tree.module);\n+            ModuleSymbol module = syms.getModule(moduleName);\n+\n+            if (module != null) {\n+                if (!env.toplevel.modle.readModules.contains(module)) {\n+                    if (env.toplevel.modle.isUnnamed()) {\n+                        log.error(tree.pos, Errors.ImportModuleDoesNotReadUnnamed(module));\n+                    } else {\n+                        log.error(tree.pos, Errors.ImportModuleDoesNotRead(env.toplevel.modle,\n+                                                                           module));\n+                    }\n+                    \/\/error recovery, make sure the module is completed:\n+                    module.getDirectives();\n+                }\n+\n+                List<ModuleSymbol> todo = List.of(module);\n+                Set<ModuleSymbol> seenModules = new HashSet<>();\n+\n+                while (!todo.isEmpty()) {\n+                    ModuleSymbol currentModule = todo.head;\n+\n+                    todo = todo.tail;\n+\n+                    if (!seenModules.add(currentModule)) {\n+                        continue;\n+                    }\n+\n+                    for (ExportsDirective export : currentModule.exports) {\n+                        if (export.modules != null && !export.modules.contains(env.toplevel.packge.modle)) {\n+                            continue;\n+                        }\n+\n+                        PackageSymbol pkg = export.getPackage();\n+                        JCImport nestedImport = make.at(tree.pos)\n+                                .Import(make.Select(make.QualIdent(pkg), names.asterisk), false);\n+\n+                        doImport(nestedImport);\n+                    }\n+\n+                    for (RequiresDirective requires : currentModule.requires) {\n+                        if (requires.isTransitive()) {\n+                            todo = todo.prepend(requires.module);\n+                        }\n+                    }\n+                }\n+            } else {\n+                log.error(tree.pos, Errors.ImportModuleNotFound(moduleName));\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":64,"deletions":9,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,0 +384,2 @@\n+    DISABLE_LINE_DOC_COMMENTS(\"--disable-line-doc-comments\", \"opt.lineDocComments\", EXTENDED, BASIC),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -64,0 +65,1 @@\n+import com.sun.tools.javac.tree.DocCommentTable;\n@@ -77,1 +79,0 @@\n-import com.sun.tools.javac.comp.Resolve.RecoveryLoadClass;\n@@ -436,0 +437,9 @@\n+        return getDocCommentItem(e, ((docCommentTable, tree) -> docCommentTable.getCommentText(tree)));\n+    }\n+\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    public DocCommentKind getDocCommentKind(Element e) {\n+        return getDocCommentItem(e, ((docCommentTable, tree) -> docCommentTable.getCommentKind(tree)));\n+    }\n+\n+    private <R> R getDocCommentItem(Element e, BiFunction<DocCommentTable, JCTree, R> f) {\n@@ -447,1 +457,1 @@\n-        return toplevel.docComments.getCommentText(tree);\n+        return f.apply(toplevel.docComments, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.ArrayList;\n@@ -31,0 +32,1 @@\n+import java.util.regex.Pattern;\n@@ -33,0 +35,1 @@\n+import com.sun.source.doctree.DocTree;\n@@ -79,1 +82,21 @@\n-    private enum Phase { PREAMBLE, BODY, POSTAMBLE }\n+    \/**\n+     * An indication of the part of documentation comment or file being read.\n+     * A documentation comment and a Markdown file just have a {@code BODY}.\n+     * An HTML file has a {@code PREAMBLE}, {@code BODY} and {@code POSTAMBLE}.\n+     * While parsing a {@code BODY}, text within {@code {@tag ... }} may be\n+     * read as {@code INLINE}.\n+     * One of the primary characteristics of each \"phase\" is the termination\n+     * condition, indicating when the current phase is complete, and either\n+     * the previous one resumed (in the case of {@code INLINE}) or the\n+     * next phase started.\n+     *\/\n+    private enum Phase {\n+        \/** The initial part of an HTML file up to and including the {@code body} and possible {@code <main>} tag. *\/\n+        PREAMBLE,\n+        \/** The initial part of a doc comment, or the rich-text content of a block tag. *\/\n+        BODY,\n+        \/** The end of an HTML file, from and including the {@code <\/main>} or {@code <\/body>} tag. *\/\n+        POSTAMBLE,\n+        \/** The rich-text content of an inline documentation comment tag. *\/\n+        INLINE\n+    }\n@@ -87,1 +110,3 @@\n-    private final boolean isFileContent;\n+    private final boolean isHtmlFile;\n+    private final DocTree.Kind textKind;\n+    private final Markdown markdown;\n@@ -106,0 +131,25 @@\n+    \/**\n+     * Creates a parser for a documentation comment.\n+     *\n+     * @param fac a parser factory, for a doc-tree maker and for reference parsers\n+     * @param diagSource the source in which the comment was found\n+     * @param comment the comment\n+     *\/\n+    public DocCommentParser(ParserFactory fac, DiagnosticSource diagSource, Comment comment) {\n+        this(fac, diagSource, comment, false);\n+    }\n+\n+    \/**\n+     * Creates a parser for a documentation comment.\n+     *\n+     * If the comment is the content of a standalone HTML file, it will be parsed\n+     * in three parts: a preamble (up to and including the {@code <main>} tag,\n+     * or {@code <body>} tag if there is no {@code <main>} tag, then the main content\n+     * of the file, and then finally the end part of the file starting at the\n+     * end tag matching the tag that ended the preamble.\n+     *\n+     * @param fac a parser factory, for a doc-tree maker and for reference parsers\n+     * @param diagSource the source in which the comment was found\n+     * @param comment the comment\n+     * @param isHtmlFile whether the comment is the entire content of an HTML file\n+     *\/\n@@ -107,1 +157,1 @@\n-                            Comment comment, boolean isFileContent) {\n+                            Comment comment, boolean isHtmlFile) {\n@@ -113,1 +163,2 @@\n-        this.isFileContent = isFileContent;\n+        this.isHtmlFile = isHtmlFile;\n+        textKind = isHtmlFile ? DocTree.Kind.TEXT : getTextKind(comment);\n@@ -116,0 +167,1 @@\n+        markdown = textKind == DocTree.Kind.MARKDOWN ? new Markdown() : null;\n@@ -118,2 +170,6 @@\n-    public DocCommentParser(ParserFactory fac, DiagnosticSource diagSource, Comment comment) {\n-        this(fac, diagSource, comment, false);\n+    private static DocTree.Kind getTextKind(Comment c) {\n+        return switch (c.getStyle()) {\n+            case JAVADOC_BLOCK -> DocTree.Kind.TEXT;\n+            case JAVADOC_LINE -> DocTree.Kind.MARKDOWN;\n+            default -> throw new IllegalArgumentException(c.getStyle().name());\n+        };\n@@ -122,0 +178,26 @@\n+    \/**\n+     * {@return the result of parsing the content given to the constructor}\n+     *\n+     * The parsing rules for \"traditional\" documentation comments are generally incompatible\n+     * with the rules for parsing CommonMark Markdown: traditional comments are parsed\n+     * with a simple recursive-descent parser, while CommonMark is parsed in two \"phases\":\n+     * first identifying blocks, and then subsequently parsing the content of those blocks.\n+     * The conflict shows up most with the rules for inline tags, some of which may contain\n+     * almost arbitrary content, including blank lines in particular.\n+     *\n+     * We do not want to build and maintain a fully-compliant Markdown parser, nor\n+     * can we leverage an existing Markdown parser, such as in commonmark-java,\n+     * which cannot handle arbitrary content in \"inline\" constructs, or the recursive\n+     * nature of some inline tags.\n+     *\n+     * The solution is a compromise. First, we identify inline and block tags,\n+     * so that they may be treated as opaque objects when subsequently using a\n+     * library (such as commonmark-java) to process the enclosing parts of the\n+     * comment. The catch is that while we do not need to provide a full Markdown\n+     * parser, we do need to parse it enough to recognize character sequences of\n+     * literal code (that is, code spans and code blocks), which should not be\n+     * scanned for inline and block tags. Most of this work is handled by the\n+     * nested {@link Markdown} class.\n+     *\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#blocks-and-inlines\">Blocks and Inlines<\/a>\n+     *\/\n@@ -131,2 +213,2 @@\n-        List<DCTree> preamble = isFileContent ? blockContent(Phase.PREAMBLE) : List.nil();\n-        List<DCTree> body = blockContent(Phase.BODY);\n+        List<DCTree> preamble = isHtmlFile ? content(Phase.PREAMBLE) : List.nil();\n+        List<DCTree> body = content(Phase.BODY);\n@@ -134,1 +216,1 @@\n-        List<DCTree> postamble = isFileContent ? blockContent(Phase.POSTAMBLE) : List.nil();\n+        List<DCTree> postamble = isHtmlFile ? content(Phase.POSTAMBLE) : List.nil();\n@@ -136,1 +218,2 @@\n-        int pos = !preamble.isEmpty() ? preamble.head.pos\n+        int pos = textKind == DocTree.Kind.MARKDOWN ? 0\n+                : !preamble.isEmpty() ? preamble.head.pos\n@@ -148,1 +231,11 @@\n-            case '\\f', '\\n', '\\r' -> newline = true;\n+            case '\\n' -> {\n+                newline = true;\n+            }\n+\n+            case '\\r' -> {\n+                if (bp + 1 < buflen && buf[bp + 1] == '\\n') {\n+                    bp++;\n+                    ch = '\\n';\n+                }\n+                newline = true;\n+            }\n@@ -157,1 +250,11 @@\n-        return blockContent(Phase.BODY);\n+        \/\/ The whitespace after a tag name is typically problematic:\n+        \/\/ should it be included in the content or not?\n+        \/\/ The problem is made worse by Markdown, in which leading\n+        \/\/ whitespace in Markdown content may be significant.\n+        \/\/ While generally in traditional comments, whitespace\n+        \/\/ after a tag name is skipped, to allow for Markdown we just\n+        \/\/ skip horizontal whitespace.\n+        while (isHorizontalWhitespace(ch) && bp < buflen) {\n+            nextChar();\n+        }\n+        return content(Phase.BODY);\n@@ -161,3 +264,17 @@\n-     * Read block content, consisting of text, html and inline tags.\n-     * Terminated by the end of input, or the beginning of the next block tag:\n-     * that is, @ as the first non-whitespace character on a line.\n+     * Reads \"rich text\" content, consisting of text, html and inline tags,\n+     * according to the given {@code phase}.\n+     *\n+     * Inline tags are only recognized in {@code BODY} and {@code INLINE}\n+     * phases, and not in {@code PREAMBLE} and {@code POSTAMBLE} phases.\n+     *\n+     * The end of the content is dependent on the phase:\n+     *\n+     * <ul>\n+     * <li>{@code PREAMBLE}: the appearance of {@code <body>} (or {@code <main>}),\n+     *      as determined by {@link #isEndPreamble()}\n+     * <li>{@code BODY}: the beginning of a block tag, or when reading from\n+     *      an HTML file, the appearance of {@code <\/main>} (or {@code <\/body>},\n+     *      as determined by {@link #isEndBody()}\n+     * <li>{@code INLINE}: '}', after skipping any matching {@code { }}\n+     * <li>{@code PREAMBLE}: end of file\n+     * <\/ul>\n@@ -165,2 +282,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    protected List<DCTree> blockContent(Phase phase) {\n+    protected List<DCTree> content(Phase phase) {\n@@ -170,0 +286,3 @@\n+        int depth = 1;                  \/\/ only used when phase is INLINE\n+        int pos = bp;                   \/\/ only used when phase is INLINE\n+\n@@ -173,2 +292,14 @@\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n+                case '\\n', '\\r' -> {\n+                    nextChar();\n+                    if (textKind == DocTree.Kind.MARKDOWN) {\n+                        markdown.update();\n+                        if (markdown.isIndentedCodeBlock()) {\n+                            markdown.skipLine();\n+                        }\n+                    }\n+                }\n+\n+                case ' ', '\\t' -> {\n+                    if (textKind == DocTree.Kind.MARKDOWN && textStart == -1) {\n+                        textStart = bp;\n+                    }\n@@ -176,1 +307,1 @@\n-                    break;\n+                }\n@@ -178,3 +309,0 @@\n-                case '&':\n-                    entity(trees);\n-                    break;\n@@ -182,10 +310,28 @@\n-                case '<':\n-                    newline = false;\n-                    if (isFileContent) {\n-                        switch (phase) {\n-                            case PREAMBLE -> {\n-                                if (isEndPreamble()) {\n-                                    trees.add(html());\n-                                    if (textStart == -1) {\n-                                        textStart = bp;\n-                                        lastNonWhite = -1;\n+                case '&' -> {\n+                    switch (textKind) {\n+                        case MARKDOWN -> defaultContentCharacter();\n+                        case TEXT -> entity(trees);\n+                        default -> throw unknownTextKind(textKind);\n+                    }\n+                }\n+\n+                case '<' -> {\n+                    switch (textKind) {\n+                        case MARKDOWN -> {\n+                            defaultContentCharacter();\n+                        }\n+                        case TEXT -> {\n+                            newline = false;\n+                            if (isHtmlFile) {\n+                                switch (phase) {\n+                                    case PREAMBLE -> {\n+                                        if (isEndPreamble()) {\n+                                            trees.add(html());\n+                                            if (textStart == -1) {\n+                                                textStart = bp;\n+                                                lastNonWhite = -1;\n+                                            }\n+                                            \/\/ mark this as the start, for processing purposes\n+                                            newline = true;\n+                                            break loop;\n+                                        }\n@@ -193,9 +339,7 @@\n-                                    \/\/ mark this as the start, for processing purposes\n-                                    newline = true;\n-                                    break loop;\n-                                }\n-                            }\n-                            case BODY -> {\n-                                if (isEndBody()) {\n-                                    addPendingText(trees, lastNonWhite);\n-                                    break loop;\n+                                    case BODY -> {\n+                                        if (isEndBody()) {\n+                                            addPendingText(trees, lastNonWhite);\n+                                            break loop;\n+                                        }\n+                                    }\n+                                    default -> { }\n@@ -204,0 +348,2 @@\n+                            addPendingText(trees, bp - 1);\n+                            trees.add(html());\n@@ -205,1 +351,7 @@\n-                            default -> { }\n+                            if (phase == Phase.PREAMBLE || phase == Phase.POSTAMBLE) {\n+                                break; \/\/ Ignore newlines after html tags, in the meta content\n+                            }\n+                            if (textStart == -1) {\n+                                textStart = bp;\n+                                lastNonWhite = -1;\n+                            }\n@@ -207,0 +359,1 @@\n+                        default -> throw unknownTextKind(textKind);\n@@ -208,2 +361,1 @@\n-                    addPendingText(trees, bp - 1);\n-                    trees.add(html());\n+                }\n@@ -211,6 +363,9 @@\n-                    if (phase == Phase.PREAMBLE || phase == Phase.POSTAMBLE) {\n-                        break; \/\/ Ignore newlines after html tags, in the meta content\n-                    }\n-                    if (textStart == -1) {\n-                        textStart = bp;\n-                        lastNonWhite = -1;\n+                case '{' -> {\n+                    switch (phase) {\n+                        case PREAMBLE, POSTAMBLE -> defaultContentCharacter();\n+                        case BODY -> inlineTag(trees);\n+                        case INLINE -> {\n+                            if (!inlineTag(trees)) {\n+                                depth++;\n+                            }\n+                        }\n@@ -218,1 +373,1 @@\n-                    break;\n+                }\n@@ -220,3 +375,13 @@\n-                case '{':\n-                    inlineTag(trees);\n-                    break;\n+                case '}' -> {\n+                    if (phase == Phase.INLINE) {\n+                        newline = false;\n+                        if (--depth == 0) {\n+                            addPendingText(trees, bp - 1);\n+                            nextChar();\n+                            return trees.toList();\n+                        }\n+                        nextChar();\n+                    } else {\n+                        defaultContentCharacter();\n+                    }\n+                }\n@@ -224,1 +389,1 @@\n-                case '@':\n+                case '@' -> {\n@@ -239,1 +404,1 @@\n-                        } else {\n+                        } else if (phase == Phase.BODY) {\n@@ -252,1 +417,2 @@\n-                    \/\/ fallthrough\n+                    defaultContentCharacter();\n+                }\n@@ -254,6 +420,52 @@\n-                default:\n-                    newline = false;\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    lastNonWhite = bp;\n-                    nextChar();\n+                case '\\\\' -> {\n+                    switch (textKind) {\n+                        case MARKDOWN -> {\n+                            defaultContentCharacter();\n+                            nextChar();\n+                            defaultContentCharacter();\n+                        }\n+                        case TEXT -> {\n+                            defaultContentCharacter();\n+                        }\n+                    }\n+                }\n+\n+                case '`', '~' -> {\n+                    switch (textKind) {\n+                        case MARKDOWN -> {\n+                            newline = false;\n+                            if (textStart == -1) {\n+                                textStart = bp;\n+                            }\n+                            lastNonWhite = bp;\n+                            var saveNewline = newline;\n+                            var isCodeFence = markdown.isCodeFence();\n+                            if (ch == '`' || ch == '~' && isCodeFence) {\n+                                int end = markdown.skipCode();\n+                                if (end == -1) {\n+                                    \/\/ if a match for the opening sequence of characters was not found:\n+                                    \/\/ - if the characters were a fence, the code block extends to the end of file\n+                                    \/\/ - if the characters were inline, the opening characters are treated literally\n+                                    if (isCodeFence) {\n+                                        lastNonWhite = buflen - 1;\n+                                    } else {\n+                                        bp = lastNonWhite;\n+                                        newline = saveNewline;\n+                                        nextChar();\n+                                    }\n+                                } else {\n+                                    lastNonWhite = end - 1;\n+                                }\n+                            } else {\n+                                nextChar();\n+                            }\n+                        }\n+                        case TEXT -> {\n+                            defaultContentCharacter();\n+                        }\n+                    }\n+                }\n+\n+                default -> {\n+                    defaultContentCharacter();\n+                }\n@@ -266,1 +478,15 @@\n-        return trees.toList();\n+        return (phase == Phase.INLINE)\n+                ? List.of(erroneous(\"dc.unterminated.inline.tag\", pos))\n+                : trees.toList();\n+    }\n+\n+    void defaultContentCharacter() {\n+        newline = false;\n+        if (textStart == -1)\n+            textStart = bp;\n+        lastNonWhite = bp;\n+        nextChar();\n+    }\n+\n+    private IllegalStateException unknownTextKind(DocTree.Kind textKind) {\n+        return new IllegalStateException(textKind.toString());\n@@ -315,1 +541,34 @@\n-    protected void inlineTag(ListBuffer<DCTree> list) {\n+    \/\/ unused, but useful when debugging\n+    private String showPos(int p) {\n+        var sb = new StringBuilder();\n+        sb.append(\"[\").append(p).append(\"] \");\n+        if (p >= 0) {\n+            for (int i = Math.max(p - 10, 0); i < Math.min(p + 10, buflen); i++) {\n+                if (i == p) sb.append(\"[\");\n+                var c = buf[i];\n+                sb.append(switch (c) {\n+                    case '\\n' -> '|';\n+                    case ' ' -> '_';\n+                    default -> c;\n+                });\n+                if (i == p) sb.append(\"]\");\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Reads a possible inline tag, after finding an opening brace <code>{<\/code> character.\n+     *\n+     * If the next character is {@code @}, an opening tag is read and added to the\n+     * given {@code list}, and the result is {@code true}.\n+     *\n+     * Otherwise, the {@code list} is updated with the characters that have been read,\n+     * and the result is {@code false}. The result also indicates that a single\n+     * opening brace was read, and that a corresponding closing brace should eventually\n+     * be read.\n+     *\n+     * @param list the list of trees being accumulated\n+     * @return {@code true} if an inline tag was read, and {@code false} otherwise\n+     *\/\n+    protected boolean inlineTag(ListBuffer<DCTree> list) {\n@@ -336,0 +595,1 @@\n+                return true;\n@@ -342,0 +602,1 @@\n+        return false;\n@@ -589,1 +850,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -591,2 +851,0 @@\n-        ListBuffer<DCTree> trees = new ListBuffer<>();\n-\n@@ -594,86 +852,1 @@\n-        int pos = bp;\n-        int depth = 1;\n-        textStart = -1;\n-\n-        loop:\n-        while (bp < buflen) {\n-\n-            switch (ch) {\n-                case '\\n': case '\\r': case '\\f':\n-                case ' ': case '\\t':\n-                    nextChar();\n-                    break;\n-\n-                case '&':\n-                    entity(trees);\n-                    break;\n-\n-                case '<':\n-                    newline = false;\n-                    addPendingText(trees, bp - 1);\n-                    trees.add(html());\n-                    textStart = bp;\n-                    lastNonWhite = -1;\n-                    break;\n-\n-                case '{':\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    newline = false;\n-                    nextChar();\n-                    if (ch == '@') {\n-                        addPendingText(trees, bp - 2);\n-                        trees.add(inlineTag());\n-                        textStart = bp;\n-                        lastNonWhite = -1;\n-                    } else {\n-                        depth++;\n-                    }\n-                    break;\n-\n-                case '}':\n-                    newline = false;\n-                    if (--depth == 0) {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        return trees.toList();\n-                    }\n-                    nextChar();\n-                    break;\n-\n-                case '@':\n-                    \/\/ check for context-sensitive escape sequences:\n-                    \/\/   newline whitespace @@\n-                    \/\/   newline whitespace @*\n-                    \/\/   *@\/\n-                    if (newline) {\n-                        char peek = peekChar();\n-                        if (peek == '@' || peek == '*') {\n-                            addPendingText(trees, bp - 1);\n-                            nextChar();\n-                            trees.add(m.at(bp - 1).newEscapeTree(ch));\n-                            newline = false;\n-                            nextChar();\n-                            textStart = bp;\n-                            break;\n-                        }\n-                    } else if (textStart != -1 && buf[bp - 1] == '*' && peekChar() == '\/') {\n-                        addPendingText(trees, bp - 1);\n-                        nextChar();\n-                        trees.add(m.at(bp - 1).newEscapeTree('\/'));\n-                        newline = false;\n-                        nextChar();\n-                        textStart = bp;\n-                        break;\n-                    }\n-                    \/\/ fallthrough\n-\n-                default:\n-                    if (textStart == -1)\n-                        textStart = bp;\n-                    nextChar();\n-                    break;\n-            }\n-        }\n-\n-        return List.of(erroneous(\"dc.unterminated.inline.tag\", pos));\n+        return content(Phase.INLINE);\n@@ -848,2 +1021,9 @@\n-     * Read the start or end of an HTML tag, or an HTML comment\n-     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     * Reads an HTML construct, beginning with {@code <}.\n+     *\n+     * <ul>\n+     * <li>start element: {@code <identifier attrs> }\n+     * <li>end element: {@code <\/identifier> }\n+     * <li>comment: {@code <!-- ... -->}\n+     * <li>doctype: {@code <!doctype ... >}\n+     * <li>cdata: {@code <![CDATA[ ... ]]>}\n+     * <\/ul>\n@@ -986,1 +1166,1 @@\n-                    addPendingText(v, bp - 1);\n+                    addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -994,1 +1174,1 @@\n-                    addPendingText(v, bp - 1);\n+                    addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -1015,0 +1195,4 @@\n+        addPendingText(list, textEnd, textKind);\n+    }\n+\n+    protected void addPendingText(ListBuffer<DCTree> list, int textEnd, DocTree.Kind kind) {\n@@ -1017,1 +1201,8 @@\n-                list.add(m.at(textStart).newTextTree(newString(textStart, textEnd + 1)));\n+                switch (kind) {\n+                    case TEXT ->\n+                            list.add(m.at(textStart).newTextTree(newString(textStart, textEnd + 1)));\n+                    case MARKDOWN ->\n+                            list.add(m.at(textStart).newRawTextTree(DocTree.Kind.MARKDOWN, newString(textStart, textEnd + 1)));\n+                    default ->\n+                        throw new IllegalArgumentException(kind.toString());\n+                }\n@@ -1127,0 +1318,450 @@\n+    \/**\n+     * A class to encapsulate the work to parse Markdown enough to\n+     * detect the boundaries of character sequences of literal text,\n+     * and to skip over such sequences, without analyzing the content.\n+     *\n+     * The primary factors are:\n+     *   - the content of the current line, including its indentation\n+     *   - the currently open set of container blocks, and any leaf block\n+     *   - a serial number that is incremented when a line is encountered\n+     *     that is not a continuation of the previous block.\n+     *\n+     * There are some limitations when using code blocks containing\n+     * strings that resemble tags, which should be treated as literal text.\n+     * In particular, list items are parsed individually and not as\n+     * part of an overall group of list items. This means that the\n+     * indentation is determined _for each item_, and not for the group\n+     * as a whole. This in turn implies that a list item cannot begin\n+     * with an indented code block. The workaround is to use a fenced code\n+     * block. It is also recommended, as a matter of style, that all\n+     * list items should use the same relative indentation for their content.\n+     *\n+     * The restrictions only apply when indented code blocks contain\n+     * strings resembling tags.\n+     *\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/\">CommonMark spec<\/a>\n+     *\/\n+    class Markdown {\n+        \/\/ Container blocks may nested contained blocks and leaf blocks.\n+        \/\/ Note, the code does not model lists, which would require\n+        \/\/ arbitrary multi-line lookahead.\n+        \/\/ https:\/\/spec.commonmark.org\/0.30\/#container-blocks\n+        private enum ContainerBlockKind {\n+            LIST_ITEM, QUOTE\n+        }\n+\n+        \/**\n+         * Details about a currently open container block.\n+         * @param blockKind the kind of block\n+         * @param indent the indentation for the block's content, for list items\n+         *\/\n+        private record BlockInfo(ContainerBlockKind blockKind, int indent) { }\n+\n+        \/**\n+         * A list of the currently open container blocks.\n+         *\/\n+        private final java.util.List<BlockInfo> containers = new ArrayList<>();\n+\n+\n+        \/\/ Except for NONE, leaf blocks contain \"textual\" content.\n+        \/\/ Single-line leaf blocks, like ATX headings and thematic breaks are all represented by NONE.\n+        \/\/ See https:\/\/spec.commonmark.org\/0.30\/#leaf-blocks\n+        private enum LeafBlockKind {\n+            NONE, PARAGRAPH, FENCED_CODE, INDENTED_CODE\n+        }\n+\n+        private LeafBlockKind leafKind = LeafBlockKind.NONE;\n+\n+        \/**\n+         * A serial number for the current \"block\".\n+         * It is updated whenever a line is encountered that indicates\n+         * the beginning of a new block, such that any potential code span\n+         * should be terminated as \"not a span\".\n+         *\/\n+        private int blockId = 0;\n+\n+        \/**\n+         * Updates the state after a newline has been read.\n+         * There are two primary goals.\n+         *\n+         * 1. Determine any change to the current list of container blocks\n+         * 2. Determine if the current line is part of a code block\n+         *\/\n+        void update() {\n+            var prevLeafKind = leafKind;\n+            int indent = readIndent(0);\n+\n+            final var line = peekLine();\n+            var peekIndex = 0;  \/\/ index into `line`; note it does not include `indent`\n+            var blockIndex = 0; \/\/ index into `blocks`\n+\n+            \/\/ Iterate examining the beginning of the line, left to right,\n+            \/\/ comparing indications of containers (indentation or markers)\n+            \/\/ against the list of currently open container blocks.\n+            \/\/ Side effects may open nested blocks or close existing ones.\n+            while (true) {\n+                if (blockIndex == containers.size()) {\n+                    \/\/ check for an open code block\n+                    if (prevLeafKind == LeafBlockKind.FENCED_CODE) {\n+                        return;\n+                    } else {\n+                        var codeIndent = (containers.isEmpty() ? 0 : containers.getLast().indent) + 4;\n+                        if (indent >= codeIndent && prevLeafKind != LeafBlockKind.PARAGRAPH) {\n+                            leafKind = LeafBlockKind.INDENTED_CODE;\n+                            if (leafKind != prevLeafKind) {\n+                                blockId++;\n+                            }\n+                            return;\n+                        }\n+                    }\n+                    \/\/ examine the remaining part of the lne\n+                    var peekLineKind = getLineKind(line.substring(peekIndex));\n+                    switch (peekLineKind) {\n+                        case BULLETED_LIST_ITEM, ORDERED_LIST_ITEM -> {\n+                            var count = indent;\n+                            \/\/ skip over the list marker\n+                            while (ch != ' ' && ch != '\\t') {\n+                                count++;\n+                                nextChar();\n+                            }\n+                            var listItemIndent = readIndent(count);\n+                            containers.add(new BlockInfo(ContainerBlockKind.LIST_ITEM, listItemIndent));\n+                            blockIndex++;\n+                            peekIndex = listItemIndent - indent;\n+                            blockId++;\n+                        }\n+\n+                        case BLOCK_QUOTE -> {\n+                            containers.add(new BlockInfo(ContainerBlockKind.QUOTE,  indent + 1));\n+                            blockIndex++;\n+                            peekIndex += 1;\n+                            blockId++;\n+                        }\n+\n+                        case OTHER -> {\n+                            leafKind = LeafBlockKind.PARAGRAPH;\n+                            return;\n+                        }\n+\n+                        case ATX_HEADER, SETEXT_UNDERLINE, THEMATIC_BREAK, BLANK -> {\n+                            leafKind = LeafBlockKind.NONE;\n+                            blockId++;\n+                            return;\n+                        }\n+\n+                        case CODE_FENCE -> {\n+                            leafKind = LeafBlockKind.FENCED_CODE;\n+                            blockId++;\n+                            return;\n+                        }\n+                    }\n+                } else {\n+                    var block = containers.get(blockIndex);\n+                    var blockKind = block.blockKind;\n+                    switch (blockKind) {\n+                        case LIST_ITEM -> {\n+                            if (indent >= block.indent) {\n+                                blockIndex++;\n+                            } else {\n+                                var peekLineKind = getLineKind(line.substring(peekIndex));\n+                                if (peekLineKind == LineKind.BLANK) {\n+                                    \/\/ blank lines are considered to be part of a list item\n+                                    blockIndex++;\n+                                } else if (peekLineKind == LineKind.OTHER && prevLeafKind == LeafBlockKind.PARAGRAPH) {\n+                                    \/\/ lazy continuation line: leaf kind and id are unchanged\n+                                    return;\n+                                } else {\n+                                    closeContainer(blockIndex);\n+                                    blockId++;\n+                                }\n+                            }\n+                        }\n+\n+                        case QUOTE -> {\n+                            var peekLineKind = getLineKind(line.substring(peekIndex));\n+                            if (peekLineKind == LineKind.BLOCK_QUOTE) {\n+                                blockIndex++;\n+                                peekIndex++;\n+                            } else if (peekLineKind == LineKind.OTHER && prevLeafKind == LeafBlockKind.PARAGRAPH) {\n+                                \/\/ lazy continuation line: leaf kind and id are unchanged\n+                                return;\n+                            } else {\n+                                closeContainer(blockIndex);\n+                                blockId++;\n+                            }\n+                        }\n+\n+                        default -> throw new IllegalStateException(blockKind.toString());\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * {@return {@code true} if the current line is part of an indented code block,\n+         *          and {@code false} otherwise}\n+         * Indented code blocks should be treated as literal text and not scanned for tags.\n+         *\/\n+        boolean isIndentedCodeBlock() {\n+            return leafKind == LeafBlockKind.INDENTED_CODE;\n+        }\n+\n+        \/**\n+         * {@return {@code true} if the current line is part of a fenced code block,\n+         *          and {@code false} otherwise}\n+         * Code fences are used to surround content that should be treated as literal text\n+         * and not scanned for tags.\n+         *\/\n+        boolean isCodeFence() {\n+            return leafKind == LeafBlockKind.FENCED_CODE;\n+        }\n+\n+        \/**\n+         * Closes a given container block, and any open nested blocks.\n+         *\n+         * @param index the index of the block to be closed\n+         *\/\n+        private void closeContainer(int index) {\n+            containers.subList(index, containers.size()).clear();\n+        }\n+\n+        \/**\n+         * Skips the content of the current line.\n+         *\/\n+        void skipLine() {\n+            while (bp < buflen) {\n+                if (ch == '\\n' || ch == '\\r') {\n+                    return;\n+                }\n+                nextChar();\n+            }\n+        }\n+\n+        \/**\n+         * Skips literal content.\n+         *\n+         * The ending delimiter is a function of the repetition count of the current\n+         * character, and whether this is fenced content or not.\n+         *\n+         * In fenced content, the ending delimiter must appear at the start of a line;\n+         * the code block may also be terminated implicitly by the end of a containing block.\n+         *\n+         * In other content, the scan may be terminated if the blockId changes,\n+         * meaning the ending delimiter was not found before the block ended.\n+         *\n+         * @return the current position, or {@code -1} to indicate that the ending\n+         *         delimiter was not found\n+         *\/\n+        int skipCode() {\n+            char term = ch;\n+            var count = count(term);\n+            var initialLeafKind = leafKind;\n+            var isFenced = (leafKind == LeafBlockKind.FENCED_CODE);\n+            var initialBlockId = blockId;\n+            while (bp < buflen) {\n+                switch (ch) {\n+                    case '\\n', '\\r' -> {\n+                        nextChar();\n+                        update();\n+                        if (isFenced) {\n+                            if (leafKind == LeafBlockKind.FENCED_CODE && ch == term && count(ch) >= count\n+                                    || blockId != initialBlockId) {\n+                                leafKind = LeafBlockKind.NONE;\n+                                return bp;\n+                            }\n+                        } else {\n+                            if (blockId != initialBlockId) {\n+                                return -1;\n+                            }\n+                        }\n+                    }\n+\n+                    default -> {\n+                        if (ch == term && initialLeafKind != LeafBlockKind.FENCED_CODE ) {\n+                            if (count(ch) == count) {\n+                                return bp;\n+                            }\n+                        }\n+                        nextChar();\n+                    }\n+                }\n+            }\n+            \/\/ found end of input\n+            return -1;\n+        }\n+\n+        \/**\n+         * Reads spaces and tabs, expanding tabs as if they were replaced by spaces\n+         * with a tab stop of 4 characters.\n+         *\n+         * @param initialCount the initial indentation\n+         * @return the indentation after skipping spaces and tabs\n+         *\/\n+        private int readIndent(int initialCount) {\n+            final int TABSTOP = 4;\n+            int indent = initialCount;\n+            while (bp < buflen) {\n+                switch (ch) {\n+                    case ' ' -> indent++;\n+                    case '\\t' -> indent += TABSTOP - indent % TABSTOP;\n+                    default -> {\n+                        return indent;\n+                    }\n+                }\n+                nextChar();\n+            }\n+            return indent;\n+        }\n+\n+        \/**\n+         * Matches a string against an ordered series of regular expressions,\n+         * to determine the \"kind\" of the string.\n+         *\n+         * @return the \"kind\" of the line\n+         *\/\n+        private LineKind getLineKind(String s) {\n+            if (s.isBlank()) {\n+                return LineKind.BLANK;\n+            }\n+\n+            switch (s.charAt(0)) {\n+                case '#', '=', '-', '+', '*', '_', '`', '~', '>',\n+                        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> {\n+                    for (LineKind lk : LineKind.values()) {\n+                        if (lk.pattern.matcher(s).matches()) {\n+                            return lk;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return LineKind.OTHER;\n+        }\n+\n+        \/**\n+         * {@return a string obtained by peeking ahead at the current line}\n+         * The current position is unchanged.\n+         *\/\n+        private String peekLine() {\n+            int p = bp;\n+            while (p < buflen) {\n+                switch (buf[p]) {\n+                    case '\\n', '\\r' -> {\n+                        return newString(bp, p);\n+                    }\n+                    default -> p++;\n+                }\n+            }\n+            return newString(bp, buflen);\n+        }\n+\n+        \/**\n+         * {@return the number of consecutive occurrences of the given character}\n+         *\n+         * @param c the character\n+         *\/\n+        private int count(char c) {\n+            int n = 1;\n+            nextChar();\n+            while (bp < buflen && ch == c) {\n+                n++;\n+                nextChar();\n+            }\n+            return n;\n+        }\n+\n+        \/\/ unused, but useful when debugging\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName()\n+                    + \"[containers:\" + containers\n+                    + \", leafKind:\" + leafKind\n+                    + \", blockId:\" + blockId\n+                    + \"]\";\n+        }\n+    }\n+\n+    \/**\n+     * The kinds of line, used when reading a Markdown documentation comment.\n+     * The values are loosely ordered by a combination of the specificity of\n+     * the associated pattern, and the likelihood of use in a doc comment.\n+     *\n+     * Note that some of the patterns overlap, such as SETEXT_UNDERLINE and\n+     * THEMATIC_BREAK. The CommonMark spec resolves the ambiguities with\n+     * priority rules, such as the following:\n+     *\n+     * * If a line of dashes that meets the above conditions for being a\n+     *   thematic break could also be interpreted as the underline of a\n+     *   setext heading, the interpretation as a setext heading takes precedence.\n+     *\n+     * * When both a thematic break and a list item are possible interpretations\n+     *   of a line, the thematic break takes precedence.\n+     *\n+     * Here in this context, the primary purpose of these kinds is to help\n+     * determine when a block boundary terminates literal text, such as a\n+     * code span, and so the exact nature of the line kind does not matter.\n+     *\/\n+    \/\/ This class is only used within the Markdown class, and could be\n+    \/\/ a private nested class there.\n+    enum LineKind {\n+        BLANK(Pattern.compile(\"[ \\t]*\")),\n+\n+        \/**\n+         * ATX header: starts with 1 to 6 # characters, followed by space or tab or end of line.\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#atx-headings\">ATX Headings<\/a>\n+         *\/\n+        ATX_HEADER(Pattern.compile(\"#{1,6}([ \\t].*|$)\")),\n+\n+        \/**\n+         * Setext header: underline is sequence of = or - followed by optional spaces and tabs.\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#setext-headings\">Setext Headings<\/a>\n+         *\/\n+        SETEXT_UNDERLINE(Pattern.compile(\"(=+|-+)[ \\t]*\")),\n+\n+        \/**\n+         * Thematic break: a line of * - _ interspersed with optional spaces and tabs\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#thematic-breaks\">Thematic Break<\/a>\n+         *\/\n+        THEMATIC_BREAK(Pattern.compile(\"((\\\\*[ \\t]*+){3,})|((-[ \\t]*+){3,})|((_[ \\t]*+){3,})\")),\n+\n+        \/**\n+         * Code fence: 3 or more back ticks or tildes; back tick fence cannot have back ticks\n+         * in the info string.\n+         * Note potential conflict with strikeout for similar reasons if strikeout is supported.\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#code-fence\">Code Fence<\/a>\n+         *\/\n+        CODE_FENCE(Pattern.compile(\"(`{3,}[^`]*+)|(~{3,}.*+)\")),\n+\n+        \/**\n+         * Bullet list item: * + - followed by at least one space or tab\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#list-items\">List items<\/a>\n+         *\/\n+        BULLETED_LIST_ITEM(Pattern.compile(\"[-+*][ \\t].*\")),\n+\n+        \/**\n+         * Ordered list item: a sequence of 1-9 arabic digits (0-9), followed by\n+         * either a . character or a ), followed by at least one space or tab\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#list-items\">List items<\/a>\n+         *\/\n+        ORDERED_LIST_ITEM(Pattern.compile(\"[0-9]{1,9}[.)][ \\t].*\")),\n+\n+        \/**\n+         * Block quote: >\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#block-quotes\">Block quotes<\/a>\n+         *\/\n+        BLOCK_QUOTE(Pattern.compile(\">.*\")),\n+\n+        \/**\n+         * Everything else...\n+         *\n+         * This entry must come last, since it matches \"none of the above\".\n+         *\/\n+        OTHER(Pattern.compile(\".*\"));\n+\n+        LineKind(Pattern p) {\n+            this.pattern = p;\n+        }\n+\n+        final Pattern pattern;\n+    }\n+\n@@ -1562,1 +2203,1 @@\n-                                addPendingText(v, bp - 1);\n+                                addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n@@ -1571,1 +2212,1 @@\n-                                addPendingText(v, bp - 1);\n+                                addPendingText(v, bp - 1, DocTree.Kind.TEXT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":804,"deletions":163,"binary":false,"changes":967,"status":"modified"},{"patch":"@@ -79,0 +79,5 @@\n+    \/**\n+     * Whether \"\/\/\/\" comments are recognized as documentation comments.\n+     *\/\n+    protected final boolean enableLineDocComments;\n+\n@@ -166,0 +171,1 @@\n+        this.enableLineDocComments = fac.enableLineDocComments;\n@@ -921,1 +927,12 @@\n-                        skipToEOLN();\n+                        if (enableLineDocComments && accept('\/')) { \/\/ JavaDoc line comment\n+                            int endPos;\n+                            do {\n+                                skipToEOLN();\n+                                endPos = position();\n+                                skipLineTerminator();\n+                                skipWhitespace();\n+                             } while (accept(\"\/\/\/\"));\n+\n+                            comments = appendComment(comments, processComment(pos, endPos, CommentStyle.JAVADOC_LINE));\n+                        } else {\n+                            skipToEOLN();\n@@ -923,2 +940,3 @@\n-                        if (isAvailable()) {\n-                            comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));\n+                            if (isAvailable()) {\n+                                comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));\n+                            }\n@@ -932,1 +950,1 @@\n-                            style = CommentStyle.JAVADOC;\n+                            style = CommentStyle.JAVADOC_BLOCK;\n@@ -1210,1 +1228,1 @@\n-        CommentStyle cs;\n+        final CommentStyle cs;\n@@ -1315,1 +1333,1 @@\n-         * Trim the first part of the JavaDoc comment.\n+         * Trim the first part of the JavaDoc block comment.\n@@ -1337,0 +1355,43 @@\n+        \/**\n+         * Determine how much indent to remove from a JavaDoc line comment.\n+         *\n+         * @return minimum indent to remove\n+         *\/\n+        int getJavadocLineCommentIndent() {\n+            int result = Integer.MAX_VALUE;\n+            UnicodeReader fullReader = lineReader(position(), position() + length());\n+\n+            while (fullReader.isAvailable()) {\n+                UnicodeReader line = fullReader.lineReader();\n+                line.skipWhitespace();\n+                line.accept(\"\/\/\/\");\n+                int pos = line.position();\n+                line.skipWhitespace();\n+\n+                if (line.isAvailable()) {\n+                    result = Integer.min(result, line.position() - pos);\n+                }\n+            }\n+\n+            return result == Integer.MAX_VALUE ? 0 : result;\n+        }\n+\n+        \/**\n+         * Trim the first part of a JavaDoc line comment.\n+         *\n+         * @param indent how much indentation to remove\n+         * @param line line reader\n+         *\n+         * @return modified line reader\n+         *\/\n+        UnicodeReader trimJavadocLineComment(UnicodeReader line, int indent) {\n+            line.skipWhitespace();\n+            line.accept(\"\/\/\/\");\n+\n+            for (int i = 0; line.isAvailable() && i < indent; i++) {\n+                line.next();\n+            }\n+\n+            return line;\n+        }\n+\n@@ -1353,0 +1414,9 @@\n+                CommentStyle style;\n+                int indent = 0;\n+                int start = position();\n+\n+                if (accept(\"\/**\")) {\n+                    style = CommentStyle.JAVADOC_BLOCK;\n+                    if (skip('*') != 0 && is('\/')) {\n+                        return ;\n+                    }\n@@ -1354,9 +1424,1 @@\n-                if (!accept(\"\/**\")) {\n-                    return;\n-                }\n-\n-                if (skip('*') != 0 && is('\/')) {\n-                    return ;\n-                }\n-\n-                skipWhitespace();\n+                    skipWhitespace();\n@@ -1364,3 +1426,10 @@\n-                if (isEOLN()) {\n-                    accept('\\r');\n-                    accept('\\n');\n+                    if (isEOLN()) {\n+                        accept('\\r');\n+                        accept('\\n');\n+                    }\n+                } else if (accept(\"\/\/\/\")) {\n+                    style = CommentStyle.JAVADOC_LINE;\n+                    reset(start);\n+                    indent = getJavadocLineCommentIndent();\n+                } else {\n+                    return;\n@@ -1371,12 +1440,18 @@\n-                    line = trimJavadocComment(line);\n-\n-                    \/\/ If standalone @deprecated tag\n-                    int pos = line.position();\n-                    line.skipWhitespace();\n-\n-                    if (line.accept(\"@deprecated\") &&\n-                            (!line.isAvailable() ||\n-                                    line.isWhitespace() ||\n-                                    line.isEOLN() ||\n-                                    line.get() == EOI)) {\n-                        deprecatedFlag = true;\n+                    line = (style == CommentStyle.JAVADOC_LINE)\n+                            ? trimJavadocLineComment(line, indent)\n+                            : trimJavadocComment(line);\n+\n+                    if (cs == CommentStyle.JAVADOC_BLOCK) {\n+                        \/\/ If standalone @deprecated tag\n+                        int pos = line.position();\n+                        line.skipWhitespace();\n+\n+                        if (line.accept(\"@deprecated\") &&\n+                                (!line.isAvailable() ||\n+                                        line.isWhitespace() ||\n+                                        line.isEOLN() ||\n+                                        line.get() == EOI)) {\n+                            deprecatedFlag = true;\n+                        }\n+\n+                        line.reset(pos);\n@@ -1385,1 +1460,0 @@\n-                    line.reset(pos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":105,"deletions":31,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -4161,1 +4161,1 @@\n-            } else if (def.hasTag(Tag.IMPORT)) {\n+            } else if (def.hasTag(Tag.IMPORT) || def.hasTag(Tag.MODULEIMPORT)) {\n@@ -4295,0 +4295,7 @@\n+        } else if (token.kind == IDENTIFIER && token.name() == names.module &&\n+                   peekToken(TokenKind.IDENTIFIER)) {\n+            checkSourceLevel(Feature.MODULE_IMPORTS);\n+            nextToken();\n+            JCExpression moduleName = qualident(false);\n+            accept(SEMI);\n+            return toP(F.at(pos).ModuleImport(moduleName));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+import javax.lang.model.util.Elements.DocCommentKind;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+\n@@ -32,1 +36,0 @@\n-import com.sun.tools.javac.tree.DCTree.DCDocComment;\n@@ -47,1 +50,1 @@\n-        DCDocComment tree;\n+        DocCommentTree tree;\n@@ -75,0 +78,10 @@\n+    @Override\n+    public DocCommentKind getCommentKind(JCTree tree) {\n+        Comment c = getComment(tree);\n+        return (c == null) ? null : switch (c.getStyle()) {\n+            case JAVADOC_BLOCK -> DocCommentKind.TRADITIONAL;\n+            case JAVADOC_LINE -> DocCommentKind.END_OF_LINE;\n+            default -> throw new IllegalStateException(c.getStyle().toString());\n+        };\n+    }\n+\n@@ -82,1 +95,1 @@\n-    public DCDocComment getCommentTree(JCTree tree) {\n+    public DocCommentTree getCommentTree(JCTree tree) {\n@@ -84,1 +97,1 @@\n-        if (e == null)\n+        if (e == null) {\n@@ -86,2 +99,4 @@\n-        if (e.tree == null)\n-            e.tree = new DocCommentParser(fac, diagSource, e.comment).parse();\n+        }\n+        if (e.tree == null) {\n+            e.tree = fac.getTrees().getDocCommentTree(diagSource, e.comment);\n+        }\n@@ -95,1 +110,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/LazyDocCommentTable.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.tools.javac.api.JavacTrees;\n@@ -37,1 +38,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic;\n@@ -75,0 +75,2 @@\n+    private final JavacTrees trees;\n+\n@@ -90,0 +92,1 @@\n+        this.trees = JavacTrees.instance(context);\n@@ -100,0 +103,4 @@\n+\n+    public JavacTrees getTrees() {\n+        return trees;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ParserFactory.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                        case JAVADOC -> {\n+                        case JAVADOC_BLOCK, JAVADOC_LINE -> {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.main.Option;\n@@ -36,0 +37,1 @@\n+import com.sun.tools.javac.util.Options;\n@@ -64,0 +66,1 @@\n+    final boolean enableLineDocComments;\n@@ -75,0 +78,2 @@\n+        var options = Options.instance(context);\n+        this.enableLineDocComments = !options.isSet(Option.DISABLE_LINE_DOC_COMMENTS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -277,3 +277,4 @@\n-            LINE,       \/\/ Starting with \/\/\n-            BLOCK,      \/\/ starting with \/*\n-            JAVADOC,    \/\/ starting with \/**\n+            LINE,            \/\/ starting with \/\/   -- also known in JLS as \"end-of-line comment\"\n+            BLOCK,           \/\/ starting with \/*   -- also known in JLS as \"traditional comment\"\n+            JAVADOC_LINE,    \/\/ starting with \/\/\/\n+            JAVADOC_BLOCK    \/\/ starting with \/**\n@@ -363,1 +364,1 @@\n-            List<Comment> comments = getComments(Comment.CommentStyle.JAVADOC);\n+            List<Comment> comments = getDocComments();\n@@ -374,1 +375,1 @@\n-            for (Comment c : getComments(Comment.CommentStyle.JAVADOC)) {\n+            for (Comment c : getDocComments()) {\n@@ -382,1 +383,1 @@\n-        private List<Comment> getComments(Comment.CommentStyle style) {\n+        private List<Comment> getDocComments() {\n@@ -388,2 +389,3 @@\n-                    if (c.getStyle() == style) {\n-                        buf.add(c);\n+                    Comment.CommentStyle style = c.getStyle();\n+                    switch (style) {\n+                        case JAVADOC_BLOCK, JAVADOC_LINE -> buf.add(c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3230,0 +3230,3 @@\n+compiler.misc.feature.module.imports=\\\n+    module imports\n+\n@@ -3540,0 +3543,12 @@\n+# 0: name\n+compiler.err.import.module.not.found=\\\n+    imported module not found: {0}\n+\n+# 0: symbol\n+compiler.err.import.module.does.not.read.unnamed=\\\n+    unnamed module does not read: {0}\n+\n+# 0: symbol, 1: symbol\n+compiler.err.import.module.does.not.read=\\\n+    module {0} does not read: {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -387,0 +387,2 @@\n+javac.opt.lineDocComments=\\\n+    Disable support for documentation comments with lines beginning '\/\/\/'\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,5 @@\n+            case MARKDOWN -> {\n+                DCRawText markdown = (DCRawText) this;\n+                return markdown.pos + markdown.code.length();\n+            }\n+\n@@ -899,0 +904,33 @@\n+    public static class DCRawText extends DCTree implements RawTextTree {\n+        public final Kind kind;\n+        public final String code;\n+\n+        DCRawText(Kind kind, String code) {\n+            if (kind != Kind.MARKDOWN) {\n+                throw new IllegalArgumentException(String.valueOf(kind));\n+            }\n+            this.kind = kind;\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public boolean isBlank() {\n+            return code.isBlank();\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.MARKDOWN;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(DocTreeVisitor<R, D> v, D d) {\n+            return v.visitRawText(this, d);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public String getContent() {\n+            return code;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import javax.lang.model.util.Elements.DocCommentKind;\n+\n+import com.sun.source.doctree.DocCommentTree;\n@@ -29,0 +32,1 @@\n+\n@@ -30,1 +34,0 @@\n-import com.sun.tools.javac.tree.DCTree.DCDocComment;\n@@ -42,1 +45,1 @@\n-     * Check if a tree node has a corresponding doc comment.\n+     * Checks if a tree node has a corresponding doc comment.\n@@ -47,1 +50,1 @@\n-     * Get the Comment token containing the doc comment, if any, for a tree node.\n+     * Returns the Comment token containing the doc comment, if any, for a tree node.\n@@ -52,1 +55,6 @@\n-     * Get the plain text of the doc comment, if any, for a tree node.\n+     * Returns the kind of the doc comment, if any, for a tree node.\n+     *\/\n+    DocCommentKind getCommentKind(JCTree tree);\n+\n+    \/**\n+     * Returns the plain text of the doc comment, if any, for a tree node.\n@@ -57,1 +65,1 @@\n-     * Get the parsed form of the doc comment as a DocTree. If any errors\n+     * Returns the parsed form of the doc comment as a DocTree. If any errors\n@@ -59,1 +67,1 @@\n-     * {@link ErroneousTree ErroneousTree} nodes within the resulting tree.\n+     * {@link ErroneousTree} nodes within the resulting tree.\n@@ -61,1 +69,1 @@\n-    DCDocComment getCommentTree(JCTree tree);\n+    DocCommentTree getCommentTree(JCTree tree);\n@@ -64,1 +72,1 @@\n-     * Set the Comment to be associated with a tree node.\n+     * Sets the Comment to be associated with a tree node.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocCommentTable.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -393,0 +393,10 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public Void visitRawText(RawTextTree node, Void p) {\n+        try {\n+            print(node.getContent());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return null;\n+    }\n+\n@@ -630,2 +640,6 @@\n-            print(' ');\n-            print(node.getContent());\n+            var content = node.getContent();\n+            boolean isEmpty = content.stream().allMatch(n -> (n instanceof TextTree t) && t.getBody().isEmpty());\n+            if (!isEmpty) {\n+                print(' ');\n+                print(content);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -71,0 +73,1 @@\n+import com.sun.tools.javac.tree.DCTree.DCRawText;\n@@ -214,1 +217,5 @@\n-        \/\/ A dummy comment to keep the diagnostics logic happy.\n+        \/\/ A dummy comment that returns Position.NOPOS for any source position.\n+        \/\/ A different solution would be to replace the Comment field\n+        \/\/ in DCDocComment with a narrower type equivalent to Function<int,int>\n+        \/\/ so that here in this code we can just supply a lambda as follows:\n+        \/\/   i -> Position.NOPOS\n@@ -216,4 +223,0 @@\n-            @Override\n-            public String getText() {\n-                return null;\n-            }\n@@ -231,0 +234,5 @@\n+            @Override\n+            public String getText() {\n+                throw new UnsupportedOperationException(getClass() + \".getText\");\n+            }\n+\n@@ -233,1 +241,1 @@\n-                return CommentStyle.JAVADOC;\n+                throw new UnsupportedOperationException(getClass() + \".getStyle\");\n@@ -238,1 +246,1 @@\n-                return false;\n+                throw new UnsupportedOperationException(getClass() + \".isDeprecated\");\n@@ -350,0 +358,7 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCRawText newRawTextTree(DocTree.Kind kind, String text) {\n+        DCTree.DCRawText tree = new DCRawText(kind, text);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -577,9 +592,8 @@\n-                        case TEXT -> {\n-                            var dtPos = dt.pos;\n-                            var s = ((DCText) dt).getBody();\n-                            var peekedNext = iter.hasNext()\n-                                    ? alist.get(iter.nextIndex())\n-                                    : null;\n-                            int sbreak = getSentenceBreak(s, peekedNext);\n-                            if (sbreak > 0) {\n-                                var fsPart = m.at(dtPos).newTextTree(s.substring(0, sbreak).stripTrailing());\n+                        case TEXT, MARKDOWN -> {\n+                            var peekedNext = iter.hasNext() ? alist.get(iter.nextIndex()) : null;\n+                            var content = getContent(dt);\n+                            int breakOffset = getSentenceBreak(dt.getKind(), content, peekedNext);\n+                            if (breakOffset > 0) {\n+                                \/\/ the end of sentence is within the current node;\n+                                \/\/ split it, skipping whitespace in between the two parts\n+                                var fsPart = newNode(dt.getKind(), dt.pos, content.substring(0, breakOffset).stripTrailing());\n@@ -587,3 +601,3 @@\n-                                int offsetPos = skipWhiteSpace(s, sbreak);\n-                                if (offsetPos > 0) {\n-                                    DCText bodyPart = m.at(dtPos + offsetPos).newTextTree(s.substring(offsetPos));\n+                                int wsOffset = skipWhiteSpace(content, breakOffset);\n+                                if (wsOffset > 0) {\n+                                    var bodyPart = newNode(dt.getKind(), dt.pos + wsOffset, content.substring(wsOffset));\n@@ -593,11 +607,6 @@\n-                            } else if (peekedNext != null) {\n-                                \/\/ if the next doctree is a break, remove trailing spaces\n-                                if (isSentenceBreak(peekedNext, false)) {\n-                                    DCTree next = iter.next();\n-                                    DCText fsPart = m.at(dtPos).newTextTree(s.stripTrailing());\n-                                    fs.add(fsPart);\n-                                    body.add(next);\n-                                    foundFirstSentence = true;\n-                                } else {\n-                                    fs.add(dt);\n-                                }\n+                            } else if (peekedNext != null && isSentenceBreak(peekedNext, false)) {\n+                                \/\/ the next node is a sentence break, so this is the end of the first sentence;\n+                                \/\/ remove trailing spaces\n+                                var fsPart = newNode(dt.getKind(), dt.pos, content.stripTrailing());\n+                                fs.add(fsPart);\n+                                foundFirstSentence = true;\n@@ -605,0 +614,1 @@\n+                                \/\/ no sentence break found; keep scanning\n@@ -636,21 +646,7 @@\n-        \/*\n-         * Computes the first sentence break, a simple dot-space algorithm.\n-         *\/\n-        private int defaultSentenceBreak(String s) {\n-            \/\/ scan for period followed by whitespace\n-            int period = -1;\n-            for (int i = 0; i < s.length(); i++) {\n-                switch (s.charAt(i)) {\n-                    case '.':\n-                        period = i;\n-                        break;\n-\n-                    case ' ':\n-                    case '\\f':\n-                    case '\\n':\n-                    case '\\r':\n-                    case '\\t':\n-                        if (period >= 0) {\n-                            return i;\n-                        }\n-                        break;\n+        private String getContent(DCTree dt) {\n+            return switch (dt.getKind()) {\n+                case TEXT -> ((DCText) dt).text;\n+                case MARKDOWN -> ((DCRawText) dt).code;\n+                default -> throw new IllegalArgumentException(dt.getKind().toString());\n+            };\n+        }\n@@ -658,6 +654,6 @@\n-                    default:\n-                        period = -1;\n-                        break;\n-                }\n-            }\n-            return -1;\n+        private DCTree newNode(DocTree.Kind kind, int pos, String text) {\n+            return switch (kind) {\n+                case TEXT -> m.at(pos).newTextTree(text);\n+                case MARKDOWN -> m.at(pos).newRawTextTree(kind, text);\n+                default -> throw new IllegalArgumentException(kind.toString());\n+            };\n@@ -686,1 +682,1 @@\n-        private int getSentenceBreak(String s, DCTree nextTree) {\n+        private int getSentenceBreak(DocTree.Kind kind, String s, DCTree nextTree) {\n@@ -689,1 +685,1 @@\n-                return defaultSentenceBreak(s);\n+                return defaultSentenceBreak(kind, s);\n@@ -691,1 +687,6 @@\n-            breakIterator.setText(s);\n+\n+            \/\/ If there is a paragraph break in a run of Markdown text, restrict the\n+            \/\/ search to the first paragraph, to avoid beginning-of-line Markdown constructs\n+            \/\/ confusing the sentence breaker.\n+            String s2 = normalize(kind, kind == Kind.MARKDOWN ? firstParaText(s) : s);\n+            breakIterator.setText(s2);\n@@ -693,2 +694,13 @@\n-            \/\/ This is the last doctree, found the droid we are looking for\n-            if (nextTree == null) {\n+\n+            switch (kind) {\n+                case MARKDOWN -> {\n+                    int endParaPos = endParaPos(s2);\n+                    if (endParaPos != -1) {\n+                        return Math.min(sbrk, endParaPos);\n+                    }\n+                }\n+            }\n+\n+            \/\/ If this is the last doctree, or if there was a paragraph break in a run\n+            \/\/ of Markdown text, then we found the droid we are looking for\n+            if (nextTree == null || kind == Kind.MARKDOWN && s2.length() < s.length()) {\n@@ -698,1 +710,1 @@\n-            \/\/ If the break is well within the span of the string ie. not\n+            \/\/ If the break is well within the span of the string i.e. not\n@@ -704,12 +716,13 @@\n-            if (nextTree.getKind() == Kind.TEXT) {\n-                \/\/ Two adjacent text trees, a corner case, perhaps\n-                \/\/ produced by a tool synthesizing a doctree. In\n-                \/\/ this case, does the break lie within the first span,\n-                \/\/ then we have the droid, otherwise allow the callers\n-                \/\/ logic to handle the break in the adjacent doctree.\n-                TextTree ttnext = (TextTree) nextTree;\n-                String combined = s + ttnext.getBody();\n-                breakIterator.setText(combined);\n-                int sbrk2 = breakIterator.next();\n-                if (sbrk < sbrk2) {\n-                    return sbrk;\n+            switch (nextTree.getKind()) {\n+                case TEXT, MARKDOWN -> {\n+                    \/\/ Two adjacent text trees, a corner case, perhaps\n+                    \/\/ produced by a tool synthesizing a doctree. In\n+                    \/\/ this case, does the break lie within the first span,\n+                    \/\/ then we have the droid, otherwise allow the callers\n+                    \/\/ logic to handle the break in the adjacent doctree.\n+                    String combined = s2 + normalize(nextTree.getKind(), getContent(nextTree));\n+                    breakIterator.setText(combined);\n+                    int sbrk2 = breakIterator.next();\n+                    if (sbrk < sbrk2) {\n+                        return sbrk;\n+                    }\n@@ -736,0 +749,63 @@\n+        \/*\n+         * Computes the first sentence break, a simple dot-space algorithm.\n+         *\/\n+        private int defaultSentenceBreak(DocTree.Kind kind, String s) {\n+            String s2 = normalize(kind, s);\n+\n+            \/\/ scan for period followed by whitespace\n+            int period = -1;\n+            for (int i = 0; i < s2.length(); i++) {\n+                switch (s2.charAt(i)) {\n+                    case '.':\n+                        period = i;\n+                        break;\n+\n+                    case ' ':\n+                    case '\\f':\n+                    case '\\n':\n+                    case '\\r':\n+                    case '\\t':\n+                        if (period >= 0) {\n+                            switch (kind) {\n+                                case MARKDOWN -> {\n+                                    int endParaPos = endParaPos(s2);\n+                                    return endParaPos == -1 || i < endParaPos ? i : endParaPos;\n+                                }\n+                                case TEXT -> {\n+                                    return i;\n+                                }\n+                                default -> throw new IllegalArgumentException(kind.toString());\n+                            }\n+                        }\n+                        break;\n+\n+                    default:\n+                        period = -1;\n+                        break;\n+                }\n+            }\n+\n+            return switch (kind) {\n+                case MARKDOWN -> endParaPos(s2); \/\/ may be -1\n+                case TEXT -> -1;\n+                default -> throw new IllegalArgumentException(kind.toString());\n+            };\n+        }\n+\n+        \/\/ End of paragraph is newline, followed by a blank line or the beginning of the next block.\n+        \/\/ - + * are list markers\n+        \/\/ # = - are for headings\n+        \/\/ - _ * are for thematic breaks\n+        \/\/ >     is for block quotes\n+        private static final Pattern endPara = Pattern.compile(\"\\n(([ \\t]*\\n)|( {0,3}[-+*#=_>]))\");\n+\n+        private static int endParaPos(String s) {\n+            Matcher m = endPara.matcher(s);\n+            return m.find() ? m.start() : -1;\n+        }\n+\n+        private static String firstParaText(String s) {\n+            int endParaPos = endParaPos(s);\n+            return endParaPos == -1 ? s : s.substring(0, endParaPos);\n+        }\n+\n@@ -765,0 +841,69 @@\n+\n+        private String normalize(DocTree.Kind kind, String s) {\n+            return switch (kind) {\n+                case TEXT -> s;\n+                case MARKDOWN -> normalizeMarkdown(s);\n+                default -> throw new IllegalArgumentException(kind.toString());\n+            };\n+        }\n+\n+        \/\/ Returns a string in which any periods that should not be considered\n+        \/\/ as ending a sentence are replaced by dashes.  This specifically\n+        \/\/ includes periods in code spans and links.\n+        private String normalizeMarkdown(String s) {\n+            StringBuilder sb = new StringBuilder();\n+            int slen = s.length();\n+            int i = 0;\n+            while (i < slen) {\n+                char ch = s.charAt(i);\n+                switch (ch) {\n+                    case '\\\\' -> {\n+                        sb.append(ch);\n+                        i++;\n+                        if (i < slen) {\n+                            sb.append(s.charAt(i));\n+                            i++;\n+                        }\n+                    }\n+\n+                    case '<' -> i = skip(sb, s, i, ch, '>');\n+                    case '[' -> i = skip(sb, s, i, ch, ']');\n+                    case '(' -> i = skip(sb, s, i, ch, ')');\n+\n+                    case '`' -> {\n+                        int start = i;\n+                        i++;\n+                        while (i < slen && s.charAt(i) == '`') {\n+                            i++;\n+                        }\n+                        String prefix = s.substring(start, i);\n+                        sb.append(prefix);\n+                        int j = s.indexOf(prefix, i);\n+                        if (j > i) {\n+                            sb.append(s.substring(i, j).replace('.', '-'));\n+                            sb.append(prefix);\n+                            i = j + prefix.length();\n+                        }\n+                    }\n+\n+                    default -> {\n+                        sb.append(ch);\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            return sb.toString();\n+        }\n+\n+        private int skip(StringBuilder sb, String s, int i, char ch, char term) {\n+            sb.append(ch);\n+            i++;\n+            int j = s.indexOf(term, i);\n+            if (j != -1) {\n+                sb.append(s.substring(i, j).replace('.', '-'));\n+                return j;\n+            } else {\n+                return i;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":220,"deletions":75,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -108,0 +108,4 @@\n+        \/** Module import clauses.\n+         *\/\n+        MODULEIMPORT,\n+\n@@ -588,2 +592,2 @@\n-        public List<JCImport> getImports() {\n-            ListBuffer<JCImport> imports = new ListBuffer<>();\n+        public List<JCImportBase> getImports() {\n+            ListBuffer<JCImportBase> imports = new ListBuffer<>();\n@@ -591,2 +595,2 @@\n-                if (tree.hasTag(IMPORT))\n-                    imports.append((JCImport)tree);\n+                if (tree instanceof JCImportBase imp)\n+                    imports.append(imp);\n@@ -611,1 +615,3 @@\n-                        && !typeDefs.head.hasTag(PACKAGEDEF) && !typeDefs.head.hasTag(IMPORT)) {\n+                        && !typeDefs.head.hasTag(PACKAGEDEF)\n+                        && !typeDefs.head.hasTag(IMPORT)\n+                        && !typeDefs.head.hasTag(MODULEIMPORT)) {\n@@ -664,0 +670,12 @@\n+    public static abstract class JCImportBase extends JCTree implements ImportTree {\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.IMPORT; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitImport(this, d);\n+        }\n+\n+        public abstract JCTree getQualifiedIdentifier();\n+    }\n+\n@@ -667,1 +685,1 @@\n-    public static class JCImport extends JCTree implements ImportTree {\n+    public static class JCImport extends JCImportBase {\n@@ -682,0 +700,2 @@\n+        public boolean isModule() { return false; }\n+        @DefinedBy(Api.COMPILER_TREE)\n@@ -684,0 +704,25 @@\n+        @Override\n+        public Tag getTag() {\n+            return IMPORT;\n+        }\n+    }\n+\n+    \/**\n+     * A module import clause.\n+     *\/\n+    public static class JCModuleImport extends JCImportBase {\n+        \/** The module name. *\/\n+        public JCExpression module;\n+        protected JCModuleImport(JCExpression module) {\n+            this.module = module;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitModuleImport(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public boolean isStatic() { return false; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public boolean isModule() { return true; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getQualifiedIdentifier() { return module; }\n+\n@@ -693,1 +738,1 @@\n-            return IMPORT;\n+            return MODULEIMPORT;\n@@ -3483,0 +3528,1 @@\n+        public void visitModuleImport(JCModuleImport that)   { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":53,"deletions":7,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -383,3 +383,2 @@\n-            if (l.head.hasTag(IMPORT)) {\n-                JCImport imp = (JCImport)l.head;\n-                Name name = TreeInfo.name(imp.qualid);\n+            if (l.head instanceof JCImportBase imp) {\n+                Name name = TreeInfo.name(imp.getQualifiedIdentifier());\n@@ -388,1 +387,2 @@\n-                        isUsed(TreeInfo.symbol(imp.qualid), cdef)) {\n+                        imp instanceof JCModuleImport ||\n+                        isUsed(TreeInfo.symbol(imp.getQualifiedIdentifier()), cdef)) {\n@@ -550,0 +550,11 @@\n+    public void visitModuleImport(JCModuleImport tree) {\n+        try {\n+            print(\"import module \");\n+            printExpr(tree.module);\n+            print(';');\n+            println();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -260,3 +260,8 @@\n-        JCImport t = (JCImport) node;\n-        JCFieldAccess qualid = copy(t.qualid, p);\n-        return M.at(t.pos).Import(qualid, t.staticImport);\n+        if (node instanceof JCModuleImport mimp) {\n+            JCExpression module = copy(mimp.module, p);\n+            return M.at(mimp.pos).ModuleImport(module);\n+        } else {\n+            JCImport t = (JCImport) node;\n+            JCFieldAccess qualid = copy(t.qualid, p);\n+            return M.at(t.pos).Import(qualid, t.staticImport);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -481,7 +481,0 @@\n-    public static DCTree.DCDocComment getCommentTree(Env<?> env, JCTree tree) {\n-        DocCommentTable docComments = (tree.hasTag(JCTree.Tag.TOPLEVEL))\n-                ? ((JCCompilationUnit) tree).docComments\n-                : env.toplevel.docComments;\n-        return (docComments == null) ? null : docComments.getCommentTree(tree);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+                || node instanceof JCModuleImport\n@@ -154,2 +155,8 @@\n-    public JCImport Import(JCFieldAccess qualid, boolean importStatic) {\n-        JCImport tree = new JCImport(qualid, importStatic);\n+    public JCImport Import(JCFieldAccess qualid, boolean staticImport) {\n+        JCImport tree = new JCImport(qualid, staticImport);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCModuleImport ModuleImport(JCExpression moduleName) {\n+        JCModuleImport tree = new JCModuleImport(moduleName);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -236,1 +236,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n@@ -258,1 +259,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n@@ -264,1 +266,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n@@ -268,1 +271,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.internal.md;\n@@ -276,0 +280,1 @@\n+    uses com.sun.tools.javac.api.JavacTrees.DocCommentTreeTransformer;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -566,0 +566,3 @@\n+\\f[V]--disable-line-doc-comments\\f[R]\n+Disables support for documentation comments with lines beginning \/\/\/.\n+.TP\n","filename":"src\/jdk.compiler\/share\/man\/javac.1","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,3 @@\n+    \/\/ whether to allow legacy mechanisms\n+    private boolean allowLegacy = false;\n+\n@@ -254,0 +257,4 @@\n+    boolean getAllowLegacy() {\n+        return allowLegacy;\n+    }\n+\n@@ -456,0 +463,2 @@\n+            case \"allowLegacy\"->\n+                allowLegacy = parseBooleanEntry(st.sval);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -457,3 +457,12 @@\n-            if (encrypt) {\n-                token.p11.C_EncryptInit(session.id(), mechWithParams,\n-                    p11KeyID);\n+\n+            if (type == Transformation.AES_GCM) {\n+                CK_VERSION cryptokiVersion = token.p11.getVersion();\n+                boolean useNormativeMechFirst = cryptokiVersion.major > 2 ||\n+                    (cryptokiVersion.major == 2  && cryptokiVersion.minor >= 40);\n+                if (encrypt) {\n+                    token.p11.C_GCMEncryptInitWithRetry(session.id(), mechWithParams,\n+                        p11KeyID, useNormativeMechFirst);\n+                } else {\n+                    token.p11.C_GCMDecryptInitWithRetry(session.id(), mechWithParams,\n+                        p11KeyID, useNormativeMechFirst);\n+                }\n@@ -461,2 +470,7 @@\n-                token.p11.C_DecryptInit(session.id(), mechWithParams,\n-                    p11KeyID);\n+                if (encrypt) {\n+                    token.p11.C_EncryptInit(session.id(), mechWithParams,\n+                        p11KeyID);\n+                } else {\n+                    token.p11.C_DecryptInit(session.id(), mechWithParams,\n+                        p11KeyID);\n+                }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1225,19 +1225,0 @@\n-    private static boolean isLegacy(CK_MECHANISM_INFO mechInfo)\n-            throws PKCS11Exception {\n-        \/\/ assume full support if no mech info available\n-        \/\/ For vendor-specific mechanisms, often no mech info is provided\n-        boolean partialSupport = false;\n-\n-        if (mechInfo != null) {\n-            if ((mechInfo.flags & CKF_DECRYPT) != 0) {\n-                \/\/ non-legacy cipher mechs should support encryption\n-                partialSupport |= ((mechInfo.flags & CKF_ENCRYPT) == 0);\n-            }\n-            if ((mechInfo.flags & CKF_VERIFY) != 0) {\n-                \/\/ non-legacy signature mechs should support signing\n-                partialSupport |= ((mechInfo.flags & CKF_SIGN) == 0);\n-            }\n-        }\n-        return partialSupport;\n-    }\n-\n@@ -1312,6 +1293,0 @@\n-            if (isLegacy(mechInfo)) {\n-                if (showInfo) {\n-                    System.out.println(\"DISABLED due to legacy\");\n-                }\n-                continue;\n-            }\n@@ -1339,0 +1314,1 @@\n+            boolean allowLegacy = config.getAllowLegacy();\n@@ -1354,0 +1330,15 @@\n+\n+                    \/\/ assume full support if no mech info available\n+                    if (!allowLegacy && mechInfo != null) {\n+                        if ((d.type == CIP &&\n+                                (mechInfo.flags & CKF_ENCRYPT) == 0) ||\n+                                (d.type == SIG &&\n+                                (mechInfo.flags & CKF_SIGN) == 0)) {\n+                            if (showInfo) {\n+                                System.out.println(\"DISABLED \" +  d.type +\n+                                        \" \" + d.algorithm +\n+                                        \" due to partial support\");\n+                            }\n+                            continue;\n+                        }\n+                    }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -796,0 +796,18 @@\n+    \/**\n+     * C_GCMEncryptInitWithRetry initializes a GCM encryption operation and retry\n+     * with alternative param structure for max compatibility.\n+     * (Encryption and decryption)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param pMechanism the encryption mechanism\n+     *         (PKCS#11 param: CK_MECHANISM_PTR pMechanism)\n+     * @param hKey the handle of the encryption key\n+     *         (PKCS#11 param: CK_OBJECT_HANDLE hKey)\n+     * @param useNormativeVerFirst whether to use normative version of GCM parameter first\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_GCMEncryptInitWithRetry(long hSession, CK_MECHANISM pMechanism,\n+            long hKey, boolean useNormativeVerFirst) throws PKCS11Exception;\n@@ -890,0 +908,18 @@\n+    \/**\n+     * C_GCMDecryptInitWithRetry initializes a GCM decryption operation\n+     * with alternative param structure for max compatibility.\n+     * (Encryption and decryption)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param pMechanism the decryption mechanism\n+     *         (PKCS#11 param: CK_MECHANISM_PTR pMechanism)\n+     * @param hKey the handle of the decryption key\n+     *         (PKCS#11 param: CK_OBJECT_HANDLE hKey)\n+     * @param useNormativeVerFirst whether to use normative version of GCM parameter first\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_GCMDecryptInitWithRetry(long hSession, CK_MECHANISM pMechanism,\n+            long hKey, boolean useNormativeVerFirst) throws PKCS11Exception;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1017,2 +1017,3 @@\n- * converts the Java CK_GCM_PARAMS object to a CK_GCM_PARAMS_NO_IVBITS pointer\n- * Note: Need to try NSS definition first to avoid SIGSEGV.\n+ * converts the Java CK_GCM_PARAMS object to a CK_GCM_PARAMS pointer\n+ * Note: Early NSS versions crash w\/ CK_GCM_PARAMS and need to use\n+ * CK_GCM_PARAMS_NO_IVBITS to avoid SIGSEGV.\n@@ -1023,1 +1024,1 @@\n- * @return pointer to the new CK_GCM_PARAMS_NO_IVBITS structure\n+ * @return pointer to the new CK_GCM_PARAMS structure\n@@ -1025,1 +1026,1 @@\n-CK_GCM_PARAMS_NO_IVBITS_PTR\n+CK_GCM_PARAMS_PTR\n@@ -1028,1 +1029,1 @@\n-    CK_GCM_PARAMS_NO_IVBITS_PTR ckParamPtr;\n+    CK_GCM_PARAMS_PTR ckParamPtr;\n@@ -1056,2 +1057,2 @@\n-    \/\/ allocate memory for CK_GCM_PARAMS_NO_IVBITS pointer\n-    ckParamPtr = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n+    \/\/ allocate memory for CK_GCM_PARAMS pointer\n+    ckParamPtr = calloc(1, sizeof(CK_GCM_PARAMS));\n@@ -1068,0 +1069,2 @@\n+    \/\/ adjust since the value is in bits\n+    ckParamPtr->ulIvBits = ckParamPtr->ulIvLen << 3;\n@@ -1077,1 +1080,1 @@\n-        *pLength = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n+        *pLength = sizeof(CK_GCM_PARAMS);\n@@ -1079,1 +1082,1 @@\n-    TRACE1(\"Created inner GCM_PARAMS PTR w\/o ulIvBits %p\\n\", ckParamPtr);\n+    TRACE1(\"Created inner GCM_PARAMS PTR %p\\n\", ckParamPtr);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-    CK_MECHANISM_PTR ckpTemp;\n@@ -93,10 +92,50 @@\n-    if (ckpMechanism->mechanism == CKM_AES_GCM) {\n-        if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n-            \/\/ retry with CKM_GCM_PARAMS structure in pkcs11t.h\n-            TRACE0(\"DEBUG C_EncryptInit: retry with CK_GCM_PARAMS\\n\");\n-            ckpTemp = updateGCMParams(env, ckpMechanism);\n-            if (ckpTemp != NULL) { \/\/ only re-call if conversion succeeds\n-                ckpMechanism = ckpTemp;\n-                rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism,\n-                        ckKeyHandle);\n-            }\n+    TRACE1(\"DEBUG C_EncryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    freeCKMechanismPtr(ckpMechanism);\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+\n+    TRACE0(\"FINISHED\\n\");\n+}\n+\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_GCMEncryptInitWithRetry\n+ * Signature: (JLsun\/security\/pkcs11\/wrapper\/CK_MECHANISM;JZ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism\n+ * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey\n+ * @param   jboolean useNormVerFirst    CK_BBOOL retry (only retry if the first\n+ *                                      init uses the non-normative version)\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_security_pkcs11_wrapper_PKCS11_C_1GCMEncryptInitWithRetry\n+(JNIEnv *env, jobject obj, jlong jSessionHandle,\n+ jobject jMechanism, jlong jKeyHandle, jboolean useNormVerFirst)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_MECHANISM_PTR ckpMechanism = NULL;\n+    CK_OBJECT_HANDLE ckKeyHandle;\n+    CK_BBOOL retry = FALSE;\n+    CK_RV rv = 1;\n+\n+    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n+    if (ckpFunctions == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckKeyHandle = jLongToCKULong(jKeyHandle);\n+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);\n+\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    \/\/ if !useNormVerFirst, then update 'ckpMechanism' in place w\/\n+    \/\/ non-normative GCM params.\n+    retry = (!useNormVerFirst && updateGCMParams(env, ckpMechanism) != NULL);\n+\n+    rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n+\n+    if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n+        \/\/ retry and update 'ckpMechanism' in place w\/ normative GCM params.\n+        if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n+            TRACE0(\"DEBUG retry C_EncryptInit\\n\");\n+            rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle,\n+                ckpMechanism, ckKeyHandle);\n@@ -106,1 +145,1 @@\n-    TRACE1(\"DEBUG C_EncryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    TRACE1(\"DEBUG C_GCMEncryptInitWithRetry: freed pMech = %p\\n\", ckpMechanism);\n@@ -315,1 +354,0 @@\n-    CK_MECHANISM_PTR ckpTemp;\n@@ -333,10 +371,51 @@\n-    if (ckpMechanism->mechanism == CKM_AES_GCM) {\n-        if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n-            \/\/ retry with CKM_GCM_PARAMS structure in pkcs11t.h\n-            TRACE0(\"DEBUG C_DecryptInit: retry with CK_GCM_PARAMS\\n\");\n-            ckpTemp = updateGCMParams(env, ckpMechanism);\n-            if (ckpTemp != NULL) { \/\/ only re-call if conversion succeeds\n-                ckpMechanism = ckpTemp;\n-                rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n-                        ckKeyHandle);\n-            }\n+    TRACE1(\"DEBUG C_DecryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    freeCKMechanismPtr(ckpMechanism);\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+\n+    TRACE0(\"FINISHED\\n\");\n+}\n+\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_GCMDecryptInitWithRetry\n+ * Signature: (JLsun\/security\/pkcs11\/wrapper\/CK_MECHANISM;JZ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism\n+ * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey\n+ * @param   jboolean useNormVerFirst    CK_BBOOL retry (only retry if the first\n+ *                                      init uses the non-normative version)\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_security_pkcs11_wrapper_PKCS11_C_1GCMDecryptInitWithRetry\n+(JNIEnv *env, jobject obj, jlong jSessionHandle,\n+ jobject jMechanism, jlong jKeyHandle, jboolean useNormVerFirst)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_MECHANISM_PTR ckpMechanism = NULL;\n+    CK_OBJECT_HANDLE ckKeyHandle;\n+    CK_BBOOL retry = FALSE;\n+    CK_RV rv = 1;\n+\n+    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n+    if (ckpFunctions == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckKeyHandle = jLongToCKULong(jKeyHandle);\n+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);\n+\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    \/\/ if !useNormVerFirst, then update 'ckpMechanism' in place w\/\n+    \/\/ non-normative GCM params.\n+    retry = (!useNormVerFirst && updateGCMParams(env, ckpMechanism) != NULL);\n+\n+    rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n+        ckKeyHandle);\n+\n+    if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n+        \/\/ retry and update 'ckpMechanism' in place w\/ normative GCM params.\n+        if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n+            TRACE0(\"DEBUG retry C_DecryptInit with normative CK_GCM_PARAMS\\n\");\n+            rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n+                ckKeyHandle);\n@@ -346,1 +425,1 @@\n-    TRACE1(\"DEBUG C_DecryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    TRACE1(\"DEBUG C_GCMDecryptInitWithRetry: freed pMech = %p\\n\", ckpMechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_crypt.c","additions":104,"deletions":25,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,5 +330,1 @@\n-                     if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n-                         TRACE0(\"[ GCM_PARAMS w\/o ulIvBits ]\\n\");\n-                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pIv);\n-                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pAAD);\n-                     } else if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS)) {\n+                     if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS)) {\n@@ -338,0 +334,4 @@\n+                     } else if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n+                         TRACE0(\"[ GCM_PARAMS w\/o ulIvBits ]\\n\");\n+                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pIv);\n+                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pAAD);\n@@ -454,3 +454,3 @@\n-\/* This function replaces the CK_GCM_PARAMS_NO_IVBITS structure associated\n- * with the specified CK_MECHANISM structure with CK_GCM_PARAMS\n- * structure.\n+\/* This function updates the specified CK_MECHANISM structure\n+ * and its GCM parameter structure switching between CK_GCM_PARAMS and\n+ * CK_GCM_PARAMS_NO_IVBITS.\n@@ -459,1 +459,1 @@\n- * the to-be-converted CK_GCM_PARAMS_NO_IVBITS structure.\n+ * the to-be-converted CK_GCM_PARAMS \/ CK_GCM_PARAMS_NO_IVBITS structure.\n@@ -461,1 +461,1 @@\n- * converted CK_GCM_PARAMS structure or NULL if no conversion took place.\n+ * converted structure or NULL if no conversion is done.\n@@ -464,9 +464,35 @@\n-    CK_GCM_PARAMS* pGcmParams2 = NULL;\n-    CK_GCM_PARAMS_NO_IVBITS* pParams = NULL;\n-    if ((mechPtr->mechanism == CKM_AES_GCM) &&\n-            (mechPtr->pParameter != NULL_PTR) &&\n-            (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS))) {\n-        pGcmParams2 = calloc(1, sizeof(CK_GCM_PARAMS));\n-        if (pGcmParams2 == NULL) {\n-            p11ThrowOutOfMemoryError(env, 0);\n-            return NULL;\n+    CK_GCM_PARAMS_PTR pParams;\n+    CK_GCM_PARAMS_NO_IVBITS_PTR pParamsNoIvBits;\n+    CK_ULONG paramLen;\n+\n+    if (mechPtr != NULL) {\n+        paramLen = mechPtr->ulParameterLen;\n+        if (paramLen == sizeof(CK_GCM_PARAMS)) {\n+            \/\/ CK_GCM_PARAMS => CK_GCM_PARAMS_NO_IVBITS\n+            pParams = (CK_GCM_PARAMS*) mechPtr->pParameter;\n+            pParamsNoIvBits = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n+            pParamsNoIvBits->pIv = pParams->pIv;\n+            pParamsNoIvBits->ulIvLen = pParams->ulIvLen;\n+            pParamsNoIvBits->pAAD = pParams->pAAD;\n+            pParamsNoIvBits->ulAADLen = pParams->ulAADLen;\n+            pParamsNoIvBits->ulTagBits = pParams->ulTagBits;\n+            mechPtr->pParameter = pParamsNoIvBits;\n+            mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n+            free(pParams);\n+            TRACE0(\"DEBUG update CK_GCM_PARAMS to CK_GCM_PARAMS_NO_IVBITS\\n\");\n+            return mechPtr;\n+        } else if (paramLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n+            \/\/ CK_GCM_PARAMS_NO_IVBITS => CK_GCM_PARAMS\n+            pParamsNoIvBits = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr->pParameter;\n+            pParams = calloc(1, sizeof(CK_GCM_PARAMS));\n+            pParams->pIv = pParamsNoIvBits->pIv;\n+            pParams->ulIvLen = pParamsNoIvBits->ulIvLen;\n+            pParams->ulIvBits = pParamsNoIvBits->ulIvLen << 3;\n+            pParams->pAAD = pParamsNoIvBits->pAAD;\n+            pParams->ulAADLen = pParamsNoIvBits->ulAADLen;\n+            pParams->ulTagBits = pParamsNoIvBits->ulTagBits;\n+            mechPtr->pParameter = pParams;\n+            mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n+            free(pParamsNoIvBits);\n+            TRACE0(\"DEBUG update CK_GCM_PARAMS_NO_IVBITS to CK_GCM_PARAMS\\n\");\n+            return mechPtr;\n@@ -474,16 +500,0 @@\n-        pParams = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr->pParameter;\n-        pGcmParams2->pIv = pParams->pIv;\n-        pGcmParams2->ulIvLen = pParams->ulIvLen;\n-        pGcmParams2->ulIvBits = (pGcmParams2->ulIvLen << 3);\n-        pGcmParams2->pAAD = pParams->pAAD;\n-        pGcmParams2->ulAADLen = pParams->ulAADLen;\n-        pGcmParams2->ulTagBits = pParams->ulTagBits;\n-        TRACE1(\"DEBUG updateGCMParams: pMech %p\\n\", mechPtr);\n-        TRACE2(\"\\t=> GCM param w\/o ulIvBits %p => GCM param %p\\n\", pParams,\n-                pGcmParams2);\n-        free(pParams);\n-        mechPtr->pParameter = pGcmParams2;\n-        mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n-        return mechPtr;\n-    } else {\n-        TRACE0(\"DEBUG updateGCMParams: no conversion done\\n\");\n@@ -491,0 +501,1 @@\n+    TRACE0(\"DEBUG updateGCMParams: no conversion done\\n\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":47,"deletions":36,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,2 @@\n+     *\n+     * @since 10\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/StandardOperation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,3 +53,0 @@\n-  \/\/ Fields for class StatRecord\n-  private static Field         statRecordField;\n-  private static CIntegerField invocationField;\n@@ -70,4 +67,0 @@\n-    \/\/ StatRecord\n-    statRecordField         = type.getField(\"_stat_record\");\n-    type                    = db.lookupType(\"Generation::StatRecord\");\n-    invocationField         = type.getCIntegerField(\"invocations\");\n@@ -80,4 +73,0 @@\n-  public int invocations() {\n-    return getStatRecord().getInvocations();\n-  }\n-\n@@ -126,15 +115,0 @@\n-\n-  public static class StatRecord extends VMObject {\n-    public StatRecord(Address addr) {\n-      super(addr);\n-    }\n-\n-    public int getInvocations() {\n-      return (int) invocationField.getValue(addr);\n-    }\n-\n-  }\n-\n-  private StatRecord getStatRecord() {\n-    return VMObjectFactory.newObject(StatRecord.class, addr.addOffsetTo(statRecordField.getOffset()));\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/Generation.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    tty.println(\"Young Generation - Invocations: \" + youngGen().invocations());\n+    tty.println(\"Young Generation: \");\n@@ -102,1 +102,1 @@\n-    tty.println(\"Old Generation - Invocations: \" + oldGen().invocations());\n+    tty.println(\"Old Generation: \");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/SerialHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  private static Address mapped_base_address;\n@@ -101,1 +102,1 @@\n-    Address mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n+    mapped_base_address = get_AddressField(FileMapHeader_type, header, \"_mapped_base_address\");\n@@ -173,8 +174,20 @@\n-      \/\/ vtablesIndex points to this:\n-      \/\/     class CppVtableInfo {\n-      \/\/         intptr_t _vtable_size;\n-      \/\/         intptr_t _cloned_vtable[1];\n-      \/\/         ...\n-      \/\/     };\n-      \/\/     CppVtableInfo** CppVtables::_index;\n-      \/\/ This is the index of all the cloned vtables. E.g., for\n+      \/\/ vtablesIndex points to to an array like this:\n+      \/\/ long info[] = {\n+      \/\/   offset of the CppVtableInfo for ConstantPool,\n+      \/\/   offset of the CppVtableInfo for InstanceKlass,\n+      \/\/   offset of the CppVtableInfo for InstanceClassLoaderKlass,\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ class CppVtableInfo {\n+      \/\/   intptr_t _vtable_size;\n+      \/\/   intptr_t _cloned_vtable[1];\n+      \/\/   ...\n+      \/\/ };\n+      \/\/\n+      \/\/ The loop below computes the following\n+      \/\/     CppVtableInfo* t_ConstantPool  = mapped_base_address + info[0];\n+      \/\/     CppVtableInfo* t_InstanceKlass = mapped_base_address + info[1];\n+      \/\/     ...\n+      \/\/\n+      \/\/ If we have the following objects\n@@ -183,3 +196,19 @@\n-      \/\/ the following holds true:\n-      \/\/     &_index[ConstantPool_Kind]->_cloned_vtable[0]  == ((intptr_t**)cp)[0]\n-      \/\/     &_index[InstanceKlass_Kind]->_cloned_vtable[0] == ((intptr_t**)ik)[0]\n+      \/\/\n+      \/\/ then the following holds true:\n+      \/\/     ((intptr_t**)cp)[0] == &t_ConstantPool->_cloned_vtable[0]  \/\/ The vtable for archived ConstantPools\n+      \/\/     ((intptr_t**)ik)[0] == &t_InstanceKlass->_cloned_vtable[0] \/\/ The vtable for archived InstanceKlasses\n+      \/\/\n+      \/\/ To get an idea what these address look like, do this:\n+      \/\/\n+      \/\/ $ java -Xlog:cds+vtables=debug -XX:+UnlockDiagnosticVMOptions -XX:ArchiveRelocationMode=0 --version\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for ConstantPool to 0x800000018\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceKlass to 0x800000090\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceClassLoaderKlass to 0x8000001e0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceMirrorKlass to 0x800000330\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceRefKlass to 0x800000480\n+      \/\/ [0.002s][debug][cds,vtables] Copying  41 vtable entries for InstanceStackChunkKlass to 0x8000005d0\n+      \/\/ [0.002s][debug][cds,vtables] Copying  14 vtable entries for Method to 0x800000720\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for ObjArrayKlass to 0x800000798\n+      \/\/ [0.002s][debug][cds,vtables] Copying  42 vtable entries for TypeArrayKlass to 0x8000008f0\n+      \/\/ java 23-internal 2024-09-17\n+      \/\/ ...\n@@ -188,2 +217,8 @@\n-        Address vtableInfoAddress = vtablesIndex.getAddressAt(i * addressSize); \/\/ = _index[i]\n-        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize); \/\/ = &_index[i]->_cloned_vtable[0]\n+        long vtable_offset = vtablesIndex.getJLongAt(i * addressSize); \/\/ long offset = _index[i]\n+\n+        \/\/ CppVtableInfo* t = the address of the CppVtableInfo for the i-th table\n+        Address vtableInfoAddress = mapped_base_address.addOffsetTo(vtable_offset);\n+\n+        \/\/ vtableAddress = &t->_cloned_vtable[0]\n+        Address vtableAddress = vtableInfoAddress.addOffsetTo(addressSize);\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-        if (sp == -1 || !auth.substring(0, sp).equals (\"Basic\")) {\n+        if (sp == -1 || !auth.substring(0, sp).equalsIgnoreCase(\"Basic\")) {\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/BasicAuthenticator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,0 @@\n-        flush();\n@@ -142,0 +141,7 @@\n+            \/*\n+            * write any pending chunk data. manually write chunk rather than\n+            * calling flush to avoid sending small packets\n+            *\/\n+            if (count > 0) {\n+                writeChunk();\n+            }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ChunkedOutputStream.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-        OutputStream tmpout = new BufferedOutputStream (ros);\n+        ByteArrayOutputStream tmpout = new ByteArrayOutputStream();\n@@ -281,2 +281,1 @@\n-        tmpout.flush() ;\n-        tmpout = null;\n+        tmpout.writeTo(ros);\n@@ -286,0 +285,1 @@\n+            ros.flush();\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ExchangeImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.io.BufferedOutputStream;\n@@ -689,0 +690,1 @@\n+                    rawout = new BufferedOutputStream(rawout);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,3 @@\n+    private static final String FAVICON_RESOURCE_PATH =\n+            \"\/sun\/net\/httpserver\/simpleserver\/resources\/favicon.ico\";\n+    private static final String FAVICON_LAST_MODIFIED = \"Mon, 23 May 1995 11:11:11 GMT\";\n@@ -253,0 +256,25 @@\n+    private static boolean isFavIconRequest(HttpExchange exchange) {\n+        return \"\/favicon.ico\".equals(exchange.getRequestURI().getPath());\n+    }\n+\n+    private void serveDefaultFavIcon(HttpExchange exchange, boolean writeBody)\n+            throws IOException\n+    {\n+        var respHdrs = exchange.getResponseHeaders();\n+        try (var stream = getClass().getModule().getResourceAsStream(FAVICON_RESOURCE_PATH)) {\n+            var bytes = stream.readAllBytes();\n+            respHdrs.set(\"Content-Type\", \"image\/x-icon\");\n+            respHdrs.set(\"Last-Modified\", FAVICON_LAST_MODIFIED);\n+            if (writeBody) {\n+                exchange.sendResponseHeaders(200, bytes.length);\n+                try (OutputStream os = exchange.getResponseBody()) {\n+                    os.write(bytes);\n+                }\n+            } else {\n+                respHdrs.set(\"Content-Length\", Integer.toString(bytes.length));\n+                exchange.sendResponseHeaders(200, -1);\n+            }\n+        }\n+    }\n+\n+\n@@ -374,0 +402,1 @@\n+            boolean isHeadRequest = exchange.getRequestMethod().equals(\"HEAD\");\n@@ -379,1 +408,1 @@\n-                } else if (exchange.getRequestMethod().equals(\"HEAD\")) {\n+                } else if (isHeadRequest) {\n@@ -385,0 +414,8 @@\n+                if (isFavIconRequest(exchange)) {\n+                    try {\n+                        serveDefaultFavIcon(exchange, !isHeadRequest);\n+                        return;\n+                    } catch (IOException ignore) {\n+                        \/\/ fall through to send the not-found response\n+                    }\n+                }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/FileServerHandler.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.Inet6Address;\n@@ -172,0 +173,7 @@\n+            if (inetAddr instanceof Inet6Address && addr.contains(\":\") && !addr.startsWith(\"[\")) {\n+                \/\/ we use the \"addr\" when printing the URL, so make sure it\n+                \/\/ conforms to RFC-2732, section 2:\n+                \/\/ To use a literal IPv6 address in a URL, the literal\n+                \/\/ address should be enclosed in \"[\" and \"]\" characters.\n+                addr = \"[\" + addr + \"]\";\n+            }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerImpl.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/resources\/favicon.ico","binary":true,"status":"added"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.IOException;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-class JDKNativePty {\n-\n-    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-    static int isatty(int fd) {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-    static String ttyname(int fd) {\n-        throw new UnsupportedOperationException(\"Not supported.\");\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/aix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.IOException;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-class JDKNativePty {\n-\n-    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-        return LinuxNativePty.current(console);\n-    }\n-\n-    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-        return LinuxNativePty.open(attr, size);\n-    }\n-\n-    static int isatty(int fd) {\n-        return LinuxNativePty.isatty(fd);\n-    }\n-\n-    static String ttyname(int fd) {\n-        return LinuxNativePty.ttyname(fd);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import java.util.Arrays;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.List;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Platform;\n-\/\/import com.sun.jna.Structure;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n-import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n-import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n-import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n-import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public interface CLibrary {\/\/extends com.sun.jna.Library {\n-\n-    void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    void ioctl(int fd, int cmd, winsize data) throws LastErrorException;\n-\n-    int isatty(int fd);\n-\n-    void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-    class winsize { \/\/extends Structure {\n-        public short ws_row;\n-        public short ws_col;\n-        public short ws_xpixel;\n-        public short ws_ypixel;\n-\n-        public winsize() {\n-        }\n-\n-        public winsize(Size ws) {\n-            ws_row = (short) ws.getRows();\n-            ws_col = (short) ws.getColumns();\n-        }\n-\n-        public Size toSize() {\n-            return new Size(ws_col, ws_row);\n-        }\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"ws_row\",\/\/\n-\/\/                    \"ws_col\",\/\/\n-\/\/                    \"ws_xpixel\",\/\/\n-\/\/                    \"ws_ypixel\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-    }\n-\n-    class termios {\/\/ extends Structure {\n-\n-        public int c_iflag;\n-        public int c_oflag;\n-        public int c_cflag;\n-        public int c_lflag;\n-        public byte c_line;\n-        public byte[] c_cc = new byte[32];\n-        public int c_ispeed;\n-        public int c_ospeed;\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"c_iflag\",\/\/\n-\/\/                    \"c_oflag\",\/\/\n-\/\/                    \"c_cflag\",\/\/\n-\/\/                    \"c_lflag\",\/\/\n-\/\/                    \"c_line\",\/\/\n-\/\/                    \"c_cc\",\/\/\n-\/\/                    \"c_ispeed\",\/\/\n-\/\/                    \"c_ospeed\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-        public termios() {\n-        }\n-\n-        public termios(Attributes t) {\n-            \/\/ Input flags\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNBRK),           IGNBRK,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.BRKINT),           BRKINT,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNPAR),           IGNPAR,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.PARMRK),           PARMRK,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.INPCK),            INPCK,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.ISTRIP),           ISTRIP,     c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.INLCR),            INLCR,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IGNCR),            IGNCR,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.ICRNL),            ICRNL,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IXON),             IXON,       c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IXOFF),            IXOFF,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IXANY),            IXANY,      c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IMAXBEL),          IMAXBEL,    c_iflag);\n-            c_iflag = setFlag(t.getInputFlag(InputFlag.IUTF8),            IUTF8,      c_iflag);\n-            \/\/ Output flags\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OPOST),          OPOST,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONLCR),          ONLCR,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OCRNL),          OCRNL,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONOCR),          ONOCR,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.ONLRET),         ONLRET,     c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OFILL),          OFILL,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.NLDLY),          NLDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.TABDLY),         TABDLY,     c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.CRDLY),          CRDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.FFDLY),          FFDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.BSDLY),          BSDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.VTDLY),          VTDLY,      c_oflag);\n-            c_oflag = setFlag(t.getOutputFlag(OutputFlag.OFDEL),          OFDEL,      c_oflag);\n-            \/\/ Control flags\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS5),          CS5,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS6),          CS6,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS7),          CS7,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CS8),          CS8,        c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CSTOPB),       CSTOPB,     c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CREAD),        CREAD,      c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.PARENB),       PARENB,     c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.PARODD),       PARODD,     c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.HUPCL),        HUPCL,      c_cflag);\n-            c_cflag = setFlag(t.getControlFlag(ControlFlag.CLOCAL),       CLOCAL,     c_cflag);\n-            \/\/ Local flags\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOKE),           ECHOKE,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOE),            ECHOE,      c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOK),            ECHOK,      c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHO),             ECHO,       c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHONL),           ECHONL,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOPRT),          ECHOPRT,    c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ECHOCTL),          ECHOCTL,    c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ISIG),             ISIG,       c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.ICANON),           ICANON,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.EXTPROC),          EXTPROC,    c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.TOSTOP),           TOSTOP,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.FLUSHO),           FLUSHO,     c_lflag);\n-            c_lflag = setFlag(t.getLocalFlag(LocalFlag.NOFLSH),           NOFLSH,     c_lflag);\n-            \/\/ Control chars\n-            c_cc[VEOF]      = (byte) t.getControlChar(ControlChar.VEOF);\n-            c_cc[VEOL]      = (byte) t.getControlChar(ControlChar.VEOL);\n-            c_cc[VEOL2]     = (byte) t.getControlChar(ControlChar.VEOL2);\n-            c_cc[VERASE]    = (byte) t.getControlChar(ControlChar.VERASE);\n-            c_cc[VWERASE]   = (byte) t.getControlChar(ControlChar.VWERASE);\n-            c_cc[VKILL]     = (byte) t.getControlChar(ControlChar.VKILL);\n-            c_cc[VREPRINT]  = (byte) t.getControlChar(ControlChar.VREPRINT);\n-            c_cc[VINTR]     = (byte) t.getControlChar(ControlChar.VINTR);\n-            c_cc[VQUIT]     = (byte) t.getControlChar(ControlChar.VQUIT);\n-            c_cc[VSUSP]     = (byte) t.getControlChar(ControlChar.VSUSP);\n-            c_cc[VSTART]    = (byte) t.getControlChar(ControlChar.VSTART);\n-            c_cc[VSTOP]     = (byte) t.getControlChar(ControlChar.VSTOP);\n-            c_cc[VLNEXT]    = (byte) t.getControlChar(ControlChar.VLNEXT);\n-            c_cc[VDISCARD]  = (byte) t.getControlChar(ControlChar.VDISCARD);\n-            c_cc[VMIN]      = (byte) t.getControlChar(ControlChar.VMIN);\n-            c_cc[VTIME]     = (byte) t.getControlChar(ControlChar.VTIME);\n-        }\n-\n-        private int setFlag(boolean flag, int value, int org) {\n-            return flag ? (org | value) : org;\n-        }\n-\n-        public Attributes toAttributes() {\n-            Attributes attr = new Attributes();\n-            \/\/ Input flags\n-            EnumSet<InputFlag> iflag = attr.getInputFlags();\n-            addFlag(c_iflag, iflag, InputFlag.IGNBRK,   IGNBRK);\n-            addFlag(c_iflag, iflag, InputFlag.IGNBRK, IGNBRK);\n-            addFlag(c_iflag, iflag, InputFlag.BRKINT, BRKINT);\n-            addFlag(c_iflag, iflag, InputFlag.IGNPAR, IGNPAR);\n-            addFlag(c_iflag, iflag, InputFlag.PARMRK, PARMRK);\n-            addFlag(c_iflag, iflag, InputFlag.INPCK, INPCK);\n-            addFlag(c_iflag, iflag, InputFlag.ISTRIP, ISTRIP);\n-            addFlag(c_iflag, iflag, InputFlag.INLCR, INLCR);\n-            addFlag(c_iflag, iflag, InputFlag.IGNCR, IGNCR);\n-            addFlag(c_iflag, iflag, InputFlag.ICRNL, ICRNL);\n-            addFlag(c_iflag, iflag, InputFlag.IXON, IXON);\n-            addFlag(c_iflag, iflag, InputFlag.IXOFF, IXOFF);\n-            addFlag(c_iflag, iflag, InputFlag.IXANY, IXANY);\n-            addFlag(c_iflag, iflag, InputFlag.IMAXBEL, IMAXBEL);\n-            addFlag(c_iflag, iflag, InputFlag.IUTF8, IUTF8);\n-            \/\/ Output flags\n-            EnumSet<OutputFlag> oflag = attr.getOutputFlags();\n-            addFlag(c_oflag, oflag, OutputFlag.OPOST, OPOST);\n-            addFlag(c_oflag, oflag, OutputFlag.ONLCR, ONLCR);\n-            addFlag(c_oflag, oflag, OutputFlag.OCRNL, OCRNL);\n-            addFlag(c_oflag, oflag, OutputFlag.ONOCR, ONOCR);\n-            addFlag(c_oflag, oflag, OutputFlag.ONLRET, ONLRET);\n-            addFlag(c_oflag, oflag, OutputFlag.OFILL, OFILL);\n-            addFlag(c_oflag, oflag, OutputFlag.NLDLY, NLDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.TABDLY, TABDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.CRDLY, CRDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.FFDLY, FFDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.BSDLY, BSDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.VTDLY, VTDLY);\n-            addFlag(c_oflag, oflag, OutputFlag.OFDEL, OFDEL);\n-            \/\/ Control flags\n-            EnumSet<ControlFlag> cflag = attr.getControlFlags();\n-            addFlag(c_cflag, cflag, ControlFlag.CS5, CS5);\n-            addFlag(c_cflag, cflag, ControlFlag.CS6, CS6);\n-            addFlag(c_cflag, cflag, ControlFlag.CS7, CS7);\n-            addFlag(c_cflag, cflag, ControlFlag.CS8, CS8);\n-            addFlag(c_cflag, cflag, ControlFlag.CSTOPB, CSTOPB);\n-            addFlag(c_cflag, cflag, ControlFlag.CREAD, CREAD);\n-            addFlag(c_cflag, cflag, ControlFlag.PARENB, PARENB);\n-            addFlag(c_cflag, cflag, ControlFlag.PARODD, PARODD);\n-            addFlag(c_cflag, cflag, ControlFlag.HUPCL, HUPCL);\n-            addFlag(c_cflag, cflag, ControlFlag.CLOCAL, CLOCAL);\n-            \/\/ Local flags\n-            EnumSet<LocalFlag> lflag = attr.getLocalFlags();\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOKE, ECHOKE);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOE, ECHOE);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOK, ECHOK);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHO, ECHO);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHONL, ECHONL);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOPRT, ECHOPRT);\n-            addFlag(c_lflag, lflag, LocalFlag.ECHOCTL, ECHOCTL);\n-            addFlag(c_lflag, lflag, LocalFlag.ISIG, ISIG);\n-            addFlag(c_lflag, lflag, LocalFlag.ICANON, ICANON);\n-            addFlag(c_lflag, lflag, LocalFlag.EXTPROC, EXTPROC);\n-            addFlag(c_lflag, lflag, LocalFlag.TOSTOP, TOSTOP);\n-            addFlag(c_lflag, lflag, LocalFlag.FLUSHO, FLUSHO);\n-            addFlag(c_lflag, lflag, LocalFlag.NOFLSH, NOFLSH);\n-            \/\/ Control chars\n-            EnumMap<ControlChar, Integer> cc = attr.getControlChars();\n-            cc.put(ControlChar.VEOF,        (int) c_cc[VEOF]);\n-            cc.put(ControlChar.VEOL,        (int) c_cc[VEOL]);\n-            cc.put(ControlChar.VEOL2,       (int) c_cc[VEOL2]);\n-            cc.put(ControlChar.VERASE,      (int) c_cc[VERASE]);\n-            cc.put(ControlChar.VWERASE,     (int) c_cc[VWERASE]);\n-            cc.put(ControlChar.VKILL,       (int) c_cc[VKILL]);\n-            cc.put(ControlChar.VREPRINT,    (int) c_cc[VREPRINT]);\n-            cc.put(ControlChar.VINTR,       (int) c_cc[VINTR]);\n-            cc.put(ControlChar.VQUIT,       (int) c_cc[VQUIT]);\n-            cc.put(ControlChar.VSUSP,       (int) c_cc[VSUSP]);\n-            cc.put(ControlChar.VSTART,      (int) c_cc[VSTART]);\n-            cc.put(ControlChar.VSTOP,       (int) c_cc[VSTOP]);\n-            cc.put(ControlChar.VLNEXT,      (int) c_cc[VLNEXT]);\n-            cc.put(ControlChar.VDISCARD,    (int) c_cc[VDISCARD]);\n-            cc.put(ControlChar.VMIN,        (int) c_cc[VMIN]);\n-            cc.put(ControlChar.VTIME,       (int) c_cc[VTIME]);\n-            \/\/ Return\n-            return attr;\n-        }\n-\n-        private <T extends Enum<T>> void addFlag(int value, EnumSet<T> flags, T flag, int v) {\n-            if ((value & v) != 0) {\n-                flags.add(flag);\n-            }\n-        }\n-    }\n-\n-    \/\/ CONSTANTS\n-\n-    int TIOCGWINSZ = \/*Platform.isMIPS() || Platform.isPPC() || Platform.isSPARC() ? 0x40087468 : *\/0x00005413;\n-    int TIOCSWINSZ = \/*Platform.isMIPS() || Platform.isPPC() || Platform.isSPARC() ? 0x80087467 : *\/0x00005414;\n-\n-    int VINTR       = 0;\n-    int VQUIT       = 1;\n-    int VERASE      = 2;\n-    int VKILL       = 3;\n-    int VEOF        = 4;\n-    int VTIME       = 5;\n-    int VMIN        = 6;\n-    int VSWTC       = 7;\n-    int VSTART      = 8;\n-    int VSTOP       = 9;\n-    int VSUSP       = 10;\n-    int VEOL        = 11;\n-    int VREPRINT    = 12;\n-    int VDISCARD    = 13;\n-    int VWERASE     = 14;\n-    int VLNEXT      = 15;\n-    int VEOL2       = 16;\n-\n-    int IGNBRK =   0x0000001;\n-    int BRKINT =   0x0000002;\n-    int IGNPAR =   0x0000004;\n-    int PARMRK =   0x0000008;\n-    int INPCK =    0x0000010;\n-    int ISTRIP =   0x0000020;\n-    int INLCR =    0x0000040;\n-    int IGNCR =    0x0000080;\n-    int ICRNL =    0x0000100;\n-    int IUCLC =    0x0000200;\n-    int IXON =     0x0000400;\n-    int IXANY =    0x0000800;\n-    int IXOFF =    0x0001000;\n-    int IMAXBEL =  0x0002000;\n-    int IUTF8 =    0x0004000;\n-\n-    int OPOST =    0x0000001;\n-    int OLCUC =    0x0000002;\n-    int ONLCR =    0x0000004;\n-    int OCRNL =    0x0000008;\n-    int ONOCR =    0x0000010;\n-    int ONLRET =   0x0000020;\n-    int OFILL =    0x0000040;\n-    int OFDEL =    0x0000080;\n-    int NLDLY =    0x0000100;\n-      int NL0 =    0x0000000;\n-      int NL1 =    0x0000100;\n-    int CRDLY =    0x0000600;\n-      int CR0 =    0x0000000;\n-      int CR1 =    0x0000200;\n-      int CR2 =    0x0000400;\n-      int CR3 =    0x0000600;\n-    int TABDLY =   0x0001800;\n-      int TAB0 =   0x0000000;\n-      int TAB1 =   0x0000800;\n-      int TAB2 =   0x0001000;\n-      int TAB3 =   0x0001800;\n-      int XTABS =  0x0001800;\n-    int BSDLY =    0x0002000;\n-      int BS0 =    0x0000000;\n-      int BS1 =    0x0002000;\n-    int VTDLY =    0x0004000;\n-      int VT0 =    0x0000000;\n-      int VT1 =    0x0004000;\n-    int FFDLY =    0x0008000;\n-      int FF0 =    0x0000000;\n-      int FF1 =    0x0008000;\n-\n-    int CBAUD =    0x000100f;\n-     int B0 =      0x0000000;\n-     int B50 =     0x0000001;\n-     int B75 =     0x0000002;\n-     int B110 =    0x0000003;\n-     int B134 =    0x0000004;\n-     int B150 =    0x0000005;\n-     int B200 =    0x0000006;\n-     int B300 =    0x0000007;\n-     int B600 =    0x0000008;\n-     int B1200 =   0x0000009;\n-     int B1800 =   0x000000a;\n-     int B2400 =   0x000000b;\n-     int B4800 =   0x000000c;\n-     int B9600 =   0x000000d;\n-     int B19200 =  0x000000e;\n-     int B38400 =  0x000000f;\n-    int EXTA =  B19200;\n-    int EXTB =  B38400;\n-    int CSIZE =    0x0000030;\n-      int CS5 =    0x0000000;\n-      int CS6 =    0x0000010;\n-      int CS7 =    0x0000020;\n-      int CS8 =    0x0000030;\n-    int CSTOPB =   0x0000040;\n-    int CREAD =    0x0000080;\n-    int PARENB =   0x0000100;\n-    int PARODD =   0x0000200;\n-    int HUPCL =    0x0000400;\n-    int CLOCAL =   0x0000800;\n-\n-    int ISIG =     0x0000001;\n-    int ICANON =   0x0000002;\n-    int XCASE =    0x0000004;\n-    int ECHO =     0x0000008;\n-    int ECHOE =    0x0000010;\n-    int ECHOK =    0x0000020;\n-    int ECHONL =   0x0000040;\n-    int NOFLSH =   0x0000080;\n-    int TOSTOP =   0x0000100;\n-    int ECHOCTL =  0x0000200;\n-    int ECHOPRT =  0x0000400;\n-    int ECHOKE =   0x0000800;\n-    int FLUSHO =   0x0001000;\n-    int PENDIN =   0x0002000;\n-    int IEXTEN =   0x0008000;\n-    int EXTPROC =  0x0010000;\n-\n-    int TCSANOW =          0x0;\n-    int TCSADRAIN =        0x1;\n-    int TCSAFLUSH =        0x2;\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary.java","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public final class CLibraryImpl implements CLibrary {\n-\n-    static {\n-        System.loadLibrary(\"le\");\n-        initIDs();\n-    }\n-\n-    private static native void initIDs();\n-\n-    @Override\n-    public native void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public native void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public void ioctl(int fd, int cmd, winsize data) throws LastErrorException {\n-        if (cmd == CLibrary.TIOCGWINSZ || cmd == CLibrary.TIOCSWINSZ) {\n-            ioctl0(fd, cmd, data);\n-        } else {\n-            throw new UnsupportedOperationException(\"Command: \" + cmd + \", not supported.\");\n-        }\n-    }\n-\n-    private native void ioctl0(int fd, int cmd, winsize data) throws LastErrorException;\n-\n-    @Override\n-    public native int isatty(int fd);\n-\n-    @Override\n-    public native void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibraryImpl.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Native;\n-\/\/import com.sun.jna.Platform;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.JnaNativePty;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TCSADRAIN;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TIOCGWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.TIOCSWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.termios;\n-import static jdk.internal.org.jline.terminal.impl.jna.linux.CLibrary.winsize;\n-\n-public class LinuxNativePty extends JnaNativePty {\n-\n-\/\/    private static final CLibrary C_LIBRARY = Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n-    private static final CLibrary C_LIBRARY = new CLibraryImpl();\n-\n-    public interface UtilLibrary {\/\/ extends com.sun.jna.Library {\n-\n-        void openpty(int[] master, int[] slave, byte[] name, CLibrary.termios t, CLibrary.winsize s) throws LastErrorException;\n-\n-\/\/        UtilLibrary INSTANCE = Native.load(\"util\", UtilLibrary.class);\n-        UtilLibrary INSTANCE = new UtilLibraryImpl();\n-    }\n-\n-    public static LinuxNativePty current(TerminalProvider.Stream consoleStream) throws IOException {\n-        switch (consoleStream) {\n-            case Output:\n-                return new LinuxNativePty(-1, null, 0, FileDescriptor.in, 1, FileDescriptor.out, ttyname(0));\n-            case Error:\n-                return new LinuxNativePty(-1, null, 0, FileDescriptor.in, 2, FileDescriptor.err, ttyname(0));\n-            default:\n-                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n-        }\n-    }\n-\n-    public static LinuxNativePty open(Attributes attr, Size size) throws IOException {\n-        int[] master = new int[1];\n-        int[] slave = new int[1];\n-        byte[] buf = new byte[64];\n-        UtilLibrary.INSTANCE.openpty(master, slave, buf,\n-                attr != null ? new termios(attr) : null,\n-                size != null ? new winsize(size) : null);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        String name = new String(buf, 0, len);\n-        return new LinuxNativePty(master[0], newDescriptor(master[0]), slave[0], newDescriptor(slave[0]), name);\n-    }\n-\n-    public LinuxNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n-        super(master, masterFD, slave, slaveFD, name);\n-    }\n-\n-    public LinuxNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n-        super(master, masterFD, slave, slaveFD, slaveOut, slaveOutFD, name);\n-    }\n-\n-    @Override\n-    public Attributes getAttr() throws IOException {\n-        termios termios = new termios();\n-        C_LIBRARY.tcgetattr(getSlave(), termios);\n-        return termios.toAttributes();\n-    }\n-\n-    @Override\n-    protected void doSetAttr(Attributes attr) throws IOException {\n-        termios termios = new termios(attr);\n-        termios org = new termios();\n-        C_LIBRARY.tcgetattr(getSlave(), org);\n-        org.c_iflag = termios.c_iflag;\n-        org.c_oflag = termios.c_oflag;\n-        org.c_lflag = termios.c_lflag;\n-        System.arraycopy(termios.c_cc, 0, org.c_cc, 0, termios.c_cc.length);\n-        C_LIBRARY.tcsetattr(getSlave(), TCSADRAIN, org);\n-    }\n-\n-    @Override\n-    public Size getSize() throws IOException {\n-        winsize sz = new winsize();\n-        C_LIBRARY.ioctl(getSlave(), TIOCGWINSZ, sz);\n-        return sz.toSize();\n-    }\n-\n-    @Override\n-    public void setSize(Size size) throws IOException {\n-        winsize sz = new winsize(size);\n-        C_LIBRARY.ioctl(getSlave(), TIOCSWINSZ, sz);\n-    }\n-\n-    public static int isatty(int fd) {\n-        return C_LIBRARY.isatty(fd);\n-    }\n-\n-    public static String ttyname(int slave) {\n-        byte[] buf = new byte[64];\n-        C_LIBRARY.ttyname_r(slave, buf, buf.length);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        return new String(buf, 0, len);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/LinuxNativePty.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.linux;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty.UtilLibrary;\n-\n-public final class UtilLibraryImpl implements UtilLibrary {\n-\n-    @Override\n-    public void openpty(int[] master, int[] slave, byte[] name, CLibrary.termios t, CLibrary.winsize s) throws LastErrorException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/linux\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/UtilLibraryImpl.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,207 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <termios.h>\n-#include <unistd.h>\n-#include <sys\/ioctl.h>\n-\n-static jclass lastErrorExceptionClass;\n-static jmethodID lastErrorExceptionConstructor;\n-\n-static jclass termios_j;\n-static jfieldID c_iflag;\n-static jfieldID c_oflag;\n-static jfieldID c_cflag;\n-static jfieldID c_lflag;\n-static jfieldID c_line;\n-static jfieldID c_cc;\n-static jfieldID c_ispeed;\n-static jfieldID c_ospeed;\n-\n-static jclass winsize_j;\n-static jfieldID ws_row;\n-static jfieldID ws_col;\n-static jfieldID ws_xpixel;\n-static jfieldID ws_ypixel;\n-\n-static void throw_errno(JNIEnv *env);\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_initIDs\n-  (JNIEnv *env, jclass unused) {\n-    jclass cls;\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n-    CHECK_NULL(cls);\n-    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n-    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n-    CHECK_NULL(lastErrorExceptionConstructor);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary$termios\");\n-    CHECK_NULL(cls);\n-    termios_j = (jclass) env->NewGlobalRef(cls);\n-    c_iflag = env->GetFieldID(termios_j, \"c_iflag\", \"I\");\n-    CHECK_NULL(c_iflag);\n-    c_oflag = env->GetFieldID(termios_j, \"c_oflag\", \"I\");\n-    CHECK_NULL(c_oflag);\n-    c_cflag = env->GetFieldID(termios_j, \"c_cflag\", \"I\");\n-    CHECK_NULL(c_cflag);\n-    c_lflag = env->GetFieldID(termios_j, \"c_lflag\", \"I\");\n-    CHECK_NULL(c_lflag);\n-    c_line = env->GetFieldID(termios_j, \"c_line\", \"B\");\n-    CHECK_NULL(c_line);\n-    c_cc = env->GetFieldID(termios_j, \"c_cc\", \"[B\");\n-    CHECK_NULL(c_cc);\n-    c_ispeed = env->GetFieldID(termios_j, \"c_ispeed\", \"I\");\n-    CHECK_NULL(c_ispeed);\n-    c_ospeed = env->GetFieldID(termios_j, \"c_ospeed\", \"I\");\n-    CHECK_NULL(c_ospeed);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary$winsize\");\n-    CHECK_NULL(cls);\n-    winsize_j = (jclass) env->NewGlobalRef(cls);\n-    ws_row = env->GetFieldID(winsize_j, \"ws_row\", \"S\");\n-    CHECK_NULL(ws_row);\n-    ws_col = env->GetFieldID(winsize_j, \"ws_col\", \"S\");\n-    CHECK_NULL(ws_col);\n-    ws_xpixel= env->GetFieldID(winsize_j, \"ws_xpixel\", \"S\");\n-    CHECK_NULL(ws_xpixel);\n-    ws_ypixel= env->GetFieldID(winsize_j, \"ws_ypixel\", \"S\");\n-    CHECK_NULL(ws_ypixel);\n-}\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_tcgetattr\n-  (JNIEnv *env, jobject, jint fd, jobject result) {\n-    termios data;\n-\n-    if (tcgetattr(fd, &data) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetIntField(result, c_iflag, data.c_iflag);\n-    env->SetIntField(result, c_oflag, data.c_oflag);\n-    env->SetIntField(result, c_cflag, data.c_cflag);\n-    env->SetIntField(result, c_lflag, data.c_lflag);\n-    env->SetIntField(result, c_line, data.c_line);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(result, c_cc);\n-    env->SetByteArrayRegion(c_ccValue, 0, NCCS, (signed char *) data.c_cc);\/\/TODO: cast?\n-    env->SetIntField(result, c_ispeed, cfgetispeed(&data));\n-    env->SetIntField(result, c_ospeed, cfgetospeed(&data));\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    tcsetattr\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary\/termios;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_tcsetattr\n-  (JNIEnv *env, jobject, jint fd, jint cmd, jobject input) {\n-    termios data;\n-\n-    data.c_iflag = env->GetIntField(input, c_iflag);\n-    data.c_oflag = env->GetIntField(input, c_oflag);\n-    data.c_cflag = env->GetIntField(input, c_cflag);\n-    data.c_lflag = env->GetIntField(input, c_lflag);\n-    data.c_line = env->GetIntField(input, c_line);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(input, c_cc);\n-    env->GetByteArrayRegion(c_ccValue, 0, NCCS, (jbyte *) data.c_cc);\n-    cfsetispeed(&data, env->GetIntField(input, c_ispeed));\n-    cfsetospeed(&data, env->GetIntField(input, c_ospeed));\n-\n-    if (tcsetattr(fd, cmd, &data) != 0) {\n-        throw_errno(env);\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    ioctl0\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/linux\/CLibrary\/winsize;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_ioctl0\n-  (JNIEnv *env, jobject, jint fd, jint cmd, jobject data) {\n-    winsize ws;\n-\n-    ws.ws_row = env->GetShortField(data, ws_row);\n-    ws.ws_col = env->GetShortField(data, ws_col);\n-    ws.ws_xpixel = env->GetShortField(data, ws_xpixel);\n-    ws.ws_ypixel = env->GetShortField(data, ws_ypixel);\n-\n-    if (ioctl(fd, cmd, &ws) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetShortField(data, ws_row, ws.ws_row);\n-    env->SetShortField(data, ws_col, ws.ws_col);\n-    env->SetShortField(data, ws_xpixel, ws.ws_xpixel);\n-    env->SetShortField(data, ws_ypixel, ws.ws_ypixel);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    isatty\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_isatty\n-  (JNIEnv *, jobject, jint fd) {\n-    return isatty(fd);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl\n- * Method:    ttyname_r\n- * Signature: (I[BI)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_linux_CLibraryImpl_ttyname_1r\n-  (JNIEnv *env, jobject, jint fd, jbyteArray buf, jint len) {\n-    char *data = new char[len];\n-    int error = ttyname_r(fd, data, len);\n-\n-    if (error != 0) {\n-        delete[] data;\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetByteArrayRegion(buf, 0, len, (jbyte *) data);\n-    delete[] data;\n-}\n-\n-\/*\n- * Throws LastErrorException based on the errno:\n- *\/\n-static void throw_errno(JNIEnv *env) {\n-    jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                 lastErrorExceptionConstructor,\n-                                 errno);\n-    env->Throw((jthrowable) exc);\n-}\n","filename":"src\/jdk.internal.le\/linux\/native\/lible\/CLibrary.cpp","additions":0,"deletions":207,"binary":false,"changes":207,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.IOException;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.osx.OsXNativePty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-class JDKNativePty {\n-\n-    static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-        return OsXNativePty.current(console);\n-    }\n-\n-    static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-        return OsXNativePty.open(attr, size);\n-    }\n-\n-    static int isatty(int fd) {\n-        return OsXNativePty.isatty(fd);\n-    }\n-\n-    static String ttyname(int fd) {\n-        return OsXNativePty.ttyname(fd);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JDKNativePty.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,394 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-import java.util.Arrays;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.List;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.NativeLong;\n-\/\/import com.sun.jna.Structure;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n-import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n-import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n-import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n-import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public interface CLibrary {\/\/extends com.sun.jna.Library {\n-\n-    void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    void ioctl(int fd, NativeLong cmd, winsize data) throws LastErrorException;\n-\n-    int isatty(int fd);\n-\n-    void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-    void openpty(int[] master, int[] slave, byte[] name, termios t, winsize s) throws LastErrorException;\n-\n-    class winsize { \/\/extends Structure {\n-        public short ws_row;\n-        public short ws_col;\n-        public short ws_xpixel;\n-        public short ws_ypixel;\n-\n-        public winsize() {\n-        }\n-\n-        public winsize(Size ws) {\n-            ws_row = (short) ws.getRows();\n-            ws_col = (short) ws.getColumns();\n-        }\n-\n-        public Size toSize() {\n-            return new Size(ws_col, ws_row);\n-        }\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"ws_row\",\/\/\n-\/\/                    \"ws_col\",\/\/\n-\/\/                    \"ws_xpixel\",\/\/\n-\/\/                    \"ws_ypixel\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-    }\n-\n-    class termios { \/\/extends Structure {\n-\n-        public NativeLong c_iflag;\n-        public NativeLong c_oflag;\n-        public NativeLong c_cflag;\n-        public NativeLong c_lflag;\n-        public byte[] c_cc = new byte[20];\n-        public NativeLong c_ispeed;\n-        public NativeLong c_ospeed;\n-\n-\/\/        @Override\n-\/\/        protected List<String> getFieldOrder() {\n-\/\/            return Arrays.asList(\/\/\n-\/\/                    \"c_iflag\",\/\/\n-\/\/                    \"c_oflag\",\/\/\n-\/\/                    \"c_cflag\",\/\/\n-\/\/                    \"c_lflag\",\/\/\n-\/\/                    \"c_cc\",\/\/\n-\/\/                    \"c_ispeed\",\/\/\n-\/\/                    \"c_ospeed\"\/\/\n-\/\/            );\n-\/\/        }\n-\n-        {\n-            c_iflag  = new NativeLong(0);\n-            c_oflag  = new NativeLong(0);\n-            c_cflag  = new NativeLong(0);\n-            c_lflag  = new NativeLong(0);\n-            c_ispeed = new NativeLong(0);\n-            c_ospeed = new NativeLong(0);\n-        }\n-\n-        public termios() {\n-        }\n-\n-        public termios(Attributes t) {\n-            \/\/ Input flags\n-            setFlag(t.getInputFlag(InputFlag.IGNBRK),           IGNBRK,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.BRKINT),           BRKINT,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IGNPAR),           IGNPAR,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.PARMRK),           PARMRK,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.INPCK),            INPCK,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.ISTRIP),           ISTRIP,     c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.INLCR),            INLCR,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IGNCR),            IGNCR,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.ICRNL),            ICRNL,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IXON),             IXON,       c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IXOFF),            IXOFF,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IXANY),            IXANY,      c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IMAXBEL),          IMAXBEL,    c_iflag);\n-            setFlag(t.getInputFlag(InputFlag.IUTF8),            IUTF8,      c_iflag);\n-            \/\/ Output flags\n-            setFlag(t.getOutputFlag(OutputFlag.OPOST),          OPOST,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONLCR),          ONLCR,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OXTABS),         OXTABS,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONOEOT),         ONOEOT,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OCRNL),          OCRNL,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONOCR),          ONOCR,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.ONLRET),         ONLRET,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OFILL),          OFILL,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.NLDLY),          NLDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.TABDLY),         TABDLY,     c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.CRDLY),          CRDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.FFDLY),          FFDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.BSDLY),          BSDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.VTDLY),          VTDLY,      c_oflag);\n-            setFlag(t.getOutputFlag(OutputFlag.OFDEL),          OFDEL,      c_oflag);\n-            \/\/ Control flags\n-            setFlag(t.getControlFlag(ControlFlag.CIGNORE),      CIGNORE,    c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS5),          CS5,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS6),          CS6,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS7),          CS7,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CS8),          CS8,        c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CSTOPB),       CSTOPB,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CREAD),        CREAD,      c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.PARENB),       PARENB,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.PARODD),       PARODD,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.HUPCL),        HUPCL,      c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CLOCAL),       CLOCAL,     c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CCTS_OFLOW),   CCTS_OFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CRTS_IFLOW),   CRTS_IFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CDTR_IFLOW),   CDTR_IFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CDSR_OFLOW),   CDSR_OFLOW, c_cflag);\n-            setFlag(t.getControlFlag(ControlFlag.CCAR_OFLOW),   CCAR_OFLOW, c_cflag);\n-            \/\/ Local flags\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOKE),           ECHOKE,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOE),            ECHOE,      c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOK),            ECHOK,      c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHO),             ECHO,       c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHONL),           ECHONL,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOPRT),          ECHOPRT,    c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ECHOCTL),          ECHOCTL,    c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ISIG),             ISIG,       c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ICANON),           ICANON,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.ALTWERASE),        ALTWERASE,  c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.IEXTEN),           IEXTEN,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.EXTPROC),          EXTPROC,    c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.TOSTOP),           TOSTOP,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.FLUSHO),           FLUSHO,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.NOKERNINFO),       NOKERNINFO, c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.PENDIN),           PENDIN,     c_lflag);\n-            setFlag(t.getLocalFlag(LocalFlag.NOFLSH),           NOFLSH,     c_lflag);\n-            \/\/ Control chars\n-            c_cc[VEOF]      = (byte) t.getControlChar(ControlChar.VEOF);\n-            c_cc[VEOL]      = (byte) t.getControlChar(ControlChar.VEOL);\n-            c_cc[VEOL2]     = (byte) t.getControlChar(ControlChar.VEOL2);\n-            c_cc[VERASE]    = (byte) t.getControlChar(ControlChar.VERASE);\n-            c_cc[VWERASE]   = (byte) t.getControlChar(ControlChar.VWERASE);\n-            c_cc[VKILL]     = (byte) t.getControlChar(ControlChar.VKILL);\n-            c_cc[VREPRINT]  = (byte) t.getControlChar(ControlChar.VREPRINT);\n-            c_cc[VINTR]     = (byte) t.getControlChar(ControlChar.VINTR);\n-            c_cc[VQUIT]     = (byte) t.getControlChar(ControlChar.VQUIT);\n-            c_cc[VSUSP]     = (byte) t.getControlChar(ControlChar.VSUSP);\n-            c_cc[VDSUSP]    = (byte) t.getControlChar(ControlChar.VDSUSP);\n-            c_cc[VSTART]    = (byte) t.getControlChar(ControlChar.VSTART);\n-            c_cc[VSTOP]     = (byte) t.getControlChar(ControlChar.VSTOP);\n-            c_cc[VLNEXT]    = (byte) t.getControlChar(ControlChar.VLNEXT);\n-            c_cc[VDISCARD]  = (byte) t.getControlChar(ControlChar.VDISCARD);\n-            c_cc[VMIN]      = (byte) t.getControlChar(ControlChar.VMIN);\n-            c_cc[VTIME]     = (byte) t.getControlChar(ControlChar.VTIME);\n-            c_cc[VSTATUS]   = (byte) t.getControlChar(ControlChar.VSTATUS);\n-        }\n-\n-        private void setFlag(boolean flag, long value, NativeLong org) {\n-            org.setValue(flag ? org.longValue() | value : org.longValue());\n-        }\n-\n-        public Attributes toAttributes() {\n-            Attributes attr = new Attributes();\n-            \/\/ Input flags\n-            EnumSet<InputFlag> iflag = attr.getInputFlags();\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNBRK,   IGNBRK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNBRK, IGNBRK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.BRKINT, BRKINT);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNPAR, IGNPAR);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.PARMRK, PARMRK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.INPCK, INPCK);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.ISTRIP, ISTRIP);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.INLCR, INLCR);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IGNCR, IGNCR);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.ICRNL, ICRNL);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IXON, IXON);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IXOFF, IXOFF);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IXANY, IXANY);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IMAXBEL, IMAXBEL);\n-            addFlag(c_iflag.longValue(), iflag, InputFlag.IUTF8, IUTF8);\n-            \/\/ Output flags\n-            EnumSet<OutputFlag> oflag = attr.getOutputFlags();\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OPOST, OPOST);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONLCR, ONLCR);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OXTABS, OXTABS);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONOEOT, ONOEOT);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OCRNL, OCRNL);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONOCR, ONOCR);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.ONLRET, ONLRET);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OFILL, OFILL);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.NLDLY, NLDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.TABDLY, TABDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.CRDLY, CRDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.FFDLY, FFDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.BSDLY, BSDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.VTDLY, VTDLY);\n-            addFlag(c_oflag.longValue(), oflag, OutputFlag.OFDEL, OFDEL);\n-            \/\/ Control flags\n-            EnumSet<ControlFlag> cflag = attr.getControlFlags();\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CIGNORE, CIGNORE);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS5, CS5);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS6, CS6);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS7, CS7);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CS8, CS8);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CSTOPB, CSTOPB);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CREAD, CREAD);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.PARENB, PARENB);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.PARODD, PARODD);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.HUPCL, HUPCL);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CLOCAL, CLOCAL);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CCTS_OFLOW, CCTS_OFLOW);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CRTS_IFLOW, CRTS_IFLOW);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CDSR_OFLOW, CDSR_OFLOW);\n-            addFlag(c_cflag.longValue(), cflag, ControlFlag.CCAR_OFLOW, CCAR_OFLOW);\n-            \/\/ Local flags\n-            EnumSet<LocalFlag> lflag = attr.getLocalFlags();\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOKE, ECHOKE);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOE, ECHOE);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOK, ECHOK);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHO, ECHO);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHONL, ECHONL);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOPRT, ECHOPRT);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ECHOCTL, ECHOCTL);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ISIG, ISIG);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ICANON, ICANON);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.ALTWERASE, ALTWERASE);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.IEXTEN, IEXTEN);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.EXTPROC, EXTPROC);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.TOSTOP, TOSTOP);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.FLUSHO, FLUSHO);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.NOKERNINFO, NOKERNINFO);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.PENDIN, PENDIN);\n-            addFlag(c_lflag.longValue(), lflag, LocalFlag.NOFLSH, NOFLSH);\n-            \/\/ Control chars\n-            EnumMap<ControlChar, Integer> cc = attr.getControlChars();\n-            cc.put(ControlChar.VEOF,        (int) c_cc[VEOF]);\n-            cc.put(ControlChar.VEOL,        (int) c_cc[VEOL]);\n-            cc.put(ControlChar.VEOL2,       (int) c_cc[VEOL2]);\n-            cc.put(ControlChar.VERASE,      (int) c_cc[VERASE]);\n-            cc.put(ControlChar.VWERASE,     (int) c_cc[VWERASE]);\n-            cc.put(ControlChar.VKILL,       (int) c_cc[VKILL]);\n-            cc.put(ControlChar.VREPRINT,    (int) c_cc[VREPRINT]);\n-            cc.put(ControlChar.VINTR,       (int) c_cc[VINTR]);\n-            cc.put(ControlChar.VQUIT,       (int) c_cc[VQUIT]);\n-            cc.put(ControlChar.VSUSP,       (int) c_cc[VSUSP]);\n-            cc.put(ControlChar.VDSUSP,      (int) c_cc[VDSUSP]);\n-            cc.put(ControlChar.VSTART,      (int) c_cc[VSTART]);\n-            cc.put(ControlChar.VSTOP,       (int) c_cc[VSTOP]);\n-            cc.put(ControlChar.VLNEXT,      (int) c_cc[VLNEXT]);\n-            cc.put(ControlChar.VDISCARD,    (int) c_cc[VDISCARD]);\n-            cc.put(ControlChar.VMIN,        (int) c_cc[VMIN]);\n-            cc.put(ControlChar.VTIME,       (int) c_cc[VTIME]);\n-            cc.put(ControlChar.VSTATUS,     (int) c_cc[VSTATUS]);\n-            \/\/ Return\n-            return attr;\n-        }\n-\n-        private <T extends Enum<T>> void addFlag(long value, EnumSet<T> flags, T flag, int v) {\n-            if ((value & v) != 0) {\n-                flags.add(flag);\n-            }\n-        }\n-    }\n-\n-    \/\/ CONSTANTS\n-\n-     long TIOCGWINSZ = 0x40087468L;\n-     long TIOCSWINSZ = 0x80087467L;\n-\n-     int TCSANOW     = 0x00000000;\n-\n-     int VEOF        = 0;\n-     int VEOL        = 1;\n-     int VEOL2       = 2;\n-     int VERASE      = 3;\n-     int VWERASE     = 4;\n-     int VKILL       = 5;\n-     int VREPRINT    = 6;\n-     int VINTR       = 8;\n-     int VQUIT       = 9;\n-     int VSUSP       = 10;\n-     int VDSUSP      = 11;\n-     int VSTART      = 12;\n-     int VSTOP       = 13;\n-     int VLNEXT      = 14;\n-     int VDISCARD    = 15;\n-     int VMIN        = 16;\n-     int VTIME       = 17;\n-     int VSTATUS     = 18;\n-\n-     int IGNBRK      = 0x00000001;\n-     int BRKINT      = 0x00000002;\n-     int IGNPAR      = 0x00000004;\n-     int PARMRK      = 0x00000008;\n-     int INPCK       = 0x00000010;\n-     int ISTRIP      = 0x00000020;\n-     int INLCR       = 0x00000040;\n-     int IGNCR       = 0x00000080;\n-     int ICRNL       = 0x00000100;\n-     int IXON        = 0x00000200;\n-     int IXOFF       = 0x00000400;\n-     int IXANY       = 0x00000800;\n-     int IMAXBEL     = 0x00002000;\n-     int IUTF8       = 0x00004000;\n-\n-     int OPOST       = 0x00000001;\n-     int ONLCR       = 0x00000002;\n-     int OXTABS      = 0x00000004;\n-     int ONOEOT      = 0x00000008;\n-     int OCRNL       = 0x00000010;\n-     int ONOCR       = 0x00000020;\n-     int ONLRET      = 0x00000040;\n-     int OFILL       = 0x00000080;\n-     int NLDLY       = 0x00000300;\n-     int TABDLY      = 0x00000c04;\n-     int CRDLY       = 0x00003000;\n-     int FFDLY       = 0x00004000;\n-     int BSDLY       = 0x00008000;\n-     int VTDLY       = 0x00010000;\n-     int OFDEL       = 0x00020000;\n-\n-     int CIGNORE     = 0x00000001;\n-     int CS5         = 0x00000000;\n-     int CS6         = 0x00000100;\n-     int CS7         = 0x00000200;\n-     int CS8         = 0x00000300;\n-     int CSTOPB      = 0x00000400;\n-     int CREAD       = 0x00000800;\n-     int PARENB      = 0x00001000;\n-     int PARODD      = 0x00002000;\n-     int HUPCL       = 0x00004000;\n-     int CLOCAL      = 0x00008000;\n-     int CCTS_OFLOW  = 0x00010000;\n-     int CRTS_IFLOW  = 0x00020000;\n-     int CDTR_IFLOW  = 0x00040000;\n-     int CDSR_OFLOW  = 0x00080000;\n-     int CCAR_OFLOW  = 0x00100000;\n-\n-     int ECHOKE      = 0x00000001;\n-     int ECHOE       = 0x00000002;\n-     int ECHOK       = 0x00000004;\n-     int ECHO        = 0x00000008;\n-     int ECHONL      = 0x00000010;\n-     int ECHOPRT     = 0x00000020;\n-     int ECHOCTL     = 0x00000040;\n-     int ISIG        = 0x00000080;\n-     int ICANON      = 0x00000100;\n-     int ALTWERASE   = 0x00000200;\n-     int IEXTEN      = 0x00000400;\n-     int EXTPROC     = 0x00000800;\n-     int TOSTOP      = 0x00400000;\n-     int FLUSHO      = 0x00800000;\n-     int NOKERNINFO  = 0x02000000;\n-     int PENDIN      = 0x20000000;\n-     int NOFLSH      = 0x80000000;\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary.java","additions":0,"deletions":394,"binary":false,"changes":394,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-public final class CLibraryImpl implements CLibrary {\n-\n-    static {\n-        System.loadLibrary(\"le\");\n-        initIDs();\n-    }\n-\n-    private static native void initIDs();\n-\n-    @Override\n-    public native void tcgetattr(int fd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public native void tcsetattr(int fd, int cmd, termios termios) throws LastErrorException;\n-\n-    @Override\n-    public void ioctl(int fd, NativeLong cmd, winsize data) throws LastErrorException {\n-        if (cmd.longValue() == CLibrary.TIOCGWINSZ || cmd.longValue() == CLibrary.TIOCSWINSZ) {\n-            ioctl0(fd, cmd.longValue(), data);\n-        } else {\n-            throw new UnsupportedOperationException(\"Command: \" + cmd + \", not supported.\");\n-        }\n-    }\n-\n-    private native void ioctl0(int fd, long cmd, winsize data) throws LastErrorException;\n-\n-    @Override\n-    public native int isatty(int fd);\n-\n-    @Override\n-    public native void ttyname_r(int fd, byte[] buf, int len) throws LastErrorException;\n-\n-    @Override\n-    public void openpty(int[] master, int[] slave, byte[] name, termios t, winsize s) throws LastErrorException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibraryImpl.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-class NativeLong {\n-\n-    public long value;\n-\n-    public NativeLong(long value) {\n-        this.value = value;\n-    }\n-\n-    public void setValue(long value) {\n-        this.value = value;\n-    }\n-\n-    public long longValue() {\n-        return value;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.osx;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/\/import com.sun.jna.Native;\n-\/\/import com.sun.jna.NativeLong;\n-\/\/import com.sun.jna.Platform;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.jna.JnaNativePty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TCSANOW;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TIOCGWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.TIOCSWINSZ;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.termios;\n-import static jdk.internal.org.jline.terminal.impl.jna.osx.CLibrary.winsize;\n-\n-public class OsXNativePty extends JnaNativePty {\n-\n-\/\/    private static final CLibrary C_LIBRARY = Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n-    private static final CLibrary C_LIBRARY = new CLibraryImpl();\/\/Native.load(Platform.C_LIBRARY_NAME, CLibrary.class);\n-\n-    public static OsXNativePty current(TerminalProvider.Stream consoleStream) throws IOException {\n-        switch (consoleStream) {\n-            case Output:\n-                return new OsXNativePty(-1, null, 0, FileDescriptor.in, 1, FileDescriptor.out, ttyname(0));\n-            case Error:\n-                return new OsXNativePty(-1, null, 0, FileDescriptor.in, 2, FileDescriptor.err, ttyname(0));\n-            default:\n-                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n-        }\n-    }\n-\n-    public static OsXNativePty open(Attributes attr, Size size) throws IOException {\n-        int[] master = new int[1];\n-        int[] slave = new int[1];\n-        byte[] buf = new byte[64];\n-        C_LIBRARY.openpty(master, slave, buf,\n-                attr != null ? new termios(attr) : null,\n-                size != null ? new winsize(size) : null);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        String name = new String(buf, 0, len);\n-        return new OsXNativePty(master[0], newDescriptor(master[0]), slave[0], newDescriptor(slave[0]), name);\n-    }\n-\n-    public OsXNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n-        super(master, masterFD, slave, slaveFD, name);\n-    }\n-\n-    public OsXNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n-        super(master, masterFD, slave, slaveFD, slaveOut, slaveOutFD, name);\n-    }\n-\n-    @Override\n-    public Attributes getAttr() throws IOException {\n-        termios termios = new termios();\n-        C_LIBRARY.tcgetattr(getSlave(), termios);\n-        return termios.toAttributes();\n-    }\n-\n-    @Override\n-    protected void doSetAttr(Attributes attr) throws IOException {\n-        termios termios = new termios(attr);\n-        C_LIBRARY.tcsetattr(getSlave(), TCSANOW, termios);\n-    }\n-\n-    @Override\n-    public Size getSize() throws IOException {\n-        winsize sz = new winsize();\n-        C_LIBRARY.ioctl(getSlave(), new NativeLong(TIOCGWINSZ), sz);\n-        return sz.toSize();\n-    }\n-\n-    @Override\n-    public void setSize(Size size) throws IOException {\n-        winsize sz = new winsize(size);\n-        C_LIBRARY.ioctl(getSlave(), new NativeLong(TIOCSWINSZ), sz);\n-    }\n-\n-    public static int isatty(int fd) {\n-        return C_LIBRARY.isatty(fd);\n-    }\n-\n-    public static String ttyname(int fd) {\n-        byte[] buf = new byte[64];\n-        C_LIBRARY.ttyname_r(fd, buf, buf.length);\n-        int len = 0;\n-        while (buf[len] != 0) {\n-            len++;\n-        }\n-        return new String(buf, 0, len);\n-    }\n-}\n","filename":"src\/jdk.internal.le\/macosx\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/OsXNativePty.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <termios.h>\n-#include <unistd.h>\n-#include <sys\/ioctl.h>\n-\n-static jclass lastErrorExceptionClass;\n-static jmethodID lastErrorExceptionConstructor;\n-\n-static jclass termios_j;\n-static jfieldID c_iflag;\n-static jfieldID c_oflag;\n-static jfieldID c_cflag;\n-static jfieldID c_lflag;\n-static jfieldID c_cc;\n-static jfieldID c_ispeed;\n-static jfieldID c_ospeed;\n-\n-static jclass winsize_j;\n-static jfieldID ws_row;\n-static jfieldID ws_col;\n-static jfieldID ws_xpixel;\n-static jfieldID ws_ypixel;\n-\n-static jclass nativelong_j;\n-static jfieldID nativelong_value;\n-\n-static void throw_errno(JNIEnv *env);\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_initIDs\n-  (JNIEnv *env, jclass) {\n-    jclass cls;\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n-    CHECK_NULL(cls);\n-    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n-    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n-    CHECK_NULL(lastErrorExceptionConstructor);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary$termios\");\n-    CHECK_NULL(cls);\n-    termios_j = (jclass) env->NewGlobalRef(cls);\n-    CHECK_NULL(termios_j);\n-    c_iflag = env->GetFieldID(termios_j, \"c_iflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_iflag);\n-    c_oflag = env->GetFieldID(termios_j, \"c_oflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_oflag);\n-    c_cflag = env->GetFieldID(termios_j, \"c_cflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_cflag);\n-    c_lflag = env->GetFieldID(termios_j, \"c_lflag\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_lflag);\n-    c_cc = env->GetFieldID(termios_j, \"c_cc\", \"[B\");\n-    CHECK_NULL(c_cc);\n-    c_ispeed = env->GetFieldID(termios_j, \"c_ispeed\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_ispeed);\n-    c_ospeed = env->GetFieldID(termios_j, \"c_ospeed\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong;\");\n-    CHECK_NULL(c_ospeed);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary$winsize\");\n-    CHECK_NULL(cls);\n-    winsize_j = (jclass) env->NewGlobalRef(cls);\n-    ws_row = env->GetFieldID(winsize_j, \"ws_row\", \"S\");\n-    CHECK_NULL(ws_row);\n-    ws_col = env->GetFieldID(winsize_j, \"ws_col\", \"S\");\n-    CHECK_NULL(ws_col);\n-    ws_xpixel= env->GetFieldID(winsize_j, \"ws_xpixel\", \"S\");\n-    CHECK_NULL(ws_xpixel);\n-    ws_ypixel= env->GetFieldID(winsize_j, \"ws_ypixel\", \"S\");\n-    CHECK_NULL(ws_ypixel);\n-\n-    nativelong_j = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/NativeLong\");\n-    CHECK_NULL(nativelong_j);\n-    nativelong_value = env->GetFieldID(nativelong_j, \"value\", \"J\");\n-    CHECK_NULL(nativelong_value);\n-}\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_tcgetattr\n-  (JNIEnv *env, jobject, jint fd, jobject result) {\n-    termios data;\n-\n-    if (tcgetattr(fd, &data) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetLongField(env->GetObjectField(result, c_iflag), nativelong_value, data.c_iflag);\n-    env->SetLongField(env->GetObjectField(result, c_oflag), nativelong_value, data.c_oflag);\n-    env->SetLongField(env->GetObjectField(result, c_cflag), nativelong_value, data.c_cflag);\n-    env->SetLongField(env->GetObjectField(result, c_lflag), nativelong_value, data.c_lflag);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(result, c_cc);\n-    env->SetByteArrayRegion(c_ccValue, 0, NCCS, (signed char *) data.c_cc);\n-    env->SetLongField(env->GetObjectField(result, c_ispeed), nativelong_value, data.c_ispeed);\n-    env->SetLongField(env->GetObjectField(result, c_ospeed), nativelong_value, data.c_ospeed);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    tcsetattr\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary\/termios;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_tcsetattr\n-  (JNIEnv *env, jobject, jint fd, jint cmd, jobject input) {\n-    termios data;\n-\n-    data.c_iflag = env->GetLongField(env->GetObjectField(input, c_iflag), nativelong_value);\n-    data.c_oflag = env->GetLongField(env->GetObjectField(input, c_oflag), nativelong_value);\n-    data.c_cflag = env->GetLongField(env->GetObjectField(input, c_cflag), nativelong_value);\n-    data.c_lflag = env->GetLongField(env->GetObjectField(input, c_lflag), nativelong_value);\n-    jbyteArray c_ccValue = (jbyteArray) env->GetObjectField(input, c_cc);\n-    env->GetByteArrayRegion(c_ccValue, 0, NCCS, (jbyte *) data.c_cc);\n-    data.c_ispeed = env->GetLongField(env->GetObjectField(input, c_ispeed), nativelong_value);\n-    data.c_ospeed = env->GetLongField(env->GetObjectField(input, c_ospeed), nativelong_value);\n-\n-    if (tcsetattr(fd, cmd, &data) != 0) {\n-        throw_errno(env);\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    ioctl0\n- * Signature: (IILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/osx\/CLibrary\/winsize;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_ioctl0\n-  (JNIEnv *env, jobject, jint fd, jlong cmd, jobject data) {\n-    winsize ws;\n-\n-    ws.ws_row = env->GetShortField(data, ws_row);\n-    ws.ws_col = env->GetShortField(data, ws_col);\n-    ws.ws_xpixel = env->GetShortField(data, ws_xpixel);\n-    ws.ws_ypixel = env->GetShortField(data, ws_ypixel);\n-\n-    if (ioctl(fd, cmd, &ws) != 0) {\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetShortField(data, ws_row, ws.ws_row);\n-    env->SetShortField(data, ws_col, ws.ws_col);\n-    env->SetShortField(data, ws_xpixel, ws.ws_xpixel);\n-    env->SetShortField(data, ws_ypixel, ws.ws_ypixel);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    isatty\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_isatty\n-  (JNIEnv *, jobject, jint fd) {\n-    return isatty(fd);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl\n- * Method:    ttyname_r\n- * Signature: (I[BI)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_osx_CLibraryImpl_ttyname_1r\n-  (JNIEnv *env, jobject, jint fd, jbyteArray buf, jint len) {\n-    char *data = new char[len];\n-    int error = ttyname_r(fd, data, len);\n-\n-    if (error != 0) {\n-        delete[] data;\n-        throw_errno(env);\n-        return ;\n-    }\n-\n-    env->SetByteArrayRegion(buf, 0, len, (jbyte *) data);\n-    delete[] data;\n-}\n-\n-\/*\n- * Throws LastErrorException based on the errno:\n- *\/\n-static void throw_errno(JNIEnv *env) {\n-    jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                 lastErrorExceptionConstructor,\n-                                 errno);\n-    env->Throw((jthrowable) exc);\n-}\n","filename":"src\/jdk.internal.le\/macosx\/native\/lible\/CLibrary.cpp","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Locale;\n@@ -41,0 +42,1 @@\n+import jdk.internal.org.jline.terminal.TerminalBuilder.SystemOutput;\n@@ -54,1 +56,3 @@\n-                                               .exec(false).build();\n+                                               .exec(false)\n+                                               .systemOutput(SystemOutput.SysOut)\n+                                               .build();\n@@ -84,2 +88,2 @@\n-        public JdkConsole format(String fmt, Object ... args) {\n-            writer().format(fmt, args).flush();\n+        public JdkConsole format(Locale locale, String format, Object ... args) {\n+            writer().format(locale, format, args).flush();\n@@ -90,6 +94,1 @@\n-        public JdkConsole printf(String format, Object ... args) {\n-            return format(format, args);\n-        }\n-\n-        @Override\n-        public String readLine(String fmt, Object ... args) {\n+        public String readLine(Locale locale, String format, Object ... args) {\n@@ -98,1 +97,1 @@\n-                return jline.readLine(fmt.formatted(args));\n+                return jline.readLine(String.format(locale, format, args).replace(\"%\", \"%%\"));\n@@ -106,1 +105,1 @@\n-            return readLine(\"\");\n+            return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n@@ -110,1 +109,1 @@\n-        public char[] readPassword(String fmt, Object ... args) {\n+        public char[] readPassword(Locale locale, String format, Object ... args) {\n@@ -113,1 +112,2 @@\n-                return jline.readLine(fmt.formatted(args), '\\0').toCharArray();\n+                return jline.readLine(String.format(locale, format, args).replace(\"%\", \"%%\"), '\\0')\n+                            .toCharArray();\n@@ -123,1 +123,1 @@\n-            return readPassword(\"\");\n+            return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -69,1 +69,1 @@\n-        for (;;) {\n+        for (; ; ) {\n@@ -81,2 +81,1 @@\n-                }\n-                else {\n+                } else {\n@@ -237,1 +236,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/keymap\/BindingReader.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -11,2 +11,0 @@\n-import java.io.IOException;\n-import java.io.StringWriter;\n@@ -221,1 +219,0 @@\n-\n@@ -267,1 +264,0 @@\n-\n@@ -309,3 +305,1 @@\n-                doGetBoundKeys((KeyMap<T>) keyMap.mapping[c],\n-                        prefix + (char) (c),\n-                        bound);\n+                doGetBoundKeys((KeyMap<T>) keyMap.mapping[c], prefix + (char) (c), bound);\n@@ -459,1 +453,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/keymap\/KeyMap.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -17,1 +17,1 @@\n- * @see jdk.internal.org.jline.keymap.KeyMap\n+ * @see org.jline.keymap.KeyMap\n@@ -21,2 +21,1 @@\n-public interface Binding {\n-}\n+public interface Binding {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Binding.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -87,4 +87,4 @@\n-    \/\/ JDK specific modification\n-    default void zeroOut() {\n-        throw new UnsupportedOperationException();\n-    }\n+    \/**\n+     * Clear any internal buffer.\n+     *\/\n+    void zeroOut();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Buffer.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -50,1 +50,9 @@\n-    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete, int sort) {\n+    public Candidate(\n+            String value,\n+            String displ,\n+            String group,\n+            String descr,\n+            String suffix,\n+            String key,\n+            boolean complete,\n+            int sort) {\n@@ -72,1 +80,2 @@\n-    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+    public Candidate(\n+            String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n@@ -162,1 +171,0 @@\n-\n@@ -166,1 +174,1 @@\n-        if( sort == o.sort() ) {\n+        if (sort == o.sort()) {\n@@ -183,1 +191,1 @@\n-        return Objects.hash(value);\n+        return Objects.hashCode(value);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Candidate.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -21,2 +21,1 @@\n-public interface Completer\n-{\n+public interface Completer {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Completer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -13,1 +13,1 @@\n- * of the {@link jdk.internal.org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n+ * of the {@link org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n@@ -25,1 +25,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletingParsedLine.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -26,2 +26,7 @@\n-    void compile(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n-            , boolean caseInsensitive, int errors, String originalGroupName);\n+    void compile(\n+            Map<LineReader.Option, Boolean> options,\n+            boolean prefix,\n+            CompletingParsedLine line,\n+            boolean caseInsensitive,\n+            int errors,\n+            String originalGroupName);\n@@ -47,1 +52,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletionMatcher.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,7 +2,1 @@\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Copyright (c) 2023, the original author(s).\n@@ -10,1 +4,2 @@\n- *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n@@ -12,6 +7,1 @@\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n@@ -48,1 +38,1 @@\n-    public int getOpenBrackets(){\n+    public int getOpenBrackets() {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/EOFError.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -16,0 +16,1 @@\n+\n@@ -17,0 +18,1 @@\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Editor.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -20,2 +20,1 @@\n-    public EndOfFileException() {\n-    }\n+    public EndOfFileException() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/EndOfFileException.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -16,1 +16,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Expander.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Highlighter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -24,2 +24,1 @@\n-public interface History extends Iterable<History.Entry>\n-{\n+public interface History extends Iterable<History.Entry> {\n@@ -78,1 +77,0 @@\n-\n@@ -113,2 +111,1 @@\n-    interface Entry\n-    {\n+    interface Entry {\n@@ -135,0 +132,1 @@\n+\n@@ -139,0 +137,1 @@\n+\n@@ -143,0 +142,1 @@\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/History.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2023, the original author(s).\n@@ -24,1 +24,1 @@\n- * <h3>Thread safety<\/h3>\n+ * <h2>Thread safety<\/h2>\n@@ -34,1 +34,1 @@\n- * <h3>Prompt strings<\/h3>\n+ * <h2>Prompt strings<\/h2>\n@@ -84,1 +84,0 @@\n-\n@@ -287,0 +286,1 @@\n+    String DUMB = \"dumb\";\n@@ -304,0 +304,1 @@\n+\n@@ -320,0 +321,1 @@\n+\n@@ -323,0 +325,1 @@\n+\n@@ -326,0 +329,1 @@\n+\n@@ -329,0 +333,1 @@\n+\n@@ -332,0 +337,1 @@\n+\n@@ -393,0 +399,20 @@\n+    \/**\n+     * Max number of times a command can be repeated.\n+     *\/\n+    String MAX_REPEAT_COUNT = \"max-repeat-count\";\n+\n+    \/**\n+     * Number of spaces to display a tabulation, the default is 4.\n+     *\/\n+    String TAB_WIDTH = \"tab-width\";\n+\n+    \/**\n+     * Name of inputrc to read at line reader creation time.\n+     *\/\n+    String INPUT_RC_FILE_NAME = \"input-rc-file-name\";\n+\n+    \/**\n+     * Prefix to automatically delegate variables to system properties\n+     *\/\n+    String SYSTEM_PROPERTY_PREFIX = \"system-property-prefix\";\n+\n@@ -472,2 +498,1 @@\n-        DISABLE_UNDO\n-        ;\n+        DISABLE_UNDO;\n@@ -614,1 +639,2 @@\n-    String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException;\n+    String readLine(String prompt, String rightPrompt, Character mask, String buffer)\n+            throws UserInterruptException, EndOfFileException;\n@@ -634,1 +660,2 @@\n-    String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException;\n+    String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer)\n+            throws UserInterruptException, EndOfFileException;\n@@ -705,1 +732,1 @@\n-     * Read a mouse event when the {@link jdk.internal.org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n+     * Read a mouse event when the {@link org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n@@ -754,4 +781,4 @@\n-    \/\/ JDK specific modification\n-    default void zeroOut() {\n-        throw new UnsupportedOperationException();\n-    }\n+    \/**\n+     * Clear any internal buffers.\n+     *\/\n+    void zeroOut();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReader.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -41,2 +41,1 @@\n-    private LineReaderBuilder() {\n-    }\n+    private LineReaderBuilder() {}\n@@ -91,2 +90,3 @@\n-                    Log.warn(\"The Parser of class \" + parser.getClass().getName() + \" does not support the CompletingParsedLine interface. \" +\n-                            \"Completion with escaped or quoted words won't work correctly.\");\n+                    Log.warn(\"The Parser of class \" + parser.getClass().getName()\n+                            + \" does not support the CompletingParsedLine interface. \"\n+                            + \"Completion with escaped or quoted words won't work correctly.\");\n@@ -156,1 +156,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReaderBuilder.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -38,2 +38,1 @@\n-        return \"Macro[\" +\n-                sequence + ']';\n+        return \"Macro[\" + sequence + ']';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Macro.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -34,1 +34,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/MaskingCallback.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -67,1 +67,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/ParsedLine.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -38,1 +38,1 @@\n-        Pattern  patternCommand = Pattern.compile(\"^\\\\s*\" + REGEX_VARIABLE + \"=(\" + REGEX_COMMAND + \")(\\\\s+|$)\");\n+        Pattern patternCommand = Pattern.compile(\"^\\\\s*\" + REGEX_VARIABLE + \"=(\" + REGEX_COMMAND + \")(\\\\s+|$)\");\n@@ -53,1 +53,1 @@\n-        Pattern  patternCommand = Pattern.compile(\"^\\\\s*(\" + REGEX_VARIABLE + \")\\\\s*=[^=~].*\");\n+        Pattern patternCommand = Pattern.compile(\"^\\\\s*(\" + REGEX_VARIABLE + \")\\\\s*=[^=~].*\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Parser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/PrintAboveWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -41,2 +41,1 @@\n-        return \"Reference[\" +\n-                name + ']';\n+        return \"Reference[\" + name + ']';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Reference.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,7 +2,1 @@\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n+ * Copyright (c) 2023, the original author(s).\n@@ -10,1 +4,2 @@\n- *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n@@ -12,6 +7,1 @@\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/SyntaxError.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -17,3 +17,1 @@\n-public class UserInterruptException\n-    extends RuntimeException\n-{\n+public class UserInterruptException extends RuntimeException {\n@@ -24,2 +22,1 @@\n-    public UserInterruptException(String partialLine)\n-    {\n+    public UserInterruptException(String partialLine) {\n@@ -32,2 +29,1 @@\n-    public String getPartialLine()\n-    {\n+    public String getPartialLine() {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/UserInterruptException.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -18,1 +18,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Widget.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -23,2 +23,1 @@\n-public class BufferImpl implements Buffer\n-{\n+public class BufferImpl implements Buffer {\n@@ -49,1 +48,1 @@\n-    public BufferImpl copy () {\n+    public BufferImpl copy() {\n@@ -110,1 +109,1 @@\n-        write(new int[] { c });\n+        write(new int[] {c});\n@@ -124,1 +123,1 @@\n-        write(new int[] { c });\n+        write(new int[] {c});\n@@ -227,2 +226,1 @@\n-        }\n-        else if ((cursor + where) > length()) {\n+        } else if ((cursor + where) > length()) {\n@@ -374,1 +372,0 @@\n-    \/\/ JDK specific modification\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/BufferImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -11,6 +11,0 @@\n-import jdk.internal.org.jline.reader.Candidate;\n-import jdk.internal.org.jline.reader.CompletingParsedLine;\n-import jdk.internal.org.jline.reader.CompletionMatcher;\n-import jdk.internal.org.jline.reader.LineReader;\n-import jdk.internal.org.jline.utils.AttributedString;\n-\n@@ -23,0 +17,6 @@\n+import jdk.internal.org.jline.reader.Candidate;\n+import jdk.internal.org.jline.reader.CompletingParsedLine;\n+import jdk.internal.org.jline.reader.CompletionMatcher;\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.utils.AttributedString;\n+\n@@ -29,2 +29,1 @@\n-    public CompletionMatcherImpl() {\n-    }\n+    public CompletionMatcherImpl() {}\n@@ -40,2 +39,7 @@\n-    public void compile(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n-            , boolean caseInsensitive, int errors, String originalGroupName) {\n+    public void compile(\n+            Map<LineReader.Option, Boolean> options,\n+            boolean prefix,\n+            CompletingParsedLine line,\n+            boolean caseInsensitive,\n+            int errors,\n+            String originalGroupName) {\n@@ -50,2 +54,1 @@\n-        for (Function<Map<String, List<Candidate>>,\n-                Map<String, List<Candidate>>> matcher : matchers) {\n+        for (Function<Map<String, List<Candidate>>, Map<String, List<Candidate>>> matcher : matchers) {\n@@ -57,2 +60,6 @@\n-        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).distinct().collect(Collectors.toList())\n-                                   : new ArrayList<>();\n+        return !matching.isEmpty()\n+                ? matching.entrySet().stream()\n+                        .flatMap(e -> e.getValue().stream())\n+                        .distinct()\n+                        .collect(Collectors.toList())\n+                : new ArrayList<>();\n@@ -66,1 +73,2 @@\n-        return matching.values().stream().flatMap(Collection::stream)\n+        return matching.values().stream()\n+                .flatMap(Collection::stream)\n@@ -69,1 +77,2 @@\n-                .findFirst().orElse(null);\n+                .findFirst()\n+                .orElse(null);\n@@ -87,2 +96,7 @@\n-    protected void defaultMatchers(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n-            , boolean caseInsensitive, int errors, String originalGroupName) {\n+    protected void defaultMatchers(\n+            Map<LineReader.Option, Boolean> options,\n+            boolean prefix,\n+            CompletingParsedLine line,\n+            boolean caseInsensitive,\n+            int errors,\n+            String originalGroupName) {\n@@ -97,2 +111,1 @@\n-                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wp))\n-            ));\n+                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wp))));\n@@ -112,3 +125,4 @@\n-                        simpleMatcher(s -> p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),\n-                        simpleMatcher(s -> p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches())\n-                ));\n+                        simpleMatcher(s -> p1.matcher(caseInsensitive ? s.toLowerCase() : s)\n+                                .matches()),\n+                        simpleMatcher(s -> p2.matcher(caseInsensitive ? s.toLowerCase() : s)\n+                                .matches())));\n@@ -118,2 +132,1 @@\n-                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi))\n-                ));\n+                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi))));\n@@ -131,2 +144,2 @@\n-    protected Function<Map<String, List<Candidate>>,\n-            Map<String, List<Candidate>>> simpleMatcher(Predicate<String> predicate) {\n+    protected Function<Map<String, List<Candidate>>, Map<String, List<Candidate>>> simpleMatcher(\n+            Predicate<String> predicate) {\n@@ -138,2 +151,2 @@\n-    protected Function<Map<String, List<Candidate>>,\n-            Map<String, List<Candidate>>> typoMatcher(String word, int errors, boolean caseInsensitive, String originalGroupName) {\n+    protected Function<Map<String, List<Candidate>>, Map<String, List<Candidate>>> typoMatcher(\n+            String word, int errors, boolean caseInsensitive, String originalGroupName) {\n@@ -142,1 +155,3 @@\n-                    .filter(e -> ReaderUtils.distance(word, caseInsensitive ? e.getKey().toLowerCase() : e.getKey()) < errors)\n+                    .filter(e -> ReaderUtils.distance(\n+                                    word, caseInsensitive ? e.getKey().toLowerCase() : e.getKey())\n+                            < errors)\n@@ -181,1 +196,2 @@\n-                    .computeIfAbsent(AttributedString.fromAnsi(candidate.value()).toString(), s -> new ArrayList<>())\n+                    .computeIfAbsent(\n+                            AttributedString.fromAnsi(candidate.value()).toString(), s -> new ArrayList<>())\n@@ -209,2 +225,1 @@\n-\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/CompletionMatcherImpl.java","additions":49,"deletions":34,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -35,2 +35,1 @@\n-            }\n-            else if (escaped) {\n+            } else if (escaped) {\n@@ -43,2 +42,1 @@\n-            }\n-            else if (c == '\\'') {\n+            } else if (c == '\\'') {\n@@ -47,2 +45,1 @@\n-            }\n-            else if (inQuote) {\n+            } else if (inQuote) {\n@@ -50,2 +47,1 @@\n-            }\n-            else {\n+            } else {\n@@ -54,2 +50,4 @@\n-                        \/\/ any '\\!' should be considered an expansion escape, so skip expansion and strip the escape character\n-                        \/\/ a leading '\\^' should be considered an expansion escape, so skip expansion and strip the escape character\n+                        \/\/ any '\\!' should be considered an expansion escape, so skip expansion and strip the escape\n+                        \/\/ character\n+                        \/\/ a leading '\\^' should be considered an expansion escape, so skip expansion and strip the\n+                        \/\/ escape character\n@@ -94,1 +92,2 @@\n-                                    String previous = history.get(history.index() - 1).trim();\n+                                    String previous =\n+                                            history.get(history.index() - 1).trim();\n@@ -131,1 +130,2 @@\n-                                        throw new IllegalArgumentException((neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n+                                        throw new IllegalArgumentException(\n+                                                (neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n@@ -135,1 +135,3 @@\n-                                    } else if (!neg && idx > history.index() - history.size() && idx <= history.index()) {\n+                                    } else if (!neg\n+                                            && idx > history.index() - history.size()\n+                                            && idx <= history.index()) {\n@@ -138,1 +140,2 @@\n-                                        throw new IllegalArgumentException((neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n+                                        throw new IllegalArgumentException(\n+                                                (neg ? \"!-\" : \"!\") + line.substring(i1, i) + \": event not found\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultExpander.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -13,0 +13,1 @@\n+import jdk.internal.org.jline.reader.Highlighter;\n@@ -15,1 +16,0 @@\n-import jdk.internal.org.jline.reader.Highlighter;\n@@ -60,1 +60,2 @@\n-                while (negativeEnd < reader.getBuffer().length() - 1 && reader.getBuffer().atChar(negativeEnd + 1) != '\\n') {\n+                while (negativeEnd < reader.getBuffer().length() - 1\n+                        && reader.getBuffer().atChar(negativeEnd + 1) != '\\n') {\n@@ -107,1 +108,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultHighlighter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -24,4 +24,4 @@\n-        ROUND,   \/\/ ()\n-        CURLY,   \/\/ {}\n-        SQUARE,  \/\/ []\n-        ANGLE    \/\/ <>\n+        ROUND, \/\/ ()\n+        CURLY, \/\/ {}\n+        SQUARE, \/\/ []\n+        ANGLE \/\/ <>\n@@ -33,0 +33,1 @@\n+\n@@ -34,2 +35,1 @@\n-            if (start == null || end == null\n-              || start.isEmpty() || end.isEmpty() || start.equals(end)) {\n+            if (start == null || end == null || start.isEmpty() || end.isEmpty() || start.equals(end)) {\n@@ -188,16 +188,16 @@\n-                case ROUND:\n-                    openingBrackets[i] = '(';\n-                    closingBrackets[i] = ')';\n-                    break;\n-                case CURLY:\n-                    openingBrackets[i] = '{';\n-                    closingBrackets[i] = '}';\n-                    break;\n-                case SQUARE:\n-                    openingBrackets[i] = '[';\n-                    closingBrackets[i] = ']';\n-                    break;\n-                case ANGLE:\n-                    openingBrackets[i] = '<';\n-                    closingBrackets[i] = '>';\n-                    break;\n+                    case ROUND:\n+                        openingBrackets[i] = '(';\n+                        closingBrackets[i] = ')';\n+                        break;\n+                    case CURLY:\n+                        openingBrackets[i] = '{';\n+                        closingBrackets[i] = '}';\n+                        break;\n+                    case SQUARE:\n+                        openingBrackets[i] = '[';\n+                        closingBrackets[i] = ']';\n+                        break;\n+                    case ANGLE:\n+                        openingBrackets[i] = '<';\n+                        closingBrackets[i] = '>';\n+                        break;\n@@ -232,1 +232,0 @@\n-\n@@ -299,1 +298,1 @@\n-                if (current.length()==0) {\n+                if (current.length() == 0) {\n@@ -327,1 +326,2 @@\n-                    rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                    rawWordLength = handleDelimiterAndGetRawWordLength(\n+                            current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n@@ -333,1 +333,2 @@\n-                } else if (quoteStart < 0 && !lineCommented\n+                } else if (quoteStart < 0\n+                        && !lineCommented\n@@ -342,1 +343,2 @@\n-                        rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                        rawWordLength = handleDelimiterAndGetRawWordLength(\n+                                current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n@@ -346,2 +348,1 @@\n-                } else if (quoteStart < 0 && !lineCommented\n-                        && isCommentDelim(line, i, blockCommentEnd)) {\n+                } else if (quoteStart < 0 && !lineCommented && isCommentDelim(line, i, blockCommentEnd)) {\n@@ -380,2 +381,2 @@\n-                throw new EOFError(-1, -1, \"Missing closing quote\", line.charAt(quoteStart) == '\\''\n-                        ? \"quote\" : \"dquote\");\n+                throw new EOFError(\n+                        -1, -1, \"Missing closing quote\", line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n@@ -384,2 +385,1 @@\n-                throw new EOFError(-1, -1, \"Missing closing block comment delimiter\",\n-                        \"add: \" + blockCommentEnd);\n+                throw new EOFError(-1, -1, \"Missing closing block comment delimiter\", \"add: \" + blockCommentEnd);\n@@ -388,2 +388,1 @@\n-                throw new EOFError(-1, -1, \"Missing opening block comment delimiter\",\n-                        \"missing: \" + blockCommentStart);\n+                throw new EOFError(-1, -1, \"Missing opening block comment delimiter\", \"missing: \" + blockCommentStart);\n@@ -401,2 +400,7 @@\n-                throw new EOFError(-1, -1, message, missing,\n-                        bracketChecker.getOpenBrackets(), bracketChecker.getNextClosingBracket());\n+                throw new EOFError(\n+                        -1,\n+                        -1,\n+                        message,\n+                        missing,\n+                        bracketChecker.getOpenBrackets(),\n+                        bracketChecker.getNextClosingBracket());\n@@ -423,1 +427,7 @@\n-    private int handleDelimiterAndGetRawWordLength(StringBuilder current, List<String> words, int rawWordStart, int rawWordCursor, int rawWordLength, int pos) {\n+    private int handleDelimiterAndGetRawWordLength(\n+            StringBuilder current,\n+            List<String> words,\n+            int rawWordStart,\n+            int rawWordCursor,\n+            int rawWordLength,\n+            int pos) {\n@@ -473,1 +483,1 @@\n-            for (String comment: lineCommentDelims) {\n+            for (String comment : lineCommentDelims) {\n@@ -587,2 +597,2 @@\n-                    if (!nested.isEmpty() && bid == nested.get(nested.size()-1)) {\n-                        nested.remove(nested.size()-1);\n+                    if (!nested.isEmpty() && bid == nested.get(nested.size() - 1)) {\n+                        nested.remove(nested.size() - 1);\n@@ -637,1 +647,1 @@\n-            for (int i=0; i < brackets.length; i++) {\n+            for (int i = 0; i < brackets.length; i++) {\n@@ -651,2 +661,1 @@\n-    public class ArgumentList implements ParsedLine, CompletingParsedLine\n-    {\n+    public class ArgumentList implements ParsedLine, CompletingParsedLine {\n@@ -670,5 +679,15 @@\n-        public ArgumentList(final String line, final List<String> words,\n-                            final int wordIndex, final int wordCursor,\n-                            final int cursor) {\n-            this(line, words, wordIndex, wordCursor, cursor,\n-                    null, wordCursor, words.get(wordIndex).length());\n+        public ArgumentList(\n+                final String line,\n+                final List<String> words,\n+                final int wordIndex,\n+                final int wordCursor,\n+                final int cursor) {\n+            this(\n+                    line,\n+                    words,\n+                    wordIndex,\n+                    wordCursor,\n+                    cursor,\n+                    null,\n+                    wordCursor,\n+                    words.get(wordIndex).length());\n@@ -688,4 +707,9 @@\n-        public ArgumentList(final String line, final List<String> words,\n-                            final int wordIndex, final int wordCursor,\n-                            final int cursor, final String openingQuote,\n-                            final int rawWordCursor, final int rawWordLength) {\n+        public ArgumentList(\n+                final String line,\n+                final List<String> words,\n+                final int wordIndex,\n+                final int wordCursor,\n+                final int cursor,\n+                final String openingQuote,\n+                final int rawWordCursor,\n+                final int rawWordLength) {\n@@ -735,2 +759,2 @@\n-            if (openingQuote==null) {\n-                for (int i=0; i < sb.length(); i++) {\n+            if (openingQuote == null) {\n+                for (int i = 0; i < sb.length(); i++) {\n@@ -749,1 +773,2 @@\n-                        needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);\n+                        needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i))\n+                                || String.valueOf(sb.charAt(i)).equals(openingQuote);\n@@ -759,2 +784,2 @@\n-                        needToBeEscaped = i -> isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i))\n-                                || isRawQuoteChar(sb.charAt(i));\n+                        needToBeEscaped = i ->\n+                                isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));\n@@ -795,1 +820,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultParser.java","additions":84,"deletions":60,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright (c) 2002-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.reader.impl;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.reader.Macro;\n+import jdk.internal.org.jline.reader.Reference;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.utils.Log;\n+\n+public final class InputRC {\n+\n+    public static void configure(LineReader reader, URL url) throws IOException {\n+        try (InputStream is = url.openStream()) {\n+            configure(reader, is);\n+        }\n+    }\n+\n+    public static void configure(LineReader reader, InputStream is) throws IOException {\n+        try (InputStreamReader r = new InputStreamReader(is)) {\n+            configure(reader, r);\n+        }\n+    }\n+\n+    public static void configure(LineReader reader, Reader r) throws IOException {\n+        BufferedReader br;\n+        if (r instanceof BufferedReader) {\n+            br = (BufferedReader) r;\n+        } else {\n+            br = new BufferedReader(r);\n+        }\n+\n+        Terminal terminal = reader.getTerminal();\n+\n+        if (Terminal.TYPE_DUMB.equals(terminal.getType()) || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType())) {\n+            reader.getVariables().putIfAbsent(LineReader.EDITING_MODE, \"dumb\");\n+        } else {\n+            reader.getVariables().putIfAbsent(LineReader.EDITING_MODE, \"emacs\");\n+        }\n+\n+        reader.setKeyMap(LineReader.MAIN);\n+        new InputRC(reader).parse(br);\n+        if (\"vi\".equals(reader.getVariable(LineReader.EDITING_MODE))) {\n+            reader.getKeyMaps().put(LineReader.MAIN, reader.getKeyMaps().get(LineReader.VIINS));\n+        } else if (\"emacs\".equals(reader.getVariable(LineReader.EDITING_MODE))) {\n+            reader.getKeyMaps().put(LineReader.MAIN, reader.getKeyMaps().get(LineReader.EMACS));\n+        } else if (\"dumb\".equals(reader.getVariable(LineReader.EDITING_MODE))) {\n+            reader.getKeyMaps().put(LineReader.MAIN, reader.getKeyMaps().get(LineReader.DUMB));\n+        }\n+    }\n+\n+    private final LineReader reader;\n+\n+    private InputRC(LineReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    private void parse(BufferedReader br) throws IOException, IllegalArgumentException {\n+        String line;\n+        boolean parsing = true;\n+        List<Boolean> ifsStack = new ArrayList<>();\n+        while ((line = br.readLine()) != null) {\n+            try {\n+                line = line.trim();\n+                if (line.length() == 0) {\n+                    continue;\n+                }\n+                if (line.charAt(0) == '#') {\n+                    continue;\n+                }\n+                int i = 0;\n+                if (line.charAt(i) == '$') {\n+                    String cmd;\n+                    String args;\n+                    ++i;\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    int s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    cmd = line.substring(s, i);\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    args = line.substring(s, i);\n+                    if (\"if\".equalsIgnoreCase(cmd)) {\n+                        ifsStack.add(parsing);\n+                        if (!parsing) {\n+                            continue;\n+                        }\n+                        if (args.startsWith(\"term=\")) {\n+                            \/\/ TODO\n+                        } else if (args.startsWith(\"mode=\")) {\n+                            String mode = (String) reader.getVariable(LineReader.EDITING_MODE);\n+                            parsing = args.substring(\"mode=\".length()).equalsIgnoreCase(mode);\n+                        } else {\n+                            parsing = args.equalsIgnoreCase(reader.getAppName());\n+                        }\n+                    } else if (\"else\".equalsIgnoreCase(cmd)) {\n+                        if (ifsStack.isEmpty()) {\n+                            throw new IllegalArgumentException(\"$else found without matching $if\");\n+                        }\n+                        boolean invert = true;\n+                        for (boolean b : ifsStack) {\n+                            if (!b) {\n+                                invert = false;\n+                                break;\n+                            }\n+                        }\n+                        if (invert) {\n+                            parsing = !parsing;\n+                        }\n+                    } else if (\"endif\".equalsIgnoreCase(cmd)) {\n+                        if (ifsStack.isEmpty()) {\n+                            throw new IllegalArgumentException(\"endif found without matching $if\");\n+                        }\n+                        parsing = ifsStack.remove(ifsStack.size() - 1);\n+                    } else if (\"include\".equalsIgnoreCase(cmd)) {\n+                        \/\/ TODO\n+                    }\n+                    continue;\n+                }\n+                if (!parsing) {\n+                    continue;\n+                }\n+                if (line.charAt(i++) == '\"') {\n+                    boolean esc = false;\n+                    for (; ; i++) {\n+                        if (i >= line.length()) {\n+                            throw new IllegalArgumentException(\"Missing closing quote on line '\" + line + \"'\");\n+                        }\n+                        if (esc) {\n+                            esc = false;\n+                        } else if (line.charAt(i) == '\\\\') {\n+                            esc = true;\n+                        } else if (line.charAt(i) == '\"') {\n+                            break;\n+                        }\n+                    }\n+                }\n+                while (i < line.length() && line.charAt(i) != ':' && line.charAt(i) != ' ' && line.charAt(i) != '\\t') {\n+                    i++;\n+                }\n+                String keySeq = line.substring(0, i);\n+                boolean equivalency = i + 1 < line.length() && line.charAt(i) == ':' && line.charAt(i + 1) == '=';\n+                i++;\n+                if (equivalency) {\n+                    i++;\n+                }\n+                if (keySeq.equalsIgnoreCase(\"set\")) {\n+                    String key;\n+                    String val;\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    int s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    key = line.substring(s, i);\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    s = i;\n+                    while (i < line.length() && (line.charAt(i) != ' ' && line.charAt(i) != '\\t')) {\n+                        i++;\n+                    }\n+                    val = line.substring(s, i);\n+                    setVar(reader, key, val);\n+                } else {\n+                    while (i < line.length() && (line.charAt(i) == ' ' || line.charAt(i) == '\\t')) {\n+                        i++;\n+                    }\n+                    int start = i;\n+                    if (i < line.length() && (line.charAt(i) == '\\'' || line.charAt(i) == '\\\"')) {\n+                        char delim = line.charAt(i++);\n+                        boolean esc = false;\n+                        for (; ; i++) {\n+                            if (i >= line.length()) {\n+                                break;\n+                            }\n+                            if (esc) {\n+                                esc = false;\n+                            } else if (line.charAt(i) == '\\\\') {\n+                                esc = true;\n+                            } else if (line.charAt(i) == delim) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    for (; i < line.length() && line.charAt(i) != ' ' && line.charAt(i) != '\\t'; i++)\n+                        ;\n+                    String val = line.substring(Math.min(start, line.length()), Math.min(i, line.length()));\n+                    if (keySeq.charAt(0) == '\"') {\n+                        keySeq = translateQuoted(keySeq);\n+                    } else {\n+                        \/\/ Bind key name\n+                        String keyName =\n+                                keySeq.lastIndexOf('-') > 0 ? keySeq.substring(keySeq.lastIndexOf('-') + 1) : keySeq;\n+                        char key = getKeyFromName(keyName);\n+                        keyName = keySeq.toLowerCase();\n+                        keySeq = \"\";\n+                        if (keyName.contains(\"meta-\") || keyName.contains(\"m-\")) {\n+                            keySeq += \"\\u001b\";\n+                        }\n+                        if (keyName.contains(\"control-\") || keyName.contains(\"c-\") || keyName.contains(\"ctrl-\")) {\n+                            key = (char) (Character.toUpperCase(key) & 0x1f);\n+                        }\n+                        keySeq += key;\n+                    }\n+                    if (val.length() > 0 && (val.charAt(0) == '\\'' || val.charAt(0) == '\\\"')) {\n+                        reader.getKeys().bind(new Macro(translateQuoted(val)), keySeq);\n+                    } else {\n+                        reader.getKeys().bind(new Reference(val), keySeq);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                Log.warn(\"Unable to parse user configuration: \", e);\n+            }\n+        }\n+    }\n+\n+    private static String translateQuoted(String keySeq) {\n+        int i;\n+        String str = keySeq.substring(1, keySeq.length() - 1);\n+        StringBuilder sb = new StringBuilder();\n+        for (i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            if (c == '\\\\') {\n+                boolean ctrl = str.regionMatches(i, \"\\\\C-\", 0, 3) || str.regionMatches(i, \"\\\\M-\\\\C-\", 0, 6);\n+                boolean meta = str.regionMatches(i, \"\\\\M-\", 0, 3) || str.regionMatches(i, \"\\\\C-\\\\M-\", 0, 6);\n+                i += (meta ? 3 : 0) + (ctrl ? 3 : 0) + (!meta && !ctrl ? 1 : 0);\n+                if (i >= str.length()) {\n+                    break;\n+                }\n+                c = str.charAt(i);\n+                if (meta) {\n+                    sb.append(\"\\u001b\");\n+                }\n+                if (ctrl) {\n+                    c = c == '?' ? 0x7f : (char) (Character.toUpperCase(c) & 0x1f);\n+                }\n+                if (!meta && !ctrl) {\n+                    switch (c) {\n+                        case 'a':\n+                            c = 0x07;\n+                            break;\n+                        case 'b':\n+                            c = '\\b';\n+                            break;\n+                        case 'd':\n+                            c = 0x7f;\n+                            break;\n+                        case 'e':\n+                            c = 0x1b;\n+                            break;\n+                        case 'f':\n+                            c = '\\f';\n+                            break;\n+                        case 'n':\n+                            c = '\\n';\n+                            break;\n+                        case 'r':\n+                            c = '\\r';\n+                            break;\n+                        case 't':\n+                            c = '\\t';\n+                            break;\n+                        case 'v':\n+                            c = 0x0b;\n+                            break;\n+                        case '\\\\':\n+                            c = '\\\\';\n+                            break;\n+                        case '0':\n+                        case '1':\n+                        case '2':\n+                        case '3':\n+                        case '4':\n+                        case '5':\n+                        case '6':\n+                        case '7':\n+                            c = 0;\n+                            for (int j = 0; j < 3; j++, i++) {\n+                                if (i >= str.length()) {\n+                                    break;\n+                                }\n+                                int k = Character.digit(str.charAt(i), 8);\n+                                if (k < 0) {\n+                                    break;\n+                                }\n+                                c = (char) (c * 8 + k);\n+                            }\n+                            c &= 0xFF;\n+                            break;\n+                        case 'x':\n+                            i++;\n+                            c = 0;\n+                            for (int j = 0; j < 2; j++, i++) {\n+                                if (i >= str.length()) {\n+                                    break;\n+                                }\n+                                int k = Character.digit(str.charAt(i), 16);\n+                                if (k < 0) {\n+                                    break;\n+                                }\n+                                c = (char) (c * 16 + k);\n+                            }\n+                            c &= 0xFF;\n+                            break;\n+                        case 'u':\n+                            i++;\n+                            c = 0;\n+                            for (int j = 0; j < 4; j++, i++) {\n+                                if (i >= str.length()) {\n+                                    break;\n+                                }\n+                                int k = Character.digit(str.charAt(i), 16);\n+                                if (k < 0) {\n+                                    break;\n+                                }\n+                                c = (char) (c * 16 + k);\n+                            }\n+                            break;\n+                    }\n+                }\n+                sb.append(c);\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static char getKeyFromName(String name) {\n+        if (\"DEL\".equalsIgnoreCase(name) || \"Rubout\".equalsIgnoreCase(name)) {\n+            return 0x7f;\n+        } else if (\"ESC\".equalsIgnoreCase(name) || \"Escape\".equalsIgnoreCase(name)) {\n+            return '\\033';\n+        } else if (\"LFD\".equalsIgnoreCase(name) || \"NewLine\".equalsIgnoreCase(name)) {\n+            return '\\n';\n+        } else if (\"RET\".equalsIgnoreCase(name) || \"Return\".equalsIgnoreCase(name)) {\n+            return '\\r';\n+        } else if (\"SPC\".equalsIgnoreCase(name) || \"Space\".equalsIgnoreCase(name)) {\n+            return ' ';\n+        } else if (\"Tab\".equalsIgnoreCase(name)) {\n+            return '\\t';\n+        } else {\n+            return name.charAt(0);\n+        }\n+    }\n+\n+    static void setVar(LineReader reader, String key, String val) {\n+        if (LineReader.KEYMAP.equalsIgnoreCase(key)) {\n+            reader.setKeyMap(val);\n+            return;\n+        }\n+\n+        for (LineReader.Option option : LineReader.Option.values()) {\n+            if (option.name().toLowerCase(Locale.ENGLISH).replace('_', '-').equals(val)) {\n+                if (\"on\".equalsIgnoreCase(val)) {\n+                    reader.setOpt(option);\n+                } else if (\"off\".equalsIgnoreCase(val)) {\n+                    reader.unsetOpt(option);\n+                }\n+                return;\n+            }\n+        }\n+\n+        reader.setVariable(key, val);\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/InputRC.java","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/KillRing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2022, the original author or authors.\n+ * Copyright (c) 2002-2023, the original author(s).\n@@ -21,0 +21,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -59,0 +62,1 @@\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;\n@@ -69,2 +73,1 @@\n-public class LineReaderImpl implements LineReader, Flushable\n-{\n+public class LineReaderImpl implements LineReader, Flushable {\n@@ -73,0 +76,4 @@\n+    \/**\n+     * @deprecated use {@link #DEFAULT_TAB_WIDTH} and {@link #getTabWidth()}\n+     *\/\n+    @Deprecated\n@@ -75,0 +82,1 @@\n+    public static final int DEFAULT_TAB_WIDTH = 4;\n@@ -81,5 +89,5 @@\n-    public static final int    DEFAULT_LIST_MAX = 100;\n-    public static final int    DEFAULT_MENU_LIST_MAX = Integer.MAX_VALUE;\n-    public static final int    DEFAULT_ERRORS = 2;\n-    public static final long   DEFAULT_BLINK_MATCHING_PAREN = 500L;\n-    public static final long   DEFAULT_AMBIGUOUS_BINDING = 1000L;\n+    public static final int DEFAULT_LIST_MAX = 100;\n+    public static final int DEFAULT_MENU_LIST_MAX = Integer.MAX_VALUE;\n+    public static final int DEFAULT_ERRORS = 2;\n+    public static final long DEFAULT_BLINK_MATCHING_PAREN = 500L;\n+    public static final long DEFAULT_AMBIGUOUS_BINDING = 1000L;\n@@ -99,3 +107,4 @@\n-    public static final int    DEFAULT_INDENTATION = 0;\n-    public static final int    DEFAULT_FEATURES_MAX_BUFFER_SIZE = 1000;\n-    public static final int    DEFAULT_SUGGESTIONS_MIN_BUFFER_SIZE = 1;\n+    public static final int DEFAULT_INDENTATION = 0;\n+    public static final int DEFAULT_FEATURES_MAX_BUFFER_SIZE = 1000;\n+    public static final int DEFAULT_SUGGESTIONS_MIN_BUFFER_SIZE = 1;\n+    public static final String DEFAULT_SYSTEM_PROPERTY_PREFIX = \"org.jline.reader.props.\";\n@@ -112,0 +121,1 @@\n+    public static final int DEFAULT_MAX_REPEAT_COUNT = 9999;\n@@ -200,1 +210,0 @@\n-\n@@ -204,1 +213,0 @@\n-\n@@ -209,0 +217,1 @@\n+\n@@ -215,0 +224,1 @@\n+\n@@ -221,0 +231,1 @@\n+\n@@ -235,1 +246,1 @@\n-    protected UndoTree<Buffer> undo = new UndoTree<>(this::setBuffer);\n+    protected UndoTree<Buffer> undo;\n@@ -245,1 +256,1 @@\n-    protected State   state = State.DONE;\n+    protected State state = State.DONE;\n@@ -281,1 +292,4 @@\n-    int candidateStartPosition = 0;\n+    protected int candidateStartPosition = 0;\n+\n+    protected String alternateIn;\n+    protected String alternateOut;\n@@ -291,0 +305,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -303,0 +318,11 @@\n+        String prefix = getString(SYSTEM_PROPERTY_PREFIX, DEFAULT_SYSTEM_PROPERTY_PREFIX);\n+        if (prefix != null) {\n+            Properties sysProps = System.getProperties();\n+            for (String s : sysProps.stringPropertyNames()) {\n+                if (s.startsWith(prefix)) {\n+                    String key = s.substring(prefix.length());\n+                    InputRC.setVar(this, key, sysProps.getProperty(s));\n+                }\n+            }\n+        }\n+\n@@ -304,0 +330,4 @@\n+        if (!Boolean.getBoolean(PROP_DISABLE_ALTERNATE_CHARSET)) {\n+            this.alternateIn = Curses.tputs(terminal.getStringCapability(Capability.enter_alt_charset_mode));\n+            this.alternateOut = Curses.tputs(terminal.getStringCapability(Capability.exit_alt_charset_mode));\n+        }\n@@ -305,0 +335,1 @@\n+        undo = new UndoTree<>(this::setBuffer);\n@@ -308,0 +339,13 @@\n+\n+        String inputRc = getString(INPUT_RC_FILE_NAME, null);\n+        if (inputRc != null) {\n+            Path inputRcPath = Paths.get(inputRc);\n+            if (Files.exists(inputRcPath)) {\n+                try (InputStream is = Files.newInputStream(inputRcPath)) {\n+                    InputRC.configure(this, is);\n+                } catch (Exception e) {\n+                    Log.debug(\"Error reading inputRc config file: \", inputRc, e);\n+                }\n+            }\n+        }\n+\n@@ -492,1 +536,2 @@\n-    public String readLine(String prompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {\n+    public String readLine(String prompt, Character mask, String buffer)\n+            throws UserInterruptException, EndOfFileException {\n@@ -506,1 +551,2 @@\n-    public String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {\n+    public String readLine(String prompt, String rightPrompt, Character mask, String buffer)\n+            throws UserInterruptException, EndOfFileException {\n@@ -520,1 +566,2 @@\n-    public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {\n+    public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer)\n+            throws UserInterruptException, EndOfFileException {\n@@ -621,11 +668,3 @@\n-                    if (isSet(Option.AUTO_FRESH_LINE))\n-                        callWidget(FRESH_LINE);\n-                    if (isSet(Option.MOUSE))\n-                        terminal.trackMouse(Terminal.MouseTracking.Normal);\n-                    if (isSet(Option.BRACKETED_PASTE))\n-                        terminal.writer().write(BRACKETED_PASTE_ON);\n-                } else {\n-                    \/\/ For dumb terminals, we need to make sure that CR are ignored\n-                    Attributes attr = new Attributes(originalAttributes);\n-                    attr.setInputFlag(Attributes.InputFlag.IGNCR, true);\n-                    terminal.setAttributes(attr);\n+                    if (isSet(Option.AUTO_FRESH_LINE)) callWidget(FRESH_LINE);\n+                    if (isSet(Option.MOUSE)) terminal.trackMouse(Terminal.MouseTracking.Normal);\n+                    if (isSet(Option.BRACKETED_PASTE)) terminal.writer().write(BRACKETED_PASTE_ON);\n@@ -636,2 +675,1 @@\n-                if (!isSet(Option.DISABLE_UNDO))\n-                    undo.newState(buf.copy());\n+                if (!isSet(Option.DISABLE_UNDO)) undo.newState(buf.copy());\n@@ -657,1 +695,2 @@\n-                if (buf.length() == 0 && getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {\n+                if (buf.length() == 0\n+                        && getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {\n@@ -678,1 +717,3 @@\n-                    Buffer copy = buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE) ? buf.copy() : null;\n+                    Buffer copy = buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                            ? buf.copy()\n+                            : null;\n@@ -683,1 +724,4 @@\n-                    if (!isSet(Option.DISABLE_UNDO) && !isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                    if (!isSet(Option.DISABLE_UNDO)\n+                            && !isUndo\n+                            && copy != null\n+                            && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n@@ -721,2 +765,2 @@\n-        }\n-        finally {\n+        } finally {\n+            AtomicBoolean interrupted = new AtomicBoolean(Thread.interrupted());\n@@ -728,0 +772,5 @@\n+                Terminal.SignalHandler tmpHandler = terminal.handle(Signal.INT, s -> interrupted.set(true));\n+                if (previousIntrHandler == null) {\n+                    previousIntrHandler = tmpHandler;\n+                }\n+\n@@ -744,0 +793,3 @@\n+                if (interrupted.get()) {\n+                    Thread.currentThread().interrupt();\n+                }\n@@ -749,2 +801,1 @@\n-        return Terminal.TYPE_DUMB.equals(terminal.getType())\n-                || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());\n+        return Terminal.TYPE_DUMB.equals(terminal.getType()) || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());\n@@ -760,2 +811,1 @@\n-        if (isSet(Option.DELAY_LINE_WRAP))\n-            display.setDelayLineWrap(true);\n+        if (isSet(Option.DELAY_LINE_WRAP)) display.setDelayLineWrap(true);\n@@ -968,2 +1018,4 @@\n-            if (!KILL_LINE.equals(ref) && !KILL_WHOLE_LINE.equals(ref)\n-                    && !BACKWARD_KILL_WORD.equals(ref) && !KILL_WORD.equals(ref)) {\n+            if (!KILL_LINE.equals(ref)\n+                    && !KILL_WHOLE_LINE.equals(ref)\n+                    && !BACKWARD_KILL_WORD.equals(ref)\n+                    && !KILL_WORD.equals(ref)) {\n@@ -1086,1 +1138,1 @@\n-        Constructor<?> ctor = Class.forName(\"jdk.internal.org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n+        Constructor<?> ctor = Class.forName(\"org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n@@ -1100,0 +1152,4 @@\n+    protected int getTabWidth() {\n+        return getInt(LineReader.TAB_WIDTH, DEFAULT_TAB_WIDTH);\n+    }\n+\n@@ -1140,1 +1196,1 @@\n-        if (historyLine != null && historyLine.length() > 0 ) {\n+        if (historyLine != null && historyLine.length() > 0) {\n@@ -1146,1 +1202,1 @@\n-    protected void handleSignal(Signal signal) {\n+    protected synchronized void handleSignal(Signal signal) {\n@@ -1149,0 +1205,2 @@\n+            size.copy(terminal.getBufferSize());\n+            display.resize(size.getRows(), size.getColumns());\n@@ -1151,1 +1209,2 @@\n-                status.hardReset();\n+                status.resize(size);\n+                status.reset();\n@@ -1153,4 +1212,3 @@\n-            size.copy(terminal.getBufferSize());\n-            display.resize(size.getRows(), size.getColumns());\n-            \/\/ restores prompt but also prevents scrolling in consoleZ, see #492\n-            \/\/ redrawLine();\n+            terminal.puts(Capability.carriage_return);\n+            terminal.puts(Capability.clr_eos);\n+            redrawLine();\n@@ -1158,2 +1216,1 @@\n-        }\n-        else if (signal == Signal.CONT) {\n+        } else if (signal == Signal.CONT) {\n@@ -1203,2 +1260,1 @@\n-        this.prompt = (prompt == null ? AttributedString.EMPTY\n-                       : expandPromptPattern(prompt, 0, \"\", 0));\n+        this.prompt = (prompt == null ? AttributedString.EMPTY : expandPromptPattern(prompt, 0, \"\", 0));\n@@ -1208,2 +1264,1 @@\n-        this.rightPrompt = (rightPrompt == null ? AttributedString.EMPTY\n-                            : expandPromptPattern(rightPrompt, 0, \"\", 0));\n+        this.rightPrompt = (rightPrompt == null ? AttributedString.EMPTY : expandPromptPattern(rightPrompt, 0, \"\", 0));\n@@ -1236,1 +1291,1 @@\n-    protected String viDeleteChangeYankToRemap (String op) {\n+    protected String viDeleteChangeYankToRemap(String op) {\n@@ -1295,1 +1350,0 @@\n-\n@@ -1335,1 +1389,0 @@\n-\n@@ -1368,3 +1421,1 @@\n-                while (buf.cursor() < buf.length()\n-                        && !isViAlphaNum(buf.currChar())\n-                        && !isWhitespace(buf.currChar())) {\n+                while (buf.cursor() < buf.length() && !isViAlphaNum(buf.currChar()) && !isWhitespace(buf.currChar())) {\n@@ -1378,3 +1429,1 @@\n-            while (buf.cursor() < buf.length()\n-                    && nl < 2\n-                    && isWhitespace(buf.currChar())) {\n+            while (buf.cursor() < buf.length() && nl < 2 && isWhitespace(buf.currChar())) {\n@@ -1400,3 +1449,1 @@\n-            while (buf.cursor() < buf.length()\n-                    && nl < 2\n-                    && isWhitespace(buf.currChar())) {\n+            while (buf.cursor() < buf.length() && nl < 2 && isWhitespace(buf.currChar())) {\n@@ -1454,1 +1501,3 @@\n-                    while (buf.cursor() < buf.length() && !isViAlphaNum(buf.nextChar()) && !isWhitespace(buf.nextChar())) {\n+                    while (buf.cursor() < buf.length()\n+                            && !isViAlphaNum(buf.nextChar())\n+                            && !isWhitespace(buf.nextChar())) {\n@@ -1723,3 +1772,1 @@\n-                buf.currChar(first\n-                        ? Character.toUpperCase(buf.currChar())\n-                        : Character.toLowerCase(buf.currChar()));\n+                buf.currChar(first ? Character.toUpperCase(buf.currChar()) : Character.toLowerCase(buf.currChar()));\n@@ -1813,1 +1860,2 @@\n-            while (end1 < lend && !isDelimiter(buf.atChar(++end1)));\n+            while (end1 < lend && !isDelimiter(buf.atChar(++end1)))\n+                ;\n@@ -1822,1 +1870,2 @@\n-                    while (isDelimiter(buf.atChar(++sta2)));\n+                    while (isDelimiter(buf.atChar(++sta2)))\n+                        ;\n@@ -1824,1 +1873,2 @@\n-                    while (end2 < lend && !isDelimiter(buf.atChar(++end2)));\n+                    while (end2 < lend && !isDelimiter(buf.atChar(++end2)))\n+                        ;\n@@ -1833,1 +1883,2 @@\n-                while (sta2 < lend && isDelimiter(buf.atChar(++sta2)));\n+                while (sta2 < lend && isDelimiter(buf.atChar(++sta2)))\n+                    ;\n@@ -1846,1 +1897,2 @@\n-                    while (end2 < lend && !isDelimiter(buf.atChar(++end2))) ;\n+                    while (end2 < lend && !isDelimiter(buf.atChar(++end2)))\n+                        ;\n@@ -1850,2 +1902,4 @@\n-                String res = buf.substring(0, sta1) + buf.substring(sta2, end2)\n-                        + buf.substring(end1, sta2) + buf.substring(sta1, end1)\n+                String res = buf.substring(0, sta1)\n+                        + buf.substring(sta2, end2)\n+                        + buf.substring(end1, sta2)\n+                        + buf.substring(sta1, end1)\n@@ -1857,2 +1911,4 @@\n-                String res = buf.substring(0, sta2) + buf.substring(sta1, end1)\n-                        + buf.substring(end2, sta1) + buf.substring(sta2, end2)\n+                String res = buf.substring(0, sta2)\n+                        + buf.substring(sta1, end1)\n+                        + buf.substring(end2, sta1)\n+                        + buf.substring(sta2, end2)\n@@ -1991,1 +2047,2 @@\n-            } while (buf.cursor() > 0 && buf.cursor() < buf.length()\n+            } while (buf.cursor() > 0\n+                    && buf.cursor() < buf.length()\n@@ -1994,2 +2051,1 @@\n-            if (buf.cursor() <= 0 || buf.cursor() >= buf.length()\n-                    || buf.currChar() == '\\n') {\n+            if (buf.cursor() <= 0 || buf.cursor() >= buf.length() || buf.currChar() == '\\n') {\n@@ -2214,1 +2270,1 @@\n-        int pos        = buf.cursor();\n+        int pos = buf.cursor();\n@@ -2220,3 +2276,3 @@\n-        int type       = getBracketType(buf.atChar(pos));\n-        int move       = (type < 0) ? -1 : 1;\n-        int count      = 1;\n+        int type = getBracketType(buf.atChar(pos));\n+        int move = (type < 0) ? -1 : 1;\n+        int count = 1;\n@@ -2224,2 +2280,1 @@\n-        if (type == 0)\n-            return false;\n+        if (type == 0) return false;\n@@ -2238,2 +2293,1 @@\n-            }\n-            else if (curType == -type) {\n+            } else if (curType == -type) {\n@@ -2248,2 +2302,1 @@\n-        if (move > 0 && isInViMoveOperation())\n-            ++pos;\n+        if (move > 0 && isInViMoveOperation()) ++pos;\n@@ -2262,1 +2315,1 @@\n-    protected int getBracketType (int ch) {\n+    protected int getBracketType(int ch) {\n@@ -2264,6 +2317,12 @@\n-            case '[': return  1;\n-            case ']': return -1;\n-            case '{': return  2;\n-            case '}': return -2;\n-            case '(': return  3;\n-            case ')': return -3;\n+            case '[':\n+                return 1;\n+            case ']':\n+                return -1;\n+            case '{':\n+                return 2;\n+            case '}':\n+                return -2;\n+            case '(':\n+                return 3;\n+            case ')':\n+                return -3;\n@@ -2334,1 +2393,1 @@\n-\/\/            state = State.INTERRUPT;\n+            \/\/            state = State.INTERRUPT;\n@@ -2381,0 +2440,4 @@\n+        int maxRepeatCount = getInt(MAX_REPEAT_COUNT, DEFAULT_MAX_REPEAT_COUNT);\n+        if (repeatCount > maxRepeatCount) {\n+            throw new IllegalArgumentException(\"digit argument should be less than \" + maxRepeatCount);\n+        }\n@@ -2441,1 +2504,2 @@\n-        while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+        while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+            ;\n@@ -2444,1 +2508,2 @@\n-            while (buf.move(1) == 1 && buf.prevChar() != '\\n') ;\n+            while (buf.move(1) == 1 && buf.prevChar() != '\\n')\n+                ;\n@@ -2557,2 +2622,4 @@\n-    static class Pair<U,V> {\n-        final U u; final V v;\n+    static class Pair<U, V> {\n+        final U u;\n+        final V v;\n+\n@@ -2563,0 +2630,1 @@\n+\n@@ -2566,0 +2634,1 @@\n+\n@@ -2578,1 +2647,2 @@\n-                .codePoints().forEach(c -> bind(terminators, ACCEPT_LINE, new String(Character.toChars(c))));\n+                .codePoints()\n+                .forEach(c -> bind(terminators, ACCEPT_LINE, new String(Character.toChars(c))));\n@@ -2586,2 +2656,2 @@\n-                        + (searchBackward ? \"bck-i-search\" : \"fwd-i-search\")\n-                        + \": \" + searchTerm + \"_\");\n+                + (searchBackward ? \"bck-i-search\" : \"fwd-i-search\")\n+                + \": \" + searchTerm + \"_\");\n@@ -2633,2 +2703,3 @@\n-                    Pattern pat = Pattern.compile(pattern, caseInsensitive ? Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE\n-                                                                           : Pattern.UNICODE_CASE);\n+                    Pattern pat = Pattern.compile(\n+                            pattern,\n+                            caseInsensitive ? Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE : Pattern.UNICODE_CASE);\n@@ -2644,1 +2715,5 @@\n-                                    Spliterators.spliteratorUnknownSize(history.reverseIterator(searchIndex < 0 ? history.last() : searchIndex - 1), Spliterator.ORDERED), false)\n+                                            Spliterators.spliteratorUnknownSize(\n+                                                    history.reverseIterator(\n+                                                            searchIndex < 0 ? history.last() : searchIndex - 1),\n+                                                    Spliterator.ORDERED),\n+                                            false)\n@@ -2657,1 +2732,5 @@\n-                                    Spliterators.spliteratorUnknownSize(history.iterator((searchIndex < 0 ? history.last() : searchIndex) + 1), Spliterator.ORDERED), false)\n+                                            Spliterators.spliteratorUnknownSize(\n+                                                    history.iterator(\n+                                                            (searchIndex < 0 ? history.last() : searchIndex) + 1),\n+                                                    Spliterator.ORDERED),\n+                                            false)\n@@ -2717,1 +2796,4 @@\n-                sb.append(\"[\").append(Character.toLowerCase(c)).append(Character.toUpperCase(c)).append(\"]\");\n+                sb.append(\"[\")\n+                        .append(Character.toLowerCase(c))\n+                        .append(Character.toUpperCase(c))\n+                        .append(\"]\");\n@@ -2745,2 +2827,1 @@\n-        if (historyBuffer == null || buf.length() == 0\n-                || !buf.toString().equals(history.current())) {\n+        if (historyBuffer == null || buf.length() == 0 || !buf.toString().equals(history.current())) {\n@@ -2794,2 +2875,1 @@\n-        if (historyBuffer == null || buf.length() == 0\n-                || !buf.toString().equals(history.current())) {\n+        if (historyBuffer == null || buf.length() == 0 || !buf.toString().equals(history.current())) {\n@@ -2987,1 +3067,1 @@\n-        int indent = getInt(INDENTATION, DEFAULT_INDENTATION)*nb;\n+        int indent = getInt(INDENTATION, DEFAULT_INDENTATION) * nb;\n@@ -3020,1 +3100,0 @@\n-\n@@ -3111,2 +3190,1 @@\n-        return upLine()\n-                || upHistory() && viFirstNonBlank();\n+        return upLine() || upHistory() && viFirstNonBlank();\n@@ -3116,2 +3194,1 @@\n-        return downLine()\n-                || downHistory() && viFirstNonBlank();\n+        return downLine() || downHistory() && viFirstNonBlank();\n@@ -3178,2 +3255,1 @@\n-        return viChange(buf.cursor(), buf.length())\n-                && setKeyMap(VIINS);\n+        return viChange(buf.cursor(), buf.length()) && setKeyMap(VIINS);\n@@ -3202,1 +3278,2 @@\n-            while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+            while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+                ;\n@@ -3256,1 +3333,2 @@\n-            while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+            while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+                ;\n@@ -3263,1 +3341,2 @@\n-            while (buf.move(1) == 1 && buf.currChar() != '\\n') ;\n+            while (buf.move(1) == 1 && buf.currChar() != '\\n')\n+                ;\n@@ -3387,1 +3466,1 @@\n-        if (! isChange && startPos > 0 && startPos == buf.length()) {\n+        if (!isChange && startPos > 0 && startPos == buf.length()) {\n@@ -3427,1 +3506,2 @@\n-        while (buf.move(-1) == -1 && buf.prevChar() != '\\n') ;\n+        while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+            ;\n@@ -3434,1 +3514,2 @@\n-        while (buf.move(1) == 1 && buf.currChar() != '\\n') ;\n+        while (buf.move(1) == 1 && buf.currChar() != '\\n')\n+            ;\n@@ -3446,1 +3527,2 @@\n-            while (buf.move(1) == 1 && buf.currChar() != '\\n');\n+            while (buf.move(1) == 1 && buf.currChar() != '\\n')\n+                ;\n@@ -3449,2 +3531,2 @@\n-            buf.move(- yankBuffer.length());\n-        } else if (yankBuffer.length () != 0) {\n+            buf.move(-yankBuffer.length());\n+        } else if (yankBuffer.length() != 0) {\n@@ -3464,1 +3546,2 @@\n-            while (buf.move(-1) == -1 && buf.prevChar() != '\\n');\n+            while (buf.move(-1) == -1 && buf.prevChar() != '\\n')\n+                ;\n@@ -3466,2 +3549,2 @@\n-            buf.move(- yankBuffer.length());\n-        } else if (yankBuffer.length () != 0) {\n+            buf.move(-yankBuffer.length());\n+        } else if (yankBuffer.length() != 0) {\n@@ -3684,1 +3767,1 @@\n-\/\/        addBuiltinWidget(widgets, QUIT, this::quit);\n+        \/\/        addBuiltinWidget(widgets, QUIT, this::quit);\n@@ -3777,0 +3860,1 @@\n+\n@@ -3800,3 +3884,0 @@\n-                if (terminal.getType().startsWith(AbstractWindowsTerminal.TYPE_WINDOWS)) {\n-                    status.resize();\n-                }\n@@ -3807,1 +3888,1 @@\n-                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -3880,1 +3961,1 @@\n-                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+                AttributedStringBuilder sb = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -3887,1 +3968,2 @@\n-                List<AttributedString> promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n+                List<AttributedString> promptLines =\n+                        sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n@@ -3907,1 +3989,1 @@\n-                if (lineId  > cursorNewLinesId) {\n+                if (lineId > cursorNewLinesId) {\n@@ -3952,4 +4034,3 @@\n-        for (char c: buffer.replace(\"\\\\\", \"\\\\\\\\\").toCharArray()) {\n-            if (c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^' || c == '*'\n-                     || c == '$' || c == '.' || c == '?' || c == '+' || c == '|' || c == '<' || c == '>' || c == '!'\n-                     || c == '-') {\n+        for (char c : buffer.replace(\"\\\\\", \"\\\\\\\\\").toCharArray()) {\n+            if (c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^' || c == '*' || c == '$'\n+                    || c == '.' || c == '?' || c == '+' || c == '|' || c == '<' || c == '>' || c == '!' || c == '-') {\n@@ -3987,1 +4068,1 @@\n-        AttributedStringBuilder full = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+        AttributedStringBuilder full = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -4043,1 +4124,2 @@\n-        if (highlighter != null && !isSet(Option.DISABLE_HIGHLIGHTER)\n+        if (highlighter != null\n+                && !isSet(Option.DISABLE_HIGHLIGHTER)\n@@ -4050,2 +4132,1 @@\n-    private AttributedString expandPromptPattern(String pattern, int padToWidth,\n-                                                 String message, int line) {\n+    private AttributedString expandPromptPattern(String pattern, int padToWidth, String message, int line) {\n@@ -4068,1 +4149,2 @@\n-                decode: while (true) {\n+                decode:\n+                while (true) {\n@@ -4076,1 +4158,1 @@\n-                                astr = AttributedString.fromAnsi(str);\n+                                astr = fromAnsi(str);\n@@ -4099,2 +4181,1 @@\n-                            if (message != null)\n-                                sb.append(message);\n+                            if (message != null) sb.append(message);\n@@ -4103,2 +4184,1 @@\n-                            if (countSeen && count >= 0)\n-                                padToWidth = count;\n+                            if (countSeen && count >= 0) padToWidth = count;\n@@ -4143,2 +4223,1 @@\n-            } else\n-                sb.append(ch);\n+            } else sb.append(ch);\n@@ -4150,3 +4229,2 @@\n-            while (--padCount >= 0)\n-                sb.insert(padPos, (char) padChar); \/\/ FIXME if wide\n-            parts.set(padPartIndex, AttributedString.fromAnsi(sb.toString()));\n+            while (--padCount >= 0) sb.insert(padPos, (char) padChar); \/\/ FIXME if wide\n+            parts.set(padPartIndex, fromAnsi(sb.toString()));\n@@ -4157,0 +4235,4 @@\n+    private AttributedString fromAnsi(String str) {\n+        return AttributedString.fromAnsi(str, Collections.singletonList(0), alternateIn, alternateOut);\n+    }\n+\n@@ -4161,1 +4243,2 @@\n-    private AttributedString insertSecondaryPrompts(AttributedString strAtt, List<AttributedString> prompts, boolean computePrompts) {\n+    private AttributedString insertSecondaryPrompts(\n+            AttributedString strAtt, List<AttributedString> prompts, boolean computePrompts) {\n@@ -4174,1 +4257,3 @@\n-                width = new TerminalLine(prompt.toString(), 0, size.getColumns()).getEndLine().length();\n+                width = new TerminalLine(prompt.toString(), 0, size.getColumns())\n+                        .getEndLine()\n+                        .length();\n@@ -4230,2 +4315,1 @@\n-        boolean endsWithNl = line.length() > 0\n-            && line.charAt(line.length() - 1) == '\\n';\n+        boolean endsWithNl = line.length() > 0 && line.charAt(line.length() - 1) == '\\n';\n@@ -4233,2 +4317,1 @@\n-        int nb = size.getColumns() - width\n-            - (line.columnLength() + (endsWithNl ? 1 : 0));\n+        int nb = size.getColumns() - width - (line.columnLength() + (endsWithNl ? 1 : 0));\n@@ -4256,2 +4339,2 @@\n-                    && getLastBinding().equals(\"\\t\")\n-                    && buf.toString().matches(\"(^|[\\\\s\\\\S]*\\n)[\\r\\n\\t ]*\");\n+                && getLastBinding().equals(\"\\t\")\n+                && buf.toString().matches(\"(^|[\\\\s\\\\S]*\\n)[\\r\\n\\t ]*\");\n@@ -4468,1 +4551,2 @@\n-                        if (SELF_INSERT.equals(ref) && chars.indexOf(getLastBinding().charAt(0)) >= 0\n+                        if (SELF_INSERT.equals(ref)\n+                                        && chars.indexOf(getLastBinding().charAt(0)) >= 0\n@@ -4536,0 +4620,1 @@\n+\n@@ -4539,0 +4624,1 @@\n+\n@@ -4542,0 +4628,1 @@\n+\n@@ -4545,0 +4632,1 @@\n+\n@@ -4548,0 +4636,1 @@\n+\n@@ -4551,0 +4640,1 @@\n+\n@@ -4554,0 +4644,1 @@\n+\n@@ -4557,0 +4648,1 @@\n+\n@@ -4567,2 +4659,1 @@\n-        return Comparator\n-                .comparing(Candidate::value, Comparator.comparingInt(wordDistance))\n+        return Comparator.comparing(Candidate::value, Comparator.comparingInt(wordDistance))\n@@ -4580,1 +4671,0 @@\n-\n@@ -4582,1 +4672,3 @@\n-        return Comparator.<String>comparingInt(s -> getOthersGroupName().equals(s) ? 1 : getOriginalGroupName().equals(s) ? -1 : 0)\n+        return Comparator.<String>comparingInt(s -> getOthersGroupName().equals(s)\n+                        ? 1\n+                        : getOriginalGroupName().equals(s) ? -1 : 0)\n@@ -4603,5 +4695,3 @@\n-                    String disp = candidates.stream()\n-                            .map(Candidate::displ)\n-                            .collect(Collectors.joining(\" \"));\n-                    possible.add(new Candidate(first.value(), disp, first.group(),\n-                            first.descr(), first.suffix(), null, first.complete()));\n+                    String disp = candidates.stream().map(Candidate::displ).collect(Collectors.joining(\" \"));\n+                    possible.add(new Candidate(\n+                            first.value(), disp, first.group(), first.descr(), first.suffix(), null, first.complete()));\n@@ -4639,2 +4729,4 @@\n-        AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n-        return text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n+        AttributedString text =\n+                insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n+        return text.columnSplitLength(size.getColumns(), false, display.delayLineWrap())\n+                .size();\n@@ -4654,1 +4746,2 @@\n-        public MenuSupport(List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+        public MenuSupport(\n+                List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n@@ -4717,1 +4810,1 @@\n-                axis = options%axis;\n+                axis = options % axis;\n@@ -4775,1 +4868,3 @@\n-                            .append(post).append(\"\\n\").toAttributedString();\n+                            .append(post)\n+                            .append(\"\\n\")\n+                            .toAttributedString();\n@@ -4788,1 +4883,2 @@\n-                        .style(AttributedStyle.DEFAULT).toAttributedString());\n+                        .style(AttributedStyle.DEFAULT)\n+                        .toAttributedString());\n@@ -4801,1 +4897,0 @@\n-\n@@ -4804,1 +4899,2 @@\n-    protected boolean doMenu(List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+    protected boolean doMenu(\n+            List<Candidate> original, String completed, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n@@ -4857,1 +4953,1 @@\n-                                && chars.indexOf(getLastBinding().charAt(0)) >= 0\n+                                        && chars.indexOf(getLastBinding().charAt(0)) >= 0\n@@ -4869,2 +4965,2 @@\n-                                && completion.suffix() != null\n-                                && completion.suffix().startsWith(getLastBinding()))) {\n+                                    && completion.suffix() != null\n+                                    && completion.suffix().startsWith(getLastBinding()))) {\n@@ -4891,2 +4987,5 @@\n-    protected boolean doList(List<Candidate> possible\n-                           , String completed, boolean runLoop, BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n+    protected boolean doList(\n+            List<Candidate> possible,\n+            String completed,\n+            boolean runLoop,\n+            BiFunction<CharSequence, Boolean, CharSequence> escaper) {\n@@ -4896,3 +4995,6 @@\n-    protected boolean doList(List<Candidate> possible\n-                           , String completed\n-                           , boolean runLoop, BiFunction<CharSequence, Boolean, CharSequence> escaper, boolean forSuggestion) {\n+    protected boolean doList(\n+            List<Candidate> possible,\n+            String completed,\n+            boolean runLoop,\n+            BiFunction<CharSequence, Boolean, CharSequence> escaper,\n+            boolean forSuggestion) {\n@@ -4904,2 +5006,4 @@\n-        AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n-        int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n+        AttributedString text =\n+                insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n+        int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap())\n+                .size();\n@@ -4909,2 +5013,5 @@\n-        if (listMax > 0 && possible.size() >= listMax\n-                || lines >= size.getRows() - promptLines) {\n+        int possibleSize = possible.size();\n+        if (possibleSize == 0 || size.getRows() == 0) {\n+            return false;\n+        }\n+        if (listMax > 0 && possibleSize >= listMax || lines >= size.getRows() - promptLines) {\n@@ -4913,1 +5020,1 @@\n-                post = () -> new AttributedString(getAppName() + \": do you wish to see all \" + possible.size()\n+                post = () -> new AttributedString(getAppName() + \": do you wish to see all \" + possibleSize\n@@ -4933,2 +5040,1 @@\n-                completionMatcher.compile(options, false, new CompletingWord(current), caseInsensitive, 0\n-                        , null);\n+                completionMatcher.compile(options, false, new CompletingWord(current), caseInsensitive, 0, null);\n@@ -4947,2 +5053,4 @@\n-                AttributedString t = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n-                int pl = t.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n+                AttributedString t = insertSecondaryPrompts(\n+                        AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n+                int pl = t.columnSplitLength(size.getColumns(), false, display.delayLineWrap())\n+                        .size();\n@@ -4957,1 +5065,2 @@\n-                    List<AttributedString> ls = pr.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n+                    List<AttributedString> ls =\n+                            pr.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n@@ -5077,5 +5186,24 @@\n-    protected PostResult computePost(List<Candidate> possible, Candidate selection, List<Candidate> ordered, String completed) {\n-        return computePost(possible, selection, ordered, completed, display::wcwidth, size.getColumns(), isSet(Option.AUTO_GROUP), isSet(Option.GROUP), isSet(Option.LIST_ROWS_FIRST));\n-    }\n-\n-    protected PostResult computePost(List<Candidate> possible, Candidate selection, List<Candidate> ordered, String completed, Function<String, Integer> wcwidth, int width, boolean autoGroup, boolean groupName, boolean rowsFirst) {\n+    protected PostResult computePost(\n+            List<Candidate> possible, Candidate selection, List<Candidate> ordered, String completed) {\n+        return computePost(\n+                possible,\n+                selection,\n+                ordered,\n+                completed,\n+                display::wcwidth,\n+                size.getColumns(),\n+                isSet(Option.AUTO_GROUP),\n+                isSet(Option.GROUP),\n+                isSet(Option.LIST_ROWS_FIRST));\n+    }\n+\n+    protected PostResult computePost(\n+            List<Candidate> possible,\n+            Candidate selection,\n+            List<Candidate> ordered,\n+            String completed,\n+            Function<String, Integer> wcwidth,\n+            int width,\n+            boolean autoGroup,\n+            boolean groupName,\n+            boolean rowsFirst) {\n@@ -5083,1 +5211,0 @@\n-        boolean customOrder = possible.stream().anyMatch(c -> c.sort() != 0);\n@@ -5086,4 +5213,2 @@\n-            Map<String, Map<Object, Candidate>> sorted;\n-            sorted = groupComparator != null\n-                        ? new TreeMap<>(groupComparator)\n-                        : new LinkedHashMap<>();\n+            Map<String, List<Candidate>> sorted;\n+            sorted = groupComparator != null ? new TreeMap<>(groupComparator) : new LinkedHashMap<>();\n@@ -5092,2 +5217,2 @@\n-                sorted.computeIfAbsent(group != null ? group : \"\", s -> new LinkedHashMap<>())\n-                        .put((customOrder ? cand.sort() : cand.value()), cand);\n+                sorted.computeIfAbsent(group != null ? group : \"\", s -> new ArrayList<>())\n+                        .add(cand);\n@@ -5095,1 +5220,1 @@\n-            for (Map.Entry<String, Map<Object, Candidate>> entry : sorted.entrySet()) {\n+            for (Map.Entry<String, List<Candidate>> entry : sorted.entrySet()) {\n@@ -5103,1 +5228,3 @@\n-                strings.add(new ArrayList<>(entry.getValue().values()));\n+                List<Candidate> candidates = entry.getValue();\n+                Collections.sort(candidates);\n+                strings.add(candidates);\n@@ -5105,1 +5232,1 @@\n-                    ordered.addAll(entry.getValue().values());\n+                    ordered.addAll(candidates);\n@@ -5110,1 +5237,1 @@\n-            TreeMap<Object, Candidate> sorted = new TreeMap<>();\n+            List<Candidate> sorted = new ArrayList<>();\n@@ -5116,1 +5243,1 @@\n-                sorted.put((customOrder ? cand.sort() : cand.value()), cand);\n+                sorted.add(cand);\n@@ -5121,1 +5248,2 @@\n-            strings.add(new ArrayList<>(sorted.values()));\n+            Collections.sort(sorted);\n+            strings.add(sorted);\n@@ -5123,1 +5251,1 @@\n-                ordered.addAll(sorted.values());\n+                ordered.addAll(sorted);\n@@ -5166,2 +5294,4 @@\n-        List<String> values = cands.stream().map(c -> AttributedString.stripAnsi(c.displ()))\n-                .filter(c -> !c.matches(\"\\\\w+\") && c.length() > 1).collect(Collectors.toList());\n+        List<String> values = cands.stream()\n+                .map(c -> AttributedString.stripAnsi(c.displ()))\n+                .filter(c -> !c.matches(\"\\\\w+\") && c.length() > 1)\n+                .collect(Collectors.toList());\n@@ -5169,1 +5299,2 @@\n-        values.forEach(v -> v.substring(0, v.length() - 1).chars()\n+        values.forEach(v -> v.substring(0, v.length() - 1)\n+                .chars()\n@@ -5171,1 +5302,1 @@\n-                .forEach(c -> notDelimiters.add(Character.toString((char)c))));\n+                .forEach(c -> notDelimiters.add(Character.toString((char) c))));\n@@ -5182,2 +5313,1 @@\n-            if (buffer.substring(0, i).matches(\".*\\\\W\")\n-                    && !notDelimiters.contains(buffer.substring(i - 1, i))) {\n+            if (buffer.substring(0, i).matches(\".*\\\\W\") && !notDelimiters.contains(buffer.substring(i - 1, i))) {\n@@ -5192,1 +5322,7 @@\n-    protected PostResult toColumns(List<Object> items, Candidate selection, String completed, Function<String, Integer> wcwidth, int width, boolean rowsFirst) {\n+    protected PostResult toColumns(\n+            List<Object> items,\n+            Candidate selection,\n+            String completed,\n+            Function<String, Integer> wcwidth,\n+            int width,\n+            boolean rowsFirst) {\n@@ -5202,2 +5338,1 @@\n-            }\n-            else if (item instanceof List) {\n+            } else if (item instanceof List) {\n@@ -5221,1 +5356,4 @@\n-                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), visibleDisplayRows() - promptLines())) {\n+                    && listSize\n+                            < Math.min(\n+                                    getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX),\n+                                    visibleDisplayRows() - promptLines())) {\n@@ -5254,2 +5392,10 @@\n-    protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed\n-                           , boolean rowsFirst, boolean doMenuList, int[] out) {\n+    protected void toColumns(\n+            Object items,\n+            int width,\n+            int maxWidth,\n+            AttributedStringBuilder sb,\n+            Candidate selection,\n+            String completed,\n+            boolean rowsFirst,\n+            boolean doMenuList,\n+            int[] out) {\n@@ -5308,2 +5454,2 @@\n-                        AttributedString left = AttributedString.fromAnsi(cand.displ());\n-                        AttributedString right = AttributedString.fromAnsi(cand.descr());\n+                        AttributedString left = fromAnsi(cand.displ());\n+                        AttributedString right = fromAnsi(cand.descr());\n@@ -5313,2 +5459,5 @@\n-                            int rem = maxWidth - (lw + MARGIN_BETWEEN_DISPLAY_AND_DESC\n-                                    + DESC_PREFIX.length() + DESC_SUFFIX.length());\n+                            int rem = maxWidth\n+                                    - (lw\n+                                            + MARGIN_BETWEEN_DISPLAY_AND_DESC\n+                                            + DESC_PREFIX.length()\n+                                            + DESC_SUFFIX.length());\n@@ -5318,2 +5467,1 @@\n-                                            right.columnSubSequence(0, rem - WCWidth.wcwidth('\\u2026')),\n-                                            \"\\u2026\");\n+                                        right.columnSubSequence(0, rem - WCWidth.wcwidth('\\u2026')), \"\\u2026\");\n@@ -5328,2 +5476,3 @@\n-                            if (left.toString().regionMatches(\n-                                    isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n+                            if (left.toString()\n+                                    .regionMatches(\n+                                            isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n@@ -5343,2 +5492,3 @@\n-                            if (left.toString().regionMatches(\n-                                    isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n+                            if (left.toString()\n+                                    .regionMatches(\n+                                            isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {\n@@ -5450,1 +5600,1 @@\n-        return AttributedString.fromAnsi(\"\\u001b[\" + str + \"m \").styleAt(0);\n+        return fromAnsi(\"\\u001b[\" + str + \"m \").styleAt(0);\n@@ -5480,2 +5630,1 @@\n-        }\n-        else if (!next && !history.previous()) {\n+        } else if (!next && !history.previous()) {\n@@ -5485,3 +5634,4 @@\n-        setBuffer(modifiedHistory.containsKey(history.index())\n-                    ? modifiedHistory.get(history.index())\n-                    : history.current());\n+        setBuffer(\n+                modifiedHistory.containsKey(history.index())\n+                        ? modifiedHistory.get(history.index())\n+                        : history.current());\n@@ -5518,1 +5668,0 @@\n-\n@@ -5728,2 +5877,1 @@\n-        if (event.getType() == MouseEvent.Type.Released\n-                && event.getButton() == MouseEvent.Button.Button1) {\n+        if (event.getType() == MouseEvent.Type.Released && event.getButton() == MouseEvent.Button.Button1) {\n@@ -5737,1 +5885,1 @@\n-            AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);\n+            AttributedStringBuilder sb = new AttributedStringBuilder().tabs(getTabWidth());\n@@ -5740,1 +5888,2 @@\n-            List<AttributedString> promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n+            List<AttributedString> promptLines =\n+                    sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n@@ -5744,2 +5893,6 @@\n-            int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();\n-            int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();\n+            int pl0 = currentLine == 0\n+                    ? prompt.columnLength()\n+                    : secondaryPrompts.get(currentLine - 1).columnLength();\n+            int pl1 = wantedLine == 0\n+                    ? prompt.columnLength()\n+                    : secondaryPrompts.get(wantedLine - 1).columnLength();\n@@ -5817,2 +5970,1 @@\n-                bell_preference = getBoolean(PREFER_VISIBLE_BELL, false)\n-                        ? BellType.VISIBLE : BellType.AUDIBLE;\n+                bell_preference = getBoolean(PREFER_VISIBLE_BELL, false) ? BellType.VISIBLE : BellType.AUDIBLE;\n@@ -5822,2 +5974,1 @@\n-            if (terminal.puts(Capability.flash_screen)\n-                    || terminal.puts(Capability.bell)) {\n+            if (terminal.puts(Capability.flash_screen) || terminal.puts(Capability.bell)) {\n@@ -5872,2 +6023,1 @@\n-        return Character.isLetterOrDigit(c)\n-                || (c < 128 && wordchars.indexOf((char) c) >= 0);\n+        return Character.isLetterOrDigit(c) || (c < 128 && wordchars.indexOf((char) c) >= 0);\n@@ -5902,0 +6052,2 @@\n+        keyMaps.put(DUMB, dumb());\n+\n@@ -5912,2 +6064,3 @@\n-        \/\/ By default, link main to emacs\n-        keyMaps.put(MAIN, keyMaps.get(EMACS));\n+        \/\/ By default, link main to emacs unless the temrinal is dumb\n+        keyMaps.put(MAIN, keyMaps.get(isTerminalDumb() ? DUMB : EMACS));\n+\n@@ -5920,72 +6073,72 @@\n-        bind(emacs, SET_MARK_COMMAND,                       ctrl('@'));\n-        bind(emacs, BEGINNING_OF_LINE,                      ctrl('A'));\n-        bind(emacs, BACKWARD_CHAR,                          ctrl('B'));\n-        bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl('D'));\n-        bind(emacs, END_OF_LINE,                            ctrl('E'));\n-        bind(emacs, FORWARD_CHAR,                           ctrl('F'));\n-        bind(emacs, SEND_BREAK,                             ctrl('G'));\n-        bind(emacs, BACKWARD_DELETE_CHAR,                   ctrl('H'));\n-        bind(emacs, EXPAND_OR_COMPLETE,                     ctrl('I'));\n-        bind(emacs, ACCEPT_LINE,                            ctrl('J'));\n-        bind(emacs, KILL_LINE,                              ctrl('K'));\n-        bind(emacs, CLEAR_SCREEN,                           ctrl('L'));\n-        bind(emacs, ACCEPT_LINE,                            ctrl('M'));\n-        bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl('N'));\n-        bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl('O'));\n-        bind(emacs, UP_LINE_OR_HISTORY,                     ctrl('P'));\n-        bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('R'));\n-        bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('S'));\n-        bind(emacs, TRANSPOSE_CHARS,                        ctrl('T'));\n-        bind(emacs, KILL_WHOLE_LINE,                        ctrl('U'));\n-        bind(emacs, QUOTED_INSERT,                          ctrl('V'));\n-        bind(emacs, BACKWARD_KILL_WORD,                     ctrl('W'));\n-        bind(emacs, YANK,                                   ctrl('Y'));\n-        bind(emacs, CHARACTER_SEARCH,                       ctrl(']'));\n-        bind(emacs, UNDO,                                   ctrl('_'));\n-        bind(emacs, SELF_INSERT,                            range(\" -~\"));\n-        bind(emacs, INSERT_CLOSE_PAREN,                     \")\");\n-        bind(emacs, INSERT_CLOSE_SQUARE,                    \"]\");\n-        bind(emacs, INSERT_CLOSE_CURLY,                     \"}\");\n-        bind(emacs, BACKWARD_DELETE_CHAR,                   del());\n-        bind(emacs, VI_MATCH_BRACKET,                       translate(\"^X^B\"));\n-        bind(emacs, SEND_BREAK,                             translate(\"^X^G\"));\n-        bind(emacs, EDIT_AND_EXECUTE_COMMAND,               translate(\"^X^E\"));\n-        bind(emacs, VI_FIND_NEXT_CHAR,                      translate(\"^X^F\"));\n-        bind(emacs, VI_JOIN,                                translate(\"^X^J\"));\n-        bind(emacs, KILL_BUFFER,                            translate(\"^X^K\"));\n-        bind(emacs, INFER_NEXT_HISTORY,                     translate(\"^X^N\"));\n-        bind(emacs, OVERWRITE_MODE,                         translate(\"^X^O\"));\n-        bind(emacs, REDO,                                   translate(\"^X^R\"));\n-        bind(emacs, UNDO,                                   translate(\"^X^U\"));\n-        bind(emacs, VI_CMD_MODE,                            translate(\"^X^V\"));\n-        bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(\"^X^X\"));\n-        bind(emacs, DO_LOWERCASE_VERSION,                   translate(\"^XA-^XZ\"));\n-        bind(emacs, WHAT_CURSOR_POSITION,                   translate(\"^X=\"));\n-        bind(emacs, KILL_LINE,                              translate(\"^X^?\"));\n-        bind(emacs, SEND_BREAK,                             alt(ctrl('G')));\n-        bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl('H')));\n-        bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl('M')));\n-        bind(emacs, COMPLETE_WORD,                          alt(esc()));\n-        bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(']')));\n-        bind(emacs, COPY_PREV_WORD,                         alt(ctrl('_')));\n-        bind(emacs, SET_MARK_COMMAND,                       alt(' '));\n-        bind(emacs, NEG_ARGUMENT,                           alt('-'));\n-        bind(emacs, DIGIT_ARGUMENT,                         range(\"\\\\E0-\\\\E9\"));\n-        bind(emacs, BEGINNING_OF_HISTORY,                   alt('<'));\n-        bind(emacs, LIST_CHOICES,                           alt('='));\n-        bind(emacs, END_OF_HISTORY,                         alt('>'));\n-        bind(emacs, LIST_CHOICES,                           alt('?'));\n-        bind(emacs, DO_LOWERCASE_VERSION,                   range(\"^[A-^[Z\"));\n-        bind(emacs, ACCEPT_AND_HOLD,                        alt('a'));\n-        bind(emacs, BACKWARD_WORD,                          alt('b'));\n-        bind(emacs, CAPITALIZE_WORD,                        alt('c'));\n-        bind(emacs, KILL_WORD,                              alt('d'));\n-        bind(emacs, KILL_WORD,                              translate(\"^[[3;5~\")); \/\/ ctrl-delete\n-        bind(emacs, FORWARD_WORD,                           alt('f'));\n-        bind(emacs, DOWN_CASE_WORD,                         alt('l'));\n-        bind(emacs, HISTORY_SEARCH_FORWARD,                 alt('n'));\n-        bind(emacs, HISTORY_SEARCH_BACKWARD,                alt('p'));\n-        bind(emacs, TRANSPOSE_WORDS,                        alt('t'));\n-        bind(emacs, UP_CASE_WORD,                           alt('u'));\n-        bind(emacs, YANK_POP,                               alt('y'));\n-        bind(emacs, BACKWARD_KILL_WORD,                     alt(del()));\n+        bind(emacs, SET_MARK_COMMAND, ctrl('@'));\n+        bind(emacs, BEGINNING_OF_LINE, ctrl('A'));\n+        bind(emacs, BACKWARD_CHAR, ctrl('B'));\n+        bind(emacs, DELETE_CHAR_OR_LIST, ctrl('D'));\n+        bind(emacs, END_OF_LINE, ctrl('E'));\n+        bind(emacs, FORWARD_CHAR, ctrl('F'));\n+        bind(emacs, SEND_BREAK, ctrl('G'));\n+        bind(emacs, BACKWARD_DELETE_CHAR, ctrl('H'));\n+        bind(emacs, EXPAND_OR_COMPLETE, ctrl('I'));\n+        bind(emacs, ACCEPT_LINE, ctrl('J'));\n+        bind(emacs, KILL_LINE, ctrl('K'));\n+        bind(emacs, CLEAR_SCREEN, ctrl('L'));\n+        bind(emacs, ACCEPT_LINE, ctrl('M'));\n+        bind(emacs, DOWN_LINE_OR_HISTORY, ctrl('N'));\n+        bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY, ctrl('O'));\n+        bind(emacs, UP_LINE_OR_HISTORY, ctrl('P'));\n+        bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('R'));\n+        bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('S'));\n+        bind(emacs, TRANSPOSE_CHARS, ctrl('T'));\n+        bind(emacs, KILL_WHOLE_LINE, ctrl('U'));\n+        bind(emacs, QUOTED_INSERT, ctrl('V'));\n+        bind(emacs, BACKWARD_KILL_WORD, ctrl('W'));\n+        bind(emacs, YANK, ctrl('Y'));\n+        bind(emacs, CHARACTER_SEARCH, ctrl(']'));\n+        bind(emacs, UNDO, ctrl('_'));\n+        bind(emacs, SELF_INSERT, range(\" -~\"));\n+        bind(emacs, INSERT_CLOSE_PAREN, \")\");\n+        bind(emacs, INSERT_CLOSE_SQUARE, \"]\");\n+        bind(emacs, INSERT_CLOSE_CURLY, \"}\");\n+        bind(emacs, BACKWARD_DELETE_CHAR, del());\n+        bind(emacs, VI_MATCH_BRACKET, translate(\"^X^B\"));\n+        bind(emacs, SEND_BREAK, translate(\"^X^G\"));\n+        bind(emacs, EDIT_AND_EXECUTE_COMMAND, translate(\"^X^E\"));\n+        bind(emacs, VI_FIND_NEXT_CHAR, translate(\"^X^F\"));\n+        bind(emacs, VI_JOIN, translate(\"^X^J\"));\n+        bind(emacs, KILL_BUFFER, translate(\"^X^K\"));\n+        bind(emacs, INFER_NEXT_HISTORY, translate(\"^X^N\"));\n+        bind(emacs, OVERWRITE_MODE, translate(\"^X^O\"));\n+        bind(emacs, REDO, translate(\"^X^R\"));\n+        bind(emacs, UNDO, translate(\"^X^U\"));\n+        bind(emacs, VI_CMD_MODE, translate(\"^X^V\"));\n+        bind(emacs, EXCHANGE_POINT_AND_MARK, translate(\"^X^X\"));\n+        bind(emacs, DO_LOWERCASE_VERSION, translate(\"^XA-^XZ\"));\n+        bind(emacs, WHAT_CURSOR_POSITION, translate(\"^X=\"));\n+        bind(emacs, KILL_LINE, translate(\"^X^?\"));\n+        bind(emacs, SEND_BREAK, alt(ctrl('G')));\n+        bind(emacs, BACKWARD_KILL_WORD, alt(ctrl('H')));\n+        bind(emacs, SELF_INSERT_UNMETA, alt(ctrl('M')));\n+        bind(emacs, COMPLETE_WORD, alt(esc()));\n+        bind(emacs, CHARACTER_SEARCH_BACKWARD, alt(ctrl(']')));\n+        bind(emacs, COPY_PREV_WORD, alt(ctrl('_')));\n+        bind(emacs, SET_MARK_COMMAND, alt(' '));\n+        bind(emacs, NEG_ARGUMENT, alt('-'));\n+        bind(emacs, DIGIT_ARGUMENT, range(\"\\\\E0-\\\\E9\"));\n+        bind(emacs, BEGINNING_OF_HISTORY, alt('<'));\n+        bind(emacs, LIST_CHOICES, alt('='));\n+        bind(emacs, END_OF_HISTORY, alt('>'));\n+        bind(emacs, LIST_CHOICES, alt('?'));\n+        bind(emacs, DO_LOWERCASE_VERSION, range(\"^[A-^[Z\"));\n+        bind(emacs, ACCEPT_AND_HOLD, alt('a'));\n+        bind(emacs, BACKWARD_WORD, alt('b'));\n+        bind(emacs, CAPITALIZE_WORD, alt('c'));\n+        bind(emacs, KILL_WORD, alt('d'));\n+        bind(emacs, KILL_WORD, translate(\"^[[3;5~\")); \/\/ ctrl-delete\n+        bind(emacs, FORWARD_WORD, alt('f'));\n+        bind(emacs, DOWN_CASE_WORD, alt('l'));\n+        bind(emacs, HISTORY_SEARCH_FORWARD, alt('n'));\n+        bind(emacs, HISTORY_SEARCH_BACKWARD, alt('p'));\n+        bind(emacs, TRANSPOSE_WORDS, alt('t'));\n+        bind(emacs, UP_CASE_WORD, alt('u'));\n+        bind(emacs, YANK_POP, alt('y'));\n+        bind(emacs, BACKWARD_KILL_WORD, alt(del()));\n@@ -5993,6 +6146,6 @@\n-        bind(emacs, FORWARD_WORD,                           translate(\"^[[1;5C\")); \/\/ ctrl-left\n-        bind(emacs, BACKWARD_WORD,                          translate(\"^[[1;5D\")); \/\/ ctrl-right\n-        bind(emacs, FORWARD_WORD,                           alt(key(Capability.key_right)));\n-        bind(emacs, BACKWARD_WORD,                          alt(key(Capability.key_left)));\n-        bind(emacs, FORWARD_WORD,                           alt(translate(\"^[[C\")));\n-        bind(emacs, BACKWARD_WORD,                          alt(translate(\"^[[D\")));\n+        bind(emacs, FORWARD_WORD, translate(\"^[[1;5C\")); \/\/ ctrl-left\n+        bind(emacs, BACKWARD_WORD, translate(\"^[[1;5D\")); \/\/ ctrl-right\n+        bind(emacs, FORWARD_WORD, alt(key(Capability.key_right)));\n+        bind(emacs, BACKWARD_WORD, alt(key(Capability.key_left)));\n+        bind(emacs, FORWARD_WORD, alt(translate(\"^[[C\")));\n+        bind(emacs, BACKWARD_WORD, alt(translate(\"^[[D\")));\n@@ -6005,26 +6158,26 @@\n-        bind(viins, SELF_INSERT,                            range(\"^@-^_\"));\n-        bind(viins, LIST_CHOICES,                           ctrl('D'));\n-        bind(viins, SEND_BREAK,                             ctrl('G'));\n-        bind(viins, BACKWARD_DELETE_CHAR,                   ctrl('H'));\n-        bind(viins, EXPAND_OR_COMPLETE,                     ctrl('I'));\n-        bind(viins, ACCEPT_LINE,                            ctrl('J'));\n-        bind(viins, CLEAR_SCREEN,                           ctrl('L'));\n-        bind(viins, ACCEPT_LINE,                            ctrl('M'));\n-        bind(viins, MENU_COMPLETE,                          ctrl('N'));\n-        bind(viins, REVERSE_MENU_COMPLETE,                  ctrl('P'));\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('R'));\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('S'));\n-        bind(viins, TRANSPOSE_CHARS,                        ctrl('T'));\n-        bind(viins, KILL_WHOLE_LINE,                        ctrl('U'));\n-        bind(viins, QUOTED_INSERT,                          ctrl('V'));\n-        bind(viins, BACKWARD_KILL_WORD,                     ctrl('W'));\n-        bind(viins, YANK,                                   ctrl('Y'));\n-        bind(viins, VI_CMD_MODE,                            ctrl('['));\n-        bind(viins, UNDO,                                   ctrl('_'));\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('X') + \"r\");\n-        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('X') + \"s\");\n-        bind(viins, SELF_INSERT,                            range(\" -~\"));\n-        bind(viins, INSERT_CLOSE_PAREN,                     \")\");\n-        bind(viins, INSERT_CLOSE_SQUARE,                    \"]\");\n-        bind(viins, INSERT_CLOSE_CURLY,                     \"}\");\n-        bind(viins, BACKWARD_DELETE_CHAR,                   del());\n+        bind(viins, SELF_INSERT, range(\"^@-^_\"));\n+        bind(viins, LIST_CHOICES, ctrl('D'));\n+        bind(viins, SEND_BREAK, ctrl('G'));\n+        bind(viins, BACKWARD_DELETE_CHAR, ctrl('H'));\n+        bind(viins, EXPAND_OR_COMPLETE, ctrl('I'));\n+        bind(viins, ACCEPT_LINE, ctrl('J'));\n+        bind(viins, CLEAR_SCREEN, ctrl('L'));\n+        bind(viins, ACCEPT_LINE, ctrl('M'));\n+        bind(viins, MENU_COMPLETE, ctrl('N'));\n+        bind(viins, REVERSE_MENU_COMPLETE, ctrl('P'));\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('R'));\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('S'));\n+        bind(viins, TRANSPOSE_CHARS, ctrl('T'));\n+        bind(viins, KILL_WHOLE_LINE, ctrl('U'));\n+        bind(viins, QUOTED_INSERT, ctrl('V'));\n+        bind(viins, BACKWARD_KILL_WORD, ctrl('W'));\n+        bind(viins, YANK, ctrl('Y'));\n+        bind(viins, VI_CMD_MODE, ctrl('['));\n+        bind(viins, UNDO, ctrl('_'));\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('X') + \"r\");\n+        bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('X') + \"s\");\n+        bind(viins, SELF_INSERT, range(\" -~\"));\n+        bind(viins, INSERT_CLOSE_PAREN, \")\");\n+        bind(viins, INSERT_CLOSE_SQUARE, \"]\");\n+        bind(viins, INSERT_CLOSE_CURLY, \"}\");\n+        bind(viins, BACKWARD_DELETE_CHAR, del());\n@@ -6037,109 +6190,109 @@\n-        bind(vicmd, LIST_CHOICES,                           ctrl('D'));\n-        bind(vicmd, EMACS_EDITING_MODE,                     ctrl('E'));\n-        bind(vicmd, SEND_BREAK,                             ctrl('G'));\n-        bind(vicmd, VI_BACKWARD_CHAR,                       ctrl('H'));\n-        bind(vicmd, ACCEPT_LINE,                            ctrl('J'));\n-        bind(vicmd, KILL_LINE,                              ctrl('K'));\n-        bind(vicmd, CLEAR_SCREEN,                           ctrl('L'));\n-        bind(vicmd, ACCEPT_LINE,                            ctrl('M'));\n-        bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                ctrl('N'));\n-        bind(vicmd, VI_UP_LINE_OR_HISTORY,                  ctrl('P'));\n-        bind(vicmd, QUOTED_INSERT,                          ctrl('Q'));\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('R'));\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('S'));\n-        bind(vicmd, TRANSPOSE_CHARS,                        ctrl('T'));\n-        bind(vicmd, KILL_WHOLE_LINE,                        ctrl('U'));\n-        bind(vicmd, QUOTED_INSERT,                          ctrl('V'));\n-        bind(vicmd, BACKWARD_KILL_WORD,                     ctrl('W'));\n-        bind(vicmd, YANK,                                   ctrl('Y'));\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl('X') + \"r\");\n-        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl('X') + \"s\");\n-        bind(vicmd, SEND_BREAK,                             alt(ctrl('G')));\n-        bind(vicmd, BACKWARD_KILL_WORD,                     alt(ctrl('H')));\n-        bind(vicmd, SELF_INSERT_UNMETA,                     alt(ctrl('M')));\n-        bind(vicmd, COMPLETE_WORD,                          alt(esc()));\n-        bind(vicmd, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(']')));\n-        bind(vicmd, SET_MARK_COMMAND,                       alt(' '));\n-\/\/        bind(vicmd, INSERT_COMMENT,                         alt('#'));\n-\/\/        bind(vicmd, INSERT_COMPLETIONS,                     alt('*'));\n-        bind(vicmd, DIGIT_ARGUMENT,                         alt('-'));\n-        bind(vicmd, BEGINNING_OF_HISTORY,                   alt('<'));\n-        bind(vicmd, LIST_CHOICES,                           alt('='));\n-        bind(vicmd, END_OF_HISTORY,                         alt('>'));\n-        bind(vicmd, LIST_CHOICES,                           alt('?'));\n-        bind(vicmd, DO_LOWERCASE_VERSION,                   range(\"^[A-^[Z\"));\n-        bind(vicmd, BACKWARD_WORD,                          alt('b'));\n-        bind(vicmd, CAPITALIZE_WORD,                        alt('c'));\n-        bind(vicmd, KILL_WORD,                              alt('d'));\n-        bind(vicmd, FORWARD_WORD,                           alt('f'));\n-        bind(vicmd, DOWN_CASE_WORD,                         alt('l'));\n-        bind(vicmd, HISTORY_SEARCH_FORWARD,                 alt('n'));\n-        bind(vicmd, HISTORY_SEARCH_BACKWARD,                alt('p'));\n-        bind(vicmd, TRANSPOSE_WORDS,                        alt('t'));\n-        bind(vicmd, UP_CASE_WORD,                           alt('u'));\n-        bind(vicmd, YANK_POP,                               alt('y'));\n-        bind(vicmd, BACKWARD_KILL_WORD,                     alt(del()));\n-\n-        bind(vicmd, FORWARD_CHAR,                           \" \");\n-        bind(vicmd, VI_INSERT_COMMENT,                      \"#\");\n-        bind(vicmd, END_OF_LINE,                            \"$\");\n-        bind(vicmd, VI_MATCH_BRACKET,                       \"%\");\n-        bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                \"+\");\n-        bind(vicmd, VI_REV_REPEAT_FIND,                     \",\");\n-        bind(vicmd, VI_UP_LINE_OR_HISTORY,                  \"-\");\n-        bind(vicmd, VI_REPEAT_CHANGE,                       \".\");\n-        bind(vicmd, VI_HISTORY_SEARCH_BACKWARD,             \"\/\");\n-        bind(vicmd, VI_DIGIT_OR_BEGINNING_OF_LINE,          \"0\");\n-        bind(vicmd, DIGIT_ARGUMENT,                         range(\"1-9\"));\n-        bind(vicmd, VI_REPEAT_FIND,                         \";\");\n-        bind(vicmd, LIST_CHOICES,                           \"=\");\n-        bind(vicmd, VI_HISTORY_SEARCH_FORWARD,              \"?\");\n-        bind(vicmd, VI_ADD_EOL,                             \"A\");\n-        bind(vicmd, VI_BACKWARD_BLANK_WORD,                 \"B\");\n-        bind(vicmd, VI_CHANGE_EOL,                          \"C\");\n-        bind(vicmd, VI_KILL_EOL,                            \"D\");\n-        bind(vicmd, VI_FORWARD_BLANK_WORD_END,              \"E\");\n-        bind(vicmd, VI_FIND_PREV_CHAR,                      \"F\");\n-        bind(vicmd, VI_FETCH_HISTORY,                       \"G\");\n-        bind(vicmd, VI_INSERT_BOL,                          \"I\");\n-        bind(vicmd, VI_JOIN,                                \"J\");\n-        bind(vicmd, VI_REV_REPEAT_SEARCH,                   \"N\");\n-        bind(vicmd, VI_OPEN_LINE_ABOVE,                     \"O\");\n-        bind(vicmd, VI_PUT_BEFORE,                          \"P\");\n-        bind(vicmd, VI_REPLACE,                             \"R\");\n-        bind(vicmd, VI_KILL_LINE,                           \"S\");\n-        bind(vicmd, VI_FIND_PREV_CHAR_SKIP,                 \"T\");\n-        bind(vicmd, REDO,                                   \"U\");\n-        bind(vicmd, VISUAL_LINE_MODE,                       \"V\");\n-        bind(vicmd, VI_FORWARD_BLANK_WORD,                  \"W\");\n-        bind(vicmd, VI_BACKWARD_DELETE_CHAR,                \"X\");\n-        bind(vicmd, VI_YANK_WHOLE_LINE,                     \"Y\");\n-        bind(vicmd, VI_FIRST_NON_BLANK,                     \"^\");\n-        bind(vicmd, VI_ADD_NEXT,                            \"a\");\n-        bind(vicmd, VI_BACKWARD_WORD,                       \"b\");\n-        bind(vicmd, VI_CHANGE,                              \"c\");\n-        bind(vicmd, VI_DELETE,                              \"d\");\n-        bind(vicmd, VI_FORWARD_WORD_END,                    \"e\");\n-        bind(vicmd, VI_FIND_NEXT_CHAR,                      \"f\");\n-        bind(vicmd, WHAT_CURSOR_POSITION,                   \"ga\");\n-        bind(vicmd, VI_BACKWARD_BLANK_WORD_END,             \"gE\");\n-        bind(vicmd, VI_BACKWARD_WORD_END,                   \"ge\");\n-        bind(vicmd, VI_BACKWARD_CHAR,                       \"h\");\n-        bind(vicmd, VI_INSERT,                              \"i\");\n-        bind(vicmd, DOWN_LINE_OR_HISTORY,                   \"j\");\n-        bind(vicmd, UP_LINE_OR_HISTORY,                     \"k\");\n-        bind(vicmd, VI_FORWARD_CHAR,                        \"l\");\n-        bind(vicmd, VI_REPEAT_SEARCH,                       \"n\");\n-        bind(vicmd, VI_OPEN_LINE_BELOW,                     \"o\");\n-        bind(vicmd, VI_PUT_AFTER,                           \"p\");\n-        bind(vicmd, VI_REPLACE_CHARS,                       \"r\");\n-        bind(vicmd, VI_SUBSTITUTE,                          \"s\");\n-        bind(vicmd, VI_FIND_NEXT_CHAR_SKIP,                 \"t\");\n-        bind(vicmd, UNDO,                                   \"u\");\n-        bind(vicmd, VISUAL_MODE,                            \"v\");\n-        bind(vicmd, VI_FORWARD_WORD,                        \"w\");\n-        bind(vicmd, VI_DELETE_CHAR,                         \"x\");\n-        bind(vicmd, VI_YANK,                                \"y\");\n-        bind(vicmd, VI_GOTO_COLUMN,                         \"|\");\n-        bind(vicmd, VI_SWAP_CASE,                           \"~\");\n-        bind(vicmd, VI_BACKWARD_CHAR,                       del());\n+        bind(vicmd, LIST_CHOICES, ctrl('D'));\n+        bind(vicmd, EMACS_EDITING_MODE, ctrl('E'));\n+        bind(vicmd, SEND_BREAK, ctrl('G'));\n+        bind(vicmd, VI_BACKWARD_CHAR, ctrl('H'));\n+        bind(vicmd, ACCEPT_LINE, ctrl('J'));\n+        bind(vicmd, KILL_LINE, ctrl('K'));\n+        bind(vicmd, CLEAR_SCREEN, ctrl('L'));\n+        bind(vicmd, ACCEPT_LINE, ctrl('M'));\n+        bind(vicmd, VI_DOWN_LINE_OR_HISTORY, ctrl('N'));\n+        bind(vicmd, VI_UP_LINE_OR_HISTORY, ctrl('P'));\n+        bind(vicmd, QUOTED_INSERT, ctrl('Q'));\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('R'));\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('S'));\n+        bind(vicmd, TRANSPOSE_CHARS, ctrl('T'));\n+        bind(vicmd, KILL_WHOLE_LINE, ctrl('U'));\n+        bind(vicmd, QUOTED_INSERT, ctrl('V'));\n+        bind(vicmd, BACKWARD_KILL_WORD, ctrl('W'));\n+        bind(vicmd, YANK, ctrl('Y'));\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD, ctrl('X') + \"r\");\n+        bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD, ctrl('X') + \"s\");\n+        bind(vicmd, SEND_BREAK, alt(ctrl('G')));\n+        bind(vicmd, BACKWARD_KILL_WORD, alt(ctrl('H')));\n+        bind(vicmd, SELF_INSERT_UNMETA, alt(ctrl('M')));\n+        bind(vicmd, COMPLETE_WORD, alt(esc()));\n+        bind(vicmd, CHARACTER_SEARCH_BACKWARD, alt(ctrl(']')));\n+        bind(vicmd, SET_MARK_COMMAND, alt(' '));\n+        \/\/        bind(vicmd, INSERT_COMMENT,                         alt('#'));\n+        \/\/        bind(vicmd, INSERT_COMPLETIONS,                     alt('*'));\n+        bind(vicmd, DIGIT_ARGUMENT, alt('-'));\n+        bind(vicmd, BEGINNING_OF_HISTORY, alt('<'));\n+        bind(vicmd, LIST_CHOICES, alt('='));\n+        bind(vicmd, END_OF_HISTORY, alt('>'));\n+        bind(vicmd, LIST_CHOICES, alt('?'));\n+        bind(vicmd, DO_LOWERCASE_VERSION, range(\"^[A-^[Z\"));\n+        bind(vicmd, BACKWARD_WORD, alt('b'));\n+        bind(vicmd, CAPITALIZE_WORD, alt('c'));\n+        bind(vicmd, KILL_WORD, alt('d'));\n+        bind(vicmd, FORWARD_WORD, alt('f'));\n+        bind(vicmd, DOWN_CASE_WORD, alt('l'));\n+        bind(vicmd, HISTORY_SEARCH_FORWARD, alt('n'));\n+        bind(vicmd, HISTORY_SEARCH_BACKWARD, alt('p'));\n+        bind(vicmd, TRANSPOSE_WORDS, alt('t'));\n+        bind(vicmd, UP_CASE_WORD, alt('u'));\n+        bind(vicmd, YANK_POP, alt('y'));\n+        bind(vicmd, BACKWARD_KILL_WORD, alt(del()));\n+\n+        bind(vicmd, FORWARD_CHAR, \" \");\n+        bind(vicmd, VI_INSERT_COMMENT, \"#\");\n+        bind(vicmd, END_OF_LINE, \"$\");\n+        bind(vicmd, VI_MATCH_BRACKET, \"%\");\n+        bind(vicmd, VI_DOWN_LINE_OR_HISTORY, \"+\");\n+        bind(vicmd, VI_REV_REPEAT_FIND, \",\");\n+        bind(vicmd, VI_UP_LINE_OR_HISTORY, \"-\");\n+        bind(vicmd, VI_REPEAT_CHANGE, \".\");\n+        bind(vicmd, VI_HISTORY_SEARCH_BACKWARD, \"\/\");\n+        bind(vicmd, VI_DIGIT_OR_BEGINNING_OF_LINE, \"0\");\n+        bind(vicmd, DIGIT_ARGUMENT, range(\"1-9\"));\n+        bind(vicmd, VI_REPEAT_FIND, \";\");\n+        bind(vicmd, LIST_CHOICES, \"=\");\n+        bind(vicmd, VI_HISTORY_SEARCH_FORWARD, \"?\");\n+        bind(vicmd, VI_ADD_EOL, \"A\");\n+        bind(vicmd, VI_BACKWARD_BLANK_WORD, \"B\");\n+        bind(vicmd, VI_CHANGE_EOL, \"C\");\n+        bind(vicmd, VI_KILL_EOL, \"D\");\n+        bind(vicmd, VI_FORWARD_BLANK_WORD_END, \"E\");\n+        bind(vicmd, VI_FIND_PREV_CHAR, \"F\");\n+        bind(vicmd, VI_FETCH_HISTORY, \"G\");\n+        bind(vicmd, VI_INSERT_BOL, \"I\");\n+        bind(vicmd, VI_JOIN, \"J\");\n+        bind(vicmd, VI_REV_REPEAT_SEARCH, \"N\");\n+        bind(vicmd, VI_OPEN_LINE_ABOVE, \"O\");\n+        bind(vicmd, VI_PUT_BEFORE, \"P\");\n+        bind(vicmd, VI_REPLACE, \"R\");\n+        bind(vicmd, VI_KILL_LINE, \"S\");\n+        bind(vicmd, VI_FIND_PREV_CHAR_SKIP, \"T\");\n+        bind(vicmd, REDO, \"U\");\n+        bind(vicmd, VISUAL_LINE_MODE, \"V\");\n+        bind(vicmd, VI_FORWARD_BLANK_WORD, \"W\");\n+        bind(vicmd, VI_BACKWARD_DELETE_CHAR, \"X\");\n+        bind(vicmd, VI_YANK_WHOLE_LINE, \"Y\");\n+        bind(vicmd, VI_FIRST_NON_BLANK, \"^\");\n+        bind(vicmd, VI_ADD_NEXT, \"a\");\n+        bind(vicmd, VI_BACKWARD_WORD, \"b\");\n+        bind(vicmd, VI_CHANGE, \"c\");\n+        bind(vicmd, VI_DELETE, \"d\");\n+        bind(vicmd, VI_FORWARD_WORD_END, \"e\");\n+        bind(vicmd, VI_FIND_NEXT_CHAR, \"f\");\n+        bind(vicmd, WHAT_CURSOR_POSITION, \"ga\");\n+        bind(vicmd, VI_BACKWARD_BLANK_WORD_END, \"gE\");\n+        bind(vicmd, VI_BACKWARD_WORD_END, \"ge\");\n+        bind(vicmd, VI_BACKWARD_CHAR, \"h\");\n+        bind(vicmd, VI_INSERT, \"i\");\n+        bind(vicmd, DOWN_LINE_OR_HISTORY, \"j\");\n+        bind(vicmd, UP_LINE_OR_HISTORY, \"k\");\n+        bind(vicmd, VI_FORWARD_CHAR, \"l\");\n+        bind(vicmd, VI_REPEAT_SEARCH, \"n\");\n+        bind(vicmd, VI_OPEN_LINE_BELOW, \"o\");\n+        bind(vicmd, VI_PUT_AFTER, \"p\");\n+        bind(vicmd, VI_REPLACE_CHARS, \"r\");\n+        bind(vicmd, VI_SUBSTITUTE, \"s\");\n+        bind(vicmd, VI_FIND_NEXT_CHAR_SKIP, \"t\");\n+        bind(vicmd, UNDO, \"u\");\n+        bind(vicmd, VISUAL_MODE, \"v\");\n+        bind(vicmd, VI_FORWARD_WORD, \"w\");\n+        bind(vicmd, VI_DELETE_CHAR, \"x\");\n+        bind(vicmd, VI_YANK, \"y\");\n+        bind(vicmd, VI_GOTO_COLUMN, \"|\");\n+        bind(vicmd, VI_SWAP_CASE, \"~\");\n+        bind(vicmd, VI_BACKWARD_CHAR, del());\n@@ -6153,3 +6306,3 @@\n-        bind(menu, MENU_COMPLETE,                     \"\\t\");\n-        bind(menu, REVERSE_MENU_COMPLETE,             key(Capability.back_tab));\n-        bind(menu, ACCEPT_LINE,                       \"\\r\", \"\\n\");\n+        bind(menu, MENU_COMPLETE, \"\\t\");\n+        bind(menu, REVERSE_MENU_COMPLETE, key(Capability.back_tab));\n+        bind(menu, ACCEPT_LINE, \"\\r\", \"\\n\");\n@@ -6162,3 +6315,3 @@\n-        bind(safe, SELF_INSERT,                 range(\"^@-^?\"));\n-        bind(safe, ACCEPT_LINE,                 \"\\r\", \"\\n\");\n-        bind(safe, SEND_BREAK,                  ctrl('G'));\n+        bind(safe, SELF_INSERT, range(\"^@-^?\"));\n+        bind(safe, ACCEPT_LINE, \"\\r\", \"\\n\");\n+        bind(safe, SEND_BREAK, ctrl('G'));\n@@ -6168,0 +6321,8 @@\n+    public KeyMap<Binding> dumb() {\n+        KeyMap<Binding> dumb = new KeyMap<>();\n+        bind(dumb, SELF_INSERT, range(\"^@-^?\"));\n+        bind(dumb, ACCEPT_LINE, \"\\r\", \"\\n\");\n+        bind(dumb, BEEP, ctrl('G'));\n+        return dumb;\n+    }\n+\n@@ -6170,7 +6331,7 @@\n-        bind(visual, UP_LINE,                   key(Capability.key_up),     \"k\");\n-        bind(visual, DOWN_LINE,                 key(Capability.key_down),   \"j\");\n-        bind(visual, this::deactivateRegion,    esc());\n-        bind(visual, EXCHANGE_POINT_AND_MARK,   \"o\");\n-        bind(visual, PUT_REPLACE_SELECTION,     \"p\");\n-        bind(visual, VI_DELETE,                 \"x\");\n-        bind(visual, VI_OPER_SWAP_CASE,         \"~\");\n+        bind(visual, UP_LINE, key(Capability.key_up), \"k\");\n+        bind(visual, DOWN_LINE, key(Capability.key_down), \"j\");\n+        bind(visual, this::deactivateRegion, esc());\n+        bind(visual, EXCHANGE_POINT_AND_MARK, \"o\");\n+        bind(visual, PUT_REPLACE_SELECTION, \"p\");\n+        bind(visual, VI_DELETE, \"x\");\n+        bind(visual, VI_OPER_SWAP_CASE, \"~\");\n@@ -6182,3 +6343,3 @@\n-        bind(viOpp, UP_LINE,                    key(Capability.key_up),     \"k\");\n-        bind(viOpp, DOWN_LINE,                  key(Capability.key_down),   \"j\");\n-        bind(viOpp, VI_CMD_MODE,                esc());\n+        bind(viOpp, UP_LINE, key(Capability.key_up), \"k\");\n+        bind(viOpp, DOWN_LINE, key(Capability.key_down), \"j\");\n+        bind(viOpp, VI_CMD_MODE, esc());\n@@ -6213,13 +6374,13 @@\n-        bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));\n-        bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));\n-        bind(map, BACKWARD_CHAR,        key(Capability.key_left));\n-        bind(map, FORWARD_CHAR,         key(Capability.key_right));\n-        bind(map, BEGINNING_OF_LINE,    key(Capability.key_home));\n-        bind(map, END_OF_LINE,          key(Capability.key_end));\n-        bind(map, DELETE_CHAR,          key(Capability.key_dc));\n-        bind(map, KILL_WHOLE_LINE,      key(Capability.key_dl));\n-        bind(map, OVERWRITE_MODE,       key(Capability.key_ic));\n-        bind(map, MOUSE,                key(Capability.key_mouse));\n-        bind(map, BEGIN_PASTE,          BRACKETED_PASTE_BEGIN);\n-        bind(map, FOCUS_IN,             FOCUS_IN_SEQ);\n-        bind(map, FOCUS_OUT,            FOCUS_OUT_SEQ);\n+        bind(map, UP_LINE_OR_SEARCH, key(Capability.key_up));\n+        bind(map, DOWN_LINE_OR_SEARCH, key(Capability.key_down));\n+        bind(map, BACKWARD_CHAR, key(Capability.key_left));\n+        bind(map, FORWARD_CHAR, key(Capability.key_right));\n+        bind(map, BEGINNING_OF_LINE, key(Capability.key_home));\n+        bind(map, END_OF_LINE, key(Capability.key_end));\n+        bind(map, DELETE_CHAR, key(Capability.key_dc));\n+        bind(map, KILL_WHOLE_LINE, key(Capability.key_dl));\n+        bind(map, OVERWRITE_MODE, key(Capability.key_ic));\n+        bind(map, MOUSE, key(Capability.key_mouse));\n+        bind(map, BEGIN_PASTE, BRACKETED_PASTE_BEGIN);\n+        bind(map, FOCUS_IN, FOCUS_IN_SEQ);\n+        bind(map, FOCUS_OUT, FOCUS_OUT_SEQ);\n@@ -6234,8 +6395,4 @@\n-            rebind(keyMap, BACKWARD_DELETE_CHAR,\n-                    del(), (char) attr.getControlChar(ControlChar.VERASE));\n-            rebind(keyMap, BACKWARD_KILL_WORD,\n-                    ctrl('W'),  (char) attr.getControlChar(ControlChar.VWERASE));\n-            rebind(keyMap, KILL_WHOLE_LINE,\n-                    ctrl('U'), (char) attr.getControlChar(ControlChar.VKILL));\n-            rebind(keyMap, QUOTED_INSERT,\n-                    ctrl('V'), (char) attr.getControlChar(ControlChar.VLNEXT));\n+            rebind(keyMap, BACKWARD_DELETE_CHAR, del(), (char) attr.getControlChar(ControlChar.VERASE));\n+            rebind(keyMap, BACKWARD_KILL_WORD, ctrl('W'), (char) attr.getControlChar(ControlChar.VWERASE));\n+            rebind(keyMap, KILL_WHOLE_LINE, ctrl('U'), (char) attr.getControlChar(ControlChar.VKILL));\n+            rebind(keyMap, QUOTED_INSERT, ctrl('V'), (char) attr.getControlChar(ControlChar.VLNEXT));\n@@ -6253,1 +6410,0 @@\n-    \/\/ JDK specific modification\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":679,"deletions":523,"binary":false,"changes":1202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -16,1 +16,1 @@\n-    private ReaderUtils() { }\n+    private ReaderUtils() {}\n@@ -33,2 +33,1 @@\n-            return s.isEmpty() || s.equalsIgnoreCase(\"on\")\n-                    || s.equalsIgnoreCase(\"1\") || s.equalsIgnoreCase(\"true\");\n+            return s.isEmpty() || s.equalsIgnoreCase(\"on\") || s.equalsIgnoreCase(\"1\") || s.equalsIgnoreCase(\"true\");\n@@ -80,1 +79,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/ReaderUtils.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -11,2 +11,0 @@\n-import jdk.internal.org.jline.reader.MaskingCallback;\n-\n@@ -15,0 +13,2 @@\n+import jdk.internal.org.jline.reader.MaskingCallback;\n+\n@@ -32,1 +32,1 @@\n-            for (int i = line.length(); i-- > 0;) {\n+            for (int i = line.length(); i-- > 0; ) {\n@@ -43,1 +43,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/SimpleMaskingCallback.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -23,0 +23,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -74,1 +75,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/UndoTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -27,3 +27,1 @@\n-public class AggregateCompleter\n-    implements Completer\n-{\n+public class AggregateCompleter implements Completer {\n@@ -81,3 +79,1 @@\n-        return getClass().getSimpleName() + \"{\" +\n-            \"completers=\" + completers +\n-            '}';\n+        return getClass().getSimpleName() + \"{\" + \"completers=\" + completers + '}';\n@@ -85,1 +81,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/AggregateCompleter.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -32,2 +32,1 @@\n-public class ArgumentCompleter implements Completer\n-{\n+public class ArgumentCompleter implements Completer {\n@@ -111,2 +110,1 @@\n-        }\n-        else {\n+        } else {\n@@ -116,1 +114,2 @@\n-        \/\/ ensure that all the previous completers are successful before allowing this completer to pass (only if strict).\n+        \/\/ ensure that all the previous completers are successful before allowing this completer to pass (only if\n+        \/\/ strict).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/ArgumentCompleter.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -22,2 +22,1 @@\n-public class EnumCompleter extends StringsCompleter\n-{\n+public class EnumCompleter extends StringsCompleter {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/EnumCompleter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -12,0 +12,1 @@\n+import java.nio.file.DirectoryStream;\n@@ -44,1 +45,1 @@\n- * @deprecated use <code>jdk.internal.org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n+ * @deprecated use <code>org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n@@ -47,2 +48,1 @@\n-public class FileNameCompleter implements Completer\n-{\n+public class FileNameCompleter implements Completer {\n@@ -75,2 +75,2 @@\n-        try {\n-            Files.newDirectoryStream(current, this::accept).forEach(p -> {\n+        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(current, this::accept)) {\n+            directoryStream.forEach(p -> {\n@@ -82,1 +82,2 @@\n-                            null, null,\n+                            null,\n+                            null,\n@@ -87,2 +88,2 @@\n-                    candidates.add(new Candidate(value, getDisplay(reader.getTerminal(), p),\n-                            null, null, null, null, true));\n+                    candidates.add(\n+                            new Candidate(value, getDisplay(reader.getTerminal(), p), null, null, null, null, true));\n@@ -128,1 +129,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/FileNameCompleter.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -25,3 +25,1 @@\n-public final class NullCompleter\n-    implements Completer\n-{\n+public final class NullCompleter implements Completer {\n@@ -30,2 +28,1 @@\n-    public void complete(LineReader reader, final ParsedLine line, final List<Candidate> candidates) {\n-    }\n+    public void complete(LineReader reader, final ParsedLine line, final List<Candidate> candidates) {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/NullCompleter.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -30,2 +30,1 @@\n-public class StringsCompleter implements Completer\n-{\n+public class StringsCompleter implements Completer {\n@@ -57,1 +56,1 @@\n-    public StringsCompleter(Candidate ... candidates) {\n+    public StringsCompleter(Candidate... candidates) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/StringsCompleter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -25,2 +25,2 @@\n-    private Map<String,List<Completer>> completers = new HashMap<>();\n-    private Map<String,String> aliasCommand = new HashMap<>();\n+    private Map<String, List<Completer>> completers = new HashMap<>();\n+    private Map<String, String> aliasCommand = new HashMap<>();\n@@ -47,3 +47,3 @@\n-                    for (String c: completers.keySet()) {\n-                        candidates.add(new Candidate(AttributedString.stripAnsi(curBuf+c)\n-                                    , c, null, null, null, null, true));\n+                    for (String c : completers.keySet()) {\n+                        candidates.add(\n+                                new Candidate(AttributedString.stripAnsi(curBuf + c), c, null, null, null, null, true));\n@@ -84,1 +84,1 @@\n-        for (String c: commands) {\n+        for (String c : commands) {\n@@ -107,2 +107,2 @@\n-        for (Map.Entry<String, List<Completer>> entry: other.getCompleters().entrySet()) {\n-            for (Completer c: entry.getValue()) {\n+        for (Map.Entry<String, List<Completer>> entry : other.getCompleters().entrySet()) {\n+            for (Completer c : entry.getValue()) {\n@@ -115,1 +115,1 @@\n-    public void addAliases(Map<String,String> aliasCommand) {\n+    public void addAliases(Map<String, String> aliasCommand) {\n@@ -122,1 +122,1 @@\n-    private Map<String,String> getAliases() {\n+    private Map<String, String> getAliases() {\n@@ -131,1 +131,1 @@\n-        for (Map.Entry<String, List<Completer>> entry: completers.entrySet()) {\n+        for (Map.Entry<String, List<Completer>> entry : completers.entrySet()) {\n@@ -146,1 +146,1 @@\n-    public Map<String,List<Completer>> getCompleters() {\n+    public Map<String, List<Completer>> getCompleters() {\n@@ -149,1 +149,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/SystemCompleter.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -44,2 +44,1 @@\n-    public DefaultHistory() {\n-    }\n+    public DefaultHistory() {}\n@@ -47,0 +46,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -70,2 +70,1 @@\n-            }\n-            catch (IllegalArgumentException | IOException e) {\n+            } catch (IllegalArgumentException | IOException e) {\n@@ -120,1 +119,1 @@\n-    private String doHistoryFileDataKey (Path path){\n+    private String doHistoryFileDataKey(Path path) {\n@@ -126,1 +125,1 @@\n-        if (!historyFiles.containsKey(key)){\n+        if (!historyFiles.containsKey(key)) {\n@@ -136,1 +135,1 @@\n-    private boolean isLineReaderHistory (Path path) throws IOException {\n+    private boolean isLineReaderHistory(Path path) throws IOException {\n@@ -144,1 +143,1 @@\n-    private void setLastLoaded(Path path, int lastloaded){\n+    private void setLastLoaded(Path path, int lastloaded) {\n@@ -148,1 +147,1 @@\n-    private void setEntriesInFile(Path path, int entriesInFile){\n+    private void setEntriesInFile(Path path, int entriesInFile) {\n@@ -152,1 +151,1 @@\n-    private void incEntriesInFile(Path path, int amount){\n+    private void incEntriesInFile(Path path, int amount) {\n@@ -156,1 +155,1 @@\n-    private int getLastLoaded(Path path){\n+    private int getLastLoaded(Path path) {\n@@ -160,1 +159,1 @@\n-    private int getEntriesInFile(Path path){\n+    private int getEntriesInFile(Path path) {\n@@ -171,3 +170,2 @@\n-            final String badHistoryFileSyntax = \"Bad history file syntax! \" +\n-                \"The history file `\" + path + \"` may be an older history: \" +\n-                \"please remove it or use a different history file.\";\n+            final String badHistoryFileSyntax = \"Bad history file syntax! \" + \"The history file `\" + path\n+                    + \"` may be an older history: \" + \"please remove it or use a different history file.\";\n@@ -186,2 +184,1 @@\n-        }\n-        else {\n+        } else {\n@@ -213,2 +210,1 @@\n-        internalWrite(file != null ? file : getPath(),\n-                      incremental ? getLastLoaded(file) : 0);\n+        internalWrite(file != null ? file : getPath(), incremental ? getLastLoaded(file) : 0);\n@@ -230,2 +226,5 @@\n-            try (BufferedWriter writer = Files.newBufferedWriter(path.toAbsolutePath(),\n-              StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE)) {\n+            try (BufferedWriter writer = Files.newBufferedWriter(\n+                    path.toAbsolutePath(),\n+                    StandardOpenOption.WRITE,\n+                    StandardOpenOption.APPEND,\n+                    StandardOpenOption.CREATE)) {\n@@ -251,6 +250,10 @@\n-        try (BufferedReader reader = Files.newBufferedReader(path)) {\n-            reader.lines().forEach(l -> {\n-                int idx = l.indexOf(':');\n-                Instant time = Instant.ofEpochMilli(Long.parseLong(l.substring(0, idx)));\n-                String line = unescape(l.substring(idx + 1));\n-                allItems.add(createEntry(allItems.size(), time, line));\n+        try (BufferedReader historyFileReader = Files.newBufferedReader(path)) {\n+            historyFileReader.lines().forEach(l -> {\n+                if (reader.isSet(LineReader.Option.HISTORY_TIMESTAMPED)) {\n+                    int idx = l.indexOf(':');\n+                    Instant time = Instant.ofEpochMilli(Long.parseLong(l.substring(0, idx)));\n+                    String line = unescape(l.substring(idx + 1));\n+                    allItems.add(createEntry(allItems.size(), time, line));\n+                } else {\n+                    allItems.add(createEntry(allItems.size(), Instant.now(), unescape(l)));\n+                }\n@@ -262,1 +265,2 @@\n-        Path temp = Files.createTempFile(path.toAbsolutePath().getParent(), path.getFileName().toString(), \".tmp\");\n+        Path temp = Files.createTempFile(\n+                path.toAbsolutePath().getParent(), path.getFileName().toString(), \".tmp\");\n@@ -354,1 +358,1 @@\n-            throw new IllegalArgumentException(\"IndexOutOfBounds: Index:\" + idx +\", Size:\" + items.size());\n+            throw new IllegalArgumentException(\"IndexOutOfBounds: Index:\" + idx + \", Size:\" + items.size());\n@@ -385,2 +389,1 @@\n-            }\n-            catch (IOException e) {\n+            } catch (IOException e) {\n@@ -420,1 +423,1 @@\n-            for (Entry e: items) {\n+            for (Entry e : items) {\n@@ -433,1 +436,1 @@\n-            for (HistoryFileData hfd: historyFiles.values()) {\n+            for (HistoryFileData hfd : historyFiles.values()) {\n@@ -636,2 +639,1 @@\n-        public HistoryFileData() {\n-        }\n+        public HistoryFileData() {}\n@@ -670,1 +672,0 @@\n-\n@@ -672,1 +673,0 @@\n-\n@@ -674,1 +674,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/history\/DefaultHistory.java","additions":38,"deletions":39,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -46,14 +46,16 @@\n-        IGNBRK,       \/* ignore BREAK condition *\/\n-        BRKINT,       \/* map BREAK to SIGINTR *\/\n-        IGNPAR,       \/* ignore (discard) parity errors *\/\n-        PARMRK,       \/* mark parity and framing errors *\/\n-        INPCK,        \/* enable checking of parity errors *\/\n-        ISTRIP,       \/* strip 8th bit off chars *\/\n-        INLCR,        \/* map NL into CR *\/\n-        IGNCR,        \/* ignore CR *\/\n-        ICRNL,        \/* map CR to NL (ala CRMOD) *\/\n-        IXON,         \/* enable output flow control *\/\n-        IXOFF,        \/* enable input flow control *\/\n-        IXANY,        \/* any char will restart after stop *\/\n-        IMAXBEL,      \/* ring bell on input queue full *\/\n-        IUTF8         \/* maintain state for UTF-8 VERASE *\/\n+        IGNBRK, \/* ignore BREAK condition *\/\n+        BRKINT, \/* map BREAK to SIGINTR *\/\n+        IGNPAR, \/* ignore (discard) parity errors *\/\n+        PARMRK, \/* mark parity and framing errors *\/\n+        INPCK, \/* enable checking of parity errors *\/\n+        ISTRIP, \/* strip 8th bit off chars *\/\n+        INLCR, \/* map NL into CR *\/\n+        IGNCR, \/* ignore CR *\/\n+        ICRNL, \/* map CR to NL (ala CRMOD) *\/\n+        IXON, \/* enable output flow control *\/\n+        IXOFF, \/* enable input flow control *\/\n+        IXANY, \/* any char will restart after stop *\/\n+        IMAXBEL, \/* ring bell on input queue full *\/\n+        IUTF8, \/* maintain state for UTF-8 VERASE *\/\n+\n+        INORMEOL \/* normalize end-of-line *\/\n@@ -66,15 +68,15 @@\n-        OPOST,       \/* enable following output processing *\/\n-        ONLCR,       \/* map NL to CR-NL (ala CRMOD) *\/\n-        OXTABS,      \/* expand tabs to spaces *\/\n-        ONOEOT,      \/* discard EOT's (^D) on output) *\/\n-        OCRNL,       \/* map CR to NL on output *\/\n-        ONOCR,       \/* no CR output at column 0 *\/\n-        ONLRET,      \/* NL performs CR function *\/\n-        OFILL,       \/* use fill characters for delay *\/\n-        NLDLY,       \/* \\n delay *\/\n-        TABDLY,      \/* horizontal tab delay *\/\n-        CRDLY,       \/* \\r delay *\/\n-        FFDLY,       \/* form feed delay *\/\n-        BSDLY,       \/* \\b delay *\/\n-        VTDLY,       \/* vertical tab delay *\/\n-        OFDEL        \/* fill is DEL, else NUL *\/\n+        OPOST, \/* enable following output processing *\/\n+        ONLCR, \/* map NL to CR-NL (ala CRMOD) *\/\n+        OXTABS, \/* expand tabs to spaces *\/\n+        ONOEOT, \/* discard EOT's (^D) on output) *\/\n+        OCRNL, \/* map CR to NL on output *\/\n+        ONOCR, \/* no CR output at column 0 *\/\n+        ONLRET, \/* NL performs CR function *\/\n+        OFILL, \/* use fill characters for delay *\/\n+        NLDLY, \/* \\n delay *\/\n+        TABDLY, \/* horizontal tab delay *\/\n+        CRDLY, \/* \\r delay *\/\n+        FFDLY, \/* form feed delay *\/\n+        BSDLY, \/* \\b delay *\/\n+        VTDLY, \/* vertical tab delay *\/\n+        OFDEL \/* fill is DEL, else NUL *\/\n@@ -87,16 +89,16 @@\n-        CIGNORE,          \/* ignore control flags *\/\n-        CS5,              \/* 5 bits    (pseudo) *\/\n-        CS6,              \/* 6 bits *\/\n-        CS7,              \/* 7 bits *\/\n-        CS8,              \/* 8 bits *\/\n-        CSTOPB,           \/* send 2 stop bits *\/\n-        CREAD,            \/* enable receiver *\/\n-        PARENB,           \/* parity enable *\/\n-        PARODD,           \/* odd parity, else even *\/\n-        HUPCL,            \/* hang up on last close *\/\n-        CLOCAL,           \/* ignore modem status lines *\/\n-        CCTS_OFLOW,       \/* CTS flow control of output *\/\n-        CRTS_IFLOW,       \/* RTS flow control of input *\/\n-        CDTR_IFLOW,       \/* DTR flow control of input *\/\n-        CDSR_OFLOW,       \/* DSR flow control of output *\/\n-        CCAR_OFLOW        \/* DCD flow control of output *\/\n+        CIGNORE, \/* ignore control flags *\/\n+        CS5, \/* 5 bits    (pseudo) *\/\n+        CS6, \/* 6 bits *\/\n+        CS7, \/* 7 bits *\/\n+        CS8, \/* 8 bits *\/\n+        CSTOPB, \/* send 2 stop bits *\/\n+        CREAD, \/* enable receiver *\/\n+        PARENB, \/* parity enable *\/\n+        PARODD, \/* odd parity, else even *\/\n+        HUPCL, \/* hang up on last close *\/\n+        CLOCAL, \/* ignore modem status lines *\/\n+        CCTS_OFLOW, \/* CTS flow control of output *\/\n+        CRTS_IFLOW, \/* RTS flow control of input *\/\n+        CDTR_IFLOW, \/* DTR flow control of input *\/\n+        CDSR_OFLOW, \/* DSR flow control of output *\/\n+        CCAR_OFLOW \/* DCD flow control of output *\/\n@@ -113,17 +115,17 @@\n-        ECHOKE,           \/* visual erase for line kill *\/\n-        ECHOE,            \/* visually erase chars *\/\n-        ECHOK,            \/* echo NL after line kill *\/\n-        ECHO,             \/* enable echoing *\/\n-        ECHONL,           \/* echo NL even if ECHO is off *\/\n-        ECHOPRT,          \/* visual erase mode for hardcopy *\/\n-        ECHOCTL,          \/* echo control chars as ^(Char) *\/\n-        ISIG,             \/* enable signals INTR, QUIT, [D]SUSP *\/\n-        ICANON,           \/* canonicalize input lines *\/\n-        ALTWERASE,        \/* use alternate WERASE algorithm *\/\n-        IEXTEN,           \/* enable DISCARD and LNEXT *\/\n-        EXTPROC,          \/* external processing *\/\n-        TOSTOP,           \/* stop background jobs from output *\/\n-        FLUSHO,           \/* output being flushed (state) *\/\n-        NOKERNINFO,       \/* no kernel output from VSTATUS *\/\n-        PENDIN,           \/* XXX retype pending input (state) *\/\n-        NOFLSH            \/* don't flush after interrupt *\/\n+        ECHOKE, \/* visual erase for line kill *\/\n+        ECHOE, \/* visually erase chars *\/\n+        ECHOK, \/* echo NL after line kill *\/\n+        ECHO, \/* enable echoing *\/\n+        ECHONL, \/* echo NL even if ECHO is off *\/\n+        ECHOPRT, \/* visual erase mode for hardcopy *\/\n+        ECHOCTL, \/* echo control chars as ^(Char) *\/\n+        ISIG, \/* enable signals INTR, QUIT, [D]SUSP *\/\n+        ICANON, \/* canonicalize input lines *\/\n+        ALTWERASE, \/* use alternate WERASE algorithm *\/\n+        IEXTEN, \/* enable DISCARD and LNEXT *\/\n+        EXTPROC, \/* external processing *\/\n+        TOSTOP, \/* stop background jobs from output *\/\n+        FLUSHO, \/* output being flushed (state) *\/\n+        NOKERNINFO, \/* no kernel output from VSTATUS *\/\n+        PENDIN, \/* XXX retype pending input (state) *\/\n+        NOFLSH \/* don't flush after interrupt *\/\n@@ -138,2 +140,1 @@\n-    public Attributes() {\n-    }\n+    public Attributes() {}\n@@ -141,0 +142,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -313,7 +315,6 @@\n-        return \"Attributes[\" +\n-                \"lflags: \" + append(lflag) + \", \" +\n-                \"iflags: \" + append(iflag) + \", \" +\n-                \"oflags: \" + append(oflag) + \", \" +\n-                \"cflags: \" + append(cflag) + \", \" +\n-                \"cchars: \" + append(EnumSet.allOf(ControlChar.class), this::display) +\n-                \"]\";\n+        return \"Attributes[\" + \"lflags: \"\n+                + append(lflag) + \", \" + \"iflags: \"\n+                + append(iflag) + \", \" + \"oflags: \"\n+                + append(oflag) + \", \" + \"cflags: \"\n+                + append(cflag) + \", \" + \"cchars: \"\n+                + append(EnumSet.allOf(ControlChar.class), this::display) + \"]\";\n@@ -348,1 +349,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Attributes.java","additions":73,"deletions":73,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Cursor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -74,7 +74,6 @@\n-        return \"MouseEvent[\" +\n-                \"type=\" + type +\n-                \", button=\" + button +\n-                \", modifiers=\" + modifiers +\n-                \", x=\" + x +\n-                \", y=\" + y +\n-                ']';\n+        return \"MouseEvent[\" + \"type=\"\n+                + type + \", button=\"\n+                + button + \", modifiers=\"\n+                + modifiers + \", x=\"\n+                + x + \", y=\"\n+                + y + ']';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/MouseEvent.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -16,2 +16,1 @@\n-    public Size() {\n-    }\n+    public Size() {}\n@@ -19,0 +18,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -53,1 +53,1 @@\n-        return row * (cols+1) + col;\n+        return row * (cols + 1) + col;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Size.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -37,0 +37,1 @@\n+\n@@ -45,0 +46,3 @@\n+    \/**\n+     * Types of signals.\n+     *\/\n@@ -54,0 +58,5 @@\n+    \/**\n+     * The SignalHandler defines the interface used to trap signals and perform specific behaviors.\n+     * @see Terminal.Signal\n+     * @see Terminal#handle(Signal, SignalHandler)\n+     *\/\n@@ -56,0 +65,4 @@\n+        \/**\n+         * The {@code SIG_DFL} value can be used to specify that the JVM default behavior\n+         * should be used to handle this signal.\n+         *\/\n@@ -57,0 +70,5 @@\n+\n+        \/**\n+         * The {@code SIG_IGN} value can be used to ignore this signal and not perform\n+         * any special processing.\n+         *\/\n@@ -59,0 +77,4 @@\n+        \/**\n+         * Handle the signal.\n+         * @param signal the signal\n+         *\/\n@@ -62,0 +84,10 @@\n+    \/**\n+     * Registers a handler for the given {@link Signal}.\n+     * <p>\n+     * Note that the JVM does not easily allow catching the {@link Signal#QUIT} signal, which causes a thread dump\n+     * to be displayed.  This signal is mainly used when connecting through an SSH socket to a virtual terminal.\n+     *\n+     * @param signal the signal to register a handler for\n+     * @param handler the handler\n+     * @return the previous signal handler\n+     *\/\n@@ -64,0 +96,11 @@\n+    \/**\n+     * Raise the specific signal.\n+     * This is not method usually called by non system terminals.\n+     * When accessing a terminal through a SSH or Telnet connection, signals may be\n+     * conveyed by the protocol and thus need to be raised when reaching the terminal code.\n+     * The terminals do that automatically when the terminal input stream has a character\n+     * mapped to {@link Attributes.ControlChar#VINTR}, {@link Attributes.ControlChar#VQUIT},\n+     * or {@link Attributes.ControlChar#VSUSP}.\n+     *\n+     * @param signal the signal to raise\n+     *\/\n@@ -183,0 +226,7 @@\n+    \/**\n+     * Returns the terminal attributes.\n+     * The returned object can be safely modified\n+     * further used in a call to {@link #setAttributes(Attributes)}.\n+     *\n+     * @return the terminal attributes.\n+     *\/\n@@ -185,0 +235,6 @@\n+    \/**\n+     * Set the terminal attributes.\n+     * The terminal will perform a copy of the given attributes.\n+     *\n+     * @param attr the new attributes\n+     *\/\n@@ -337,1 +393,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Terminal.java","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -11,3 +11,0 @@\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -22,0 +19,4 @@\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n@@ -27,0 +28,1 @@\n+import java.util.Set;\n@@ -34,1 +36,0 @@\n-import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n@@ -36,0 +37,3 @@\n+import jdk.internal.org.jline.terminal.impl.DumbTerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalExt;\n@@ -52,4 +56,16 @@\n-    public static final String PROP_JNA = \"org.jline.terminal.jna\";\n-    public static final String PROP_JANSI = \"org.jline.terminal.jansi\";\n-    public static final String PROP_EXEC = \"org.jline.terminal.exec\";\n-    public static final String PROP_DUMB = \"org.jline.terminal.dumb\";\n+    public static final String PROP_PROVIDER = \"org.jline.terminal.provider\";\n+    public static final String PROP_PROVIDERS = \"org.jline.terminal.providers\";\n+    public static final String PROP_PROVIDER_FFM = \"ffm\";\n+    public static final String PROP_PROVIDER_JNI = \"jni\";\n+    public static final String PROP_PROVIDER_JANSI = \"jansi\";\n+    public static final String PROP_PROVIDER_JNA = \"jna\";\n+    public static final String PROP_PROVIDER_EXEC = \"exec\";\n+    public static final String PROP_PROVIDER_DUMB = \"dumb\";\n+    public static final String PROP_PROVIDERS_DEFAULT = String.join(\n+            \",\", PROP_PROVIDER_FFM, PROP_PROVIDER_JNI, PROP_PROVIDER_JANSI, PROP_PROVIDER_JNA, PROP_PROVIDER_EXEC);\n+    public static final String PROP_FFM = \"org.jline.terminal.\" + PROP_PROVIDER_FFM;\n+    public static final String PROP_JNI = \"org.jline.terminal.\" + PROP_PROVIDER_JNI;\n+    public static final String PROP_JANSI = \"org.jline.terminal.\" + PROP_PROVIDER_JANSI;\n+    public static final String PROP_JNA = \"org.jline.terminal.\" + PROP_PROVIDER_JNA;\n+    public static final String PROP_EXEC = \"org.jline.terminal.\" + PROP_PROVIDER_EXEC;\n+    public static final String PROP_DUMB = \"org.jline.terminal.\" + PROP_PROVIDER_DUMB;\n@@ -62,0 +78,2 @@\n+    public static final String PROP_OUTPUT_FORCED_OUT = \"forced-out\";\n+    public static final String PROP_OUTPUT_FORCED_ERR = \"forced-err\";\n@@ -71,0 +89,26 @@\n+    \/\/\n+    \/\/ System properties controlling how FileDescriptor are create.\n+    \/\/ The value can be a comma separated list of defined mechanisms.\n+    \/\/\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE = \"org.jline.terminal.pty.fileDescriptorCreationMode\";\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE = \"native\";\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION = \"reflection\";\n+    public static final String PROP_FILE_DESCRIPTOR_CREATION_MODE_DEFAULT =\n+            String.join(\",\", PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION, PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE);\n+\n+    \/\/\n+    \/\/ System properties controlling how RedirectPipe are created.\n+    \/\/ The value can be a comma separated list of defined mechanisms.\n+    \/\/\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE = \"org.jline.terminal.exec.redirectPipeCreationMode\";\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE = \"native\";\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION = \"reflection\";\n+    public static final String PROP_REDIRECT_PIPE_CREATION_MODE_DEFAULT =\n+            String.join(\",\", PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION, PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE);\n+\n+    public static final Set<String> DEPRECATED_PROVIDERS =\n+            Collections.unmodifiableSet(new HashSet<>(Arrays.asList(PROP_PROVIDER_JNA, PROP_PROVIDER_JANSI)));\n+\n+    public static final String PROP_DISABLE_DEPRECATED_PROVIDER_WARNING =\n+            \"org.jline.terminal.disableDeprecatedProviderWarning\";\n+\n@@ -78,1 +122,3 @@\n-        SysErrOrSysOut\n+        SysErrOrSysOut,\n+        ForcedSysOut,\n+        ForcedSysErr\n@@ -118,0 +164,2 @@\n+    private String provider;\n+    private String providers;\n@@ -120,0 +168,1 @@\n+    private Boolean jni;\n@@ -121,0 +170,1 @@\n+    private Boolean ffm;\n@@ -125,1 +175,1 @@\n-    private boolean nativeSignals = false;\n+    private boolean nativeSignals = true;\n@@ -130,2 +180,1 @@\n-    private TerminalBuilder() {\n-    }\n+    private TerminalBuilder() {}\n@@ -163,0 +212,10 @@\n+    public TerminalBuilder provider(String provider) {\n+        this.provider = provider;\n+        return this;\n+    }\n+\n+    public TerminalBuilder providers(String providers) {\n+        this.providers = providers;\n+        return this;\n+    }\n+\n@@ -173,0 +232,5 @@\n+    public TerminalBuilder jni(boolean jni) {\n+        this.jni = jni;\n+        return this;\n+    }\n+\n@@ -178,0 +242,5 @@\n+    public TerminalBuilder ffm(boolean ffm) {\n+        this.ffm = ffm;\n+        return this;\n+    }\n+\n@@ -283,0 +352,6 @@\n+    \/**\n+     * Determines the default value for signal handlers.\n+     * All signals will be mapped to the given handler.\n+     * @param signalHandler the default signal handler\n+     * @return The builder\n+     *\/\n@@ -308,0 +383,5 @@\n+    \/**\n+     * Builds the terminal.\n+     * @return the newly created terminal, never {@code null}\n+     * @throws IOException if an error occurs\n+     *\/\n@@ -316,1 +396,2 @@\n-            Log.debug(() -> \"Using pty \" + ((AbstractPosixTerminal) terminal).getPty().getClass().getSimpleName());\n+            Log.debug(() -> \"Using pty \"\n+                    + ((AbstractPosixTerminal) terminal).getPty().getClass().getSimpleName());\n@@ -326,39 +407,6 @@\n-        Charset encoding = this.encoding;\n-        if (encoding == null) {\n-            String charsetName = System.getProperty(PROP_ENCODING);\n-            if (charsetName != null && Charset.isSupported(charsetName)) {\n-                encoding = Charset.forName(charsetName);\n-            }\n-        }\n-        if (encoding == null) {\n-            int codepage = this.codepage;\n-            if (codepage <= 0) {\n-                String str = System.getProperty(PROP_CODEPAGE);\n-                if (str != null) {\n-                    codepage = Integer.parseInt(str);\n-                }\n-            }\n-            if (codepage >= 0) {\n-                encoding = getCodepageCharset(codepage);\n-            } else {\n-                encoding = StandardCharsets.UTF_8;\n-            }\n-        }\n-        String type = this.type;\n-        if (type == null) {\n-            type = System.getProperty(PROP_TYPE);\n-        }\n-        if (type == null) {\n-            type = System.getenv(\"TERM\");\n-        }\n-        Boolean jna = this.jna;\n-        if (jna == null) {\n-            jna = getBoolean(PROP_JNA, true);\n-        }\n-        Boolean jansi = this.jansi;\n-        if (jansi == null) {\n-            jansi = getBoolean(PROP_JANSI, true);\n-        }\n-        Boolean exec = this.exec;\n-        if (exec == null) {\n-            exec = getBoolean(PROP_EXEC, true);\n+        Charset encoding = computeEncoding();\n+        String type = computeType();\n+\n+        String provider = this.provider;\n+        if (provider == null) {\n+            provider = System.getProperty(PROP_PROVIDER, null);\n@@ -366,0 +414,4 @@\n+\n+        boolean forceDumb =\n+                (DumbTerminal.TYPE_DUMB.equals(type) || type != null && type.startsWith(DumbTerminal.TYPE_DUMB_COLOR))\n+                        || (provider != null && provider.equals(PROP_PROVIDER_DUMB));\n@@ -371,30 +423,1 @@\n-        List<TerminalProvider> providers = new ArrayList<>();\n-        if (jna) {\n-            try {\n-                TerminalProvider provider = TerminalProvider.load(\"jna\");\n-                providers.add(provider);\n-            }  catch (Throwable t) {\n-                Log.debug(\"Unable to load JNA support: \", t);\n-                exception.addSuppressed(t);\n-            }\n-        }\n-        if (jansi) {\n-            try {\n-                TerminalProvider provider = TerminalProvider.load(\"jansi\");\n-                providers.add(provider);\n-            }  catch (Throwable t) {\n-                Log.debug(\"Unable to load JANSI support: \", t);\n-                exception.addSuppressed(t);\n-            }\n-        }\n-        if (exec)\n-        {\n-            try {\n-                TerminalProvider provider = TerminalProvider.load(\"exec\");\n-                providers.add(provider);\n-            }  catch (Throwable t) {\n-                Log.debug(\"Unable to load EXEC support: \", t);\n-                exception.addSuppressed(t);\n-            }\n-        }\n-\n+        List<TerminalProvider> providers = getProviders(provider, exception);\n@@ -403,2 +426,3 @@\n-            if (system != null && ((in != null && !in.equals(System.in)) ||\n-                    (out != null && !out.equals(System.out) && !out.equals(System.err)))) {\n+            if (system != null\n+                    && ((in != null && !in.equals(System.in))\n+                            || (out != null && !out.equals(System.out) && !out.equals(System.err)))) {\n@@ -410,28 +434,5 @@\n-            if (out != null) {\n-                if (out.equals(System.out)) {\n-                    systemOutput = SystemOutput.SysOut;\n-                } else if (out.equals(System.err)) {\n-                    systemOutput = SystemOutput.SysErr;\n-                }\n-            }\n-            if (systemOutput == null) {\n-                String str = System.getProperty(PROP_OUTPUT);\n-                if (str != null) {\n-                    switch (str.trim().toLowerCase(Locale.ROOT)) {\n-                        case PROP_OUTPUT_OUT: systemOutput = SystemOutput.SysOut; break;\n-                        case PROP_OUTPUT_ERR: systemOutput = SystemOutput.SysErr; break;\n-                        case PROP_OUTPUT_OUT_ERR: systemOutput = SystemOutput.SysOutOrSysErr; break;\n-                        case PROP_OUTPUT_ERR_OUT: systemOutput = SystemOutput.SysErrOrSysOut; break;\n-                        default:\n-                            Log.debug(\"Unsupported value for \" + PROP_OUTPUT + \": \" + str + \". Supported values are: \"\n-                                    + String.join(\", \", PROP_OUTPUT_OUT, PROP_OUTPUT_ERR, PROP_OUTPUT_OUT_ERR,PROP_OUTPUT_ERR_OUT)\n-                                    + \".\");\n-                    }\n-                }\n-            }\n-            if (systemOutput == null) {\n-                systemOutput = SystemOutput.SysOutOrSysErr;\n-            }\n-            Map<TerminalProvider.Stream, Boolean> system = Stream.of(TerminalProvider.Stream.values())\n-                    .collect(Collectors.toMap(stream -> stream, stream -> providers.stream().anyMatch(p -> p.isSystemStream(stream))));\n-            TerminalProvider.Stream console = select(system, systemOutput);\n+            SystemOutput systemOutput = computeSystemOutput();\n+            Map<SystemStream, Boolean> system = Stream.of(SystemStream.values())\n+                    .collect(Collectors.toMap(\n+                            stream -> stream, stream -> providers.stream().anyMatch(p -> p.isSystemStream(stream))));\n+            SystemStream systemStream = select(system, systemOutput);\n@@ -439,1 +440,1 @@\n-            if (system.get(TerminalProvider.Stream.Input) && console != null) {\n+            if (!forceDumb && system.get(SystemStream.Input) && systemStream != null) {\n@@ -446,2 +447,4 @@\n-                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM)  && \"xterm\".equals(type)\n-                        && this.type == null && System.getProperty(PROP_TYPE) == null) {\n+                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM)\n+                        && \"xterm\".equals(type)\n+                        && this.type == null\n+                        && System.getProperty(PROP_TYPE) == null) {\n@@ -450,1 +453,1 @@\n-                for ( TerminalProvider provider : providers) {\n+                for (TerminalProvider prov : providers) {\n@@ -453,2 +456,10 @@\n-                            terminal = provider.sysTerminal(name, type, ansiPassThrough, encoding,\n-                                    nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n+                            terminal = prov.sysTerminal(\n+                                    name,\n+                                    type,\n+                                    ansiPassThrough,\n+                                    encoding,\n+                                    nativeSignals,\n+                                    signalHandler,\n+                                    paused,\n+                                    systemStream,\n+                                    inputStreamWrapper);\n@@ -456,1 +467,1 @@\n-                            Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n+                            Log.debug(\"Error creating \" + prov.name() + \" based terminal: \", t.getMessage(), t);\n@@ -461,3 +472,5 @@\n-                if (terminal == null && OSUtils.IS_WINDOWS &&  !jna && !jansi && (dumb == null || !dumb)) {\n-                    throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n-                            + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n+                if (terminal == null && OSUtils.IS_WINDOWS && providers.isEmpty() && (dumb == null || !dumb)) {\n+                    throw new IllegalStateException(\n+                            \"Unable to create a system terminal. On Windows, either JLine's native libraries, JNA \"\n+                                    + \"or Jansi library is required.  Make sure to add one of those in the classpath.\",\n+                            exception);\n@@ -471,3 +484,3 @@\n-                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n-                            \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n-                            \"or that previously created system Terminals have been correctly closed.\"));\n+                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \"\n+                            + \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \"\n+                            + \"or that previously created system Terminals have been correctly closed.\"));\n@@ -478,27 +491,10 @@\n-            if (terminal == null && (dumb == null || dumb)) {\n-                \/\/ forced colored dumb terminal\n-                Boolean color = this.color;\n-                if (color == null) {\n-                    color = getBoolean(PROP_DUMB_COLOR, false);\n-                    \/\/ detect emacs using the env variable\n-                    if (!color) {\n-                        String emacs = System.getenv(\"INSIDE_EMACS\");\n-                        color = emacs != null && emacs.contains(\"comint\");\n-                    }\n-                    \/\/ detect Intellij Idea\n-                    if (!color) {\n-                        String command = getParentProcessCommand();\n-                        color = command != null && command.contains(\"idea\");\n-                    }\n-                    if (!color) {\n-                        color = system.get(TerminalProvider.Stream.Output) && System.getenv(\"TERM\") != null;\n-                    }\n-                    if (!color && dumb == null) {\n-                        if (Log.isDebugEnabled()) {\n-                            Log.warn(\"input is tty: {}\", system.get(TerminalProvider.Stream.Input));\n-                            Log.warn(\"output is tty: {}\", system.get(TerminalProvider.Stream.Output));\n-                            Log.warn(\"error is tty: {}\", system.get(TerminalProvider.Stream.Error));\n-                            Log.warn(\"Creating a dumb terminal\", exception);\n-                        } else {\n-                            Log.warn(\"Unable to create a system terminal, creating a dumb terminal (enable debug logging for more information)\");\n-                        }\n+            if (terminal == null && (forceDumb || dumb == null || dumb)) {\n+                if (!forceDumb && dumb == null) {\n+                    if (Log.isDebugEnabled()) {\n+                        Log.warn(\"input is tty: \" + system.get(SystemStream.Input));\n+                        Log.warn(\"output is tty: \" + system.get(SystemStream.Output));\n+                        Log.warn(\"error is tty: \" + system.get(SystemStream.Error));\n+                        Log.warn(\"Creating a dumb terminal\", exception);\n+                    } else {\n+                        Log.warn(\n+                                \"Unable to create a system terminal, creating a dumb terminal (enable debug logging for more information)\");\n@@ -507,4 +503,8 @@\n-                terminal = new DumbTerminal(name, color ? Terminal.TYPE_DUMB_COLOR : Terminal.TYPE_DUMB,\n-                        new FileInputStream(FileDescriptor.in),\n-                        new FileOutputStream(console == TerminalProvider.Stream.Output ? FileDescriptor.out : FileDescriptor.err),\n-                        encoding, signalHandler);\n+                type = getDumbTerminalType(dumb, systemStream);\n+                terminal = new DumbTerminalProvider()\n+                        .sysTerminal(name, type, false, encoding, nativeSignals, signalHandler, paused, systemStream, inputStreamWrapper);\n+                if (OSUtils.IS_WINDOWS) {\n+                    Attributes attr = terminal.getAttributes();\n+                    attr.setInputFlag(Attributes.InputFlag.IGNCR, true);\n+                    terminal.setAttributes(attr);\n+                }\n@@ -513,1 +513,1 @@\n-            for ( TerminalProvider provider : providers) {\n+            for (TerminalProvider prov : providers) {\n@@ -516,1 +516,2 @@\n-                        terminal = provider.newTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n+                        terminal = prov.newTerminal(\n+                                name, type, in, out, encoding, signalHandler, paused, attributes, size);\n@@ -518,1 +519,1 @@\n-                        Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n+                        Log.debug(\"Error creating \" + prov.name() + \" based terminal: \", t.getMessage(), t);\n@@ -527,0 +528,9 @@\n+        if (terminal instanceof TerminalExt) {\n+            TerminalExt te = (TerminalExt) terminal;\n+            if (DEPRECATED_PROVIDERS.contains(te.getProvider().name())\n+                    && !getBoolean(PROP_DISABLE_DEPRECATED_PROVIDER_WARNING, false)) {\n+                Log.warn(\"The terminal provider \" + te.getProvider().name()\n+                        + \" has been deprecated, check your configuration. This warning can be disabled by setting the system property \"\n+                        + PROP_DISABLE_DEPRECATED_PROVIDER_WARNING + \" to true.\");\n+            }\n+        }\n@@ -530,1 +540,183 @@\n-    private TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, SystemOutput systemOutput) {\n+    private String getDumbTerminalType(Boolean dumb, SystemStream systemStream) {\n+        \/\/ forced colored dumb terminal\n+        Boolean color = this.color;\n+        if (color == null) {\n+            color = getBoolean(PROP_DUMB_COLOR, null);\n+        }\n+        if (dumb == null) {\n+            \/\/ detect emacs using the env variable\n+            if (color == null) {\n+                String emacs = System.getenv(\"INSIDE_EMACS\");\n+                if (emacs != null && emacs.contains(\"comint\")) {\n+                    color = true;\n+                }\n+            }\n+            \/\/ detect Intellij Idea\n+            if (color == null) {\n+                \/\/ using the env variable on windows\n+                String ideHome = System.getenv(\"IDE_HOME\");\n+                if (ideHome != null) {\n+                    color = true;\n+                } else {\n+                    \/\/ using the parent process command on unix\/mac\n+                    String command = getParentProcessCommand();\n+                    if (command != null && command.endsWith(\"\/idea\")) {\n+                        color = true;\n+                    }\n+                }\n+            }\n+            if (color == null) {\n+                color = systemStream != null && System.getenv(\"TERM\") != null;\n+            }\n+        } else {\n+            if (color == null) {\n+                color = false;\n+            }\n+        }\n+        return color ? Terminal.TYPE_DUMB_COLOR : Terminal.TYPE_DUMB;\n+    }\n+\n+    public SystemOutput computeSystemOutput() {\n+        SystemOutput systemOutput = null;\n+        if (out != null) {\n+            if (out.equals(System.out)) {\n+                systemOutput = SystemOutput.SysOut;\n+            } else if (out.equals(System.err)) {\n+                systemOutput = SystemOutput.SysErr;\n+            }\n+        }\n+        if (systemOutput == null) {\n+            systemOutput = this.systemOutput;\n+        }\n+        if (systemOutput == null) {\n+            String str = System.getProperty(PROP_OUTPUT);\n+            if (str != null) {\n+                switch (str.trim().toLowerCase(Locale.ROOT)) {\n+                    case PROP_OUTPUT_OUT:\n+                        systemOutput = SystemOutput.SysOut;\n+                        break;\n+                    case PROP_OUTPUT_ERR:\n+                        systemOutput = SystemOutput.SysErr;\n+                        break;\n+                    case PROP_OUTPUT_OUT_ERR:\n+                        systemOutput = SystemOutput.SysOutOrSysErr;\n+                        break;\n+                    case PROP_OUTPUT_ERR_OUT:\n+                        systemOutput = SystemOutput.SysErrOrSysOut;\n+                        break;\n+                    case PROP_OUTPUT_FORCED_OUT:\n+                        systemOutput = SystemOutput.ForcedSysOut;\n+                        break;\n+                    case PROP_OUTPUT_FORCED_ERR:\n+                        systemOutput = SystemOutput.ForcedSysErr;\n+                        break;\n+                    default:\n+                        Log.debug(\"Unsupported value for \" + PROP_OUTPUT + \": \" + str + \". Supported values are: \"\n+                                + String.join(\n+                                        \", \",\n+                                        PROP_OUTPUT_OUT,\n+                                        PROP_OUTPUT_ERR,\n+                                        PROP_OUTPUT_OUT_ERR,\n+                                        PROP_OUTPUT_ERR_OUT)\n+                                + \".\");\n+                }\n+            }\n+        }\n+        if (systemOutput == null) {\n+            systemOutput = SystemOutput.SysOutOrSysErr;\n+        }\n+        return systemOutput;\n+    }\n+\n+    public String computeType() {\n+        String type = this.type;\n+        if (type == null) {\n+            type = System.getProperty(PROP_TYPE);\n+        }\n+        if (type == null) {\n+            type = System.getenv(\"TERM\");\n+        }\n+        return type;\n+    }\n+\n+    public Charset computeEncoding() {\n+        Charset encoding = this.encoding;\n+        if (encoding == null) {\n+            String charsetName = System.getProperty(PROP_ENCODING);\n+            if (charsetName != null && Charset.isSupported(charsetName)) {\n+                encoding = Charset.forName(charsetName);\n+            }\n+        }\n+        if (encoding == null) {\n+            int codepage = this.codepage;\n+            if (codepage <= 0) {\n+                String str = System.getProperty(PROP_CODEPAGE);\n+                if (str != null) {\n+                    codepage = Integer.parseInt(str);\n+                }\n+            }\n+            if (codepage >= 0) {\n+                encoding = getCodepageCharset(codepage);\n+            } else {\n+                encoding = StandardCharsets.UTF_8;\n+            }\n+        }\n+        return encoding;\n+    }\n+\n+    \/**\n+     * Get the list of available terminal providers.\n+     * This list is sorted according to the {@link #PROP_PROVIDERS} system property.\n+     * @param provider if not {@code null}, only this provider will be checked\n+     * @param exception if a provider throws an exception, it will be added to this exception as a suppressed exception\n+     * @return a list of terminal providers\n+     *\/\n+    public List<TerminalProvider> getProviders(String provider, IllegalStateException exception) {\n+        List<TerminalProvider> providers = new ArrayList<>();\n+        \/\/ Check ffm provider\n+        checkProvider(provider, exception, providers, ffm, PROP_FFM, PROP_PROVIDER_FFM);\n+        \/\/ Check jni provider\n+        checkProvider(provider, exception, providers, jni, PROP_JNI, PROP_PROVIDER_JNI);\n+        \/\/ Check jansi provider\n+        checkProvider(provider, exception, providers, jansi, PROP_JANSI, PROP_PROVIDER_JANSI);\n+        \/\/ Check jna provider\n+        checkProvider(provider, exception, providers, jna, PROP_JNA, PROP_PROVIDER_JNA);\n+        \/\/ Check exec provider\n+        checkProvider(provider, exception, providers, exec, PROP_EXEC, PROP_PROVIDER_EXEC);\n+        \/\/ Order providers\n+        List<String> order = Arrays.asList(\n+                (this.providers != null ? this.providers : System.getProperty(PROP_PROVIDERS, PROP_PROVIDERS_DEFAULT))\n+                        .split(\",\"));\n+        providers.sort(Comparator.comparing(l -> {\n+            int idx = order.indexOf(l.name());\n+            return idx >= 0 ? idx : Integer.MAX_VALUE;\n+        }));\n+        String names = providers.stream().map(TerminalProvider::name).collect(Collectors.joining(\", \"));\n+        Log.debug(\"Available providers: \" + names);\n+        return providers;\n+    }\n+\n+    private void checkProvider(\n+            String provider,\n+            IllegalStateException exception,\n+            List<TerminalProvider> providers,\n+            Boolean load,\n+            String property,\n+            String name) {\n+        Boolean doLoad = provider != null ? (Boolean) name.equals(provider) : load;\n+        if (doLoad == null) {\n+            doLoad = getBoolean(property, true);\n+        }\n+        if (doLoad) {\n+            try {\n+                TerminalProvider prov = TerminalProvider.load(name);\n+                prov.isSystemStream(SystemStream.Output);\n+                providers.add(prov);\n+            } catch (Throwable t) {\n+                Log.debug(\"Unable to load \" + name + \" provider: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+    }\n+\n+    private SystemStream select(Map<SystemStream, Boolean> system, SystemOutput systemOutput) {\n@@ -533,1 +725,1 @@\n-                return select(system, TerminalProvider.Stream.Output);\n+                return select(system, SystemStream.Output);\n@@ -535,1 +727,1 @@\n-                return select(system, TerminalProvider.Stream.Error);\n+                return select(system, SystemStream.Error);\n@@ -537,1 +729,1 @@\n-                return select(system, TerminalProvider.Stream.Output, TerminalProvider.Stream.Error);\n+                return select(system, SystemStream.Output, SystemStream.Error);\n@@ -539,1 +731,5 @@\n-                return select(system, TerminalProvider.Stream.Error, TerminalProvider.Stream.Output);\n+                return select(system, SystemStream.Error, SystemStream.Output);\n+            case ForcedSysOut:\n+                return SystemStream.Output;\n+            case ForcedSysErr:\n+                return SystemStream.Error;\n@@ -544,2 +740,2 @@\n-    private static TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, TerminalProvider.Stream... streams) {\n-        for (TerminalProvider.Stream s : streams) {\n+    private static SystemStream select(Map<SystemStream, Boolean> system, SystemStream... streams) {\n+        for (SystemStream s : streams) {\n@@ -560,1 +756,3 @@\n-            Object command = ((Optional<?>) infoMethod.getReturnType().getMethod(\"command\").invoke(info)).orElse(null);\n+            Object command = ((Optional<?>)\n+                            infoMethod.getReturnType().getMethod(\"command\").invoke(info))\n+                    .orElse(null);\n@@ -585,1 +783,1 @@\n-        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n+        \/\/ http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n@@ -632,1 +830,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":367,"deletions":170,"binary":false,"changes":537,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -21,0 +21,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -31,1 +33,2 @@\n-    public AbstractPosixTerminal(String name, String type, Pty pty, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    public AbstractPosixTerminal(String name, String type, Pty pty, Charset encoding, SignalHandler signalHandler)\n+            throws IOException {\n@@ -85,0 +88,9 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return getPty().getProvider();\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return getPty().getSystemStream();\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPosixTerminal.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -11,4 +11,2 @@\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.NonBlockingInputStream;\n-\n+import java.io.FileDescriptor;\n+import java.io.FilterInputStream;\n@@ -19,0 +17,9 @@\n+import java.lang.reflect.Field;\n+\n+\/\/import jdk.internal.org.jline.nativ.JLineLibrary;\n+\/\/import jdk.internal.org.jline.nativ.JLineNativeLoader;\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.NonBlockingInputStream;\n@@ -20,0 +27,4 @@\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE_DEFAULT;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION;\n@@ -24,0 +35,2 @@\n+    protected final TerminalProvider provider;\n+    protected final SystemStream systemStream;\n@@ -25,0 +38,6 @@\n+    private boolean skipNextLf;\n+\n+    public AbstractPty(TerminalProvider provider, SystemStream systemStream) {\n+        this.provider = provider;\n+        this.systemStream = systemStream;\n+    }\n@@ -35,0 +54,22 @@\n+        InputStream nsi = new FilterInputStream(si) {\n+            @Override\n+            public int read() throws IOException {\n+                for (; ; ) {\n+                    int c = super.read();\n+                    if (current.getInputFlag(Attributes.InputFlag.INORMEOL)) {\n+                        if (c == '\\r') {\n+                            skipNextLf = true;\n+                            c = '\\n';\n+                        } else if (c == '\\n') {\n+                            if (skipNextLf) {\n+                                skipNextLf = false;\n+                                continue;\n+                            }\n+                        } else {\n+                            skipNextLf = false;\n+                        }\n+                    }\n+                    return c;\n+                }\n+            }\n+        };\n@@ -36,1 +77,1 @@\n-            return new PtyInputStream(si);\n+            return new PtyInputStream(nsi);\n@@ -38,1 +79,1 @@\n-            return si;\n+            return nsi;\n@@ -52,0 +93,10 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return systemStream;\n+    }\n+\n@@ -105,0 +156,99 @@\n+    private static FileDescriptorCreator fileDescriptorCreator;\n+\n+    protected static FileDescriptor newDescriptor(int fd) {\n+        if (fileDescriptorCreator == null) {\n+            String str =\n+                    System.getProperty(PROP_FILE_DESCRIPTOR_CREATION_MODE, PROP_FILE_DESCRIPTOR_CREATION_MODE_DEFAULT);\n+            String[] modes = str.split(\",\");\n+            IllegalStateException ise = new IllegalStateException(\"Unable to create FileDescriptor\");\n+            for (String mode : modes) {\n+                try {\n+                    switch (mode) {\n+                        case PROP_FILE_DESCRIPTOR_CREATION_MODE_NATIVE:\n+                            fileDescriptorCreator = null;\/\/new NativeFileDescriptorCreator();\n+                            break;\n+                        case PROP_FILE_DESCRIPTOR_CREATION_MODE_REFLECTION:\n+                            fileDescriptorCreator = new ReflectionFileDescriptorCreator();\n+                            break;\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ ignore\n+                    ise.addSuppressed(t);\n+                }\n+                if (fileDescriptorCreator != null) {\n+                    break;\n+                }\n+            }\n+            if (fileDescriptorCreator == null) {\n+                throw ise;\n+            }\n+        }\n+        return fileDescriptorCreator.newDescriptor(fd);\n+    }\n+\n+    interface FileDescriptorCreator {\n+        FileDescriptor newDescriptor(int fd);\n+    }\n+\n+    \/*\n+     * Class that could be used on OpenJDK 17.  However, it requires the following JVM option\n+     *   --add-exports java.base\/jdk.internal.access=ALL-UNNAMED\n+     * so the benefit does not seem important enough to warrant the problems caused\n+     * by access the jdk.internal.access package at compile time, which itself requires\n+     * custom compiler options and a different maven module, or at least a different compile\n+     * phase with a JDK 17 compiler.\n+     * So, just keep the ReflectionFileDescriptorCreator for now.\n+     *\n+    static class Jdk17FileDescriptorCreator implements FileDescriptorCreator {\n+        private final jdk.internal.access.JavaIOFileDescriptorAccess fdAccess;\n+        Jdk17FileDescriptorCreator() {\n+            fdAccess = jdk.internal.access.SharedSecrets.getJavaIOFileDescriptorAccess();\n+        }\n+\n+        @Override\n+        public FileDescriptor newDescriptor(int fd) {\n+            FileDescriptor descriptor = new FileDescriptor();\n+            fdAccess.set(descriptor, fd);\n+            return descriptor;\n+        }\n+    }\n+     *\/\n+\n+    \/**\n+     * Reflection based file descriptor creator.\n+     * This requires the following option\n+     *   --add-opens java.base\/java.io=ALL-UNNAMED\n+     *\/\n+    static class ReflectionFileDescriptorCreator implements FileDescriptorCreator {\n+        private final Field fileDescriptorField;\n+\n+        ReflectionFileDescriptorCreator() throws Exception {\n+            Field field = FileDescriptor.class.getDeclaredField(\"fd\");\n+            field.setAccessible(true);\n+            fileDescriptorField = field;\n+        }\n+\n+        @Override\n+        public FileDescriptor newDescriptor(int fd) {\n+            FileDescriptor descriptor = new FileDescriptor();\n+            try {\n+                fileDescriptorField.set(descriptor, fd);\n+            } catch (IllegalAccessException e) {\n+                \/\/ This should not happen as the field has been set accessible\n+                throw new IllegalStateException(e);\n+            }\n+            return descriptor;\n+        }\n+    }\n+\n+\/\/    static class NativeFileDescriptorCreator implements FileDescriptorCreator {\n+\/\/        NativeFileDescriptorCreator() {\n+\/\/            \/\/ Force load the library\n+\/\/            JLineNativeLoader.initialize();\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public FileDescriptor newDescriptor(int fd) {\n+\/\/            return JLineLibrary.newFileDescriptor(fd);\n+\/\/        }\n+\/\/    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPty.java","additions":157,"deletions":7,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -30,1 +30,1 @@\n-import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalExt;\n@@ -38,1 +38,1 @@\n-public abstract class AbstractTerminal implements Terminal {\n+public abstract class AbstractTerminal implements TerminalExt {\n@@ -47,1 +47,1 @@\n-    protected final ColorPalette palette = new ColorPalette(this);\n+    protected final ColorPalette palette;\n@@ -55,1 +55,3 @@\n-    public AbstractTerminal(String name, String type, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public AbstractTerminal(String name, String type, Charset encoding, SignalHandler signalHandler)\n+            throws IOException {\n@@ -59,0 +61,1 @@\n+        this.palette = new ColorPalette(this);\n@@ -88,1 +91,5 @@\n-        if (handler != SignalHandler.SIG_DFL && handler != SignalHandler.SIG_IGN) {\n+        if (handler == SignalHandler.SIG_DFL) {\n+            if (status != null && signal == Signal.WINCH) {\n+                status.resize();\n+            }\n+        } else if (handler != SignalHandler.SIG_IGN) {\n@@ -91,3 +98,0 @@\n-        if (status != null && signal == Signal.WINCH) {\n-            status.resize();\n-        }\n@@ -108,2 +112,1 @@\n-            status.update(null);\n-            flush();\n+            status.close();\n@@ -129,1 +132,1 @@\n-                writer().write(new char[]{'^', (char) (vcc + '@')}, 0, 2);\n+                writer().write(new char[] {'^', (char) (vcc + '@')}, 0, 2);\n@@ -220,2 +223,1 @@\n-                MouseEvent.Type.Moved, MouseEvent.Button.NoButton,\n-                EnumSet.noneOf(MouseEvent.Modifier.class), 0, 0);\n+            MouseEvent.Type.Moved, MouseEvent.Button.NoButton, EnumSet.noneOf(MouseEvent.Modifier.class), 0, 0);\n@@ -271,2 +273,1 @@\n-    public void pause() {\n-    }\n+    public void pause() {}\n@@ -275,2 +276,1 @@\n-    public void pause(boolean wait) throws InterruptedException {\n-    }\n+    public void pause(boolean wait) throws InterruptedException {}\n@@ -279,2 +279,1 @@\n-    public void resume() {\n-    }\n+    public void resume() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractTerminal.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -32,2 +32,1 @@\n-    public void flush() {\n-    }\n+    public void flush() {}\n@@ -36,3 +35,1 @@\n-    public void close() {\n-    }\n-\n+    public void close() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsConsoleWriter.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2023, the original author(s).\n@@ -11,0 +11,10 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n@@ -13,0 +23,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -24,11 +36,0 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Function;\n-\n@@ -47,1 +48,1 @@\n-public abstract class AbstractWindowsTerminal extends AbstractTerminal {\n+public abstract class AbstractWindowsTerminal<Console> extends AbstractTerminal {\n@@ -59,5 +60,5 @@\n-    protected static final int ENABLE_LINE_INPUT      = 0x0002;\n-    protected static final int ENABLE_ECHO_INPUT      = 0x0004;\n-    protected static final int ENABLE_WINDOW_INPUT    = 0x0008;\n-    protected static final int ENABLE_MOUSE_INPUT     = 0x0010;\n-    protected static final int ENABLE_INSERT_MODE     = 0x0020;\n+    protected static final int ENABLE_LINE_INPUT = 0x0002;\n+    protected static final int ENABLE_ECHO_INPUT = 0x0004;\n+    protected static final int ENABLE_WINDOW_INPUT = 0x0008;\n+    protected static final int ENABLE_MOUSE_INPUT = 0x0010;\n+    protected static final int ENABLE_INSERT_MODE = 0x0020;\n@@ -65,0 +66,1 @@\n+    protected static final int ENABLE_EXTENDED_FLAGS = 0x0080;\n@@ -74,1 +76,6 @@\n-    protected final int originalConsoleMode;\n+    protected final Console inConsole;\n+    protected final Console outConsole;\n+    protected final int originalInConsoleMode;\n+    protected final int originalOutConsoleMode;\n+    private final TerminalProvider provider;\n+    private final SystemStream systemStream;\n@@ -83,2 +90,18 @@\n-\n-    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    protected boolean skipNextLf;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public AbstractWindowsTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            Writer writer,\n+            String name,\n+            String type,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            SignalHandler signalHandler,\n+            Console inConsole,\n+            int inConsoleMode,\n+            Console outConsole,\n+            int outConsoleMode,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -86,0 +109,2 @@\n+        this.provider = provider;\n+        this.systemStream = systemStream;\n@@ -92,0 +117,2 @@\n+        this.inConsole = inConsole;\n+        this.outConsole = outConsole;\n@@ -94,1 +121,2 @@\n-        originalConsoleMode = getConsoleMode();\n+        this.originalInConsoleMode = inConsoleMode;\n+        this.originalOutConsoleMode = outConsoleMode;\n@@ -97,1 +125,1 @@\n-        attributes.setControlChar(Attributes.ControlChar.VEOF,  ctrl('D'));\n+        attributes.setControlChar(Attributes.ControlChar.VEOF, ctrl('D'));\n@@ -151,1 +179,1 @@\n-        int mode = getConsoleMode();\n+        int mode = getConsoleMode(inConsole);\n@@ -176,0 +204,3 @@\n+            \/\/ mouse events not send with quick edit mode\n+            \/\/ to disable ENABLE_QUICK_EDIT_MODE just set extended flag\n+            mode |= ENABLE_EXTENDED_FLAGS;\n@@ -177,1 +208,1 @@\n-        setConsoleMode(mode);\n+        setConsoleMode(inConsole, mode);\n@@ -200,1 +231,2 @@\n-        setConsoleMode(originalConsoleMode);\n+        setConsoleMode(inConsole, originalInConsoleMode);\n+        setConsoleMode(outConsole, originalOutConsoleMode);\n@@ -204,13 +236,15 @@\n-    static final int ALT_FLAG =   0x02;\n-    static final int CTRL_FLAG =  0x04;\n-\n-    static final int RIGHT_ALT_PRESSED =   0x0001;\n-    static final int LEFT_ALT_PRESSED =    0x0002;\n-    static final int RIGHT_CTRL_PRESSED =  0x0004;\n-    static final int LEFT_CTRL_PRESSED =   0x0008;\n-    static final int SHIFT_PRESSED =       0x0010;\n-    static final int NUMLOCK_ON =          0x0020;\n-    static final int SCROLLLOCK_ON =       0x0040;\n-    static final int CAPSLOCK_ON =         0x0080;\n-\n-    protected void processKeyEvent(final boolean isKeyDown, final short virtualKeyCode, char ch, final int controlKeyState) throws IOException {\n+    static final int ALT_FLAG = 0x02;\n+    static final int CTRL_FLAG = 0x04;\n+\n+    static final int RIGHT_ALT_PRESSED = 0x0001;\n+    static final int LEFT_ALT_PRESSED = 0x0002;\n+    static final int RIGHT_CTRL_PRESSED = 0x0004;\n+    static final int LEFT_CTRL_PRESSED = 0x0008;\n+    static final int SHIFT_PRESSED = 0x0010;\n+    static final int NUMLOCK_ON = 0x0020;\n+    static final int SCROLLLOCK_ON = 0x0040;\n+    static final int CAPSLOCK_ON = 0x0080;\n+\n+    protected void processKeyEvent(\n+            final boolean isKeyDown, final short virtualKeyCode, char ch, final int controlKeyState)\n+            throws IOException {\n@@ -225,2 +259,3 @@\n-                    && (controlKeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED | RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED | SHIFT_PRESSED))\n-                        == (RIGHT_ALT_PRESSED | LEFT_CTRL_PRESSED)) {\n+                    && (controlKeyState\n+                                    & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED | RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))\n+                            == (RIGHT_ALT_PRESSED | LEFT_CTRL_PRESSED)) {\n@@ -229,1 +264,2 @@\n-                final String keySeq = getEscapeSequence(virtualKeyCode, (isCtrl ? CTRL_FLAG : 0) + (isAlt ? ALT_FLAG : 0) + (isShift ? SHIFT_FLAG : 0));\n+                final String keySeq = getEscapeSequence(\n+                        virtualKeyCode, (isCtrl ? CTRL_FLAG : 0) + (isAlt ? ALT_FLAG : 0) + (isShift ? SHIFT_FLAG : 0));\n@@ -243,1 +279,1 @@\n-                *\/\n+                 *\/\n@@ -257,1 +293,1 @@\n-                } else if (isCtrl) { \/\/Handles the ctrl key events(uchar=0)\n+                } else if (isCtrl) { \/\/ Handles the ctrl key events(uchar=0)\n@@ -260,1 +296,1 @@\n-                    } else if (virtualKeyCode == 191) { \/\/?\n+                    } else if (virtualKeyCode == 191) { \/\/ ?\n@@ -278,1 +314,1 @@\n-                processInputChar(ch);  \/\/ no such combination in Windows\n+                processInputChar(ch); \/\/ no such combination in Windows\n@@ -471,1 +507,13 @@\n-        if (c == '\\r') {\n+        if (attributes.getInputFlag(Attributes.InputFlag.INORMEOL)) {\n+            if (c == '\\r') {\n+                skipNextLf = true;\n+                c = '\\n';\n+            } else if (c == '\\n') {\n+                if (skipNextLf) {\n+                    skipNextLf = false;\n+                    return;\n+                }\n+            } else {\n+                skipNextLf = false;\n+            }\n+        } else if (c == '\\r') {\n@@ -481,4 +529,4 @@\n-\/\/        if (attributes.getLocalFlag(Attributes.LocalFlag.ECHO)) {\n-\/\/            processOutputByte(c);\n-\/\/            masterOutput.flush();\n-\/\/        }\n+        \/\/        if (attributes.getLocalFlag(Attributes.LocalFlag.ECHO)) {\n+        \/\/            processOutputByte(c);\n+        \/\/            masterOutput.flush();\n+        \/\/        }\n@@ -495,1 +543,1 @@\n-    protected abstract int getConsoleMode();\n+    protected abstract int getConsoleMode(Console console);\n@@ -497,1 +545,1 @@\n-    protected abstract void setConsoleMode(int mode);\n+    protected abstract void setConsoleMode(Console console, int mode);\n@@ -507,1 +555,4 @@\n-}\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n@@ -509,0 +560,5 @@\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return systemStream;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsTerminal.java","additions":110,"deletions":54,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -11,5 +11,0 @@\n-import jdk.internal.org.jline.terminal.Cursor;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.utils.Curses;\n-import jdk.internal.org.jline.utils.InfoCmp;\n-\n@@ -22,0 +17,5 @@\n+import jdk.internal.org.jline.terminal.Cursor;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.utils.Curses;\n+import jdk.internal.org.jline.utils.InfoCmp;\n+\n@@ -108,1 +108,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/CursorSupport.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, the original author or authors.\n+ * Copyright (c) 2022, the original author(s).\n@@ -20,0 +20,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -29,1 +30,1 @@\n-    static void diag(PrintStream out) {\n+    public static void diag(PrintStream out) {\n@@ -53,0 +54,11 @@\n+        \/\/ FFM\n+        out.println(\"FFM Support\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"ffm\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"FFM support not available: \" + t);\n+        }\n+        out.println();\n+\n@@ -63,1 +75,1 @@\n-        out.println(\"JansiSupport\");\n+        out.println(\"Jansi2Support\");\n@@ -69,1 +81,11 @@\n-            out.println(\"Jansi support not available: \" + t);\n+            out.println(\"Jansi 2 support not available: \" + t);\n+        }\n+        out.println();\n+\n+        out.println(\"JniSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jni\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"JNI support not available: \" + t);\n@@ -86,3 +108,3 @@\n-            out.println(\"StdIn stream =    \" + provider.isSystemStream(TerminalProvider.Stream.Input));\n-            out.println(\"StdOut stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Output));\n-            out.println(\"StdErr stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Error));\n+            out.println(\"StdIn stream =    \" + provider.isSystemStream(SystemStream.Input));\n+            out.println(\"StdOut stream =   \" + provider.isSystemStream(SystemStream.Output));\n+            out.println(\"StdErr stream =   \" + provider.isSystemStream(SystemStream.Error));\n@@ -93,3 +115,3 @@\n-            out.println(\"StdIn stream name =     \" + provider.systemStreamName(TerminalProvider.Stream.Input));\n-            out.println(\"StdOut stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Output));\n-            out.println(\"StdErr stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Error));\n+            out.println(\"StdIn stream name =     \" + provider.systemStreamName(SystemStream.Input));\n+            out.println(\"StdOut stream name =    \" + provider.systemStreamName(SystemStream.Output));\n+            out.println(\"StdErr stream name =    \" + provider.systemStreamName(SystemStream.Error));\n@@ -99,2 +121,10 @@\n-        try (Terminal terminal = provider.sysTerminal(\"diag\", \"xterm\", false, StandardCharsets.UTF_8,\n-                false, Terminal.SignalHandler.SIG_DFL, false, TerminalProvider.Stream.Output, input -> input) ) {\n+        try (Terminal terminal = provider.sysTerminal(\n+                \"diag\",\n+                \"xterm\",\n+                false,\n+                StandardCharsets.UTF_8,\n+                false,\n+                Terminal.SignalHandler.SIG_DFL,\n+                false,\n+                SystemStream.Output,\n+                input -> input)) {\n@@ -105,1 +135,2 @@\n-                    ForkJoinTask<Integer> t = new ForkJoinPool(1).submit(() -> terminal.reader().read(1) );\n+                    ForkJoinTask<Integer> t =\n+                            new ForkJoinPool(1).submit(() -> terminal.reader().read(1));\n@@ -111,1 +142,5 @@\n-                        sb.append(\" with pty \").append(((AbstractPosixTerminal) terminal).getPty().getClass().getName());\n+                        sb.append(\" with pty \")\n+                                .append(((AbstractPosixTerminal) terminal)\n+                                        .getPty()\n+                                        .getClass()\n+                                        .getName());\n@@ -132,1 +167,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/Diag.java","additions":49,"deletions":15,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -17,0 +17,1 @@\n+import java.util.function.Function;\n@@ -21,0 +22,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -27,0 +30,2 @@\n+    private final TerminalProvider provider;\n+    private final SystemStream systemStream;\n@@ -33,0 +38,1 @@\n+    private boolean skipNextLf;\n@@ -34,2 +40,2 @@\n-    public DumbTerminal(InputStream in, OutputStream out) throws IOException {\n-        this(TYPE_DUMB, TYPE_DUMB, in, out, null);\n+    public DumbTerminal(InputStream in, OutputStream out, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        this(TYPE_DUMB, TYPE_DUMB, in, out, null, inputStreamWrapper);\n@@ -38,2 +44,3 @@\n-    public DumbTerminal(String name, String type, InputStream in, OutputStream out, Charset encoding) throws IOException {\n-        this(name, type, in, out, encoding, SignalHandler.SIG_DFL);\n+    public DumbTerminal(String name, String type, InputStream in, OutputStream out, Charset encoding, Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        this(null, null, name, type, in, out, encoding, SignalHandler.SIG_DFL, inputStreamWrapper);\n@@ -42,1 +49,12 @@\n-    public DumbTerminal(String name, String type, InputStream in, OutputStream out, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public DumbTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            String name,\n+            String type,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -44,1 +62,3 @@\n-        NonBlockingInputStream nbis = NonBlocking.nonBlocking(getName(), in);\n+        this.provider = provider;\n+        this.systemStream = systemStream;\n+        NonBlockingInputStream nbis = NonBlocking.nonBlocking(getName(), inputStreamWrapper.apply(in));\n@@ -48,1 +68,1 @@\n-                for (;;) {\n+                for (; ; ) {\n@@ -65,1 +85,13 @@\n-                    if (c == '\\r') {\n+                    if (attributes.getInputFlag(Attributes.InputFlag.INORMEOL)) {\n+                        if (c == '\\r') {\n+                            skipNextLf = true;\n+                            c = '\\n';\n+                        } else if (c == '\\n') {\n+                            if (skipNextLf) {\n+                                skipNextLf = false;\n+                                continue;\n+                            }\n+                        } else {\n+                            skipNextLf = false;\n+                        }\n+                    } else if (c == '\\r') {\n@@ -83,1 +115,1 @@\n-        this.attributes.setControlChar(ControlChar.VERASE,  (char) 127);\n+        this.attributes.setControlChar(ControlChar.VERASE, (char) 127);\n@@ -85,2 +117,2 @@\n-        this.attributes.setControlChar(ControlChar.VKILL,   (char) 21);\n-        this.attributes.setControlChar(ControlChar.VLNEXT,  (char) 22);\n+        this.attributes.setControlChar(ControlChar.VKILL, (char) 21);\n+        this.attributes.setControlChar(ControlChar.VLNEXT, (char) 22);\n@@ -110,3 +142,1 @@\n-        Attributes attr = new Attributes();\n-        attr.copy(attributes);\n-        return attr;\n+        return new Attributes(attributes);\n@@ -129,0 +159,9 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return systemStream;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/DumbTerminal.java","additions":54,"deletions":15,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+public class DumbTerminalProvider implements TerminalProvider {\n+\n+    @Override\n+    public String name() {\n+        return TerminalBuilder.PROP_PROVIDER_DUMB;\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        return new DumbTerminal(\n+                this,\n+                systemStream,\n+                name,\n+                type,\n+                new FileInputStream(FileDescriptor.in),\n+                new FileOutputStream(systemStream == SystemStream.Error ? FileDescriptor.err : FileDescriptor.out),\n+                encoding,\n+                signalHandler,\n+                inputStreamWrapper);\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(SystemStream stream) {\n+        return false;\n+    }\n+\n+    @Override\n+    public String systemStreamName(SystemStream stream) {\n+        return null;\n+    }\n+\n+    @Override\n+    public int systemStreamWidth(SystemStream stream) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TerminalProvider[\" + name() + \"]\";\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/DumbTerminalProvider.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -1,296 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2016, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl;\n-\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.FileDescriptor;\n-import java.io.OutputStream;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n-import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n-import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n-import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n-import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import static jdk.internal.org.jline.utils.ExecHelper.exec;\n-\n-public class ExecPty extends AbstractPty implements Pty {\n-\n-    private final String name;\n-    private final TerminalProvider.Stream console;\n-\n-    public static Pty current(TerminalProvider.Stream console) throws IOException {\n-        try {\n-            String result = exec(true, OSUtils.TTY_COMMAND);\n-            if (console != TerminalProvider.Stream.Output && console != TerminalProvider.Stream.Error) {\n-                throw new IllegalArgumentException(\"console should be Output or Error: \" + console);\n-            }\n-            return new ExecPty(result.trim(), console);\n-        } catch (IOException e) {\n-            throw new IOException(\"Not a tty\", e);\n-        }\n-    }\n-\n-    protected ExecPty(String name, TerminalProvider.Stream console) {\n-        this.name = name;\n-        this.console = console;\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    @Override\n-    public InputStream getMasterInput() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public OutputStream getMasterOutput() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected InputStream doGetSlaveInput() throws IOException {\n-        return console != null\n-                ? new FileInputStream(FileDescriptor.in)\n-                : new FileInputStream(getName());\n-    }\n-\n-    @Override\n-    public OutputStream getSlaveOutput() throws IOException {\n-        return console == TerminalProvider.Stream.Output\n-                ? new FileOutputStream(FileDescriptor.out)\n-                : console == TerminalProvider.Stream.Error\n-                    ? new FileOutputStream(FileDescriptor.err)\n-                    : new FileOutputStream(getName());\n-    }\n-\n-    @Override\n-    public Attributes getAttr() throws IOException {\n-        String cfg = doGetConfig();\n-        return doGetAttr(cfg);\n-    }\n-\n-    @Override\n-    protected void doSetAttr(Attributes attr) throws IOException {\n-        List<String> commands = getFlagsToSet(attr, getAttr());\n-        if (!commands.isEmpty()) {\n-            commands.add(0, OSUtils.STTY_COMMAND);\n-            if (console == null) {\n-                commands.add(1, OSUtils.STTY_F_OPTION);\n-                commands.add(2, getName());\n-            }\n-            exec(console != null, commands.toArray(new String[0]));\n-        }\n-    }\n-\n-    protected List<String> getFlagsToSet(Attributes attr, Attributes current) {\n-        List<String> commands = new ArrayList<>();\n-        for (InputFlag flag : InputFlag.values()) {\n-            if (attr.getInputFlag(flag) != current.getInputFlag(flag)) {\n-                commands.add((attr.getInputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        for (OutputFlag flag : OutputFlag.values()) {\n-            if (attr.getOutputFlag(flag) != current.getOutputFlag(flag)) {\n-                commands.add((attr.getOutputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        for (ControlFlag flag : ControlFlag.values()) {\n-            if (attr.getControlFlag(flag) != current.getControlFlag(flag)) {\n-                commands.add((attr.getControlFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        for (LocalFlag flag : LocalFlag.values()) {\n-            if (attr.getLocalFlag(flag) != current.getLocalFlag(flag)) {\n-                commands.add((attr.getLocalFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n-            }\n-        }\n-        String undef = System.getProperty(\"os.name\").toLowerCase().startsWith(\"hp\") ? \"^-\" : \"undef\";\n-        for (ControlChar cchar : ControlChar.values()) {\n-            int v = attr.getControlChar(cchar);\n-            if (v >= 0 && v != current.getControlChar(cchar)) {\n-                String str = \"\";\n-                commands.add(cchar.name().toLowerCase().substring(1));\n-                if (cchar == ControlChar.VMIN || cchar == ControlChar.VTIME) {\n-                    commands.add(Integer.toString(v));\n-                }\n-                else if (v == 0) {\n-                    commands.add(undef);\n-                }\n-                else {\n-                    if (v >= 128) {\n-                        v -= 128;\n-                        str += \"M-\";\n-                    }\n-                    if (v < 32 || v == 127) {\n-                        v ^= 0x40;\n-                        str += \"^\";\n-                    }\n-                    str += (char) v;\n-                    commands.add(str);\n-                }\n-            }\n-        }\n-        return commands;\n-    }\n-\n-    @Override\n-    public Size getSize() throws IOException {\n-        String cfg = doGetConfig();\n-        return doGetSize(cfg);\n-    }\n-\n-    protected String doGetConfig() throws IOException {\n-        return console != null\n-                ? exec(true,  OSUtils.STTY_COMMAND, \"-a\")\n-                : exec(false, OSUtils.STTY_COMMAND, OSUtils.STTY_F_OPTION, getName(), \"-a\");\n-    }\n-\n-    static Attributes doGetAttr(String cfg) throws IOException {\n-        Attributes attributes = new Attributes();\n-        for (InputFlag flag : InputFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setInputFlag(flag, value);\n-            }\n-        }\n-        for (OutputFlag flag : OutputFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setOutputFlag(flag, value);\n-            }\n-        }\n-        for (ControlFlag flag : ControlFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setControlFlag(flag, value);\n-            }\n-        }\n-        for (LocalFlag flag : LocalFlag.values()) {\n-            Boolean value = doGetFlag(cfg, flag);\n-            if (value != null) {\n-                attributes.setLocalFlag(flag, value);\n-            }\n-        }\n-        for (ControlChar cchar : ControlChar.values()) {\n-            String name = cchar.name().toLowerCase().substring(1);\n-            if (\"reprint\".endsWith(name)) {\n-                name = \"(?:reprint|rprnt)\";\n-            }\n-            Matcher matcher = Pattern.compile(\"[\\\\s;]\" + name + \"\\\\s*=\\\\s*(.+?)[\\\\s;]\").matcher(cfg);\n-            if (matcher.find()) {\n-                attributes.setControlChar(cchar, parseControlChar(matcher.group(1).toUpperCase()));\n-            }\n-        }\n-        return attributes;\n-    }\n-\n-    private static Boolean doGetFlag(String cfg, Enum<?> flag) {\n-        Matcher matcher = Pattern.compile(\"(?:^|[\\\\s;])(\\\\-?\" + flag.name().toLowerCase() + \")(?:[\\\\s;]|$)\").matcher(cfg);\n-        return matcher.find() ? !matcher.group(1).startsWith(\"-\") : null;\n-    }\n-\n-    static int parseControlChar(String str) {\n-        \/\/ undef\n-        if (\"<UNDEF>\".equals(str)) {\n-            return -1;\n-        }\n-        \/\/ del\n-        if (\"DEL\".equalsIgnoreCase(str)) {\n-            return 127;\n-        }\n-        \/\/ octal\n-        if (str.charAt(0) == '0') {\n-            return Integer.parseInt(str, 8);\n-        }\n-        \/\/ decimal\n-        if (str.charAt(0) >= '1' && str.charAt(0) <= '9') {\n-            return Integer.parseInt(str, 10);\n-        }\n-        \/\/ control char\n-        if (str.charAt(0) == '^') {\n-            if (str.charAt(1) == '?') {\n-                return 127;\n-            } else {\n-                return str.charAt(1) - 64;\n-            }\n-        } else if (str.charAt(0) == 'M' && str.charAt(1) == '-') {\n-            if (str.charAt(2) == '^') {\n-                if (str.charAt(3) == '?') {\n-                    return 127 + 128;\n-                } else {\n-                    return str.charAt(3) - 64 + 128;\n-                }\n-            } else {\n-                return str.charAt(2) + 128;\n-            }\n-        } else {\n-            return str.charAt(0);\n-        }\n-    }\n-\n-    static Size doGetSize(String cfg) throws IOException {\n-        return new Size(doGetInt(\"columns\", cfg), doGetInt(\"rows\", cfg));\n-    }\n-\n-    static int doGetInt(String name, String cfg) throws IOException {\n-        String[] patterns = new String[] {\n-                \"\\\\b([0-9]+)\\\\s+\" + name + \"\\\\b\",\n-                \"\\\\b\" + name + \"\\\\s+([0-9]+)\\\\b\",\n-                \"\\\\b\" + name + \"\\\\s*=\\\\s*([0-9]+)\\\\b\"\n-        };\n-        for (String pattern : patterns) {\n-            Matcher matcher = Pattern.compile(pattern).matcher(cfg);\n-            if (matcher.find()) {\n-                return Integer.parseInt(matcher.group(1));\n-            }\n-        }\n-        throw new IOException(\"Unable to parse \" + name);\n-    }\n-\n-    @Override\n-    public void setSize(Size size) throws IOException {\n-        if (console != null) {\n-            exec(true,\n-                 OSUtils.STTY_COMMAND,\n-                 \"columns\", Integer.toString(size.getColumns()),\n-                 \"rows\", Integer.toString(size.getRows()));\n-        } else {\n-            exec(false,\n-                 OSUtils.STTY_COMMAND,\n-                 OSUtils.STTY_F_OPTION, getName(),\n-                 \"columns\", Integer.toString(size.getColumns()),\n-                 \"rows\", Integer.toString(size.getRows()));\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"ExecPty[\" + getName() + (console != null ? \", system]\" : \"]\");\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExecPty.java","additions":0,"deletions":296,"binary":false,"changes":296,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -11,4 +11,0 @@\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Cursor;\n-import jdk.internal.org.jline.terminal.Size;\n-\n@@ -22,0 +18,5 @@\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Cursor;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n@@ -35,0 +36,1 @@\n+    private final TerminalProvider provider;\n@@ -41,5 +43,4 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding) throws IOException {\n-        this(name, type, masterInput, masterOutput, encoding, SignalHandler.SIG_DFL);\n+    public ExternalTerminal(\n+            String name, String type, InputStream masterInput, OutputStream masterOutput, Charset encoding)\n+            throws IOException {\n+        this(null, name, type, masterInput, masterOutput, encoding, SignalHandler.SIG_DFL);\n@@ -48,6 +49,10 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding,\n-                            SignalHandler signalHandler) throws IOException {\n-        this(name, type, masterInput, masterOutput, encoding, signalHandler, false);\n+    public ExternalTerminal(\n+            TerminalProvider provider,\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            SignalHandler signalHandler)\n+            throws IOException {\n+        this(provider, name, type, masterInput, masterOutput, encoding, signalHandler, false);\n@@ -56,7 +61,11 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding,\n-                            SignalHandler signalHandler,\n-                            boolean paused) throws IOException {\n-        this(name, type, masterInput, masterOutput, encoding, signalHandler, paused, null, null);\n+    public ExternalTerminal(\n+            TerminalProvider provider,\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            boolean paused)\n+            throws IOException {\n+        this(provider, name, type, masterInput, masterOutput, encoding, signalHandler, paused, null, null);\n@@ -65,8 +74,13 @@\n-    public ExternalTerminal(String name, String type,\n-                            InputStream masterInput,\n-                            OutputStream masterOutput,\n-                            Charset encoding,\n-                            SignalHandler signalHandler,\n-                            boolean paused,\n-                            Attributes attributes,\n-                            Size size) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public ExternalTerminal(\n+            TerminalProvider provider,\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n@@ -74,0 +88,1 @@\n+        this.provider = provider;\n@@ -174,0 +189,4 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return provider;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExternalTerminal.java","additions":50,"deletions":31,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -17,0 +17,1 @@\n+import java.util.EnumSet;\n@@ -26,0 +27,2 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -48,15 +51,0 @@\n-    private static final String DEFAULT_TERMINAL_ATTRIBUTES =\n-                    \"speed 9600 baud; 24 rows; 80 columns;\\n\" +\n-                    \"lflags: icanon isig iexten echo echoe -echok echoke -echonl echoctl\\n\" +\n-                    \"\\t-echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo\\n\" +\n-                    \"\\t-extproc\\n\" +\n-                    \"iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel iutf8\\n\" +\n-                    \"\\t-ignbrk brkint -inpck -ignpar -parmrk\\n\" +\n-                    \"oflags: opost onlcr -oxtabs -onocr -onlret\\n\" +\n-                    \"cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow\\n\" +\n-                    \"\\t-dtrflow -mdmbuf\\n\" +\n-                    \"cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = <undef>;\\n\" +\n-                    \"\\teol2 = <undef>; erase = ^?; intr = ^C; kill = ^U; lnext = ^V;\\n\" +\n-                    \"\\tmin = 1; quit = ^\\\\; reprint = ^R; start = ^Q; status = ^T;\\n\" +\n-                    \"\\tstop = ^S; susp = ^Z; time = 0; werase = ^W;\\n\";\n-\n@@ -87,0 +75,1 @@\n+\n@@ -89,4 +78,4 @@\n-    public LineDisciplineTerminal(String name,\n-                                  String type,\n-                                  OutputStream masterOutput,\n-                                  Charset encoding) throws IOException {\n+    protected boolean skipNextLf;\n+\n+    public LineDisciplineTerminal(String name, String type, OutputStream masterOutput, Charset encoding)\n+            throws IOException {\n@@ -96,5 +85,4 @@\n-    public LineDisciplineTerminal(String name,\n-                                  String type,\n-                                  OutputStream masterOutput,\n-                                  Charset encoding,\n-                                  SignalHandler signalHandler) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public LineDisciplineTerminal(\n+            String name, String type, OutputStream masterOutput, Charset encoding, SignalHandler signalHandler)\n+            throws IOException {\n@@ -109,1 +97,1 @@\n-        this.attributes = ExecPty.doGetAttr(DEFAULT_TERMINAL_ATTRIBUTES);\n+        this.attributes = getDefaultTerminalAttributes();\n@@ -114,0 +102,55 @@\n+    private static Attributes getDefaultTerminalAttributes() {\n+        \/\/ speed 9600 baud; 24 rows; 80 columns;\n+        \/\/ lflags: icanon isig iexten echo echoe -echok echoke -echonl echoctl\n+        \/\/     -echoprt -altwerase -noflsh -tostop -flusho pendin -nokerninfo\n+        \/\/     -extproc\n+        \/\/ iflags: -istrip icrnl -inlcr -igncr ixon -ixoff ixany imaxbel iutf8\n+        \/\/     -ignbrk brkint -inpck -ignpar -parmrk\n+        \/\/ oflags: opost onlcr -oxtabs -onocr -onlret\n+        \/\/ cflags: cread cs8 -parenb -parodd hupcl -clocal -cstopb -crtscts -dsrflow\n+        \/\/     -dtrflow -mdmbuf\n+        \/\/ cchars: discard = ^O; dsusp = ^Y; eof = ^D; eol = <undef>;\n+        \/\/     eol2 = <undef>; erase = ^?; intr = ^C; kill = ^U; lnext = ^V;\n+        \/\/     min = 1; quit = ^\\\\; reprint = ^R; start = ^Q; status = ^T;\n+        \/\/     stop = ^S; susp = ^Z; time = 0; werase = ^W;\n+        Attributes attr = new Attributes();\n+        attr.setLocalFlags(EnumSet.of(\n+                LocalFlag.ICANON,\n+                LocalFlag.ISIG,\n+                LocalFlag.IEXTEN,\n+                LocalFlag.ECHO,\n+                LocalFlag.ECHOE,\n+                LocalFlag.ECHOKE,\n+                LocalFlag.ECHOCTL,\n+                LocalFlag.PENDIN));\n+        attr.setInputFlags(EnumSet.of(\n+                InputFlag.ICRNL,\n+                InputFlag.IXON,\n+                InputFlag.IXANY,\n+                InputFlag.IMAXBEL,\n+                InputFlag.IUTF8,\n+                InputFlag.BRKINT));\n+        attr.setOutputFlags(EnumSet.of(OutputFlag.OPOST, OutputFlag.ONLCR));\n+        attr.setControlChar(ControlChar.VDISCARD, ctrl('O'));\n+        attr.setControlChar(ControlChar.VDSUSP, ctrl('Y'));\n+        attr.setControlChar(ControlChar.VEOF, ctrl('D'));\n+        attr.setControlChar(ControlChar.VERASE, ctrl('?'));\n+        attr.setControlChar(ControlChar.VINTR, ctrl('C'));\n+        attr.setControlChar(ControlChar.VKILL, ctrl('U'));\n+        attr.setControlChar(ControlChar.VLNEXT, ctrl('V'));\n+        attr.setControlChar(ControlChar.VMIN, 1);\n+        attr.setControlChar(ControlChar.VQUIT, ctrl('\\\\'));\n+        attr.setControlChar(ControlChar.VREPRINT, ctrl('R'));\n+        attr.setControlChar(ControlChar.VSTART, ctrl('Q'));\n+        attr.setControlChar(ControlChar.VSTATUS, ctrl('T'));\n+        attr.setControlChar(ControlChar.VSTOP, ctrl('S'));\n+        attr.setControlChar(ControlChar.VSUSP, ctrl('Z'));\n+        attr.setControlChar(ControlChar.VTIME, 0);\n+        attr.setControlChar(ControlChar.VWERASE, ctrl('W'));\n+        return attr;\n+    }\n+\n+    private static int ctrl(char c) {\n+        return c == '?' ? 177 : c - 64;\n+    }\n+\n@@ -133,3 +176,1 @@\n-        Attributes attr = new Attributes();\n-        attr.copy(attributes);\n-        return attr;\n+        return new Attributes(attributes);\n@@ -152,1 +193,1 @@\n-   @Override\n+    @Override\n@@ -154,1 +195,1 @@\n-       Objects.requireNonNull(signal);\n+        Objects.requireNonNull(signal);\n@@ -217,1 +258,13 @@\n-        if (c == '\\r') {\n+        if (attributes.getInputFlag(InputFlag.INORMEOL)) {\n+            if (c == '\\r') {\n+                skipNextLf = true;\n+                c = '\\n';\n+            } else if (c == '\\n') {\n+                if (skipNextLf) {\n+                    skipNextLf = false;\n+                    return false;\n+                }\n+            } else {\n+                skipNextLf = false;\n+            }\n+        } else if (c == '\\r') {\n@@ -276,0 +329,10 @@\n+    @Override\n+    public TerminalProvider getProvider() {\n+        return null;\n+    }\n+\n+    @Override\n+    public SystemStream getSystemStream() {\n+        return null;\n+    }\n+\n@@ -287,2 +350,1 @@\n-            } else if ((off < 0) || (off > b.length) || (len < 0) ||\n-                    ((off + len) > b.length) || ((off + len) < 0)) {\n+            } else if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)) {\n@@ -293,1 +355,1 @@\n-            for (int i = 0 ; i < len ; i++) {\n+            for (int i = 0; i < len; i++) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/LineDisciplineTerminal.java","additions":97,"deletions":35,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -11,5 +11,0 @@\n-import jdk.internal.org.jline.terminal.MouseEvent;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.utils.InfoCmp;\n-import jdk.internal.org.jline.utils.InputStreamReader;\n-\n@@ -23,0 +18,5 @@\n+import jdk.internal.org.jline.terminal.MouseEvent;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.utils.InfoCmp;\n+import jdk.internal.org.jline.utils.InputStreamReader;\n+\n@@ -81,1 +81,2 @@\n-                            && (last.getType() == MouseEvent.Type.Pressed || last.getType() == MouseEvent.Type.Dragged)) {\n+                            && (last.getType() == MouseEvent.Type.Pressed\n+                                    || last.getType() == MouseEvent.Type.Dragged)) {\n@@ -90,1 +91,2 @@\n-                            && (last.getType() == MouseEvent.Type.Pressed || last.getType() == MouseEvent.Type.Dragged)) {\n+                            && (last.getType() == MouseEvent.Type.Pressed\n+                                    || last.getType() == MouseEvent.Type.Dragged)) {\n@@ -99,1 +101,2 @@\n-                            && (last.getType() == MouseEvent.Type.Pressed || last.getType() == MouseEvent.Type.Dragged)) {\n+                            && (last.getType() == MouseEvent.Type.Pressed\n+                                    || last.getType() == MouseEvent.Type.Dragged)) {\n@@ -137,1 +140,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/MouseSupport.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -20,2 +20,1 @@\n-    private NativeSignalHandler() {\n-    }\n+    private NativeSignalHandler() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/NativeSignalHandler.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -41,1 +41,2 @@\n-    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding) throws IOException {\n+    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding)\n+            throws IOException {\n@@ -45,1 +46,9 @@\n-    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding, SignalHandler signalHandler) throws IOException {\n+    public PosixPtyTerminal(\n+            String name,\n+            String type,\n+            Pty pty,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            SignalHandler signalHandler)\n+            throws IOException {\n@@ -49,1 +58,11 @@\n-    public PosixPtyTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding, SignalHandler signalHandler, boolean paused) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public PosixPtyTerminal(\n+            String name,\n+            String type,\n+            Pty pty,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            SignalHandler signalHandler,\n+            boolean paused)\n+            throws IOException {\n@@ -116,1 +135,1 @@\n-        if (p2 !=null) {\n+        if (p2 != null) {\n@@ -170,1 +189,1 @@\n-            for (;;) {\n+            for (; ; ) {\n@@ -196,1 +215,1 @@\n-            for (;;) {\n+            for (; ; ) {\n@@ -224,1 +243,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixPtyTerminal.java","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -21,1 +21,0 @@\n-import jdk.internal.org.jline.utils.NonBlocking;\n@@ -23,0 +22,2 @@\n+import jdk.internal.org.jline.utils.FastBufferedOutputStream;\n+import jdk.internal.org.jline.utils.NonBlocking;\n@@ -38,3 +39,5 @@\n-    public PosixSysTerminal(String name, String type, Pty pty, Charset encoding,\n-                            boolean nativeSignals, SignalHandler signalHandler,\n-                            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    @SuppressWarnings(\"this-escape\")\n+    public PosixSysTerminal(\n+            String name, String type, Pty pty, Charset encoding, boolean nativeSignals, SignalHandler signalHandler,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -43,1 +46,1 @@\n-        this.output = pty.getSlaveOutput();\n+        this.output = new FastBufferedOutputStream(pty.getSlaveOutput());\n@@ -101,1 +104,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixSysTerminal.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2002-2016, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.exec;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Attributes.ControlChar;\n+import jdk.internal.org.jline.terminal.Attributes.ControlFlag;\n+import jdk.internal.org.jline.terminal.Attributes.InputFlag;\n+import jdk.internal.org.jline.terminal.Attributes.LocalFlag;\n+import jdk.internal.org.jline.terminal.Attributes.OutputFlag;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.AbstractPty;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import static jdk.internal.org.jline.utils.ExecHelper.exec;\n+\n+public class ExecPty extends AbstractPty implements Pty {\n+\n+    private final String name;\n+\n+    public static Pty current(TerminalProvider provider, SystemStream systemStream) throws IOException {\n+        try {\n+            String result = exec(true, OSUtils.TTY_COMMAND);\n+            if (systemStream != SystemStream.Output && systemStream != SystemStream.Error) {\n+                throw new IllegalArgumentException(\"systemStream should be Output or Error: \" + systemStream);\n+            }\n+            return new ExecPty(provider, systemStream, result.trim());\n+        } catch (IOException e) {\n+            throw new IOException(\"Not a tty\", e);\n+        }\n+    }\n+\n+    protected ExecPty(TerminalProvider provider, SystemStream systemStream, String name) {\n+        super(provider, systemStream);\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {}\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public InputStream getMasterInput() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public OutputStream getMasterOutput() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected InputStream doGetSlaveInput() throws IOException {\n+        return systemStream != null ? new FileInputStream(FileDescriptor.in) : new FileInputStream(getName());\n+    }\n+\n+    @Override\n+    public OutputStream getSlaveOutput() throws IOException {\n+        return systemStream == SystemStream.Output\n+                ? new FileOutputStream(FileDescriptor.out)\n+                : systemStream == SystemStream.Error\n+                        ? new FileOutputStream(FileDescriptor.err)\n+                        : new FileOutputStream(getName());\n+    }\n+\n+    @Override\n+    public Attributes getAttr() throws IOException {\n+        String cfg = doGetConfig();\n+        return doGetAttr(cfg);\n+    }\n+\n+    @Override\n+    protected void doSetAttr(Attributes attr) throws IOException {\n+        List<String> commands = getFlagsToSet(attr, getAttr());\n+        if (!commands.isEmpty()) {\n+            commands.add(0, OSUtils.STTY_COMMAND);\n+            if (systemStream == null) {\n+                commands.add(1, OSUtils.STTY_F_OPTION);\n+                commands.add(2, getName());\n+            }\n+            try {\n+                exec(systemStream != null, commands.toArray(new String[0]));\n+            } catch (IOException e) {\n+                \/\/ Handle partial failures with GNU stty, see #97\n+                if (e.toString().contains(\"unable to perform all requested operations\")) {\n+                    commands = getFlagsToSet(attr, getAttr());\n+                    if (!commands.isEmpty()) {\n+                        throw new IOException(\"Could not set the following flags: \" + String.join(\", \", commands), e);\n+                    }\n+                } else {\n+                    throw e;\n+                }\n+            }\n+        }\n+    }\n+\n+    protected List<String> getFlagsToSet(Attributes attr, Attributes current) {\n+        List<String> commands = new ArrayList<>();\n+        for (InputFlag flag : InputFlag.values()) {\n+            if (attr.getInputFlag(flag) != current.getInputFlag(flag) && flag != InputFlag.INORMEOL) {\n+                commands.add((attr.getInputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        for (OutputFlag flag : OutputFlag.values()) {\n+            if (attr.getOutputFlag(flag) != current.getOutputFlag(flag)) {\n+                commands.add((attr.getOutputFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        for (ControlFlag flag : ControlFlag.values()) {\n+            if (attr.getControlFlag(flag) != current.getControlFlag(flag)) {\n+                commands.add((attr.getControlFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        for (LocalFlag flag : LocalFlag.values()) {\n+            if (attr.getLocalFlag(flag) != current.getLocalFlag(flag)) {\n+                commands.add((attr.getLocalFlag(flag) ? flag.name() : \"-\" + flag.name()).toLowerCase());\n+            }\n+        }\n+        String undef = System.getProperty(\"os.name\").toLowerCase().startsWith(\"hp\") ? \"^-\" : \"undef\";\n+        for (ControlChar cchar : ControlChar.values()) {\n+            int v = attr.getControlChar(cchar);\n+            if (v >= 0 && v != current.getControlChar(cchar)) {\n+                String str = \"\";\n+                commands.add(cchar.name().toLowerCase().substring(1));\n+                if (cchar == ControlChar.VMIN || cchar == ControlChar.VTIME) {\n+                    commands.add(Integer.toString(v));\n+                } else if (v == 0) {\n+                    commands.add(undef);\n+                } else {\n+                    if (v >= 128) {\n+                        v -= 128;\n+                        str += \"M-\";\n+                    }\n+                    if (v < 32 || v == 127) {\n+                        v ^= 0x40;\n+                        str += \"^\";\n+                    }\n+                    str += (char) v;\n+                    commands.add(str);\n+                }\n+            }\n+        }\n+        return commands;\n+    }\n+\n+    @Override\n+    public Size getSize() throws IOException {\n+        String cfg = doGetConfig();\n+        return doGetSize(cfg);\n+    }\n+\n+    protected String doGetConfig() throws IOException {\n+        return systemStream != null\n+                ? exec(true, OSUtils.STTY_COMMAND, \"-a\")\n+                : exec(false, OSUtils.STTY_COMMAND, OSUtils.STTY_F_OPTION, getName(), \"-a\");\n+    }\n+\n+    public static Attributes doGetAttr(String cfg) throws IOException {\n+        Attributes attributes = new Attributes();\n+        for (InputFlag flag : InputFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setInputFlag(flag, value);\n+            }\n+        }\n+        for (OutputFlag flag : OutputFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setOutputFlag(flag, value);\n+            }\n+        }\n+        for (ControlFlag flag : ControlFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setControlFlag(flag, value);\n+            }\n+        }\n+        for (LocalFlag flag : LocalFlag.values()) {\n+            Boolean value = doGetFlag(cfg, flag);\n+            if (value != null) {\n+                attributes.setLocalFlag(flag, value);\n+            }\n+        }\n+        for (ControlChar cchar : ControlChar.values()) {\n+            String name = cchar.name().toLowerCase().substring(1);\n+            if (\"reprint\".endsWith(name)) {\n+                name = \"(?:reprint|rprnt)\";\n+            }\n+            Matcher matcher =\n+                    Pattern.compile(\"[\\\\s;]\" + name + \"\\\\s*=\\\\s*(.+?)[\\\\s;]\").matcher(cfg);\n+            if (matcher.find()) {\n+                attributes.setControlChar(\n+                        cchar, parseControlChar(matcher.group(1).toUpperCase()));\n+            }\n+        }\n+        return attributes;\n+    }\n+\n+    private static Boolean doGetFlag(String cfg, Enum<?> flag) {\n+        Matcher matcher = Pattern.compile(\"(?:^|[\\\\s;])(\\\\-?\" + flag.name().toLowerCase() + \")(?:[\\\\s;]|$)\")\n+                .matcher(cfg);\n+        return matcher.find() ? !matcher.group(1).startsWith(\"-\") : null;\n+    }\n+\n+    static int parseControlChar(String str) {\n+        \/\/ undef\n+        if (\"<UNDEF>\".equals(str)) {\n+            return -1;\n+        }\n+        \/\/ del\n+        if (\"DEL\".equalsIgnoreCase(str)) {\n+            return 127;\n+        }\n+        \/\/ octal\n+        if (str.charAt(0) == '0') {\n+            return Integer.parseInt(str, 8);\n+        }\n+        \/\/ decimal\n+        if (str.charAt(0) >= '1' && str.charAt(0) <= '9') {\n+            return Integer.parseInt(str, 10);\n+        }\n+        \/\/ control char\n+        if (str.charAt(0) == '^') {\n+            if (str.charAt(1) == '?') {\n+                return 127;\n+            } else {\n+                return str.charAt(1) - 64;\n+            }\n+        } else if (str.charAt(0) == 'M' && str.charAt(1) == '-') {\n+            if (str.charAt(2) == '^') {\n+                if (str.charAt(3) == '?') {\n+                    return 127 + 128;\n+                } else {\n+                    return str.charAt(3) - 64 + 128;\n+                }\n+            } else {\n+                return str.charAt(2) + 128;\n+            }\n+        } else {\n+            return str.charAt(0);\n+        }\n+    }\n+\n+    static Size doGetSize(String cfg) throws IOException {\n+        return new Size(doGetInt(\"columns\", cfg), doGetInt(\"rows\", cfg));\n+    }\n+\n+    static int doGetInt(String name, String cfg) throws IOException {\n+        String[] patterns = new String[] {\n+            \"\\\\b([0-9]+)\\\\s+\" + name + \"\\\\b\", \"\\\\b\" + name + \"\\\\s+([0-9]+)\\\\b\", \"\\\\b\" + name + \"\\\\s*=\\\\s*([0-9]+)\\\\b\"\n+        };\n+        for (String pattern : patterns) {\n+            Matcher matcher = Pattern.compile(pattern).matcher(cfg);\n+            if (matcher.find()) {\n+                return Integer.parseInt(matcher.group(1));\n+            }\n+        }\n+        throw new IOException(\"Unable to parse \" + name);\n+    }\n+\n+    @Override\n+    public void setSize(Size size) throws IOException {\n+        if (systemStream != null) {\n+            exec(\n+                    true,\n+                    OSUtils.STTY_COMMAND,\n+                    \"columns\",\n+                    Integer.toString(size.getColumns()),\n+                    \"rows\",\n+                    Integer.toString(size.getRows()));\n+        } else {\n+            exec(\n+                    false,\n+                    OSUtils.STTY_COMMAND,\n+                    OSUtils.STTY_F_OPTION,\n+                    getName(),\n+                    \"columns\",\n+                    Integer.toString(size.getColumns()),\n+                    \"rows\",\n+                    Integer.toString(size.getRows()));\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ExecPty[\" + getName() + (systemStream != null ? \", system]\" : \"]\");\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecPty.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, the original author or authors.\n+ * Copyright (c) 2022, the original author(s).\n@@ -20,0 +20,2 @@\n+\/\/import jdk.internal.org.jline.nativ.JLineLibrary;\n+\/\/import jdk.internal.org.jline.nativ.JLineNativeLoader;\n@@ -23,1 +25,1 @@\n-import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n@@ -27,0 +29,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -29,0 +32,1 @@\n+import jdk.internal.org.jline.utils.Log;\n@@ -31,2 +35,8 @@\n-public class ExecTerminalProvider implements TerminalProvider\n-{\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE_DEFAULT;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE;\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION;\n+\n+public class ExecTerminalProvider implements TerminalProvider {\n+\n+    private static boolean warned;\n@@ -35,1 +45,1 @@\n-        return \"exec\";\n+        return TerminalBuilder.PROP_PROVIDER_EXEC;\n@@ -38,2 +48,2 @@\n-    public Pty current(Stream consoleStream) throws IOException {\n-        return ExecPty.current(consoleStream);\n+    public Pty current(SystemStream systemStream) throws IOException {\n+        return ExecPty.current(this, systemStream);\n@@ -43,3 +53,11 @@\n-    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    public Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -47,1 +65,2 @@\n-            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+            return winSysTerminal(\n+                    name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, systemStream, inputStreamWrapper);\n@@ -49,1 +68,2 @@\n-            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+            return posixSysTerminal(\n+                    name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, systemStream, inputStreamWrapper);\n@@ -53,3 +73,11 @@\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                    boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                    Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper ) throws IOException {\n+    public Terminal winSysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n@@ -57,1 +85,1 @@\n-            Pty pty = current(consoleStream);\n+            Pty pty = current(systemStream);\n@@ -64,4 +92,12 @@\n-    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        Pty pty = current(consoleStream);\n+    public Terminal posixSysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        Pty pty = current(systemStream);\n@@ -72,5 +108,12 @@\n-    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n-                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Attributes attributes, Size size) throws IOException\n-    {\n-        return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n+    public Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n+        return new ExternalTerminal(this, name, type, in, out, encoding, signalHandler, paused, attributes, size);\n@@ -80,1 +123,1 @@\n-    public boolean isSystemStream(Stream stream) {\n+    public boolean isSystemStream(SystemStream stream) {\n@@ -82,1 +125,1 @@\n-            return isWindowsSystemStream(stream) || isPosixSystemStream(stream);\n+            return isPosixSystemStream(stream) || isWindowsSystemStream(stream);\n@@ -88,2 +131,2 @@\n-    public boolean isWindowsSystemStream(Stream stream) {\n-        return systemStreamName( stream ) != null;\n+    public boolean isWindowsSystemStream(SystemStream stream) {\n+        return systemStreamName(stream) != null;\n@@ -92,1 +135,1 @@\n-    public boolean isPosixSystemStream(Stream stream) {\n+    public boolean isPosixSystemStream(SystemStream stream) {\n@@ -95,1 +138,2 @@\n-                    .inheritIO().start();\n+                    .inheritIO()\n+                    .start();\n@@ -98,0 +142,1 @@\n+            Log.debug(\"ExecTerminalProvider failed 'test -t' for \" + stream, t);\n@@ -104,1 +149,1 @@\n-    public String systemStreamName(Stream stream) {\n+    public String systemStreamName(SystemStream stream) {\n@@ -106,4 +151,5 @@\n-            ProcessBuilder.Redirect input = stream == Stream.Input\n-                                ? ProcessBuilder.Redirect.INHERIT\n-                                : getRedirect(stream == Stream.Output ? FileDescriptor.out : FileDescriptor.err);\n-            Process p = new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n+            ProcessBuilder.Redirect input = stream == SystemStream.Input\n+                    ? ProcessBuilder.Redirect.INHERIT\n+                    : newDescriptor(stream == SystemStream.Output ? FileDescriptor.out : FileDescriptor.err);\n+            Process p =\n+                    new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n@@ -115,0 +161,7 @@\n+            if (\"java.lang.reflect.InaccessibleObjectException\"\n+                            .equals(t.getClass().getName())\n+                    && !warned) {\n+                Log.warn(\n+                        \"The ExecTerminalProvider requires the JVM options: '--add-opens java.base\/java.lang=ALL-UNNAMED'\");\n+                warned = true;\n+            }\n@@ -120,12 +173,91 @@\n-    private ProcessBuilder.Redirect getRedirect(FileDescriptor fd) throws ReflectiveOperationException {\n-        \/\/ This is not really allowed, but this is the only way to redirect the output or error stream\n-        \/\/ to the input.  This is definitely not something you'd usually want to do, but in the case of\n-        \/\/ the `tty` utility, it provides a way to get\n-        Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n-        Constructor<?> cns = rpi.getDeclaredConstructor();\n-        cns.setAccessible(true);\n-        ProcessBuilder.Redirect input = (ProcessBuilder.Redirect) cns.newInstance();\n-        Field f = rpi.getDeclaredField(\"fd\");\n-        f.setAccessible(true);\n-        f.set(input, fd);\n-        return input;\n+    @Override\n+    public int systemStreamWidth(SystemStream stream) {\n+        try (ExecPty pty = new ExecPty(this, stream, null)) {\n+            return pty.getSize().getColumns();\n+        } catch (Throwable t) {\n+            return -1;\n+        }\n+    }\n+\n+    private static RedirectPipeCreator redirectPipeCreator;\n+\n+    protected static ProcessBuilder.Redirect newDescriptor(FileDescriptor fd) {\n+        if (redirectPipeCreator == null) {\n+            String str = System.getProperty(PROP_REDIRECT_PIPE_CREATION_MODE, PROP_REDIRECT_PIPE_CREATION_MODE_DEFAULT);\n+            String[] modes = str.split(\",\");\n+            IllegalStateException ise = new IllegalStateException(\"Unable to create RedirectPipe\");\n+            for (String mode : modes) {\n+                try {\n+                    switch (mode) {\n+                        case PROP_REDIRECT_PIPE_CREATION_MODE_NATIVE:\n+                            redirectPipeCreator = null;\/\/new NativeRedirectPipeCreator();\n+                            break;\n+                        case PROP_REDIRECT_PIPE_CREATION_MODE_REFLECTION:\n+                            redirectPipeCreator = new ReflectionRedirectPipeCreator();\n+                            break;\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ ignore\n+                    ise.addSuppressed(t);\n+                }\n+                if (redirectPipeCreator != null) {\n+                    break;\n+                }\n+            }\n+            if (redirectPipeCreator == null) {\n+                throw ise;\n+            }\n+        }\n+        return redirectPipeCreator.newRedirectPipe(fd);\n+    }\n+\n+    interface RedirectPipeCreator {\n+        ProcessBuilder.Redirect newRedirectPipe(FileDescriptor fd);\n+    }\n+\n+    \/**\n+     * Reflection based file descriptor creator.\n+     * This requires the following option\n+     *   --add-opens java.base\/java.lang=ALL-UNNAMED\n+     *\/\n+    static class ReflectionRedirectPipeCreator implements RedirectPipeCreator {\n+        private final Constructor<ProcessBuilder.Redirect> constructor;\n+        private final Field fdField;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReflectionRedirectPipeCreator() throws Exception {\n+            Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n+            constructor = (Constructor<ProcessBuilder.Redirect>) rpi.getDeclaredConstructor();\n+            constructor.setAccessible(true);\n+            fdField = rpi.getDeclaredField(\"fd\");\n+            fdField.setAccessible(true);\n+        }\n+\n+        @Override\n+        public ProcessBuilder.Redirect newRedirectPipe(FileDescriptor fd) {\n+            try {\n+                ProcessBuilder.Redirect input = constructor.newInstance();\n+                fdField.set(input, fd);\n+                return input;\n+            } catch (ReflectiveOperationException e) {\n+                \/\/ This should not happen as the field has been set accessible\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+    }\n+\n+\/\/    static class NativeRedirectPipeCreator implements RedirectPipeCreator {\n+\/\/        public NativeRedirectPipeCreator() {\n+\/\/            \/\/ Force load the library\n+\/\/            JLineNativeLoader.initialize();\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public ProcessBuilder.Redirect newRedirectPipe(FileDescriptor fd) {\n+\/\/            return JLineLibrary.newRedirectPipe(fd);\n+\/\/        }\n+\/\/    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TerminalProvider[\" + name() + \"]\";\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecTerminalProvider.java","additions":180,"deletions":48,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -0,0 +1,1170 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+\/\/import java.util.logging.Level;\n+\/\/import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+@SuppressWarnings(\"restricted\")\n+class CLibrary {\n+\n+\/\/    private static final Logger logger = Logger.getLogger(\"org.jline\");\n+\n+    \/\/ Window sizes.\n+    \/\/ @see <a href=\"http:\/\/man7.org\/linux\/man-pages\/man4\/tty_ioctl.4.html\">IOCTL_TTY(2) man-page<\/a>\n+    static class winsize {\n+        static final GroupLayout LAYOUT;\n+        private static final VarHandle ws_col;\n+        private static final VarHandle ws_row;\n+\n+        static {\n+            LAYOUT = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_SHORT.withName(\"ws_row\"),\n+                    ValueLayout.JAVA_SHORT.withName(\"ws_col\"),\n+                    ValueLayout.JAVA_SHORT,\n+                    ValueLayout.JAVA_SHORT);\n+            ws_row = FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"ws_row\"));\n+            ws_col = FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"ws_col\"));\n+        }\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        winsize() {\n+            seg = java.lang.foreign.Arena.ofAuto().allocate(LAYOUT);\n+        }\n+\n+        winsize(short ws_col, short ws_row) {\n+            this();\n+            ws_col(ws_col);\n+            ws_row(ws_row);\n+        }\n+\n+        java.lang.foreign.MemorySegment segment() {\n+            return seg;\n+        }\n+\n+        short ws_col() {\n+            return (short) ws_col.get(seg);\n+        }\n+\n+        void ws_col(short col) {\n+            ws_col.set(seg, col);\n+        }\n+\n+        short ws_row() {\n+            return (short) ws_row.get(seg);\n+        }\n+\n+        void ws_row(short row) {\n+            ws_row.set(seg, row);\n+        }\n+    }\n+\n+    \/\/ termios structure for termios functions, describing a general terminal interface that is\n+    \/\/ provided to control asynchronous communications ports\n+    \/\/ @see <a href=\"http:\/\/man7.org\/linux\/man-pages\/man3\/termios.3.html\">TERMIOS(3) man-page<\/a>\n+    static class termios {\n+        static final GroupLayout LAYOUT;\n+        private static final VarHandle c_iflag;\n+        private static final VarHandle c_oflag;\n+        private static final VarHandle c_cflag;\n+        private static final VarHandle c_lflag;\n+        private static final long c_cc_offset;\n+        private static final VarHandle c_ispeed;\n+        private static final VarHandle c_ospeed;\n+\n+        static {\n+            if (OSUtils.IS_OSX) {\n+                LAYOUT = MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_LONG.withName(\"c_iflag\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_oflag\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_cflag\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_lflag\"),\n+                        MemoryLayout.sequenceLayout(32, ValueLayout.JAVA_BYTE).withName(\"c_cc\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_ispeed\"),\n+                        ValueLayout.JAVA_LONG.withName(\"c_ospeed\"));\n+            } else if (OSUtils.IS_LINUX) {\n+                LAYOUT = MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"c_iflag\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_oflag\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_cflag\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_lflag\"),\n+                        ValueLayout.JAVA_BYTE.withName(\"c_line\"),\n+                        MemoryLayout.sequenceLayout(32, ValueLayout.JAVA_BYTE).withName(\"c_cc\"),\n+                        MemoryLayout.paddingLayout(3),\n+                        ValueLayout.JAVA_INT.withName(\"c_ispeed\"),\n+                        ValueLayout.JAVA_INT.withName(\"c_ospeed\"));\n+            } else {\n+                throw new IllegalStateException(\"Unsupported system!\");\n+            }\n+            c_iflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_iflag\")));\n+            c_oflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_oflag\")));\n+            c_cflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_cflag\")));\n+            c_lflag = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_lflag\")));\n+            c_cc_offset = LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(\"c_cc\"));\n+            c_ispeed = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_ispeed\")));\n+            c_ospeed = adjust2LinuxHandle(\n+                    FfmTerminalProvider.lookupVarHandle(LAYOUT, MemoryLayout.PathElement.groupElement(\"c_ospeed\")));\n+        }\n+\n+        private static VarHandle adjust2LinuxHandle(VarHandle v) {\n+            if (OSUtils.IS_LINUX) {\n+                MethodHandle id = MethodHandles.identity(int.class);\n+                v = MethodHandles.filterValue(\n+                        v,\n+                        MethodHandles.explicitCastArguments(id, MethodType.methodType(int.class, long.class)),\n+                        MethodHandles.explicitCastArguments(id, MethodType.methodType(long.class, int.class)));\n+            }\n+\n+            return v;\n+        }\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        termios() {\n+            seg = java.lang.foreign.Arena.ofAuto().allocate(LAYOUT);\n+        }\n+\n+        termios(Attributes t) {\n+            this();\n+            \/\/ Input flags\n+            long c_iflag = 0;\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IGNBRK), IGNBRK, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.BRKINT), BRKINT, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IGNPAR), IGNPAR, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.PARMRK), PARMRK, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.INPCK), INPCK, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.ISTRIP), ISTRIP, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.INLCR), INLCR, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IGNCR), IGNCR, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.ICRNL), ICRNL, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IXON), IXON, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IXOFF), IXOFF, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IXANY), IXANY, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IMAXBEL), IMAXBEL, c_iflag);\n+            c_iflag = setFlag(t.getInputFlag(Attributes.InputFlag.IUTF8), IUTF8, c_iflag);\n+            c_iflag(c_iflag);\n+            \/\/ Output flags\n+            long c_oflag = 0;\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OPOST), OPOST, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONLCR), ONLCR, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OXTABS), OXTABS, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONOEOT), ONOEOT, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OCRNL), OCRNL, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONOCR), ONOCR, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.ONLRET), ONLRET, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OFILL), OFILL, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.NLDLY), NLDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.TABDLY), TABDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.CRDLY), CRDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.FFDLY), FFDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.BSDLY), BSDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.VTDLY), VTDLY, c_oflag);\n+            c_oflag = setFlag(t.getOutputFlag(Attributes.OutputFlag.OFDEL), OFDEL, c_oflag);\n+            c_oflag(c_oflag);\n+            \/\/ Control flags\n+            long c_cflag = 0;\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CIGNORE), CIGNORE, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS5), CS5, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS6), CS6, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS7), CS7, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CS8), CS8, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CSTOPB), CSTOPB, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CREAD), CREAD, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.PARENB), PARENB, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.PARODD), PARODD, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.HUPCL), HUPCL, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CLOCAL), CLOCAL, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CCTS_OFLOW), CCTS_OFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CRTS_IFLOW), CRTS_IFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CDTR_IFLOW), CDTR_IFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CDSR_OFLOW), CDSR_OFLOW, c_cflag);\n+            c_cflag = setFlag(t.getControlFlag(Attributes.ControlFlag.CCAR_OFLOW), CCAR_OFLOW, c_cflag);\n+            c_cflag(c_cflag);\n+            \/\/ Local flags\n+            long c_lflag = 0;\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOKE), ECHOKE, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOE), ECHOE, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOK), ECHOK, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHO), ECHO, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHONL), ECHONL, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOPRT), ECHOPRT, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ECHOCTL), ECHOCTL, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ISIG), ISIG, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ICANON), ICANON, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.ALTWERASE), ALTWERASE, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.IEXTEN), IEXTEN, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.EXTPROC), EXTPROC, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.TOSTOP), TOSTOP, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.FLUSHO), FLUSHO, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.NOKERNINFO), NOKERNINFO, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.PENDIN), PENDIN, c_lflag);\n+            c_lflag = setFlag(t.getLocalFlag(Attributes.LocalFlag.NOFLSH), NOFLSH, c_lflag);\n+            c_lflag(c_lflag);\n+            \/\/ Control chars\n+            byte[] c_cc = new byte[20];\n+            c_cc[VEOF] = (byte) t.getControlChar(Attributes.ControlChar.VEOF);\n+            c_cc[VEOL] = (byte) t.getControlChar(Attributes.ControlChar.VEOL);\n+            c_cc[VEOL2] = (byte) t.getControlChar(Attributes.ControlChar.VEOL2);\n+            c_cc[VERASE] = (byte) t.getControlChar(Attributes.ControlChar.VERASE);\n+            c_cc[VWERASE] = (byte) t.getControlChar(Attributes.ControlChar.VWERASE);\n+            c_cc[VKILL] = (byte) t.getControlChar(Attributes.ControlChar.VKILL);\n+            c_cc[VREPRINT] = (byte) t.getControlChar(Attributes.ControlChar.VREPRINT);\n+            c_cc[VINTR] = (byte) t.getControlChar(Attributes.ControlChar.VINTR);\n+            c_cc[VQUIT] = (byte) t.getControlChar(Attributes.ControlChar.VQUIT);\n+            c_cc[VSUSP] = (byte) t.getControlChar(Attributes.ControlChar.VSUSP);\n+            if (VDSUSP != (-1)) {\n+                c_cc[VDSUSP] = (byte) t.getControlChar(Attributes.ControlChar.VDSUSP);\n+            }\n+            c_cc[VSTART] = (byte) t.getControlChar(Attributes.ControlChar.VSTART);\n+            c_cc[VSTOP] = (byte) t.getControlChar(Attributes.ControlChar.VSTOP);\n+            c_cc[VLNEXT] = (byte) t.getControlChar(Attributes.ControlChar.VLNEXT);\n+            c_cc[VDISCARD] = (byte) t.getControlChar(Attributes.ControlChar.VDISCARD);\n+            c_cc[VMIN] = (byte) t.getControlChar(Attributes.ControlChar.VMIN);\n+            c_cc[VTIME] = (byte) t.getControlChar(Attributes.ControlChar.VTIME);\n+            if (VSTATUS != (-1)) {\n+                c_cc[VSTATUS] = (byte) t.getControlChar(Attributes.ControlChar.VSTATUS);\n+            }\n+            c_cc().copyFrom(java.lang.foreign.MemorySegment.ofArray(c_cc));\n+        }\n+\n+        java.lang.foreign.MemorySegment segment() {\n+            return seg;\n+        }\n+\n+        long c_iflag() {\n+            return (long) c_iflag.get(seg);\n+        }\n+\n+        void c_iflag(long f) {\n+            c_iflag.set(seg, f);\n+        }\n+\n+        long c_oflag() {\n+            return (long) c_oflag.get(seg);\n+        }\n+\n+        void c_oflag(long f) {\n+            c_oflag.set(seg, f);\n+        }\n+\n+        long c_cflag() {\n+            return (long) c_cflag.get(seg);\n+        }\n+\n+        void c_cflag(long f) {\n+            c_cflag.set(seg, f);\n+        }\n+\n+        long c_lflag() {\n+            return (long) c_lflag.get(seg);\n+        }\n+\n+        void c_lflag(long f) {\n+            c_lflag.set(seg, f);\n+        }\n+\n+        java.lang.foreign.MemorySegment c_cc() {\n+            return seg.asSlice(c_cc_offset, 20);\n+        }\n+\n+        long c_ispeed() {\n+            return (long) c_ispeed.get(seg);\n+        }\n+\n+        void c_ispeed(long f) {\n+            c_ispeed.set(seg, f);\n+        }\n+\n+        long c_ospeed() {\n+            return (long) c_ospeed.get(seg);\n+        }\n+\n+        void c_ospeed(long f) {\n+            c_ospeed.set(seg, f);\n+        }\n+\n+        private static long setFlag(boolean flag, long value, long org) {\n+            return flag ? org | value : org;\n+        }\n+\n+        private static <T extends Enum<T>> void addFlag(long value, EnumSet<T> flags, T flag, int v) {\n+            if ((value & v) != 0) {\n+                flags.add(flag);\n+            }\n+        }\n+\n+        public Attributes asAttributes() {\n+            Attributes attr = new Attributes();\n+            \/\/ Input flags\n+            long c_iflag = c_iflag();\n+            EnumSet<Attributes.InputFlag> iflag = attr.getInputFlags();\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNBRK, IGNBRK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNBRK, IGNBRK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.BRKINT, BRKINT);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNPAR, IGNPAR);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.PARMRK, PARMRK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.INPCK, INPCK);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.ISTRIP, ISTRIP);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.INLCR, INLCR);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IGNCR, IGNCR);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.ICRNL, ICRNL);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IXON, IXON);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IXOFF, IXOFF);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IXANY, IXANY);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IMAXBEL, IMAXBEL);\n+            addFlag(c_iflag, iflag, Attributes.InputFlag.IUTF8, IUTF8);\n+            \/\/ Output flags\n+            long c_oflag = c_oflag();\n+            EnumSet<Attributes.OutputFlag> oflag = attr.getOutputFlags();\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OPOST, OPOST);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONLCR, ONLCR);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OXTABS, OXTABS);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONOEOT, ONOEOT);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OCRNL, OCRNL);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONOCR, ONOCR);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.ONLRET, ONLRET);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OFILL, OFILL);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.NLDLY, NLDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.TABDLY, TABDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.CRDLY, CRDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.FFDLY, FFDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.BSDLY, BSDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.VTDLY, VTDLY);\n+            addFlag(c_oflag, oflag, Attributes.OutputFlag.OFDEL, OFDEL);\n+            \/\/ Control flags\n+            long c_cflag = c_cflag();\n+            EnumSet<Attributes.ControlFlag> cflag = attr.getControlFlags();\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CIGNORE, CIGNORE);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS5, CS5);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS6, CS6);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS7, CS7);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CS8, CS8);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CSTOPB, CSTOPB);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CREAD, CREAD);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.PARENB, PARENB);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.PARODD, PARODD);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.HUPCL, HUPCL);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CLOCAL, CLOCAL);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CCTS_OFLOW, CCTS_OFLOW);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CRTS_IFLOW, CRTS_IFLOW);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CDSR_OFLOW, CDSR_OFLOW);\n+            addFlag(c_cflag, cflag, Attributes.ControlFlag.CCAR_OFLOW, CCAR_OFLOW);\n+            \/\/ Local flags\n+            long c_lflag = c_lflag();\n+            EnumSet<Attributes.LocalFlag> lflag = attr.getLocalFlags();\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOKE, ECHOKE);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOE, ECHOE);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOK, ECHOK);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHO, ECHO);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHONL, ECHONL);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOPRT, ECHOPRT);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ECHOCTL, ECHOCTL);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ISIG, ISIG);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ICANON, ICANON);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.ALTWERASE, ALTWERASE);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.IEXTEN, IEXTEN);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.EXTPROC, EXTPROC);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.TOSTOP, TOSTOP);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.FLUSHO, FLUSHO);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.NOKERNINFO, NOKERNINFO);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.PENDIN, PENDIN);\n+            addFlag(c_lflag, lflag, Attributes.LocalFlag.NOFLSH, NOFLSH);\n+            \/\/ Control chars\n+            byte[] c_cc = c_cc().toArray(ValueLayout.JAVA_BYTE);\n+            EnumMap<Attributes.ControlChar, Integer> cc = attr.getControlChars();\n+            cc.put(Attributes.ControlChar.VEOF, (int) c_cc[VEOF]);\n+            cc.put(Attributes.ControlChar.VEOL, (int) c_cc[VEOL]);\n+            cc.put(Attributes.ControlChar.VEOL2, (int) c_cc[VEOL2]);\n+            cc.put(Attributes.ControlChar.VERASE, (int) c_cc[VERASE]);\n+            cc.put(Attributes.ControlChar.VWERASE, (int) c_cc[VWERASE]);\n+            cc.put(Attributes.ControlChar.VKILL, (int) c_cc[VKILL]);\n+            cc.put(Attributes.ControlChar.VREPRINT, (int) c_cc[VREPRINT]);\n+            cc.put(Attributes.ControlChar.VINTR, (int) c_cc[VINTR]);\n+            cc.put(Attributes.ControlChar.VQUIT, (int) c_cc[VQUIT]);\n+            cc.put(Attributes.ControlChar.VSUSP, (int) c_cc[VSUSP]);\n+            if (VDSUSP != (-1)) {\n+                cc.put(Attributes.ControlChar.VDSUSP, (int) c_cc[VDSUSP]);\n+            }\n+            cc.put(Attributes.ControlChar.VSTART, (int) c_cc[VSTART]);\n+            cc.put(Attributes.ControlChar.VSTOP, (int) c_cc[VSTOP]);\n+            cc.put(Attributes.ControlChar.VLNEXT, (int) c_cc[VLNEXT]);\n+            cc.put(Attributes.ControlChar.VDISCARD, (int) c_cc[VDISCARD]);\n+            cc.put(Attributes.ControlChar.VMIN, (int) c_cc[VMIN]);\n+            cc.put(Attributes.ControlChar.VTIME, (int) c_cc[VTIME]);\n+            if (VSTATUS != (-1)) {\n+                cc.put(Attributes.ControlChar.VSTATUS, (int) c_cc[VSTATUS]);\n+            }\n+            \/\/ Return\n+            return attr;\n+        }\n+    }\n+\n+    static MethodHandle ioctl;\n+    static MethodHandle isatty;\n+    static MethodHandle openpty;\n+    static MethodHandle tcsetattr;\n+    static MethodHandle tcgetattr;\n+    static MethodHandle ttyname_r;\n+    static LinkageError openptyError;\n+\n+    static {\n+        \/\/ methods\n+        Linker linker = Linker.nativeLinker();\n+        SymbolLookup lookup = SymbolLookup.loaderLookup().or(linker.defaultLookup());\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man2\/ioctl.2.html\n+        ioctl = linker.downcallHandle(\n+                lookup.find(\"ioctl\").get(),\n+                FunctionDescriptor.of(\n+                        ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.ADDRESS),\n+                Linker.Option.firstVariadicArg(2));\n+        \/\/ https:\/\/www.man7.org\/linux\/man-pages\/man3\/isatty.3.html\n+        isatty = linker.downcallHandle(\n+                lookup.find(\"isatty\").get(), FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/tcsetattr.3p.html\n+        tcsetattr = linker.downcallHandle(\n+                lookup.find(\"tcsetattr\").get(),\n+                FunctionDescriptor.of(\n+                        ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/tcgetattr.3p.html\n+        tcgetattr = linker.downcallHandle(\n+                lookup.find(\"tcgetattr\").get(),\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/ttyname.3.html\n+        ttyname_r = linker.downcallHandle(\n+                lookup.find(\"ttyname_r\").get(),\n+                FunctionDescriptor.of(\n+                        ValueLayout.JAVA_INT, ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+        \/\/ https:\/\/man7.org\/linux\/man-pages\/man3\/openpty.3.html\n+        LinkageError error = null;\n+        Optional<MemorySegment> openPtyAddr = lookup.find(\"openpty\");\n+        if (openPtyAddr.isPresent()) {\n+            openpty = linker.downcallHandle(\n+                    openPtyAddr.get(),\n+                    FunctionDescriptor.of(\n+                            ValueLayout.JAVA_INT,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS,\n+                            ValueLayout.ADDRESS));\n+            openptyError = null;\n+        } else {\n+            openpty = null;\n+            openptyError = error;\n+        }\n+    }\n+\n+    private static String readFully(InputStream in) throws IOException {\n+        int readLen = 0;\n+        ByteArrayOutputStream b = new ByteArrayOutputStream();\n+        byte[] buf = new byte[32];\n+        while ((readLen = in.read(buf, 0, buf.length)) >= 0) {\n+            b.write(buf, 0, readLen);\n+        }\n+        return b.toString();\n+    }\n+\n+    static Size getTerminalSize(int fd) {\n+        try {\n+            winsize ws = new winsize();\n+            int res = (int) ioctl.invoke(fd, (long) TIOCGWINSZ, ws.segment());\n+            return new Size(ws.ws_col(), ws.ws_row());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call ioctl(TIOCGWINSZ)\", e);\n+        }\n+    }\n+\n+    static void setTerminalSize(int fd, Size size) {\n+        try {\n+            winsize ws = new winsize();\n+            ws.ws_row((short) size.getRows());\n+            ws.ws_col((short) size.getColumns());\n+            int res = (int) ioctl.invoke(fd, TIOCSWINSZ, ws.segment());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call ioctl(TIOCSWINSZ)\", e);\n+        }\n+    }\n+\n+    static Attributes getAttributes(int fd) {\n+        try {\n+            termios t = new termios();\n+            int res = (int) tcgetattr.invoke(fd, t.segment());\n+            return t.asAttributes();\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call tcgetattr()\", e);\n+        }\n+    }\n+\n+    static void setAttributes(int fd, Attributes attr) {\n+        try {\n+            termios t = new termios(attr);\n+            int res = (int) tcsetattr.invoke(fd, TCSANOW, t.segment());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call tcsetattr()\", e);\n+        }\n+    }\n+\n+    static boolean isTty(int fd) {\n+        try {\n+            return (int) isatty.invoke(fd) == 1;\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call isatty()\", e);\n+        }\n+    }\n+\n+    static String ttyName(int fd) {\n+        try {\n+            java.lang.foreign.MemorySegment buf =\n+                    java.lang.foreign.Arena.ofAuto().allocate(64);\n+            int res = (int) ttyname_r.invoke(fd, buf, buf.byteSize());\n+            byte[] data = buf.toArray(ValueLayout.JAVA_BYTE);\n+            int len = 0;\n+            while (data[len] != 0) {\n+                len++;\n+            }\n+            return new String(data, 0, len);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call ttyname_r()\", e);\n+        }\n+    }\n+\n+    static Pty openpty(TerminalProvider provider, Attributes attr, Size size) {\n+        if (openptyError != null) {\n+            throw openptyError;\n+        }\n+        try {\n+            java.lang.foreign.MemorySegment buf =\n+                    java.lang.foreign.Arena.ofAuto().allocate(64);\n+            java.lang.foreign.MemorySegment master =\n+                    java.lang.foreign.Arena.ofAuto().allocate(ValueLayout.JAVA_INT);\n+            java.lang.foreign.MemorySegment slave =\n+                    java.lang.foreign.Arena.ofAuto().allocate(ValueLayout.JAVA_INT);\n+            int res = (int) openpty.invoke(\n+                    master,\n+                    slave,\n+                    buf,\n+                    attr != null ? new termios(attr).segment() : java.lang.foreign.MemorySegment.NULL,\n+                    size != null\n+                            ? new winsize((short) size.getRows(), (short) size.getColumns()).segment()\n+                            : java.lang.foreign.MemorySegment.NULL);\n+            byte[] str = buf.toArray(ValueLayout.JAVA_BYTE);\n+            int len = 0;\n+            while (str[len] != 0) {\n+                len++;\n+            }\n+            String device = new String(str, 0, len);\n+            return new FfmNativePty(\n+                    provider, null, master.get(ValueLayout.JAVA_INT, 0), slave.get(ValueLayout.JAVA_INT, 0), device);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Unable to call openpty()\", e);\n+        }\n+    }\n+\n+    \/\/ CONSTANTS\n+\n+    private static final int TIOCGWINSZ;\n+    private static final int TIOCSWINSZ;\n+\n+    private static final int TCSANOW;\n+    private static int TCSADRAIN;\n+    private static int TCSAFLUSH;\n+\n+    private static final int VEOF;\n+    private static final int VEOL;\n+    private static final int VEOL2;\n+    private static final int VERASE;\n+    private static final int VWERASE;\n+    private static final int VKILL;\n+    private static final int VREPRINT;\n+    private static final int VERASE2;\n+    private static final int VINTR;\n+    private static final int VQUIT;\n+    private static final int VSUSP;\n+    private static final int VDSUSP;\n+    private static final int VSTART;\n+    private static final int VSTOP;\n+    private static final int VLNEXT;\n+    private static final int VDISCARD;\n+    private static final int VMIN;\n+    private static final int VSWTC;\n+    private static final int VTIME;\n+    private static final int VSTATUS;\n+\n+    private static final int IGNBRK;\n+    private static final int BRKINT;\n+    private static final int IGNPAR;\n+    private static final int PARMRK;\n+    private static final int INPCK;\n+    private static final int ISTRIP;\n+    private static final int INLCR;\n+    private static final int IGNCR;\n+    private static final int ICRNL;\n+    private static int IUCLC;\n+    private static final int IXON;\n+    private static final int IXOFF;\n+    private static final int IXANY;\n+    private static final int IMAXBEL;\n+    private static int IUTF8;\n+\n+    private static final int OPOST;\n+    private static int OLCUC;\n+    private static final int ONLCR;\n+    private static int OXTABS;\n+    private static int NLDLY;\n+    private static int NL0;\n+    private static int NL1;\n+    private static final int TABDLY;\n+    private static int TAB0;\n+    private static int TAB1;\n+    private static int TAB2;\n+    private static int TAB3;\n+    private static int CRDLY;\n+    private static int CR0;\n+    private static int CR1;\n+    private static int CR2;\n+    private static int CR3;\n+    private static int FFDLY;\n+    private static int FF0;\n+    private static int FF1;\n+    private static int XTABS;\n+    private static int BSDLY;\n+    private static int BS0;\n+    private static int BS1;\n+    private static int VTDLY;\n+    private static int VT0;\n+    private static int VT1;\n+    private static int CBAUD;\n+    private static int B0;\n+    private static int B50;\n+    private static int B75;\n+    private static int B110;\n+    private static int B134;\n+    private static int B150;\n+    private static int B200;\n+    private static int B300;\n+    private static int B600;\n+    private static int B1200;\n+    private static int B1800;\n+    private static int B2400;\n+    private static int B4800;\n+    private static int B9600;\n+    private static int B19200;\n+    private static int B38400;\n+    private static int EXTA;\n+    private static int EXTB;\n+    private static int OFDEL;\n+    private static int ONOEOT;\n+    private static final int OCRNL;\n+    private static int ONOCR;\n+    private static final int ONLRET;\n+    private static int OFILL;\n+\n+    private static int CIGNORE;\n+    private static int CSIZE;\n+    private static final int CS5;\n+    private static final int CS6;\n+    private static final int CS7;\n+    private static final int CS8;\n+    private static final int CSTOPB;\n+    private static final int CREAD;\n+    private static final int PARENB;\n+    private static final int PARODD;\n+    private static final int HUPCL;\n+    private static final int CLOCAL;\n+    private static int CCTS_OFLOW;\n+    private static int CRTS_IFLOW;\n+    private static int CDTR_IFLOW;\n+    private static int CDSR_OFLOW;\n+    private static int CCAR_OFLOW;\n+\n+    private static final int ECHOKE;\n+    private static final int ECHOE;\n+    private static final int ECHOK;\n+    private static final int ECHO;\n+    private static final int ECHONL;\n+    private static final int ECHOPRT;\n+    private static final int ECHOCTL;\n+    private static final int ISIG;\n+    private static final int ICANON;\n+    private static int XCASE;\n+    private static int ALTWERASE;\n+    private static final int IEXTEN;\n+    private static final int EXTPROC;\n+    private static final int TOSTOP;\n+    private static final int FLUSHO;\n+    private static int NOKERNINFO;\n+    private static final int PENDIN;\n+    private static final int NOFLSH;\n+\n+    static {\n+        String osName = System.getProperty(\"os.name\");\n+        if (osName.startsWith(\"Linux\")) {\n+            String arch = System.getProperty(\"os.arch\");\n+            boolean isMipsPpcOrSparc = arch.equals(\"mips\")\n+                    || arch.equals(\"mips64\")\n+                    || arch.equals(\"mipsel\")\n+                    || arch.equals(\"mips64el\")\n+                    || arch.startsWith(\"ppc\")\n+                    || arch.startsWith(\"sparc\");\n+            TIOCGWINSZ = isMipsPpcOrSparc ? 0x40087468 : 0x00005413;\n+            TIOCSWINSZ = isMipsPpcOrSparc ? 0x80087467 : 0x00005414;\n+\n+            TCSANOW = 0x0;\n+            TCSADRAIN = 0x1;\n+            TCSAFLUSH = 0x2;\n+\n+            VINTR = 0;\n+            VQUIT = 1;\n+            VERASE = 2;\n+            VKILL = 3;\n+            VEOF = 4;\n+            VTIME = 5;\n+            VMIN = 6;\n+            VSWTC = 7;\n+            VSTART = 8;\n+            VSTOP = 9;\n+            VSUSP = 10;\n+            VEOL = 11;\n+            VREPRINT = 12;\n+            VDISCARD = 13;\n+            VWERASE = 14;\n+            VLNEXT = 15;\n+            VEOL2 = 16;\n+            VERASE2 = -1;\n+            VDSUSP = -1;\n+            VSTATUS = -1;\n+\n+            IGNBRK = 0x0000001;\n+            BRKINT = 0x0000002;\n+            IGNPAR = 0x0000004;\n+            PARMRK = 0x0000008;\n+            INPCK = 0x0000010;\n+            ISTRIP = 0x0000020;\n+            INLCR = 0x0000040;\n+            IGNCR = 0x0000080;\n+            ICRNL = 0x0000100;\n+            IUCLC = 0x0000200;\n+            IXON = 0x0000400;\n+            IXANY = 0x0000800;\n+            IXOFF = 0x0001000;\n+            IMAXBEL = 0x0002000;\n+            IUTF8 = 0x0004000;\n+\n+            OPOST = 0x0000001;\n+            OLCUC = 0x0000002;\n+            ONLCR = 0x0000004;\n+            OCRNL = 0x0000008;\n+            ONOCR = 0x0000010;\n+            ONLRET = 0x0000020;\n+            OFILL = 0x0000040;\n+            OFDEL = 0x0000080;\n+            NLDLY = 0x0000100;\n+            NL0 = 0x0000000;\n+            NL1 = 0x0000100;\n+            CRDLY = 0x0000600;\n+            CR0 = 0x0000000;\n+            CR1 = 0x0000200;\n+            CR2 = 0x0000400;\n+            CR3 = 0x0000600;\n+            TABDLY = 0x0001800;\n+            TAB0 = 0x0000000;\n+            TAB1 = 0x0000800;\n+            TAB2 = 0x0001000;\n+            TAB3 = 0x0001800;\n+            XTABS = 0x0001800;\n+            BSDLY = 0x0002000;\n+            BS0 = 0x0000000;\n+            BS1 = 0x0002000;\n+            VTDLY = 0x0004000;\n+            VT0 = 0x0000000;\n+            VT1 = 0x0004000;\n+            FFDLY = 0x0008000;\n+            FF0 = 0x0000000;\n+            FF1 = 0x0008000;\n+\n+            CBAUD = 0x000100f;\n+            B0 = 0x0000000;\n+            B50 = 0x0000001;\n+            B75 = 0x0000002;\n+            B110 = 0x0000003;\n+            B134 = 0x0000004;\n+            B150 = 0x0000005;\n+            B200 = 0x0000006;\n+            B300 = 0x0000007;\n+            B600 = 0x0000008;\n+            B1200 = 0x0000009;\n+            B1800 = 0x000000a;\n+            B2400 = 0x000000b;\n+            B4800 = 0x000000c;\n+            B9600 = 0x000000d;\n+            B19200 = 0x000000e;\n+            B38400 = 0x000000f;\n+            EXTA = B19200;\n+            EXTB = B38400;\n+            CSIZE = 0x0000030;\n+            CS5 = 0x0000000;\n+            CS6 = 0x0000010;\n+            CS7 = 0x0000020;\n+            CS8 = 0x0000030;\n+            CSTOPB = 0x0000040;\n+            CREAD = 0x0000080;\n+            PARENB = 0x0000100;\n+            PARODD = 0x0000200;\n+            HUPCL = 0x0000400;\n+            CLOCAL = 0x0000800;\n+\n+            ISIG = 0x0000001;\n+            ICANON = 0x0000002;\n+            XCASE = 0x0000004;\n+            ECHO = 0x0000008;\n+            ECHOE = 0x0000010;\n+            ECHOK = 0x0000020;\n+            ECHONL = 0x0000040;\n+            NOFLSH = 0x0000080;\n+            TOSTOP = 0x0000100;\n+            ECHOCTL = 0x0000200;\n+            ECHOPRT = 0x0000400;\n+            ECHOKE = 0x0000800;\n+            FLUSHO = 0x0001000;\n+            PENDIN = 0x0002000;\n+            IEXTEN = 0x0008000;\n+            EXTPROC = 0x0010000;\n+        } else if (osName.startsWith(\"Solaris\") || osName.startsWith(\"SunOS\")) {\n+            int _TIOC = ('T' << 8);\n+            TIOCGWINSZ = (_TIOC | 104);\n+            TIOCSWINSZ = (_TIOC | 103);\n+\n+            TCSANOW = 0x0;\n+            TCSADRAIN = 0x1;\n+            TCSAFLUSH = 0x2;\n+\n+            VINTR = 0;\n+            VQUIT = 1;\n+            VERASE = 2;\n+            VKILL = 3;\n+            VEOF = 4;\n+            VTIME = 5;\n+            VMIN = 6;\n+            VSWTC = 7;\n+            VSTART = 8;\n+            VSTOP = 9;\n+            VSUSP = 10;\n+            VEOL = 11;\n+            VREPRINT = 12;\n+            VDISCARD = 13;\n+            VWERASE = 14;\n+            VLNEXT = 15;\n+            VEOL2 = 16;\n+            VERASE2 = -1;\n+            VDSUSP = -1;\n+            VSTATUS = -1;\n+\n+            IGNBRK = 0x0000001;\n+            BRKINT = 0x0000002;\n+            IGNPAR = 0x0000004;\n+            PARMRK = 0x0000010;\n+            INPCK = 0x0000020;\n+            ISTRIP = 0x0000040;\n+            INLCR = 0x0000100;\n+            IGNCR = 0x0000200;\n+            ICRNL = 0x0000400;\n+            IUCLC = 0x0001000;\n+            IXON = 0x0002000;\n+            IXANY = 0x0004000;\n+            IXOFF = 0x0010000;\n+            IMAXBEL = 0x0020000;\n+            IUTF8 = 0x0040000;\n+\n+            OPOST = 0x0000001;\n+            OLCUC = 0x0000002;\n+            ONLCR = 0x0000004;\n+            OCRNL = 0x0000010;\n+            ONOCR = 0x0000020;\n+            ONLRET = 0x0000040;\n+            OFILL = 0x0000100;\n+            OFDEL = 0x0000200;\n+            NLDLY = 0x0000400;\n+            NL0 = 0x0000000;\n+            NL1 = 0x0000400;\n+            CRDLY = 0x0003000;\n+            CR0 = 0x0000000;\n+            CR1 = 0x0001000;\n+            CR2 = 0x0002000;\n+            CR3 = 0x0003000;\n+            TABDLY = 0x0014000;\n+            TAB0 = 0x0000000;\n+            TAB1 = 0x0004000;\n+            TAB2 = 0x0010000;\n+            TAB3 = 0x0014000;\n+            XTABS = 0x0014000;\n+            BSDLY = 0x0020000;\n+            BS0 = 0x0000000;\n+            BS1 = 0x0020000;\n+            VTDLY = 0x0040000;\n+            VT0 = 0x0000000;\n+            VT1 = 0x0040000;\n+            FFDLY = 0x0100000;\n+            FF0 = 0x0000000;\n+            FF1 = 0x0100000;\n+\n+            CBAUD = 0x0010017;\n+            B0 = 0x0000000;\n+            B50 = 0x0000001;\n+            B75 = 0x0000002;\n+            B110 = 0x0000003;\n+            B134 = 0x0000004;\n+            B150 = 0x0000005;\n+            B200 = 0x0000006;\n+            B300 = 0x0000007;\n+            B600 = 0x0000010;\n+            B1200 = 0x0000011;\n+            B1800 = 0x0000012;\n+            B2400 = 0x0000013;\n+            B4800 = 0x0000014;\n+            B9600 = 0x0000015;\n+            B19200 = 0x0000016;\n+            B38400 = 0x0000017;\n+            EXTA = 0xB19200;\n+            EXTB = 0xB38400;\n+            CSIZE = 0x0000060;\n+            CS5 = 0x0000000;\n+            CS6 = 0x0000020;\n+            CS7 = 0x0000040;\n+            CS8 = 0x0000060;\n+            CSTOPB = 0x0000100;\n+            CREAD = 0x0000200;\n+            PARENB = 0x0000400;\n+            PARODD = 0x0001000;\n+            HUPCL = 0x0002000;\n+            CLOCAL = 0x0004000;\n+\n+            ISIG = 0x0000001;\n+            ICANON = 0x0000002;\n+            XCASE = 0x0000004;\n+            ECHO = 0x0000010;\n+            ECHOE = 0x0000020;\n+            ECHOK = 0x0000040;\n+            ECHONL = 0x0000100;\n+            NOFLSH = 0x0000200;\n+            TOSTOP = 0x0000400;\n+            ECHOCTL = 0x0001000;\n+            ECHOPRT = 0x0002000;\n+            ECHOKE = 0x0004000;\n+            FLUSHO = 0x0010000;\n+            PENDIN = 0x0040000;\n+            IEXTEN = 0x0100000;\n+            EXTPROC = 0x0200000;\n+        } else if (osName.startsWith(\"Mac\") || osName.startsWith(\"Darwin\")) {\n+            TIOCGWINSZ = 0x40087468;\n+            TIOCSWINSZ = 0x80087467;\n+\n+            TCSANOW = 0x00000000;\n+\n+            VEOF = 0;\n+            VEOL = 1;\n+            VEOL2 = 2;\n+            VERASE = 3;\n+            VWERASE = 4;\n+            VKILL = 5;\n+            VREPRINT = 6;\n+            VINTR = 8;\n+            VQUIT = 9;\n+            VSUSP = 10;\n+            VDSUSP = 11;\n+            VSTART = 12;\n+            VSTOP = 13;\n+            VLNEXT = 14;\n+            VDISCARD = 15;\n+            VMIN = 16;\n+            VTIME = 17;\n+            VSTATUS = 18;\n+            VERASE2 = -1;\n+            VSWTC = -1;\n+\n+            IGNBRK = 0x00000001;\n+            BRKINT = 0x00000002;\n+            IGNPAR = 0x00000004;\n+            PARMRK = 0x00000008;\n+            INPCK = 0x00000010;\n+            ISTRIP = 0x00000020;\n+            INLCR = 0x00000040;\n+            IGNCR = 0x00000080;\n+            ICRNL = 0x00000100;\n+            IXON = 0x00000200;\n+            IXOFF = 0x00000400;\n+            IXANY = 0x00000800;\n+            IMAXBEL = 0x00002000;\n+            IUTF8 = 0x00004000;\n+\n+            OPOST = 0x00000001;\n+            ONLCR = 0x00000002;\n+            OXTABS = 0x00000004;\n+            ONOEOT = 0x00000008;\n+            OCRNL = 0x00000010;\n+            ONOCR = 0x00000020;\n+            ONLRET = 0x00000040;\n+            OFILL = 0x00000080;\n+            NLDLY = 0x00000300;\n+            TABDLY = 0x00000c04;\n+            CRDLY = 0x00003000;\n+            FFDLY = 0x00004000;\n+            BSDLY = 0x00008000;\n+            VTDLY = 0x00010000;\n+            OFDEL = 0x00020000;\n+\n+            CIGNORE = 0x00000001;\n+            CS5 = 0x00000000;\n+            CS6 = 0x00000100;\n+            CS7 = 0x00000200;\n+            CS8 = 0x00000300;\n+            CSTOPB = 0x00000400;\n+            CREAD = 0x00000800;\n+            PARENB = 0x00001000;\n+            PARODD = 0x00002000;\n+            HUPCL = 0x00004000;\n+            CLOCAL = 0x00008000;\n+            CCTS_OFLOW = 0x00010000;\n+            CRTS_IFLOW = 0x00020000;\n+            CDTR_IFLOW = 0x00040000;\n+            CDSR_OFLOW = 0x00080000;\n+            CCAR_OFLOW = 0x00100000;\n+\n+            ECHOKE = 0x00000001;\n+            ECHOE = 0x00000002;\n+            ECHOK = 0x00000004;\n+            ECHO = 0x00000008;\n+            ECHONL = 0x00000010;\n+            ECHOPRT = 0x00000020;\n+            ECHOCTL = 0x00000040;\n+            ISIG = 0x00000080;\n+            ICANON = 0x00000100;\n+            ALTWERASE = 0x00000200;\n+            IEXTEN = 0x00000400;\n+            EXTPROC = 0x00000800;\n+            TOSTOP = 0x00400000;\n+            FLUSHO = 0x00800000;\n+            NOKERNINFO = 0x02000000;\n+            PENDIN = 0x20000000;\n+            NOFLSH = 0x80000000;\n+        } else if (osName.startsWith(\"FreeBSD\")) {\n+            TIOCGWINSZ = 0x40087468;\n+            TIOCSWINSZ = 0x80087467;\n+\n+            TCSANOW = 0x0;\n+            TCSADRAIN = 0x1;\n+            TCSAFLUSH = 0x2;\n+\n+            VEOF = 0;\n+            VEOL = 1;\n+            VEOL2 = 2;\n+            VERASE = 3;\n+            VWERASE = 4;\n+            VKILL = 5;\n+            VREPRINT = 6;\n+            VERASE2 = 7;\n+            VINTR = 8;\n+            VQUIT = 9;\n+            VSUSP = 10;\n+            VDSUSP = 11;\n+            VSTART = 12;\n+            VSTOP = 13;\n+            VLNEXT = 14;\n+            VDISCARD = 15;\n+            VMIN = 16;\n+            VTIME = 17;\n+            VSTATUS = 18;\n+            VSWTC = -1;\n+\n+            IGNBRK = 0x0000001;\n+            BRKINT = 0x0000002;\n+            IGNPAR = 0x0000004;\n+            PARMRK = 0x0000008;\n+            INPCK = 0x0000010;\n+            ISTRIP = 0x0000020;\n+            INLCR = 0x0000040;\n+            IGNCR = 0x0000080;\n+            ICRNL = 0x0000100;\n+            IXON = 0x0000200;\n+            IXOFF = 0x0000400;\n+            IXANY = 0x0000800;\n+            IMAXBEL = 0x0002000;\n+\n+            OPOST = 0x0000001;\n+            ONLCR = 0x0000002;\n+            TABDLY = 0x0000004;\n+            TAB0 = 0x0000000;\n+            TAB3 = 0x0000004;\n+            ONOEOT = 0x0000008;\n+            OCRNL = 0x0000010;\n+            ONLRET = 0x0000040;\n+\n+            CIGNORE = 0x0000001;\n+            CSIZE = 0x0000300;\n+            CS5 = 0x0000000;\n+            CS6 = 0x0000100;\n+            CS7 = 0x0000200;\n+            CS8 = 0x0000300;\n+            CSTOPB = 0x0000400;\n+            CREAD = 0x0000800;\n+            PARENB = 0x0001000;\n+            PARODD = 0x0002000;\n+            HUPCL = 0x0004000;\n+            CLOCAL = 0x0008000;\n+\n+            ECHOKE = 0x0000001;\n+            ECHOE = 0x0000002;\n+            ECHOK = 0x0000004;\n+            ECHO = 0x0000008;\n+            ECHONL = 0x0000010;\n+            ECHOPRT = 0x0000020;\n+            ECHOCTL = 0x0000040;\n+            ISIG = 0x0000080;\n+            ICANON = 0x0000100;\n+            ALTWERASE = 0x000200;\n+            IEXTEN = 0x0000400;\n+            EXTPROC = 0x0000800;\n+            TOSTOP = 0x0400000;\n+            FLUSHO = 0x0800000;\n+            PENDIN = 0x2000000;\n+            NOFLSH = 0x8000000;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/CLibrary.java","additions":1170,"deletions":0,"binary":false,"changes":1170,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.AbstractPty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+\n+class FfmNativePty extends AbstractPty {\n+    private final int master;\n+    private final int slave;\n+    private final int slaveOut;\n+    private final String name;\n+    private final FileDescriptor masterFD;\n+    private final FileDescriptor slaveFD;\n+    private final FileDescriptor slaveOutFD;\n+\n+    public FfmNativePty(TerminalProvider provider, SystemStream systemStream, int master, int slave, String name) {\n+        this(\n+                provider,\n+                systemStream,\n+                master,\n+                newDescriptor(master),\n+                slave,\n+                newDescriptor(slave),\n+                slave,\n+                newDescriptor(slave),\n+                name);\n+    }\n+\n+    public FfmNativePty(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            int master,\n+            FileDescriptor masterFD,\n+            int slave,\n+            FileDescriptor slaveFD,\n+            int slaveOut,\n+            FileDescriptor slaveOutFD,\n+            String name) {\n+        super(provider, systemStream);\n+        this.master = master;\n+        this.slave = slave;\n+        this.slaveOut = slaveOut;\n+        this.name = name;\n+        this.masterFD = masterFD;\n+        this.slaveFD = slaveFD;\n+        this.slaveOutFD = slaveOutFD;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (master > 0) {\n+            getMasterInput().close();\n+        }\n+        if (slave > 0) {\n+            getSlaveInput().close();\n+        }\n+    }\n+\n+    public int getMaster() {\n+        return master;\n+    }\n+\n+    public int getSlave() {\n+        return slave;\n+    }\n+\n+    public int getSlaveOut() {\n+        return slaveOut;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public FileDescriptor getMasterFD() {\n+        return masterFD;\n+    }\n+\n+    public FileDescriptor getSlaveFD() {\n+        return slaveFD;\n+    }\n+\n+    public FileDescriptor getSlaveOutFD() {\n+        return slaveOutFD;\n+    }\n+\n+    public InputStream getMasterInput() {\n+        return new FileInputStream(getMasterFD());\n+    }\n+\n+    public OutputStream getMasterOutput() {\n+        return new FileOutputStream(getMasterFD());\n+    }\n+\n+    protected InputStream doGetSlaveInput() {\n+        return new FileInputStream(getSlaveFD());\n+    }\n+\n+    public OutputStream getSlaveOutput() {\n+        return new FileOutputStream(getSlaveOutFD());\n+    }\n+\n+    @Override\n+    public Attributes getAttr() throws IOException {\n+        return CLibrary.getAttributes(slave);\n+    }\n+\n+    @Override\n+    protected void doSetAttr(Attributes attr) throws IOException {\n+        CLibrary.setAttributes(slave, attr);\n+    }\n+\n+    @Override\n+    public Size getSize() throws IOException {\n+        return CLibrary.getTerminalSize(slave);\n+    }\n+\n+    @Override\n+    public void setSize(Size size) throws IOException {\n+        CLibrary.setTerminalSize(slave, size);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"FfmNativePty[\" + getName() + \"]\";\n+    }\n+\n+    public static boolean isPosixSystemStream(SystemStream stream) {\n+        switch (stream) {\n+            case Input:\n+                return CLibrary.isTty(0);\n+            case Output:\n+                return CLibrary.isTty(1);\n+            case Error:\n+                return CLibrary.isTty(2);\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public static String posixSystemStreamName(SystemStream stream) {\n+        switch (stream) {\n+            case Input:\n+                return CLibrary.ttyName(0);\n+            case Output:\n+                return CLibrary.ttyName(1);\n+            case Error:\n+                return CLibrary.ttyName(2);\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public static int systemStreamWidth(SystemStream systemStream) {\n+        int fd = systemStream == SystemStream.Output ? 1 : 2;\n+        return CLibrary.getTerminalSize(fd).getColumns();\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/FfmNativePty.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.TerminalBuilder;\n+import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class FfmTerminalProvider implements TerminalProvider {\n+\n+    public FfmTerminalProvider() {\n+        if (!FfmTerminalProvider.class.getModule().isNativeAccessEnabled()) {\n+            throw new UnsupportedOperationException(\n+                    \"Native access is not enabled for the current module: \" + FfmTerminalProvider.class.getModule());\n+        }\n+    }\n+\n+    @Override\n+    public String name() {\n+        return TerminalBuilder.PROP_PROVIDER_FFM;\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return NativeWinSysTerminal.createTerminal(\n+                    this, systemStream, name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, inputStreamWrapper);\n+        } else {\n+            Pty pty = new FfmNativePty(\n+                    this,\n+                    systemStream,\n+                    -1,\n+                    null,\n+                    0,\n+                    FileDescriptor.in,\n+                    systemStream == SystemStream.Output ? 1 : 2,\n+                    systemStream == SystemStream.Output ? FileDescriptor.out : FileDescriptor.err,\n+                    CLibrary.ttyName(0));\n+            return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+        }\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream in,\n+            OutputStream out,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException {\n+        Pty pty = CLibrary.openpty(this, attributes, size);\n+        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(SystemStream stream) {\n+        if (OSUtils.IS_WINDOWS) {\n+            return isWindowsSystemStream(stream);\n+        } else {\n+            return isPosixSystemStream(stream);\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(SystemStream stream) {\n+        return NativeWinSysTerminal.isWindowsSystemStream(stream);\n+    }\n+\n+    public boolean isPosixSystemStream(SystemStream stream) {\n+        return FfmNativePty.isPosixSystemStream(stream);\n+    }\n+\n+    @Override\n+    public String systemStreamName(SystemStream stream) {\n+        return FfmNativePty.posixSystemStreamName(stream);\n+    }\n+\n+    @Override\n+    public int systemStreamWidth(SystemStream stream) {\n+        return FfmNativePty.systemStreamWidth(stream);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TerminalProvider[\" + name() + \"]\";\n+    }\n+\n+    static VarHandle lookupVarHandle(MemoryLayout layout, PathElement... element) {\n+        VarHandle h = layout.varHandle(element);\n+\n+        \/\/ the last parameter of the VarHandle is additional offset, hardcode zero:\n+        h = MethodHandles.insertCoordinates(h, h.coordinateTypes().size() - 1, 0L);\n+\n+        return h;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/FfmTerminalProvider.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,927 @@\n+\/*\n+ * Copyright (c) 2009-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+\n+@SuppressWarnings({\"unused\", \"restricted\"})\n+final class Kernel32 {\n+\n+    public static final int FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000;\n+\n+    public static final int INVALID_HANDLE_VALUE = -1;\n+    public static final int STD_INPUT_HANDLE = -10;\n+    public static final int STD_OUTPUT_HANDLE = -11;\n+    public static final int STD_ERROR_HANDLE = -12;\n+\n+    public static final int ENABLE_PROCESSED_INPUT = 0x0001;\n+    public static final int ENABLE_LINE_INPUT = 0x0002;\n+    public static final int ENABLE_ECHO_INPUT = 0x0004;\n+    public static final int ENABLE_WINDOW_INPUT = 0x0008;\n+    public static final int ENABLE_MOUSE_INPUT = 0x0010;\n+    public static final int ENABLE_INSERT_MODE = 0x0020;\n+    public static final int ENABLE_QUICK_EDIT_MODE = 0x0040;\n+    public static final int ENABLE_EXTENDED_FLAGS = 0x0080;\n+\n+    public static final int RIGHT_ALT_PRESSED = 0x0001;\n+    public static final int LEFT_ALT_PRESSED = 0x0002;\n+    public static final int RIGHT_CTRL_PRESSED = 0x0004;\n+    public static final int LEFT_CTRL_PRESSED = 0x0008;\n+    public static final int SHIFT_PRESSED = 0x0010;\n+\n+    public static final int FOREGROUND_BLUE = 0x0001;\n+    public static final int FOREGROUND_GREEN = 0x0002;\n+    public static final int FOREGROUND_RED = 0x0004;\n+    public static final int FOREGROUND_INTENSITY = 0x0008;\n+    public static final int BACKGROUND_BLUE = 0x0010;\n+    public static final int BACKGROUND_GREEN = 0x0020;\n+    public static final int BACKGROUND_RED = 0x0040;\n+    public static final int BACKGROUND_INTENSITY = 0x0080;\n+\n+    \/\/ Button state\n+    public static final int FROM_LEFT_1ST_BUTTON_PRESSED = 0x0001;\n+    public static final int RIGHTMOST_BUTTON_PRESSED = 0x0002;\n+    public static final int FROM_LEFT_2ND_BUTTON_PRESSED = 0x0004;\n+    public static final int FROM_LEFT_3RD_BUTTON_PRESSED = 0x0008;\n+    public static final int FROM_LEFT_4TH_BUTTON_PRESSED = 0x0010;\n+\n+    \/\/ Event flags\n+    public static final int MOUSE_MOVED = 0x0001;\n+    public static final int DOUBLE_CLICK = 0x0002;\n+    public static final int MOUSE_WHEELED = 0x0004;\n+    public static final int MOUSE_HWHEELED = 0x0008;\n+\n+    \/\/ Event types\n+    public static final short KEY_EVENT = 0x0001;\n+    public static final short MOUSE_EVENT = 0x0002;\n+    public static final short WINDOW_BUFFER_SIZE_EVENT = 0x0004;\n+    public static final short MENU_EVENT = 0x0008;\n+    public static final short FOCUS_EVENT = 0x0010;\n+\n+    public static int WaitForSingleObject(java.lang.foreign.MemorySegment hHandle, int dwMilliseconds) {\n+        MethodHandle mh$ = requireNonNull(WaitForSingleObject$MH, \"WaitForSingleObject\");\n+        try {\n+            return (int) mh$.invokeExact(hHandle, dwMilliseconds);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static java.lang.foreign.MemorySegment GetStdHandle(int nStdHandle) {\n+        MethodHandle mh$ = requireNonNull(GetStdHandle$MH, \"GetStdHandle\");\n+        try {\n+            return (java.lang.foreign.MemorySegment) mh$.invokeExact(nStdHandle);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int FormatMessageW(\n+            int dwFlags,\n+            java.lang.foreign.MemorySegment lpSource,\n+            int dwMessageId,\n+            int dwLanguageId,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nSize,\n+            java.lang.foreign.MemorySegment Arguments) {\n+        MethodHandle mh$ = requireNonNull(FormatMessageW$MH, \"FormatMessageW\");\n+        try {\n+            return (int) mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleTextAttribute(java.lang.foreign.MemorySegment hConsoleOutput, short wAttributes) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleTextAttribute$MH, \"SetConsoleTextAttribute\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, wAttributes);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleMode(java.lang.foreign.MemorySegment hConsoleHandle, int dwMode) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleMode$MH, \"SetConsoleMode\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleHandle, dwMode);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetConsoleMode(\n+            java.lang.foreign.MemorySegment hConsoleHandle, java.lang.foreign.MemorySegment lpMode) {\n+        MethodHandle mh$ = requireNonNull(GetConsoleMode$MH, \"GetConsoleMode\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleHandle, lpMode);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleTitleW(java.lang.foreign.MemorySegment lpConsoleTitle) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleTitleW$MH, \"SetConsoleTitleW\");\n+        try {\n+            return (int) mh$.invokeExact(lpConsoleTitle);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int SetConsoleCursorPosition(java.lang.foreign.MemorySegment hConsoleOutput, COORD dwCursorPosition) {\n+        MethodHandle mh$ = requireNonNull(SetConsoleCursorPosition$MH, \"SetConsoleCursorPosition\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, dwCursorPosition.seg);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int FillConsoleOutputCharacterW(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            char cCharacter,\n+            int nLength,\n+            COORD dwWriteCoord,\n+            java.lang.foreign.MemorySegment lpNumberOfCharsWritten) {\n+        MethodHandle mh$ = requireNonNull(FillConsoleOutputCharacterW$MH, \"FillConsoleOutputCharacterW\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord.seg, lpNumberOfCharsWritten);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int FillConsoleOutputAttribute(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            short wAttribute,\n+            int nLength,\n+            COORD dwWriteCoord,\n+            java.lang.foreign.MemorySegment lpNumberOfAttrsWritten) {\n+        MethodHandle mh$ = requireNonNull(FillConsoleOutputAttribute$MH, \"FillConsoleOutputAttribute\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, wAttribute, nLength, dwWriteCoord.seg, lpNumberOfAttrsWritten);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int WriteConsoleW(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nNumberOfCharsToWrite,\n+            java.lang.foreign.MemorySegment lpNumberOfCharsWritten,\n+            java.lang.foreign.MemorySegment lpReserved) {\n+        MethodHandle mh$ = requireNonNull(WriteConsoleW$MH, \"WriteConsoleW\");\n+        try {\n+            return (int) mh$.invokeExact(\n+                    hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int ReadConsoleInputW(\n+            java.lang.foreign.MemorySegment hConsoleInput,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nLength,\n+            java.lang.foreign.MemorySegment lpNumberOfEventsRead) {\n+        MethodHandle mh$ = requireNonNull(ReadConsoleInputW$MH, \"ReadConsoleInputW\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int PeekConsoleInputW(\n+            java.lang.foreign.MemorySegment hConsoleInput,\n+            java.lang.foreign.MemorySegment lpBuffer,\n+            int nLength,\n+            java.lang.foreign.MemorySegment lpNumberOfEventsRead) {\n+        MethodHandle mh$ = requireNonNull(PeekConsoleInputW$MH, \"PeekConsoleInputW\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetConsoleScreenBufferInfo(\n+            java.lang.foreign.MemorySegment hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo) {\n+        MethodHandle mh$ = requireNonNull(GetConsoleScreenBufferInfo$MH, \"GetConsoleScreenBufferInfo\");\n+        try {\n+            return (int) mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfo.seg);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int ScrollConsoleScreenBuffer(\n+            java.lang.foreign.MemorySegment hConsoleOutput,\n+            SMALL_RECT lpScrollRectangle,\n+            SMALL_RECT lpClipRectangle,\n+            COORD dwDestinationOrigin,\n+            CHAR_INFO lpFill) {\n+        MethodHandle mh$ = requireNonNull(ScrollConsoleScreenBufferW$MH, \"ScrollConsoleScreenBuffer\");\n+        try {\n+            return (int)\n+                    mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetLastError() {\n+        MethodHandle mh$ = requireNonNull(GetLastError$MH, \"GetLastError\");\n+        try {\n+            return (int) mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static int GetFileType(java.lang.foreign.MemorySegment hFile) {\n+        MethodHandle mh$ = requireNonNull(GetFileType$MH, \"GetFileType\");\n+        try {\n+            return (int) mh$.invokeExact(hFile);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static java.lang.foreign.MemorySegment _get_osfhandle(int fd) {\n+        MethodHandle mh$ = requireNonNull(_get_osfhandle$MH, \"_get_osfhandle\");\n+        try {\n+            return (java.lang.foreign.MemorySegment) mh$.invokeExact(fd);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    public static INPUT_RECORD[] readConsoleInputHelper(java.lang.foreign.MemorySegment handle, int count, boolean peek)\n+            throws IOException {\n+        return readConsoleInputHelper(java.lang.foreign.Arena.ofAuto(), handle, count, peek);\n+    }\n+\n+    public static INPUT_RECORD[] readConsoleInputHelper(\n+            java.lang.foreign.Arena arena, java.lang.foreign.MemorySegment handle, int count, boolean peek)\n+            throws IOException {\n+        java.lang.foreign.MemorySegment inputRecordPtr = arena.allocate(INPUT_RECORD.LAYOUT, count);\n+        java.lang.foreign.MemorySegment length = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT, 1);\n+        int res = peek\n+                ? PeekConsoleInputW(handle, inputRecordPtr, count, length)\n+                : ReadConsoleInputW(handle, inputRecordPtr, count, length);\n+        if (res == 0) {\n+            throw new IOException(\"ReadConsoleInputW failed: \" + getLastErrorMessage());\n+        }\n+        int len = length.get(java.lang.foreign.ValueLayout.JAVA_INT, 0);\n+        return inputRecordPtr\n+                .elements(INPUT_RECORD.LAYOUT)\n+                .map(INPUT_RECORD::new)\n+                .limit(len)\n+                .toArray(INPUT_RECORD[]::new);\n+    }\n+\n+    public static String getLastErrorMessage() {\n+        int errorCode = GetLastError();\n+        return getErrorMessage(errorCode);\n+    }\n+\n+    public static String getErrorMessage(int errorCode) {\n+        int bufferSize = 160;\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment data = arena.allocate(bufferSize);\n+            FormatMessageW(\n+                    FORMAT_MESSAGE_FROM_SYSTEM,\n+                    java.lang.foreign.MemorySegment.NULL,\n+                    errorCode,\n+                    0,\n+                    data,\n+                    bufferSize,\n+                    java.lang.foreign.MemorySegment.NULL);\n+            return new String(data.toArray(java.lang.foreign.ValueLayout.JAVA_BYTE), StandardCharsets.UTF_16LE).trim();\n+        }\n+    }\n+\n+    private static final java.lang.foreign.SymbolLookup SYMBOL_LOOKUP;\n+\n+    static {\n+        System.loadLibrary(\"msvcrt\");\n+        System.loadLibrary(\"Kernel32\");\n+        SYMBOL_LOOKUP = java.lang.foreign.SymbolLookup.loaderLookup();\n+    }\n+\n+    static MethodHandle downcallHandle(String name, java.lang.foreign.FunctionDescriptor fdesc) {\n+        return SYMBOL_LOOKUP\n+                .find(name)\n+                .map(addr -> java.lang.foreign.Linker.nativeLinker().downcallHandle(addr, fdesc))\n+                .orElse(null);\n+    }\n+\n+    static final java.lang.foreign.ValueLayout.OfBoolean C_BOOL$LAYOUT = java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+    static final java.lang.foreign.ValueLayout.OfByte C_CHAR$LAYOUT = java.lang.foreign.ValueLayout.JAVA_BYTE;\n+    static final java.lang.foreign.ValueLayout.OfChar C_WCHAR$LAYOUT = java.lang.foreign.ValueLayout.JAVA_CHAR;\n+    static final java.lang.foreign.ValueLayout.OfShort C_SHORT$LAYOUT = java.lang.foreign.ValueLayout.JAVA_SHORT;\n+    static final java.lang.foreign.ValueLayout.OfShort C_WORD$LAYOUT = java.lang.foreign.ValueLayout.JAVA_SHORT;\n+    static final java.lang.foreign.ValueLayout.OfInt C_DWORD$LAYOUT = java.lang.foreign.ValueLayout.JAVA_INT;\n+    static final java.lang.foreign.ValueLayout.OfInt C_INT$LAYOUT = java.lang.foreign.ValueLayout.JAVA_INT;\n+    static final java.lang.foreign.ValueLayout.OfLong C_LONG$LAYOUT = java.lang.foreign.ValueLayout.JAVA_LONG;\n+    static final java.lang.foreign.ValueLayout.OfLong C_LONG_LONG$LAYOUT = java.lang.foreign.ValueLayout.JAVA_LONG;\n+    static final java.lang.foreign.ValueLayout.OfFloat C_FLOAT$LAYOUT = java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+    static final java.lang.foreign.ValueLayout.OfDouble C_DOUBLE$LAYOUT = java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+    static final java.lang.foreign.AddressLayout C_POINTER$LAYOUT = java.lang.foreign.ValueLayout.ADDRESS;\n+\n+    static final MethodHandle WaitForSingleObject$MH = downcallHandle(\n+            \"WaitForSingleObject\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT));\n+    static final MethodHandle GetStdHandle$MH =\n+            downcallHandle(\"GetStdHandle\", java.lang.foreign.FunctionDescriptor.of(C_POINTER$LAYOUT, C_INT$LAYOUT));\n+    static final MethodHandle FormatMessageW$MH = downcallHandle(\n+            \"FormatMessageW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT));\n+    static final MethodHandle SetConsoleTextAttribute$MH = downcallHandle(\n+            \"SetConsoleTextAttribute\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_SHORT$LAYOUT));\n+    static final MethodHandle SetConsoleMode$MH = downcallHandle(\n+            \"SetConsoleMode\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT));\n+    static final MethodHandle GetConsoleMode$MH = downcallHandle(\n+            \"GetConsoleMode\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT));\n+\n+    static final MethodHandle SetConsoleTitleW$MH =\n+            downcallHandle(\"SetConsoleTitleW\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle SetConsoleCursorPosition$MH = downcallHandle(\n+            \"SetConsoleCursorPosition\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, COORD.LAYOUT));\n+    static final MethodHandle FillConsoleOutputCharacterW$MH = downcallHandle(\n+            \"FillConsoleOutputCharacterW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_WCHAR$LAYOUT, C_INT$LAYOUT, COORD.LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle FillConsoleOutputAttribute$MH = downcallHandle(\n+            \"FillConsoleOutputAttribute\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_SHORT$LAYOUT, C_INT$LAYOUT, COORD.LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle WriteConsoleW$MH = downcallHandle(\n+            \"WriteConsoleW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT));\n+\n+    static final MethodHandle ReadConsoleInputW$MH = downcallHandle(\n+            \"ReadConsoleInputW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle PeekConsoleInputW$MH = downcallHandle(\n+            \"PeekConsoleInputW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT, C_INT$LAYOUT, C_POINTER$LAYOUT));\n+\n+    static final MethodHandle GetConsoleScreenBufferInfo$MH = downcallHandle(\n+            \"GetConsoleScreenBufferInfo\",\n+            java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT, C_POINTER$LAYOUT));\n+\n+    static final MethodHandle ScrollConsoleScreenBufferW$MH = downcallHandle(\n+            \"ScrollConsoleScreenBufferW\",\n+            java.lang.foreign.FunctionDescriptor.of(\n+                    C_INT$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    C_POINTER$LAYOUT,\n+                    COORD.LAYOUT,\n+                    C_POINTER$LAYOUT));\n+    static final MethodHandle GetLastError$MH =\n+            downcallHandle(\"GetLastError\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT));\n+    static final MethodHandle GetFileType$MH =\n+            downcallHandle(\"GetFileType\", java.lang.foreign.FunctionDescriptor.of(C_INT$LAYOUT, C_POINTER$LAYOUT));\n+    static final MethodHandle _get_osfhandle$MH =\n+            downcallHandle(\"_get_osfhandle\", java.lang.foreign.FunctionDescriptor.of(C_POINTER$LAYOUT, C_INT$LAYOUT));\n+\n+    public static final class INPUT_RECORD {\n+        static final java.lang.foreign.MemoryLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"EventType\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT, \/\/ padding\n+                java.lang.foreign.MemoryLayout.unionLayout(\n+                                KEY_EVENT_RECORD.LAYOUT.withName(\"KeyEvent\"),\n+                                MOUSE_EVENT_RECORD.LAYOUT.withName(\"MouseEvent\"),\n+                                WINDOW_BUFFER_SIZE_RECORD.LAYOUT.withName(\"WindowBufferSizeEvent\"),\n+                                MENU_EVENT_RECORD.LAYOUT.withName(\"MenuEvent\"),\n+                                FOCUS_EVENT_RECORD.LAYOUT.withName(\"FocusEvent\"))\n+                        .withName(\"Event\"));\n+        static final VarHandle EventType$VH = varHandle(LAYOUT, \"EventType\");\n+        static final long Event$OFFSET = byteOffset(LAYOUT, \"Event\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public INPUT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public INPUT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public INPUT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public short eventType() {\n+            return (short) EventType$VH.get(seg);\n+        }\n+\n+        public KEY_EVENT_RECORD keyEvent() {\n+            return new KEY_EVENT_RECORD(seg, Event$OFFSET);\n+        }\n+\n+        public MOUSE_EVENT_RECORD mouseEvent() {\n+            return new MOUSE_EVENT_RECORD(seg, Event$OFFSET);\n+        }\n+\n+        public FOCUS_EVENT_RECORD focusEvent() {\n+            return new FOCUS_EVENT_RECORD(seg, Event$OFFSET);\n+        }\n+    }\n+\n+    public static final class MENU_EVENT_RECORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(C_DWORD$LAYOUT.withName(\"dwCommandId\"));\n+        static final VarHandle COMMAND_ID = varHandle(LAYOUT, \"dwCommandId\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public MENU_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public MENU_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public MENU_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public int commandId() {\n+            return (int) MENU_EVENT_RECORD.COMMAND_ID.get(seg);\n+        }\n+\n+        public void commandId(int commandId) {\n+            MENU_EVENT_RECORD.COMMAND_ID.set(seg, commandId);\n+        }\n+    }\n+\n+    public static final class FOCUS_EVENT_RECORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(C_INT$LAYOUT.withName(\"bSetFocus\"));\n+        static final VarHandle SET_FOCUS = varHandle(LAYOUT, \"bSetFocus\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public FOCUS_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public FOCUS_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public FOCUS_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = Objects.requireNonNull(seg);\n+        }\n+\n+        public FOCUS_EVENT_RECORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public boolean setFocus() {\n+            return ((int) FOCUS_EVENT_RECORD.SET_FOCUS.get(seg) != 0);\n+        }\n+\n+        public void setFocus(boolean setFocus) {\n+            FOCUS_EVENT_RECORD.SET_FOCUS.set(seg, setFocus ? 1 : 0);\n+        }\n+    }\n+\n+    public static final class WINDOW_BUFFER_SIZE_RECORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(COORD.LAYOUT.withName(\"size\"));\n+        static final long SIZE_OFFSET = byteOffset(LAYOUT, \"size\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public WINDOW_BUFFER_SIZE_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public WINDOW_BUFFER_SIZE_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public WINDOW_BUFFER_SIZE_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public COORD size() {\n+            return new COORD(seg, SIZE_OFFSET);\n+        }\n+\n+        public String toString() {\n+            return \"WINDOW_BUFFER_SIZE_RECORD{size=\" + this.size() + '}';\n+        }\n+    }\n+\n+    public static final class MOUSE_EVENT_RECORD {\n+\n+        static final java.lang.foreign.MemoryLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                COORD.LAYOUT.withName(\"dwMousePosition\"),\n+                C_DWORD$LAYOUT.withName(\"dwButtonState\"),\n+                C_DWORD$LAYOUT.withName(\"dwControlKeyState\"),\n+                C_DWORD$LAYOUT.withName(\"dwEventFlags\"));\n+        static final long MOUSE_POSITION_OFFSET = byteOffset(LAYOUT, \"dwMousePosition\");\n+        static final VarHandle BUTTON_STATE = varHandle(LAYOUT, \"dwButtonState\");\n+        static final VarHandle CONTROL_KEY_STATE = varHandle(LAYOUT, \"dwControlKeyState\");\n+        static final VarHandle EVENT_FLAGS = varHandle(LAYOUT, \"dwEventFlags\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public MOUSE_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public MOUSE_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public MOUSE_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = Objects.requireNonNull(seg);\n+        }\n+\n+        public MOUSE_EVENT_RECORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public COORD mousePosition() {\n+            return new COORD(seg, MOUSE_POSITION_OFFSET);\n+        }\n+\n+        public int buttonState() {\n+            return (int) BUTTON_STATE.get(seg);\n+        }\n+\n+        public int controlKeyState() {\n+            return (int) CONTROL_KEY_STATE.get(seg);\n+        }\n+\n+        public int eventFlags() {\n+            return (int) EVENT_FLAGS.get(seg);\n+        }\n+\n+        public String toString() {\n+            return \"MOUSE_EVENT_RECORD{mousePosition=\" + mousePosition() + \", buttonState=\" + buttonState()\n+                    + \", controlKeyState=\" + controlKeyState() + \", eventFlags=\" + eventFlags() + '}';\n+        }\n+    }\n+\n+    public static final class KEY_EVENT_RECORD {\n+\n+        static final java.lang.foreign.MemoryLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                java.lang.foreign.ValueLayout.JAVA_INT.withName(\"bKeyDown\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"wRepeatCount\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"wVirtualKeyCode\"),\n+                java.lang.foreign.ValueLayout.JAVA_SHORT.withName(\"wVirtualScanCode\"),\n+                java.lang.foreign.MemoryLayout.unionLayout(\n+                                java.lang.foreign.ValueLayout.JAVA_CHAR.withName(\"UnicodeChar\"),\n+                                java.lang.foreign.ValueLayout.JAVA_BYTE.withName(\"AsciiChar\"))\n+                        .withName(\"uChar\"),\n+                java.lang.foreign.ValueLayout.JAVA_INT.withName(\"dwControlKeyState\"));\n+        static final VarHandle bKeyDown$VH = varHandle(LAYOUT, \"bKeyDown\");\n+        static final VarHandle wRepeatCount$VH = varHandle(LAYOUT, \"wRepeatCount\");\n+        static final VarHandle wVirtualKeyCode$VH = varHandle(LAYOUT, \"wVirtualKeyCode\");\n+        static final VarHandle wVirtualScanCode$VH = varHandle(LAYOUT, \"wVirtualScanCode\");\n+        static final VarHandle UnicodeChar$VH = varHandle(LAYOUT, \"uChar\", \"UnicodeChar\");\n+        static final VarHandle AsciiChar$VH = varHandle(LAYOUT, \"uChar\", \"AsciiChar\");\n+        static final VarHandle dwControlKeyState$VH = varHandle(LAYOUT, \"dwControlKeyState\");\n+\n+        final java.lang.foreign.MemorySegment seg;\n+\n+        public KEY_EVENT_RECORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public KEY_EVENT_RECORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public KEY_EVENT_RECORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public KEY_EVENT_RECORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public boolean keyDown() {\n+            return ((int) bKeyDown$VH.get(seg)) != 0;\n+        }\n+\n+        public int repeatCount() {\n+            return (int) wRepeatCount$VH.get(seg);\n+        }\n+\n+        public short keyCode() {\n+            return (short) wVirtualKeyCode$VH.get(seg);\n+        }\n+\n+        public short scanCode() {\n+            return (short) wVirtualScanCode$VH.get(seg);\n+        }\n+\n+        public char uchar() {\n+            return (char) UnicodeChar$VH.get(seg);\n+        }\n+\n+        public int controlKeyState() {\n+            return (int) dwControlKeyState$VH.get(seg);\n+        }\n+\n+        public String toString() {\n+            return \"KEY_EVENT_RECORD{keyDown=\" + this.keyDown() + \", repeatCount=\" + this.repeatCount() + \", keyCode=\"\n+                    + this.keyCode() + \", scanCode=\" + this.scanCode() + \", uchar=\" + this.uchar()\n+                    + \", controlKeyState=\"\n+                    + this.controlKeyState() + '}';\n+        }\n+    }\n+\n+    public static final class CHAR_INFO {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                java.lang.foreign.MemoryLayout.unionLayout(\n+                                C_WCHAR$LAYOUT.withName(\"UnicodeChar\"), C_CHAR$LAYOUT.withName(\"AsciiChar\"))\n+                        .withName(\"Char\"),\n+                C_WORD$LAYOUT.withName(\"Attributes\"));\n+        static final VarHandle UnicodeChar$VH = varHandle(LAYOUT, \"Char\", \"UnicodeChar\");\n+        static final VarHandle Attributes$VH = varHandle(LAYOUT, \"Attributes\");\n+\n+        final java.lang.foreign.MemorySegment seg;\n+\n+        public CHAR_INFO() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public CHAR_INFO(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public CHAR_INFO(java.lang.foreign.Arena arena, char c, short a) {\n+            this(arena);\n+            UnicodeChar$VH.set(seg, c);\n+            Attributes$VH.set(seg, a);\n+        }\n+\n+        public CHAR_INFO(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public char unicodeChar() {\n+            return (char) UnicodeChar$VH.get(seg);\n+        }\n+    }\n+\n+    public static final class CONSOLE_SCREEN_BUFFER_INFO {\n+        static final java.lang.foreign.GroupLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                COORD.LAYOUT.withName(\"dwSize\"),\n+                COORD.LAYOUT.withName(\"dwCursorPosition\"),\n+                C_WORD$LAYOUT.withName(\"wAttributes\"),\n+                SMALL_RECT.LAYOUT.withName(\"srWindow\"),\n+                COORD.LAYOUT.withName(\"dwMaximumWindowSize\"));\n+        static final long dwSize$OFFSET = byteOffset(LAYOUT, \"dwSize\");\n+        static final long dwCursorPosition$OFFSET = byteOffset(LAYOUT, \"dwCursorPosition\");\n+        static final VarHandle wAttributes$VH = varHandle(LAYOUT, \"wAttributes\");\n+        static final long srWindow$OFFSET = byteOffset(LAYOUT, \"srWindow\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public CONSOLE_SCREEN_BUFFER_INFO() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public CONSOLE_SCREEN_BUFFER_INFO(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public CONSOLE_SCREEN_BUFFER_INFO(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public COORD size() {\n+            return new COORD(seg, dwSize$OFFSET);\n+        }\n+\n+        public COORD cursorPosition() {\n+            return new COORD(seg, dwCursorPosition$OFFSET);\n+        }\n+\n+        public short attributes() {\n+            return (short) wAttributes$VH.get(seg);\n+        }\n+\n+        public SMALL_RECT window() {\n+            return new SMALL_RECT(seg, srWindow$OFFSET);\n+        }\n+\n+        public int windowWidth() {\n+            return this.window().width() + 1;\n+        }\n+\n+        public int windowHeight() {\n+            return this.window().height() + 1;\n+        }\n+\n+        public void attributes(short attr) {\n+            wAttributes$VH.set(seg, attr);\n+        }\n+    }\n+\n+    public static final class COORD {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT =\n+                java.lang.foreign.MemoryLayout.structLayout(C_SHORT$LAYOUT.withName(\"x\"), C_SHORT$LAYOUT.withName(\"y\"));\n+        static final VarHandle x$VH = varHandle(LAYOUT, \"x\");\n+        static final VarHandle y$VH = varHandle(LAYOUT, \"y\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public COORD() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public COORD(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public COORD(java.lang.foreign.Arena arena, short x, short y) {\n+            this(arena.allocate(LAYOUT));\n+            x(x);\n+            y(y);\n+        }\n+\n+        public COORD(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public COORD(java.lang.foreign.MemorySegment seg, long offset) {\n+            this.seg = Objects.requireNonNull(seg).asSlice(offset, LAYOUT.byteSize());\n+        }\n+\n+        public short x() {\n+            return (short) COORD.x$VH.get(seg);\n+        }\n+\n+        public void x(short x) {\n+            COORD.x$VH.set(seg, x);\n+        }\n+\n+        public short y() {\n+            return (short) COORD.y$VH.get(seg);\n+        }\n+\n+        public void y(short y) {\n+            COORD.y$VH.set(seg, y);\n+        }\n+\n+        public COORD copy(java.lang.foreign.Arena arena) {\n+            return new COORD(arena.allocate(LAYOUT).copyFrom(seg));\n+        }\n+    }\n+\n+    public static final class SMALL_RECT {\n+\n+        static final java.lang.foreign.GroupLayout LAYOUT = java.lang.foreign.MemoryLayout.structLayout(\n+                C_SHORT$LAYOUT.withName(\"Left\"),\n+                C_SHORT$LAYOUT.withName(\"Top\"),\n+                C_SHORT$LAYOUT.withName(\"Right\"),\n+                C_SHORT$LAYOUT.withName(\"Bottom\"));\n+        static final VarHandle Left$VH = varHandle(LAYOUT, \"Left\");\n+        static final VarHandle Top$VH = varHandle(LAYOUT, \"Top\");\n+        static final VarHandle Right$VH = varHandle(LAYOUT, \"Right\");\n+        static final VarHandle Bottom$VH = varHandle(LAYOUT, \"Bottom\");\n+\n+        private final java.lang.foreign.MemorySegment seg;\n+\n+        public SMALL_RECT() {\n+            this(java.lang.foreign.Arena.ofAuto());\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.Arena arena) {\n+            this(arena.allocate(LAYOUT));\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.Arena arena, SMALL_RECT rect) {\n+            this(arena);\n+            left(rect.left());\n+            right(rect.right());\n+            top(rect.top());\n+            bottom(rect.bottom());\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.MemorySegment seg, long offset) {\n+            this(seg.asSlice(offset, LAYOUT.byteSize()));\n+        }\n+\n+        public SMALL_RECT(java.lang.foreign.MemorySegment seg) {\n+            this.seg = seg;\n+        }\n+\n+        public short left() {\n+            return (short) Left$VH.get(seg);\n+        }\n+\n+        public short top() {\n+            return (short) Top$VH.get(seg);\n+        }\n+\n+        public short right() {\n+            return (short) Right$VH.get(seg);\n+        }\n+\n+        public short bottom() {\n+            return (short) Bottom$VH.get(seg);\n+        }\n+\n+        public short width() {\n+            return (short) (this.right() - this.left());\n+        }\n+\n+        public short height() {\n+            return (short) (this.bottom() - this.top());\n+        }\n+\n+        public void left(short l) {\n+            Left$VH.set(seg, l);\n+        }\n+\n+        public void top(short t) {\n+            Top$VH.set(seg, t);\n+        }\n+\n+        public void right(short r) {\n+            Right$VH.set(seg, r);\n+        }\n+\n+        public void bottom(short b) {\n+            Bottom$VH.set(seg, b);\n+        }\n+\n+        public SMALL_RECT copy(java.lang.foreign.Arena arena) {\n+            return new SMALL_RECT(arena.allocate(LAYOUT).copyFrom(seg));\n+        }\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    static VarHandle varHandle(java.lang.foreign.MemoryLayout layout, String name) {\n+        return FfmTerminalProvider.lookupVarHandle(\n+                layout, java.lang.foreign.MemoryLayout.PathElement.groupElement(name));\n+    }\n+\n+    static VarHandle varHandle(java.lang.foreign.MemoryLayout layout, String e1, String name) {\n+        return FfmTerminalProvider.lookupVarHandle(\n+                layout,\n+                java.lang.foreign.MemoryLayout.PathElement.groupElement(e1),\n+                java.lang.foreign.MemoryLayout.PathElement.groupElement(name));\n+    }\n+\n+    static long byteOffset(java.lang.foreign.MemoryLayout layout, String name) {\n+        return layout.byteOffset(java.lang.foreign.MemoryLayout.PathElement.groupElement(name));\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/Kernel32.java","additions":927,"deletions":0,"binary":false,"changes":927,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.IOException;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import jdk.internal.org.jline.terminal.impl.AbstractWindowsConsoleWriter;\n+\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetStdHandle;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_OUTPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.WriteConsoleW;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.getLastErrorMessage;\n+\n+class NativeWinConsoleWriter extends AbstractWindowsConsoleWriter {\n+\n+    private final java.lang.foreign.MemorySegment console = GetStdHandle(STD_OUTPUT_HANDLE);\n+\n+    @Override\n+    protected void writeConsole(char[] text, int len) throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment txt = arena.allocateFrom(ValueLayout.JAVA_CHAR, text);\n+            if (WriteConsoleW(console, txt, len, MemorySegment.NULL, MemorySegment.NULL) == 0) {\n+                throw new IOException(\"Failed to write to console: \" + getLastErrorMessage());\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/NativeWinConsoleWriter.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOError;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+import java.util.function.IntConsumer;\n+\n+import jdk.internal.org.jline.terminal.Cursor;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.*;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetConsoleMode;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetConsoleScreenBufferInfo;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetStdHandle;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.INPUT_RECORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.INVALID_HANDLE_VALUE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.KEY_EVENT_RECORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.MOUSE_EVENT_RECORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_ERROR_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_INPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_OUTPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleMode;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.WaitForSingleObject;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.getLastErrorMessage;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.readConsoleInputHelper;\n+\n+public class NativeWinSysTerminal extends AbstractWindowsTerminal<java.lang.foreign.MemorySegment> {\n+\n+    public static NativeWinSysTerminal createTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            SignalHandler signalHandler,\n+            boolean paused,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            \/\/ Get input console mode\n+            java.lang.foreign.MemorySegment consoleIn = GetStdHandle(STD_INPUT_HANDLE);\n+            java.lang.foreign.MemorySegment inMode = allocateInt(arena);\n+            if (GetConsoleMode(consoleIn, inMode) == 0) {\n+                throw new IOException(\"Failed to get console mode: \" + getLastErrorMessage());\n+            }\n+            \/\/ Get output console and mode\n+            java.lang.foreign.MemorySegment console;\n+            switch (systemStream) {\n+                case Output:\n+                    console = GetStdHandle(STD_OUTPUT_HANDLE);\n+                    break;\n+                case Error:\n+                    console = GetStdHandle(STD_ERROR_HANDLE);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported stream for console: \" + systemStream);\n+            }\n+            java.lang.foreign.MemorySegment outMode = allocateInt(arena);\n+            if (GetConsoleMode(console, outMode) == 0) {\n+                throw new IOException(\"Failed to get console mode: \" + getLastErrorMessage());\n+            }\n+            \/\/ Create writer\n+            Writer writer;\n+            if (ansiPassThrough) {\n+                type = type != null ? type : OSUtils.IS_CONEMU ? TYPE_WINDOWS_CONEMU : TYPE_WINDOWS;\n+                writer = new NativeWinConsoleWriter();\n+            } else {\n+                int m = inMode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0);\n+                if (enableVtp(console, m)) {\n+                    type = type != null ? type : TYPE_WINDOWS_VTP;\n+                    writer = new NativeWinConsoleWriter();\n+                } else if (OSUtils.IS_CONEMU) {\n+                    type = type != null ? type : TYPE_WINDOWS_CONEMU;\n+                    writer = new NativeWinConsoleWriter();\n+                } else {\n+                    type = type != null ? type : TYPE_WINDOWS;\n+                    writer = new WindowsAnsiWriter(new BufferedWriter(new NativeWinConsoleWriter()));\n+                }\n+            }\n+            \/\/ Create terminal\n+            NativeWinSysTerminal terminal = new NativeWinSysTerminal(\n+                    provider,\n+                    systemStream,\n+                    writer,\n+                    name,\n+                    type,\n+                    encoding,\n+                    nativeSignals,\n+                    signalHandler,\n+                    consoleIn,\n+                    inMode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0),\n+                    console,\n+                    outMode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0),\n+                    inputStreamWrapper);\n+            \/\/ Start input pump thread\n+            if (!paused) {\n+                terminal.resume();\n+            }\n+            return terminal;\n+        }\n+    }\n+\n+    private static boolean enableVtp(java.lang.foreign.MemorySegment console, int m) {\n+        return SetConsoleMode(console, m | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING) != 0;\n+    }\n+\n+    public static boolean isWindowsSystemStream(SystemStream stream) {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment console;\n+            java.lang.foreign.MemorySegment mode = allocateInt(arena);\n+            switch (stream) {\n+                case Input:\n+                    console = GetStdHandle(STD_INPUT_HANDLE);\n+                    break;\n+                case Output:\n+                    console = GetStdHandle(STD_OUTPUT_HANDLE);\n+                    break;\n+                case Error:\n+                    console = GetStdHandle(STD_ERROR_HANDLE);\n+                    break;\n+                default:\n+                    return false;\n+            }\n+            return GetConsoleMode(console, mode) != 0;\n+        }\n+    }\n+\n+    private static java.lang.foreign.MemorySegment allocateInt(java.lang.foreign.Arena arena) {\n+        return arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+    }\n+\n+    NativeWinSysTerminal(\n+            TerminalProvider provider,\n+            SystemStream systemStream,\n+            Writer writer,\n+            String name,\n+            String type,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            SignalHandler signalHandler,\n+            java.lang.foreign.MemorySegment inConsole,\n+            int inConsoleMode,\n+            java.lang.foreign.MemorySegment outConsole,\n+            int outConsoleMode,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException {\n+        super(\n+                provider,\n+                systemStream,\n+                writer,\n+                name,\n+                type,\n+                encoding,\n+                nativeSignals,\n+                signalHandler,\n+                inConsole,\n+                inConsoleMode,\n+                outConsole,\n+                outConsoleMode,\n+                inputStreamWrapper);\n+    }\n+\n+    @Override\n+    protected int getConsoleMode(java.lang.foreign.MemorySegment console) {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment mode = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+            if (GetConsoleMode(console, mode) == 0) {\n+                return -1;\n+            }\n+            return mode.get(java.lang.foreign.ValueLayout.JAVA_INT, 0);\n+        }\n+    }\n+\n+    @Override\n+    protected void setConsoleMode(java.lang.foreign.MemorySegment console, int mode) {\n+        SetConsoleMode(console, mode);\n+    }\n+\n+    public Size getSize() {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(arena);\n+            GetConsoleScreenBufferInfo(outConsole, info);\n+            return new Size(info.windowWidth(), info.windowHeight());\n+        }\n+    }\n+\n+    @Override\n+    public Size getBufferSize() {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(arena);\n+            GetConsoleScreenBufferInfo(outConsole, info);\n+            return new Size(info.size().x(), info.size().y());\n+        }\n+    }\n+\n+    protected boolean processConsoleInput() throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            INPUT_RECORD[] events;\n+            if (inConsole != null\n+                    && inConsole.address() != INVALID_HANDLE_VALUE\n+                    && WaitForSingleObject(inConsole, 100) == 0) {\n+                events = readConsoleInputHelper(arena, inConsole, 1, false);\n+            } else {\n+                return false;\n+            }\n+\n+            boolean flush = false;\n+            for (INPUT_RECORD event : events) {\n+                int eventType = event.eventType();\n+                if (eventType == KEY_EVENT) {\n+                    KEY_EVENT_RECORD keyEvent = event.keyEvent();\n+                    processKeyEvent(\n+                            keyEvent.keyDown(), keyEvent.keyCode(), keyEvent.uchar(), keyEvent.controlKeyState());\n+                    flush = true;\n+                } else if (eventType == WINDOW_BUFFER_SIZE_EVENT) {\n+                    raise(Signal.WINCH);\n+                } else if (eventType == MOUSE_EVENT) {\n+                    processMouseEvent(event.mouseEvent());\n+                    flush = true;\n+                } else if (eventType == FOCUS_EVENT) {\n+                    processFocusEvent(event.focusEvent().setFocus());\n+                }\n+            }\n+\n+            return flush;\n+        }\n+    }\n+\n+    private final char[] focus = new char[] {'\\033', '[', ' '};\n+\n+    private void processFocusEvent(boolean hasFocus) throws IOException {\n+        if (focusTracking) {\n+            focus[2] = hasFocus ? 'I' : 'O';\n+            slaveInputPipe.write(focus);\n+        }\n+    }\n+\n+    private final char[] mouse = new char[] {'\\033', '[', 'M', ' ', ' ', ' '};\n+\n+    private void processMouseEvent(MOUSE_EVENT_RECORD mouseEvent) throws IOException {\n+        int dwEventFlags = mouseEvent.eventFlags();\n+        int dwButtonState = mouseEvent.buttonState();\n+        if (tracking == MouseTracking.Off\n+                || tracking == MouseTracking.Normal && dwEventFlags == MOUSE_MOVED\n+                || tracking == MouseTracking.Button && dwEventFlags == MOUSE_MOVED && dwButtonState == 0) {\n+            return;\n+        }\n+        int cb = 0;\n+        dwEventFlags &= ~DOUBLE_CLICK; \/\/ Treat double-clicks as normal\n+        if (dwEventFlags == MOUSE_WHEELED) {\n+            cb |= 64;\n+            if ((dwButtonState >> 16) < 0) {\n+                cb |= 1;\n+            }\n+        } else if (dwEventFlags == MOUSE_HWHEELED) {\n+            return;\n+        } else if ((dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED) != 0) {\n+            cb |= 0x00;\n+        } else if ((dwButtonState & RIGHTMOST_BUTTON_PRESSED) != 0) {\n+            cb |= 0x01;\n+        } else if ((dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED) != 0) {\n+            cb |= 0x02;\n+        } else {\n+            cb |= 0x03;\n+        }\n+        int cx = mouseEvent.mousePosition().x();\n+        int cy = mouseEvent.mousePosition().y();\n+        mouse[3] = (char) (' ' + cb);\n+        mouse[4] = (char) (' ' + cx + 1);\n+        mouse[5] = (char) (' ' + cy + 1);\n+        slaveInputPipe.write(mouse);\n+    }\n+\n+    @Override\n+    public Cursor getCursorPosition(IntConsumer discarded) {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(arena);\n+            if (GetConsoleScreenBufferInfo(outConsole, info) == 0) {\n+                throw new IOError(new IOException(\"Could not get the cursor position: \" + getLastErrorMessage()));\n+            }\n+            return new Cursor(info.cursorPosition().x(), info.cursorPosition().y());\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/NativeWinSysTerminal.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,407 @@\n+\/*\n+ * Copyright (c) 2022-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.ffm;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import jdk.internal.org.jline.utils.AnsiWriter;\n+import jdk.internal.org.jline.utils.Colors;\n+\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_BLUE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_GREEN;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_INTENSITY;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.BACKGROUND_RED;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.CHAR_INFO;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.CONSOLE_SCREEN_BUFFER_INFO;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.COORD;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_BLUE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_GREEN;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_INTENSITY;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FOREGROUND_RED;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FillConsoleOutputAttribute;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.FillConsoleOutputCharacterW;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetConsoleScreenBufferInfo;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.GetStdHandle;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SMALL_RECT;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.STD_OUTPUT_HANDLE;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.ScrollConsoleScreenBuffer;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleCursorPosition;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleTextAttribute;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.SetConsoleTitleW;\n+import static jdk.internal.org.jline.terminal.impl.ffm.Kernel32.getLastErrorMessage;\n+\n+class WindowsAnsiWriter extends AnsiWriter {\n+\n+    private static final java.lang.foreign.MemorySegment console = GetStdHandle(STD_OUTPUT_HANDLE);\n+\n+    private static final short FOREGROUND_BLACK = 0;\n+    private static final short FOREGROUND_YELLOW = (short) (FOREGROUND_RED | FOREGROUND_GREEN);\n+    private static final short FOREGROUND_MAGENTA = (short) (FOREGROUND_BLUE | FOREGROUND_RED);\n+    private static final short FOREGROUND_CYAN = (short) (FOREGROUND_BLUE | FOREGROUND_GREEN);\n+    private static final short FOREGROUND_WHITE = (short) (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\n+\n+    private static final short BACKGROUND_BLACK = 0;\n+    private static final short BACKGROUND_YELLOW = (short) (BACKGROUND_RED | BACKGROUND_GREEN);\n+    private static final short BACKGROUND_MAGENTA = (short) (BACKGROUND_BLUE | BACKGROUND_RED);\n+    private static final short BACKGROUND_CYAN = (short) (BACKGROUND_BLUE | BACKGROUND_GREEN);\n+    private static final short BACKGROUND_WHITE = (short) (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE);\n+\n+    private static final short[] ANSI_FOREGROUND_COLOR_MAP = {\n+        FOREGROUND_BLACK,\n+        FOREGROUND_RED,\n+        FOREGROUND_GREEN,\n+        FOREGROUND_YELLOW,\n+        FOREGROUND_BLUE,\n+        FOREGROUND_MAGENTA,\n+        FOREGROUND_CYAN,\n+        FOREGROUND_WHITE,\n+    };\n+\n+    private static final short[] ANSI_BACKGROUND_COLOR_MAP = {\n+        BACKGROUND_BLACK,\n+        BACKGROUND_RED,\n+        BACKGROUND_GREEN,\n+        BACKGROUND_YELLOW,\n+        BACKGROUND_BLUE,\n+        BACKGROUND_MAGENTA,\n+        BACKGROUND_CYAN,\n+        BACKGROUND_WHITE,\n+    };\n+\n+    private final CONSOLE_SCREEN_BUFFER_INFO info = new CONSOLE_SCREEN_BUFFER_INFO(java.lang.foreign.Arena.ofAuto());\n+    private final short originalColors;\n+\n+    private boolean negative;\n+    private boolean bold;\n+    private boolean underline;\n+    private short savedX = -1;\n+    private short savedY = -1;\n+\n+    public WindowsAnsiWriter(Writer out) throws IOException {\n+        super(out);\n+        getConsoleInfo();\n+        originalColors = info.attributes();\n+    }\n+\n+    private void getConsoleInfo() throws IOException {\n+        out.flush();\n+        if (GetConsoleScreenBufferInfo(console, info) == 0) {\n+            throw new IOException(\"Could not get the screen info: \" + getLastErrorMessage());\n+        }\n+        if (negative) {\n+            info.attributes(invertAttributeColors(info.attributes()));\n+        }\n+    }\n+\n+    private void applyAttribute() throws IOException {\n+        out.flush();\n+        short attributes = info.attributes();\n+        \/\/ bold is simulated by high foreground intensity\n+        if (bold) {\n+            attributes |= FOREGROUND_INTENSITY;\n+        }\n+        \/\/ underline is simulated by high foreground intensity\n+        if (underline) {\n+            attributes |= BACKGROUND_INTENSITY;\n+        }\n+        if (negative) {\n+            attributes = invertAttributeColors(attributes);\n+        }\n+        if (SetConsoleTextAttribute(console, attributes) == 0) {\n+            throw new IOException(getLastErrorMessage());\n+        }\n+    }\n+\n+    private short invertAttributeColors(short attributes) {\n+        \/\/ Swap the the Foreground and Background bits.\n+        int fg = 0x000F & attributes;\n+        fg <<= 4;\n+        int bg = 0X00F0 & attributes;\n+        bg >>= 4;\n+        attributes = (short) ((attributes & 0xFF00) | fg | bg);\n+        return attributes;\n+    }\n+\n+    private void applyCursorPosition() throws IOException {\n+        info.cursorPosition().x((short)\n+                Math.max(0, Math.min(info.size().x() - 1, info.cursorPosition().x())));\n+        info.cursorPosition().y((short)\n+                Math.max(0, Math.min(info.size().y() - 1, info.cursorPosition().y())));\n+        if (SetConsoleCursorPosition(console, info.cursorPosition()) == 0) {\n+            throw new IOException(getLastErrorMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void processEraseScreen(int eraseOption) throws IOException {\n+        getConsoleInfo();\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment written = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+            switch (eraseOption) {\n+                case ERASE_SCREEN -> {\n+                    COORD topLeft = new COORD(arena, (short) 0, info.window().top());\n+                    int screenLength = info.window().height() * info.size().x();\n+                    FillConsoleOutputAttribute(console, originalColors, screenLength, topLeft, written);\n+                    FillConsoleOutputCharacterW(console, ' ', screenLength, topLeft, written);\n+                }\n+                case ERASE_SCREEN_TO_BEGINING -> {\n+                    COORD topLeft2 = new COORD(arena, (short) 0, info.window().top());\n+                    int lengthToCursor =\n+                            (info.cursorPosition().y() - info.window().top())\n+                                            * info.size().x()\n+                                    + info.cursorPosition().x();\n+                    FillConsoleOutputAttribute(console, originalColors, lengthToCursor, topLeft2, written);\n+                    FillConsoleOutputCharacterW(console, ' ', lengthToCursor, topLeft2, written);\n+                }\n+                case ERASE_SCREEN_TO_END -> {\n+                    int lengthToEnd =\n+                            (info.window().bottom() - info.cursorPosition().y())\n+                                            * info.size().x()\n+                                    + (info.size().x() - info.cursorPosition().x());\n+                    FillConsoleOutputAttribute(console, originalColors, lengthToEnd, info.cursorPosition(), written);\n+                    FillConsoleOutputCharacterW(console, ' ', lengthToEnd, info.cursorPosition(), written);\n+                }\n+                default -> {}\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processEraseLine(int eraseOption) throws IOException {\n+        getConsoleInfo();\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment written = arena.allocate(java.lang.foreign.ValueLayout.JAVA_INT);\n+            switch (eraseOption) {\n+                case ERASE_LINE -> {\n+                    COORD leftColCurrRow =\n+                            new COORD(arena, (short) 0, info.cursorPosition().y());\n+                    FillConsoleOutputAttribute(\n+                            console, originalColors, info.size().x(), leftColCurrRow, written);\n+                    FillConsoleOutputCharacterW(console, ' ', info.size().x(), leftColCurrRow, written);\n+                }\n+                case ERASE_LINE_TO_BEGINING -> {\n+                    COORD leftColCurrRow2 =\n+                            new COORD(arena, (short) 0, info.cursorPosition().y());\n+                    FillConsoleOutputAttribute(\n+                            console, originalColors, info.cursorPosition().x(), leftColCurrRow2, written);\n+                    FillConsoleOutputCharacterW(\n+                            console, ' ', info.cursorPosition().x(), leftColCurrRow2, written);\n+                }\n+                case ERASE_LINE_TO_END -> {\n+                    int lengthToLastCol =\n+                            info.size().x() - info.cursorPosition().x();\n+                    FillConsoleOutputAttribute(\n+                            console, originalColors, lengthToLastCol, info.cursorPosition(), written);\n+                    FillConsoleOutputCharacterW(console, ' ', lengthToLastCol, info.cursorPosition(), written);\n+                }\n+                default -> {}\n+            }\n+        }\n+    }\n+\n+    protected void processCursorUpLine(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) 0);\n+        info.cursorPosition().y((short) (info.cursorPosition().y() - count));\n+        applyCursorPosition();\n+    }\n+\n+    protected void processCursorDownLine(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) 0);\n+        info.cursorPosition().y((short) (info.cursorPosition().y() + count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorLeft(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) (info.cursorPosition().x() - count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorRight(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) (info.cursorPosition().x() + count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorDown(int count) throws IOException {\n+        getConsoleInfo();\n+        int nb = Math.max(0, info.cursorPosition().y() + count - info.size().y() + 1);\n+        if (nb != count) {\n+            info.cursorPosition().y((short) (info.cursorPosition().y() + count));\n+            applyCursorPosition();\n+        }\n+        if (nb > 0) {\n+            try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+                SMALL_RECT scroll = new SMALL_RECT(arena, info.window());\n+                scroll.top((short) 0);\n+                COORD org = new COORD(arena);\n+                org.x((short) 0);\n+                org.y((short) (-nb));\n+                CHAR_INFO info = new CHAR_INFO(arena, ' ', originalColors);\n+                ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processCursorUp(int count) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().y((short) (info.cursorPosition().y() - count));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorTo(int row, int col) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().y((short) (info.window().top() + row - 1));\n+        info.cursorPosition().x((short) (col - 1));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processCursorToColumn(int x) throws IOException {\n+        getConsoleInfo();\n+        info.cursorPosition().x((short) (x - 1));\n+        applyCursorPosition();\n+    }\n+\n+    @Override\n+    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {\n+        int color = Colors.roundColor(paletteIndex, 16);\n+        info.attributes((short) ((info.attributes() & ~0x0007) | ANSI_FOREGROUND_COLOR_MAP[color & 0x07]));\n+        info.attributes(\n+                (short) ((info.attributes() & ~FOREGROUND_INTENSITY) | (color >= 8 ? FOREGROUND_INTENSITY : 0)));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {\n+        int color = Colors.roundColor(paletteIndex, 16);\n+        info.attributes((short) ((info.attributes() & ~0x0070) | ANSI_BACKGROUND_COLOR_MAP[color & 0x07]));\n+        info.attributes(\n+                (short) ((info.attributes() & ~BACKGROUND_INTENSITY) | (color >= 8 ? BACKGROUND_INTENSITY : 0)));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processDefaultTextColor() throws IOException {\n+        info.attributes((short) ((info.attributes() & ~0x000F) | (originalColors & 0xF)));\n+        info.attributes((short) (info.attributes() & ~FOREGROUND_INTENSITY));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processDefaultBackgroundColor() throws IOException {\n+        info.attributes((short) ((info.attributes() & ~0x00F0) | (originalColors & 0xF0)));\n+        info.attributes((short) (info.attributes() & ~BACKGROUND_INTENSITY));\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processAttributeRest() throws IOException {\n+        info.attributes((short) ((info.attributes() & ~0x00FF) | originalColors));\n+        this.negative = false;\n+        this.bold = false;\n+        this.underline = false;\n+        applyAttribute();\n+    }\n+\n+    @Override\n+    protected void processSetAttribute(int attribute) throws IOException {\n+        switch (attribute) {\n+            case ATTRIBUTE_INTENSITY_BOLD -> {\n+                bold = true;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_INTENSITY_NORMAL -> {\n+                bold = false;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_UNDERLINE -> {\n+                underline = true;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_UNDERLINE_OFF -> {\n+                underline = false;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_NEGATIVE_ON -> {\n+                negative = true;\n+                applyAttribute();\n+            }\n+            case ATTRIBUTE_NEGATIVE_OFF -> {\n+                negative = false;\n+                applyAttribute();\n+            }\n+            default -> {}\n+        }\n+    }\n+\n+    @Override\n+    protected void processSaveCursorPosition() throws IOException {\n+        getConsoleInfo();\n+        savedX = info.cursorPosition().x();\n+        savedY = info.cursorPosition().y();\n+    }\n+\n+    @Override\n+    protected void processRestoreCursorPosition() throws IOException {\n+        \/\/ restore only if there was a save operation first\n+        if (savedX != -1 && savedY != -1) {\n+            out.flush();\n+            info.cursorPosition().x(savedX);\n+            info.cursorPosition().y(savedY);\n+            applyCursorPosition();\n+        }\n+    }\n+\n+    @Override\n+    protected void processInsertLine(int optionInt) throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            getConsoleInfo();\n+            SMALL_RECT scroll = info.window().copy(arena);\n+            scroll.top(info.cursorPosition().y());\n+            COORD org =\n+                    new COORD(arena, (short) 0, (short) (info.cursorPosition().y() + optionInt));\n+            CHAR_INFO info = new CHAR_INFO(arena, ' ', originalColors);\n+            if (ScrollConsoleScreenBuffer(console, scroll, scroll, org, info) == 0) {\n+                throw new IOException(getLastErrorMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processDeleteLine(int optionInt) throws IOException {\n+        try (java.lang.foreign.Arena arena = java.lang.foreign.Arena.ofConfined()) {\n+            getConsoleInfo();\n+            SMALL_RECT scroll = info.window().copy(arena);\n+            scroll.top(info.cursorPosition().y());\n+            COORD org =\n+                    new COORD(arena, (short) 0, (short) (info.cursorPosition().y() - optionInt));\n+            CHAR_INFO info = new CHAR_INFO(arena, ' ', originalColors);\n+            if (ScrollConsoleScreenBuffer(console, scroll, scroll, org, info) == 0) {\n+                throw new IOException(getLastErrorMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void processChangeWindowTitle(String title) {\n+        try (java.lang.foreign.Arena session = java.lang.foreign.Arena.ofConfined()) {\n+            java.lang.foreign.MemorySegment str = session.allocateFrom(title);\n+            SetConsoleTitleW(str);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/WindowsAnsiWriter.java","additions":407,"deletions":0,"binary":false,"changes":407,"status":"added"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-@SuppressWarnings(\"serial\")\n-public class LastErrorException extends RuntimeException{\n-\n-    public final long lastError;\n-\n-    public LastErrorException(long lastError) {\n-        this.lastError = lastError;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -37,0 +37,3 @@\n+    SystemStream getSystemStream();\n+\n+    TerminalProvider getProvider();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/Pty.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * Copyright (c) 2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+public enum SystemStream {\n+    Input,\n+    Output,\n+    Error\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/SystemStream.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+import jdk.internal.org.jline.terminal.Terminal;\n+\n+\/**\n+ * The {@code TerminalExt} interface is implemented by {@code Terminal}s\n+ * and provides access to the Terminal's internals.\n+ *\/\n+public interface TerminalExt extends Terminal {\n+\n+    \/**\n+     * Returns the {@code TerminalProvider} that created this terminal\n+     * or {@code null} if the terminal was created with no provider.\n+     *\/\n+    TerminalProvider getProvider();\n+\n+    \/**\n+     * The underlying system stream, may be {@link SystemStream#Output},\n+     * {@link SystemStream#Error}, or {@code null} if this terminal is not bound\n+     * to a system stream.\n+     *\/\n+    SystemStream getSystemStream();\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalExt.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, the original author or authors.\n+ * Copyright (c) 2022, the original author(s).\n@@ -14,1 +14,0 @@\n-import java.net.URL;\n@@ -17,1 +16,0 @@\n-import java.util.ServiceLoader;\n@@ -24,0 +22,1 @@\n+import jdk.internal.org.jline.terminal.impl.ffm.FfmTerminalProvider;\n@@ -25,8 +24,1 @@\n-public interface TerminalProvider\n-{\n-\n-    enum Stream {\n-        Input,\n-        Output,\n-        Error\n-    }\n+public interface TerminalProvider {\n@@ -36,4 +28,23 @@\n-    Terminal sysTerminal(String name, String type, boolean ansiPassThrough,\n-                         Charset encoding, boolean nativeSignals,\n-                         Terminal.SignalHandler signalHandler, boolean paused,\n-                         Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n+    Terminal sysTerminal(\n+            String name,\n+            String type,\n+            boolean ansiPassThrough,\n+            Charset encoding,\n+            boolean nativeSignals,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            SystemStream systemStream,\n+            Function<InputStream, InputStream> inputStreamWrapper)\n+            throws IOException;\n+\n+    Terminal newTerminal(\n+            String name,\n+            String type,\n+            InputStream masterInput,\n+            OutputStream masterOutput,\n+            Charset encoding,\n+            Terminal.SignalHandler signalHandler,\n+            boolean paused,\n+            Attributes attributes,\n+            Size size)\n+            throws IOException;\n@@ -41,4 +52,1 @@\n-    Terminal newTerminal(String name, String type,\n-                         InputStream masterInput, OutputStream masterOutput,\n-                         Charset encoding, Terminal.SignalHandler signalHandler,\n-                         boolean paused, Attributes attributes, Size size) throws IOException;\n+    boolean isSystemStream(SystemStream stream);\n@@ -46,1 +54,1 @@\n-    boolean isSystemStream(Stream stream);\n+    String systemStreamName(SystemStream stream);\n@@ -48,1 +56,1 @@\n-    String systemStreamName(Stream stream);\n+    int systemStreamWidth(SystemStream stream);\n@@ -53,7 +61,1 @@\n-            case \"jna\": {\n-                try {\n-                    return (TerminalProvider) Class.forName(\"jdk.internal.org.jline.terminal.impl.jna.JnaTerminalProvider\").getConstructor().newInstance();\n-                } catch (ReflectiveOperationException t) {\n-                    throw new IOException(t);\n-                }\n-            }\n+            case \"ffm\": return new FfmTerminalProvider();\n@@ -65,1 +67,1 @@\n-        InputStream is = cl.getResourceAsStream( \"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n+        InputStream is = cl.getResourceAsStream(\"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n@@ -74,1 +76,1 @@\n-                Class<?> clazz = cl.loadClass( className );\n+                Class<?> clazz = cl.loadClass(className);\n@@ -76,2 +78,2 @@\n-            } catch ( Exception e ) {\n-                throw new IOException(\"Unable to load terminal provider \" + name, e);\n+            } catch (Exception e) {\n+                throw new IOException(\"Unable to load terminal provider \" + name + \": \" + e.getMessage(), e);\n@@ -83,1 +85,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalProvider.java","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2009-2018 the original author(s).\n+ * Copyright (c) 2009-2018, the original author(s).\n@@ -4,3 +4,2 @@\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n@@ -8,7 +7,1 @@\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n@@ -255,3 +248,2 @@\n-        for (;;) {\n-            if (!optionsIterator.hasNext())\n-                throw new IllegalArgumentException();\n+        for (; ; ) {\n+            if (!optionsIterator.hasNext()) throw new IllegalArgumentException();\n@@ -259,2 +251,1 @@\n-            if (arg != null)\n-                return (Integer) arg;\n+            if (arg != null) return (Integer) arg;\n@@ -349,4 +340,2 @@\n-                                        if (value == 38)\n-                                            processSetForegroundColorExt(r, g, b);\n-                                        else\n-                                            processSetBackgroundColorExt(r, g, b);\n+                                        if (value == 38) processSetForegroundColorExt(r, g, b);\n+                                        else processSetBackgroundColorExt(r, g, b);\n@@ -356,2 +345,1 @@\n-                                }\n-                                else if (arg2or5 == 5) {\n+                                } else if (arg2or5 == 5) {\n@@ -361,4 +349,2 @@\n-                                        if (value == 38)\n-                                            processSetForegroundColorExt(paletteIndex);\n-                                        else\n-                                            processSetBackgroundColorExt(paletteIndex);\n+                                        if (value == 38) processSetForegroundColorExt(paletteIndex);\n+                                        else processSetBackgroundColorExt(paletteIndex);\n@@ -368,2 +354,1 @@\n-                                }\n-                                else {\n+                                } else {\n@@ -452,2 +437,1 @@\n-    protected void processRestoreCursorPosition() throws IOException {\n-    }\n+    protected void processRestoreCursorPosition() throws IOException {}\n@@ -459,2 +443,1 @@\n-    protected void processSaveCursorPosition() throws IOException {\n-    }\n+    protected void processSaveCursorPosition() throws IOException {}\n@@ -467,2 +450,1 @@\n-    protected void processInsertLine(int optionInt) throws IOException {\n-    }\n+    protected void processInsertLine(int optionInt) throws IOException {}\n@@ -475,2 +457,1 @@\n-    protected void processDeleteLine(int optionInt) throws IOException {\n-    }\n+    protected void processDeleteLine(int optionInt) throws IOException {}\n@@ -483,2 +464,1 @@\n-    protected void processScrollDown(int optionInt) throws IOException {\n-    }\n+    protected void processScrollDown(int optionInt) throws IOException {}\n@@ -491,2 +471,1 @@\n-    protected void processScrollUp(int optionInt) throws IOException {\n-    }\n+    protected void processScrollUp(int optionInt) throws IOException {}\n@@ -503,2 +482,1 @@\n-    protected void processEraseScreen(int eraseOption) throws IOException {\n-    }\n+    protected void processEraseScreen(int eraseOption) throws IOException {}\n@@ -515,2 +493,15 @@\n-    protected void processEraseLine(int eraseOption) throws IOException {\n-    }\n+    protected void processEraseLine(int eraseOption) throws IOException {}\n+\n+    protected static final int ATTRIBUTE_INTENSITY_BOLD = 1; \/\/  Intensity: Bold\n+    protected static final int ATTRIBUTE_INTENSITY_FAINT = 2; \/\/  Intensity; Faint  not widely supported\n+    protected static final int ATTRIBUTE_ITALIC = 3; \/\/  Italic; on  not widely supported. Sometimes treated as inverse.\n+    protected static final int ATTRIBUTE_UNDERLINE = 4; \/\/  Underline; Single\n+    protected static final int ATTRIBUTE_BLINK_SLOW = 5; \/\/  Blink; Slow  less than 150 per minute\n+    protected static final int ATTRIBUTE_BLINK_FAST = 6; \/\/  Blink; Rapid  MS-DOS ANSI.SYS; 150 per minute or more\n+    protected static final int ATTRIBUTE_NEGATIVE_ON =\n+            7; \/\/  Image; Negative  inverse or reverse; swap foreground and background\n+    protected static final int ATTRIBUTE_CONCEAL_ON = 8; \/\/  Conceal on\n+    protected static final int ATTRIBUTE_UNDERLINE_DOUBLE = 21; \/\/  Underline; Double  not widely supported\n+    protected static final int ATTRIBUTE_INTENSITY_NORMAL = 22; \/\/  Intensity; Normal  not bold and not faint\n+    protected static final int ATTRIBUTE_UNDERLINE_OFF = 24; \/\/  Underline; None\n+    protected static final int ATTRIBUTE_BLINK_OFF = 25; \/\/  Blink; off\n@@ -518,12 +509,0 @@\n-    protected static final int ATTRIBUTE_INTENSITY_BOLD = 1; \/\/         Intensity: Bold\n-    protected static final int ATTRIBUTE_INTENSITY_FAINT = 2; \/\/        Intensity; Faint        not widely supported\n-    protected static final int ATTRIBUTE_ITALIC = 3; \/\/         Italic; on      not widely supported. Sometimes treated as inverse.\n-    protected static final int ATTRIBUTE_UNDERLINE = 4; \/\/      Underline; Single\n-    protected static final int ATTRIBUTE_BLINK_SLOW = 5; \/\/     Blink; Slow     less than 150 per minute\n-    protected static final int ATTRIBUTE_BLINK_FAST = 6; \/\/     Blink; Rapid    MS-DOS ANSI.SYS; 150 per minute or more\n-    protected static final int ATTRIBUTE_NEGATIVE_ON = 7; \/\/    Image; Negative         inverse or reverse; swap foreground and background\n-    protected static final int ATTRIBUTE_CONCEAL_ON = 8; \/\/     Conceal on\n-    protected static final int ATTRIBUTE_UNDERLINE_DOUBLE = 21; \/\/      Underline; Double       not widely supported\n-    protected static final int ATTRIBUTE_INTENSITY_NORMAL = 22; \/\/      Intensity; Normal       not bold and not faint\n-    protected static final int ATTRIBUTE_UNDERLINE_OFF = 24; \/\/         Underline; None\n-    protected static final int ATTRIBUTE_BLINK_OFF = 25; \/\/     Blink; off\n@@ -532,0 +511,1 @@\n+\n@@ -533,1 +513,1 @@\n-    protected static final int ATTRIBUTE_CONCEAL_OFF = 28; \/\/   Reveal  conceal off\n+    protected static final int ATTRIBUTE_CONCEAL_OFF = 28; \/\/  Reveal  conceal off\n@@ -549,2 +529,1 @@\n-    protected void processSetAttribute(int attribute) throws IOException {\n-    }\n+    protected void processSetAttribute(int attribute) throws IOException {}\n@@ -587,2 +566,1 @@\n-    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {\n-    }\n+    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {}\n@@ -628,2 +606,1 @@\n-    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {\n-    }\n+    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {}\n@@ -647,2 +624,1 @@\n-    protected void processDefaultTextColor() throws IOException {\n-    }\n+    protected void processDefaultTextColor() throws IOException {}\n@@ -654,2 +630,1 @@\n-    protected void processDefaultBackgroundColor() throws IOException {\n-    }\n+    protected void processDefaultBackgroundColor() throws IOException {}\n@@ -661,2 +636,1 @@\n-    protected void processAttributeRest() throws IOException {\n-    }\n+    protected void processAttributeRest() throws IOException {}\n@@ -671,2 +645,1 @@\n-    protected void processCursorTo(int row, int col) throws IOException {\n-    }\n+    protected void processCursorTo(int row, int col) throws IOException {}\n@@ -679,2 +652,1 @@\n-    protected void processCursorToColumn(int x) throws IOException {\n-    }\n+    protected void processCursorToColumn(int x) throws IOException {}\n@@ -687,2 +659,1 @@\n-    protected void processCursorUpLine(int count) throws IOException {\n-    }\n+    protected void processCursorUpLine(int count) throws IOException {}\n@@ -707,2 +678,1 @@\n-    protected void processCursorLeft(int count) throws IOException {\n-    }\n+    protected void processCursorLeft(int count) throws IOException {}\n@@ -727,2 +697,1 @@\n-    protected void processCursorDown(int count) throws IOException {\n-    }\n+    protected void processCursorDown(int count) throws IOException {}\n@@ -735,2 +704,1 @@\n-    protected void processCursorUp(int count) throws IOException {\n-    }\n+    protected void processCursorUp(int count) throws IOException {}\n@@ -738,2 +706,1 @@\n-    protected void processUnknownExtension(ArrayList<Object> options, int command) {\n-    }\n+    protected void processUnknownExtension(ArrayList<Object> options, int command) {}\n@@ -754,2 +721,1 @@\n-    protected void processChangeIconName(String name) {\n-    }\n+    protected void processChangeIconName(String name) {}\n@@ -761,2 +727,1 @@\n-    protected void processChangeWindowTitle(String title) {\n-    }\n+    protected void processChangeWindowTitle(String title) {}\n@@ -769,2 +734,1 @@\n-    protected void processUnknownOperatingSystemCommand(int command, String param) {\n-    }\n+    protected void processUnknownOperatingSystemCommand(int command, String param) {}\n@@ -784,2 +748,1 @@\n-    protected void processCharsetSelect(int set, char seq) {\n-    }\n+    protected void processCharsetSelect(int set, char seq) {}\n@@ -788,2 +751,1 @@\n-        if (options.size() <= index)\n-            throw new IllegalArgumentException();\n+        if (options.size() <= index) throw new IllegalArgumentException();\n@@ -791,4 +753,2 @@\n-        if (value == null)\n-            throw new IllegalArgumentException();\n-        if (!value.getClass().equals(Integer.class))\n-            throw new IllegalArgumentException();\n+        if (value == null) throw new IllegalArgumentException();\n+        if (!value.getClass().equals(Integer.class)) throw new IllegalArgumentException();\n@@ -831,1 +791,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AnsiWriter.java","additions":57,"deletions":98,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -18,0 +18,1 @@\n+import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;\n@@ -33,0 +34,1 @@\n+import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;\n@@ -36,1 +38,0 @@\n-import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;\n@@ -38,1 +39,0 @@\n-import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;\n@@ -123,0 +123,1 @@\n+                \/\/ @spotless:off\n@@ -136,0 +137,1 @@\n+                \/\/ @spotless:on\n@@ -142,1 +144,1 @@\n-            long  s = styleCodeAt(i) & ~F_HIDDEN; \/\/ The hidden flag does not change the ansi styles\n+            long s = styleCodeAt(i) & ~F_HIDDEN; \/\/ The hidden flag does not change the ansi styles\n@@ -144,1 +146,1 @@\n-                long  d = (style ^ s) & MASK;\n+                long d = (style ^ s) & MASK;\n@@ -175,3 +177,3 @@\n-                                int r = (int)(fg >> (FG_COLOR_EXP + 16)) & 0xFF;\n-                                int g = (int)(fg >> (FG_COLOR_EXP + 8)) & 0xFF;\n-                                int b = (int)(fg >> FG_COLOR_EXP) & 0xFF;\n+                                int r = (int) (fg >> (FG_COLOR_EXP + 16)) & 0xFF;\n+                                int g = (int) (fg >> (FG_COLOR_EXP + 8)) & 0xFF;\n+                                int b = (int) (fg >> FG_COLOR_EXP) & 0xFF;\n@@ -184,1 +186,1 @@\n-                                rounded = palette.round((int)(fg >> FG_COLOR_EXP) & 0xFF);\n+                                rounded = palette.round((int) (fg >> FG_COLOR_EXP) & 0xFF);\n@@ -214,3 +216,3 @@\n-                                int r = (int)(bg >> (BG_COLOR_EXP + 16)) & 0xFF;\n-                                int g = (int)(bg >> (BG_COLOR_EXP + 8)) & 0xFF;\n-                                int b = (int)(bg >> BG_COLOR_EXP) & 0xFF;\n+                                int r = (int) (bg >> (BG_COLOR_EXP + 16)) & 0xFF;\n+                                int g = (int) (bg >> (BG_COLOR_EXP + 8)) & 0xFF;\n+                                int b = (int) (bg >> BG_COLOR_EXP) & 0xFF;\n@@ -223,1 +225,1 @@\n-                                rounded = palette.round((int)(bg >> BG_COLOR_EXP) & 0xFF);\n+                                rounded = palette.round((int) (bg >> BG_COLOR_EXP) & 0xFF);\n@@ -246,2 +248,1 @@\n-                        if (    (d & F_BOLD)  != 0 && (s & F_BOLD)  == 0\n-                                || (d & F_FAINT) != 0 && (s & F_FAINT) == 0) {\n+                        if ((d & F_BOLD) != 0 && (s & F_BOLD) == 0 || (d & F_FAINT) != 0 && (s & F_FAINT) == 0) {\n@@ -363,2 +364,1 @@\n-            if (!isHidden(cur))\n-                cols += WCWidth.wcwidth(cp);\n+            if (!isHidden(cur)) cols += WCWidth.wcwidth(cp);\n@@ -385,2 +385,1 @@\n-            if (cp == '\\n')\n-                break;\n+            if (cp == '\\n') break;\n@@ -410,1 +409,1 @@\n-                strings.add(subSequence(beg, includeNewlines ? cur+1 : cur));\n+                strings.add(subSequence(beg, includeNewlines ? cur + 1 : cur));\n@@ -432,1 +431,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedCharSequence.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -18,0 +18,2 @@\n+import jdk.internal.org.jline.terminal.Terminal;\n+\n@@ -106,0 +108,16 @@\n+        return fromAnsi(ansi, tabs, null, null);\n+    }\n+\n+    public static AttributedString fromAnsi(String ansi, Terminal terminal) {\n+        String alternateIn, alternateOut;\n+        if (!DISABLE_ALTERNATE_CHARSET) {\n+            alternateIn = Curses.tputs(terminal.getStringCapability(InfoCmp.Capability.enter_alt_charset_mode));\n+            alternateOut = Curses.tputs(terminal.getStringCapability(InfoCmp.Capability.exit_alt_charset_mode));\n+        } else {\n+            alternateIn = null;\n+            alternateOut = null;\n+        }\n+        return fromAnsi(ansi, Arrays.asList(0), alternateIn, alternateOut);\n+    }\n+\n+    public static AttributedString fromAnsi(String ansi, List<Integer> tabs, String altIn, String altOut) {\n@@ -111,0 +129,1 @@\n+                .altCharset(altIn, altOut)\n@@ -119,3 +138,1 @@\n-        return new AttributedStringBuilder(ansi.length())\n-                .ansiAppend(ansi)\n-                .toString();\n+        return new AttributedStringBuilder(ansi.length()).ansiAppend(ansi).toString();\n@@ -165,1 +182,1 @@\n-            return new AttributedString(buffer, newstyle, start , end);\n+            return new AttributedString(buffer, newstyle, start, end);\n@@ -182,1 +199,1 @@\n-            if (a1[s1+i] != a2[s2+i]) {\n+            if (a1[s1 + i] != a2[s2 + i]) {\n@@ -188,0 +205,1 @@\n+\n@@ -190,1 +208,1 @@\n-            if (a1[s1+i] != a2[s2+i]) {\n+            if (a1[s1 + i] != a2[s2 + i]) {\n@@ -224,1 +242,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedString.java","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -30,0 +30,3 @@\n+    private char[] altIn;\n+    private char[] altOut;\n+    private boolean inAltCharset;\n@@ -84,4 +87,1 @@\n-                Arrays.copyOfRange(buffer, start, end),\n-                Arrays.copyOfRange(style, start, end),\n-                0,\n-                end - start);\n+                Arrays.copyOfRange(buffer, start, end), Arrays.copyOfRange(style, start, end), 0, end - start);\n@@ -111,0 +111,8 @@\n+    public AttributedStringBuilder append(char c, int repeat) {\n+        AttributedString s = new AttributedString(Character.toString(c), current);\n+        while (repeat-- > 0) {\n+            append(s);\n+        }\n+        return this;\n+    }\n+\n@@ -120,1 +128,1 @@\n-    public AttributedStringBuilder style(Function<AttributedStyle,AttributedStyle> style) {\n+    public AttributedStringBuilder style(Function<AttributedStyle, AttributedStyle> style) {\n@@ -125,1 +133,1 @@\n-    public AttributedStringBuilder styled(Function<AttributedStyle,AttributedStyle> style, CharSequence cs) {\n+    public AttributedStringBuilder styled(Function<AttributedStyle, AttributedStyle> style, CharSequence cs) {\n@@ -133,1 +141,2 @@\n-    public AttributedStringBuilder styled(Function<AttributedStyle,AttributedStyle> style, Consumer<AttributedStringBuilder> consumer) {\n+    public AttributedStringBuilder styled(\n+            Function<AttributedStyle, AttributedStyle> style, Consumer<AttributedStringBuilder> consumer) {\n@@ -341,2 +350,0 @@\n-            } else if (c == '\\t' && tabs.defined()) {\n-                insertTab(current);\n@@ -344,5 +351,11 @@\n-                ensureCapacity(length + 1);\n-                buffer[length] = c;\n-                style[length] = this.current.getStyle();\n-                if (c == '\\n') {\n-                    lastLineLength = 0;\n+                if (ansiState >= 1) {\n+                    ensureCapacity(length + 1);\n+                    buffer[length++] = 27;\n+                    if (ansiState >= 2) {\n+                        ensureCapacity(length + 1);\n+                        buffer[length++] = '[';\n+                    }\n+                    ansiState = 0;\n+                }\n+                if (c == '\\t' && tabs.defined()) {\n+                    insertTab(current);\n@@ -350,1 +363,53 @@\n-                    lastLineLength++;\n+                    ensureCapacity(length + 1);\n+                    if (inAltCharset) {\n+                        switch (c) {\n+                            case 'j':\n+                                c = '\\u2518';\n+                                break;\n+                            case 'k':\n+                                c = '\\u2510';\n+                                break;\n+                            case 'l':\n+                                c = '\\u250C';\n+                                break;\n+                            case 'm':\n+                                c = '\\u2514';\n+                                break;\n+                            case 'n':\n+                                c = '\\u253C';\n+                                break;\n+                            case 'q':\n+                                c = '\\u2500';\n+                                break;\n+                            case 't':\n+                                c = '\\u251C';\n+                                break;\n+                            case 'u':\n+                                c = '\\u2524';\n+                                break;\n+                            case 'v':\n+                                c = '\\u2534';\n+                                break;\n+                            case 'w':\n+                                c = '\\u252C';\n+                                break;\n+                            case 'x':\n+                                c = '\\u2502';\n+                                break;\n+                        }\n+                    }\n+                    buffer[length] = c;\n+                    style[length] = this.current.getStyle();\n+                    if (c == '\\n') {\n+                        lastLineLength = 0;\n+                    } else {\n+                        lastLineLength++;\n+                    }\n+                    length++;\n+                    if (altIn != null && altOut != null) {\n+                        char[] alt = inAltCharset ? altOut : altIn;\n+                        if (equals(buffer, length - alt.length, alt, 0, alt.length)) {\n+                            inAltCharset = !inAltCharset;\n+                            length -= alt.length;\n+                        }\n+                    }\n@@ -352,1 +417,0 @@\n-                length++;\n@@ -358,0 +422,12 @@\n+    private static boolean equals(char[] a, int aFromIndex, char[] b, int bFromIndex, int length) {\n+        if (aFromIndex < 0 || bFromIndex < 0 || aFromIndex + length > a.length || bFromIndex + length > b.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < length; i++) {\n+            if (a[aFromIndex + i] != b[bFromIndex + i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -396,0 +472,9 @@\n+    public AttributedStringBuilder altCharset(String altIn, String altOut) {\n+        if (length > 0) {\n+            throw new IllegalStateException(\"Cannot change alternative charset after appending text\");\n+        }\n+        this.altIn = altIn != null ? altIn.toCharArray() : null;\n+        this.altOut = altOut != null ? altOut.toCharArray() : null;\n+        return this;\n+    }\n+\n@@ -419,1 +504,1 @@\n-    private class TabStops {\n+    private static class TabStops {\n@@ -431,1 +516,1 @@\n-            for (int s: tabs) {\n+            for (int s : tabs) {\n@@ -450,1 +535,1 @@\n-                for (int s: tabs) {\n+                for (int s : tabs) {\n@@ -459,1 +544,0 @@\n-\n@@ -461,1 +545,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedStringBuilder.java","additions":105,"deletions":22,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2021, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author(s).\n@@ -18,33 +18,33 @@\n-    public static final int BLACK =     0;\n-    public static final int RED =       1;\n-    public static final int GREEN =     2;\n-    public static final int YELLOW =    3;\n-    public static final int BLUE =      4;\n-    public static final int MAGENTA =   5;\n-    public static final int CYAN =      6;\n-    public static final int WHITE =     7;\n-\n-    public static final int BRIGHT =    8;\n-\n-    static final long F_BOLD            = 0x00000001;\n-    static final long F_FAINT           = 0x00000002;\n-    static final long F_ITALIC          = 0x00000004;\n-    static final long F_UNDERLINE       = 0x00000008;\n-    static final long F_BLINK           = 0x00000010;\n-    static final long F_INVERSE         = 0x00000020;\n-    static final long F_CONCEAL         = 0x00000040;\n-    static final long F_CROSSED_OUT     = 0x00000080;\n-    static final long F_FOREGROUND_IND  = 0x00000100;\n-    static final long F_FOREGROUND_RGB  = 0x00000200;\n-    static final long F_FOREGROUND      = F_FOREGROUND_IND | F_FOREGROUND_RGB;\n-    static final long F_BACKGROUND_IND  = 0x00000400;\n-    static final long F_BACKGROUND_RGB  = 0x00000800;\n-    static final long F_BACKGROUND      = F_BACKGROUND_IND | F_BACKGROUND_RGB;\n-    static final long F_HIDDEN          = 0x00001000;\n-\n-    static final long MASK           = 0x00001FFF;\n-\n-    static final int FG_COLOR_EXP    = 15;\n-    static final int BG_COLOR_EXP    = 39;\n-    static final long FG_COLOR        = 0xFFFFFFL << FG_COLOR_EXP;\n-    static final long BG_COLOR        = 0xFFFFFFL << BG_COLOR_EXP;\n+    public static final int BLACK = 0;\n+    public static final int RED = 1;\n+    public static final int GREEN = 2;\n+    public static final int YELLOW = 3;\n+    public static final int BLUE = 4;\n+    public static final int MAGENTA = 5;\n+    public static final int CYAN = 6;\n+    public static final int WHITE = 7;\n+\n+    public static final int BRIGHT = 8;\n+\n+    static final long F_BOLD = 0x00000001;\n+    static final long F_FAINT = 0x00000002;\n+    static final long F_ITALIC = 0x00000004;\n+    static final long F_UNDERLINE = 0x00000008;\n+    static final long F_BLINK = 0x00000010;\n+    static final long F_INVERSE = 0x00000020;\n+    static final long F_CONCEAL = 0x00000040;\n+    static final long F_CROSSED_OUT = 0x00000080;\n+    static final long F_FOREGROUND_IND = 0x00000100;\n+    static final long F_FOREGROUND_RGB = 0x00000200;\n+    static final long F_FOREGROUND = F_FOREGROUND_IND | F_FOREGROUND_RGB;\n+    static final long F_BACKGROUND_IND = 0x00000400;\n+    static final long F_BACKGROUND_RGB = 0x00000800;\n+    static final long F_BACKGROUND = F_BACKGROUND_IND | F_BACKGROUND_RGB;\n+    static final long F_HIDDEN = 0x00001000;\n+\n+    static final long MASK = 0x00001FFF;\n+\n+    static final int FG_COLOR_EXP = 15;\n+    static final int BG_COLOR_EXP = 39;\n+    static final long FG_COLOR = 0xFFFFFFL << FG_COLOR_EXP;\n+    static final long BG_COLOR = 0xFFFFFFL << BG_COLOR_EXP;\n@@ -73,2 +73,3 @@\n-        this.mask = mask & MASK | ((style & F_FOREGROUND) != 0 ? FG_COLOR : 0)\n-                                | ((style & F_BACKGROUND) != 0 ? BG_COLOR : 0);\n+        this.mask = mask & MASK\n+                | ((style & F_FOREGROUND) != 0 ? FG_COLOR : 0)\n+                | ((style & F_BACKGROUND) != 0 ? BG_COLOR : 0);\n@@ -179,1 +180,3 @@\n-        return new AttributedStyle(style & ~FG_COLOR | F_FOREGROUND_IND | (((long) color << FG_COLOR_EXP) & FG_COLOR), mask | F_FOREGROUND_IND);\n+        return new AttributedStyle(\n+                style & ~FG_COLOR | F_FOREGROUND_IND | (((long) color << FG_COLOR_EXP) & FG_COLOR),\n+                mask | F_FOREGROUND_IND);\n@@ -187,1 +190,3 @@\n-        return new AttributedStyle(style & ~FG_COLOR | F_FOREGROUND_RGB | ((((long) color & 0xFFFFFF) << FG_COLOR_EXP) & FG_COLOR), mask | F_FOREGROUND_RGB);\n+        return new AttributedStyle(\n+                style & ~FG_COLOR | F_FOREGROUND_RGB | ((((long) color & 0xFFFFFF) << FG_COLOR_EXP) & FG_COLOR),\n+                mask | F_FOREGROUND_RGB);\n@@ -199,1 +204,3 @@\n-        return new AttributedStyle(style & ~BG_COLOR | F_BACKGROUND_IND | (((long) color << BG_COLOR_EXP) & BG_COLOR), mask | F_BACKGROUND_IND);\n+        return new AttributedStyle(\n+                style & ~BG_COLOR | F_BACKGROUND_IND | (((long) color << BG_COLOR_EXP) & BG_COLOR),\n+                mask | F_BACKGROUND_IND);\n@@ -207,1 +214,3 @@\n-        return new AttributedStyle(style & ~BG_COLOR | F_BACKGROUND_RGB | ((((long) color & 0xFFFFFF) << BG_COLOR_EXP) & BG_COLOR), mask | F_BACKGROUND_RGB);\n+        return new AttributedStyle(\n+                style & ~BG_COLOR | F_BACKGROUND_RGB | ((((long) color & 0xFFFFFF) << BG_COLOR_EXP) & BG_COLOR),\n+                mask | F_BACKGROUND_RGB);\n@@ -252,1 +261,0 @@\n-\n@@ -269,5 +277,1 @@\n-        return \"AttributedStyle{\" +\n-                \"style=\" + style +\n-                \", mask=\" + mask +\n-                \", ansi=\" + toAnsi() +\n-                '}';\n+        return \"AttributedStyle{\" + \"style=\" + style + \", mask=\" + mask + \", ansi=\" + toAnsi() + '}';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedStyle.java","additions":50,"deletions":46,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -17,2 +17,1 @@\n-    public ClosedException() {\n-    }\n+    public ClosedException() {}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ClosedException.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -24,1 +24,2 @@\n-    public static final String XTERM_INITC = \"\\\\E]4;%p1%d;rgb\\\\:%p2%{255}%*%{1000}%\/%2.2X\/%p3%{255}%*%{1000}%\/%2.2X\/%p4%{255}%*%{1000}%\/%2.2X\\\\E\\\\\\\\\";\n+    public static final String XTERM_INITC =\n+            \"\\\\E]4;%p1%d;rgb\\\\:%p2%{255}%*%{1000}%\/%2.2X\/%p3%{255}%*%{1000}%\/%2.2X\/%p4%{255}%*%{1000}%\/%2.2X\\\\E\\\\\\\\\";\n@@ -44,0 +45,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -248,4 +250,7 @@\n-                double r = Integer.parseInt(rgb.get(0), 16) \/ ((1 << (4 * rgb.get(0).length())) - 1.0);\n-                double g = Integer.parseInt(rgb.get(1), 16) \/ ((1 << (4 * rgb.get(1).length())) - 1.0);\n-                double b = Integer.parseInt(rgb.get(2), 16) \/ ((1 << (4 * rgb.get(2).length())) - 1.0);\n-                palette[idx] = (int)((Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255));\n+                double r = Integer.parseInt(rgb.get(0), 16)\n+                        \/ ((1 << (4 * rgb.get(0).length())) - 1.0);\n+                double g = Integer.parseInt(rgb.get(1), 16)\n+                        \/ ((1 << (4 * rgb.get(1).length())) - 1.0);\n+                double b = Integer.parseInt(rgb.get(2), 16)\n+                        \/ ((1 << (4 * rgb.get(2).length())) - 1.0);\n+                palette[idx] = (int) ((Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255));\n@@ -259,1 +264,2 @@\n-        while (max > 0 && palette[--max] == 0);\n+        while (max > 0 && palette[--max] == 0)\n+            ;\n@@ -262,0 +268,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"ColorPalette[\" + \"length=\" + getLength() + \", \" + \"distance='\" + getDist() + \"\\']\";\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ColorPalette.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -24,0 +24,2 @@\n+    \/\/ @spotless:off\n+\n@@ -114,0 +116,2 @@\n+    \/\/ @spotless:on\n+\n@@ -115,1 +119,1 @@\n-    public static final double[] D50 = new double[] { 96.422f, 100.0f,  82.521f };\n+    public static final double[] D50 = new double[] {96.422f, 100.0f, 82.521f};\n@@ -117,1 +121,1 @@\n-    public static final double[] D65 = new double[] { 95.047, 100.0, 108.883 };\n+    public static final double[] D65 = new double[] {95.047, 100.0, 108.883};\n@@ -120,1 +124,1 @@\n-    public static final double[] averageSurrounding = new double[] { 1.0, 0.690, 1.0 };\n+    public static final double[] averageSurrounding = new double[] {1.0, 0.690, 1.0};\n@@ -122,1 +126,1 @@\n-    public static final double[] dimSurrounding =     new double[] { 0.9, 0.590, 0.9 };\n+    public static final double[] dimSurrounding = new double[] {0.9, 0.590, 0.9};\n@@ -124,1 +128,1 @@\n-    public static final double[] darkSurrounding =    new double[] { 0.8, 0.525, 0.8 };\n+    public static final double[] darkSurrounding = new double[] {0.8, 0.525, 0.8};\n@@ -127,1 +131,1 @@\n-    public static final double[] sRGB_encoding_environment = vc(D50,  64.0,  64.0\/5, dimSurrounding);\n+    public static final double[] sRGB_encoding_environment = vc(D50, 64.0, 64.0 \/ 5, dimSurrounding);\n@@ -129,1 +133,1 @@\n-    public static final double[] sRGB_typical_environment  = vc(D50, 200.0, 200.0\/5, averageSurrounding);\n+    public static final double[] sRGB_typical_environment = vc(D50, 200.0, 200.0 \/ 5, averageSurrounding);\n@@ -131,1 +135,1 @@\n-    public static final double[] AdobeRGB_environment      = vc(D65, 160.0, 160.0\/5, averageSurrounding);\n+    public static final double[] AdobeRGB_environment = vc(D65, 160.0, 160.0 \/ 5, averageSurrounding);\n@@ -152,2 +156,3 @@\n-                 BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n-                br.lines().map(String::trim)\n+                    BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n+                br.lines()\n+                        .map(String::trim)\n@@ -209,1 +214,1 @@\n-        return doGetDistance(dist);\n+        return new NamedDistance(dist, doGetDistance(dist));\n@@ -219,1 +224,1 @@\n-                double[] w = { 2.0 + rmean, 4.0, 3.0 - rmean };\n+                double[] w = {2.0 + rmean, 4.0, 3.0 - rmean};\n@@ -231,1 +236,1 @@\n-            return (p1, p2) -> scalar(rgb2cielab(p1), rgb2cielab(p2), new double[] { w[0], w[1], w[1] });\n+            return (p1, p2) -> scalar(rgb2cielab(p1), rgb2cielab(p2), new double[] {w[0], w[1], w[1]});\n@@ -254,1 +259,1 @@\n-                return scalar(c1, c2, new double[] { w[0], w[1], w[1] });\n+                return scalar(c1, c2, new double[] {w[0], w[1], w[1]});\n@@ -276,1 +281,2 @@\n-        String[] weights = dist.substring(dist.indexOf('(') + 1, dist.length() - 1).split(\",\");\n+        String[] weights =\n+                dist.substring(dist.indexOf('(') + 1, dist.length() - 1).split(\",\");\n@@ -281,3 +287,1 @@\n-        return sqr((c1[0] - c2[0]) * w[0])\n-             + sqr((c1[1] - c2[1]) * w[1])\n-             + sqr((c1[2] - c2[2]) * w[2]);\n+        return sqr((c1[0] - c2[0]) * w[0]) + sqr((c1[1] - c2[1]) * w[1]) + sqr((c1[2] - c2[2]) * w[2]);\n@@ -287,3 +291,21 @@\n-        return sqr(c1[0] - c2[0])\n-             + sqr(c1[1] - c2[1])\n-             + sqr(c1[2] - c2[2]);\n+        return sqr(c1[0] - c2[0]) + sqr(c1[1] - c2[1]) + sqr(c1[2] - c2[2]);\n+    }\n+\n+    private static class NamedDistance implements Distance {\n+        private final String name;\n+        private final Distance delegate;\n+\n+        public NamedDistance(String name, Distance delegate) {\n+            this.name = name;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public double compute(int c1, int c2) {\n+            return delegate.compute(c1, c2);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n@@ -328,1 +350,1 @@\n-        double G = 0.5 * (1.0 - Math.sqrt(c_star_average_ab_pot_7 \/ (c_star_average_ab_pot_7 + 6103515625.0))); \/\/25^7\n+        double G = 0.5 * (1.0 - Math.sqrt(c_star_average_ab_pot_7 \/ (c_star_average_ab_pot_7 + 6103515625.0))); \/\/ 25^7\n@@ -368,1 +390,2 @@\n-        double S_L = 1.0 + ((0.015 * L_prime_average_minus_50_square) \/ Math.sqrt(20.0 + L_prime_average_minus_50_square));\n+        double S_L =\n+                1.0 + ((0.015 * L_prime_average_minus_50_square) \/ Math.sqrt(20.0 + L_prime_average_minus_50_square));\n@@ -372,1 +395,2 @@\n-        double h_prime_average_minus_275_div_25_square = h_prime_average_minus_275_div_25 * h_prime_average_minus_275_div_25;\n+        double h_prime_average_minus_275_div_25_square =\n+                h_prime_average_minus_275_div_25 * h_prime_average_minus_275_div_25;\n@@ -376,2 +400,2 @@\n-        double R_C = 2.0 * Math.sqrt(C_prime_average_pot_7 \/ (C_prime_average_pot_7 + 6103515625.0)); \/\/25^7\n-        double R_T = - Math.sin(Math.toRadians(2.0 * delta_theta)) * R_C;\n+        double R_C = 2.0 * Math.sqrt(C_prime_average_pot_7 \/ (C_prime_average_pot_7 + 6103515625.0)); \/\/ 25^7\n+        double R_T = -Math.sin(Math.toRadians(2.0 * delta_theta)) * R_C;\n@@ -395,1 +419,1 @@\n-        return new double[] {sJ, a, b };\n+        return new double[] {sJ, a, b};\n@@ -399,1 +423,1 @@\n-        return camlch(c1, c2, new double[] { 1.0, 1.0, 1.0 });\n+        return camlch(c1, c2, new double[] {1.0, 1.0, 1.0});\n@@ -417,4 +441,2 @@\n-        if (difference > ch)\n-            difference -= c;\n-        if (difference < -ch)\n-            difference += c;\n+        if (difference > ch) difference -= c;\n+        if (difference < -ch) difference += c;\n@@ -426,3 +448,3 @@\n-        int g = (color >>  8) & 0xFF;\n-        int b = (color >>  0) & 0xFF;\n-        return new double[] { r \/ 255.0, g \/ 255.0, b \/ 255.0 };\n+        int g = (color >> 8) & 0xFF;\n+        int b = (color >> 0) & 0xFF;\n+        return new double[] {r \/ 255.0, g \/ 255.0, b \/ 255.0};\n@@ -457,1 +479,1 @@\n-        return new double[] { lch[0], lch[1] * Math.cos(lch[2] * toRad), lch[1] * Math.sin(lch[2] * toRad) };\n+        return new double[] {lch[0], lch[1] * Math.cos(lch[2] * toRad), lch[1] * Math.sin(lch[2] * toRad)};\n@@ -463,1 +485,1 @@\n-        return new double[] { cam[J], cam[M], cam[h] };\n+        return new double[] {cam[J], cam[M], cam[h]};\n@@ -481,1 +503,0 @@\n-\n@@ -486,1 +507,2 @@\n-        \/\/ calculate corresponding (sharpened) cone response considering various luminance level and surround conditions in D\n+        \/\/ calculate corresponding (sharpened) cone response considering various luminance level and surround conditions\n+        \/\/ in D\n@@ -504,1 +526,3 @@\n-        double t = e * Math.sqrt(Math.pow(a, 2.0) + Math.pow(b, 2.0)) \/ (RGBPrime_a[0] + RGBPrime_a[1] + 1.05 * RGBPrime_a[2]);\n+        double t = e\n+                * Math.sqrt(Math.pow(a, 2.0) + Math.pow(b, 2.0))\n+                \/ (RGBPrime_a[0] + RGBPrime_a[1] + 1.05 * RGBPrime_a[2]);\n@@ -508,1 +532,4 @@\n-        double C = Math.signum(t) * Math.pow(Math.abs(t), 0.9) * Math.sqrt(J \/ 100.0) * Math.pow(1.64- Math.pow(0.29, vc[VC_N]), 0.73);\n+        double C = Math.signum(t)\n+                * Math.pow(Math.abs(t), 0.9)\n+                * Math.sqrt(J \/ 100.0)\n+                * Math.pow(1.64 - Math.pow(0.29, vc[VC_N]), 0.73);\n@@ -513,1 +540,1 @@\n-        return new double[] { J, Q, C, M, s, H, h };\n+        return new double[] {J, Q, C, M, s, H, h};\n@@ -517,2 +544,1 @@\n-        if (h < 20.14)\n-            h = h + 360;\n+        if (h < 20.14) h = h + 360;\n@@ -520,1 +546,1 @@\n-        if (h >= 20.14 && h < 90.0) {  \/\/ index i = 1\n+        if (h >= 20.14 && h < 90.0) { \/\/ index i = 1\n@@ -526,1 +552,1 @@\n-        } else if (h < 237.53) {  \/\/ index i = 3\n+        } else if (h < 237.53) { \/\/ index i = 3\n@@ -529,1 +555,1 @@\n-        } else if (h <= 380.14) {  \/\/ index i = 4\n+        } else if (h <= 380.14) { \/\/ index i = 4\n@@ -533,2 +559,1 @@\n-            if (H <= 400.0 && H >= 399.999)\n-                H = 0;\n+            if (H <= 400.0 && H >= 399.999) H = 0;\n@@ -543,2 +568,2 @@\n-        for(int channel = 0; channel < RGB.length; channel++) {\n-            if(RGB[channel] >= 0) {\n+        for (int channel = 0; channel < RGB.length; channel++) {\n+            if (RGB[channel] >= 0) {\n@@ -556,1 +581,1 @@\n-        return new double[] { vc[VC_D_RGB_R] * RGB[0], vc[VC_D_RGB_G] * RGB[1], vc[VC_D_RGB_B] * RGB[2] };\n+        return new double[] {vc[VC_D_RGB_R] * RGB[0], vc[VC_D_RGB_G] * RGB[1], vc[VC_D_RGB_B] * RGB[2]};\n@@ -561,2 +586,2 @@\n-        RGBPrime[0] =  0.7409792 * RGB[0] + 0.2180250 * RGB[1] + 0.0410058 * RGB[2];\n-        RGBPrime[1] =  0.2853532 * RGB[0] + 0.6242014 * RGB[1] + 0.0904454 * RGB[2];\n+        RGBPrime[0] = 0.7409792 * RGB[0] + 0.2180250 * RGB[1] + 0.0410058 * RGB[2];\n+        RGBPrime[1] = 0.2853532 * RGB[0] + 0.6242014 * RGB[1] + 0.0904454 * RGB[2];\n@@ -569,1 +594,1 @@\n-        RGB[0] =  0.7328 * XYZ[0] + 0.4296 * XYZ[1] - 0.1624 * XYZ[2];\n+        RGB[0] = 0.7328 * XYZ[0] + 0.4296 * XYZ[1] - 0.1624 * XYZ[2];\n@@ -571,1 +596,1 @@\n-        RGB[2] =  0.0030 * XYZ[0] + 0.0136 * XYZ[1] + 0.9834 * XYZ[2];\n+        RGB[2] = 0.0030 * XYZ[0] + 0.0136 * XYZ[1] + 0.9834 * XYZ[2];\n@@ -584,2 +609,2 @@\n-    static final int VC_F =   5;\n-    static final int VC_C =   6;\n+    static final int VC_F = 5;\n+    static final int VC_C = 6;\n@@ -610,1 +635,2 @@\n-        double D = Math.max(0.0, Math.min(1.0, vc[VC_F] * (1.0 - (1.0 \/ 3.6) * Math.pow(Math.E, (-L_A - 42.0) \/ 92.0))));\n+        double D =\n+                Math.max(0.0, Math.min(1.0, vc[VC_F] * (1.0 - (1.0 \/ 3.6) * Math.pow(Math.E, (-L_A - 42.0) \/ 92.0))));\n@@ -613,3 +639,1 @@\n-                (D * Yw \/ RGB_w[0]) + (1.0 - D),\n-                (D * Yw \/ RGB_w[1]) + (1.0 - D),\n-                (D * Yw \/ RGB_w[2]) + (1.0 - D),\n+            (D * Yw \/ RGB_w[0]) + (1.0 - D), (D * Yw \/ RGB_w[1]) + (1.0 - D), (D * Yw \/ RGB_w[2]) + (1.0 - D),\n@@ -622,1 +646,1 @@\n-        vc[VC_F_L] = 0.2 * kpow4 * (L_Ax5) + 0.1 * Math.pow(1.0 - kpow4, 2.0) * Math.pow(L_Ax5, 1.0\/3.0);\n+        vc[VC_F_L] = 0.2 * kpow4 * (L_Ax5) + 0.1 * Math.pow(1.0 - kpow4, 2.0) * Math.pow(L_Ax5, 1.0 \/ 3.0);\n@@ -629,1 +653,2 @@\n-        vc[VC_N_CB] = vc[VC_N_BB]; \/\/ chromatic contrast factors (calculate increase in J, Q, and C caused by dark backgrounds)\n+        vc[VC_N_CB] = vc[\n+                VC_N_BB]; \/\/ chromatic contrast factors (calculate increase in J, Q, and C caused by dark backgrounds)\n@@ -635,2 +660,2 @@\n-        for(int channel = 0; channel < RGBPrime_w.length; channel++) {\n-            if(RGBPrime_w[channel] >= 0) {\n+        for (int channel = 0; channel < RGBPrime_w.length; channel++) {\n+            if (RGBPrime_w[channel] >= 0) {\n@@ -663,1 +688,1 @@\n-        return new double[] { x, y, z };\n+        return new double[] {x, y, z};\n@@ -677,1 +702,1 @@\n-        return new double[] { l, a, b };\n+        return new double[] {l, a, b};\n@@ -682,0 +707,1 @@\n+\n@@ -689,1 +715,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Colors.java","additions":95,"deletions":70,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -32,2 +32,1 @@\n-    private Curses() {\n-    }\n+    private Curses() {}\n@@ -98,3 +97,3 @@\n-\/\/                        case 'l':\n-\/\/                            rawPrint('\\l');\n-\/\/                            break;\n+                                \/\/                        case 'l':\n+                                \/\/                            rawPrint('\\l');\n+                                \/\/                            break;\n@@ -141,1 +140,1 @@\n-                        out.append((char)(ch - '@'));\n+                        out.append((char) (ch - '@'));\n@@ -198,1 +197,2 @@\n-                            while (str.charAt(index++) != '}') ;\n+                            while (str.charAt(index++) != '}')\n+                                ;\n@@ -367,4 +367,12 @@\n-                                    case '-': left = true; break;\n-                                    case '+': plus = true; break;\n-                                    case '#': alternate = true; break;\n-                                    case ' ': space = true; break;\n+                                    case '-':\n+                                        left = true;\n+                                        break;\n+                                    case '+':\n+                                        plus = true;\n+                                        break;\n+                                    case '#':\n+                                        alternate = true;\n+                                        break;\n+                                    case ' ':\n+                                        space = true;\n+                                        break;\n@@ -476,1 +484,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Curses.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -28,1 +28,3 @@\n-        DELETE, INSERT, EQUAL\n+        DELETE,\n+        INSERT,\n+        EQUAL\n@@ -89,4 +91,2 @@\n-                if (startHiddenRange < 0)\n-                    startHiddenRange = commonStart;\n-            } else\n-                startHiddenRange = -1;\n+                if (startHiddenRange < 0) startHiddenRange = commonStart;\n+            } else startHiddenRange = -1;\n@@ -96,3 +96,2 @@\n-            && ((l1 > commonStart && text1.isHidden(commonStart))\n-                || (l2 > commonStart && text2.isHidden(commonStart))))\n-            commonStart = startHiddenRange;\n+                && ((l1 > commonStart && text1.isHidden(commonStart))\n+                        || (l2 > commonStart && text2.isHidden(commonStart)))) commonStart = startHiddenRange;\n@@ -106,4 +105,2 @@\n-                if (startHiddenRange < 0)\n-                    startHiddenRange = commonEnd;\n-            } else\n-                startHiddenRange = -1;\n+                if (startHiddenRange < 0) startHiddenRange = commonEnd;\n+            } else startHiddenRange = -1;\n@@ -112,2 +109,1 @@\n-        if (startHiddenRange >= 0)\n-            commonEnd = startHiddenRange;\n+        if (startHiddenRange >= 0) commonEnd = startHiddenRange;\n@@ -116,2 +112,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.EQUAL,\n-                    text1.subSequence(0, commonStart)));\n+            diffs.add(new Diff(DiffHelper.Operation.EQUAL, text1.subSequence(0, commonStart)));\n@@ -120,2 +115,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.INSERT,\n-                    text2.subSequence(commonStart, l2 - commonEnd)));\n+            diffs.add(new Diff(DiffHelper.Operation.INSERT, text2.subSequence(commonStart, l2 - commonEnd)));\n@@ -124,2 +118,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.DELETE,\n-                    text1.subSequence(commonStart, l1 - commonEnd)));\n+            diffs.add(new Diff(DiffHelper.Operation.DELETE, text1.subSequence(commonStart, l1 - commonEnd)));\n@@ -128,2 +121,1 @@\n-            diffs.add(new Diff(DiffHelper.Operation.EQUAL,\n-                    text1.subSequence(l1 - commonEnd, l1)));\n+            diffs.add(new Diff(DiffHelper.Operation.EQUAL, text1.subSequence(l1 - commonEnd, l1)));\n@@ -133,1 +125,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/DiffHelper.java","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -40,2 +40,2 @@\n-    private int columns;\n-    private int columns1; \/\/ columns+1\n+    protected int columns;\n+    protected int columns1; \/\/ columns+1\n@@ -52,0 +52,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -57,1 +58,1 @@\n-                            && can(Capability.delete_line, Capability.parm_delete_line);\n+                && can(Capability.delete_line, Capability.parm_delete_line);\n@@ -59,2 +60,1 @@\n-        this.delayedWrapAtEol = this.wrapAtEol\n-            && terminal.getBooleanCapability(Capability.eat_newline_glitch);\n+        this.delayedWrapAtEol = this.wrapAtEol && terminal.getBooleanCapability(Capability.eat_newline_glitch);\n@@ -72,1 +72,4 @@\n-    public void setDelayLineWrap(boolean v) { delayLineWrap = v; }\n+\n+    public void setDelayLineWrap(boolean v) {\n+        delayLineWrap = v;\n+    }\n@@ -76,0 +79,2 @@\n+            \/\/ OpenJDK patch. Original code assigned 1 to columns, which ended up\n+            \/\/ appending \" \\b\" to the prompt in certain cases.\n@@ -83,1 +88,2 @@\n-            oldLines = AttributedString.join(AttributedString.EMPTY, oldLines).columnSplitLength(columns, true, delayLineWrap());\n+            oldLines = AttributedString.join(AttributedString.EMPTY, oldLines)\n+                    .columnSplitLength(columns, true, delayLineWrap());\n@@ -131,1 +137,2 @@\n-            newLines = newLines.stream().map(s -> new AttributedString(s.toString()))\n+            newLines = newLines.stream()\n+                    .map(s -> new AttributedString(s.toString()))\n@@ -141,2 +148,1 @@\n-            while (nbHeaders < l\n-                   && Objects.equals(newLines.get(nbHeaders), oldLines.get(nbHeaders))) {\n+            while (nbHeaders < l && Objects.equals(newLines.get(nbHeaders), oldLines.get(nbHeaders))) {\n@@ -146,1 +152,3 @@\n-                    && Objects.equals(newLines.get(newLines.size() - nbFooters - 1), oldLines.get(oldLines.size() - nbFooters - 1))) {\n+                    && Objects.equals(\n+                            newLines.get(newLines.size() - nbFooters - 1),\n+                            oldLines.get(oldLines.size() - nbFooters - 1))) {\n@@ -193,6 +201,2 @@\n-            AttributedString oldLine =\n-                lineIndex < oldLines.size() ? oldLines.get(lineIndex)\n-                : AttributedString.NEWLINE;\n-            AttributedString newLine =\n-                 lineIndex < newLines.size() ? newLines.get(lineIndex)\n-                : AttributedString.NEWLINE;\n+            AttributedString oldLine = lineIndex < oldLines.size() ? oldLines.get(lineIndex) : AttributedString.NEWLINE;\n+            AttributedString newLine = lineIndex < newLines.size() ? newLines.get(lineIndex) : AttributedString.NEWLINE;\n@@ -203,2 +207,2 @@\n-            boolean oldNL = oldLength > 0 && oldLine.charAt(oldLength-1)=='\\n';\n-            boolean newNL = newLength > 0 && newLine.charAt(newLength-1)=='\\n';\n+            boolean oldNL = oldLength > 0 && oldLine.charAt(oldLength - 1) == '\\n';\n+            boolean newNL = newLength > 0 && newLine.charAt(newLength - 1) == '\\n';\n@@ -213,3 +217,1 @@\n-            if (wrapNeeded\n-                && lineIndex == (cursorPos + 1) \/ columns1\n-                && lineIndex < newLines.size()) {\n+            if (wrapNeeded && lineIndex == (cursorPos + 1) \/ columns1 && lineIndex < newLines.size()) {\n@@ -253,2 +255,1 @@\n-                        if (i <= diffs.size() - 2\n-                                && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n+                        if (i <= diffs.size() - 2 && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n@@ -285,2 +286,1 @@\n-                        if (i <= diffs.size() - 2\n-                                && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n+                        if (i <= diffs.size() - 2 && diffs.get(i + 1).operation == DiffHelper.Operation.EQUAL) {\n@@ -308,4 +308,2 @@\n-            boolean newWrap = ! newNL && lineIndex < newLines.size();\n-            if (targetCursorPos + 1 == lineIndex * columns1\n-                && (newWrap || ! delayLineWrap))\n-                targetCursorPos++;\n+            boolean newWrap = !newNL && lineIndex < newLines.size();\n+            if (targetCursorPos + 1 == lineIndex * columns1 && (newWrap || !delayLineWrap)) targetCursorPos++;\n@@ -315,7 +313,5 @@\n-                boolean oldWrap = ! oldNL && lineIndex < oldLines.size();\n-                if (newWrap != oldWrap && ! (oldWrap && cleared)) {\n-                    moveVisualCursorTo(lineIndex*columns1-1, newLines);\n-                    if (newWrap)\n-                        wrapNeeded = true;\n-                    else\n-                        terminal.puts(Capability.clr_eol);\n+                boolean oldWrap = !oldNL && lineIndex < oldLines.size();\n+                if (newWrap != oldWrap && !(oldWrap && cleared)) {\n+                    moveVisualCursorTo(lineIndex * columns1 - 1, newLines);\n+                    if (newWrap) wrapNeeded = true;\n+                    else terminal.puts(Capability.clr_eol);\n@@ -325,2 +321,4 @@\n-                    terminal.writer().write(\" \\b\");\n-                    cursorPos++;\n+                    if (!fullScreen || (fullScreen && lineIndex < numLines)) {\n+                        terminal.writer().write(\" \\b\");\n+                        cursorPos++;\n+                    }\n@@ -361,2 +359,1 @@\n-        return terminal.getStringCapability(single) != null\n-                || terminal.getStringCapability(multi) != null;\n+        return terminal.getStringCapability(single) != null || terminal.getStringCapability(multi) != null;\n@@ -408,1 +405,1 @@\n-        return max != 0 ? new int[] { start1, start2, max } : null;\n+        return max != 0 ? new int[] {start1, start2, max} : null;\n@@ -416,2 +413,1 @@\n-    protected void moveVisualCursorTo(int targetPos,\n-                                      List<AttributedString> newLines) {\n+    protected void moveVisualCursorTo(int targetPos, List<AttributedString> newLines) {\n@@ -425,6 +421,5 @@\n-                AttributedString lastChar = row >= newLines.size() ? AttributedString.EMPTY\n-                    : newLines.get(row).columnSubSequence(columns-1, columns);\n-                if (lastChar.length() == 0)\n-                    rawPrint((int) ' ');\n-                else\n-                    rawPrint(lastChar);\n+                AttributedString lastChar = row >= newLines.size()\n+                        ? AttributedString.EMPTY\n+                        : newLines.get(row).columnSubSequence(columns - 1, columns);\n+                if (lastChar.length() == 0) rawPrint((int) ' ');\n+                else rawPrint(lastChar);\n@@ -502,1 +497,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":46,"deletions":52,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -25,2 +25,1 @@\n-    private ExecHelper() {\n-    }\n+    private ExecHelper() {}\n@@ -34,1 +33,1 @@\n-                Map<String,String> env = pb.environment();\n+                Map<String, String> env = pb.environment();\n@@ -93,1 +92,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ExecHelper.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2009-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.utils;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+\/**\n+ * A simple buffering output stream with no synchronization.\n+ *\/\n+public class FastBufferedOutputStream extends FilterOutputStream {\n+\n+    protected final byte[] buf = new byte[8192];\n+    protected int count;\n+\n+    public FastBufferedOutputStream(OutputStream out) {\n+        super(out);\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        if (count >= buf.length) {\n+            flushBuffer();\n+        }\n+        buf[count++] = (byte) b;\n+    }\n+\n+    @Override\n+    public void write(byte b[], int off, int len) throws IOException {\n+        if (len >= buf.length) {\n+            flushBuffer();\n+            out.write(b, off, len);\n+            return;\n+        }\n+        if (len > buf.length - count) {\n+            flushBuffer();\n+        }\n+        System.arraycopy(b, off, buf, count, len);\n+        count += len;\n+    }\n+\n+    private void flushBuffer() throws IOException {\n+        if (count > 0) {\n+            out.write(buf, 0, count);\n+            count = 0;\n+        }\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        flushBuffer();\n+        out.flush();\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/FastBufferedOutputStream.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -31,2 +31,1 @@\n-    private InfoCmp() {\n-    }\n+    private InfoCmp() {}\n@@ -36,465 +35,464 @@\n-\n-        auto_left_margin,           \/\/ auto_left_margin, bw, bw\n-        auto_right_margin,          \/\/ auto_right_margin, am, am\n-        back_color_erase,           \/\/ back_color_erase, bce, ut\n-        can_change,                 \/\/ can_change, ccc, cc\n-        ceol_standout_glitch,       \/\/ ceol_standout_glitch, xhp, xs\n-        col_addr_glitch,            \/\/ col_addr_glitch, xhpa, YA\n-        cpi_changes_res,            \/\/ cpi_changes_res, cpix, YF\n-        cr_cancels_micro_mode,      \/\/ cr_cancels_micro_mode, crxm, YB\n-        dest_tabs_magic_smso,       \/\/ dest_tabs_magic_smso, xt, xt\n-        eat_newline_glitch,         \/\/ eat_newline_glitch, xenl, xn\n-        erase_overstrike,           \/\/ erase_overstrike, eo, eo\n-        generic_type,               \/\/ generic_type, gn, gn\n-        hard_copy,                  \/\/ hard_copy, hc, hc\n-        hard_cursor,                \/\/ hard_cursor, chts, HC\n-        has_meta_key,               \/\/ has_meta_key, km, km\n-        has_print_wheel,            \/\/ has_print_wheel, daisy, YC\n-        has_status_line,            \/\/ has_status_line, hs, hs\n-        hue_lightness_saturation,   \/\/ hue_lightness_saturation, hls, hl\n-        insert_null_glitch,         \/\/ insert_null_glitch, in, in\n-        lpi_changes_res,            \/\/ lpi_changes_res, lpix, YG\n-        memory_above,               \/\/ memory_above, da, da\n-        memory_below,               \/\/ memory_below, db, db\n-        move_insert_mode,           \/\/ move_insert_mode, mir, mi\n-        move_standout_mode,         \/\/ move_standout_mode, msgr, ms\n-        needs_xon_xoff,             \/\/ needs_xon_xoff, nxon, nx\n-        no_esc_ctlc,                \/\/ no_esc_ctlc, xsb, xb\n-        no_pad_char,                \/\/ no_pad_char, npc, NP\n-        non_dest_scroll_region,     \/\/ non_dest_scroll_region, ndscr, ND\n-        non_rev_rmcup,              \/\/ non_rev_rmcup, nrrmc, NR\n-        over_strike,                \/\/ over_strike, os, os\n-        prtr_silent,                \/\/ prtr_silent, mc5i, 5i\n-        row_addr_glitch,            \/\/ row_addr_glitch, xvpa, YD\n-        semi_auto_right_margin,     \/\/ semi_auto_right_margin, sam, YE\n-        status_line_esc_ok,         \/\/ status_line_esc_ok, eslok, es\n-        tilde_glitch,               \/\/ tilde_glitch, hz, hz\n-        transparent_underline,      \/\/ transparent_underline, ul, ul\n-        xon_xoff,                   \/\/ xon_xoff, xon, xo\n-        columns,                    \/\/ columns, cols, co\n-        init_tabs,                  \/\/ init_tabs, it, it\n-        label_height,               \/\/ label_height, lh, lh\n-        label_width,                \/\/ label_width, lw, lw\n-        lines,                      \/\/ lines, lines, li\n-        lines_of_memory,            \/\/ lines_of_memory, lm, lm\n-        magic_cookie_glitch,        \/\/ magic_cookie_glitch, xmc, sg\n-        max_attributes,             \/\/ max_attributes, ma, ma\n-        max_colors,                 \/\/ max_colors, colors, Co\n-        max_pairs,                  \/\/ max_pairs, pairs, pa\n-        maximum_windows,            \/\/ maximum_windows, wnum, MW\n-        no_color_video,             \/\/ no_color_video, ncv, NC\n-        num_labels,                 \/\/ num_labels, nlab, Nl\n-        padding_baud_rate,          \/\/ padding_baud_rate, pb, pb\n-        virtual_terminal,           \/\/ virtual_terminal, vt, vt\n-        width_status_line,          \/\/ width_status_line, wsl, ws\n-        bit_image_entwining,        \/\/ bit_image_entwining, bitwin, Yo\n-        bit_image_type,             \/\/ bit_image_type, bitype, Yp\n-        buffer_capacity,            \/\/ buffer_capacity, bufsz, Ya\n-        buttons,                    \/\/ buttons, btns, BT\n-        dot_horz_spacing,           \/\/ dot_horz_spacing, spinh, Yc\n-        dot_vert_spacing,           \/\/ dot_vert_spacing, spinv, Yb\n-        max_micro_address,          \/\/ max_micro_address, maddr, Yd\n-        max_micro_jump,             \/\/ max_micro_jump, mjump, Ye\n-        micro_col_size,             \/\/ micro_col_size, mcs, Yf\n-        micro_line_size,            \/\/ micro_line_size, mls, Yg\n-        number_of_pins,             \/\/ number_of_pins, npins, Yh\n-        output_res_char,            \/\/ output_res_char, orc, Yi\n-        output_res_horz_inch,       \/\/ output_res_horz_inch, orhi, Yk\n-        output_res_line,            \/\/ output_res_line, orl, Yj\n-        output_res_vert_inch,       \/\/ output_res_vert_inch, orvi, Yl\n-        print_rate,                 \/\/ print_rate, cps, Ym\n-        wide_char_size,             \/\/ wide_char_size, widcs, Yn\n-        acs_chars,                  \/\/ acs_chars, acsc, ac\n-        back_tab,                   \/\/ back_tab, cbt, bt\n-        bell,                       \/\/ bell, bel, bl\n-        carriage_return,            \/\/ carriage_return, cr, cr\n-        change_char_pitch,          \/\/ change_char_pitch, cpi, ZA\n-        change_line_pitch,          \/\/ change_line_pitch, lpi, ZB\n-        change_res_horz,            \/\/ change_res_horz, chr, ZC\n-        change_res_vert,            \/\/ change_res_vert, cvr, ZD\n-        change_scroll_region,       \/\/ change_scroll_region, csr, cs\n-        char_padding,               \/\/ char_padding, rmp, rP\n-        clear_all_tabs,             \/\/ clear_all_tabs, tbc, ct\n-        clear_margins,              \/\/ clear_margins, mgc, MC\n-        clear_screen,               \/\/ clear_screen, clear, cl\n-        clr_bol,                    \/\/ clr_bol, el1, cb\n-        clr_eol,                    \/\/ clr_eol, el, ce\n-        clr_eos,                    \/\/ clr_eos, ed, cd\n-        column_address,             \/\/ column_address, hpa, ch\n-        command_character,          \/\/ command_character, cmdch, CC\n-        create_window,              \/\/ create_window, cwin, CW\n-        cursor_address,             \/\/ cursor_address, cup, cm\n-        cursor_down,                \/\/ cursor_down, cud1, do\n-        cursor_home,                \/\/ cursor_home, home, ho\n-        cursor_invisible,           \/\/ cursor_invisible, civis, vi\n-        cursor_left,                \/\/ cursor_left, cub1, le\n-        cursor_mem_address,         \/\/ cursor_mem_address, mrcup, CM\n-        cursor_normal,              \/\/ cursor_normal, cnorm, ve\n-        cursor_right,               \/\/ cursor_right, cuf1, nd\n-        cursor_to_ll,               \/\/ cursor_to_ll, ll, ll\n-        cursor_up,                  \/\/ cursor_up, cuu1, up\n-        cursor_visible,             \/\/ cursor_visible, cvvis, vs\n-        define_char,                \/\/ define_char, defc, ZE\n-        delete_character,           \/\/ delete_character, dch1, dc\n-        delete_line,                \/\/ delete_line, dl1, dl\n-        dial_phone,                 \/\/ dial_phone, dial, DI\n-        dis_status_line,            \/\/ dis_status_line, dsl, ds\n-        display_clock,              \/\/ display_clock, dclk, DK\n-        down_half_line,             \/\/ down_half_line, hd, hd\n-        ena_acs,                    \/\/ ena_acs, enacs, eA\n-        enter_alt_charset_mode,     \/\/ enter_alt_charset_mode, smacs, as\n-        enter_am_mode,              \/\/ enter_am_mode, smam, SA\n-        enter_blink_mode,           \/\/ enter_blink_mode, blink, mb\n-        enter_bold_mode,            \/\/ enter_bold_mode, bold, md\n-        enter_ca_mode,              \/\/ enter_ca_mode, smcup, ti\n-        enter_delete_mode,          \/\/ enter_delete_mode, smdc, dm\n-        enter_dim_mode,             \/\/ enter_dim_mode, dim, mh\n-        enter_doublewide_mode,      \/\/ enter_doublewide_mode, swidm, ZF\n-        enter_draft_quality,        \/\/ enter_draft_quality, sdrfq, ZG\n-        enter_insert_mode,          \/\/ enter_insert_mode, smir, im\n-        enter_italics_mode,         \/\/ enter_italics_mode, sitm, ZH\n-        enter_leftward_mode,        \/\/ enter_leftward_mode, slm, ZI\n-        enter_micro_mode,           \/\/ enter_micro_mode, smicm, ZJ\n-        enter_near_letter_quality,  \/\/ enter_near_letter_quality, snlq, ZK\n-        enter_normal_quality,       \/\/ enter_normal_quality, snrmq, ZL\n-        enter_protected_mode,       \/\/ enter_protected_mode, prot, mp\n-        enter_reverse_mode,         \/\/ enter_reverse_mode, rev, mr\n-        enter_secure_mode,          \/\/ enter_secure_mode, invis, mk\n-        enter_shadow_mode,          \/\/ enter_shadow_mode, sshm, ZM\n-        enter_standout_mode,        \/\/ enter_standout_mode, smso, so\n-        enter_subscript_mode,       \/\/ enter_subscript_mode, ssubm, ZN\n-        enter_superscript_mode,     \/\/ enter_superscript_mode, ssupm, ZO\n-        enter_underline_mode,       \/\/ enter_underline_mode, smul, us\n-        enter_upward_mode,          \/\/ enter_upward_mode, sum, ZP\n-        enter_xon_mode,             \/\/ enter_xon_mode, smxon, SX\n-        erase_chars,                \/\/ erase_chars, ech, ec\n-        exit_alt_charset_mode,      \/\/ exit_alt_charset_mode, rmacs, ae\n-        exit_am_mode,               \/\/ exit_am_mode, rmam, RA\n-        exit_attribute_mode,        \/\/ exit_attribute_mode, sgr0, me\n-        exit_ca_mode,               \/\/ exit_ca_mode, rmcup, te\n-        exit_delete_mode,           \/\/ exit_delete_mode, rmdc, ed\n-        exit_doublewide_mode,       \/\/ exit_doublewide_mode, rwidm, ZQ\n-        exit_insert_mode,           \/\/ exit_insert_mode, rmir, ei\n-        exit_italics_mode,          \/\/ exit_italics_mode, ritm, ZR\n-        exit_leftward_mode,         \/\/ exit_leftward_mode, rlm, ZS\n-        exit_micro_mode,            \/\/ exit_micro_mode, rmicm, ZT\n-        exit_shadow_mode,           \/\/ exit_shadow_mode, rshm, ZU\n-        exit_standout_mode,         \/\/ exit_standout_mode, rmso, se\n-        exit_subscript_mode,        \/\/ exit_subscript_mode, rsubm, ZV\n-        exit_superscript_mode,      \/\/ exit_superscript_mode, rsupm, ZW\n-        exit_underline_mode,        \/\/ exit_underline_mode, rmul, ue\n-        exit_upward_mode,           \/\/ exit_upward_mode, rum, ZX\n-        exit_xon_mode,              \/\/ exit_xon_mode, rmxon, RX\n-        fixed_pause,                \/\/ fixed_pause, pause, PA\n-        flash_hook,                 \/\/ flash_hook, hook, fh\n-        flash_screen,               \/\/ flash_screen, flash, vb\n-        form_feed,                  \/\/ form_feed, ff, ff\n-        from_status_line,           \/\/ from_status_line, fsl, fs\n-        goto_window,                \/\/ goto_window, wingo, WG\n-        hangup,                     \/\/ hangup, hup, HU\n-        init_1string,               \/\/ init_1string, is1, i1\n-        init_2string,               \/\/ init_2string, is2, is\n-        init_3string,               \/\/ init_3string, is3, i3\n-        init_file,                  \/\/ init_file, if, if\n-        init_prog,                  \/\/ init_prog, iprog, iP\n-        initialize_color,           \/\/ initialize_color, initc, Ic\n-        initialize_pair,            \/\/ initialize_pair, initp, Ip\n-        insert_character,           \/\/ insert_character, ich1, ic\n-        insert_line,                \/\/ insert_line, il1, al\n-        insert_padding,             \/\/ insert_padding, ip, ip\n-        key_a1,                     \/\/ key_a1, ka1, K1\n-        key_a3,                     \/\/ key_a3, ka3, K3\n-        key_b2,                     \/\/ key_b2, kb2, K2\n-        key_backspace,              \/\/ key_backspace, kbs, kb\n-        key_beg,                    \/\/ key_beg, kbeg, @1\n-        key_btab,                   \/\/ key_btab, kcbt, kB\n-        key_c1,                     \/\/ key_c1, kc1, K4\n-        key_c3,                     \/\/ key_c3, kc3, K5\n-        key_cancel,                 \/\/ key_cancel, kcan, @2\n-        key_catab,                  \/\/ key_catab, ktbc, ka\n-        key_clear,                  \/\/ key_clear, kclr, kC\n-        key_close,                  \/\/ key_close, kclo, @3\n-        key_command,                \/\/ key_command, kcmd, @4\n-        key_copy,                   \/\/ key_copy, kcpy, @5\n-        key_create,                 \/\/ key_create, kcrt, @6\n-        key_ctab,                   \/\/ key_ctab, kctab, kt\n-        key_dc,                     \/\/ key_dc, kdch1, kD\n-        key_dl,                     \/\/ key_dl, kdl1, kL\n-        key_down,                   \/\/ key_down, kcud1, kd\n-        key_eic,                    \/\/ key_eic, krmir, kM\n-        key_end,                    \/\/ key_end, kend, @7\n-        key_enter,                  \/\/ key_enter, kent, @8\n-        key_eol,                    \/\/ key_eol, kel, kE\n-        key_eos,                    \/\/ key_eos, ked, kS\n-        key_exit,                   \/\/ key_exit, kext, @9\n-        key_f0,                     \/\/ key_f0, kf0, k0\n-        key_f1,                     \/\/ key_f1, kf1, k1\n-        key_f10,                    \/\/ key_f10, kf10, k;\n-        key_f11,                    \/\/ key_f11, kf11, F1\n-        key_f12,                    \/\/ key_f12, kf12, F2\n-        key_f13,                    \/\/ key_f13, kf13, F3\n-        key_f14,                    \/\/ key_f14, kf14, F4\n-        key_f15,                    \/\/ key_f15, kf15, F5\n-        key_f16,                    \/\/ key_f16, kf16, F6\n-        key_f17,                    \/\/ key_f17, kf17, F7\n-        key_f18,                    \/\/ key_f18, kf18, F8\n-        key_f19,                    \/\/ key_f19, kf19, F9\n-        key_f2,                     \/\/ key_f2, kf2, k2\n-        key_f20,                    \/\/ key_f20, kf20, FA\n-        key_f21,                    \/\/ key_f21, kf21, FB\n-        key_f22,                    \/\/ key_f22, kf22, FC\n-        key_f23,                    \/\/ key_f23, kf23, FD\n-        key_f24,                    \/\/ key_f24, kf24, FE\n-        key_f25,                    \/\/ key_f25, kf25, FF\n-        key_f26,                    \/\/ key_f26, kf26, FG\n-        key_f27,                    \/\/ key_f27, kf27, FH\n-        key_f28,                    \/\/ key_f28, kf28, FI\n-        key_f29,                    \/\/ key_f29, kf29, FJ\n-        key_f3,                     \/\/ key_f3, kf3, k3\n-        key_f30,                    \/\/ key_f30, kf30, FK\n-        key_f31,                    \/\/ key_f31, kf31, FL\n-        key_f32,                    \/\/ key_f32, kf32, FM\n-        key_f33,                    \/\/ key_f33, kf33, FN\n-        key_f34,                    \/\/ key_f34, kf34, FO\n-        key_f35,                    \/\/ key_f35, kf35, FP\n-        key_f36,                    \/\/ key_f36, kf36, FQ\n-        key_f37,                    \/\/ key_f37, kf37, FR\n-        key_f38,                    \/\/ key_f38, kf38, FS\n-        key_f39,                    \/\/ key_f39, kf39, FT\n-        key_f4,                     \/\/ key_f4, kf4, k4\n-        key_f40,                    \/\/ key_f40, kf40, FU\n-        key_f41,                    \/\/ key_f41, kf41, FV\n-        key_f42,                    \/\/ key_f42, kf42, FW\n-        key_f43,                    \/\/ key_f43, kf43, FX\n-        key_f44,                    \/\/ key_f44, kf44, FY\n-        key_f45,                    \/\/ key_f45, kf45, FZ\n-        key_f46,                    \/\/ key_f46, kf46, Fa\n-        key_f47,                    \/\/ key_f47, kf47, Fb\n-        key_f48,                    \/\/ key_f48, kf48, Fc\n-        key_f49,                    \/\/ key_f49, kf49, Fd\n-        key_f5,                     \/\/ key_f5, kf5, k5\n-        key_f50,                    \/\/ key_f50, kf50, Fe\n-        key_f51,                    \/\/ key_f51, kf51, Ff\n-        key_f52,                    \/\/ key_f52, kf52, Fg\n-        key_f53,                    \/\/ key_f53, kf53, Fh\n-        key_f54,                    \/\/ key_f54, kf54, Fi\n-        key_f55,                    \/\/ key_f55, kf55, Fj\n-        key_f56,                    \/\/ key_f56, kf56, Fk\n-        key_f57,                    \/\/ key_f57, kf57, Fl\n-        key_f58,                    \/\/ key_f58, kf58, Fm\n-        key_f59,                    \/\/ key_f59, kf59, Fn\n-        key_f6,                     \/\/ key_f6, kf6, k6\n-        key_f60,                    \/\/ key_f60, kf60, Fo\n-        key_f61,                    \/\/ key_f61, kf61, Fp\n-        key_f62,                    \/\/ key_f62, kf62, Fq\n-        key_f63,                    \/\/ key_f63, kf63, Fr\n-        key_f7,                     \/\/ key_f7, kf7, k7\n-        key_f8,                     \/\/ key_f8, kf8, k8\n-        key_f9,                     \/\/ key_f9, kf9, k9\n-        key_find,                   \/\/ key_find, kfnd, @0\n-        key_help,                   \/\/ key_help, khlp, %1\n-        key_home,                   \/\/ key_home, khome, kh\n-        key_ic,                     \/\/ key_ic, kich1, kI\n-        key_il,                     \/\/ key_il, kil1, kA\n-        key_left,                   \/\/ key_left, kcub1, kl\n-        key_ll,                     \/\/ key_ll, kll, kH\n-        key_mark,                   \/\/ key_mark, kmrk, %2\n-        key_message,                \/\/ key_message, kmsg, %3\n-        key_move,                   \/\/ key_move, kmov, %4\n-        key_next,                   \/\/ key_next, knxt, %5\n-        key_npage,                  \/\/ key_npage, knp, kN\n-        key_open,                   \/\/ key_open, kopn, %6\n-        key_options,                \/\/ key_options, kopt, %7\n-        key_ppage,                  \/\/ key_ppage, kpp, kP\n-        key_previous,               \/\/ key_previous, kprv, %8\n-        key_print,                  \/\/ key_print, kprt, %9\n-        key_redo,                   \/\/ key_redo, krdo, %0\n-        key_reference,              \/\/ key_reference, kref, &1\n-        key_refresh,                \/\/ key_refresh, krfr, &2\n-        key_replace,                \/\/ key_replace, krpl, &3\n-        key_restart,                \/\/ key_restart, krst, &4\n-        key_resume,                 \/\/ key_resume, kres, &5\n-        key_right,                  \/\/ key_right, kcuf1, kr\n-        key_save,                   \/\/ key_save, ksav, &6\n-        key_sbeg,                   \/\/ key_sbeg, kBEG, &9\n-        key_scancel,                \/\/ key_scancel, kCAN, &0\n-        key_scommand,               \/\/ key_scommand, kCMD, *1\n-        key_scopy,                  \/\/ key_scopy, kCPY, *2\n-        key_screate,                \/\/ key_screate, kCRT, *3\n-        key_sdc,                    \/\/ key_sdc, kDC, *4\n-        key_sdl,                    \/\/ key_sdl, kDL, *5\n-        key_select,                 \/\/ key_select, kslt, *6\n-        key_send,                   \/\/ key_send, kEND, *7\n-        key_seol,                   \/\/ key_seol, kEOL, *8\n-        key_sexit,                  \/\/ key_sexit, kEXT, *9\n-        key_sf,                     \/\/ key_sf, kind, kF\n-        key_sfind,                  \/\/ key_sfind, kFND, *0\n-        key_shelp,                  \/\/ key_shelp, kHLP, #1\n-        key_shome,                  \/\/ key_shome, kHOM, #2\n-        key_sic,                    \/\/ key_sic, kIC, #3\n-        key_sleft,                  \/\/ key_sleft, kLFT, #4\n-        key_smessage,               \/\/ key_smessage, kMSG, %a\n-        key_smove,                  \/\/ key_smove, kMOV, %b\n-        key_snext,                  \/\/ key_snext, kNXT, %c\n-        key_soptions,               \/\/ key_soptions, kOPT, %d\n-        key_sprevious,              \/\/ key_sprevious, kPRV, %e\n-        key_sprint,                 \/\/ key_sprint, kPRT, %f\n-        key_sr,                     \/\/ key_sr, kri, kR\n-        key_sredo,                  \/\/ key_sredo, kRDO, %g\n-        key_sreplace,               \/\/ key_sreplace, kRPL, %h\n-        key_sright,                 \/\/ key_sright, kRIT, %i\n-        key_srsume,                 \/\/ key_srsume, kRES, %j\n-        key_ssave,                  \/\/ key_ssave, kSAV, !1\n-        key_ssuspend,               \/\/ key_ssuspend, kSPD, !2\n-        key_stab,                   \/\/ key_stab, khts, kT\n-        key_sundo,                  \/\/ key_sundo, kUND, !3\n-        key_suspend,                \/\/ key_suspend, kspd, &7\n-        key_undo,                   \/\/ key_undo, kund, &8\n-        key_up,                     \/\/ key_up, kcuu1, ku\n-        keypad_local,               \/\/ keypad_local, rmkx, ke\n-        keypad_xmit,                \/\/ keypad_xmit, smkx, ks\n-        lab_f0,                     \/\/ lab_f0, lf0, l0\n-        lab_f1,                     \/\/ lab_f1, lf1, l1\n-        lab_f10,                    \/\/ lab_f10, lf10, la\n-        lab_f2,                     \/\/ lab_f2, lf2, l2\n-        lab_f3,                     \/\/ lab_f3, lf3, l3\n-        lab_f4,                     \/\/ lab_f4, lf4, l4\n-        lab_f5,                     \/\/ lab_f5, lf5, l5\n-        lab_f6,                     \/\/ lab_f6, lf6, l6\n-        lab_f7,                     \/\/ lab_f7, lf7, l7\n-        lab_f8,                     \/\/ lab_f8, lf8, l8\n-        lab_f9,                     \/\/ lab_f9, lf9, l9\n-        label_format,               \/\/ label_format, fln, Lf\n-        label_off,                  \/\/ label_off, rmln, LF\n-        label_on,                   \/\/ label_on, smln, LO\n-        meta_off,                   \/\/ meta_off, rmm, mo\n-        meta_on,                    \/\/ meta_on, smm, mm\n-        micro_column_address,       \/\/ micro_column_address, mhpa, ZY\n-        micro_down,                 \/\/ micro_down, mcud1, ZZ\n-        micro_left,                 \/\/ micro_left, mcub1, Za\n-        micro_right,                \/\/ micro_right, mcuf1, Zb\n-        micro_row_address,          \/\/ micro_row_address, mvpa, Zc\n-        micro_up,                   \/\/ micro_up, mcuu1, Zd\n-        newline,                    \/\/ newline, nel, nw\n-        order_of_pins,              \/\/ order_of_pins, porder, Ze\n-        orig_colors,                \/\/ orig_colors, oc, oc\n-        orig_pair,                  \/\/ orig_pair, op, op\n-        pad_char,                   \/\/ pad_char, pad, pc\n-        parm_dch,                   \/\/ parm_dch, dch, DC\n-        parm_delete_line,           \/\/ parm_delete_line, dl, DL\n-        parm_down_cursor,           \/\/ parm_down_cursor, cud, DO\n-        parm_down_micro,            \/\/ parm_down_micro, mcud, Zf\n-        parm_ich,                   \/\/ parm_ich, ich, IC\n-        parm_index,                 \/\/ parm_index, indn, SF\n-        parm_insert_line,           \/\/ parm_insert_line, il, AL\n-        parm_left_cursor,           \/\/ parm_left_cursor, cub, LE\n-        parm_left_micro,            \/\/ parm_left_micro, mcub, Zg\n-        parm_right_cursor,          \/\/ parm_right_cursor, cuf, RI\n-        parm_right_micro,           \/\/ parm_right_micro, mcuf, Zh\n-        parm_rindex,                \/\/ parm_rindex, rin, SR\n-        parm_up_cursor,             \/\/ parm_up_cursor, cuu, UP\n-        parm_up_micro,              \/\/ parm_up_micro, mcuu, Zi\n-        pkey_key,                   \/\/ pkey_key, pfkey, pk\n-        pkey_local,                 \/\/ pkey_local, pfloc, pl\n-        pkey_xmit,                  \/\/ pkey_xmit, pfx, px\n-        plab_norm,                  \/\/ plab_norm, pln, pn\n-        print_screen,               \/\/ print_screen, mc0, ps\n-        prtr_non,                   \/\/ prtr_non, mc5p, pO\n-        prtr_off,                   \/\/ prtr_off, mc4, pf\n-        prtr_on,                    \/\/ prtr_on, mc5, po\n-        pulse,                      \/\/ pulse, pulse, PU\n-        quick_dial,                 \/\/ quick_dial, qdial, QD\n-        remove_clock,               \/\/ remove_clock, rmclk, RC\n-        repeat_char,                \/\/ repeat_char, rep, rp\n-        req_for_input,              \/\/ req_for_input, rfi, RF\n-        reset_1string,              \/\/ reset_1string, rs1, r1\n-        reset_2string,              \/\/ reset_2string, rs2, r2\n-        reset_3string,              \/\/ reset_3string, rs3, r3\n-        reset_file,                 \/\/ reset_file, rf, rf\n-        restore_cursor,             \/\/ restore_cursor, rc, rc\n-        row_address,                \/\/ row_address, vpa, cv\n-        save_cursor,                \/\/ save_cursor, sc, sc\n-        scroll_forward,             \/\/ scroll_forward, ind, sf\n-        scroll_reverse,             \/\/ scroll_reverse, ri, sr\n-        select_char_set,            \/\/ select_char_set, scs, Zj\n-        set_attributes,             \/\/ set_attributes, sgr, sa\n-        set_background,             \/\/ set_background, setb, Sb\n-        set_bottom_margin,          \/\/ set_bottom_margin, smgb, Zk\n-        set_bottom_margin_parm,     \/\/ set_bottom_margin_parm, smgbp, Zl\n-        set_clock,                  \/\/ set_clock, sclk, SC\n-        set_color_pair,             \/\/ set_color_pair, scp, sp\n-        set_foreground,             \/\/ set_foreground, setf, Sf\n-        set_left_margin,            \/\/ set_left_margin, smgl, ML\n-        set_left_margin_parm,       \/\/ set_left_margin_parm, smglp, Zm\n-        set_right_margin,           \/\/ set_right_margin, smgr, MR\n-        set_right_margin_parm,      \/\/ set_right_margin_parm, smgrp, Zn\n-        set_tab,                    \/\/ set_tab, hts, st\n-        set_top_margin,             \/\/ set_top_margin, smgt, Zo\n-        set_top_margin_parm,        \/\/ set_top_margin_parm, smgtp, Zp\n-        set_window,                 \/\/ set_window, wind, wi\n-        start_bit_image,            \/\/ start_bit_image, sbim, Zq\n-        start_char_set_def,         \/\/ start_char_set_def, scsd, Zr\n-        stop_bit_image,             \/\/ stop_bit_image, rbim, Zs\n-        stop_char_set_def,          \/\/ stop_char_set_def, rcsd, Zt\n-        subscript_characters,       \/\/ subscript_characters, subcs, Zu\n-        superscript_characters,     \/\/ superscript_characters, supcs, Zv\n-        tab,                        \/\/ tab, ht, ta\n-        these_cause_cr,             \/\/ these_cause_cr, docr, Zw\n-        to_status_line,             \/\/ to_status_line, tsl, ts\n-        tone,                       \/\/ tone, tone, TO\n-        underline_char,             \/\/ underline_char, uc, uc\n-        up_half_line,               \/\/ up_half_line, hu, hu\n-        user0,                      \/\/ user0, u0, u0\n-        user1,                      \/\/ user1, u1, u1\n-        user2,                      \/\/ user2, u2, u2\n-        user3,                      \/\/ user3, u3, u3\n-        user4,                      \/\/ user4, u4, u4\n-        user5,                      \/\/ user5, u5, u5\n-        user6,                      \/\/ user6, u6, u6\n-        user7,                      \/\/ user7, u7, u7\n-        user8,                      \/\/ user8, u8, u8\n-        user9,                      \/\/ user9, u9, u9\n-        wait_tone,                  \/\/ wait_tone, wait, WA\n-        xoff_character,             \/\/ xoff_character, xoffc, XF\n-        xon_character,              \/\/ xon_character, xonc, XN\n-        zero_motion,                \/\/ zero_motion, zerom, Zx\n-        alt_scancode_esc,           \/\/ alt_scancode_esc, scesa, S8\n-        bit_image_carriage_return,  \/\/ bit_image_carriage_return, bicr, Yv\n-        bit_image_newline,          \/\/ bit_image_newline, binel, Zz\n-        bit_image_repeat,           \/\/ bit_image_repeat, birep, Xy\n-        char_set_names,             \/\/ char_set_names, csnm, Zy\n-        code_set_init,              \/\/ code_set_init, csin, ci\n-        color_names,                \/\/ color_names, colornm, Yw\n-        define_bit_image_region,    \/\/ define_bit_image_region, defbi, Yx\n-        device_type,                \/\/ device_type, devt, dv\n-        display_pc_char,            \/\/ display_pc_char, dispc, S1\n-        end_bit_image_region,       \/\/ end_bit_image_region, endbi, Yy\n-        enter_pc_charset_mode,      \/\/ enter_pc_charset_mode, smpch, S2\n-        enter_scancode_mode,        \/\/ enter_scancode_mode, smsc, S4\n-        exit_pc_charset_mode,       \/\/ exit_pc_charset_mode, rmpch, S3\n-        exit_scancode_mode,         \/\/ exit_scancode_mode, rmsc, S5\n-        get_mouse,                  \/\/ get_mouse, getm, Gm\n-        key_mouse,                  \/\/ key_mouse, kmous, Km\n-        mouse_info,                 \/\/ mouse_info, minfo, Mi\n-        pc_term_options,            \/\/ pc_term_options, pctrm, S6\n-        pkey_plab,                  \/\/ pkey_plab, pfxl, xl\n-        req_mouse_pos,              \/\/ req_mouse_pos, reqmp, RQ\n-        scancode_escape,            \/\/ scancode_escape, scesc, S7\n-        set0_des_seq,               \/\/ set0_des_seq, s0ds, s0\n-        set1_des_seq,               \/\/ set1_des_seq, s1ds, s1\n-        set2_des_seq,               \/\/ set2_des_seq, s2ds, s2\n-        set3_des_seq,               \/\/ set3_des_seq, s3ds, s3\n-        set_a_background,           \/\/ set_a_background, setab, AB\n-        set_a_foreground,           \/\/ set_a_foreground, setaf, AF\n-        set_color_band,             \/\/ set_color_band, setcolor, Yz\n-        set_lr_margin,              \/\/ set_lr_margin, smglr, ML\n-        set_page_length,            \/\/ set_page_length, slines, YZ\n-        set_tb_margin,              \/\/ set_tb_margin, smgtb, MT\n-        enter_horizontal_hl_mode,   \/\/ enter_horizontal_hl_mode, ehhlm, Xh\n-        enter_left_hl_mode,         \/\/ enter_left_hl_mode, elhlm, Xl\n-        enter_low_hl_mode,          \/\/ enter_low_hl_mode, elohlm, Xo\n-        enter_right_hl_mode,        \/\/ enter_right_hl_mode, erhlm, Xr\n-        enter_top_hl_mode,          \/\/ enter_top_hl_mode, ethlm, Xt\n-        enter_vertical_hl_mode,     \/\/ enter_vertical_hl_mode, evhlm, Xv\n-        set_a_attributes,           \/\/ set_a_attributes, sgr1, sA\n-        set_pglen_inch,             \/\/ set_pglen_inch, slength, sL)\n+        auto_left_margin, \/\/ auto_left_margin, bw, bw\n+        auto_right_margin, \/\/ auto_right_margin, am, am\n+        back_color_erase, \/\/ back_color_erase, bce, ut\n+        can_change, \/\/ can_change, ccc, cc\n+        ceol_standout_glitch, \/\/ ceol_standout_glitch, xhp, xs\n+        col_addr_glitch, \/\/ col_addr_glitch, xhpa, YA\n+        cpi_changes_res, \/\/ cpi_changes_res, cpix, YF\n+        cr_cancels_micro_mode, \/\/ cr_cancels_micro_mode, crxm, YB\n+        dest_tabs_magic_smso, \/\/ dest_tabs_magic_smso, xt, xt\n+        eat_newline_glitch, \/\/ eat_newline_glitch, xenl, xn\n+        erase_overstrike, \/\/ erase_overstrike, eo, eo\n+        generic_type, \/\/ generic_type, gn, gn\n+        hard_copy, \/\/ hard_copy, hc, hc\n+        hard_cursor, \/\/ hard_cursor, chts, HC\n+        has_meta_key, \/\/ has_meta_key, km, km\n+        has_print_wheel, \/\/ has_print_wheel, daisy, YC\n+        has_status_line, \/\/ has_status_line, hs, hs\n+        hue_lightness_saturation, \/\/ hue_lightness_saturation, hls, hl\n+        insert_null_glitch, \/\/ insert_null_glitch, in, in\n+        lpi_changes_res, \/\/ lpi_changes_res, lpix, YG\n+        memory_above, \/\/ memory_above, da, da\n+        memory_below, \/\/ memory_below, db, db\n+        move_insert_mode, \/\/ move_insert_mode, mir, mi\n+        move_standout_mode, \/\/ move_standout_mode, msgr, ms\n+        needs_xon_xoff, \/\/ needs_xon_xoff, nxon, nx\n+        no_esc_ctlc, \/\/ no_esc_ctlc, xsb, xb\n+        no_pad_char, \/\/ no_pad_char, npc, NP\n+        non_dest_scroll_region, \/\/ non_dest_scroll_region, ndscr, ND\n+        non_rev_rmcup, \/\/ non_rev_rmcup, nrrmc, NR\n+        over_strike, \/\/ over_strike, os, os\n+        prtr_silent, \/\/ prtr_silent, mc5i, 5i\n+        row_addr_glitch, \/\/ row_addr_glitch, xvpa, YD\n+        semi_auto_right_margin, \/\/ semi_auto_right_margin, sam, YE\n+        status_line_esc_ok, \/\/ status_line_esc_ok, eslok, es\n+        tilde_glitch, \/\/ tilde_glitch, hz, hz\n+        transparent_underline, \/\/ transparent_underline, ul, ul\n+        xon_xoff, \/\/ xon_xoff, xon, xo\n+        columns, \/\/ columns, cols, co\n+        init_tabs, \/\/ init_tabs, it, it\n+        label_height, \/\/ label_height, lh, lh\n+        label_width, \/\/ label_width, lw, lw\n+        lines, \/\/ lines, lines, li\n+        lines_of_memory, \/\/ lines_of_memory, lm, lm\n+        magic_cookie_glitch, \/\/ magic_cookie_glitch, xmc, sg\n+        max_attributes, \/\/ max_attributes, ma, ma\n+        max_colors, \/\/ max_colors, colors, Co\n+        max_pairs, \/\/ max_pairs, pairs, pa\n+        maximum_windows, \/\/ maximum_windows, wnum, MW\n+        no_color_video, \/\/ no_color_video, ncv, NC\n+        num_labels, \/\/ num_labels, nlab, Nl\n+        padding_baud_rate, \/\/ padding_baud_rate, pb, pb\n+        virtual_terminal, \/\/ virtual_terminal, vt, vt\n+        width_status_line, \/\/ width_status_line, wsl, ws\n+        bit_image_entwining, \/\/ bit_image_entwining, bitwin, Yo\n+        bit_image_type, \/\/ bit_image_type, bitype, Yp\n+        buffer_capacity, \/\/ buffer_capacity, bufsz, Ya\n+        buttons, \/\/ buttons, btns, BT\n+        dot_horz_spacing, \/\/ dot_horz_spacing, spinh, Yc\n+        dot_vert_spacing, \/\/ dot_vert_spacing, spinv, Yb\n+        max_micro_address, \/\/ max_micro_address, maddr, Yd\n+        max_micro_jump, \/\/ max_micro_jump, mjump, Ye\n+        micro_col_size, \/\/ micro_col_size, mcs, Yf\n+        micro_line_size, \/\/ micro_line_size, mls, Yg\n+        number_of_pins, \/\/ number_of_pins, npins, Yh\n+        output_res_char, \/\/ output_res_char, orc, Yi\n+        output_res_horz_inch, \/\/ output_res_horz_inch, orhi, Yk\n+        output_res_line, \/\/ output_res_line, orl, Yj\n+        output_res_vert_inch, \/\/ output_res_vert_inch, orvi, Yl\n+        print_rate, \/\/ print_rate, cps, Ym\n+        wide_char_size, \/\/ wide_char_size, widcs, Yn\n+        acs_chars, \/\/ acs_chars, acsc, ac\n+        back_tab, \/\/ back_tab, cbt, bt\n+        bell, \/\/ bell, bel, bl\n+        carriage_return, \/\/ carriage_return, cr, cr\n+        change_char_pitch, \/\/ change_char_pitch, cpi, ZA\n+        change_line_pitch, \/\/ change_line_pitch, lpi, ZB\n+        change_res_horz, \/\/ change_res_horz, chr, ZC\n+        change_res_vert, \/\/ change_res_vert, cvr, ZD\n+        change_scroll_region, \/\/ change_scroll_region, csr, cs\n+        char_padding, \/\/ char_padding, rmp, rP\n+        clear_all_tabs, \/\/ clear_all_tabs, tbc, ct\n+        clear_margins, \/\/ clear_margins, mgc, MC\n+        clear_screen, \/\/ clear_screen, clear, cl\n+        clr_bol, \/\/ clr_bol, el1, cb\n+        clr_eol, \/\/ clr_eol, el, ce\n+        clr_eos, \/\/ clr_eos, ed, cd\n+        column_address, \/\/ column_address, hpa, ch\n+        command_character, \/\/ command_character, cmdch, CC\n+        create_window, \/\/ create_window, cwin, CW\n+        cursor_address, \/\/ cursor_address, cup, cm\n+        cursor_down, \/\/ cursor_down, cud1, do\n+        cursor_home, \/\/ cursor_home, home, ho\n+        cursor_invisible, \/\/ cursor_invisible, civis, vi\n+        cursor_left, \/\/ cursor_left, cub1, le\n+        cursor_mem_address, \/\/ cursor_mem_address, mrcup, CM\n+        cursor_normal, \/\/ cursor_normal, cnorm, ve\n+        cursor_right, \/\/ cursor_right, cuf1, nd\n+        cursor_to_ll, \/\/ cursor_to_ll, ll, ll\n+        cursor_up, \/\/ cursor_up, cuu1, up\n+        cursor_visible, \/\/ cursor_visible, cvvis, vs\n+        define_char, \/\/ define_char, defc, ZE\n+        delete_character, \/\/ delete_character, dch1, dc\n+        delete_line, \/\/ delete_line, dl1, dl\n+        dial_phone, \/\/ dial_phone, dial, DI\n+        dis_status_line, \/\/ dis_status_line, dsl, ds\n+        display_clock, \/\/ display_clock, dclk, DK\n+        down_half_line, \/\/ down_half_line, hd, hd\n+        ena_acs, \/\/ ena_acs, enacs, eA\n+        enter_alt_charset_mode, \/\/ enter_alt_charset_mode, smacs, as\n+        enter_am_mode, \/\/ enter_am_mode, smam, SA\n+        enter_blink_mode, \/\/ enter_blink_mode, blink, mb\n+        enter_bold_mode, \/\/ enter_bold_mode, bold, md\n+        enter_ca_mode, \/\/ enter_ca_mode, smcup, ti\n+        enter_delete_mode, \/\/ enter_delete_mode, smdc, dm\n+        enter_dim_mode, \/\/ enter_dim_mode, dim, mh\n+        enter_doublewide_mode, \/\/ enter_doublewide_mode, swidm, ZF\n+        enter_draft_quality, \/\/ enter_draft_quality, sdrfq, ZG\n+        enter_insert_mode, \/\/ enter_insert_mode, smir, im\n+        enter_italics_mode, \/\/ enter_italics_mode, sitm, ZH\n+        enter_leftward_mode, \/\/ enter_leftward_mode, slm, ZI\n+        enter_micro_mode, \/\/ enter_micro_mode, smicm, ZJ\n+        enter_near_letter_quality, \/\/ enter_near_letter_quality, snlq, ZK\n+        enter_normal_quality, \/\/ enter_normal_quality, snrmq, ZL\n+        enter_protected_mode, \/\/ enter_protected_mode, prot, mp\n+        enter_reverse_mode, \/\/ enter_reverse_mode, rev, mr\n+        enter_secure_mode, \/\/ enter_secure_mode, invis, mk\n+        enter_shadow_mode, \/\/ enter_shadow_mode, sshm, ZM\n+        enter_standout_mode, \/\/ enter_standout_mode, smso, so\n+        enter_subscript_mode, \/\/ enter_subscript_mode, ssubm, ZN\n+        enter_superscript_mode, \/\/ enter_superscript_mode, ssupm, ZO\n+        enter_underline_mode, \/\/ enter_underline_mode, smul, us\n+        enter_upward_mode, \/\/ enter_upward_mode, sum, ZP\n+        enter_xon_mode, \/\/ enter_xon_mode, smxon, SX\n+        erase_chars, \/\/ erase_chars, ech, ec\n+        exit_alt_charset_mode, \/\/ exit_alt_charset_mode, rmacs, ae\n+        exit_am_mode, \/\/ exit_am_mode, rmam, RA\n+        exit_attribute_mode, \/\/ exit_attribute_mode, sgr0, me\n+        exit_ca_mode, \/\/ exit_ca_mode, rmcup, te\n+        exit_delete_mode, \/\/ exit_delete_mode, rmdc, ed\n+        exit_doublewide_mode, \/\/ exit_doublewide_mode, rwidm, ZQ\n+        exit_insert_mode, \/\/ exit_insert_mode, rmir, ei\n+        exit_italics_mode, \/\/ exit_italics_mode, ritm, ZR\n+        exit_leftward_mode, \/\/ exit_leftward_mode, rlm, ZS\n+        exit_micro_mode, \/\/ exit_micro_mode, rmicm, ZT\n+        exit_shadow_mode, \/\/ exit_shadow_mode, rshm, ZU\n+        exit_standout_mode, \/\/ exit_standout_mode, rmso, se\n+        exit_subscript_mode, \/\/ exit_subscript_mode, rsubm, ZV\n+        exit_superscript_mode, \/\/ exit_superscript_mode, rsupm, ZW\n+        exit_underline_mode, \/\/ exit_underline_mode, rmul, ue\n+        exit_upward_mode, \/\/ exit_upward_mode, rum, ZX\n+        exit_xon_mode, \/\/ exit_xon_mode, rmxon, RX\n+        fixed_pause, \/\/ fixed_pause, pause, PA\n+        flash_hook, \/\/ flash_hook, hook, fh\n+        flash_screen, \/\/ flash_screen, flash, vb\n+        form_feed, \/\/ form_feed, ff, ff\n+        from_status_line, \/\/ from_status_line, fsl, fs\n+        goto_window, \/\/ goto_window, wingo, WG\n+        hangup, \/\/ hangup, hup, HU\n+        init_1string, \/\/ init_1string, is1, i1\n+        init_2string, \/\/ init_2string, is2, is\n+        init_3string, \/\/ init_3string, is3, i3\n+        init_file, \/\/ init_file, if, if\n+        init_prog, \/\/ init_prog, iprog, iP\n+        initialize_color, \/\/ initialize_color, initc, Ic\n+        initialize_pair, \/\/ initialize_pair, initp, Ip\n+        insert_character, \/\/ insert_character, ich1, ic\n+        insert_line, \/\/ insert_line, il1, al\n+        insert_padding, \/\/ insert_padding, ip, ip\n+        key_a1, \/\/ key_a1, ka1, K1\n+        key_a3, \/\/ key_a3, ka3, K3\n+        key_b2, \/\/ key_b2, kb2, K2\n+        key_backspace, \/\/ key_backspace, kbs, kb\n+        key_beg, \/\/ key_beg, kbeg, @1\n+        key_btab, \/\/ key_btab, kcbt, kB\n+        key_c1, \/\/ key_c1, kc1, K4\n+        key_c3, \/\/ key_c3, kc3, K5\n+        key_cancel, \/\/ key_cancel, kcan, @2\n+        key_catab, \/\/ key_catab, ktbc, ka\n+        key_clear, \/\/ key_clear, kclr, kC\n+        key_close, \/\/ key_close, kclo, @3\n+        key_command, \/\/ key_command, kcmd, @4\n+        key_copy, \/\/ key_copy, kcpy, @5\n+        key_create, \/\/ key_create, kcrt, @6\n+        key_ctab, \/\/ key_ctab, kctab, kt\n+        key_dc, \/\/ key_dc, kdch1, kD\n+        key_dl, \/\/ key_dl, kdl1, kL\n+        key_down, \/\/ key_down, kcud1, kd\n+        key_eic, \/\/ key_eic, krmir, kM\n+        key_end, \/\/ key_end, kend, @7\n+        key_enter, \/\/ key_enter, kent, @8\n+        key_eol, \/\/ key_eol, kel, kE\n+        key_eos, \/\/ key_eos, ked, kS\n+        key_exit, \/\/ key_exit, kext, @9\n+        key_f0, \/\/ key_f0, kf0, k0\n+        key_f1, \/\/ key_f1, kf1, k1\n+        key_f10, \/\/ key_f10, kf10, k;\n+        key_f11, \/\/ key_f11, kf11, F1\n+        key_f12, \/\/ key_f12, kf12, F2\n+        key_f13, \/\/ key_f13, kf13, F3\n+        key_f14, \/\/ key_f14, kf14, F4\n+        key_f15, \/\/ key_f15, kf15, F5\n+        key_f16, \/\/ key_f16, kf16, F6\n+        key_f17, \/\/ key_f17, kf17, F7\n+        key_f18, \/\/ key_f18, kf18, F8\n+        key_f19, \/\/ key_f19, kf19, F9\n+        key_f2, \/\/ key_f2, kf2, k2\n+        key_f20, \/\/ key_f20, kf20, FA\n+        key_f21, \/\/ key_f21, kf21, FB\n+        key_f22, \/\/ key_f22, kf22, FC\n+        key_f23, \/\/ key_f23, kf23, FD\n+        key_f24, \/\/ key_f24, kf24, FE\n+        key_f25, \/\/ key_f25, kf25, FF\n+        key_f26, \/\/ key_f26, kf26, FG\n+        key_f27, \/\/ key_f27, kf27, FH\n+        key_f28, \/\/ key_f28, kf28, FI\n+        key_f29, \/\/ key_f29, kf29, FJ\n+        key_f3, \/\/ key_f3, kf3, k3\n+        key_f30, \/\/ key_f30, kf30, FK\n+        key_f31, \/\/ key_f31, kf31, FL\n+        key_f32, \/\/ key_f32, kf32, FM\n+        key_f33, \/\/ key_f33, kf33, FN\n+        key_f34, \/\/ key_f34, kf34, FO\n+        key_f35, \/\/ key_f35, kf35, FP\n+        key_f36, \/\/ key_f36, kf36, FQ\n+        key_f37, \/\/ key_f37, kf37, FR\n+        key_f38, \/\/ key_f38, kf38, FS\n+        key_f39, \/\/ key_f39, kf39, FT\n+        key_f4, \/\/ key_f4, kf4, k4\n+        key_f40, \/\/ key_f40, kf40, FU\n+        key_f41, \/\/ key_f41, kf41, FV\n+        key_f42, \/\/ key_f42, kf42, FW\n+        key_f43, \/\/ key_f43, kf43, FX\n+        key_f44, \/\/ key_f44, kf44, FY\n+        key_f45, \/\/ key_f45, kf45, FZ\n+        key_f46, \/\/ key_f46, kf46, Fa\n+        key_f47, \/\/ key_f47, kf47, Fb\n+        key_f48, \/\/ key_f48, kf48, Fc\n+        key_f49, \/\/ key_f49, kf49, Fd\n+        key_f5, \/\/ key_f5, kf5, k5\n+        key_f50, \/\/ key_f50, kf50, Fe\n+        key_f51, \/\/ key_f51, kf51, Ff\n+        key_f52, \/\/ key_f52, kf52, Fg\n+        key_f53, \/\/ key_f53, kf53, Fh\n+        key_f54, \/\/ key_f54, kf54, Fi\n+        key_f55, \/\/ key_f55, kf55, Fj\n+        key_f56, \/\/ key_f56, kf56, Fk\n+        key_f57, \/\/ key_f57, kf57, Fl\n+        key_f58, \/\/ key_f58, kf58, Fm\n+        key_f59, \/\/ key_f59, kf59, Fn\n+        key_f6, \/\/ key_f6, kf6, k6\n+        key_f60, \/\/ key_f60, kf60, Fo\n+        key_f61, \/\/ key_f61, kf61, Fp\n+        key_f62, \/\/ key_f62, kf62, Fq\n+        key_f63, \/\/ key_f63, kf63, Fr\n+        key_f7, \/\/ key_f7, kf7, k7\n+        key_f8, \/\/ key_f8, kf8, k8\n+        key_f9, \/\/ key_f9, kf9, k9\n+        key_find, \/\/ key_find, kfnd, @0\n+        key_help, \/\/ key_help, khlp, %1\n+        key_home, \/\/ key_home, khome, kh\n+        key_ic, \/\/ key_ic, kich1, kI\n+        key_il, \/\/ key_il, kil1, kA\n+        key_left, \/\/ key_left, kcub1, kl\n+        key_ll, \/\/ key_ll, kll, kH\n+        key_mark, \/\/ key_mark, kmrk, %2\n+        key_message, \/\/ key_message, kmsg, %3\n+        key_move, \/\/ key_move, kmov, %4\n+        key_next, \/\/ key_next, knxt, %5\n+        key_npage, \/\/ key_npage, knp, kN\n+        key_open, \/\/ key_open, kopn, %6\n+        key_options, \/\/ key_options, kopt, %7\n+        key_ppage, \/\/ key_ppage, kpp, kP\n+        key_previous, \/\/ key_previous, kprv, %8\n+        key_print, \/\/ key_print, kprt, %9\n+        key_redo, \/\/ key_redo, krdo, %0\n+        key_reference, \/\/ key_reference, kref, &1\n+        key_refresh, \/\/ key_refresh, krfr, &2\n+        key_replace, \/\/ key_replace, krpl, &3\n+        key_restart, \/\/ key_restart, krst, &4\n+        key_resume, \/\/ key_resume, kres, &5\n+        key_right, \/\/ key_right, kcuf1, kr\n+        key_save, \/\/ key_save, ksav, &6\n+        key_sbeg, \/\/ key_sbeg, kBEG, &9\n+        key_scancel, \/\/ key_scancel, kCAN, &0\n+        key_scommand, \/\/ key_scommand, kCMD, *1\n+        key_scopy, \/\/ key_scopy, kCPY, *2\n+        key_screate, \/\/ key_screate, kCRT, *3\n+        key_sdc, \/\/ key_sdc, kDC, *4\n+        key_sdl, \/\/ key_sdl, kDL, *5\n+        key_select, \/\/ key_select, kslt, *6\n+        key_send, \/\/ key_send, kEND, *7\n+        key_seol, \/\/ key_seol, kEOL, *8\n+        key_sexit, \/\/ key_sexit, kEXT, *9\n+        key_sf, \/\/ key_sf, kind, kF\n+        key_sfind, \/\/ key_sfind, kFND, *0\n+        key_shelp, \/\/ key_shelp, kHLP, #1\n+        key_shome, \/\/ key_shome, kHOM, #2\n+        key_sic, \/\/ key_sic, kIC, #3\n+        key_sleft, \/\/ key_sleft, kLFT, #4\n+        key_smessage, \/\/ key_smessage, kMSG, %a\n+        key_smove, \/\/ key_smove, kMOV, %b\n+        key_snext, \/\/ key_snext, kNXT, %c\n+        key_soptions, \/\/ key_soptions, kOPT, %d\n+        key_sprevious, \/\/ key_sprevious, kPRV, %e\n+        key_sprint, \/\/ key_sprint, kPRT, %f\n+        key_sr, \/\/ key_sr, kri, kR\n+        key_sredo, \/\/ key_sredo, kRDO, %g\n+        key_sreplace, \/\/ key_sreplace, kRPL, %h\n+        key_sright, \/\/ key_sright, kRIT, %i\n+        key_srsume, \/\/ key_srsume, kRES, %j\n+        key_ssave, \/\/ key_ssave, kSAV, !1\n+        key_ssuspend, \/\/ key_ssuspend, kSPD, !2\n+        key_stab, \/\/ key_stab, khts, kT\n+        key_sundo, \/\/ key_sundo, kUND, !3\n+        key_suspend, \/\/ key_suspend, kspd, &7\n+        key_undo, \/\/ key_undo, kund, &8\n+        key_up, \/\/ key_up, kcuu1, ku\n+        keypad_local, \/\/ keypad_local, rmkx, ke\n+        keypad_xmit, \/\/ keypad_xmit, smkx, ks\n+        lab_f0, \/\/ lab_f0, lf0, l0\n+        lab_f1, \/\/ lab_f1, lf1, l1\n+        lab_f10, \/\/ lab_f10, lf10, la\n+        lab_f2, \/\/ lab_f2, lf2, l2\n+        lab_f3, \/\/ lab_f3, lf3, l3\n+        lab_f4, \/\/ lab_f4, lf4, l4\n+        lab_f5, \/\/ lab_f5, lf5, l5\n+        lab_f6, \/\/ lab_f6, lf6, l6\n+        lab_f7, \/\/ lab_f7, lf7, l7\n+        lab_f8, \/\/ lab_f8, lf8, l8\n+        lab_f9, \/\/ lab_f9, lf9, l9\n+        label_format, \/\/ label_format, fln, Lf\n+        label_off, \/\/ label_off, rmln, LF\n+        label_on, \/\/ label_on, smln, LO\n+        meta_off, \/\/ meta_off, rmm, mo\n+        meta_on, \/\/ meta_on, smm, mm\n+        micro_column_address, \/\/ micro_column_address, mhpa, ZY\n+        micro_down, \/\/ micro_down, mcud1, ZZ\n+        micro_left, \/\/ micro_left, mcub1, Za\n+        micro_right, \/\/ micro_right, mcuf1, Zb\n+        micro_row_address, \/\/ micro_row_address, mvpa, Zc\n+        micro_up, \/\/ micro_up, mcuu1, Zd\n+        newline, \/\/ newline, nel, nw\n+        order_of_pins, \/\/ order_of_pins, porder, Ze\n+        orig_colors, \/\/ orig_colors, oc, oc\n+        orig_pair, \/\/ orig_pair, op, op\n+        pad_char, \/\/ pad_char, pad, pc\n+        parm_dch, \/\/ parm_dch, dch, DC\n+        parm_delete_line, \/\/ parm_delete_line, dl, DL\n+        parm_down_cursor, \/\/ parm_down_cursor, cud, DO\n+        parm_down_micro, \/\/ parm_down_micro, mcud, Zf\n+        parm_ich, \/\/ parm_ich, ich, IC\n+        parm_index, \/\/ parm_index, indn, SF\n+        parm_insert_line, \/\/ parm_insert_line, il, AL\n+        parm_left_cursor, \/\/ parm_left_cursor, cub, LE\n+        parm_left_micro, \/\/ parm_left_micro, mcub, Zg\n+        parm_right_cursor, \/\/ parm_right_cursor, cuf, RI\n+        parm_right_micro, \/\/ parm_right_micro, mcuf, Zh\n+        parm_rindex, \/\/ parm_rindex, rin, SR\n+        parm_up_cursor, \/\/ parm_up_cursor, cuu, UP\n+        parm_up_micro, \/\/ parm_up_micro, mcuu, Zi\n+        pkey_key, \/\/ pkey_key, pfkey, pk\n+        pkey_local, \/\/ pkey_local, pfloc, pl\n+        pkey_xmit, \/\/ pkey_xmit, pfx, px\n+        plab_norm, \/\/ plab_norm, pln, pn\n+        print_screen, \/\/ print_screen, mc0, ps\n+        prtr_non, \/\/ prtr_non, mc5p, pO\n+        prtr_off, \/\/ prtr_off, mc4, pf\n+        prtr_on, \/\/ prtr_on, mc5, po\n+        pulse, \/\/ pulse, pulse, PU\n+        quick_dial, \/\/ quick_dial, qdial, QD\n+        remove_clock, \/\/ remove_clock, rmclk, RC\n+        repeat_char, \/\/ repeat_char, rep, rp\n+        req_for_input, \/\/ req_for_input, rfi, RF\n+        reset_1string, \/\/ reset_1string, rs1, r1\n+        reset_2string, \/\/ reset_2string, rs2, r2\n+        reset_3string, \/\/ reset_3string, rs3, r3\n+        reset_file, \/\/ reset_file, rf, rf\n+        restore_cursor, \/\/ restore_cursor, rc, rc\n+        row_address, \/\/ row_address, vpa, cv\n+        save_cursor, \/\/ save_cursor, sc, sc\n+        scroll_forward, \/\/ scroll_forward, ind, sf\n+        scroll_reverse, \/\/ scroll_reverse, ri, sr\n+        select_char_set, \/\/ select_char_set, scs, Zj\n+        set_attributes, \/\/ set_attributes, sgr, sa\n+        set_background, \/\/ set_background, setb, Sb\n+        set_bottom_margin, \/\/ set_bottom_margin, smgb, Zk\n+        set_bottom_margin_parm, \/\/ set_bottom_margin_parm, smgbp, Zl\n+        set_clock, \/\/ set_clock, sclk, SC\n+        set_color_pair, \/\/ set_color_pair, scp, sp\n+        set_foreground, \/\/ set_foreground, setf, Sf\n+        set_left_margin, \/\/ set_left_margin, smgl, ML\n+        set_left_margin_parm, \/\/ set_left_margin_parm, smglp, Zm\n+        set_right_margin, \/\/ set_right_margin, smgr, MR\n+        set_right_margin_parm, \/\/ set_right_margin_parm, smgrp, Zn\n+        set_tab, \/\/ set_tab, hts, st\n+        set_top_margin, \/\/ set_top_margin, smgt, Zo\n+        set_top_margin_parm, \/\/ set_top_margin_parm, smgtp, Zp\n+        set_window, \/\/ set_window, wind, wi\n+        start_bit_image, \/\/ start_bit_image, sbim, Zq\n+        start_char_set_def, \/\/ start_char_set_def, scsd, Zr\n+        stop_bit_image, \/\/ stop_bit_image, rbim, Zs\n+        stop_char_set_def, \/\/ stop_char_set_def, rcsd, Zt\n+        subscript_characters, \/\/ subscript_characters, subcs, Zu\n+        superscript_characters, \/\/ superscript_characters, supcs, Zv\n+        tab, \/\/ tab, ht, ta\n+        these_cause_cr, \/\/ these_cause_cr, docr, Zw\n+        to_status_line, \/\/ to_status_line, tsl, ts\n+        tone, \/\/ tone, tone, TO\n+        underline_char, \/\/ underline_char, uc, uc\n+        up_half_line, \/\/ up_half_line, hu, hu\n+        user0, \/\/ user0, u0, u0\n+        user1, \/\/ user1, u1, u1\n+        user2, \/\/ user2, u2, u2\n+        user3, \/\/ user3, u3, u3\n+        user4, \/\/ user4, u4, u4\n+        user5, \/\/ user5, u5, u5\n+        user6, \/\/ user6, u6, u6\n+        user7, \/\/ user7, u7, u7\n+        user8, \/\/ user8, u8, u8\n+        user9, \/\/ user9, u9, u9\n+        wait_tone, \/\/ wait_tone, wait, WA\n+        xoff_character, \/\/ xoff_character, xoffc, XF\n+        xon_character, \/\/ xon_character, xonc, XN\n+        zero_motion, \/\/ zero_motion, zerom, Zx\n+        alt_scancode_esc, \/\/ alt_scancode_esc, scesa, S8\n+        bit_image_carriage_return, \/\/ bit_image_carriage_return, bicr, Yv\n+        bit_image_newline, \/\/ bit_image_newline, binel, Zz\n+        bit_image_repeat, \/\/ bit_image_repeat, birep, Xy\n+        char_set_names, \/\/ char_set_names, csnm, Zy\n+        code_set_init, \/\/ code_set_init, csin, ci\n+        color_names, \/\/ color_names, colornm, Yw\n+        define_bit_image_region, \/\/ define_bit_image_region, defbi, Yx\n+        device_type, \/\/ device_type, devt, dv\n+        display_pc_char, \/\/ display_pc_char, dispc, S1\n+        end_bit_image_region, \/\/ end_bit_image_region, endbi, Yy\n+        enter_pc_charset_mode, \/\/ enter_pc_charset_mode, smpch, S2\n+        enter_scancode_mode, \/\/ enter_scancode_mode, smsc, S4\n+        exit_pc_charset_mode, \/\/ exit_pc_charset_mode, rmpch, S3\n+        exit_scancode_mode, \/\/ exit_scancode_mode, rmsc, S5\n+        get_mouse, \/\/ get_mouse, getm, Gm\n+        key_mouse, \/\/ key_mouse, kmous, Km\n+        mouse_info, \/\/ mouse_info, minfo, Mi\n+        pc_term_options, \/\/ pc_term_options, pctrm, S6\n+        pkey_plab, \/\/ pkey_plab, pfxl, xl\n+        req_mouse_pos, \/\/ req_mouse_pos, reqmp, RQ\n+        scancode_escape, \/\/ scancode_escape, scesc, S7\n+        set0_des_seq, \/\/ set0_des_seq, s0ds, s0\n+        set1_des_seq, \/\/ set1_des_seq, s1ds, s1\n+        set2_des_seq, \/\/ set2_des_seq, s2ds, s2\n+        set3_des_seq, \/\/ set3_des_seq, s3ds, s3\n+        set_a_background, \/\/ set_a_background, setab, AB\n+        set_a_foreground, \/\/ set_a_foreground, setaf, AF\n+        set_color_band, \/\/ set_color_band, setcolor, Yz\n+        set_lr_margin, \/\/ set_lr_margin, smglr, ML\n+        set_page_length, \/\/ set_page_length, slines, YZ\n+        set_tb_margin, \/\/ set_tb_margin, smgtb, MT\n+        enter_horizontal_hl_mode, \/\/ enter_horizontal_hl_mode, ehhlm, Xh\n+        enter_left_hl_mode, \/\/ enter_left_hl_mode, elhlm, Xl\n+        enter_low_hl_mode, \/\/ enter_low_hl_mode, elohlm, Xo\n+        enter_right_hl_mode, \/\/ enter_right_hl_mode, erhlm, Xr\n+        enter_top_hl_mode, \/\/ enter_top_hl_mode, ethlm, Xt\n+        enter_vertical_hl_mode, \/\/ enter_vertical_hl_mode, evhlm, Xv\n+        set_a_attributes, \/\/ set_a_attributes, sgr1, sA\n+        set_pglen_inch, \/\/ set_pglen_inch, slength, sL)\n@@ -518,2 +516,3 @@\n-             BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n-            br.lines().map(String::trim)\n+                BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n+            br.lines()\n+                    .map(String::trim)\n@@ -542,3 +541,1 @@\n-    public static String getInfoCmp(\n-            String terminal\n-    ) throws IOException, InterruptedException {\n+    public static String getInfoCmp(String terminal) throws IOException, InterruptedException {\n@@ -566,2 +563,1 @@\n-            Map<Capability, String> strings\n-    ) {\n+            Map<Capability, String> strings) {\n@@ -612,1 +608,1 @@\n-             BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n+                BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n@@ -620,3 +616,16 @@\n-        for (String s : Arrays.asList(\"dumb\", \"dumb-color\", \"ansi\", \"xterm\", \"xterm-256color\",\n-                \"windows\", \"windows-256color\", \"windows-conemu\", \"windows-vtp\",\n-                \"screen\", \"screen-256color\", \"rxvt-unicode\", \"rxvt-unicode-256color\", \"rxvt-basic\", \"rxvt\")) {\n+        for (String s : Arrays.asList(\n+                \"dumb\",\n+                \"dumb-color\",\n+                \"ansi\",\n+                \"xterm\",\n+                \"xterm-256color\",\n+                \"windows\",\n+                \"windows-256color\",\n+                \"windows-conemu\",\n+                \"windows-vtp\",\n+                \"screen\",\n+                \"screen-256color\",\n+                \"rxvt-unicode\",\n+                \"rxvt-unicode-256color\",\n+                \"rxvt-basic\",\n+                \"rxvt\")) {\n@@ -626,1 +635,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InfoCmp.java","additions":488,"deletions":480,"binary":false,"changes":968,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -25,1 +25,0 @@\n-\n@@ -69,3 +68,4 @@\n-        decoder = Charset.defaultCharset().newDecoder().onMalformedInput(\n-                CodingErrorAction.REPLACE).onUnmappableCharacter(\n-                CodingErrorAction.REPLACE);\n+        decoder = Charset.defaultCharset()\n+                .newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -90,2 +90,1 @@\n-    public InputStreamReader(InputStream in, final String enc)\n-            throws UnsupportedEncodingException {\n+    public InputStreamReader(InputStream in, final String enc) throws UnsupportedEncodingException {\n@@ -98,3 +97,4 @@\n-            decoder = Charset.forName(enc).newDecoder().onMalformedInput(\n-                    CodingErrorAction.REPLACE).onUnmappableCharacter(\n-                    CodingErrorAction.REPLACE);\n+            decoder = Charset.forName(enc)\n+                    .newDecoder()\n+                    .onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -102,2 +102,1 @@\n-            throw (UnsupportedEncodingException)\n-                    new UnsupportedEncodingException(enc).initCause(e);\n+            throw (UnsupportedEncodingException) new UnsupportedEncodingException(enc).initCause(e);\n@@ -137,3 +136,3 @@\n-        decoder = charset.newDecoder().onMalformedInput(\n-                CodingErrorAction.REPLACE).onUnmappableCharacter(\n-                CodingErrorAction.REPLACE);\n+        decoder = charset.newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -260,2 +259,1 @@\n-                        if ((in.available() == 0)\n-                            && (out.position() > offset)) {\n+                        if ((in.available() == 0) && (out.position() > offset)) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InputStreamReader.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -52,3 +52,2 @@\n-    public static int distance(CharSequence source, CharSequence target,\n-                               int deleteCost, int insertCost,\n-                               int replaceCost, int swapCost) {\n+    public static int distance(\n+            CharSequence source, CharSequence target, int deleteCost, int insertCost, int replaceCost, int swapCost) {\n@@ -118,1 +117,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Levenshtein.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -76,2 +76,1 @@\n-        }\n-        else {\n+        } else {\n@@ -87,1 +86,1 @@\n-\/\/            \/\/ Special handling for the last message if its a throwable, render its stack on the next line\n+\/\/            \/\/ Special handling for the last message if it's a throwable, render its stack on the next line\n@@ -90,2 +89,1 @@\n-\/\/            }\n-\/\/            else {\n+\/\/            } else {\n@@ -125,1 +123,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Log.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -87,2 +87,1 @@\n-            return (int) (reader.available() * this.encoder.averageBytesPerChar())\n-                    + bytes.remaining();\n+            return (int) (reader.available() * this.encoder.averageBytesPerChar()) + bytes.remaining();\n@@ -127,1 +126,0 @@\n-\n@@ -138,4 +136,6 @@\n-            this(inputStream,\n-                (encoding != null ? encoding : Charset.defaultCharset()).newDecoder()\n-                    .onMalformedInput(CodingErrorAction.REPLACE)\n-                    .onUnmappableCharacter(CodingErrorAction.REPLACE));\n+            this(\n+                    inputStream,\n+                    (encoding != null ? encoding : Charset.defaultCharset())\n+                            .newDecoder()\n+                            .onMalformedInput(CodingErrorAction.REPLACE)\n+                            .onUnmappableCharacter(CodingErrorAction.REPLACE));\n@@ -204,2 +204,2 @@\n-                    int nb = input.readBuffered(bytes.array(), bytes.limit(),\n-                                            bytes.capacity() - bytes.limit(), t.timeout());\n+                    int nb = input.readBuffered(\n+                            bytes.array(), bytes.limit(), bytes.capacity() - bytes.limit(), t.timeout());\n@@ -230,1 +230,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlocking.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -77,1 +77,1 @@\n-        b[off] = (byte)c;\n+        b[off] = (byte) c;\n@@ -118,2 +118,1 @@\n-    public void shutdown() {\n-    }\n+    public void shutdown() {}\n@@ -122,1 +121,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStream.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -29,11 +29,9 @@\n-public class NonBlockingInputStreamImpl\n-    extends NonBlockingInputStream\n-{\n-    private InputStream in;                  \/\/ The actual input stream\n-    private int         b = READ_EXPIRED;    \/\/ Recently read byte\n-\n-    private String      name;\n-    private boolean     threadIsReading      = false;\n-    private IOException exception            = null;\n-    private long        threadDelay          = 60 * 1000;\n-    private Thread      thread;\n+public class NonBlockingInputStreamImpl extends NonBlockingInputStream {\n+    private InputStream in; \/\/ The actual input stream\n+    private int b = READ_EXPIRED; \/\/ Recently read byte\n+\n+    private String name;\n+    private boolean threadIsReading = false;\n+    private IOException exception = null;\n+    private long threadDelay = 60 * 1000;\n+    private Thread thread;\n@@ -100,2 +98,1 @@\n-            if (!isPeek)\n-                exception = null;\n+            if (!isPeek) exception = null;\n@@ -112,2 +109,1 @@\n-        }\n-        else if (!isPeek && timeout <= 0L && !threadIsReading) {\n+        } else if (!isPeek && timeout <= 0L && !threadIsReading) {\n@@ -115,2 +111,1 @@\n-        }\n-        else {\n+        } else {\n@@ -131,1 +126,1 @@\n-            while (!t.elapsed())  {\n+            while (!t.elapsed()) {\n@@ -137,2 +132,1 @@\n-                }\n-                catch (InterruptedException e) {\n+                } catch (InterruptedException e) {\n@@ -146,2 +140,1 @@\n-                    if (!isPeek)\n-                        exception = null;\n+                    if (!isPeek) exception = null;\n@@ -171,1 +164,1 @@\n-    private void run () {\n+    private void run() {\n@@ -239,1 +232,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStreamImpl.java","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -60,5 +60,1 @@\n-        return buffer.hasRemaining()\n-                ? 0\n-                : closed\n-                    ? EOF\n-                    : READ_EXPIRED;\n+        return buffer.hasRemaining() ? 0 : closed ? EOF : READ_EXPIRED;\n@@ -170,1 +166,1 @@\n-            NonBlockingPumpInputStream.this.write(new byte[] { (byte) b }, 0, 1);\n+            NonBlockingPumpInputStream.this.write(new byte[] {(byte) b}, 0, 1);\n@@ -187,1 +183,0 @@\n-\n@@ -189,1 +184,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpInputStream.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -124,1 +124,1 @@\n-                                throw new IOException( \"Timeout reading\" );\n+                                throw new IOException(\"Timeout reading\");\n@@ -210,2 +210,1 @@\n-        public void flush() throws IOException {\n-        }\n+        public void flush() throws IOException {}\n@@ -217,1 +216,0 @@\n-\n@@ -219,1 +217,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpReader.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -26,2 +26,1 @@\n-    public void shutdown() {\n-    }\n+    public void shutdown() {}\n@@ -112,1 +111,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReader.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -31,3 +31,1 @@\n-public class NonBlockingReaderImpl\n-    extends NonBlockingReader\n-{\n+public class NonBlockingReaderImpl extends NonBlockingReader {\n@@ -36,2 +34,2 @@\n-    private Reader in;                  \/\/ The actual input stream\n-    private int    ch   = READ_EXPIRED; \/\/ Recently read character\n+    private Reader in; \/\/ The actual input stream\n+    private int ch = READ_EXPIRED; \/\/ Recently read character\n@@ -39,5 +37,5 @@\n-    private String      name;\n-    private boolean     threadIsReading      = false;\n-    private IOException exception            = null;\n-    private long        threadDelay          = 60 * 1000;\n-    private Thread      thread;\n+    private String name;\n+    private boolean threadIsReading = false;\n+    private IOException exception = null;\n+    private long threadDelay = 60 * 1000;\n+    private Thread thread;\n@@ -138,2 +136,1 @@\n-            if (!isPeek)\n-                exception = null;\n+            if (!isPeek) exception = null;\n@@ -150,2 +147,1 @@\n-        }\n-        else if (!isPeek && timeout <= 0L && !threadIsReading) {\n+        } else if (!isPeek && timeout <= 0L && !threadIsReading) {\n@@ -153,2 +149,1 @@\n-        }\n-        else {\n+        } else {\n@@ -169,1 +164,1 @@\n-            while (!t.elapsed())  {\n+            while (!t.elapsed()) {\n@@ -175,2 +170,1 @@\n-                }\n-                catch (InterruptedException e) {\n+                } catch (InterruptedException e) {\n@@ -184,2 +178,1 @@\n-                    if (!isPeek)\n-                        exception = null;\n+                    if (!isPeek) exception = null;\n@@ -209,1 +202,1 @@\n-    private void run () {\n+    private void run() {\n@@ -248,3 +241,3 @@\n-\/\/                    if (charRead < 0) {\n-\/\/                        continue;\n-\/\/                    }\n+                    \/\/                    if (charRead < 0) {\n+                    \/\/                        continue;\n+                    \/\/                    }\n@@ -253,1 +246,1 @@\n-\/\/                    charRead = -1;\n+                    \/\/                    charRead = -1;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReaderImpl.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -12,2 +12,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n@@ -17,1 +15,2 @@\n-    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").toLowerCase().contains(\"win\");\n+    public static final boolean IS_LINUX =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"linux\");\n@@ -19,3 +18,11 @@\n-    public static final boolean IS_CYGWIN = IS_WINDOWS\n-            && System.getenv(\"PWD\") != null\n-            && System.getenv(\"PWD\").startsWith(\"\/\");\n+    public static final boolean IS_WINDOWS =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"win\");\n+\n+    public static final boolean IS_OSX =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"mac\");\n+\n+    public static final boolean IS_AIX =\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"aix\");\n+\n+    public static final boolean IS_CYGWIN =\n+            IS_WINDOWS && System.getenv(\"PWD\") != null && System.getenv(\"PWD\").startsWith(\"\/\");\n@@ -31,1 +38,1 @@\n-                || System.getenv(\"MSYSTEM\").equals(\"MSYS\"));\n+                    || System.getenv(\"MSYSTEM\").equals(\"MSYS\"));\n@@ -39,5 +46,1 @@\n-    public static final boolean IS_CONEMU = IS_WINDOWS\n-            && System.getenv(\"ConEmuPID\") != null;\n-\n-    public static final boolean IS_OSX = System.getProperty(\"os.name\").toLowerCase().contains(\"mac\");\n-    public static final boolean IS_AIX = System.getProperty(\"os.name\").equals(\"AIX\");\n+    public static final boolean IS_CONEMU = IS_WINDOWS && System.getenv(\"ConEmuPID\") != null;\n@@ -51,0 +54,4 @@\n+    private static boolean isExecutable(File f) {\n+        return f.canExecute() && !f.isDirectory();\n+    }\n+\n@@ -52,27 +59,26 @@\n-        String tty;\n-        String stty;\n-        String sttyfopt;\n-        String infocmp;\n-        String test;\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            tty = null;\n-            stty = null;\n-            sttyfopt = null;\n-            infocmp = null;\n-            test = null;\n-            String path = System.getenv(\"PATH\");\n-            if (path != null) {\n-                String[] paths = path.split(\";\");\n-                for (String p : paths) {\n-                    if (tty == null && new File(p, \"tty.exe\").exists()) {\n-                        tty = new File(p, \"tty.exe\").getAbsolutePath();\n-                    }\n-                    if (stty == null && new File(p, \"stty.exe\").exists()) {\n-                        stty = new File(p, \"stty.exe\").getAbsolutePath();\n-                    }\n-                    if (infocmp == null && new File(p, \"infocmp.exe\").exists()) {\n-                        infocmp = new File(p, \"infocmp.exe\").getAbsolutePath();\n-                    }\n-                    if (test == null && new File(p, \"test.exe\").exists()) {\n-                        test = new File(p, \"test.exe\").getAbsolutePath();\n-                    }\n+        boolean cygwinOrMsys = OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM;\n+        String suffix = cygwinOrMsys ? \".exe\" : \"\";\n+        String tty = null;\n+        String stty = null;\n+        String sttyfopt = null;\n+        String infocmp = null;\n+        String test = null;\n+        String path = System.getenv(\"PATH\");\n+        if (path != null) {\n+            String[] paths = path.split(File.pathSeparator);\n+            for (String p : paths) {\n+                File ttyFile = new File(p, \"tty\" + suffix);\n+                if (tty == null && isExecutable(ttyFile)) {\n+                    tty = ttyFile.getAbsolutePath();\n+                }\n+                File sttyFile = new File(p, \"stty\" + suffix);\n+                if (stty == null && isExecutable(sttyFile)) {\n+                    stty = sttyFile.getAbsolutePath();\n+                }\n+                File infocmpFile = new File(p, \"infocmp\" + suffix);\n+                if (infocmp == null && isExecutable(infocmpFile)) {\n+                    infocmp = infocmpFile.getAbsolutePath();\n+                }\n+                File testFile = new File(p, \"test\" + suffix);\n+                if (test == null && isExecutable(testFile)) {\n+                    test = testFile.getAbsolutePath();\n@@ -81,19 +87,0 @@\n-            if (tty == null) {\n-                tty = \"tty.exe\";\n-            }\n-            if (stty == null) {\n-                stty = \"stty.exe\";\n-            }\n-            if (infocmp == null) {\n-                infocmp = \"infocmp.exe\";\n-            }\n-            if (test == null) {\n-                test = \"test.exe\";\n-            }\n-        } else {\n-            tty = \"tty\";\n-            stty = IS_OSX ? \"\/bin\/stty\" : \"stty\";\n-            sttyfopt = IS_OSX ? \"-f\" : \"-F\";\n-            infocmp = \"infocmp\";\n-            test = isTestCommandValid(\"\/usr\/bin\/test\") ? \"\/usr\/bin\/test\"\n-                                                       : \"\/bin\/test\";\n@@ -101,0 +88,13 @@\n+        if (tty == null) {\n+            tty = \"tty\" + suffix;\n+        }\n+        if (stty == null) {\n+            stty = \"stty\" + suffix;\n+        }\n+        if (infocmp == null) {\n+            infocmp = \"infocmp\" + suffix;\n+        }\n+        if (test == null) {\n+            test = \"test\" + suffix;\n+        }\n+        sttyfopt = IS_OSX ? \"-f\" : \"-F\";\n@@ -107,4 +107,0 @@\n-\n-    private static boolean isTestCommandValid(String command) {\n-        return Files.isExecutable(Paths.get(command));\n-    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":59,"deletions":63,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -381,1 +381,0 @@\n-\n@@ -467,1 +466,0 @@\n-\n@@ -469,1 +467,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/PumpReader.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -21,2 +21,1 @@\n-public final class ShutdownHooks\n-{\n+public final class ShutdownHooks {\n@@ -32,2 +31,1 @@\n-            hook = addHook(new Thread(\"JLine Shutdown Hook\")\n-            {\n+            hook = addHook(new Thread(\"JLine Shutdown Hook\") {\n@@ -56,2 +54,1 @@\n-            }\n-            catch (Throwable e) {\n+            } catch (Throwable e) {\n@@ -94,2 +91,1 @@\n-        }\n-        catch (IllegalStateException e) {\n+        } catch (IllegalStateException e) {\n@@ -103,2 +99,1 @@\n-    public interface Task\n-    {\n+    public interface Task {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ShutdownHooks.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author(s).\n@@ -24,2 +24,1 @@\n-    private Signals() {\n-    }\n+    private Signals() {}\n@@ -44,2 +43,2 @@\n-            Object signalHandler = Proxy.newProxyInstance(loader,\n-                    new Class<?>[]{signalHandlerClass}, (proxy, method, args) -> {\n+            Object signalHandler =\n+                    Proxy.newProxyInstance(loader, new Class<?>[] {signalHandlerClass}, (proxy, method, args) -> {\n@@ -104,2 +103,1 @@\n-        return signalClass.getMethod(\"handle\", signalClass, signalHandlerClass)\n-                .invoke(null, signal, handler);\n+        return signalClass.getMethod(\"handle\", signalClass, signalHandlerClass).invoke(null, signal, handler);\n@@ -123,1 +121,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Signals.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2019, the original author(s).\n@@ -11,2 +11,0 @@\n-import java.util.Objects;\n-import java.util.Collections;\n@@ -14,0 +12,1 @@\n+import java.util.Collections;\n@@ -15,0 +14,4 @@\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import jdk.internal.org.jline.terminal.Size;\n@@ -18,1 +21,0 @@\n-import jdk.internal.org.jline.terminal.Size;\n@@ -22,1 +24,1 @@\n-    protected final AbstractTerminal terminal;\n+    protected final Terminal terminal;\n@@ -24,5 +26,0 @@\n-    protected List<AttributedString> oldLines = Collections.emptyList();\n-    protected List<AttributedString> linesToRestore = Collections.emptyList();\n-    protected int rows;\n-    protected int columns;\n-    protected boolean force;\n@@ -32,0 +29,3 @@\n+    protected Display display;\n+    protected List<AttributedString> lines = Collections.emptyList();\n+    protected int scrollRegion;\n@@ -37,4 +37,2 @@\n-    public static Status getStatus(Terminal terminal, boolean create) {\n-        return terminal instanceof AbstractTerminal\n-                ? ((AbstractTerminal) terminal).getStatus(create)\n-                : null;\n+    public static Optional<Status> getExistingStatus(Terminal terminal) {\n+        return Optional.ofNullable(getStatus(terminal, false));\n@@ -43,0 +41,3 @@\n+    public static Status getStatus(Terminal terminal, boolean create) {\n+        return terminal instanceof AbstractTerminal ? ((AbstractTerminal) terminal).getStatus(create) : null;\n+    }\n@@ -44,1 +45,2 @@\n-    public Status(AbstractTerminal terminal) {\n+    @SuppressWarnings(\"this-escape\")\n+    public Status(Terminal terminal) {\n@@ -47,3 +49,3 @@\n-            && terminal.getStringCapability(Capability.save_cursor) != null\n-            && terminal.getStringCapability(Capability.restore_cursor) != null\n-            && terminal.getStringCapability(Capability.cursor_address) != null;\n+                && terminal.getStringCapability(Capability.save_cursor) != null\n+                && terminal.getStringCapability(Capability.restore_cursor) != null\n+                && terminal.getStringCapability(Capability.cursor_address) != null;\n@@ -51,6 +53,1 @@\n-            char borderChar = '\\u2700';\n-            AttributedStringBuilder bb = new AttributedStringBuilder();\n-            for (int i = 0; i < 200; i++) {\n-                bb.append(borderChar);\n-            }\n-            borderString = bb.toAttributedString();\n+            display = new MovingCursorDisplay(terminal);\n@@ -58,0 +55,2 @@\n+            display.reset();\n+            scrollRegion = display.rows - 1;\n@@ -61,0 +60,7 @@\n+    public void close() {\n+        terminal.puts(Capability.save_cursor);\n+        terminal.puts(Capability.change_scroll_region, 0, display.rows - 1);\n+        terminal.puts(Capability.restore_cursor);\n+        terminal.flush();\n+    }\n+\n@@ -66,4 +72,1 @@\n-        Size size = terminal.getSize();\n-        this.rows = size.getRows();\n-        this.columns = size.getColumns();\n-        this.force = true;\n+        resize(terminal.getSize());\n@@ -72,2 +75,2 @@\n-    public void reset() {\n-        this.force = true;\n+    public void resize(Size size) {\n+        display.resize(size.getRows(), size.getColumns());\n@@ -76,3 +79,5 @@\n-    public void hardReset() {\n-        if (suspended) {\n-            return;\n+    public void reset() {\n+        if (supported) {\n+            display.reset();\n+            scrollRegion = display.rows;\n+            terminal.puts(Capability.change_scroll_region, 0, scrollRegion);\n@@ -80,5 +85,0 @@\n-        List<AttributedString> lines = new ArrayList<>(oldLines);\n-        int b = border;\n-        update(null);\n-        border = b;\n-        update(lines);\n@@ -91,1 +91,1 @@\n-        update(oldLines);\n+        update(lines);\n@@ -94,2 +94,2 @@\n-    public void clear() {\n-        privateClear(oldLines.size());\n+    public void hide() {\n+        update(Collections.emptyList());\n@@ -98,4 +98,2 @@\n-    private void clearAll() {\n-        int b = border;\n-        border = 0;\n-        privateClear(oldLines.size() + b);\n+    public void update(List<AttributedString> lines) {\n+        update(lines, true);\n@@ -104,9 +102,2 @@\n-    private void privateClear(int statusSize) {\n-        List<AttributedString> as = new ArrayList<>();\n-        for (int i = 0; i < statusSize; i++) {\n-            as.add(new AttributedString(\"\"));\n-        }\n-        if (!as.isEmpty()) {\n-            update(as);\n-        }\n-    }\n+    private final AttributedString ellipsis =\n+            new AttributedStringBuilder().append(\"\\u2026\", AttributedStyle.INVERSE).toAttributedString();\n@@ -114,1 +105,5 @@\n-    public void update(List<AttributedString> lines) {\n+    \/**\n+     * Returns <code>true<\/code> if the cursor may be misplaced and should\n+     * be updated.\n+     *\/\n+    public void update(List<AttributedString> lines, boolean flush) {\n@@ -118,3 +113,1 @@\n-        if (lines == null) {\n-            lines = Collections.emptyList();\n-        }\n+        this.lines = new ArrayList<>(lines);\n@@ -122,1 +115,0 @@\n-            linesToRestore = new ArrayList<>(lines);\n@@ -125,2 +117,7 @@\n-        if (lines.isEmpty()) {\n-            clearAll();\n+\n+        lines = new ArrayList<>(lines);\n+        \/\/ add border\n+        int rows = display.rows;\n+        int columns = display.columns;\n+        if (border == 1 && !lines.isEmpty() && rows > 1) {\n+            lines.add(0, getBorderString(columns));\n@@ -128,2 +125,15 @@\n-        if (oldLines.equals(lines) && !force) {\n-            return;\n+        \/\/ trim or complete lines to the full width\n+        for (int i = 0; i < lines.size(); i++) {\n+            AttributedString str = lines.get(i);\n+            if (str.columnLength() > columns) {\n+                str = new AttributedStringBuilder(columns)\n+                        .append(lines.get(i).columnSubSequence(0, columns - ellipsis.columnLength()))\n+                        .append(ellipsis)\n+                        .toAttributedString();\n+            } else if (str.columnLength() < columns) {\n+                str = new AttributedStringBuilder(columns)\n+                        .append(str)\n+                        .append(' ', columns - str.columnLength())\n+                        .toAttributedString();\n+            }\n+            lines.set(i, str);\n@@ -131,4 +141,10 @@\n-        int statusSize = lines.size() + (lines.size() == 0 ? 0 : border);\n-        int nb = statusSize - oldLines.size() - (oldLines.size() == 0 ? 0 : border);\n-        if (nb > 0) {\n-            for (int i = 0; i < nb; i++) {\n+\n+        List<AttributedString> oldLines = this.display.oldLines;\n+\n+        int newScrollRegion = display.rows - 1 - lines.size();\n+        \/\/ Update the scroll region if needed.\n+        \/\/ Note that settings the scroll region usually moves the cursor, so we need to get ready for that.\n+        if (newScrollRegion < scrollRegion) {\n+            \/\/ We need to scroll up to grow the status bar\n+            terminal.puts(Capability.save_cursor);\n+            for (int i = newScrollRegion; i < scrollRegion; i++) {\n@@ -137,1 +153,3 @@\n-            for (int i = 0; i < nb; i++) {\n+            terminal.puts(Capability.change_scroll_region, 0, newScrollRegion);\n+            terminal.puts(Capability.restore_cursor);\n+            for (int i = newScrollRegion; i < scrollRegion; i++) {\n@@ -140,0 +158,6 @@\n+            scrollRegion = newScrollRegion;\n+        } else if (newScrollRegion > scrollRegion) {\n+            terminal.puts(Capability.save_cursor);\n+            terminal.puts(Capability.change_scroll_region, 0, newScrollRegion);\n+            terminal.puts(Capability.restore_cursor);\n+            scrollRegion = newScrollRegion;\n@@ -141,5 +165,9 @@\n-        terminal.puts(Capability.save_cursor);\n-        terminal.puts(Capability.cursor_address, rows - statusSize, 0);\n-        if (!terminal.puts(Capability.clr_eos)) {\n-            for (int i = rows - statusSize; i < rows; i++) {\n-                terminal.puts(Capability.cursor_address, i, 0);\n+\n+        \/\/ if the display has more lines, we need to add empty ones to make sure they will be erased\n+        List<AttributedString> toDraw = new ArrayList<>(lines);\n+        int nbToDraw = toDraw.size();\n+        int nbOldLines = oldLines.size();\n+        if (nbOldLines > nbToDraw) {\n+            terminal.puts(Capability.save_cursor);\n+            terminal.puts(Capability.cursor_address, display.rows - nbOldLines, 0);\n+            for (int i = 0; i < nbOldLines - nbToDraw; i++) {\n@@ -147,0 +175,4 @@\n+                if (i < nbOldLines - nbToDraw - 1) {\n+                    terminal.puts(Capability.cursor_down);\n+                }\n+                oldLines.remove(0);\n@@ -148,0 +180,1 @@\n+            terminal.puts(Capability.restore_cursor);\n@@ -149,12 +182,10 @@\n-        if (border == 1 && lines.size() > 0) {\n-            terminal.puts(Capability.cursor_address, rows - statusSize, 0);\n-            borderString.columnSubSequence(0, columns).print(terminal);\n-        }\n-        for (int i = 0; i < lines.size(); i++) {\n-            terminal.puts(Capability.cursor_address, rows - lines.size() + i, 0);\n-            if (lines.get(i).length() > columns) {\n-                AttributedStringBuilder asb = new AttributedStringBuilder();\n-                asb.append(lines.get(i).substring(0, columns - 3)).append(\"...\", new AttributedStyle(AttributedStyle.INVERSE));\n-                asb.toAttributedString().columnSubSequence(0, columns).print(terminal);\n-            } else {\n-                lines.get(i).columnSubSequence(0, columns).print(terminal);\n+        \/\/ update display\n+        display.update(lines, -1, flush);\n+    }\n+\n+    private AttributedString getBorderString(int columns) {\n+        if (borderString == null || borderString.length() != columns) {\n+            char borderChar = '\\u2700';\n+            AttributedStringBuilder bb = new AttributedStringBuilder();\n+            for (int i = 0; i < columns; i++) {\n+                bb.append(borderChar);\n@@ -162,0 +193,1 @@\n+            borderString = bb.toAttributedString();\n@@ -163,5 +195,1 @@\n-        terminal.puts(Capability.change_scroll_region, 0, rows - 1 - statusSize);\n-        terminal.puts(Capability.restore_cursor);\n-        terminal.flush();\n-        oldLines = new ArrayList<>(lines);\n-        force = false;\n+        return borderString;\n@@ -170,0 +198,5 @@\n+    \/**\n+     * The {@code suspend} method is used when a full-screen.\n+     * If the status was not already suspended, the lines\n+     * used by the status are cleared during this call.\n+     *\/\n@@ -171,2 +204,2 @@\n-        if (suspended) {\n-            return;\n+        if (!suspended) {\n+            suspended = true;\n@@ -174,5 +207,0 @@\n-        linesToRestore = new ArrayList<>(oldLines);\n-        int b = border;\n-        update(null);\n-        border = b;\n-        suspended = true;\n@@ -181,0 +209,6 @@\n+    \/**\n+     * The {@code restore()} call is the opposite of {@code suspend()} and\n+     * will make the status bar be updated again.\n+     * If the status was suspended, the lines\n+     * used by the status will be drawn during this call.\n+     *\/\n@@ -182,2 +216,3 @@\n-        if (!suspended) {\n-            return;\n+        if (suspended) {\n+            suspended = false;\n+            update(this.lines);\n@@ -185,3 +220,0 @@\n-        suspended = false;\n-        update(linesToRestore);\n-        linesToRestore = Collections.emptyList();\n@@ -191,1 +223,11 @@\n-        return oldLines.size() + border;\n+        return size(this.lines);\n+    }\n+\n+    private int size(List<?> lines) {\n+        int l = lines.size();\n+        return l > 0 ? l + border : 0;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Status[\" + \"supported=\" + supported + ']';\n@@ -194,0 +236,37 @@\n+    static class MovingCursorDisplay extends Display {\n+        protected int firstLine;\n+\n+        public MovingCursorDisplay(Terminal terminal) {\n+            super(terminal, false);\n+        }\n+\n+        @Override\n+        public void update(List<AttributedString> newLines, int targetCursorPos, boolean flush) {\n+            cursorPos = -1;\n+            firstLine = rows - newLines.size();\n+            super.update(newLines, targetCursorPos, flush);\n+            if (cursorPos != -1) {\n+                terminal.puts(Capability.restore_cursor);\n+            }\n+        }\n+\n+        @Override\n+        protected void moveVisualCursorTo(int targetPos, List<AttributedString> newLines) {\n+            initCursor();\n+            super.moveVisualCursorTo(targetPos, newLines);\n+        }\n+\n+        @Override\n+        protected int moveVisualCursorTo(int i1) {\n+            initCursor();\n+            return super.moveVisualCursorTo(i1);\n+        }\n+\n+        void initCursor() {\n+            if (cursorPos == -1) {\n+                terminal.puts(Capability.save_cursor);\n+                terminal.puts(Capability.cursor_address, firstLine, 0);\n+                cursorPos = 0;\n+            }\n+        }\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Status.java","additions":182,"deletions":103,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -58,6 +58,6 @@\n-           \/\/ load indexed color\n-           Integer color = color(name);\n-           if (color != null && color != -1) {\n-               color = Colors.DEFAULT_COLORS_256[color];\n-           }\n-           return color;\n+            \/\/ load indexed color\n+            Integer color = color(name);\n+            if (color != null && color != -1) {\n+                color = Colors.DEFAULT_COLORS_256[color];\n+            }\n+            return color;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/StyleResolver.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2018, the original author(s).\n@@ -47,1 +47,0 @@\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Timeout.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2016, the original author(s).\n@@ -13,2 +13,1 @@\n-    private WCWidth() {\n-    }\n+    private WCWidth() {}\n@@ -47,2 +46,1 @@\n-    public static int wcwidth(int ucs)\n-    {\n+    public static int wcwidth(int ucs) {\n@@ -51,4 +49,2 @@\n-        if (ucs == 0)\n-            return 0;\n-        if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))\n-            return -1;\n+        if (ucs == 0) return 0;\n+        if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return -1;\n@@ -57,2 +53,1 @@\n-        if (bisearch(ucs, combining, combining.length - 1))\n-            return 0;\n+        if (bisearch(ucs, combining, combining.length - 1)) return 0;\n@@ -61,15 +56,17 @@\n-        return 1 +\n-                ((ucs >= 0x1100 &&\n-                        (ucs <= 0x115f ||                           \/* Hangul Jamo init. consonants *\/\n-                                ucs == 0x2329 || ucs == 0x232a ||\n-                                (ucs >= 0x2e80 && ucs <= 0xa4cf &&\n-                                        ucs != 0x303f) ||           \/* CJK ... Yi *\/\n-                                (ucs >= 0xac00 && ucs <= 0xd7a3) || \/* Hangul Syllables *\/\n-                                (ucs >= 0xf900 && ucs <= 0xfaff) || \/* CJK Compatibility Ideographs *\/\n-                                (ucs >= 0xfe10 && ucs <= 0xfe19) || \/* Vertical forms *\/\n-                                (ucs >= 0xfe30 && ucs <= 0xfe6f) || \/* CJK Compatibility Forms *\/\n-                                (ucs >= 0xff00 && ucs <= 0xff60) || \/* Fullwidth Forms *\/\n-                                (ucs >= 0xffe0 && ucs <= 0xffe6) ||\n-                                (ucs >= 0x1f000 && ucs <= 0x1feee) ||\n-                                (ucs >= 0x20000 && ucs <= 0x2fffd) ||\n-                                (ucs >= 0x30000 && ucs <= 0x3fffd))) ? 1 : 0);\n+        return 1\n+                + ((ucs >= 0x1100\n+                                && (ucs <= 0x115f\n+                                        || \/* Hangul Jamo init. consonants *\/ ucs == 0x2329\n+                                        || ucs == 0x232a\n+                                        || (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f)\n+                                        || \/* CJK ... Yi *\/ (ucs >= 0xac00 && ucs <= 0xd7a3)\n+                                        || \/* Hangul Syllables *\/ (ucs >= 0xf900 && ucs <= 0xfaff)\n+                                        || \/* CJK Compatibility Ideographs *\/ (ucs >= 0xfe10 && ucs <= 0xfe19)\n+                                        || \/* Vertical forms *\/ (ucs >= 0xfe30 && ucs <= 0xfe6f)\n+                                        || \/* CJK Compatibility Forms *\/ (ucs >= 0xff00 && ucs <= 0xff60)\n+                                        || \/* Fullwidth Forms *\/ (ucs >= 0xffe0 && ucs <= 0xffe6)\n+                                        || (ucs >= 0x1f000 && ucs <= 0x1feee)\n+                                        || (ucs >= 0x20000 && ucs <= 0x2fffd)\n+                                        || (ucs >= 0x30000 && ucs <= 0x3fffd)))\n+                        ? 1\n+                        : 0);\n@@ -81,48 +78,48 @@\n-            new Interval( 0x0300, 0x036F ), new Interval( 0x0483, 0x0486 ), new Interval( 0x0488, 0x0489 ),\n-            new Interval( 0x0591, 0x05BD ), new Interval( 0x05BF, 0x05BF ), new Interval( 0x05C1, 0x05C2 ),\n-            new Interval( 0x05C4, 0x05C5 ), new Interval( 0x05C7, 0x05C7 ), new Interval( 0x0600, 0x0603 ),\n-            new Interval( 0x0610, 0x0615 ), new Interval( 0x064B, 0x065E ), new Interval( 0x0670, 0x0670 ),\n-            new Interval( 0x06D6, 0x06E4 ), new Interval( 0x06E7, 0x06E8 ), new Interval( 0x06EA, 0x06ED ),\n-            new Interval( 0x070F, 0x070F ), new Interval( 0x0711, 0x0711 ), new Interval( 0x0730, 0x074A ),\n-            new Interval( 0x07A6, 0x07B0 ), new Interval( 0x07EB, 0x07F3 ), new Interval( 0x0901, 0x0902 ),\n-            new Interval( 0x093C, 0x093C ), new Interval( 0x0941, 0x0948 ), new Interval( 0x094D, 0x094D ),\n-            new Interval( 0x0951, 0x0954 ), new Interval( 0x0962, 0x0963 ), new Interval( 0x0981, 0x0981 ),\n-            new Interval( 0x09BC, 0x09BC ), new Interval( 0x09C1, 0x09C4 ), new Interval( 0x09CD, 0x09CD ),\n-            new Interval( 0x09E2, 0x09E3 ), new Interval( 0x0A01, 0x0A02 ), new Interval( 0x0A3C, 0x0A3C ),\n-            new Interval( 0x0A41, 0x0A42 ), new Interval( 0x0A47, 0x0A48 ), new Interval( 0x0A4B, 0x0A4D ),\n-            new Interval( 0x0A70, 0x0A71 ), new Interval( 0x0A81, 0x0A82 ), new Interval( 0x0ABC, 0x0ABC ),\n-            new Interval( 0x0AC1, 0x0AC5 ), new Interval( 0x0AC7, 0x0AC8 ), new Interval( 0x0ACD, 0x0ACD ),\n-            new Interval( 0x0AE2, 0x0AE3 ), new Interval( 0x0B01, 0x0B01 ), new Interval( 0x0B3C, 0x0B3C ),\n-            new Interval( 0x0B3F, 0x0B3F ), new Interval( 0x0B41, 0x0B43 ), new Interval( 0x0B4D, 0x0B4D ),\n-            new Interval( 0x0B56, 0x0B56 ), new Interval( 0x0B82, 0x0B82 ), new Interval( 0x0BC0, 0x0BC0 ),\n-            new Interval( 0x0BCD, 0x0BCD ), new Interval( 0x0C3E, 0x0C40 ), new Interval( 0x0C46, 0x0C48 ),\n-            new Interval( 0x0C4A, 0x0C4D ), new Interval( 0x0C55, 0x0C56 ), new Interval( 0x0CBC, 0x0CBC ),\n-            new Interval( 0x0CBF, 0x0CBF ), new Interval( 0x0CC6, 0x0CC6 ), new Interval( 0x0CCC, 0x0CCD ),\n-            new Interval( 0x0CE2, 0x0CE3 ), new Interval( 0x0D41, 0x0D43 ), new Interval( 0x0D4D, 0x0D4D ),\n-            new Interval( 0x0DCA, 0x0DCA ), new Interval( 0x0DD2, 0x0DD4 ), new Interval( 0x0DD6, 0x0DD6 ),\n-            new Interval( 0x0E31, 0x0E31 ), new Interval( 0x0E34, 0x0E3A ), new Interval( 0x0E47, 0x0E4E ),\n-            new Interval( 0x0EB1, 0x0EB1 ), new Interval( 0x0EB4, 0x0EB9 ), new Interval( 0x0EBB, 0x0EBC ),\n-            new Interval( 0x0EC8, 0x0ECD ), new Interval( 0x0F18, 0x0F19 ), new Interval( 0x0F35, 0x0F35 ),\n-            new Interval( 0x0F37, 0x0F37 ), new Interval( 0x0F39, 0x0F39 ), new Interval( 0x0F71, 0x0F7E ),\n-            new Interval( 0x0F80, 0x0F84 ), new Interval( 0x0F86, 0x0F87 ), new Interval( 0x0F90, 0x0F97 ),\n-            new Interval( 0x0F99, 0x0FBC ), new Interval( 0x0FC6, 0x0FC6 ), new Interval( 0x102D, 0x1030 ),\n-            new Interval( 0x1032, 0x1032 ), new Interval( 0x1036, 0x1037 ), new Interval( 0x1039, 0x1039 ),\n-            new Interval( 0x1058, 0x1059 ), new Interval( 0x1160, 0x11FF ), new Interval( 0x135F, 0x135F ),\n-            new Interval( 0x1712, 0x1714 ), new Interval( 0x1732, 0x1734 ), new Interval( 0x1752, 0x1753 ),\n-            new Interval( 0x1772, 0x1773 ), new Interval( 0x17B4, 0x17B5 ), new Interval( 0x17B7, 0x17BD ),\n-            new Interval( 0x17C6, 0x17C6 ), new Interval( 0x17C9, 0x17D3 ), new Interval( 0x17DD, 0x17DD ),\n-            new Interval( 0x180B, 0x180D ), new Interval( 0x18A9, 0x18A9 ), new Interval( 0x1920, 0x1922 ),\n-            new Interval( 0x1927, 0x1928 ), new Interval( 0x1932, 0x1932 ), new Interval( 0x1939, 0x193B ),\n-            new Interval( 0x1A17, 0x1A18 ), new Interval( 0x1B00, 0x1B03 ), new Interval( 0x1B34, 0x1B34 ),\n-            new Interval( 0x1B36, 0x1B3A ), new Interval( 0x1B3C, 0x1B3C ), new Interval( 0x1B42, 0x1B42 ),\n-            new Interval( 0x1B6B, 0x1B73 ), new Interval( 0x1DC0, 0x1DCA ), new Interval( 0x1DFE, 0x1DFF ),\n-            new Interval( 0x200B, 0x200F ), new Interval( 0x202A, 0x202E ), new Interval( 0x2060, 0x2063 ),\n-            new Interval( 0x206A, 0x206F ), new Interval( 0x20D0, 0x20EF ), new Interval( 0x302A, 0x302F ),\n-            new Interval( 0x3099, 0x309A ), new Interval( 0xA806, 0xA806 ), new Interval( 0xA80B, 0xA80B ),\n-            new Interval( 0xA825, 0xA826 ), new Interval( 0xFB1E, 0xFB1E ), new Interval( 0xFE00, 0xFE0F ),\n-            new Interval( 0xFE20, 0xFE23 ), new Interval( 0xFEFF, 0xFEFF ), new Interval( 0xFFF9, 0xFFFB ),\n-            new Interval( 0x10A01, 0x10A03 ), new Interval( 0x10A05, 0x10A06 ), new Interval( 0x10A0C, 0x10A0F ),\n-            new Interval( 0x10A38, 0x10A3A ), new Interval( 0x10A3F, 0x10A3F ), new Interval( 0x1D167, 0x1D169 ),\n-            new Interval( 0x1D173, 0x1D182 ), new Interval( 0x1D185, 0x1D18B ), new Interval( 0x1D1AA, 0x1D1AD ),\n-            new Interval( 0x1D242, 0x1D244 ), new Interval( 0x1F3FB, 0x1F3FF ), new Interval( 0xE0001, 0xE0001 ),\n-            new Interval( 0xE0020, 0xE007F ), new Interval( 0xE0100, 0xE01EF )\n+        new Interval(0x0300, 0x036F), new Interval(0x0483, 0x0486), new Interval(0x0488, 0x0489),\n+        new Interval(0x0591, 0x05BD), new Interval(0x05BF, 0x05BF), new Interval(0x05C1, 0x05C2),\n+        new Interval(0x05C4, 0x05C5), new Interval(0x05C7, 0x05C7), new Interval(0x0600, 0x0603),\n+        new Interval(0x0610, 0x0615), new Interval(0x064B, 0x065E), new Interval(0x0670, 0x0670),\n+        new Interval(0x06D6, 0x06E4), new Interval(0x06E7, 0x06E8), new Interval(0x06EA, 0x06ED),\n+        new Interval(0x070F, 0x070F), new Interval(0x0711, 0x0711), new Interval(0x0730, 0x074A),\n+        new Interval(0x07A6, 0x07B0), new Interval(0x07EB, 0x07F3), new Interval(0x0901, 0x0902),\n+        new Interval(0x093C, 0x093C), new Interval(0x0941, 0x0948), new Interval(0x094D, 0x094D),\n+        new Interval(0x0951, 0x0954), new Interval(0x0962, 0x0963), new Interval(0x0981, 0x0981),\n+        new Interval(0x09BC, 0x09BC), new Interval(0x09C1, 0x09C4), new Interval(0x09CD, 0x09CD),\n+        new Interval(0x09E2, 0x09E3), new Interval(0x0A01, 0x0A02), new Interval(0x0A3C, 0x0A3C),\n+        new Interval(0x0A41, 0x0A42), new Interval(0x0A47, 0x0A48), new Interval(0x0A4B, 0x0A4D),\n+        new Interval(0x0A70, 0x0A71), new Interval(0x0A81, 0x0A82), new Interval(0x0ABC, 0x0ABC),\n+        new Interval(0x0AC1, 0x0AC5), new Interval(0x0AC7, 0x0AC8), new Interval(0x0ACD, 0x0ACD),\n+        new Interval(0x0AE2, 0x0AE3), new Interval(0x0B01, 0x0B01), new Interval(0x0B3C, 0x0B3C),\n+        new Interval(0x0B3F, 0x0B3F), new Interval(0x0B41, 0x0B43), new Interval(0x0B4D, 0x0B4D),\n+        new Interval(0x0B56, 0x0B56), new Interval(0x0B82, 0x0B82), new Interval(0x0BC0, 0x0BC0),\n+        new Interval(0x0BCD, 0x0BCD), new Interval(0x0C3E, 0x0C40), new Interval(0x0C46, 0x0C48),\n+        new Interval(0x0C4A, 0x0C4D), new Interval(0x0C55, 0x0C56), new Interval(0x0CBC, 0x0CBC),\n+        new Interval(0x0CBF, 0x0CBF), new Interval(0x0CC6, 0x0CC6), new Interval(0x0CCC, 0x0CCD),\n+        new Interval(0x0CE2, 0x0CE3), new Interval(0x0D41, 0x0D43), new Interval(0x0D4D, 0x0D4D),\n+        new Interval(0x0DCA, 0x0DCA), new Interval(0x0DD2, 0x0DD4), new Interval(0x0DD6, 0x0DD6),\n+        new Interval(0x0E31, 0x0E31), new Interval(0x0E34, 0x0E3A), new Interval(0x0E47, 0x0E4E),\n+        new Interval(0x0EB1, 0x0EB1), new Interval(0x0EB4, 0x0EB9), new Interval(0x0EBB, 0x0EBC),\n+        new Interval(0x0EC8, 0x0ECD), new Interval(0x0F18, 0x0F19), new Interval(0x0F35, 0x0F35),\n+        new Interval(0x0F37, 0x0F37), new Interval(0x0F39, 0x0F39), new Interval(0x0F71, 0x0F7E),\n+        new Interval(0x0F80, 0x0F84), new Interval(0x0F86, 0x0F87), new Interval(0x0F90, 0x0F97),\n+        new Interval(0x0F99, 0x0FBC), new Interval(0x0FC6, 0x0FC6), new Interval(0x102D, 0x1030),\n+        new Interval(0x1032, 0x1032), new Interval(0x1036, 0x1037), new Interval(0x1039, 0x1039),\n+        new Interval(0x1058, 0x1059), new Interval(0x1160, 0x11FF), new Interval(0x135F, 0x135F),\n+        new Interval(0x1712, 0x1714), new Interval(0x1732, 0x1734), new Interval(0x1752, 0x1753),\n+        new Interval(0x1772, 0x1773), new Interval(0x17B4, 0x17B5), new Interval(0x17B7, 0x17BD),\n+        new Interval(0x17C6, 0x17C6), new Interval(0x17C9, 0x17D3), new Interval(0x17DD, 0x17DD),\n+        new Interval(0x180B, 0x180D), new Interval(0x18A9, 0x18A9), new Interval(0x1920, 0x1922),\n+        new Interval(0x1927, 0x1928), new Interval(0x1932, 0x1932), new Interval(0x1939, 0x193B),\n+        new Interval(0x1A17, 0x1A18), new Interval(0x1B00, 0x1B03), new Interval(0x1B34, 0x1B34),\n+        new Interval(0x1B36, 0x1B3A), new Interval(0x1B3C, 0x1B3C), new Interval(0x1B42, 0x1B42),\n+        new Interval(0x1B6B, 0x1B73), new Interval(0x1DC0, 0x1DCA), new Interval(0x1DFE, 0x1DFF),\n+        new Interval(0x200B, 0x200F), new Interval(0x202A, 0x202E), new Interval(0x2060, 0x2063),\n+        new Interval(0x206A, 0x206F), new Interval(0x20D0, 0x20EF), new Interval(0x302A, 0x302F),\n+        new Interval(0x3099, 0x309A), new Interval(0xA806, 0xA806), new Interval(0xA80B, 0xA80B),\n+        new Interval(0xA825, 0xA826), new Interval(0xFB1E, 0xFB1E), new Interval(0xFE00, 0xFE0F),\n+        new Interval(0xFE20, 0xFE23), new Interval(0xFEFF, 0xFEFF), new Interval(0xFFF9, 0xFFFB),\n+        new Interval(0x10A01, 0x10A03), new Interval(0x10A05, 0x10A06), new Interval(0x10A0C, 0x10A0F),\n+        new Interval(0x10A38, 0x10A3A), new Interval(0x10A3F, 0x10A3F), new Interval(0x1D167, 0x1D169),\n+        new Interval(0x1D173, 0x1D182), new Interval(0x1D185, 0x1D18B), new Interval(0x1D1AA, 0x1D1AD),\n+        new Interval(0x1D242, 0x1D244), new Interval(0x1F3FB, 0x1F3FF), new Interval(0xE0001, 0xE0001),\n+        new Interval(0xE0020, 0xE007F), new Interval(0xE0100, 0xE01EF)\n@@ -146,2 +143,1 @@\n-        if (ucs < table[0].first || ucs > table[max].last)\n-            return false;\n+        if (ucs < table[0].first || ucs > table[max].last) return false;\n@@ -150,6 +146,3 @@\n-            if (ucs > table[mid].last)\n-                min = mid + 1;\n-            else if (ucs < table[mid].first)\n-                max = mid - 1;\n-            else\n-                return true;\n+            if (ucs > table[mid].last) min = mid + 1;\n+            else if (ucs < table[mid].first) max = mid - 1;\n+            else return true;\n@@ -160,2 +153,0 @@\n-\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/WCWidth.java","additions":75,"deletions":84,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2017, the original author or authors.\n+ * Copyright (c) 2002-2017, the original author(s).\n@@ -38,3 +38,5 @@\n-        this(out, charset.newDecoder()\n-                .onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE));\n+        this(\n+                out,\n+                charset.newDecoder()\n+                        .onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE));\n@@ -50,1 +52,1 @@\n-        write(new byte[] { (byte)b }, 0, 1);\n+        write(new byte[] {(byte) b}, 0, 1);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/WriterOutputStream.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,0 +8,3 @@\n+\tcivis=\\E[?25l, cvvis=\\E[?25h,\n+\tsmcup=\\E[?1049h, rmcup=\\E[?1049l,\n+\trc=\\E8, sc=\\E7,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-conemu.caps","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## JLine v3.22.0\n+## JLine v3.26.1\n@@ -6,1 +6,1 @@\n-Copyright (c) 2002-2018, the original author or authors.\n+Copyright (c) 2002-2023, the original author or authors.\n","filename":"src\/jdk.internal.le\/share\/legal\/jline.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.lang.reflect.Constructor;\n-\n-\/\/import com.sun.jna.Platform;\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.AbstractPty;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.freebsd.FreeBsdNativePty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.linux.LinuxNativePty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.osx.OsXNativePty;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.solaris.SolarisNativePty;\n-\n-public abstract class JnaNativePty extends AbstractPty implements Pty {\n-\n-    private final int master;\n-    private final int slave;\n-    private final int slaveOut;\n-    private final String name;\n-    private final FileDescriptor masterFD;\n-    private final FileDescriptor slaveFD;\n-    private final FileDescriptor slaveOutFD;\n-\n-    public static JnaNativePty current(TerminalProvider.Stream console) throws IOException {\n-\/\/        if (Platform.isMac()) {\n-\/\/            if (Platform.is64Bit() && Platform.isARM()) {\n-\/\/                throw new UnsupportedOperationException();\n-\/\/            }\n-\/\/            return OsXNativePty.current(console);\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.current(console);\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.current(console);\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.current(console);\n-\/\/        } else {\n-\/\/            throw new UnsupportedOperationException();\n-\/\/        }\n-        return JDKNativePty.current(console);\n-    }\n-\n-    public static JnaNativePty open(Attributes attr, Size size) throws IOException {\n-\/\/        if (Platform.isMac()) {\n-\/\/            return OsXNativePty.open(attr, size);\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.open(attr, size);\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.open(attr, size);\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.open(attr, size);\n-\/\/        } else {\n-\/\/            throw new UnsupportedOperationException();\n-\/\/        }\n-        return JDKNativePty.open(attr, size);\n-    }\n-\n-    protected JnaNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, String name) {\n-        this(master, masterFD, slave, slaveFD, slave, slaveFD, name);\n-    }\n-\n-    protected JnaNativePty(int master, FileDescriptor masterFD, int slave, FileDescriptor slaveFD, int slaveOut, FileDescriptor slaveOutFD, String name) {\n-        this.master = master;\n-        this.slave = slave;\n-        this.slaveOut = slaveOut;\n-        this.name = name;\n-        this.masterFD = masterFD;\n-        this.slaveFD = slaveFD;\n-        this.slaveOutFD = slaveOutFD;\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        if (master > 0) {\n-            getMasterInput().close();\n-        }\n-        if (slave > 0) {\n-            getSlaveInput().close();\n-        }\n-    }\n-\n-    public int getMaster() {\n-        return master;\n-    }\n-\n-    public int getSlave() {\n-        return slave;\n-    }\n-\n-    public int getSlaveOut() {\n-        return slaveOut;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public FileDescriptor getMasterFD() {\n-        return masterFD;\n-    }\n-\n-    public FileDescriptor getSlaveFD() {\n-        return slaveFD;\n-    }\n-\n-    public FileDescriptor getSlaveOutFD() {\n-        return slaveOutFD;\n-    }\n-\n-    public InputStream getMasterInput() {\n-        return new FileInputStream(getMasterFD());\n-    }\n-\n-    public OutputStream getMasterOutput() {\n-        return new FileOutputStream(getMasterFD());\n-    }\n-\n-    protected InputStream doGetSlaveInput() {\n-        return new FileInputStream(getSlaveFD());\n-    }\n-\n-    public OutputStream getSlaveOutput() {\n-        return new FileOutputStream(getSlaveOutFD());\n-    }\n-\n-    protected static FileDescriptor newDescriptor(int fd) {\n-        try {\n-            Constructor<FileDescriptor> cns = FileDescriptor.class.getDeclaredConstructor(int.class);\n-            cns.setAccessible(true);\n-            return cns.newInstance(fd);\n-        } catch (Throwable e) {\n-            throw new RuntimeException(\"Unable to create FileDescriptor\", e);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"JnaNativePty[\" + getName() + \"]\";\n-    }\n-\n-    public static boolean isPosixSystemStream(TerminalProvider.Stream stream) {\n-        switch (stream) {\n-            case Input: return isatty(0);\n-            case Output: return isatty(1);\n-            case Error: return isatty(2);\n-            default: return false;\n-        }\n-    }\n-\n-    public static String posixSystemStreamName(TerminalProvider.Stream stream) {\n-        switch (stream) {\n-            case Input: return ttyname(0);\n-            case Output: return ttyname(1);\n-            case Error: return ttyname(2);\n-            default: return null;\n-        }\n-    }\n-\n-    private static boolean isatty(int fd) {\n-\/\/        if (Platform.isMac()) {\n-\/\/            return OsXNativePty.isatty(fd) == 1;\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.isatty(fd) == 1;\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.isatty(fd) == 1;\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.isatty(fd) == 1;\n-\/\/        } else {\n-\/\/            return false;\n-\/\/        }\n-        return JDKNativePty.isatty(fd) == 1;\n-    }\n-\n-    private static String ttyname(int fd) {\n-\/\/        if (Platform.isMac()) {\n-\/\/            return OsXNativePty.ttyname(fd);\n-\/\/        } else if (Platform.isLinux()) {\n-\/\/            return LinuxNativePty.ttyname(fd);\n-\/\/        } else if (Platform.isSolaris()) {\n-\/\/            return SolarisNativePty.ttyname(fd);\n-\/\/        } else if (Platform.isFreeBSD()) {\n-\/\/            return FreeBsdNativePty.ttyname(fd);\n-\/\/        } else {\n-\/\/            return null;\n-\/\/        }\n-        return JDKNativePty.ttyname(fd);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/unix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaNativePty.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n-\/\/import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public class JnaTerminalProvider implements TerminalProvider\n-{\n-    @Override\n-    public String name() {\n-        return \"jna\";\n-    }\n-\n-    public Pty current(TerminalProvider.Stream console) throws IOException {\n-        return JnaNativePty.current(console);\n-    }\n-\n-    public Pty open(Attributes attributes, Size size) throws IOException {\n-        return JnaNativePty.open(attributes, size);\n-    }\n-\n-    @Override\n-    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-\/\/        if (OSUtils.IS_WINDOWS) {\n-\/\/            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream );\n-\/\/        } else {\n-            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n-\/\/        }\n-    }\n-\n-\/\/    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-\/\/                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-\/\/                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-\/\/        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console);\n-\/\/    }\n-\/\/\n-    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-\/\/        Pty pty = jdk.internal.org.jline.terminal.impl.ExecPty.current(consoleStream);\n-        Pty pty = current(consoleStream);\n-        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n-    }\n-\n-    @Override\n-    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n-                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Attributes attributes, Size size) throws IOException\n-    {\n-        Pty pty = open(attributes, size);\n-        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n-    }\n-\n-    @Override\n-    public boolean isSystemStream(Stream stream) {\n-        try {\n-\/\/            if (OSUtils.IS_WINDOWS) {\n-\/\/                return isWindowsSystemStream(stream);\n-\/\/            } else {\n-                return isPosixSystemStream(stream);\n-\/\/            }\n-        } catch (Throwable t) {\n-            return false;\n-        }\n-    }\n-\n-\/\/    public boolean isWindowsSystemStream(Stream stream) {\n-\/\/        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n-\/\/    }\n-\n-    public boolean isPosixSystemStream(Stream stream) {\n-        return JnaNativePty.isPosixSystemStream(stream);\n-    }\n-\n-    @Override\n-    public String systemStreamName(Stream stream) {\n-        if (OSUtils.IS_WINDOWS) {\n-            return null;\n-        } else {\n-            return JnaNativePty.posixSystemStreamName(stream);\n-        }\n-    }\n-}\n","filename":"src\/jdk.internal.le\/unix\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n-import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public class JnaTerminalProvider implements TerminalProvider\n-{\n-    @Override\n-    public String name() {\n-        return \"jna\";\n-    }\n-\n-\/\/    public Pty current(TerminalProvider.Stream console) throws IOException {\n-\/\/        return JnaNativePty.current(console);\n-\/\/    }\n-\/\/\n-\/\/    public Pty open(Attributes attributes, Size size) throws IOException {\n-\/\/        return JnaNativePty.open(attributes, size);\n-\/\/    }\n-\n-    @Override\n-    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        if (OSUtils.IS_WINDOWS) {\n-            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n-    }\n-\n-\/\/    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n-\/\/                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n-\/\/                                     Stream consoleStream) throws IOException {\n-\/\/        Pty pty = current(consoleStream);\n-\/\/        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler);\n-\/\/    }\n-\n-    @Override\n-    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n-                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n-                                Attributes attributes, Size size) throws IOException\n-    {\n-\/\/        Pty pty = open(attributes, size);\n-\/\/        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isSystemStream(Stream stream) {\n-        try {\n-            if (OSUtils.IS_WINDOWS) {\n-                return isWindowsSystemStream(stream);\n-            } else {\n-\/\/                return isPosixSystemStream(stream);\n-                return false;\n-            }\n-        } catch (Throwable t) {\n-            return false;\n-        }\n-    }\n-\n-    public boolean isWindowsSystemStream(Stream stream) {\n-        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n-    }\n-\n-\/\/    public boolean isPosixSystemStream(Stream stream) {\n-\/\/        return JnaNativePty.isPosixSystemStream(stream);\n-\/\/    }\n-\n-    @Override\n-    public String systemStreamName(Stream stream) {\n-\/\/        if (OSUtils.IS_WINDOWS) {\n-            return null;\n-\/\/        } else {\n-\/\/            return JnaNativePty.posixSystemStreamName(stream);\n-\/\/        }\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-class IntByReference {\n-\n-    public int value;\n-\n-    public int getValue() {\n-        return value;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2017, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-import jdk.internal.org.jline.terminal.impl.AbstractWindowsConsoleWriter;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-import java.io.IOException;\n-\n-class JnaWinConsoleWriter extends AbstractWindowsConsoleWriter {\n-\n-    private final Pointer console;\n-    private final IntByReference writtenChars = new IntByReference();\n-\n-    JnaWinConsoleWriter(Pointer console) {\n-        this.console = console;\n-    }\n-\n-    @Override\n-    protected void writeConsole(char[] text, int len) throws IOException {\n-        try {\n-            Kernel32.INSTANCE.WriteConsoleW(this.console, text, len, this.writtenChars, null);\n-        } catch (LastErrorException e) {\n-            throw new IOException(\"Failed to write to console\", e);\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinConsoleWriter.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-import java.util.function.IntConsumer;\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-import jdk.internal.org.jline.terminal.Cursor;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n-import jdk.internal.org.jline.utils.InfoCmp;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-public class JnaWinSysTerminal extends AbstractWindowsTerminal {\n-\n-    private static final Pointer consoleIn = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_INPUT_HANDLE);\n-    private static final Pointer consoleOut = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);\n-    private static final Pointer consoleErr = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_ERROR_HANDLE);\n-\n-    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, boolean paused, TerminalProvider.Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        Pointer console;\n-        switch (consoleStream) {\n-            case Output:\n-                console = JnaWinSysTerminal.consoleOut;\n-                break;\n-            case Error:\n-                console = JnaWinSysTerminal.consoleErr;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n-        }\n-        Writer writer;\n-        if (ansiPassThrough) {\n-            if (type == null) {\n-                type = OSUtils.IS_CONEMU ? TYPE_WINDOWS_CONEMU : TYPE_WINDOWS;\n-            }\n-            writer = new JnaWinConsoleWriter(console);\n-        } else {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n-            try {\n-                Kernel32.INSTANCE.SetConsoleMode(console, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n-                if (type == null) {\n-                    type = TYPE_WINDOWS_VTP;\n-                }\n-                writer = new JnaWinConsoleWriter(console);\n-            } catch (LastErrorException e) {\n-                if (OSUtils.IS_CONEMU) {\n-                    if (type == null) {\n-                        type = TYPE_WINDOWS_CONEMU;\n-                    }\n-                    writer = new JnaWinConsoleWriter(console);\n-                } else {\n-                    if (type == null) {\n-                        type = TYPE_WINDOWS;\n-                    }\n-                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(console)), console);\n-                }\n-            }\n-        }\n-        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n-        \/\/ Start input pump thread\n-        if (!paused) {\n-            terminal.resume();\n-        }\n-        return terminal;\n-    }\n-\n-    public static boolean isWindowsSystemStream(TerminalProvider.Stream stream) {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Pointer console;\n-            switch (stream) {\n-                case Input: console = consoleIn; break;\n-                case Output: console = consoleOut; break;\n-                case Error: console = consoleErr; break;\n-                default: return false;\n-            }\n-            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler,\n-            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n-        strings.put(InfoCmp.Capability.key_mouse, \"\\\\E[M\");\n-    }\n-\n-    @Override\n-    protected int getConsoleMode() {\n-        IntByReference mode = new IntByReference();\n-        Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n-        return mode.getValue();\n-    }\n-\n-    @Override\n-    protected void setConsoleMode(int mode) {\n-        Kernel32.INSTANCE.SetConsoleMode(consoleIn, mode);\n-    }\n-\n-    public Size getSize() {\n-        Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);\n-        return new Size(info.windowWidth(), info.windowHeight());\n-    }\n-\n-    public Size getBufferSize() {\n-        Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);\n-        return new Size(info.dwSize.X, info.dwSize.Y);\n-    }\n-\n-    protected boolean processConsoleInput() throws IOException {\n-        Kernel32.INPUT_RECORD event = readConsoleInput(100);\n-        if (event == null) {\n-            return false;\n-        }\n-\n-        switch (event.EventType) {\n-            case Kernel32.INPUT_RECORD.KEY_EVENT:\n-                processKeyEvent(event.Event.KeyEvent);\n-                return true;\n-            case Kernel32.INPUT_RECORD.WINDOW_BUFFER_SIZE_EVENT:\n-                raise(Signal.WINCH);\n-                return false;\n-            case Kernel32.INPUT_RECORD.MOUSE_EVENT:\n-                processMouseEvent(event.Event.MouseEvent);\n-                return true;\n-            case Kernel32.INPUT_RECORD.FOCUS_EVENT:\n-                processFocusEvent(event.Event.FocusEvent.bSetFocus);\n-                return true;\n-            default:\n-                \/\/ Skip event\n-                return false;\n-        }\n-    }\n-\n-    private void processKeyEvent(Kernel32.KEY_EVENT_RECORD keyEvent) throws IOException {\n-        processKeyEvent(keyEvent.bKeyDown, keyEvent.wVirtualKeyCode, keyEvent.uChar.UnicodeChar, keyEvent.dwControlKeyState);\n-    }\n-\n-    private char[] focus = new char[] { '\\033', '[', ' ' };\n-\n-    private void processFocusEvent(boolean hasFocus) throws IOException {\n-        if (focusTracking) {\n-            focus[2] = hasFocus ? 'I' : 'O';\n-            slaveInputPipe.write(focus);\n-        }\n-    }\n-\n-    private char[] mouse = new char[] { '\\033', '[', 'M', ' ', ' ', ' ' };\n-\n-    private void processMouseEvent(Kernel32.MOUSE_EVENT_RECORD mouseEvent) throws IOException {\n-        int dwEventFlags = mouseEvent.dwEventFlags;\n-        int dwButtonState = mouseEvent.dwButtonState;\n-        if (tracking == MouseTracking.Off\n-                || tracking == MouseTracking.Normal && dwEventFlags == Kernel32.MOUSE_MOVED\n-                || tracking == MouseTracking.Button && dwEventFlags == Kernel32.MOUSE_MOVED && dwButtonState == 0) {\n-            return;\n-        }\n-        int cb = 0;\n-        dwEventFlags &= ~ Kernel32.DOUBLE_CLICK; \/\/ Treat double-clicks as normal\n-        if (dwEventFlags == Kernel32.MOUSE_WHEELED) {\n-            cb |= 64;\n-            if ((dwButtonState >> 16) < 0) {\n-                cb |= 1;\n-            }\n-        } else if (dwEventFlags == Kernel32.MOUSE_HWHEELED) {\n-            return;\n-        } else if ((dwButtonState & Kernel32.FROM_LEFT_1ST_BUTTON_PRESSED) != 0) {\n-            cb |= 0x00;\n-        } else if ((dwButtonState & Kernel32.RIGHTMOST_BUTTON_PRESSED) != 0) {\n-            cb |= 0x01;\n-        } else if ((dwButtonState & Kernel32.FROM_LEFT_2ND_BUTTON_PRESSED) != 0) {\n-            cb |= 0x02;\n-        } else {\n-            cb |= 0x03;\n-        }\n-        int cx = mouseEvent.dwMousePosition.X;\n-        int cy = mouseEvent.dwMousePosition.Y;\n-        mouse[3] = (char) (' ' + cb);\n-        mouse[4] = (char) (' ' + cx + 1);\n-        mouse[5] = (char) (' ' + cy + 1);\n-        slaveInputPipe.write(mouse);\n-    }\n-\n-    private final Kernel32.INPUT_RECORD[] inputEvents = new Kernel32.INPUT_RECORD[1];\n-    private final IntByReference eventsRead = new IntByReference();\n-\n-    private Kernel32.INPUT_RECORD readConsoleInput(int dwMilliseconds) throws IOException {\n-        if (Kernel32.INSTANCE.WaitForSingleObject(consoleIn, dwMilliseconds) != 0) {\n-            return null;\n-        }\n-        Kernel32.INSTANCE.ReadConsoleInput(consoleIn, inputEvents, 1, eventsRead);\n-        if (eventsRead.getValue() == 1) {\n-            return inputEvents[0];\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    @Override\n-    public Cursor getCursorPosition(IntConsumer discarded) {\n-        Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);\n-        return new Cursor(info.dwCursorPosition.X, info.dwCursorPosition.Y);\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinSysTerminal.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,634 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2018, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-\/\/OpenJDK changes:\n-\/\/-references to JNA types commented out\n-\/\/-replacement types provided where needed (IntByReference, LastErrorException, Pointer)\n-\/\/-methods not used by JLine commented out\n-\/\/-provided an implementation of the interface (Kernel32Impl), backed by a native implementation (Kernel32.cpp)\n-\n-\/\/import com.sun.jna.LastErrorException;\n-\/\/import com.sun.jna.Native;\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.Structure;\n-\/\/import com.sun.jna.Union;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-\/\/import com.sun.jna.win32.StdCallLibrary;\n-\/\/import com.sun.jna.win32.W32APIOptions;\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-\n-interface Kernel32 {\/\/extends StdCallLibrary {\n-\n-    Kernel32 INSTANCE = new Kernel32Impl();\n-\/\/    Kernel32 INSTANCE = Native.load(\"kernel32\", Kernel32.class, W32APIOptions.UNICODE_OPTIONS);\n-\n-\/\/    Pointer INVALID_HANDLE_VALUE = Pointer.createConstant(-1L);\n-\n-    int STD_INPUT_HANDLE =  -10;\n-    int STD_OUTPUT_HANDLE = -11;\n-    int STD_ERROR_HANDLE =  -12;\n-\n-    int ENABLE_PROCESSED_INPUT =    0x0001;\n-    int ENABLE_LINE_INPUT =         0x0002;\n-    int ENABLE_ECHO_INPUT =         0x0004;\n-    int ENABLE_WINDOW_INPUT =       0x0008;\n-    int ENABLE_MOUSE_INPUT =        0x0010;\n-    int ENABLE_INSERT_MODE =        0x0020;\n-    int ENABLE_QUICK_EDIT_MODE =    0x0040;\n-    int ENABLE_EXTENDED_FLAGS =     0x0080;\n-\n-    int RIGHT_ALT_PRESSED =     0x0001;\n-    int LEFT_ALT_PRESSED =      0x0002;\n-    int RIGHT_CTRL_PRESSED =    0x0004;\n-    int LEFT_CTRL_PRESSED =     0x0008;\n-    int SHIFT_PRESSED =         0x0010;\n-\n-    int FOREGROUND_BLUE =       0x0001;\n-    int FOREGROUND_GREEN =      0x0002;\n-    int FOREGROUND_RED =        0x0004;\n-    int FOREGROUND_INTENSITY =  0x0008;\n-    int BACKGROUND_BLUE =       0x0010;\n-    int BACKGROUND_GREEN =      0x0020;\n-    int BACKGROUND_RED =        0x0040;\n-    int BACKGROUND_INTENSITY =  0x0080;\n-\n-    \/\/ Button state\n-    int FROM_LEFT_1ST_BUTTON_PRESSED = 0x0001;\n-    int RIGHTMOST_BUTTON_PRESSED     = 0x0002;\n-    int FROM_LEFT_2ND_BUTTON_PRESSED = 0x0004;\n-    int FROM_LEFT_3RD_BUTTON_PRESSED = 0x0008;\n-    int FROM_LEFT_4TH_BUTTON_PRESSED = 0x0010;\n-\n-    \/\/ Event flags\n-    int MOUSE_MOVED                  = 0x0001;\n-    int DOUBLE_CLICK                 = 0x0002;\n-    int MOUSE_WHEELED                = 0x0004;\n-    int MOUSE_HWHEELED               = 0x0008;\n-\n-    \/\/ DWORD WINAPI WaitForSingleObject(\n-    \/\/  _In_ HANDLE hHandle,\n-    \/\/  _In_ DWORD  dwMilliseconds\n-    \/\/ );\n-    int WaitForSingleObject(Pointer in_hHandle, int in_dwMilliseconds);\n-\n-    \/\/ HANDLE WINAPI GetStdHandle(\n-    \/\/ __in DWORD nStdHandle\n-    \/\/ );\n-    Pointer GetStdHandle(int nStdHandle);\n-\n-\/\/    \/\/ BOOL WINAPI AllocConsole(void);\n-\/\/    void AllocConsole() throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI FreeConsole(void);\n-\/\/    void FreeConsole() throws LastErrorException;\n-\/\/\n-\/\/    \/\/ HWND WINAPI GetConsoleWindow(void);\n-\/\/    Pointer GetConsoleWindow();\n-\/\/\n-\/\/    \/\/ UINT WINAPI GetConsoleCP(void)\n-\/\/    int GetConsoleCP();\n-\/\/\n-    \/\/ UINT WINAPI GetConsoleOutputCP(void)\n-    int GetConsoleOutputCP();\n-\n-    \/\/ BOOL WINAPI FillConsoleOutputCharacter(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ TCHAR cCharacter,\n-    \/\/ _In_ DWORD nLength,\n-    \/\/ _In_ COORD dwWriteCoord,\n-    \/\/ _Out_ LPDWORD lpNumberOfCharsWritten);\n-    void FillConsoleOutputCharacter(Pointer in_hConsoleOutput,\n-                                    char in_cCharacter, int in_nLength, COORD in_dwWriteCoord,\n-                                    IntByReference out_lpNumberOfCharsWritten)\n-            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI FillConsoleOutputAttribute(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ WORD wAttribute,\n-    \/\/ _In_ DWORD nLength,\n-    \/\/ _In_ COORD dwWriteCoord,\n-    \/\/ _Out_ LPDWORD lpNumberOfAttrsWritten);\n-    void FillConsoleOutputAttribute(Pointer in_hConsoleOutput,\n-                                    short in_wAttribute, int in_nLength, COORD in_dwWriteCoord,\n-                                    IntByReference out_lpNumberOfAttrsWritten)\n-            throws LastErrorException;\n-\/\/\n-\/\/\/\/    \/\/ BOOL WINAPI GetConsoleCursorInfo(\n-\/\/\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/\/\/    \/\/ _Out_ PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);\n-\/\/\/\/    void GetConsoleCursorInfo(Pointer in_hConsoleOutput,\n-\/\/\/\/                              CONSOLE_CURSOR_INFO.ByReference out_lpConsoleCursorInfo)\n-\/\/\/\/            throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI GetConsoleMode(\n-    \/\/   _In_   HANDLE hConsoleHandle,\n-    \/\/   _Out_  LPDWORD lpMode);\n-    void GetConsoleMode(\n-            Pointer in_hConsoleOutput,\n-            IntByReference out_lpMode)\n-            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI GetConsoleScreenBufferInfo(\n-    \/\/ _In_   HANDLE hConsoleOutput,\n-    \/\/ _Out_  PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);\n-    void GetConsoleScreenBufferInfo(\n-            Pointer in_hConsoleOutput,\n-            CONSOLE_SCREEN_BUFFER_INFO out_lpConsoleScreenBufferInfo)\n-            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI GetNumberOfConsoleInputEvents(\n-\/\/    \/\/ _In_ HANDLE hConsoleInput,\n-\/\/    \/\/ _Out_ LPDWORD lpcNumberOfEvents);\n-\/\/    void GetNumberOfConsoleInputEvents(Pointer in_hConsoleOutput,\n-\/\/                                       IntByReference out_lpcNumberOfEvents) throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI ReadConsoleInput(\n-    \/\/ _In_ HANDLE hConsoleInput,\n-    \/\/ _Out_ PINPUT_RECORD lpBuffer,\n-    \/\/ _In_ DWORD nLength,\n-    \/\/ _Out_ LPDWORD lpNumberOfEventsRead);\n-    void ReadConsoleInput(Pointer in_hConsoleOutput,\n-                          INPUT_RECORD[] out_lpBuffer, int in_nLength,\n-                          IntByReference out_lpNumberOfEventsRead) throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI SetConsoleCtrlHandler(\n-\/\/    \/\/ _In_opt_  PHANDLER_ROUTINE HandlerRoutine,\n-\/\/    \/\/ _In_      BOOL Add);\n-\/\/    void SetConsoleCtrlHandler(\n-\/\/            Pointer in_opt_HandlerRoutine,\n-\/\/            boolean in_Add)\n-\/\/            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI ReadConsoleOutput(\n-\/\/    \/\/ _In_     HANDLE hConsoleOutput,\n-\/\/    \/\/ _Out_    PCHAR_INFO lpBuffer,\n-\/\/    \/\/ _In_     COORD dwBufferSize,\n-\/\/    \/\/ _In_     COORD dwBufferCoord,\n-\/\/    \/\/ _Inout_  PSMALL_RECT lpReadRegion);\n-\/\/\/\/    void ReadConsoleOutput(Pointer in_hConsoleOutput, CHAR_INFO[] out_lpBuffer,\n-\/\/\/\/                           COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                           SMALL_RECT inout_lpReadRegion) throws LastErrorException;\n-\/\/\/\/    void ReadConsoleOutputA(Pointer in_hConsoleOutput, CHAR_INFO[] out_lpBuffer,\n-\/\/\/\/                            COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                            SMALL_RECT inout_lpReadRegion) throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI ReadConsoleOutputCharacter(\n-\/\/    \/\/ _In_   HANDLE hConsoleOutput,\n-\/\/    \/\/ _Out_  LPTSTR lpCharacter,\n-\/\/    \/\/ _In_   DWORD nLength,\n-\/\/    \/\/ _In_   COORD dwReadCoord,\n-\/\/    \/\/ _Out_  LPDWORD lpNumberOfCharsRead);\n-\/\/    void ReadConsoleOutputCharacter(Pointer in_hConsoleOutput,\n-\/\/                                    char[] ouy_lpCharacter, int in_nLength, COORD in_dwReadCoord,\n-\/\/                                    IntByReference out_lpNumberOfCharsRead)\n-\/\/            throws LastErrorException;\n-\/\/    void ReadConsoleOutputCharacterA(Pointer in_hConsoleOutput,\n-\/\/                                     byte[] ouy_lpCharacter, int in_nLength, COORD in_dwReadCoord,\n-\/\/                                     IntByReference out_lpNumberOfCharsRead)\n-\/\/            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI SetConsoleCursorInfo(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo);\n-\/\/    void SetConsoleCursorInfo(Pointer in_hConsoleOutput,\n-\/\/                              CONSOLE_CURSOR_INFO in_lpConsoleCursorInfo)\n-\/\/            throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI SetConsoleCP(\n-\/\/    \/\/ _In_ UINT wCodePageID);\n-\/\/    void SetConsoleCP(int in_wCodePageID) throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI SetConsoleOutputCP(\n-\/\/    \/\/ _In_ UINT wCodePageID);\n-\/\/    void SetConsoleOutputCP(int in_wCodePageID) throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI SetConsoleCursorPosition(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ COORD dwCursorPosition);\n-    void SetConsoleCursorPosition(Pointer in_hConsoleOutput,\n-                                  COORD in_dwCursorPosition) throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI SetConsoleMode(\n-    \/\/   _In_  HANDLE hConsoleHandle,\n-    \/\/   _In_  DWORD dwMode);\n-    void SetConsoleMode(\n-            Pointer in_hConsoleOutput,\n-            int in_dwMode) throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI SetConsoleScreenBufferSize(\n-\/\/    \/\/ __in HANDLE hConsoleOutput,\n-\/\/    \/\/ __in COORD dwSize\n-\/\/    \/\/ );\n-\/\/    void SetConsoleScreenBufferSize(Pointer in_hConsoleOutput,\n-\/\/                                    COORD in_dwSize) throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI SetConsoleTextAttribute(\n-    \/\/ _In_ HANDLE hConsoleOutput,\n-    \/\/ _In_ WORD   wAttributes\n-    \/\/ );\n-    void SetConsoleTextAttribute(Pointer in_hConsoleOutput,\n-                                 short in_wAttributes)\n-            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI SetConsoleTitle(\n-    \/\/ _In_ LPCTSTR lpConsoleTitle\n-    \/\/ );\n-    void SetConsoleTitle(String in_lpConsoleTitle)\n-            throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI SetConsoleWindowInfo(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ BOOL bAbsolute,\n-\/\/    \/\/ _In_ const SMALL_RECT *lpConsoleWindow);\n-\/\/    void SetConsoleWindowInfo(Pointer in_hConsoleOutput,\n-\/\/                              boolean in_bAbsolute, SMALL_RECT in_lpConsoleWindow)\n-\/\/            throws LastErrorException;\n-\n-    \/\/ BOOL WINAPI WriteConsole(\n-    \/\/  _In_             HANDLE  hConsoleOutput,\n-    \/\/  _In_       const VOID    *lpBuffer,\n-    \/\/  _In_             DWORD   nNumberOfCharsToWrite,\n-    \/\/  _Out_            LPDWORD lpNumberOfCharsWritten,\n-    \/\/  _Reserved_       LPVOID  lpReserved\n-    \/\/ );\n-    void WriteConsoleW(Pointer in_hConsoleOutput, char[] in_lpBuffer, int in_nNumberOfCharsToWrite,\n-                          IntByReference out_lpNumberOfCharsWritten, Pointer reserved_lpReserved) throws LastErrorException;\n-\n-\/\/    \/\/ BOOL WINAPI WriteConsoleOutput(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ const CHAR_INFO *lpBuffer,\n-\/\/    \/\/ _In_ COORD dwBufferSize,\n-\/\/    \/\/ _In_ COORD dwBufferCoord,\n-\/\/    \/\/ _Inout_ PSMALL_RECT lpWriteRegion);\n-\/\/\/\/    void WriteConsoleOutput(Pointer in_hConsoleOutput, CHAR_INFO[] in_lpBuffer,\n-\/\/\/\/                            COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                            SMALL_RECT inout_lpWriteRegion) throws LastErrorException;\n-\/\/\/\/    void WriteConsoleOutputA(Pointer in_hConsoleOutput, CHAR_INFO[] in_lpBuffer,\n-\/\/\/\/                             COORD in_dwBufferSize, COORD in_dwBufferCoord,\n-\/\/\/\/                             SMALL_RECT inout_lpWriteRegion) throws LastErrorException;\n-\/\/\n-\/\/    \/\/ BOOL WINAPI WriteConsoleOutputCharacter(\n-\/\/    \/\/ _In_ HANDLE hConsoleOutput,\n-\/\/    \/\/ _In_ LPCTSTR lpCharacter,\n-\/\/    \/\/ _In_ DWORD nLength,\n-\/\/    \/\/ _In_ COORD dwWriteCoord,\n-\/\/    \/\/ _Out_ LPDWORD lpNumberOfCharsWritten);\n-\/\/    void WriteConsoleOutputCharacter(Pointer in_hConsoleOutput,\n-\/\/                                     char[] in_lpCharacter, int in_nLength, COORD in_dwWriteCoord,\n-\/\/                                     IntByReference out_lpNumberOfCharsWritten)\n-\/\/            throws LastErrorException;\n-\/\/    void WriteConsoleOutputCharacterA(Pointer in_hConsoleOutput,\n-\/\/                                      byte[] in_lpCharacter, int in_nLength, COORD in_dwWriteCoord,\n-\/\/                                      IntByReference out_lpNumberOfCharsWritten)\n-\/\/            throws LastErrorException;\n-\/\/\n-    \/\/ BOOL WINAPI ScrollConsoleScreenBuffer(\n-    \/\/     _In_           HANDLE     hConsoleOutput,\n-    \/\/     _In_     const SMALL_RECT *lpScrollRectangle,\n-    \/\/     _In_opt_ const SMALL_RECT *lpClipRectangle,\n-    \/\/     _In_           COORD      dwDestinationOrigin,\n-    \/\/     _In_     const CHAR_INFO  *lpFill);\n-    void ScrollConsoleScreenBuffer(Pointer in_hConsoleOutput,\n-                                   SMALL_RECT in_lpScrollRectangle,\n-                                   SMALL_RECT in_lpClipRectangle,\n-                                   COORD in_dwDestinationOrigin,\n-                                   CHAR_INFO in_lpFill)\n-            throws LastErrorException;\n-\n-    \/\/ typedef struct _CHAR_INFO {\n-    \/\/   union {\n-    \/\/     WCHAR UnicodeChar;\n-    \/\/     CHAR  AsciiChar;\n-    \/\/   } Char;\n-    \/\/   WORD  Attributes;\n-    \/\/ } CHAR_INFO, *PCHAR_INFO;\n-    class CHAR_INFO {\/\/extends Structure {\n-        public CHAR_INFO() {\n-        }\n-\n-        public CHAR_INFO(char c, short attr) {\n-            uChar = new UnionChar(c);\n-            Attributes = attr;\n-        }\n-\n-\/\/        public CHAR_INFO(byte c, short attr) {\n-\/\/            uChar = new UnionChar(c);\n-\/\/            Attributes = attr;\n-\/\/        }\n-\n-        public UnionChar uChar;\n-        public short Attributes;\n-\n-\/\/        public static CHAR_INFO[] createArray(int size) {\n-\/\/            return (CHAR_INFO[]) new CHAR_INFO().toArray(size);\n-\/\/        }\n-\/\/\n-\/\/        private static String[] fieldOrder = { \"uChar\", \"Attributes\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _CONSOLE_CURSOR_INFO {\n-    \/\/   DWORD dwSize;\n-    \/\/   BOOL  bVisible;\n-    \/\/ } CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;\n-    class CONSOLE_CURSOR_INFO {\/\/extends Structure {\n-        public int dwSize;\n-        public boolean bVisible;\n-\n-\/\/        public static class ByReference extends CONSOLE_CURSOR_INFO implements\n-\/\/                Structure.ByReference {\n-\/\/        }\n-\/\/\n-\/\/        private static String[] fieldOrder = { \"dwSize\", \"bVisible\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _CONSOLE_SCREEN_BUFFER_INFO {\n-    \/\/   COORD      dwSize;\n-    \/\/   COORD      dwCursorPosition;\n-    \/\/   WORD       wAttributes;\n-    \/\/   SMALL_RECT srWindow;\n-    \/\/   COORD      dwMaximumWindowSize;\n-    \/\/ } CONSOLE_SCREEN_BUFFER_INFO;\n-    class CONSOLE_SCREEN_BUFFER_INFO {\/\/extends Structure {\n-        public COORD      dwSize;\n-        public COORD      dwCursorPosition;\n-        public short      wAttributes;\n-        public SMALL_RECT srWindow;\n-        public COORD      dwMaximumWindowSize;\n-\n-\/\/        private static String[] fieldOrder = { \"dwSize\", \"dwCursorPosition\", \"wAttributes\", \"srWindow\", \"dwMaximumWindowSize\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-\n-        public int windowWidth() {\n-            return this.srWindow.width() + 1;\n-        }\n-\n-        public int windowHeight() {\n-            return this.srWindow.height() + 1;\n-        }\n-    }\n-\n-    \/\/ typedef struct _COORD {\n-    \/\/    SHORT X;\n-    \/\/    SHORT Y;\n-    \/\/  } COORD, *PCOORD;\n-    class COORD {\/\/extends Structure implements Structure.ByValue {\n-        public COORD() {\n-        }\n-\n-        public COORD(short X, short Y) {\n-            this.X = X;\n-            this.Y = Y;\n-        }\n-\n-        public short X;\n-        public short Y;\n-\n-\/\/        private static String[] fieldOrder = { \"X\", \"Y\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _INPUT_RECORD {\n-    \/\/   WORD  EventType;\n-    \/\/   union {\n-    \/\/     KEY_EVENT_RECORD          KeyEvent;\n-    \/\/     MOUSE_EVENT_RECORD        MouseEvent;\n-    \/\/     WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;\n-    \/\/     MENU_EVENT_RECORD         MenuEvent;\n-    \/\/     FOCUS_EVENT_RECORD        FocusEvent;\n-    \/\/   } Event;\n-    \/\/ } INPUT_RECORD;\n-    class INPUT_RECORD {\/\/extends Structure {\n-        public static final short KEY_EVENT = 0x0001;\n-        public static final short MOUSE_EVENT = 0x0002;\n-        public static final short WINDOW_BUFFER_SIZE_EVENT = 0x0004;\n-        public static final short MENU_EVENT = 0x0008;\n-        public static final short FOCUS_EVENT = 0x0010;\n-\n-        public short EventType;\n-        public EventUnion Event;\n-\n-        public static class EventUnion {\/\/extends Union {\n-            public KEY_EVENT_RECORD KeyEvent;\n-            public MOUSE_EVENT_RECORD MouseEvent;\n-            public WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;\n-            public MENU_EVENT_RECORD MenuEvent;\n-            public FOCUS_EVENT_RECORD FocusEvent;\n-        }\n-\n-\/\/        @Override\n-\/\/        public void read() {\n-\/\/            readField(\"EventType\");\n-\/\/            switch (EventType) {\n-\/\/                case KEY_EVENT:\n-\/\/                    Event.setType(KEY_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/                case MOUSE_EVENT:\n-\/\/                    Event.setType(MOUSE_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/                case WINDOW_BUFFER_SIZE_EVENT:\n-\/\/                    Event.setType(WINDOW_BUFFER_SIZE_RECORD.class);\n-\/\/                    break;\n-\/\/                case MENU_EVENT:\n-\/\/                    Event.setType(MENU_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/                case FOCUS_EVENT:\n-\/\/                    Event.setType(MENU_EVENT_RECORD.class);\n-\/\/                    break;\n-\/\/            }\n-\/\/            super.read();\n-\/\/        }\n-\n-\/\/        private static String[] fieldOrder = {\"EventType\", \"Event\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _KEY_EVENT_RECORD {\n-    \/\/   BOOL  bKeyDown;\n-    \/\/   WORD  wRepeatCount;\n-    \/\/   WORD  wVirtualKeyCode;\n-    \/\/   WORD  wVirtualScanCode;\n-    \/\/   union {\n-    \/\/     WCHAR UnicodeChar;\n-    \/\/     CHAR  AsciiChar;\n-    \/\/   } uChar;\n-    \/\/   DWORD dwControlKeyState;\n-    \/\/ } KEY_EVENT_RECORD;\n-    class KEY_EVENT_RECORD {\/\/extends Structure {\n-        public boolean bKeyDown;\n-        public short wRepeatCount;\n-        public short wVirtualKeyCode;\n-        public short wVirtualScanCode;\n-        public UnionChar uChar;\n-        public int dwControlKeyState;\n-\n-\/\/        private static String[] fieldOrder = {\"bKeyDown\", \"wRepeatCount\", \"wVirtualKeyCode\", \"wVirtualScanCode\", \"uChar\", \"dwControlKeyState\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _MOUSE_EVENT_RECORD {\n-    \/\/   COORD dwMousePosition;\n-    \/\/   DWORD dwButtonState;\n-    \/\/   DWORD dwControlKeyState;\n-    \/\/   DWORD dwEventFlags;\n-    \/\/ } MOUSE_EVENT_RECORD;\n-    class MOUSE_EVENT_RECORD {\/\/extends Structure {\n-        public COORD dwMousePosition;\n-        public int dwButtonState;\n-        public int dwControlKeyState;\n-        public int dwEventFlags;\n-\n-\/\/        private static String[] fieldOrder = { \"dwMousePosition\", \"dwButtonState\", \"dwControlKeyState\", \"dwEventFlags\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _WINDOW_BUFFER_SIZE_RECORD {\n-    \/\/   COORD dwSize;\n-    \/\/ } WINDOW_BUFFER_SIZE_RECORD;\n-    class WINDOW_BUFFER_SIZE_RECORD {\/\/extends Structure {\n-        public COORD dwSize;\n-\n-\/\/        private static String[] fieldOrder = {\"dwSize\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _MENU_EVENT_RECORD {\n-    \/\/   UINT dwCommandId;\n-    \/\/ } MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;\n-    class MENU_EVENT_RECORD {\/\/extends Structure {\n-\n-        public int dwCommandId;\n-\n-\/\/        private static String[] fieldOrder = {\"dwCommandId\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _FOCUS_EVENT_RECORD {\n-    \/\/  BOOL bSetFocus;\n-    \/\/} FOCUS_EVENT_RECORD;\n-    class FOCUS_EVENT_RECORD {\/\/extends Structure {\n-        public boolean bSetFocus;\n-\n-\/\/        private static String[] fieldOrder = {\"bSetFocus\"};\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-    }\n-\n-    \/\/ typedef struct _SMALL_RECT {\n-    \/\/    SHORT Left;\n-    \/\/    SHORT Top;\n-    \/\/    SHORT Right;\n-    \/\/    SHORT Bottom;\n-    \/\/  } SMALL_RECT;\n-    class SMALL_RECT {\/\/extends Structure {\n-        public SMALL_RECT() {\n-        }\n-\n-        public SMALL_RECT(SMALL_RECT org) {\n-            this(org.Top, org.Left, org.Bottom, org.Right);\n-        }\n-\n-        public SMALL_RECT(short Top, short Left, short Bottom, short Right) {\n-            this.Top = Top;\n-            this.Left = Left;\n-            this.Bottom = Bottom;\n-            this.Right = Right;\n-        }\n-\n-        public short Left;\n-        public short Top;\n-        public short Right;\n-        public short Bottom;\n-\n-\/\/        private static String[] fieldOrder = { \"Left\", \"Top\", \"Right\", \"Bottom\" };\n-\/\/\n-\/\/        @Override\n-\/\/        protected java.util.List<String> getFieldOrder() {\n-\/\/            return java.util.Arrays.asList(fieldOrder);\n-\/\/        }\n-\n-        public short width() {\n-            return (short)(this.Right - this.Left);\n-        }\n-\n-        public short height() {\n-            return (short)(this.Bottom - this.Top);\n-        }\n-\n-    }\n-\n-    class UnionChar {\/\/extends Union {\n-        public UnionChar() {\n-        }\n-\n-        public UnionChar(char c) {\n-\/\/            setType(char.class);\n-            UnicodeChar = c;\n-        }\n-\n-\/\/        public UnionChar(byte c) {\n-\/\/            setType(byte.class);\n-\/\/            AsciiChar = c;\n-\/\/        }\n-\n-        public void set(char c) {\n-\/\/            setType(char.class);\n-            UnicodeChar = c;\n-        }\n-\n-\/\/        public void set(byte c) {\n-\/\/            setType(byte.class);\n-\/\/            AsciiChar = c;\n-\/\/        }\n-\n-        public char UnicodeChar;\n-\/\/        public byte AsciiChar;\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32.java","additions":0,"deletions":634,"binary":false,"changes":634,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-import jdk.internal.org.jline.terminal.impl.jna.LastErrorException;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CHAR_INFO;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_SCREEN_BUFFER_INFO;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.COORD;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD;\n-import jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.SMALL_RECT;\n-\n-public class Kernel32Impl implements Kernel32 {\n-\n-    static {\n-        System.loadLibrary(\"le\");\n-        initIDs();\n-    }\n-\n-    private static native void initIDs();\n-\n-    @Override\n-    public native int WaitForSingleObject(Pointer in_hHandle, int in_dwMilliseconds);\n-\n-    @Override\n-    public native Pointer GetStdHandle(int nStdHandle);\n-\n-    @Override\n-    public native int GetConsoleOutputCP();\n-\n-    @Override\n-    public native void FillConsoleOutputCharacter(Pointer in_hConsoleOutput, char in_cCharacter, int in_nLength, COORD in_dwWriteCoord, IntByReference out_lpNumberOfCharsWritten) throws LastErrorException;\n-\n-    @Override\n-    public native void FillConsoleOutputAttribute(Pointer in_hConsoleOutput, short in_wAttribute, int in_nLength, COORD in_dwWriteCoord, IntByReference out_lpNumberOfAttrsWritten) throws LastErrorException;\n-\n-    @Override\n-    public native void GetConsoleMode(Pointer in_hConsoleOutput, IntByReference out_lpMode) throws LastErrorException;\n-\n-    @Override\n-    public native void GetConsoleScreenBufferInfo(Pointer in_hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO out_lpConsoleScreenBufferInfo) throws LastErrorException;\n-\n-    @Override\n-    public native void ReadConsoleInput(Pointer in_hConsoleOutput, INPUT_RECORD[] out_lpBuffer, int in_nLength, IntByReference out_lpNumberOfEventsRead) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleCursorPosition(Pointer in_hConsoleOutput, COORD in_dwCursorPosition) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleMode(Pointer in_hConsoleOutput, int in_dwMode) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleTextAttribute(Pointer in_hConsoleOutput, short in_wAttributes) throws LastErrorException;\n-\n-    @Override\n-    public native void SetConsoleTitle(String in_lpConsoleTitle) throws LastErrorException;\n-\n-    @Override\n-    public native void WriteConsoleW(Pointer in_hConsoleOutput, char[] in_lpBuffer, int in_nNumberOfCharsToWrite, IntByReference out_lpNumberOfCharsWritten, Pointer reserved_lpReserved) throws LastErrorException;\n-\n-    @Override\n-    public native void ScrollConsoleScreenBuffer(Pointer in_hConsoleOutput, SMALL_RECT in_lpScrollRectangle, SMALL_RECT in_lpClipRectangle, COORD in_dwDestinationOrigin, CHAR_INFO in_lpFill) throws LastErrorException;\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32Impl.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-class Pointer {\n-    public final long value;\n-\n-    public Pointer(long value) {\n-        this.value = value;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,353 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2016, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna.win;\n-\n-import java.io.IOException;\n-import java.io.Writer;\n-\n-\/\/import com.sun.jna.Pointer;\n-\/\/import com.sun.jna.ptr.IntByReference;\n-import jdk.internal.org.jline.utils.AnsiWriter;\n-import jdk.internal.org.jline.utils.Colors;\n-\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_BLUE;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_GREEN;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_INTENSITY;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_RED;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_BLUE;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_GREEN;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_INTENSITY;\n-import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_RED;\n-\n-\n-\/**\n- * A Windows ANSI escape processor, uses JNA to access native platform\n- * API's to change the console attributes.\n- *\n- * @since 1.0\n- * @author <a href=\"http:\/\/hiramchirino.com\">Hiram Chirino<\/a>\n- * @author Joris Kuipers\n- *\/\n-public final class WindowsAnsiWriter extends AnsiWriter {\n-\n-    private static final short FOREGROUND_BLACK   = 0;\n-    private static final short FOREGROUND_YELLOW  = (short) (FOREGROUND_RED|FOREGROUND_GREEN);\n-    private static final short FOREGROUND_MAGENTA = (short) (FOREGROUND_BLUE|FOREGROUND_RED);\n-    private static final short FOREGROUND_CYAN    = (short) (FOREGROUND_BLUE|FOREGROUND_GREEN);\n-    private static final short FOREGROUND_WHITE   = (short) (FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);\n-\n-    private static final short BACKGROUND_BLACK   = 0;\n-    private static final short BACKGROUND_YELLOW  = (short) (BACKGROUND_RED|BACKGROUND_GREEN);\n-    private static final short BACKGROUND_MAGENTA = (short) (BACKGROUND_BLUE|BACKGROUND_RED);\n-    private static final short BACKGROUND_CYAN    = (short) (BACKGROUND_BLUE|BACKGROUND_GREEN);\n-    private static final short BACKGROUND_WHITE   = (short) (BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE);\n-\n-    private static final short ANSI_FOREGROUND_COLOR_MAP[] = {\n-            FOREGROUND_BLACK,\n-            FOREGROUND_RED,\n-            FOREGROUND_GREEN,\n-            FOREGROUND_YELLOW,\n-            FOREGROUND_BLUE,\n-            FOREGROUND_MAGENTA,\n-            FOREGROUND_CYAN,\n-            FOREGROUND_WHITE,\n-    };\n-\n-    private static final short ANSI_BACKGROUND_COLOR_MAP[] = {\n-            BACKGROUND_BLACK,\n-            BACKGROUND_RED,\n-            BACKGROUND_GREEN,\n-            BACKGROUND_YELLOW,\n-            BACKGROUND_BLUE,\n-            BACKGROUND_MAGENTA,\n-            BACKGROUND_CYAN,\n-            BACKGROUND_WHITE,\n-    };\n-\n-    private static final int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n-\n-    private final Pointer console;\n-\n-    private final Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();\n-    private final short originalColors;\n-\n-    private boolean negative;\n-    private boolean bold;\n-    private boolean underline;\n-    private short savedX = -1;\n-    private short savedY = -1;\n-\n-    public WindowsAnsiWriter(Writer out, Pointer console) throws IOException {\n-        super(out);\n-        this.console = console;\n-        getConsoleInfo();\n-        originalColors = info.wAttributes;\n-    }\n-\n-    private void getConsoleInfo() throws IOException {\n-        out.flush();\n-        Kernel32.INSTANCE.GetConsoleScreenBufferInfo(console, info);\n-        if (negative) {\n-            info.wAttributes = invertAttributeColors(info.wAttributes);\n-        }\n-    }\n-\n-    private void applyAttribute() throws IOException {\n-        out.flush();\n-        short attributes = info.wAttributes;\n-        \/\/ bold is simulated by high foreground intensity\n-        if (bold) {\n-            attributes |= FOREGROUND_INTENSITY;\n-        }\n-        \/\/ underline is simulated by high foreground intensity\n-        if (underline) {\n-            attributes |= BACKGROUND_INTENSITY;\n-        }\n-        if (negative) {\n-            attributes = invertAttributeColors(attributes);\n-        }\n-        Kernel32.INSTANCE.SetConsoleTextAttribute(console, attributes);\n-    }\n-\n-    private short invertAttributeColors(short attributes) {\n-        \/\/ Swap the the Foreground and Background bits.\n-        int fg = 0x000F & attributes;\n-        fg <<= 4;\n-        int bg = 0X00F0 & attributes;\n-        bg >>= 4;\n-        attributes = (short) ((attributes & 0xFF00) | fg | bg);\n-        return attributes;\n-    }\n-\n-    private void applyCursorPosition() throws IOException {\n-        info.dwCursorPosition.X = (short) Math.max(0, Math.min(info.dwSize.X - 1, info.dwCursorPosition.X));\n-        info.dwCursorPosition.Y = (short) Math.max(0, Math.min(info.dwSize.Y - 1, info.dwCursorPosition.Y));\n-        Kernel32.INSTANCE.SetConsoleCursorPosition(console, info.dwCursorPosition);\n-    }\n-\n-    protected void processEraseScreen(int eraseOption) throws IOException {\n-        getConsoleInfo();\n-        IntByReference written = new IntByReference();\n-        switch(eraseOption) {\n-            case ERASE_SCREEN:\n-                Kernel32.COORD topLeft = new Kernel32.COORD();\n-                topLeft.X = 0;\n-                topLeft.Y = info.srWindow.Top;\n-                int screenLength = info.srWindow.height() * info.dwSize.X;\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', screenLength, topLeft, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, screenLength, topLeft, written);\n-                break;\n-            case ERASE_SCREEN_TO_BEGINING:\n-                Kernel32.COORD topLeft2 = new Kernel32.COORD();\n-                topLeft2.X = 0;\n-                topLeft2.Y = info.srWindow.Top;\n-                int lengthToCursor = (info.dwCursorPosition.Y - info.srWindow.Top) * info.dwSize.X + info.dwCursorPosition.X;\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', lengthToCursor, topLeft2, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToCursor, topLeft2, written);\n-                break;\n-            case ERASE_SCREEN_TO_END:\n-                int lengthToEnd = (info.srWindow.Bottom - info.dwCursorPosition.Y) * info.dwSize.X +\n-                        (info.dwSize.X - info.dwCursorPosition.X);\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', lengthToEnd, info.dwCursorPosition, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToEnd, info.dwCursorPosition, written);\n-        }\n-    }\n-\n-    protected void processEraseLine(int eraseOption) throws IOException {\n-        getConsoleInfo();\n-        IntByReference written = new IntByReference();\n-        switch(eraseOption) {\n-            case ERASE_LINE:\n-                Kernel32.COORD leftColCurrRow = new Kernel32.COORD((short) 0, info.dwCursorPosition.Y);\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', info.dwSize.X, leftColCurrRow, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, info.dwSize.X, leftColCurrRow, written);\n-                break;\n-            case ERASE_LINE_TO_BEGINING:\n-                Kernel32.COORD leftColCurrRow2 = new Kernel32.COORD((short) 0, info.dwCursorPosition.Y);\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', info.dwCursorPosition.X, leftColCurrRow2, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, info.dwCursorPosition.X, leftColCurrRow2, written);\n-                break;\n-            case ERASE_LINE_TO_END:\n-                int lengthToLastCol = info.dwSize.X - info.dwCursorPosition.X;\n-                Kernel32.INSTANCE.FillConsoleOutputCharacter(console, ' ', lengthToLastCol, info.dwCursorPosition, written);\n-                Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToLastCol, info.dwCursorPosition, written);\n-        }\n-    }\n-\n-    protected void processCursorUpLine(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X = 0;\n-        info.dwCursorPosition.Y -= (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorDownLine(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X = 0;\n-        info.dwCursorPosition.Y += (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorLeft(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X -= (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorRight(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X += (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorDown(int count) throws IOException {\n-        getConsoleInfo();\n-        int nb = Math.max(0, info.dwCursorPosition.Y + count - info.dwSize.Y + 1);\n-        if (nb != count) {\n-            info.dwCursorPosition.Y += (short) count;\n-            applyCursorPosition();\n-        }\n-        if (nb > 0) {\n-            Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);\n-            scroll.Top = 0;\n-            Kernel32.COORD org = new Kernel32.COORD();\n-            org.X = 0;\n-            org.Y = (short)(- nb);\n-            Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(' ', originalColors);\n-            Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n-        }\n-    }\n-\n-    protected void processCursorUp(int count) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.Y -= (short) count;\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorTo(int row, int col) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.Y = (short) (info.srWindow.Top + row - 1);\n-        info.dwCursorPosition.X = (short) (col - 1);\n-        applyCursorPosition();\n-    }\n-\n-    protected void processCursorToColumn(int x) throws IOException {\n-        getConsoleInfo();\n-        info.dwCursorPosition.X = (short) (x - 1);\n-        applyCursorPosition();\n-    }\n-\n-    @Override\n-    protected void processSetForegroundColorExt(int paletteIndex) throws IOException {\n-        int color = Colors.roundColor(paletteIndex, 16);\n-        info.wAttributes = (short) ((info.wAttributes & ~0x0007) | ANSI_FOREGROUND_COLOR_MAP[color & 0x07]);\n-        info.wAttributes = (short) ((info.wAttributes & ~FOREGROUND_INTENSITY) | (color >= 8 ? FOREGROUND_INTENSITY : 0));\n-        applyAttribute();\n-    }\n-\n-    protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {\n-        int color = Colors.roundColor(paletteIndex, 16);\n-        info.wAttributes = (short)((info.wAttributes & ~0x0070 ) | ANSI_BACKGROUND_COLOR_MAP[color & 0x07]);\n-        info.wAttributes = (short) ((info.wAttributes & ~BACKGROUND_INTENSITY) | (color >= 8 ? BACKGROUND_INTENSITY : 0));\n-        applyAttribute();\n-    }\n-\n-    protected void processDefaultTextColor() throws IOException {\n-        info.wAttributes = (short)((info.wAttributes & ~0x000F ) | (originalColors & 0x000F));\n-        applyAttribute();\n-    }\n-\n-    protected void processDefaultBackgroundColor() throws IOException {\n-        info.wAttributes = (short)((info.wAttributes & ~0x00F0 ) | (originalColors & 0x00F0));\n-        applyAttribute();\n-    }\n-\n-    protected void processAttributeRest() throws IOException {\n-        info.wAttributes = (short)((info.wAttributes & ~0x00FF ) | originalColors);\n-        this.negative = false;\n-        this.bold = false;\n-        this.underline = false;\n-        applyAttribute();\n-    }\n-\n-    protected void processSetAttribute(int attribute) throws IOException {\n-        switch(attribute) {\n-            case ATTRIBUTE_INTENSITY_BOLD:\n-                bold = true;\n-                applyAttribute();\n-                break;\n-            case ATTRIBUTE_INTENSITY_NORMAL:\n-                bold = false;\n-                applyAttribute();\n-                break;\n-\n-            case ATTRIBUTE_UNDERLINE:\n-                underline = true;\n-                applyAttribute();\n-                break;\n-            case ATTRIBUTE_UNDERLINE_OFF:\n-                underline = false;\n-                applyAttribute();\n-                break;\n-\n-            case ATTRIBUTE_NEGATIVE_ON:\n-                negative = true;\n-                applyAttribute();\n-                break;\n-            case ATTRIBUTE_NEGATIVE_OFF:\n-                negative = false;\n-                applyAttribute();\n-                break;\n-        }\n-    }\n-\n-    protected void processSaveCursorPosition() throws IOException {\n-        getConsoleInfo();\n-        savedX = info.dwCursorPosition.X;\n-        savedY = info.dwCursorPosition.Y;\n-    }\n-\n-    protected void processRestoreCursorPosition() throws IOException {\n-        \/\/ restore only if there was a save operation first\n-        if (savedX != -1 && savedY != -1) {\n-            out.flush();\n-            info.dwCursorPosition.X = savedX;\n-            info.dwCursorPosition.Y = savedY;\n-            applyCursorPosition();\n-        }\n-    }\n-\n-    @Override\n-    protected void processInsertLine(int optionInt) throws IOException {\n-        getConsoleInfo();\n-        Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);\n-        scroll.Top = info.dwCursorPosition.Y;\n-        Kernel32.COORD org = new Kernel32.COORD();\n-        org.X = 0;\n-        org.Y = (short)(info.dwCursorPosition.Y + optionInt);\n-        Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(' ', originalColors);\n-        Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n-    }\n-\n-    @Override\n-    protected void processDeleteLine(int optionInt) throws IOException {\n-        getConsoleInfo();\n-        Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);\n-        scroll.Top = info.dwCursorPosition.Y;\n-        Kernel32.COORD org = new Kernel32.COORD();\n-        org.X = 0;\n-        org.Y = (short)(info.dwCursorPosition.Y - optionInt);\n-        Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(' ', originalColors);\n-        Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);\n-    }\n-\n-    protected void processChangeWindowTitle(String label) {\n-        Kernel32.INSTANCE.SetConsoleTitle(label);\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/WindowsAnsiWriter.java","additions":0,"deletions":353,"binary":false,"changes":353,"status":"deleted"},{"patch":"@@ -1,710 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl.h\"\n-\n-#include <stdlib.h>\n-#include <wincon.h>\n-#include <winuser.h>\n-\n-static jclass pointerClass;\n-static jmethodID pointerConstructor;\n-static jfieldID pointerValue;\n-\n-static jclass intByReferenceClass;\n-static jfieldID intByReferenceValue;\n-\n-static jclass lastErrorExceptionClass;\n-static jmethodID lastErrorExceptionConstructor;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CHAR_INFO\n-static jclass CHAR_INFO_Class;\n-static jmethodID CHAR_INFO_Constructor;\n-static jfieldID CHAR_INFO_uChar;\n-static jfieldID CHAR_INFO_Attributes;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_CURSOR_INFO\n-static jclass CONSOLE_CURSOR_INFO_Class;\n-static jmethodID CONSOLE_CURSOR_INFO_Constructor;\n-static jfieldID CONSOLE_CURSOR_INFO_dwSize;\n-static jfieldID CONSOLE_CURSOR_INFO_bVisible;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_SCREEN_BUFFER_INFO\n-static jclass CONSOLE_SCREEN_BUFFER_INFO_Class;\n-static jmethodID CONSOLE_SCREEN_BUFFER_INFO_Constructor;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_dwSize;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_wAttributes;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_srWindow;\n-static jfieldID CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.COORD\n-static jclass COORD_Class;\n-static jmethodID COORD_Constructor;\n-static jfieldID COORD_X;\n-static jfieldID COORD_Y;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD\n-static jclass INPUT_RECORD_Class;\n-static jmethodID INPUT_RECORD_Constructor;\n-static jfieldID INPUT_RECORD_EventType;\n-static jfieldID INPUT_RECORD_Event;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD.EventUnion\n-static jclass EventUnion_Class;\n-static jmethodID EventUnion_Constructor;\n-static jfieldID EventUnion_KeyEvent;\n-static jfieldID EventUnion_MouseEvent;\n-static jfieldID EventUnion_WindowBufferSizeEvent;\n-static jfieldID EventUnion_MenuEvent;\n-static jfieldID EventUnion_FocusEvent;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.KEY_EVENT_RECORD\n-static jclass KEY_EVENT_RECORD_Class;\n-static jmethodID KEY_EVENT_RECORD_Constructor;\n-static jfieldID KEY_EVENT_RECORD_bKeyDown;\n-static jfieldID KEY_EVENT_RECORD_wRepeatCount;\n-static jfieldID KEY_EVENT_RECORD_wVirtualKeyCode;\n-static jfieldID KEY_EVENT_RECORD_wVirtualScanCode;\n-static jfieldID KEY_EVENT_RECORD_uChar;\n-static jfieldID KEY_EVENT_RECORD_dwControlKeyState;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MOUSE_EVENT_RECORD\n-static jclass MOUSE_EVENT_RECORD_Class;\n-static jmethodID MOUSE_EVENT_RECORD_Constructor;\n-static jfieldID MOUSE_EVENT_RECORD_dwMousePosition;\n-static jfieldID MOUSE_EVENT_RECORD_dwButtonState;\n-static jfieldID MOUSE_EVENT_RECORD_dwControlKeyState;\n-static jfieldID MOUSE_EVENT_RECORD_dwEventFlags;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.WINDOW_BUFFER_SIZE_RECORD\n-static jclass WINDOW_BUFFER_SIZE_RECORD_Class;\n-static jmethodID WINDOW_BUFFER_SIZE_RECORD_Constructor;\n-static jfieldID WINDOW_BUFFER_SIZE_RECORD_dwSize;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MENU_EVENT_RECORD\n-static jclass MENU_EVENT_RECORD_Class;\n-static jmethodID MENU_EVENT_RECORD_Constructor;\n-static jfieldID MENU_EVENT_RECORD_dwCommandId;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOCUS_EVENT_RECORD\n-static jclass FOCUS_EVENT_RECORD_Class;\n-static jmethodID FOCUS_EVENT_RECORD_Constructor;\n-static jfieldID FOCUS_EVENT_RECORD_bSetFocus;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.SMALL_RECT\n-static jclass SMALL_RECT_Class;\n-static jmethodID SMALL_RECT_Constructor;\n-static jfieldID SMALL_RECT_Left;\n-static jfieldID SMALL_RECT_Top;\n-static jfieldID SMALL_RECT_Right;\n-static jfieldID SMALL_RECT_Bottom;\n-\n-\/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.UnionChar\n-static jclass UnionChar_Class;\n-static jmethodID UnionChar_Constructor;\n-static jfieldID UnionChar_UnicodeChar;\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_initIDs\n-  (JNIEnv *env, jclass) {\n-    jclass cls;\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer\");\n-    CHECK_NULL(cls);\n-    pointerClass = (jclass) env->NewGlobalRef(cls);\n-    pointerConstructor = env->GetMethodID(cls, \"<init>\", \"(J)V\");\n-    CHECK_NULL(pointerConstructor);\n-    pointerValue  = env->GetFieldID(cls, \"value\", \"J\");\n-    CHECK_NULL(pointerValue);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/LastErrorException\");\n-    CHECK_NULL(cls);\n-    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n-    lastErrorExceptionConstructor = env->GetMethodID(cls, \"<init>\", \"(J)V\");\n-    CHECK_NULL(lastErrorExceptionConstructor);\n-\n-    cls = env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference\");\n-    CHECK_NULL(cls);\n-    intByReferenceClass = (jclass) env->NewGlobalRef(cls);\n-    intByReferenceValue = env->GetFieldID(cls, \"value\", \"I\");\n-    CHECK_NULL(intByReferenceValue);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CHAR_INFO\n-    CHAR_INFO_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$CHAR_INFO\"));\n-    CHECK_NULL(CHAR_INFO_Class);\n-    CHAR_INFO_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(CHAR_INFO_Constructor);\n-    CHAR_INFO_uChar = env->GetFieldID(CHAR_INFO_Class, \"uChar\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$UnionChar;\");\n-    CHECK_NULL(CHAR_INFO_uChar);\n-    CHAR_INFO_Attributes = env->GetFieldID(CHAR_INFO_Class, \"Attributes\", \"S\");\n-    CHECK_NULL(CHAR_INFO_Attributes);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_CURSOR_INFO\n-    CONSOLE_CURSOR_INFO_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$CONSOLE_CURSOR_INFO\"));\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_Class);\n-    CONSOLE_CURSOR_INFO_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_Constructor);\n-    CONSOLE_CURSOR_INFO_dwSize = env->GetFieldID(CONSOLE_CURSOR_INFO_Class, \"dwSize\", \"I\");\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_dwSize);\n-    CONSOLE_CURSOR_INFO_bVisible = env->GetFieldID(CONSOLE_CURSOR_INFO_Class, \"bVisible\", \"Z\");\n-    CHECK_NULL(CONSOLE_CURSOR_INFO_bVisible);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.CONSOLE_SCREEN_BUFFER_INFO\n-    CONSOLE_SCREEN_BUFFER_INFO_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$CONSOLE_SCREEN_BUFFER_INFO\"));\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_Class);\n-    CONSOLE_SCREEN_BUFFER_INFO_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_Constructor);\n-    CONSOLE_SCREEN_BUFFER_INFO_dwSize = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"dwSize\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_dwSize);\n-    CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"dwCursorPosition\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition);\n-    CONSOLE_SCREEN_BUFFER_INFO_wAttributes = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"wAttributes\", \"S\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_wAttributes);\n-    CONSOLE_SCREEN_BUFFER_INFO_srWindow = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"srWindow\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$SMALL_RECT;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_srWindow);\n-    CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize = env->GetFieldID(CONSOLE_SCREEN_BUFFER_INFO_Class, \"dwMaximumWindowSize\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.COORD\n-    COORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD\"));\n-    CHECK_NULL(COORD_Class);\n-    COORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(COORD_Constructor);\n-    COORD_X = env->GetFieldID(COORD_Class, \"X\", \"S\");\n-    CHECK_NULL(COORD_X);\n-    COORD_Y = env->GetFieldID(COORD_Class, \"Y\", \"S\");\n-    CHECK_NULL(COORD_Y);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD\n-    INPUT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$INPUT_RECORD\"));\n-    CHECK_NULL(INPUT_RECORD_Class);\n-    INPUT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(INPUT_RECORD_Constructor);\n-    INPUT_RECORD_EventType = env->GetFieldID(INPUT_RECORD_Class, \"EventType\", \"S\");\n-    CHECK_NULL(INPUT_RECORD_EventType);\n-    INPUT_RECORD_Event = env->GetFieldID(INPUT_RECORD_Class, \"Event\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$INPUT_RECORD$EventUnion;\");\n-    CHECK_NULL(INPUT_RECORD_Event);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.INPUT_RECORD.EventUnion\n-    EventUnion_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$INPUT_RECORD$EventUnion\"));\n-    CHECK_NULL(EventUnion_Class);\n-    EventUnion_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(EventUnion_Constructor);\n-    EventUnion_KeyEvent = env->GetFieldID(EventUnion_Class, \"KeyEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$KEY_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_KeyEvent);\n-    EventUnion_MouseEvent = env->GetFieldID(EventUnion_Class, \"MouseEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MOUSE_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_MouseEvent);\n-    EventUnion_WindowBufferSizeEvent = env->GetFieldID(EventUnion_Class, \"WindowBufferSizeEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$WINDOW_BUFFER_SIZE_RECORD;\");\n-    CHECK_NULL(EventUnion_WindowBufferSizeEvent);\n-    EventUnion_MenuEvent = env->GetFieldID(EventUnion_Class, \"MenuEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MENU_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_MenuEvent);\n-    EventUnion_FocusEvent = env->GetFieldID(EventUnion_Class, \"FocusEvent\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$FOCUS_EVENT_RECORD;\");\n-    CHECK_NULL(EventUnion_FocusEvent);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.KEY_EVENT_RECORD\n-    KEY_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$KEY_EVENT_RECORD\"));\n-    CHECK_NULL(KEY_EVENT_RECORD_Class);\n-    KEY_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(KEY_EVENT_RECORD_Constructor);\n-    KEY_EVENT_RECORD_bKeyDown = env->GetFieldID(KEY_EVENT_RECORD_Class, \"bKeyDown\", \"Z\");\n-    CHECK_NULL(KEY_EVENT_RECORD_bKeyDown);\n-    KEY_EVENT_RECORD_wRepeatCount = env->GetFieldID(KEY_EVENT_RECORD_Class, \"wRepeatCount\", \"S\");\n-    CHECK_NULL(KEY_EVENT_RECORD_wRepeatCount);\n-    KEY_EVENT_RECORD_wVirtualKeyCode = env->GetFieldID(KEY_EVENT_RECORD_Class, \"wVirtualKeyCode\", \"S\");\n-    CHECK_NULL(KEY_EVENT_RECORD_wVirtualKeyCode);\n-    KEY_EVENT_RECORD_wVirtualScanCode = env->GetFieldID(KEY_EVENT_RECORD_Class, \"wVirtualScanCode\", \"S\");\n-    CHECK_NULL(KEY_EVENT_RECORD_wVirtualScanCode);\n-    KEY_EVENT_RECORD_uChar = env->GetFieldID(KEY_EVENT_RECORD_Class, \"uChar\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$UnionChar;\");\n-    CHECK_NULL(KEY_EVENT_RECORD_uChar);\n-    KEY_EVENT_RECORD_dwControlKeyState = env->GetFieldID(KEY_EVENT_RECORD_Class, \"dwControlKeyState\", \"I\");\n-    CHECK_NULL(KEY_EVENT_RECORD_dwControlKeyState);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MOUSE_EVENT_RECORD\n-    MOUSE_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MOUSE_EVENT_RECORD\"));\n-    CHECK_NULL(MOUSE_EVENT_RECORD_Class);\n-    MOUSE_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_Constructor);\n-    MOUSE_EVENT_RECORD_dwMousePosition = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwMousePosition\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwMousePosition);\n-    MOUSE_EVENT_RECORD_dwButtonState = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwButtonState\", \"I\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwButtonState);\n-    MOUSE_EVENT_RECORD_dwControlKeyState = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwControlKeyState\", \"I\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwControlKeyState);\n-    MOUSE_EVENT_RECORD_dwEventFlags = env->GetFieldID(MOUSE_EVENT_RECORD_Class, \"dwEventFlags\", \"I\");\n-    CHECK_NULL(MOUSE_EVENT_RECORD_dwEventFlags);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.WINDOW_BUFFER_SIZE_RECORD\n-    WINDOW_BUFFER_SIZE_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$WINDOW_BUFFER_SIZE_RECORD\"));\n-    CHECK_NULL(WINDOW_BUFFER_SIZE_RECORD_Class);\n-    WINDOW_BUFFER_SIZE_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(WINDOW_BUFFER_SIZE_RECORD_Constructor);\n-    WINDOW_BUFFER_SIZE_RECORD_dwSize = env->GetFieldID(WINDOW_BUFFER_SIZE_RECORD_Class, \"dwSize\", \"Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$COORD;\");\n-    CHECK_NULL(WINDOW_BUFFER_SIZE_RECORD_dwSize);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.MENU_EVENT_RECORD\n-    MENU_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$MENU_EVENT_RECORD\"));\n-    CHECK_NULL(MENU_EVENT_RECORD_Class);\n-    MENU_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(MENU_EVENT_RECORD_Constructor);\n-    MENU_EVENT_RECORD_dwCommandId = env->GetFieldID(MENU_EVENT_RECORD_Class, \"dwCommandId\", \"I\");\n-    CHECK_NULL(MENU_EVENT_RECORD_dwCommandId);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOCUS_EVENT_RECORD\n-    FOCUS_EVENT_RECORD_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$FOCUS_EVENT_RECORD\"));\n-    CHECK_NULL(FOCUS_EVENT_RECORD_Class);\n-    FOCUS_EVENT_RECORD_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(FOCUS_EVENT_RECORD_Constructor);\n-    FOCUS_EVENT_RECORD_bSetFocus = env->GetFieldID(FOCUS_EVENT_RECORD_Class, \"bSetFocus\", \"Z\");\n-    CHECK_NULL(FOCUS_EVENT_RECORD_bSetFocus);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.SMALL_RECT\n-    SMALL_RECT_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$SMALL_RECT\"));\n-    CHECK_NULL(SMALL_RECT_Class);\n-    SMALL_RECT_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(SMALL_RECT_Constructor);\n-    SMALL_RECT_Left = env->GetFieldID(SMALL_RECT_Class, \"Left\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Left);\n-    SMALL_RECT_Top = env->GetFieldID(SMALL_RECT_Class, \"Top\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Top);\n-    SMALL_RECT_Right = env->GetFieldID(SMALL_RECT_Class, \"Right\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Right);\n-    SMALL_RECT_Bottom = env->GetFieldID(SMALL_RECT_Class, \"Bottom\", \"S\");\n-    CHECK_NULL(SMALL_RECT_Bottom);\n-\n-    \/\/jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.UnionChar\n-    UnionChar_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32$UnionChar\"));\n-    CHECK_NULL(UnionChar_Class);\n-    UnionChar_Constructor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    CHECK_NULL(UnionChar_Constructor);\n-    UnionChar_UnicodeChar = env->GetFieldID(UnionChar_Class, \"UnicodeChar\", \"C\");\n-    CHECK_NULL(UnionChar_UnicodeChar);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    WaitForSingleObject\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_WaitForSingleObject\n-  (JNIEnv *env, jobject kernel, jobject in_hHandle, jint in_dwMilliseconds) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hHandle, pointerValue));\n-    return WaitForSingleObject(h, in_dwMilliseconds);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetStdHandle\n- * Signature: (I)Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;\n- *\/\n-JNIEXPORT jobject JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetStdHandle\n-  (JNIEnv *env, jobject, jint nStdHandle) {\n-    return env->NewObject(pointerClass,\n-                          pointerConstructor,\n-                          nStdHandle);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetConsoleOutputCP\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetConsoleOutputCP\n-  (JNIEnv *, jobject) {\n-    return GetConsoleOutputCP();\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    FillConsoleOutputCharacter\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;CILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_FillConsoleOutputCharacter\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jchar in_cCharacter, jint in_nLength, jobject in_dwWriteCoord, jobject out_lpNumberOfCharsWritten) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    DWORD written;\n-    COORD coord;\n-    coord.X = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_X);\n-    coord.Y = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_Y);\n-    if (!FillConsoleOutputCharacter(h, (CHAR) in_cCharacter, in_nLength, coord, &written)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->SetIntField(out_lpNumberOfCharsWritten, intByReferenceValue, written);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    FillConsoleOutputAttribute\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;SILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_FillConsoleOutputAttribute\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jshort in_wAttribute, jint in_nLength, jobject in_dwWriteCoord, jobject out_lpNumberOfAttrsWritten) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    DWORD written;\n-    COORD coord;\n-    coord.X = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_X);\n-    coord.Y = (SHORT) env->GetLongField(in_dwWriteCoord, COORD_Y);\n-    if (!FillConsoleOutputAttribute(h, in_wAttribute, in_nLength, coord, &written)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->SetIntField(out_lpNumberOfAttrsWritten, intByReferenceValue, written);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetConsoleMode\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetConsoleMode\n-  (JNIEnv *env, jobject, jobject in_hConsoleOutput, jobject out_lpMode) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    DWORD mode;\n-    if (!GetConsoleMode(h, &mode)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->SetIntField(out_lpMode, intByReferenceValue, mode);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    GetConsoleScreenBufferInfo\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/CONSOLE_SCREEN_BUFFER_INFO;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_GetConsoleScreenBufferInfo\n-  (JNIEnv *env, jobject, jobject in_hConsoleOutput, jobject\/*CONSOLE_SCREEN_BUFFER_INFO*\/ out_lpConsoleScreenBufferInfo) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    CONSOLE_SCREEN_BUFFER_INFO buffer;\n-    if (!GetConsoleScreenBufferInfo(h, &buffer)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-\n-    jobject dwSize = env->NewObject(COORD_Class,\n-                                    COORD_Constructor);\n-    env->SetIntField(dwSize, COORD_X, buffer.dwSize.X);\n-    env->SetIntField(dwSize, COORD_Y, buffer.dwSize.Y);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_dwSize, dwSize);\n-\n-    jobject dwCursorPosition = env->NewObject(COORD_Class,\n-                                              COORD_Constructor);\n-    env->SetIntField(dwCursorPosition, COORD_X, buffer.dwCursorPosition.X);\n-    env->SetIntField(dwCursorPosition, COORD_Y, buffer.dwCursorPosition.Y);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_dwCursorPosition, dwCursorPosition);\n-\n-    env->SetIntField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_wAttributes, buffer.wAttributes);\n-\n-    jobject srWindow = env->NewObject(SMALL_RECT_Class,\n-                                      SMALL_RECT_Constructor);\n-    env->SetIntField(srWindow, SMALL_RECT_Left, buffer.srWindow.Left);\n-    env->SetIntField(srWindow, SMALL_RECT_Top, buffer.srWindow.Top);\n-    env->SetIntField(srWindow, SMALL_RECT_Right, buffer.srWindow.Right);\n-    env->SetIntField(srWindow, SMALL_RECT_Bottom, buffer.srWindow.Bottom);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_srWindow, srWindow);\n-\n-    jobject dwMaximumWindowSize = env->NewObject(COORD_Class,\n-                                                 COORD_Constructor);\n-    env->SetIntField(dwMaximumWindowSize, COORD_X, buffer.dwMaximumWindowSize.X);\n-    env->SetIntField(dwMaximumWindowSize, COORD_Y, buffer.dwMaximumWindowSize.Y);\n-    env->SetObjectField(out_lpConsoleScreenBufferInfo, CONSOLE_SCREEN_BUFFER_INFO_dwMaximumWindowSize, dwMaximumWindowSize);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    ReadConsoleInput\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;[Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/INPUT_RECORD;ILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_ReadConsoleInput\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jobjectArray\/*INPUT_RECORD[]*\/ out_lpBuffer, jint in_nLength, jobject out_lpNumberOfEventsRead) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    INPUT_RECORD *buffer = new INPUT_RECORD[in_nLength];\n-    DWORD numberOfEventsRead;\n-    if (!ReadConsoleInputW(h, buffer, in_nLength, &numberOfEventsRead)) {\n-        delete[] buffer;\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    for (unsigned int i = 0; i < numberOfEventsRead; i++) {\n-        jobject record = env->NewObject(INPUT_RECORD_Class,\n-                                        INPUT_RECORD_Constructor);\n-        env->SetShortField(record, INPUT_RECORD_EventType, buffer[i].EventType);\n-        switch (buffer[i].EventType) {\n-            case KEY_EVENT: {\n-                jobject keyEvent = env->NewObject(KEY_EVENT_RECORD_Class,\n-                                                  KEY_EVENT_RECORD_Constructor);\n-                env->SetBooleanField(keyEvent, KEY_EVENT_RECORD_bKeyDown, buffer[i].Event.KeyEvent.bKeyDown);\n-                env->SetShortField(keyEvent, KEY_EVENT_RECORD_wRepeatCount, buffer[i].Event.KeyEvent.wRepeatCount);\n-                env->SetShortField(keyEvent, KEY_EVENT_RECORD_wVirtualKeyCode, buffer[i].Event.KeyEvent.wVirtualKeyCode);\n-                env->SetShortField(keyEvent, KEY_EVENT_RECORD_wVirtualScanCode, buffer[i].Event.KeyEvent.wVirtualScanCode);\n-\n-                jobject unionChar = env->NewObject(UnionChar_Class,\n-                                                   UnionChar_Constructor);\n-\n-                env->SetIntField(unionChar, UnionChar_UnicodeChar, buffer[i].Event.KeyEvent.uChar.UnicodeChar);\n-\n-                env->SetObjectField(keyEvent, KEY_EVENT_RECORD_uChar, unionChar);\n-\n-                env->SetIntField(keyEvent, KEY_EVENT_RECORD_dwControlKeyState, buffer[i].Event.KeyEvent.dwControlKeyState);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_KeyEvent, keyEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case MOUSE_EVENT: {\n-                jobject mouseEvent = env->NewObject(MOUSE_EVENT_RECORD_Class,\n-                                                    MOUSE_EVENT_RECORD_Constructor);\n-\n-                jobject dwMousePosition = env->NewObject(COORD_Class,\n-                                                         COORD_Constructor);\n-                env->SetIntField(dwMousePosition, COORD_X, buffer[i].Event.MouseEvent.dwMousePosition.X);\n-                env->SetIntField(dwMousePosition, COORD_Y, buffer[i].Event.MouseEvent.dwMousePosition.Y);\n-                env->SetObjectField(mouseEvent, MOUSE_EVENT_RECORD_dwMousePosition, dwMousePosition);\n-                env->SetIntField(mouseEvent, MOUSE_EVENT_RECORD_dwButtonState, buffer[i].Event.MouseEvent.dwButtonState);\n-                env->SetIntField(mouseEvent, MOUSE_EVENT_RECORD_dwControlKeyState, buffer[i].Event.MouseEvent.dwControlKeyState);\n-                env->SetIntField(mouseEvent, MOUSE_EVENT_RECORD_dwEventFlags, buffer[i].Event.MouseEvent.dwEventFlags);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_MouseEvent, mouseEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case WINDOW_BUFFER_SIZE_EVENT: {\n-                jobject windowBufferSize = env->NewObject(WINDOW_BUFFER_SIZE_RECORD_Class,\n-                                                          WINDOW_BUFFER_SIZE_RECORD_Constructor);\n-\n-                jobject dwSize = env->NewObject(COORD_Class,\n-                                                COORD_Constructor);\n-                env->SetIntField(dwSize, COORD_X, buffer[i].Event.WindowBufferSizeEvent.dwSize.X);\n-                env->SetIntField(dwSize, COORD_Y, buffer[i].Event.WindowBufferSizeEvent.dwSize.Y);\n-                env->SetObjectField(windowBufferSize, WINDOW_BUFFER_SIZE_RECORD_dwSize, dwSize);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_WindowBufferSizeEvent, windowBufferSize);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case MENU_EVENT: {\n-                jobject menuEvent = env->NewObject(MENU_EVENT_RECORD_Class,\n-                                                          MENU_EVENT_RECORD_Constructor);\n-\n-                env->SetBooleanField(menuEvent, MENU_EVENT_RECORD_dwCommandId, buffer[i].Event.MenuEvent.dwCommandId);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_MenuEvent, menuEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-            case FOCUS_EVENT: {\n-                jobject focusEvent = env->NewObject(FOCUS_EVENT_RECORD_Class,\n-                                                    FOCUS_EVENT_RECORD_Constructor);\n-\n-                env->SetIntField(focusEvent, FOCUS_EVENT_RECORD_bSetFocus, buffer[i].Event.FocusEvent.bSetFocus);\n-\n-                jobject event = env->NewObject(EventUnion_Class,\n-                                               EventUnion_Constructor);\n-\n-                env->SetObjectField(event, EventUnion_FocusEvent, focusEvent);\n-                env->SetObjectField(record, INPUT_RECORD_Event, event);\n-                break;\n-            }\n-        }\n-        env->SetObjectArrayElement(out_lpBuffer, i, record);\n-    }\n-    env->SetIntField(out_lpNumberOfEventsRead, intByReferenceValue, numberOfEventsRead);\n-    delete[] buffer;\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleCursorPosition\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleCursorPosition\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jobject in_dwCursorPosition) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    COORD coord;\n-    coord.X = (SHORT) env->GetLongField(in_dwCursorPosition, COORD_X);\n-    coord.Y = (SHORT) env->GetLongField(in_dwCursorPosition, COORD_Y);\n-    if (!SetConsoleCursorPosition(h, coord)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return;\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleMode\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleMode\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jint in_dwMode) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    if (!SetConsoleMode(h, in_dwMode)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleTextAttribute\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;S)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleTextAttribute\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jshort in_wAttributes) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    if (!SetConsoleTextAttribute(h, in_wAttributes)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    SetConsoleTitle\n- * Signature: (Ljava\/lang\/String;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_SetConsoleTitle\n-  (JNIEnv *env, jobject, jstring in_lpConsoleTitle) {\n-    const char *chars = env->GetStringUTFChars(in_lpConsoleTitle, NULL);\n-    if (!SetConsoleTitle(chars)) {\n-        env->ReleaseStringUTFChars(in_lpConsoleTitle, chars);\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-    env->ReleaseStringUTFChars(in_lpConsoleTitle, chars);\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    WriteConsoleW\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;[CILjdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/IntByReference;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_WriteConsoleW\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jcharArray in_lpBuffer, jint in_nNumberOfCharsToWrite, jobject out_lpNumberOfCharsWritten, jobject) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-    jchar *chars = new jchar[in_nNumberOfCharsToWrite];\n-    env->GetCharArrayRegion(in_lpBuffer, 0, in_nNumberOfCharsToWrite, chars);\n-    DWORD written;\n-    if (!WriteConsoleW(h, chars, in_nNumberOfCharsToWrite, &written, NULL)) {\n-        delete[] chars;\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-\n-    env->SetIntField(out_lpNumberOfCharsWritten, intByReferenceValue, written);\n-    delete[] chars;\n-}\n-\n-\/*\n- * Class:     jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl\n- * Method:    ScrollConsoleScreenBuffer\n- * Signature: (Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Pointer;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/SMALL_RECT;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/SMALL_RECT;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/COORD;Ljdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/Kernel32\/CHAR_INFO;)V\n- *\/\n-JNIEXPORT void JNICALL Java_jdk_internal_org_jline_terminal_impl_jna_win_Kernel32Impl_ScrollConsoleScreenBuffer\n-  (JNIEnv *env, jobject kernel, jobject in_hConsoleOutput, jobject in_lpScrollRectangle, jobject in_lpClipRectangle, jobject in_dwDestinationOrigin, jobject in_lpFill) {\n-    HANDLE h = GetStdHandle((jint) env->GetLongField(in_hConsoleOutput, pointerValue));\n-\n-    SMALL_RECT scrollRectangle;\n-    scrollRectangle.Left = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Left);\n-    scrollRectangle.Top = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Top);\n-    scrollRectangle.Right = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Right);\n-    scrollRectangle.Bottom = (SHORT) env->GetLongField(in_lpScrollRectangle, SMALL_RECT_Bottom);\n-\n-    SMALL_RECT clipRectangle;\n-    clipRectangle.Left = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Left);\n-    clipRectangle.Top = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Top);\n-    clipRectangle.Right = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Right);\n-    clipRectangle.Bottom = (SHORT) env->GetLongField(in_lpClipRectangle, SMALL_RECT_Bottom);\n-\n-    COORD destinationOrigin;\n-    destinationOrigin.X = (SHORT) env->GetLongField(in_dwDestinationOrigin, COORD_X);\n-    destinationOrigin.Y = (SHORT) env->GetLongField(in_dwDestinationOrigin, COORD_Y);\n-\n-    CHAR_INFO charInfo;\n-    charInfo.Char.UnicodeChar = env->GetCharField(env->GetObjectField(in_lpFill, CHAR_INFO_uChar), UnionChar_UnicodeChar);\n-    charInfo.Attributes = env->GetShortField(in_lpFill, CHAR_INFO_Attributes);\n-\n-    if (!ScrollConsoleScreenBuffer(h, &scrollRectangle, &clipRectangle, destinationOrigin, &charInfo)) {\n-        DWORD error = GetLastError();\n-        jobject exc = env->NewObject(lastErrorExceptionClass,\n-                                     lastErrorExceptionConstructor,\n-                                     (jlong) error);\n-        env->Throw((jthrowable) exc);\n-        return ;\n-    }\n-}\n","filename":"src\/jdk.internal.le\/windows\/native\/lible\/Kernel32.cpp","additions":0,"deletions":710,"binary":false,"changes":710,"status":"deleted"},{"patch":"@@ -0,0 +1,976 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.markdown;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTreeVisitor;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+\n+import com.sun.tools.javac.api.JavacTrees;\n+import com.sun.tools.javac.parser.ReferenceParser;\n+import com.sun.tools.javac.tree.DCTree;\n+import com.sun.tools.javac.tree.DocTreeMaker;\n+import com.sun.tools.javac.util.DefinedBy;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.TablesExtension;\n+import jdk.internal.org.commonmark.internal.InlineParserImpl;\n+import jdk.internal.org.commonmark.node.AbstractVisitor;\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.IncludeSourceSpans;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.InlineParserContext;\n+import jdk.internal.org.commonmark.parser.InlineParserFactory;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import static com.sun.tools.javac.util.Position.NOPOS;\n+\n+\/**\n+ * A class to transform a {@code DocTree} node into a similar one with\n+ * doc-comment \"extensions\" translated into equivalent standard {@code DocTree} nodes.\n+ *\n+ * <p>The primary extension is to allow references to program elements to be\n+ * translated to {@code {@link ...}} or {@code {@linkplain ...}} tags.\n+ *\/\n+public class MarkdownTransformer implements JavacTrees.DocCommentTreeTransformer {\n+\n+    \/**\n+     * Public no-args constructor, suitable for use with {@link java.util.ServiceLoader}.\n+     *\/\n+    public MarkdownTransformer() { }\n+\n+    public String name() {\n+        return \"standard\";\n+    }\n+\n+    @Override @DefinedBy(DefinedBy.Api.COMPILER_TREE)\n+    public DocCommentTree transform(DocTrees trees, DocCommentTree tree) {\n+        if (!(trees instanceof JavacTrees t)) {\n+            throw new IllegalArgumentException(\"class not supported: \" + trees.getClass());\n+        }\n+        if (!(tree instanceof DCTree.DCDocComment dc)) {\n+            throw new IllegalArgumentException(\"class not supported: \" + tree.getClass());\n+        }\n+\n+        return isMarkdown(dc) ? new DCTransformer(t).transform(dc) : dc;\n+    }\n+\n+    private boolean isMarkdown(DocCommentTree node) {\n+        return isMarkdownVisitor.visitDocComment(node, null);\n+    }\n+\n+    \/**\n+     * A fast scanner for detecting Markdown nodes in documentation comment nodes.\n+     * The scanner returns as soon as any Markdown node is found.\n+     *\/\n+    private static final DocTreeVisitor<Boolean, Void> isMarkdownVisitor = new DocTreeScanner<>() {\n+        @Override\n+        public Boolean scan(Iterable<? extends DocTree> nodes, Void ignore) {\n+            if (nodes != null) {\n+                for (DocTree node : nodes) {\n+                    Boolean b = scan(node, ignore);\n+                    if (b == Boolean.TRUE) {\n+                        return b;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean scan(DocTree node, Void ignore) {\n+            return node != null && node.getKind() == DocTree.Kind.MARKDOWN ? Boolean.TRUE : super.scan(node, ignore);\n+        }\n+\n+        @Override\n+        public Boolean reduce(Boolean r1, Boolean r2) {\n+            return r1 == Boolean.TRUE || r2 == Boolean.TRUE;\n+        }\n+    };\n+\n+    private static final char PLACEHOLDER = '\\uFFFC'; \/\/ Unicode Object Replacement Character\n+\n+    private static class DCTransformer {\n+        private final DocTreeMaker m;\n+        private final ReferenceParser refParser;\n+\n+        \/\/ a dynamically generated scheme for the URLs of automatically generated references;\n+        \/\/ to allow user-generated code URLs, change this to just \"code:\"\n+        private final String autorefScheme = \"code-\" + Integer.toHexString(hashCode()) + \":\";\n+\n+        DCTransformer(JavacTrees t) {\n+            m = t.getDocTreeFactory();\n+            refParser = new ReferenceParser(t.getParserFactory());\n+        }\n+\n+        \/**\n+         * Transforms a doc tree node.\n+         * This node dispatches to a more specific overload, based on the kind of the node.\n+         * The result may be the same as the argument if no transformations were made.\n+         *\n+         * @param tree the tree node\n+         * @return a tree with any \"extensions\" converted into tags\n+         *\/\n+        public DCTree transform(DCTree tree) {\n+            \/\/ The following switch statement could eventually be converted to a\n+            \/\/ pattern switch. It is intended to be a total switch, with a default\n+            \/\/ to catch any omissions.\n+            return switch (tree.getKind()) {\n+                \/\/ The following cannot contain Markdown and so always transform to themselves.\n+                case ATTRIBUTE,\n+                        CODE, COMMENT,\n+                        DOC_ROOT, DOC_TYPE,\n+                        END_ELEMENT, ENTITY, ERRONEOUS, ESCAPE,\n+                        IDENTIFIER, INHERIT_DOC,\n+                        LITERAL,\n+                        REFERENCE,\n+                        SNIPPET, START_ELEMENT, SYSTEM_PROPERTY,\n+                        TEXT,\n+                        VALUE -> tree;\n+\n+                \/\/ The following may contain Markdown in at least one of their fields.\n+                case AUTHOR -> transform((DCTree.DCAuthor) tree);\n+                case DEPRECATED -> transform((DCTree.DCDeprecated) tree);\n+                case DOC_COMMENT -> transform((DCTree.DCDocComment) tree);\n+                case EXCEPTION, THROWS -> transform((DCTree.DCThrows) tree);\n+                case HIDDEN -> transform((DCTree.DCHidden) tree);\n+                case INDEX -> transform((DCTree.DCIndex) tree);\n+                case LINK, LINK_PLAIN -> transform((DCTree.DCLink) tree);\n+                case PARAM -> transform((DCTree.DCParam) tree);\n+                case PROVIDES -> transform((DCTree.DCProvides) tree);\n+                case RETURN -> transform((DCTree.DCReturn) tree);\n+                case SEE -> transform((DCTree.DCSee) tree);\n+                case SERIAL -> transform((DCTree.DCSerial) tree);\n+                case SERIAL_DATA -> transform((DCTree.DCSerialData) tree);\n+                case SERIAL_FIELD -> transform((DCTree.DCSerialField) tree);\n+                case SINCE -> transform((DCTree.DCSince) tree);\n+                case SPEC -> transform((DCTree.DCSpec) tree);\n+                case SUMMARY -> transform((DCTree.DCSummary) tree);\n+                case UNKNOWN_BLOCK_TAG -> transform((DCTree.DCUnknownBlockTag) tree);\n+                case UNKNOWN_INLINE_TAG -> transform((DCTree.DCUnknownInlineTag) tree);\n+                case USES -> transform((DCTree.DCUses) tree);\n+                case VERSION -> transform((DCTree.DCVersion) tree);\n+\n+                \/\/ This should never be handled directly; instead it should be handled as part of\n+                \/\/   transform(List<? extends DocTree>);\n+                \/\/ because a Markdown node has the potential to be split into multiple nodes.\n+                case MARKDOWN -> throw new IllegalArgumentException(tree.getKind().toString());\n+\n+                \/\/ Catch in case new kinds are added\n+                default -> throw new IllegalArgumentException(tree.getKind().toString());\n+            };\n+        }\n+\n+        \/**\n+         * Transforms a list of doc tree nodes.\n+         * If any of the nodes contain Markdown, the Markdown source is parsed\n+         * and analyzed for any transformations.\n+         * Any non-Markdown nodes are individually transformed.\n+         *\n+         * @param trees the list of tree nodes to be transformed\n+         * @return the transformed list\n+         *\/\n+        private List<? extends DCTree> transform(List<? extends DCTree> trees) {\n+            boolean hasMarkdown = trees.stream().anyMatch(t -> t.getKind() == DocTree.Kind.MARKDOWN);\n+            if (hasMarkdown) {\n+                var sourceBuilder = new StringBuilder();\n+                var replacements = new ArrayList<>();\n+\n+                \/*\n+                 * Step 1: Convert the trees into a string containing Markdown text,\n+                 *         using Unicode Object Replacement characters to mark the positions\n+                 *         of non-Markdown content.\n+                 *\/\n+                for (DCTree tree : trees) {\n+                    if (tree instanceof RawTextTree t) {\n+                        if (t.getKind() != DocTree.Kind.MARKDOWN) {\n+                            throw new IllegalStateException(t.getKind().toString());\n+                        }\n+                        String code = t.getContent();\n+                        \/\/ handle the (unlikely) case of any U+FFFC characters existing in the code\n+                        int start = 0;\n+                        int pos;\n+                        while ((pos = code.indexOf(PLACEHOLDER, start)) != -1) {\n+                            replacements.add(PLACEHOLDER);\n+                            start = pos + 1;\n+                        }\n+                        sourceBuilder.append(code);\n+                    } else {\n+                        replacements.add(transform(tree));\n+                        sourceBuilder.append(PLACEHOLDER);\n+                    }\n+                }\n+\n+                \/*\n+                 * Step 2: Build a parser, and configure it to accept additional syntactic constructs,\n+                 *         such as reference-style links to program elements.\n+                 *\/\n+                String source = sourceBuilder.toString();\n+                Parser parser = Parser.builder()\n+                        .extensions(List.of(TablesExtension.create()))\n+                        .inlineParserFactory(new AutoRefInlineParserFactory(refParser, autorefScheme))\n+                        .includeSourceSpans(IncludeSourceSpans.BLOCKS_AND_INLINES)\n+                        .build();\n+                Node document = parser.parse(source);\n+\n+                \/*\n+                 * Step 3: Analyze the parsed tree, converting it back to a list of DocTree nodes,\n+                 *         consisting of Markdown text interspersed with any pre-existing\n+                 *         DocTree nodes, as well as any new nodes created by converting\n+                 *         parts of the Markdown tree into nodes for old-style javadoc tags.\n+                 *\/\n+                var firstTreePos = trees.getFirst().getStartPosition();\n+                Lower v = new Lower(m, document, source, firstTreePos, replacements, autorefScheme);\n+                document.accept(v);\n+\n+                return v.getTrees();\n+\n+            } else {\n+                var list2 = trees.stream()\n+                        .map(this::transform)\n+                        .toList();\n+                return equal(list2, trees) ? trees : list2;\n+            }\n+        }\n+\n+        \/\/-----------------------------------------------------------------------------\n+        \/\/\n+        \/\/ The following {@code transform} methods invoke {@code transform} on\n+        \/\/ any children that may contain Markdown. If the transformations on\n+        \/\/ the children are all identity transformations (that is the result\n+        \/\/ of the transformations are the same as the originals) then the\n+        \/\/ result of the overall transform is the original object. But if\n+        \/\/ any transformation on the children is not an identity transformation\n+        \/\/ then the result is a new node containing the transformed values.\n+        \/\/\n+        \/\/ Thus, we only duplicate the parts of the tree that have changed,\n+        \/\/ and we do not duplicate the parts of the tree that have not changed.\n+\n+        private DCTree.DCAuthor transform(DCTree.DCAuthor tree) {\n+            var name2 = transform(tree.name);\n+            return (equal(name2, tree.name))\n+                    ? tree\n+                    : m.at(tree.pos).newAuthorTree(name2);\n+        }\n+\n+        private DCTree.DCDeprecated transform(DCTree.DCDeprecated tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newDeprecatedTree(body2);\n+        }\n+\n+        public DCTree.DCDocComment transform(DCTree.DCDocComment tree) {\n+            var fullBody2 = transform(tree.fullBody);\n+            var tags2 = transform(tree.tags);\n+            \/\/ Note: preamble and postamble only appear in HTML files, so should always be\n+            \/\/ null or empty for doc comments and\/or Markdown files\n+            var pre2 = transform(tree.preamble);\n+            var post2 = transform(tree.postamble);\n+            return (equal(fullBody2, tree.fullBody) && equal(tags2, tree.tags)\n+                    && equal(pre2, tree.preamble) && equal(post2, tree.postamble))\n+                    ? tree\n+                    : m.at(tree.pos).newDocCommentTree(tree.comment, fullBody2, tags2, pre2, post2);\n+        }\n+\n+        private DCTree.DCHidden transform(DCTree.DCHidden tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newHiddenTree(body2);\n+        }\n+\n+        private DCTree.DCIndex transform(DCTree.DCIndex tree) {\n+            \/\/ The public API permits a DocTree, although in the implementation, it is always a TextTree.\n+            var term2 = transform(tree.term);\n+            var desc2 = transform(tree.description);\n+            return (equal(term2, tree.term) && equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newIndexTree(term2, desc2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCLink transform(DCTree.DCLink tree) {\n+            var label2 = transform(tree.label);\n+            return (equal(label2, tree.label))\n+                    ? tree\n+                    : switch (tree.getKind()) {\n+                case LINK -> m.at(tree.pos).newLinkTree(tree.ref, label2).setEndPos(tree.getEndPos());\n+                case LINK_PLAIN -> m.at(tree.pos).newLinkPlainTree(tree.ref, label2).setEndPos(tree.getEndPos());\n+                default -> throw new IllegalArgumentException(tree.getKind().toString());\n+            };\n+        }\n+\n+        private DCTree.DCParam transform(DCTree.DCParam tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newParamTree(tree.isTypeParameter, tree.name, desc2);\n+        }\n+\n+        private DCTree.DCProvides transform(DCTree.DCProvides tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newProvidesTree(tree.serviceType, desc2);\n+        }\n+\n+        private DCTree.DCReturn transform(DCTree.DCReturn tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newReturnTree(tree.inline, desc2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCSee transform(DCTree.DCSee tree) {\n+            List<? extends DocTree> ref2 = transform(tree.reference);\n+            return (equal(ref2, tree.getReference()))\n+                    ? tree\n+                    : m.at(tree.pos).newSeeTree(ref2);\n+        }\n+\n+        private DCTree.DCSerial transform(DCTree.DCSerial tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newSerialTree(desc2);\n+        }\n+\n+        private DCTree.DCSerialData transform(DCTree.DCSerialData tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newSerialDataTree(desc2);\n+        }\n+\n+        private DCTree.DCSerialField transform(DCTree.DCSerialField tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newSerialFieldTree(tree.name, tree.type, desc2);\n+        }\n+\n+        DCTree.DCSince transform(DCTree.DCSince tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newSinceTree(body2);\n+        }\n+\n+        private DCTree.DCSpec transform(DCTree.DCSpec tree) {\n+            var title2 = transform(tree.title);\n+            return (equal(title2, tree.title))\n+                    ? tree\n+                    : m.at(tree.pos).newSpecTree(tree.uri, title2);\n+        }\n+\n+        private DCTree.DCSummary transform(DCTree.DCSummary tree) {\n+            var summ2 = transform(tree.summary);\n+            return (equal(summ2, tree.summary))\n+                    ? tree\n+                    : m.at(tree.pos).newSummaryTree(summ2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCThrows transform(DCTree.DCThrows tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : switch (tree.getKind()) {\n+                case EXCEPTION -> m.at(tree.pos).newExceptionTree(tree.name, desc2);\n+                case THROWS -> m.at(tree.pos).newThrowsTree(tree.name, desc2);\n+                default -> throw new IllegalArgumentException(tree.getKind().toString());\n+            };\n+        }\n+\n+        private DCTree.DCUnknownBlockTag transform(DCTree.DCUnknownBlockTag tree) {\n+            var cont2 = transform(tree.content);\n+            return (equal(cont2, tree.content))\n+                    ? tree\n+                    : m.at(tree.pos).newUnknownBlockTagTree(tree.name, cont2);\n+        }\n+\n+        private DCTree.DCUnknownInlineTag transform(DCTree.DCUnknownInlineTag tree) {\n+            var cont2 = transform(tree.content);\n+            return (equal(cont2, tree.content))\n+                    ? tree\n+                    : m.at(tree.pos).newUnknownInlineTagTree(tree.name, cont2).setEndPos(tree.getEndPos());\n+        }\n+\n+        private DCTree.DCUses transform(DCTree.DCUses tree) {\n+            var desc2 = transform(tree.description);\n+            return (equal(desc2, tree.description))\n+                    ? tree\n+                    : m.at(tree.pos).newUsesTree(tree.serviceType, desc2);\n+        }\n+\n+        private DCTree.DCVersion transform(DCTree.DCVersion tree) {\n+            var body2 = transform(tree.body);\n+            return (equal(body2, tree.body))\n+                    ? tree\n+                    : m.at(tree.pos).newVersionTree(body2);\n+        }\n+\n+        \/**\n+         * Shallow \"equals\" for two doc tree nodes.\n+         *\n+         * @param <T> the type of the items\n+         * @param item1 the first item\n+         * @param item2 the second item\n+         * @return {@code true} if the items are reference-equal, and {@code false} otherwise\n+         *\/\n+        private static <T extends DocTree> boolean equal(T item1, T item2) {\n+            return item1 == item2;\n+        }\n+\n+        \/**\n+         * Shallow \"equals\" for two lists of doc tree nodes.\n+         *\n+         * @param <T> the type of the items\n+         * @param list1 the first item\n+         * @param list2 the second item\n+         * @return {@code true} if the items are reference-equal, and {@code false} otherwise\n+         *\/\n+        private static <T extends DocTree> boolean equal(List<? extends T> list1, List<? extends T> list2) {\n+            if (list1 == null || list2 == null) {\n+                return (list1 == list2);\n+            }\n+\n+            if (list1.size() != list2.size()) {\n+                return false;\n+            }\n+\n+            var iter1 = list1.iterator();\n+            var iter2 = list2.iterator();\n+            while (iter1.hasNext()) {\n+                var item1 = iter1.next();\n+                var item2 = iter2.next();\n+                if (item1 != item2) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * An {@code InlineParserFactory} that checks any unresolved link references in\n+     * reference links. If an unresolved link reference appears to be a reference to a\n+     * program element, such as may be used in {@code @see ...} or {@code {@link ...}}\n+     * tags, it generates a synthetic {@code LinkReferenceDefinition}.\n+     *\n+     * The reference is not validated to ensure it refers to any existing element.\n+     *\n+     * The primary function of this {@code InlineParserFactory} is to provide\n+     * a custom implementation of an {@code InlineParserContext} via the\n+     * {@code create(InlineParserContext inlineParserContext)} method.\n+     * It is this {@code InlineParserContext} that actually manages the set\n+     * of link reference definitions.\n+     *\n+     * This {@code InlineParserFactory} is intended to be registered with a\n+     * {@code Parser.Builder} using {@code setInlineParserFactory}.\n+     *\/\n+    private static class AutoRefInlineParserFactory implements InlineParserFactory {\n+        private final ReferenceParser refParser;\n+        private final String autorefScheme;\n+\n+        AutoRefInlineParserFactory(ReferenceParser refParser,\n+                                   String autorefScheme) {\n+            this.refParser = refParser;\n+            this.autorefScheme = autorefScheme;\n+        }\n+\n+        \/**\n+         * Creates a parser with a modified {@code InlineParserContext} that\n+         * delegates to the standard {@code InlineParserContext} and also\n+         * checks unresolved link references.\n+         *\n+         * @param inlineParserContext the standard {@code InlineParserContext}\n+         * @return the {@code InlineParser}\n+         *\/\n+        @Override\n+        public InlineParser create(InlineParserContext inlineParserContext) {\n+            return new InlineParserImpl(new InlineParserContext() {\n+\n+                @Override\n+                public List<DelimiterProcessor> getCustomDelimiterProcessors() {\n+                    return inlineParserContext.getCustomDelimiterProcessors();\n+                }\n+\n+                \/**\n+                 * {@inheritDoc}\n+                 *\n+                 * If the given label does not match any explicitly defined\n+                 * link reference definition, but does match a reference\n+                 * to a program element, a synthetic link reference definition\n+                 * is returned, with the label prefixed by the {@code autorefScheme}.\n+                 *\n+                 * @param label the link label to look up\n+                 * @return the link reference definition for the label, or {@code null}\n+                 *\/\n+                @Override\n+                public LinkReferenceDefinition getLinkReferenceDefinition(String label) {\n+                    \/\/ In CommonMark, square brackets characters need to be escaped within a link label.\n+                    \/\/ See https:\/\/spec.commonmark.org\/0.30\/#link-label\n+                    \/\/   Unescaped square bracket characters are not allowed inside the opening\n+                    \/\/   and closing square brackets of link labels.\n+                    \/\/ The escape characters are still present here in the label,\n+                    \/\/ so we remove them before creating the autoref URL.\n+                    \/\/ Note that the characters always appear together as a pair in API references.\n+                    var l = label.replace(\"\\\\[\\\\]\", \"[]\");\n+                    var d = inlineParserContext.getLinkReferenceDefinition(l);\n+                    return d == null && isReference(l)\n+                            ? new LinkReferenceDefinition(\"\", autorefScheme + l, \"\")\n+                            : d;\n+                }\n+            });\n+        }\n+\n+        \/**\n+         * {@return whether a string appears to be a reference to a program element}\n+         *\n+         * @param s the string\n+         *\/\n+        private boolean isReference(String s) {\n+            try {\n+                refParser.parse(s, ReferenceParser.Mode.MEMBER_OPTIONAL);\n+                return true;\n+            } catch (ReferenceParser.ParseException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A visitor to scan a Markdown document looking for any constructs that\n+     * should be mapped to doc comment nodes.\n+     *\n+     * The intended use is as follows:\n+     * {@snippet\n+     *     Lower v = new Lower(document, source, replacements);\n+     *     document.accept(v);\n+     *     var result = v.getTrees();\n+     * }\n+     *\n+     * On coordinates ...\n+     *\n+     * There are various position\/coordinate systems in play in this code:\n+     *\n+     * 1. Tree positions, which correspond to positions in the original comment,\n+     *    represented as a 0-based character offset within the content of the comment.\n+     * 2. Positions in the source string given to the Markdown parser,\n+     *    represented as a 0-based character offset within the source string.\n+     *    These differ from positions in the original comment if the source string\n+     *    contains U+FFFC characters representing embedded tree nodes.\n+     * 3. Positions in the source string given to the Markdown parser,\n+     *    represented as (line, column) values within SourceSpan nodes.\n+     *    Both line and column are 0-based.\n+     *    Note: SourceSpan objects never include newline characters.\n+     *\n+     * See {@link Lower#toSourcePos(int, int)} to convert from (line, column)\n+     * coordinates to a source position.\n+     * See {@link Lower#sourcePosToTreePos(int)} to convert from a source\n+     * position to a position in the original comment, for use in tree nodes.\n+     *\/\n+\n+    \/\/ Future opportunity:\n+    \/\/\n+    \/\/ It would be possible to override {@code visit(Heading)} and\n+    \/\/ check for certain recognized headings, and for those headings,\n+    \/\/ check the content that follows up to but not including\n+    \/\/ the next heading at the same or higher level, or end of text.\n+    \/\/ When a match occurs, the heading and the content could be translated\n+    \/\/ into one or more block tags. Note that any such block tags should\n+    \/\/ probably be stored separately from {@code trees}, and handled\n+    \/\/ appropriately by the caller of this method, either by accepting\n+    \/\/ such tags, or by reporting an error if they are not applicable.\n+    \/\/\n+    \/\/ A variant would be to pass in a boolean parameter to indicate\n+    \/\/ whether such tags would be acceptable if found, and to ignore\n+    \/\/ the heading and content if the block tag would not be acceptable.\n+    \/\/\n+    \/\/ If a heading and any following content is converted to a block tag,\n+    \/\/ the content should probably be removed from the tree, so that\n+    \/\/ it is not handled by the call of {@code visitChildren} that\n+    \/\/ invoked {@code visit(Heading)}.\n+    \/\/\n+    \/\/ Overall, this would allow Markdown constructs such as the following:\n+    \/\/\n+    \/\/ \/\/\/ Method description.\n+    \/\/ \/\/\/\n+    \/\/ \/\/\/ # Parameters\n+    \/\/ \/\/\/ * args\n+    \/\/ \/\/\/\n+    \/\/ \/\/\/ # Returns\n+    \/\/ \/\/\/   a result\n+    \/\/ \/\/\/\n+    \/\/ \/\/\/ # Throws\n+    \/\/ \/\/\/ * IOException if an error occurs\n+    \/\/\n+    \/\/ That being said, is it so much better than using standard block tags?\n+    \/\/ It is somewhat more concise for any repeatable block tag, if we\n+    \/\/ leverage the idea of a heading followed by a list.\n+    private static class Lower extends AbstractVisitor {\n+        private final DocTreeMaker m;\n+        private final String autorefScheme;\n+\n+        \/**\n+         * The Markdown document being processed.\n+         *\/\n+        private final Node document;\n+\n+        \/**\n+         * The source for the Markdown document being processed.\n+         * The document has \"source spans\" that indirectly point into this string\n+         * using {@code (line, column)} coordinates.\n+         * @see #toSourcePos(int, int)\n+         *\/\n+        private final String source;\n+\n+        \/**\n+         * An array giving the position of the first character after each newline\n+         * in the source.\n+         * Used to convert {@code (line, column)} coordinates to a character offset\n+         * in {@code source}.\n+         *\/\n+        private final int[] sourceLineOffsets;\n+\n+        \/**\n+         * An iterator containing the values to be substituted into the generated\n+         * tree when U+FFFC characters are encountered in the document.\n+         * There is a 1-1 correspondence between the values returned by the\n+         * iterator and the U+FFFC characters in the document.\n+         * The replacement objects may be either {@code DCTree} objects or\n+         * U+FFFC characters that were found in the original document.\n+         *\/\n+        private final Iterator<?> replaceIter;\n+\n+        \/**\n+         * The list of trees being built.\n+         * It may be temporarily replaced while visiting the children of\n+         * {@code Link} codes.\n+         *\/\n+        private List<DCTree> trees;\n+\n+        \/**\n+         * The source text being accumulated, prior to being placed in a\n+         * Markdown source node ({@code RawTextTree} with kind {@code MARKDOWN}).\n+         *\/\n+        private final StringBuilder text;\n+\n+        \/**\n+         * The initial position in the enclosing comment of the source\n+         * being transformed.\n+         *\/\n+        private int mainStartPos;\n+\n+        \/**\n+         * The start of source text to be copied literally when required.\n+         *\/\n+        private int copyStartPos;\n+\n+        \/**\n+         * The current adjustment from positions in {@code source} to positions\n+         * in the original comment, as used in doc tree nodes.\n+         * The difference arises because of the use of U+FFFC characters for\n+         * embedded objects. As the document (and source) are scanned,\n+         * this offset is updated when U+FFFC characters are encountered.\n+         *\/\n+        private int replaceAdjustPos;\n+\n+        \/**\n+         * The pattern for a line break.\n+         * This is equivalent to the detection in the Markdown parser, so that\n+         * {@code (line, column)} coordinates can be accurately converted back\n+         * into source positions.\n+         *\n+         * @see jdk.internal.org.commonmark.internal.DocumentParser#parse(String)\n+         * @see jdk.internal.org.commonmark.internal.util.Parsing#findLineBreak(CharSequence, int)\n+         *\/\n+        private static final Pattern lineBreak = Pattern.compile(\"\\n|\\r\\n?\");\n+\n+        \/**\n+         * Creates an instance of the visitor, given a document,\n+         * the source text for the document and objects to be substituted\n+         * when U+FFFC characters are encountered.\n+         *\n+         * Note the document does not itself contain any source text:\n+         * it just contains {@code SourceSpan} objects that point into\n+         * the source text using line and column indices.\n+         *\n+         * @param document the document to be converted\n+         * @param source the source of the document to be converted\n+         * @param sourcePos the position in the enclosing comment of the source to be converted\n+         * @param replacements the objects to be substituted when U+FFFC is encountered\n+         * @param autorefScheme the scheme used for auto-generated references\n+         *\/\n+        public Lower(DocTreeMaker docTreeMaker,\n+                     Node document,\n+                     String source, int sourcePos,\n+                     List<?> replacements,\n+                     String autorefScheme) {\n+            this.m = docTreeMaker;\n+            this.document = document;\n+            this.source = source;\n+            this.autorefScheme = autorefScheme;\n+\n+            sourceLineOffsets = Stream.concat(\n+                            Stream.of(0),\n+                            lineBreak.matcher(source).results().map(MatchResult::end))\n+                    .mapToInt(Integer::intValue)\n+                    .toArray();\n+\n+            replaceIter = replacements.iterator();\n+\n+            trees = new ArrayList<>();\n+            text = new StringBuilder();\n+            mainStartPos = sourcePos;\n+            copyStartPos = 0;\n+            replaceAdjustPos = 0;\n+        }\n+\n+        \/**\n+         * {@return the trees that were built after using the visitor}\n+         *\/\n+        public List<DCTree> getTrees() {\n+            return trees;\n+        }\n+\n+        \/**\n+         * Visits a CommonMark {@code Link} node.\n+         *\n+         * If the destination for the link begins with the {@code autorefScheme}\n+         * convert it to {@code {@link ...}} or {@code {@linkplain ...}} DocTree node.\n+         * {@code {@link ...}} will be used if the content (label) for\n+         * the link is the same as the reference found after the {@code code:};\n+         * otherwise, {@code {@linkplain ...}} will be used.\n+         *\n+         * The label will be left blank for {@code {@link ...}} nodes,\n+         * implying that a default label should be used, based on the\n+         * program element that was referenced.\n+         *\n+         * @param link the link node\n+         *\/\n+        @Override\n+        public void visit(Link link) {\n+            String dest = link.getDestination();\n+            if (dest.startsWith(autorefScheme)) {\n+                \/\/ copy the source text up to the start of the node\n+                copyTo(getStartPos(link));\n+                \/\/ push temporary value for {@code trees} while handling the content of the node\n+                var saveTrees = trees;\n+                trees = new ArrayList<>();\n+                try {\n+                    copyStartPos = getStartPos(link.getFirstChild());\n+                    visitChildren(link);\n+                    copyTo(getEndPos(link.getLastChild()));\n+\n+                    \/\/ determine whether to use {@link ... } or {@linkplain ...}\n+                    \/\/ based on whether the \"link text\" is the same as the \"link destination\"\n+                    String ref = dest.substring(autorefScheme.length());\n+                    int refPos = sourcePosToTreePos(getRefPos(ref, link));\n+                    var newRefTree = m.at(refPos).newReferenceTree(ref).setEndPos(refPos + ref.length());\n+\n+                    Node child = link.getFirstChild();\n+                    DocTree.Kind linkKind = child.getNext() == null\n+                            && child instanceof Text t\n+                            && t.getLiteral().equals(ref) ? DocTree.Kind.LINK : DocTree.Kind.LINK_PLAIN;\n+\n+                    DCTree newLinkTree = linkKind == DocTree.Kind.LINK\n+                            ? m.at(NOPOS).newLinkTree(newRefTree, List.of()) \/\/ ignore the child trees\n+                            : m.at(NOPOS).newLinkPlainTree(newRefTree, trees);\n+\n+                    saveTrees.add(newLinkTree);\n+                } finally {\n+                    \/\/ start any subsequent copy after the end of the link node\n+                    copyStartPos = getEndPos(link);\n+                    trees = saveTrees;\n+                }\n+            } else {\n+                visitChildren(link);\n+            }\n+        }\n+\n+        \/**\n+         * {@return the position in the source for the reference in a link}\n+         * Many syntactic forms may yield a {@code Link} object, so scan the\n+         * source looking for a match. Since the reference typically comes\n+         * after any text (when they are different), scan the source backwards.\n+         *\n+         * @param ref the reference to find\n+         * @param link the link containing the reference\n+         *\/\n+        private int getRefPos(String ref, Link link) {\n+            var spans = link.getSourceSpans();\n+            var revSpanIter = spans.listIterator(spans.size());\n+            while (revSpanIter.hasPrevious()) {\n+                var span = revSpanIter.previous();\n+                var start = toSourcePos(span.getLineIndex(), span.getColumnIndex());\n+                var end = toSourcePos(span.getLineIndex(), span.getColumnIndex() + span.getLength());\n+                var s = source.substring(start, end);\n+                var index = s.lastIndexOf(ref);\n+                if (index != -1) {\n+                    return start + index;\n+                }\n+            }\n+            return NOPOS;\n+        }\n+\n+        \/**\n+         * {@return the position in the original comment for a position in {@code source},\n+         * using {@link #replaceAdjustPos}}\n+         *\n+         * @param pos the position in {@code source}\n+         *\/\n+        private int sourcePosToTreePos(int pos) {\n+            return pos == NOPOS ? NOPOS : mainStartPos + pos + replaceAdjustPos;\n+        }\n+\n+        \/**\n+         * Processes a node and any children.\n+         *\n+         * If the node has children, the children are each visited by\n+         * calling their {@code accept} method, and then finally, if this\n+         * is the top-level {@code document} node, any pending text is\n+         * flushed.\n+         *\n+         * If the node does not have children, the source spans for\n+         * the node are processed instead.\n+         *\n+         * Note that unlike the default implementation of {@code visitChildren},\n+         * the next child is not accessed until after the current child\n+         * has been visited.  This allows a child to peek at and possibly remove\n+         * any child nodes that may follow it.\n+         *\n+         * @param node the node whose children should be visited\n+         *\/\n+        @Override\n+        protected void visitChildren(Node node) {\n+            Node child = node.getFirstChild();\n+            if (child != null) {\n+                while (child != null) {\n+                    \/\/ defer getting the next child until after this node has\n+                    \/\/ been processed, in case any following nodes were handled\n+                    \/\/ by this node, and removed from the document\n+                    child.accept(this);\n+                    child = child.getNext();\n+                }\n+                if (node == document) {\n+                    \/\/ the top level document has no spans of its own, so use the last child\n+                    copyTo(getEndPos(document.getLastChild()));\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * {@return the start of this node, from the start of the first span}\n+         *\n+         * @param node the node\n+         *\/\n+        private int getStartPos(Node node) {\n+            var spans = node.getSourceSpans();\n+            var firstSpan = spans.getFirst();\n+            return toSourcePos(firstSpan.getLineIndex(), firstSpan.getColumnIndex());\n+        }\n+\n+        \/**\n+         * {@return the end of this node, from the end of the last span}\n+         * The end points to the first character not included in the span.\n+         *\n+         * @param node the node\n+         *\/\n+        private int getEndPos(Node node) {\n+            var spans = node.getSourceSpans();\n+            var lastSpan = spans.getLast();\n+            return toSourcePos(lastSpan.getLineIndex(), lastSpan.getColumnIndex() + lastSpan.getLength());\n+        }\n+\n+        \/**\n+         * {@return the position in the {@code source} string for a given {@code (line, column}}\n+         *\n+         * @param lineIndex the line index\n+         * @param columnIndex the column index\n+         *\/\n+        private int toSourcePos(int lineIndex, int columnIndex) {\n+            return sourceLineOffsets[lineIndex] + columnIndex;\n+        }\n+\n+        \/**\n+         * Copies source text from the saved copy-start position to the given end position\n+         * using the saved {@code source}, to the list of {@code trees}.\n+         *\n+         * @param endPos the end position\n+         *\/\n+        private void copyTo(int endPos) {\n+            int startPos = copyStartPos;\n+            int rawTextStartPos = copyStartPos;\n+            int pos;\n+            while ((pos = source.indexOf(PLACEHOLDER, startPos)) != -1 && pos < endPos) {\n+                text.append(source, startPos, pos);\n+                assert replaceIter.hasNext();\n+                Object r = replaceIter.next();\n+                if (r instanceof DCTree t) {\n+                    flushText(rawTextStartPos);\n+                    trees.add(t);\n+                    replaceAdjustPos += t.getEndPosition() - t.getStartPosition() - 1;\n+                    rawTextStartPos = pos + 1;\n+                } else if (r.equals(PLACEHOLDER)) {\n+                    text.append(PLACEHOLDER);\n+                } else {\n+                    throw new IllegalStateException(r.getClass().toString());\n+                }\n+                startPos = pos + 1;\n+            }\n+            if (startPos < endPos) {\n+                text.append(source, startPos, endPos);\n+            }\n+            flushText(rawTextStartPos);\n+        }\n+\n+        \/**\n+         * Flushes any text in the {@code text} buffer, by creating a new\n+         * Markdown source text node and adding it to the list of trees.\n+         *\/\n+        private void flushText(int pos) {\n+            if (!text.isEmpty()) {\n+                trees.add(m.at(sourcePosToTreePos(pos)).newRawTextTree(DocTree.Kind.MARKDOWN, text.toString()));\n+                text.setLength(0);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/markdown\/MarkdownTransformer.java","additions":976,"deletions":0,"binary":false,"changes":976,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark;\n+\n+\/**\n+ * Base interface for a parser\/renderer extension.\n+ * <p>\n+ * Doesn't have any methods itself, but has specific sub interfaces to\n+ * configure parser\/renderer. This base interface is for convenience, so that a list of extensions can be built and then\n+ * used for configuring both the parser and renderer in the same way.\n+ *\/\n+public interface Extension {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/Extension.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomBlock;\n+\n+\/**\n+ * Table block containing a {@link TableHead} and optionally a {@link TableBody}.\n+ *\/\n+public class TableBlock extends CustomBlock {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableBlock.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Body part of a {@link TableBlock} containing {@link TableRow TableRows}.\n+ *\/\n+public class TableBody extends CustomNode {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableBody.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Table cell of a {@link TableRow} containing inline nodes.\n+ *\/\n+public class TableCell extends CustomNode {\n+\n+    private boolean header;\n+    private Alignment alignment;\n+    private int width;\n+\n+    \/**\n+     * @return whether the cell is a header or not\n+     *\/\n+    public boolean isHeader() {\n+        return header;\n+    }\n+\n+    public void setHeader(boolean header) {\n+        this.header = header;\n+    }\n+\n+    \/**\n+     * @return the cell alignment or {@code null} if no specific alignment\n+     *\/\n+    public Alignment getAlignment() {\n+        return alignment;\n+    }\n+\n+    public void setAlignment(Alignment alignment) {\n+        this.alignment = alignment;\n+    }\n+\n+    \/**\n+     * @return the cell width (the number of dash and colon characters in the delimiter row of the table for this column)\n+     *\/\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public void setWidth(int width) {\n+        this.width = width;\n+    }\n+\n+    \/**\n+     * How the cell is aligned horizontally.\n+     *\/\n+    public enum Alignment {\n+        LEFT, CENTER, RIGHT\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableCell.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Head part of a {@link TableBlock} containing {@link TableRow TableRows}.\n+ *\/\n+public class TableHead extends CustomNode {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableHead.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.node.CustomNode;\n+\n+\/**\n+ * Table row of a {@link TableHead} or {@link TableBody} containing {@link TableCell TableCells}.\n+ *\/\n+public class TableRow extends CustomNode {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TableRow.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableBlockParser;\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableHtmlNodeRenderer;\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableMarkdownNodeRenderer;\n+import jdk.internal.org.commonmark.ext.gfm.tables.internal.TableTextContentNodeRenderer;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.html.HtmlRenderer;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownRenderer;\n+import jdk.internal.org.commonmark.renderer.text.TextContentNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.text.TextContentNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.text.TextContentRenderer;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+\/**\n+ * Extension for GFM tables using \"|\" pipes (GitHub Flavored Markdown).\n+ * <p>\n+ * Create it with {@link #create()} and then configure it on the builders\n+ * ({@link org.commonmark.parser.Parser.Builder#extensions(Iterable)},\n+ * {@link HtmlRenderer.Builder#extensions(Iterable)}).\n+ * <\/p>\n+ * <p>\n+ * The parsed tables are turned into {@link TableBlock} blocks.\n+ * <\/p>\n+ *\n+ * @see <a href=\"https:\/\/github.github.com\/gfm\/#tables-extension-\">Tables (extension) in GitHub Flavored Markdown Spec<\/a>\n+ *\/\n+public class TablesExtension implements Parser.ParserExtension, HtmlRenderer.HtmlRendererExtension,\n+        TextContentRenderer.TextContentRendererExtension, MarkdownRenderer.MarkdownRendererExtension {\n+\n+    private TablesExtension() {\n+    }\n+\n+    public static Extension create() {\n+        return new TablesExtension();\n+    }\n+\n+    @Override\n+    public void extend(Parser.Builder parserBuilder) {\n+        parserBuilder.customBlockParserFactory(new TableBlockParser.Factory());\n+    }\n+\n+    @Override\n+    public void extend(HtmlRenderer.Builder rendererBuilder) {\n+        rendererBuilder.nodeRendererFactory(new HtmlNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(HtmlNodeRendererContext context) {\n+                return new TableHtmlNodeRenderer(context);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void extend(TextContentRenderer.Builder rendererBuilder) {\n+        rendererBuilder.nodeRendererFactory(new TextContentNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(TextContentNodeRendererContext context) {\n+                return new TableTextContentNodeRenderer(context);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void extend(MarkdownRenderer.Builder rendererBuilder) {\n+        rendererBuilder.nodeRendererFactory(new MarkdownNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(MarkdownNodeRendererContext context) {\n+                return new TableMarkdownNodeRenderer(context);\n+            }\n+\n+            @Override\n+            public Set<Character> getSpecialCharacters() {\n+                return Collections.singleton('|');\n+            }\n+        });\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/TablesExtension.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.*;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.block.*;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TableBlockParser extends AbstractBlockParser {\n+\n+    private final TableBlock block = new TableBlock();\n+    private final List<SourceLine> rowLines = new ArrayList<>();\n+    private final List<TableCellInfo> columns;\n+\n+    private boolean canHaveLazyContinuationLines = true;\n+\n+    private TableBlockParser(List<TableCellInfo> columns, SourceLine headerLine) {\n+        this.columns = columns;\n+        this.rowLines.add(headerLine);\n+    }\n+\n+    @Override\n+    public boolean canHaveLazyContinuationLines() {\n+        return canHaveLazyContinuationLines;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        CharSequence content = state.getLine().getContent();\n+        int pipe = Characters.find('|', content, state.getNextNonSpaceIndex());\n+        if (pipe != -1) {\n+            if (pipe == state.getNextNonSpaceIndex()) {\n+                \/\/ If we *only* have a pipe character (and whitespace), that is not a valid table row and ends the table.\n+                if (Characters.skipSpaceTab(content, pipe + 1, content.length()) == content.length()) {\n+                    \/\/ We also don't want the pipe to be added via lazy continuation.\n+                    canHaveLazyContinuationLines = false;\n+                    return BlockContinue.none();\n+                }\n+            }\n+            return BlockContinue.atIndex(state.getIndex());\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        rowLines.add(line);\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+        List<SourceSpan> sourceSpans = block.getSourceSpans();\n+\n+        SourceSpan headerSourceSpan = !sourceSpans.isEmpty() ? sourceSpans.get(0) : null;\n+        Node head = new TableHead();\n+        if (headerSourceSpan != null) {\n+            head.addSourceSpan(headerSourceSpan);\n+        }\n+        block.appendChild(head);\n+\n+        TableRow headerRow = new TableRow();\n+        headerRow.setSourceSpans(head.getSourceSpans());\n+        head.appendChild(headerRow);\n+\n+        List<SourceLine> headerCells = split(rowLines.get(0));\n+        int headerColumns = headerCells.size();\n+        for (int i = 0; i < headerColumns; i++) {\n+            SourceLine cell = headerCells.get(i);\n+            TableCell tableCell = parseCell(cell, i, inlineParser);\n+            tableCell.setHeader(true);\n+            headerRow.appendChild(tableCell);\n+        }\n+\n+        TableBody body = null;\n+        \/\/ Body starts at index 2. 0 is header, 1 is separator.\n+        for (int rowIndex = 2; rowIndex < rowLines.size(); rowIndex++) {\n+            SourceLine rowLine = rowLines.get(rowIndex);\n+            SourceSpan sourceSpan = rowIndex < sourceSpans.size() ? sourceSpans.get(rowIndex) : null;\n+            List<SourceLine> cells = split(rowLine);\n+            TableRow row = new TableRow();\n+            if (sourceSpan != null) {\n+                row.addSourceSpan(sourceSpan);\n+            }\n+\n+            \/\/ Body can not have more columns than head\n+            for (int i = 0; i < headerColumns; i++) {\n+                SourceLine cell = i < cells.size() ? cells.get(i) : SourceLine.of(\"\", null);\n+                TableCell tableCell = parseCell(cell, i, inlineParser);\n+                row.appendChild(tableCell);\n+            }\n+\n+            if (body == null) {\n+                \/\/ It's valid to have a table without body. In that case, don't add an empty TableBody node.\n+                body = new TableBody();\n+                block.appendChild(body);\n+            }\n+            body.appendChild(row);\n+            body.addSourceSpan(sourceSpan);\n+        }\n+    }\n+\n+    private TableCell parseCell(SourceLine cell, int column, InlineParser inlineParser) {\n+        TableCell tableCell = new TableCell();\n+        SourceSpan sourceSpan = cell.getSourceSpan();\n+        if (sourceSpan != null) {\n+            tableCell.addSourceSpan(sourceSpan);\n+        }\n+\n+        if (column < columns.size()) {\n+            TableCellInfo cellInfo = columns.get(column);\n+            tableCell.setAlignment(cellInfo.getAlignment());\n+            tableCell.setWidth(cellInfo.getWidth());\n+        }\n+\n+        CharSequence content = cell.getContent();\n+        int start = Characters.skipSpaceTab(content, 0, content.length());\n+        int end = Characters.skipSpaceTabBackwards(content, content.length() - 1, start);\n+        inlineParser.parse(SourceLines.of(cell.substring(start, end + 1)), tableCell);\n+\n+        return tableCell;\n+    }\n+\n+    private static List<SourceLine> split(SourceLine line) {\n+        CharSequence row = line.getContent();\n+        int nonSpace = Characters.skipSpaceTab(row, 0, row.length());\n+        int cellStart = nonSpace;\n+        int cellEnd = row.length();\n+        if (row.charAt(nonSpace) == '|') {\n+            \/\/ This row has leading\/trailing pipes - skip the leading pipe\n+            cellStart = nonSpace + 1;\n+            \/\/ Strip whitespace from the end but not the pipe or we could miss an empty (\"||\") cell\n+            int nonSpaceEnd = Characters.skipSpaceTabBackwards(row, row.length() - 1, cellStart);\n+            cellEnd = nonSpaceEnd + 1;\n+        }\n+        List<SourceLine> cells = new ArrayList<>();\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = cellStart; i < cellEnd; i++) {\n+            char c = row.charAt(i);\n+            switch (c) {\n+                case '\\\\':\n+                    if (i + 1 < cellEnd && row.charAt(i + 1) == '|') {\n+                        \/\/ Pipe is special for table parsing. An escaped pipe doesn't result in a new cell, but is\n+                        \/\/ passed down to inline parsing as an unescaped pipe. Note that that applies even for the `\\|`\n+                        \/\/ in an input like `\\\\|` - in other words, table parsing doesn't support escaping backslashes.\n+                        sb.append('|');\n+                        i++;\n+                    } else {\n+                        \/\/ Preserve backslash before other characters or at end of line.\n+                        sb.append('\\\\');\n+                    }\n+                    break;\n+                case '|':\n+                    String content = sb.toString();\n+\n+                    cells.add(SourceLine.of(content, line.substring(cellStart, i).getSourceSpan()));\n+                    sb.setLength(0);\n+                    \/\/ + 1 to skip the pipe itself for the next cell's span\n+                    cellStart = i + 1;\n+                    break;\n+                default:\n+                    sb.append(c);\n+            }\n+        }\n+        if (sb.length() > 0) {\n+            String content = sb.toString();\n+            cells.add(SourceLine.of(content, line.substring(cellStart, line.getContent().length()).getSourceSpan()));\n+        }\n+        return cells;\n+    }\n+\n+    \/\/ Examples of valid separators:\n+    \/\/\n+    \/\/ |-\n+    \/\/ -|\n+    \/\/ |-|\n+    \/\/ -|-\n+    \/\/ |-|-|\n+    \/\/ --- | ---\n+    private static List<TableCellInfo> parseSeparator(CharSequence s) {\n+        List<TableCellInfo> columns = new ArrayList<>();\n+        int pipes = 0;\n+        boolean valid = false;\n+        int i = 0;\n+        int width = 0;\n+        while (i < s.length()) {\n+            char c = s.charAt(i);\n+            switch (c) {\n+                case '|':\n+                    i++;\n+                    pipes++;\n+                    if (pipes > 1) {\n+                        \/\/ More than one adjacent pipe not allowed\n+                        return null;\n+                    }\n+                    \/\/ Need at lest one pipe, even for a one column table\n+                    valid = true;\n+                    break;\n+                case '-':\n+                case ':':\n+                    if (pipes == 0 && !columns.isEmpty()) {\n+                        \/\/ Need a pipe after the first column (first column doesn't need to start with one)\n+                        return null;\n+                    }\n+                    boolean left = false;\n+                    boolean right = false;\n+                    if (c == ':') {\n+                        left = true;\n+                        i++;\n+                        width++;\n+                    }\n+                    boolean haveDash = false;\n+                    while (i < s.length() && s.charAt(i) == '-') {\n+                        i++;\n+                        width++;\n+                        haveDash = true;\n+                    }\n+                    if (!haveDash) {\n+                        \/\/ Need at least one dash\n+                        return null;\n+                    }\n+                    if (i < s.length() && s.charAt(i) == ':') {\n+                        right = true;\n+                        i++;\n+                        width++;\n+                    }\n+                    columns.add(new TableCellInfo(getAlignment(left, right), width));\n+                    width = 0;\n+                    \/\/ Next, need another pipe\n+                    pipes = 0;\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                    \/\/ White space is allowed between pipes and columns\n+                    i++;\n+                    break;\n+                default:\n+                    \/\/ Any other character is invalid\n+                    return null;\n+            }\n+        }\n+        if (!valid) {\n+            return null;\n+        }\n+        return columns;\n+    }\n+\n+    private static TableCell.Alignment getAlignment(boolean left, boolean right) {\n+        if (left && right) {\n+            return TableCell.Alignment.CENTER;\n+        } else if (left) {\n+            return TableCell.Alignment.LEFT;\n+        } else if (right) {\n+            return TableCell.Alignment.RIGHT;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            List<SourceLine> paragraphLines = matchedBlockParser.getParagraphLines().getLines();\n+            if (paragraphLines.size() == 1 && Characters.find('|', paragraphLines.get(0).getContent(), 0) != -1) {\n+                SourceLine line = state.getLine();\n+                SourceLine separatorLine = line.substring(state.getIndex(), line.getContent().length());\n+                List<TableCellInfo> columns = parseSeparator(separatorLine.getContent());\n+                if (columns != null && !columns.isEmpty()) {\n+                    SourceLine paragraph = paragraphLines.get(0);\n+                    List<SourceLine> headerCells = split(paragraph);\n+                    if (columns.size() >= headerCells.size()) {\n+                        return BlockStart.of(new TableBlockParser(columns, paragraph))\n+                                .atIndex(state.getIndex())\n+                                .replaceActiveBlockParser();\n+                    }\n+                }\n+            }\n+            return BlockStart.none();\n+        }\n+    }\n+\n+    private static class TableCellInfo {\n+        private final TableCell.Alignment alignment;\n+        private final int width;\n+\n+        public TableCell.Alignment getAlignment() {\n+            return alignment;\n+        }\n+\n+        public int getWidth() {\n+            return width;\n+        }\n+\n+        public TableCellInfo(TableCell.Alignment alignment, int width) {\n+            this.alignment = alignment;\n+            this.width = width;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableBlockParser.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.*;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.html.HtmlWriter;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public class TableHtmlNodeRenderer extends TableNodeRenderer {\n+\n+    private final HtmlWriter htmlWriter;\n+    private final HtmlNodeRendererContext context;\n+\n+    public TableHtmlNodeRenderer(HtmlNodeRendererContext context) {\n+        this.htmlWriter = context.getWriter();\n+        this.context = context;\n+    }\n+\n+    protected void renderBlock(TableBlock tableBlock) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"table\", getAttributes(tableBlock, \"table\"));\n+        renderChildren(tableBlock);\n+        htmlWriter.tag(\"\/table\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderHead(TableHead tableHead) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"thead\", getAttributes(tableHead, \"thead\"));\n+        renderChildren(tableHead);\n+        htmlWriter.tag(\"\/thead\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderBody(TableBody tableBody) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"tbody\", getAttributes(tableBody, \"tbody\"));\n+        renderChildren(tableBody);\n+        htmlWriter.tag(\"\/tbody\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderRow(TableRow tableRow) {\n+        htmlWriter.line();\n+        htmlWriter.tag(\"tr\", getAttributes(tableRow, \"tr\"));\n+        renderChildren(tableRow);\n+        htmlWriter.tag(\"\/tr\");\n+        htmlWriter.line();\n+    }\n+\n+    protected void renderCell(TableCell tableCell) {\n+        String tagName = tableCell.isHeader() ? \"th\" : \"td\";\n+        htmlWriter.line();\n+        htmlWriter.tag(tagName, getCellAttributes(tableCell, tagName));\n+        renderChildren(tableCell);\n+        htmlWriter.tag(\"\/\" + tagName);\n+        htmlWriter.line();\n+    }\n+\n+    private Map<String, String> getAttributes(Node node, String tagName) {\n+        return context.extendAttributes(node, tagName, Collections.<String, String>emptyMap());\n+    }\n+\n+    private Map<String, String> getCellAttributes(TableCell tableCell, String tagName) {\n+        if (tableCell.getAlignment() != null) {\n+            return context.extendAttributes(tableCell, tagName, Collections.singletonMap(\"align\", getAlignValue(tableCell.getAlignment())));\n+        } else {\n+            return context.extendAttributes(tableCell, tagName, Collections.<String, String>emptyMap());\n+        }\n+    }\n+\n+    private static String getAlignValue(TableCell.Alignment alignment) {\n+        switch (alignment) {\n+            case LEFT:\n+                return \"left\";\n+            case CENTER:\n+                return \"center\";\n+            case RIGHT:\n+                return \"right\";\n+        }\n+        throw new IllegalStateException(\"Unknown alignment: \" + alignment);\n+    }\n+\n+    private void renderChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableHtmlNodeRenderer.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.*;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.markdown.MarkdownWriter;\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The Table node renderer that is needed for rendering GFM tables (GitHub Flavored Markdown) to text content.\n+ *\/\n+public class TableMarkdownNodeRenderer extends TableNodeRenderer implements NodeRenderer {\n+    private final MarkdownWriter writer;\n+    private final MarkdownNodeRendererContext context;\n+\n+    private final AsciiMatcher pipe = AsciiMatcher.builder().c('|').build();\n+\n+    private final List<TableCell.Alignment> columns = new ArrayList<>();\n+\n+    public TableMarkdownNodeRenderer(MarkdownNodeRendererContext context) {\n+        this.writer = context.getWriter();\n+        this.context = context;\n+    }\n+\n+    @Override\n+    protected void renderBlock(TableBlock node) {\n+        columns.clear();\n+        writer.pushTight(true);\n+        renderChildren(node);\n+        writer.popTight();\n+        writer.block();\n+    }\n+\n+    @Override\n+    protected void renderHead(TableHead node) {\n+        renderChildren(node);\n+        for (TableCell.Alignment columnAlignment : columns) {\n+            writer.raw('|');\n+            if (columnAlignment == TableCell.Alignment.LEFT) {\n+                writer.raw(\":---\");\n+            } else if (columnAlignment == TableCell.Alignment.RIGHT) {\n+                writer.raw(\"---:\");\n+            } else if (columnAlignment == TableCell.Alignment.CENTER) {\n+                writer.raw(\":---:\");\n+            } else {\n+                writer.raw(\"---\");\n+            }\n+        }\n+        writer.raw(\"|\");\n+        writer.block();\n+    }\n+\n+    @Override\n+    protected void renderBody(TableBody node) {\n+        renderChildren(node);\n+    }\n+\n+    @Override\n+    protected void renderRow(TableRow node) {\n+        renderChildren(node);\n+        \/\/ Trailing | at the end of the line\n+        writer.raw(\"|\");\n+        writer.block();\n+    }\n+\n+    @Override\n+    protected void renderCell(TableCell node) {\n+        if (node.getParent() != null && node.getParent().getParent() instanceof TableHead) {\n+            columns.add(node.getAlignment());\n+        }\n+        writer.raw(\"|\");\n+        writer.pushRawEscape(pipe);\n+        renderChildren(node);\n+        writer.popRawEscape();\n+    }\n+\n+    private void renderChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableMarkdownNodeRenderer.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBlock;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBody;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableCell;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableHead;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableRow;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+abstract class TableNodeRenderer implements NodeRenderer {\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                TableBlock.class,\n+                TableHead.class,\n+                TableBody.class,\n+                TableRow.class,\n+                TableCell.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        if (node instanceof TableBlock) {\n+            renderBlock((TableBlock) node);\n+        } else if (node instanceof TableHead) {\n+            renderHead((TableHead) node);\n+        } else if (node instanceof TableBody) {\n+            renderBody((TableBody) node);\n+        } else if (node instanceof TableRow) {\n+            renderRow((TableRow) node);\n+        } else if (node instanceof TableCell) {\n+            renderCell((TableCell) node);\n+        }\n+    }\n+\n+    protected abstract void renderBlock(TableBlock node);\n+\n+    protected abstract void renderHead(TableHead node);\n+\n+    protected abstract void renderBody(TableBody node);\n+\n+    protected abstract void renderRow(TableRow node);\n+\n+    protected abstract void renderCell(TableCell node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableNodeRenderer.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.ext.gfm.tables.internal;\n+\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBlock;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableBody;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableCell;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableHead;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TableRow;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.text.TextContentNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.text.TextContentWriter;\n+\n+\/**\n+ * The Table node renderer that is needed for rendering GFM tables (GitHub Flavored Markdown) to text content.\n+ *\/\n+public class TableTextContentNodeRenderer extends TableNodeRenderer {\n+\n+    private final TextContentWriter textContentWriter;\n+    private final TextContentNodeRendererContext context;\n+\n+    public TableTextContentNodeRenderer(TextContentNodeRendererContext context) {\n+        this.textContentWriter = context.getWriter();\n+        this.context = context;\n+    }\n+\n+    protected void renderBlock(TableBlock tableBlock) {\n+        renderChildren(tableBlock);\n+        if (tableBlock.getNext() != null) {\n+            textContentWriter.write(\"\\n\");\n+        }\n+    }\n+\n+    protected void renderHead(TableHead tableHead) {\n+        renderChildren(tableHead);\n+    }\n+\n+    protected void renderBody(TableBody tableBody) {\n+        renderChildren(tableBody);\n+    }\n+\n+    protected void renderRow(TableRow tableRow) {\n+        textContentWriter.line();\n+        renderChildren(tableRow);\n+        textContentWriter.line();\n+    }\n+\n+    protected void renderCell(TableCell tableCell) {\n+        renderChildren(tableCell);\n+        textContentWriter.write('|');\n+        textContentWriter.whitespace();\n+    }\n+\n+    private void renderLastCell(TableCell tableCell) {\n+        renderChildren(tableCell);\n+    }\n+\n+    private void renderChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+\n+            \/\/ For last cell in row, we dont render the delimiter.\n+            if (node instanceof TableCell && next == null) {\n+                renderLastCell((TableCell) node);\n+            } else {\n+                context.render(node);\n+            }\n+\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/ext\/gfm\/tables\/internal\/TableTextContentNodeRenderer.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+class BlockContent {\n+\n+    private final StringBuilder sb;\n+\n+    private int lineCount = 0;\n+\n+    public BlockContent() {\n+        sb = new StringBuilder();\n+    }\n+\n+    public BlockContent(String content) {\n+        sb = new StringBuilder(content);\n+    }\n+\n+    public void add(CharSequence line) {\n+        if (lineCount != 0) {\n+            sb.append('\\n');\n+        }\n+        sb.append(line);\n+        lineCount++;\n+    }\n+\n+    public String getString() {\n+        return sb.toString();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockContent.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+\n+public class BlockContinueImpl extends BlockContinue {\n+\n+    private final int newIndex;\n+    private final int newColumn;\n+    private final boolean finalize;\n+\n+    public BlockContinueImpl(int newIndex, int newColumn, boolean finalize) {\n+        this.newIndex = newIndex;\n+        this.newColumn = newColumn;\n+        this.finalize = finalize;\n+    }\n+\n+    public int getNewIndex() {\n+        return newIndex;\n+    }\n+\n+    public int getNewColumn() {\n+        return newColumn;\n+    }\n+\n+    public boolean isFinalize() {\n+        return finalize;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockContinueImpl.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.BlockQuote;\n+import jdk.internal.org.commonmark.parser.block.*;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+public class BlockQuoteParser extends AbstractBlockParser {\n+\n+    private final BlockQuote block = new BlockQuote();\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block block) {\n+        return true;\n+    }\n+\n+    @Override\n+    public BlockQuote getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        int nextNonSpace = state.getNextNonSpaceIndex();\n+        if (isMarker(state, nextNonSpace)) {\n+            int newColumn = state.getColumn() + state.getIndent() + 1;\n+            \/\/ optional following space or tab\n+            if (Characters.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n+                newColumn++;\n+            }\n+            return BlockContinue.atColumn(newColumn);\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    private static boolean isMarker(ParserState state, int index) {\n+        CharSequence line = state.getLine().getContent();\n+        return state.getIndent() < Parsing.CODE_BLOCK_INDENT && index < line.length() && line.charAt(index) == '>';\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            if (isMarker(state, nextNonSpace)) {\n+                int newColumn = state.getColumn() + state.getIndent() + 1;\n+                \/\/ optional following space or tab\n+                if (Characters.isSpaceOrTab(state.getLine().getContent(), nextNonSpace + 1)) {\n+                    newColumn++;\n+                }\n+                return BlockStart.of(new BlockQuoteParser()).atColumn(newColumn);\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockQuoteParser.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.parser.block.BlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockStart;\n+\n+public class BlockStartImpl extends BlockStart {\n+\n+    private final BlockParser[] blockParsers;\n+    private int newIndex = -1;\n+    private int newColumn = -1;\n+    private boolean replaceActiveBlockParser = false;\n+\n+    public BlockStartImpl(BlockParser... blockParsers) {\n+        this.blockParsers = blockParsers;\n+    }\n+\n+    public BlockParser[] getBlockParsers() {\n+        return blockParsers;\n+    }\n+\n+    public int getNewIndex() {\n+        return newIndex;\n+    }\n+\n+    public int getNewColumn() {\n+        return newColumn;\n+    }\n+\n+    public boolean isReplaceActiveBlockParser() {\n+        return replaceActiveBlockParser;\n+    }\n+\n+    @Override\n+    public BlockStart atIndex(int newIndex) {\n+        this.newIndex = newIndex;\n+        return this;\n+    }\n+\n+    @Override\n+    public BlockStart atColumn(int newColumn) {\n+        this.newColumn = newColumn;\n+        return this;\n+    }\n+\n+    @Override\n+    public BlockStart replaceActiveBlockParser() {\n+        this.replaceActiveBlockParser = true;\n+        return this;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/BlockStartImpl.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+\n+\/**\n+ * Opening bracket for links (<code>[<\/code>) or images (<code>![<\/code>).\n+ *\/\n+public class Bracket {\n+\n+    public final Text node;\n+\n+    \/**\n+     * The position of the marker for the bracket (<code>[<\/code> or <code>![<\/code>)\n+     *\/\n+    public final Position markerPosition;\n+\n+    \/**\n+     * The position of the content (after the opening bracket)\n+     *\/\n+    public final Position contentPosition;\n+\n+    \/**\n+     * Whether this is an image or link.\n+     *\/\n+    public final boolean image;\n+\n+    \/**\n+     * Previous bracket.\n+     *\/\n+    public final Bracket previous;\n+\n+    \/**\n+     * Previous delimiter (emphasis, etc) before this bracket.\n+     *\/\n+    public final Delimiter previousDelimiter;\n+\n+    \/**\n+     * Whether this bracket is allowed to form a link\/image (also known as \"active\").\n+     *\/\n+    public boolean allowed = true;\n+\n+    \/**\n+     * Whether there is an unescaped bracket (opening or closing) anywhere after this opening bracket.\n+     *\/\n+    public boolean bracketAfter = false;\n+\n+    static public Bracket link(Text node, Position markerPosition, Position contentPosition, Bracket previous, Delimiter previousDelimiter) {\n+        return new Bracket(node, markerPosition, contentPosition, previous, previousDelimiter, false);\n+    }\n+\n+    static public Bracket image(Text node, Position markerPosition, Position contentPosition, Bracket previous, Delimiter previousDelimiter) {\n+        return new Bracket(node, markerPosition, contentPosition, previous, previousDelimiter, true);\n+    }\n+\n+    private Bracket(Text node, Position markerPosition, Position contentPosition, Bracket previous, Delimiter previousDelimiter, boolean image) {\n+        this.node = node;\n+        this.markerPosition = markerPosition;\n+        this.contentPosition = contentPosition;\n+        this.image = image;\n+        this.previous = previous;\n+        this.previousDelimiter = previousDelimiter;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/Bracket.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterRun;\n+\n+import java.util.List;\n+\n+\/**\n+ * Delimiter (emphasis, strong emphasis or custom emphasis).\n+ *\/\n+public class Delimiter implements DelimiterRun {\n+\n+    public final List<Text> characters;\n+    public final char delimiterChar;\n+    private final int originalLength;\n+\n+    \/\/ Can open emphasis, see spec.\n+    private final boolean canOpen;\n+\n+    \/\/ Can close emphasis, see spec.\n+    private final boolean canClose;\n+\n+    public Delimiter previous;\n+    public Delimiter next;\n+\n+    public Delimiter(List<Text> characters, char delimiterChar, boolean canOpen, boolean canClose, Delimiter previous) {\n+        this.characters = characters;\n+        this.delimiterChar = delimiterChar;\n+        this.canOpen = canOpen;\n+        this.canClose = canClose;\n+        this.previous = previous;\n+        this.originalLength = characters.size();\n+    }\n+\n+    @Override\n+    public boolean canOpen() {\n+        return canOpen;\n+    }\n+\n+    @Override\n+    public boolean canClose() {\n+        return canClose;\n+    }\n+\n+    @Override\n+    public int length() {\n+        return characters.size();\n+    }\n+\n+    @Override\n+    public int originalLength() {\n+        return originalLength;\n+    }\n+\n+    @Override\n+    public Text getOpener() {\n+        return characters.get(characters.size() - 1);\n+    }\n+\n+    @Override\n+    public Text getCloser() {\n+        return characters.get(0);\n+    }\n+\n+    @Override\n+    public Iterable<Text> getOpeners(int length) {\n+        if (!(length >= 1 && length <= length())) {\n+            throw new IllegalArgumentException(\"length must be between 1 and \" + length() + \", was \" + length);\n+        }\n+\n+        return characters.subList(characters.size() - length, characters.size());\n+    }\n+\n+    @Override\n+    public Iterable<Text> getClosers(int length) {\n+        if (!(length >= 1 && length <= length())) {\n+            throw new IllegalArgumentException(\"length must be between 1 and \" + length() + \", was \" + length);\n+        }\n+\n+        return characters.subList(0, length);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/Delimiter.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.Document;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.AbstractBlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+import jdk.internal.org.commonmark.parser.block.ParserState;\n+\n+public class DocumentBlockParser extends AbstractBlockParser {\n+\n+    private final Document document = new Document();\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block block) {\n+        return true;\n+    }\n+\n+    @Override\n+    public Document getBlock() {\n+        return document;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        return BlockContinue.atIndex(state.getIndex());\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/DocumentBlockParser.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,639 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.*;\n+import jdk.internal.org.commonmark.parser.block.*;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.*;\n+\n+public class DocumentParser implements ParserState {\n+\n+    private static final Set<Class<? extends Block>> CORE_FACTORY_TYPES = new LinkedHashSet<>(Arrays.asList(\n+            BlockQuote.class,\n+            Heading.class,\n+            FencedCodeBlock.class,\n+            HtmlBlock.class,\n+            ThematicBreak.class,\n+            ListBlock.class,\n+            IndentedCodeBlock.class));\n+\n+    private static final Map<Class<? extends Block>, BlockParserFactory> NODES_TO_CORE_FACTORIES;\n+\n+    static {\n+        Map<Class<? extends Block>, BlockParserFactory> map = new HashMap<>();\n+        map.put(BlockQuote.class, new BlockQuoteParser.Factory());\n+        map.put(Heading.class, new HeadingParser.Factory());\n+        map.put(FencedCodeBlock.class, new FencedCodeBlockParser.Factory());\n+        map.put(HtmlBlock.class, new HtmlBlockParser.Factory());\n+        map.put(ThematicBreak.class, new ThematicBreakParser.Factory());\n+        map.put(ListBlock.class, new ListBlockParser.Factory());\n+        map.put(IndentedCodeBlock.class, new IndentedCodeBlockParser.Factory());\n+        NODES_TO_CORE_FACTORIES = Collections.unmodifiableMap(map);\n+    }\n+\n+    private SourceLine line;\n+\n+    \/**\n+     * Line index (0-based)\n+     *\/\n+    private int lineIndex = -1;\n+\n+    \/**\n+     * current index (offset) in input line (0-based)\n+     *\/\n+    private int index = 0;\n+\n+    \/**\n+     * current column of input line (tab causes column to go to next 4-space tab stop) (0-based)\n+     *\/\n+    private int column = 0;\n+\n+    \/**\n+     * if the current column is within a tab character (partially consumed tab)\n+     *\/\n+    private boolean columnIsInTab;\n+\n+    private int nextNonSpace = 0;\n+    private int nextNonSpaceColumn = 0;\n+    private int indent = 0;\n+    private boolean blank;\n+\n+    private final List<BlockParserFactory> blockParserFactories;\n+    private final InlineParserFactory inlineParserFactory;\n+    private final List<DelimiterProcessor> delimiterProcessors;\n+    private final IncludeSourceSpans includeSourceSpans;\n+    private final DocumentBlockParser documentBlockParser;\n+    private final LinkReferenceDefinitions definitions = new LinkReferenceDefinitions();\n+\n+    private final List<OpenBlockParser> openBlockParsers = new ArrayList<>();\n+    private final List<BlockParser> allBlockParsers = new ArrayList<>();\n+\n+    public DocumentParser(List<BlockParserFactory> blockParserFactories, InlineParserFactory inlineParserFactory,\n+                          List<DelimiterProcessor> delimiterProcessors, IncludeSourceSpans includeSourceSpans) {\n+        this.blockParserFactories = blockParserFactories;\n+        this.inlineParserFactory = inlineParserFactory;\n+        this.delimiterProcessors = delimiterProcessors;\n+        this.includeSourceSpans = includeSourceSpans;\n+\n+        this.documentBlockParser = new DocumentBlockParser();\n+        activateBlockParser(new OpenBlockParser(documentBlockParser, 0));\n+    }\n+\n+    public static Set<Class<? extends Block>> getDefaultBlockParserTypes() {\n+        return CORE_FACTORY_TYPES;\n+    }\n+\n+    public static List<BlockParserFactory> calculateBlockParserFactories(List<BlockParserFactory> customBlockParserFactories, Set<Class<? extends Block>> enabledBlockTypes) {\n+        List<BlockParserFactory> list = new ArrayList<>();\n+        \/\/ By having the custom factories come first, extensions are able to change behavior of core syntax.\n+        list.addAll(customBlockParserFactories);\n+        for (Class<? extends Block> blockType : enabledBlockTypes) {\n+            list.add(NODES_TO_CORE_FACTORIES.get(blockType));\n+        }\n+        return list;\n+    }\n+\n+    public static void checkEnabledBlockTypes(Set<Class<? extends Block>> enabledBlockTypes) {\n+        for (Class<? extends Block> enabledBlockType : enabledBlockTypes) {\n+            if (!NODES_TO_CORE_FACTORIES.containsKey(enabledBlockType)) {\n+                throw new IllegalArgumentException(\"Can't enable block type \" + enabledBlockType + \", possible options are: \" + NODES_TO_CORE_FACTORIES.keySet());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The main parsing function. Returns a parsed document AST.\n+     *\/\n+    public Document parse(String input) {\n+        int lineStart = 0;\n+        int lineBreak;\n+        while ((lineBreak = Characters.findLineBreak(input, lineStart)) != -1) {\n+            String line = input.substring(lineStart, lineBreak);\n+            parseLine(line);\n+            if (lineBreak + 1 < input.length() && input.charAt(lineBreak) == '\\r' && input.charAt(lineBreak + 1) == '\\n') {\n+                lineStart = lineBreak + 2;\n+            } else {\n+                lineStart = lineBreak + 1;\n+            }\n+        }\n+        if (input.length() > 0 && (lineStart == 0 || lineStart < input.length())) {\n+            String line = input.substring(lineStart);\n+            parseLine(line);\n+        }\n+\n+        return finalizeAndProcess();\n+    }\n+\n+    public Document parse(Reader input) throws IOException {\n+        BufferedReader bufferedReader;\n+        if (input instanceof BufferedReader) {\n+            bufferedReader = (BufferedReader) input;\n+        } else {\n+            bufferedReader = new BufferedReader(input);\n+        }\n+\n+        String line;\n+        while ((line = bufferedReader.readLine()) != null) {\n+            parseLine(line);\n+        }\n+\n+        return finalizeAndProcess();\n+    }\n+\n+    @Override\n+    public SourceLine getLine() {\n+        return line;\n+    }\n+\n+    @Override\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    @Override\n+    public int getNextNonSpaceIndex() {\n+        return nextNonSpace;\n+    }\n+\n+    @Override\n+    public int getColumn() {\n+        return column;\n+    }\n+\n+    @Override\n+    public int getIndent() {\n+        return indent;\n+    }\n+\n+    @Override\n+    public boolean isBlank() {\n+        return blank;\n+    }\n+\n+    @Override\n+    public BlockParser getActiveBlockParser() {\n+        return openBlockParsers.get(openBlockParsers.size() - 1).blockParser;\n+    }\n+\n+    \/**\n+     * Analyze a line of text and update the document appropriately. We parse markdown text by calling this on each\n+     * line of input, then finalizing the document.\n+     *\/\n+    private void parseLine(CharSequence ln) {\n+        setLine(ln);\n+\n+        \/\/ For each containing block, try to parse the associated line start.\n+        \/\/ The document will always match, so we can skip the first block parser and start at 1 matches\n+        int matches = 1;\n+        for (int i = 1; i < openBlockParsers.size(); i++) {\n+            OpenBlockParser openBlockParser = openBlockParsers.get(i);\n+            BlockParser blockParser = openBlockParser.blockParser;\n+            findNextNonSpace();\n+\n+            BlockContinue result = blockParser.tryContinue(this);\n+            if (result instanceof BlockContinueImpl) {\n+                BlockContinueImpl blockContinue = (BlockContinueImpl) result;\n+                openBlockParser.sourceIndex = getIndex();\n+                if (blockContinue.isFinalize()) {\n+                    addSourceSpans();\n+                    closeBlockParsers(openBlockParsers.size() - i);\n+                    return;\n+                } else {\n+                    if (blockContinue.getNewIndex() != -1) {\n+                        setNewIndex(blockContinue.getNewIndex());\n+                    } else if (blockContinue.getNewColumn() != -1) {\n+                        setNewColumn(blockContinue.getNewColumn());\n+                    }\n+                    matches++;\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        int unmatchedBlocks = openBlockParsers.size() - matches;\n+        BlockParser blockParser = openBlockParsers.get(matches - 1).blockParser;\n+        boolean startedNewBlock = false;\n+\n+        int lastIndex = index;\n+\n+        \/\/ Unless last matched container is a code block, try new container starts,\n+        \/\/ adding children to the last matched container:\n+        boolean tryBlockStarts = blockParser.getBlock() instanceof Paragraph || blockParser.isContainer();\n+        while (tryBlockStarts) {\n+            lastIndex = index;\n+            findNextNonSpace();\n+\n+            \/\/ this is a little performance optimization:\n+            if (isBlank() || (indent < Parsing.CODE_BLOCK_INDENT && Characters.isLetter(this.line.getContent(), nextNonSpace))) {\n+                setNewIndex(nextNonSpace);\n+                break;\n+            }\n+\n+            BlockStartImpl blockStart = findBlockStart(blockParser);\n+            if (blockStart == null) {\n+                setNewIndex(nextNonSpace);\n+                break;\n+            }\n+\n+            startedNewBlock = true;\n+            int sourceIndex = getIndex();\n+\n+            \/\/ We're starting a new block. If we have any previous blocks that need to be closed, we need to do it now.\n+            if (unmatchedBlocks > 0) {\n+                closeBlockParsers(unmatchedBlocks);\n+                unmatchedBlocks = 0;\n+            }\n+\n+            if (blockStart.getNewIndex() != -1) {\n+                setNewIndex(blockStart.getNewIndex());\n+            } else if (blockStart.getNewColumn() != -1) {\n+                setNewColumn(blockStart.getNewColumn());\n+            }\n+\n+            List<SourceSpan> replacedSourceSpans = null;\n+            if (blockStart.isReplaceActiveBlockParser()) {\n+                Block replacedBlock = prepareActiveBlockParserForReplacement();\n+                replacedSourceSpans = replacedBlock.getSourceSpans();\n+            }\n+\n+            for (BlockParser newBlockParser : blockStart.getBlockParsers()) {\n+                addChild(new OpenBlockParser(newBlockParser, sourceIndex));\n+                if (replacedSourceSpans != null) {\n+                    newBlockParser.getBlock().setSourceSpans(replacedSourceSpans);\n+                }\n+                blockParser = newBlockParser;\n+                tryBlockStarts = newBlockParser.isContainer();\n+            }\n+        }\n+\n+        \/\/ What remains at the offset is a text line. Add the text to the\n+        \/\/ appropriate block.\n+\n+        \/\/ First check for a lazy paragraph continuation:\n+        if (!startedNewBlock && !isBlank() &&\n+                getActiveBlockParser().canHaveLazyContinuationLines()) {\n+            openBlockParsers.get(openBlockParsers.size() - 1).sourceIndex = lastIndex;\n+            \/\/ lazy paragraph continuation\n+            addLine();\n+\n+        } else {\n+\n+            \/\/ finalize any blocks not matched\n+            if (unmatchedBlocks > 0) {\n+                closeBlockParsers(unmatchedBlocks);\n+            }\n+\n+            if (!blockParser.isContainer()) {\n+                addLine();\n+            } else if (!isBlank()) {\n+                \/\/ create paragraph container for line\n+                ParagraphParser paragraphParser = new ParagraphParser();\n+                addChild(new OpenBlockParser(paragraphParser, lastIndex));\n+                addLine();\n+            } else {\n+                \/\/ This can happen for a list item like this:\n+                \/\/ ```\n+                \/\/ *\n+                \/\/ list item\n+                \/\/ ```\n+                \/\/\n+                \/\/ The first line does not start a paragraph yet, but we still want to record source positions.\n+                addSourceSpans();\n+            }\n+        }\n+    }\n+\n+    private void setLine(CharSequence ln) {\n+        lineIndex++;\n+        index = 0;\n+        column = 0;\n+        columnIsInTab = false;\n+\n+        CharSequence lineContent = prepareLine(ln);\n+        SourceSpan sourceSpan = null;\n+        if (includeSourceSpans != IncludeSourceSpans.NONE) {\n+            sourceSpan = SourceSpan.of(lineIndex, 0, lineContent.length());\n+        }\n+        this.line = SourceLine.of(lineContent, sourceSpan);\n+    }\n+\n+    private void findNextNonSpace() {\n+        int i = index;\n+        int cols = column;\n+\n+        blank = true;\n+        int length = line.getContent().length();\n+        while (i < length) {\n+            char c = line.getContent().charAt(i);\n+            switch (c) {\n+                case ' ':\n+                    i++;\n+                    cols++;\n+                    continue;\n+                case '\\t':\n+                    i++;\n+                    cols += (4 - (cols % 4));\n+                    continue;\n+            }\n+            blank = false;\n+            break;\n+        }\n+\n+        nextNonSpace = i;\n+        nextNonSpaceColumn = cols;\n+        indent = nextNonSpaceColumn - column;\n+    }\n+\n+    private void setNewIndex(int newIndex) {\n+        if (newIndex >= nextNonSpace) {\n+            \/\/ We can start from here, no need to calculate tab stops again\n+            index = nextNonSpace;\n+            column = nextNonSpaceColumn;\n+        }\n+        int length = line.getContent().length();\n+        while (index < newIndex && index != length) {\n+            advance();\n+        }\n+        \/\/ If we're going to an index as opposed to a column, we're never within a tab\n+        columnIsInTab = false;\n+    }\n+\n+    private void setNewColumn(int newColumn) {\n+        if (newColumn >= nextNonSpaceColumn) {\n+            \/\/ We can start from here, no need to calculate tab stops again\n+            index = nextNonSpace;\n+            column = nextNonSpaceColumn;\n+        }\n+        int length = line.getContent().length();\n+        while (column < newColumn && index != length) {\n+            advance();\n+        }\n+        if (column > newColumn) {\n+            \/\/ Last character was a tab and we overshot our target\n+            index--;\n+            column = newColumn;\n+            columnIsInTab = true;\n+        } else {\n+            columnIsInTab = false;\n+        }\n+    }\n+\n+    private void advance() {\n+        char c = line.getContent().charAt(index);\n+        index++;\n+        if (c == '\\t') {\n+            column += Parsing.columnsToNextTabStop(column);\n+        } else {\n+            column++;\n+        }\n+    }\n+\n+    \/**\n+     * Add line content to the active block parser. We assume it can accept lines -- that check should be done before\n+     * calling this.\n+     *\/\n+    private void addLine() {\n+        CharSequence content;\n+        if (columnIsInTab) {\n+            \/\/ Our column is in a partially consumed tab. Expand the remaining columns (to the next tab stop) to spaces.\n+            int afterTab = index + 1;\n+            CharSequence rest = line.getContent().subSequence(afterTab, line.getContent().length());\n+            int spaces = Parsing.columnsToNextTabStop(column);\n+            StringBuilder sb = new StringBuilder(spaces + rest.length());\n+            for (int i = 0; i < spaces; i++) {\n+                sb.append(' ');\n+            }\n+            sb.append(rest);\n+            content = sb.toString();\n+        } else if (index == 0) {\n+            content = line.getContent();\n+        } else {\n+            content = line.getContent().subSequence(index, line.getContent().length());\n+        }\n+        SourceSpan sourceSpan = null;\n+        if (includeSourceSpans == IncludeSourceSpans.BLOCKS_AND_INLINES) {\n+            \/\/ Note that if we're in a partially-consumed tab, the length here corresponds to the content but not to the\n+            \/\/ actual source length. That sounds like a problem, but I haven't found a test case where it matters (yet).\n+            sourceSpan = SourceSpan.of(lineIndex, index, content.length());\n+        }\n+        getActiveBlockParser().addLine(SourceLine.of(content, sourceSpan));\n+        addSourceSpans();\n+    }\n+\n+    private void addSourceSpans() {\n+        if (includeSourceSpans != IncludeSourceSpans.NONE) {\n+            \/\/ Don't add source spans for Document itself (it would get the whole source text)\n+            for (int i = 1; i < openBlockParsers.size(); i++) {\n+                OpenBlockParser openBlockParser = openBlockParsers.get(i);\n+                int blockIndex = openBlockParser.sourceIndex;\n+                int length = line.getContent().length() - blockIndex;\n+                if (length != 0) {\n+                    openBlockParser.blockParser.addSourceSpan(SourceSpan.of(lineIndex, blockIndex, length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private BlockStartImpl findBlockStart(BlockParser blockParser) {\n+        MatchedBlockParser matchedBlockParser = new MatchedBlockParserImpl(blockParser);\n+        for (BlockParserFactory blockParserFactory : blockParserFactories) {\n+            BlockStart result = blockParserFactory.tryStart(this, matchedBlockParser);\n+            if (result instanceof BlockStartImpl) {\n+                return (BlockStartImpl) result;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Finalize a block. Close it and do any necessary postprocessing, e.g. setting the content of blocks and\n+     * collecting link reference definitions from paragraphs.\n+     *\/\n+    private void finalize(BlockParser blockParser) {\n+        if (blockParser instanceof ParagraphParser) {\n+            addDefinitionsFrom((ParagraphParser) blockParser);\n+        }\n+\n+        blockParser.closeBlock();\n+    }\n+\n+    private void addDefinitionsFrom(ParagraphParser paragraphParser) {\n+        for (LinkReferenceDefinition definition : paragraphParser.getDefinitions()) {\n+            \/\/ Add nodes into document before paragraph.\n+            paragraphParser.getBlock().insertBefore(definition);\n+\n+            definitions.add(definition);\n+        }\n+    }\n+\n+    \/**\n+     * Walk through a block & children recursively, parsing string content into inline content where appropriate.\n+     *\/\n+    private void processInlines() {\n+        InlineParserContextImpl context = new InlineParserContextImpl(delimiterProcessors, definitions);\n+        InlineParser inlineParser = inlineParserFactory.create(context);\n+\n+        for (BlockParser blockParser : allBlockParsers) {\n+            blockParser.parseInlines(inlineParser);\n+        }\n+    }\n+\n+    \/**\n+     * Add block of type tag as a child of the tip. If the tip can't accept children, close and finalize it and try\n+     * its parent, and so on until we find a block that can accept children.\n+     *\/\n+    private void addChild(OpenBlockParser openBlockParser) {\n+        while (!getActiveBlockParser().canContain(openBlockParser.blockParser.getBlock())) {\n+            closeBlockParsers(1);\n+        }\n+\n+        getActiveBlockParser().getBlock().appendChild(openBlockParser.blockParser.getBlock());\n+        activateBlockParser(openBlockParser);\n+    }\n+\n+    private void activateBlockParser(OpenBlockParser openBlockParser) {\n+        openBlockParsers.add(openBlockParser);\n+    }\n+\n+    private OpenBlockParser deactivateBlockParser() {\n+        return openBlockParsers.remove(openBlockParsers.size() - 1);\n+    }\n+\n+    private Block prepareActiveBlockParserForReplacement() {\n+        \/\/ Note that we don't want to parse inlines, as it's getting replaced.\n+        BlockParser old = deactivateBlockParser().blockParser;\n+\n+        if (old instanceof ParagraphParser) {\n+            ParagraphParser paragraphParser = (ParagraphParser) old;\n+            \/\/ Collect any link reference definitions. Note that replacing the active block parser is done after a\n+            \/\/ block parser got the current paragraph content using MatchedBlockParser#getContentString. In case the\n+            \/\/ paragraph started with link reference definitions, we parse and strip them before the block parser gets\n+            \/\/ the content. We want to keep them.\n+            \/\/ If no replacement happens, we collect the definitions as part of finalizing paragraph blocks.\n+            addDefinitionsFrom(paragraphParser);\n+        }\n+\n+        \/\/ Do this so that source positions are calculated, which we will carry over to the replacing block.\n+        old.closeBlock();\n+        old.getBlock().unlink();\n+        return old.getBlock();\n+    }\n+\n+    private Document finalizeAndProcess() {\n+        closeBlockParsers(openBlockParsers.size());\n+        processInlines();\n+        return documentBlockParser.getBlock();\n+    }\n+\n+    private void closeBlockParsers(int count) {\n+        for (int i = 0; i < count; i++) {\n+            BlockParser blockParser = deactivateBlockParser().blockParser;\n+            finalize(blockParser);\n+            \/\/ Remember for inline parsing. Note that a lot of blocks don't need inline parsing. We could have a\n+            \/\/ separate interface (e.g. BlockParserWithInlines) so that we only have to remember those that actually\n+            \/\/ have inlines to parse.\n+            allBlockParsers.add(blockParser);\n+        }\n+    }\n+\n+    \/**\n+     * Prepares the input line replacing {@code \\0}\n+     *\/\n+    private static CharSequence prepareLine(CharSequence line) {\n+        \/\/ Avoid building a new string in the majority of cases (no \\0)\n+        StringBuilder sb = null;\n+        int length = line.length();\n+        for (int i = 0; i < length; i++) {\n+            char c = line.charAt(i);\n+            if (c == '\\0') {\n+                if (sb == null) {\n+                    sb = new StringBuilder(length);\n+                    sb.append(line, 0, i);\n+                }\n+                sb.append('\\uFFFD');\n+            } else {\n+                if (sb != null) {\n+                    sb.append(c);\n+                }\n+            }\n+        }\n+\n+        if (sb != null) {\n+            return sb.toString();\n+        } else {\n+            return line;\n+        }\n+    }\n+\n+    private static class MatchedBlockParserImpl implements MatchedBlockParser {\n+\n+        private final BlockParser matchedBlockParser;\n+\n+        public MatchedBlockParserImpl(BlockParser matchedBlockParser) {\n+            this.matchedBlockParser = matchedBlockParser;\n+        }\n+\n+        @Override\n+        public BlockParser getMatchedBlockParser() {\n+            return matchedBlockParser;\n+        }\n+\n+        @Override\n+        public SourceLines getParagraphLines() {\n+            if (matchedBlockParser instanceof ParagraphParser) {\n+                ParagraphParser paragraphParser = (ParagraphParser) matchedBlockParser;\n+                return paragraphParser.getParagraphLines();\n+            }\n+            return SourceLines.empty();\n+        }\n+    }\n+\n+    private static class OpenBlockParser {\n+        private final BlockParser blockParser;\n+        private int sourceIndex;\n+\n+        OpenBlockParser(BlockParser blockParser, int sourceIndex) {\n+            this.blockParser = blockParser;\n+            this.sourceIndex = sourceIndex;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/DocumentParser.java","additions":639,"deletions":0,"binary":false,"changes":639,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.FencedCodeBlock;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.*;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+import static jdk.internal.org.commonmark.internal.util.Escaping.unescapeString;\n+\n+public class FencedCodeBlockParser extends AbstractBlockParser {\n+\n+    private final FencedCodeBlock block = new FencedCodeBlock();\n+    private final char fenceChar;\n+    private final int openingFenceLength;\n+\n+    private String firstLine;\n+    private StringBuilder otherLines = new StringBuilder();\n+\n+    public FencedCodeBlockParser(char fenceChar, int fenceLength, int fenceIndent) {\n+        this.fenceChar = fenceChar;\n+        this.openingFenceLength = fenceLength;\n+        block.setFenceCharacter(String.valueOf(fenceChar));\n+        block.setOpeningFenceLength(fenceLength);\n+        block.setFenceIndent(fenceIndent);\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        int nextNonSpace = state.getNextNonSpaceIndex();\n+        int newIndex = state.getIndex();\n+        CharSequence line = state.getLine().getContent();\n+        if (state.getIndent() < Parsing.CODE_BLOCK_INDENT && nextNonSpace < line.length() && tryClosing(line, nextNonSpace)) {\n+            \/\/ closing fence - we're at end of line, so we can finalize now\n+            return BlockContinue.finished();\n+        } else {\n+            \/\/ skip optional spaces of fence indent\n+            int i = block.getFenceIndent();\n+            int length = line.length();\n+            while (i > 0 && newIndex < length && line.charAt(newIndex) == ' ') {\n+                newIndex++;\n+                i--;\n+            }\n+        }\n+        return BlockContinue.atIndex(newIndex);\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        if (firstLine == null) {\n+            firstLine = line.getContent().toString();\n+        } else {\n+            otherLines.append(line.getContent());\n+            otherLines.append('\\n');\n+        }\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        \/\/ first line becomes info string\n+        block.setInfo(unescapeString(firstLine.trim()));\n+        block.setLiteral(otherLines.toString());\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            int indent = state.getIndent();\n+            if (indent >= Parsing.CODE_BLOCK_INDENT) {\n+                return BlockStart.none();\n+            }\n+\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            FencedCodeBlockParser blockParser = checkOpener(state.getLine().getContent(), nextNonSpace, indent);\n+            if (blockParser != null) {\n+                return BlockStart.of(blockParser).atIndex(nextNonSpace + blockParser.block.getOpeningFenceLength());\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+\n+    \/\/ spec: A code fence is a sequence of at least three consecutive backtick characters (`) or tildes (~). (Tildes and\n+    \/\/ backticks cannot be mixed.)\n+    private static FencedCodeBlockParser checkOpener(CharSequence line, int index, int indent) {\n+        int backticks = 0;\n+        int tildes = 0;\n+        int length = line.length();\n+        loop:\n+        for (int i = index; i < length; i++) {\n+            switch (line.charAt(i)) {\n+                case '`':\n+                    backticks++;\n+                    break;\n+                case '~':\n+                    tildes++;\n+                    break;\n+                default:\n+                    break loop;\n+            }\n+        }\n+        if (backticks >= 3 && tildes == 0) {\n+            \/\/ spec: If the info string comes after a backtick fence, it may not contain any backtick characters.\n+            if (Characters.find('`', line, index + backticks) != -1) {\n+                return null;\n+            }\n+            return new FencedCodeBlockParser('`', backticks, indent);\n+        } else if (tildes >= 3 && backticks == 0) {\n+            \/\/ spec: Info strings for tilde code blocks can contain backticks and tildes\n+            return new FencedCodeBlockParser('~', tildes, indent);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ spec: The content of the code block consists of all subsequent lines, until a closing code fence of the same type\n+    \/\/ as the code block began with (backticks or tildes), and with at least as many backticks or tildes as the opening\n+    \/\/ code fence.\n+    private boolean tryClosing(CharSequence line, int index) {\n+        int fences = Characters.skip(fenceChar, line, index, line.length()) - index;\n+        if (fences < openingFenceLength) {\n+            return false;\n+        }\n+        \/\/ spec: The closing code fence [...] may be followed only by spaces, which are ignored.\n+        int after = Characters.skipSpaceTab(line, index + fences, line.length());\n+        if (after == line.length()) {\n+            block.setClosingFenceLength(fences);\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/FencedCodeBlockParser.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.Heading;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+import jdk.internal.org.commonmark.parser.block.*;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+public class HeadingParser extends AbstractBlockParser {\n+\n+    private final Heading block = new Heading();\n+    private final SourceLines content;\n+\n+    public HeadingParser(int level, SourceLines content) {\n+        block.setLevel(level);\n+        this.content = content;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState parserState) {\n+        \/\/ In both ATX and Setext headings, once we have the heading markup, there's nothing more to parse.\n+        return BlockContinue.none();\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+        inlineParser.parse(content, block);\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT) {\n+                return BlockStart.none();\n+            }\n+\n+            SourceLine line = state.getLine();\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            if (line.getContent().charAt(nextNonSpace) == '#') {\n+                HeadingParser atxHeading = getAtxHeading(line.substring(nextNonSpace, line.getContent().length()));\n+                if (atxHeading != null) {\n+                    return BlockStart.of(atxHeading).atIndex(line.getContent().length());\n+                }\n+            }\n+\n+            int setextHeadingLevel = getSetextHeadingLevel(line.getContent(), nextNonSpace);\n+            if (setextHeadingLevel > 0) {\n+                SourceLines paragraph = matchedBlockParser.getParagraphLines();\n+                if (!paragraph.isEmpty()) {\n+                    return BlockStart.of(new HeadingParser(setextHeadingLevel, paragraph))\n+                            .atIndex(line.getContent().length())\n+                            .replaceActiveBlockParser();\n+                }\n+            }\n+\n+            return BlockStart.none();\n+        }\n+    }\n+\n+    \/\/ spec: An ATX heading consists of a string of characters, parsed as inline content, between an opening sequence of\n+    \/\/ 1\\u20136 unescaped # characters and an optional closing sequence of any number of unescaped # characters. The opening\n+    \/\/ sequence of # characters must be followed by a space or by the end of line. The optional closing sequence of #s\n+    \/\/ must be preceded by a space and may be followed by spaces only.\n+    private static HeadingParser getAtxHeading(SourceLine line) {\n+        Scanner scanner = Scanner.of(SourceLines.of(line));\n+        int level = scanner.matchMultiple('#');\n+\n+        if (level == 0 || level > 6) {\n+            return null;\n+        }\n+\n+        if (!scanner.hasNext()) {\n+            \/\/ End of line after markers is an empty heading\n+            return new HeadingParser(level, SourceLines.empty());\n+        }\n+\n+        char next = scanner.peek();\n+        if (!(next == ' ' || next == '\\t')) {\n+            return null;\n+        }\n+\n+        scanner.whitespace();\n+        Position start = scanner.position();\n+        Position end = start;\n+        boolean hashCanEnd = true;\n+\n+        while (scanner.hasNext()) {\n+            char c = scanner.peek();\n+            switch (c) {\n+                case '#':\n+                    if (hashCanEnd) {\n+                        scanner.matchMultiple('#');\n+                        int whitespace = scanner.whitespace();\n+                        \/\/ If there's other characters, the hashes and spaces were part of the heading\n+                        if (scanner.hasNext()) {\n+                            end = scanner.position();\n+                        }\n+                        hashCanEnd = whitespace > 0;\n+                    } else {\n+                        scanner.next();\n+                        end = scanner.position();\n+                    }\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                    hashCanEnd = true;\n+                    scanner.next();\n+                    break;\n+                default:\n+                    hashCanEnd = false;\n+                    scanner.next();\n+                    end = scanner.position();\n+            }\n+        }\n+\n+        SourceLines source = scanner.getSource(start, end);\n+        String content = source.getContent();\n+        if (content.isEmpty()) {\n+            return new HeadingParser(level, SourceLines.empty());\n+        }\n+        return new HeadingParser(level, source);\n+    }\n+\n+    \/\/ spec: A setext heading underline is a sequence of = characters or a sequence of - characters, with no more than\n+    \/\/ 3 spaces indentation and any number of trailing spaces.\n+    @SuppressWarnings(\"fallthrough\") private static int getSetextHeadingLevel(CharSequence line, int index) {\n+        switch (line.charAt(index)) {\n+            case '=':\n+                if (isSetextHeadingRest(line, index + 1, '=')) {\n+                    return 1;\n+                }\n+            case '-':\n+                if (isSetextHeadingRest(line, index + 1, '-')) {\n+                    return 2;\n+                }\n+        }\n+        return 0;\n+    }\n+\n+    private static boolean isSetextHeadingRest(CharSequence line, int index, char marker) {\n+        int afterMarker = Characters.skip(marker, line, index, line.length());\n+        int afterSpace = Characters.skipSpaceTab(line, afterMarker, line.length());\n+        return afterSpace >= line.length();\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/HeadingParser.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.HtmlBlock;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+import java.util.regex.Pattern;\n+\n+public class HtmlBlockParser extends AbstractBlockParser {\n+\n+    private static final String TAGNAME = \"[A-Za-z][A-Za-z0-9-]*\";\n+    private static final String ATTRIBUTENAME = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\n+    private static final String UNQUOTEDVALUE = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\n+    private static final String SINGLEQUOTEDVALUE = \"'[^']*'\";\n+    private static final String DOUBLEQUOTEDVALUE = \"\\\"[^\\\"]*\\\"\";\n+    private static final String ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE\n+            + \"|\" + DOUBLEQUOTEDVALUE + \")\";\n+    private static final String ATTRIBUTEVALUESPEC = \"(?:\" + \"\\\\s*=\" + \"\\\\s*\" + ATTRIBUTEVALUE\n+            + \")\";\n+    private static final String ATTRIBUTE = \"(?:\" + \"\\\\s+\" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC\n+            + \"?)\";\n+\n+    private static final String OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\" + \"\\\\s*\/?>\";\n+    private static final String CLOSETAG = \"<\/\" + TAGNAME + \"\\\\s*[>]\";\n+\n+    private static final Pattern[][] BLOCK_PATTERNS = new Pattern[][]{\n+            {null, null}, \/\/ not used (no type 0)\n+            {\n+                    Pattern.compile(\"^<(?:script|pre|style|textarea)(?:\\\\s|>|$)\", Pattern.CASE_INSENSITIVE),\n+                    Pattern.compile(\"<\/(?:script|pre|style|textarea)>\", Pattern.CASE_INSENSITIVE)\n+            },\n+            {\n+                    Pattern.compile(\"^<!--\"),\n+                    Pattern.compile(\"-->\")\n+            },\n+            {\n+                    Pattern.compile(\"^<[?]\"),\n+                    Pattern.compile(\"\\\\?>\")\n+            },\n+            {\n+                    Pattern.compile(\"^<![A-Z]\"),\n+                    Pattern.compile(\">\")\n+            },\n+            {\n+                    Pattern.compile(\"^<!\\\\[CDATA\\\\[\"),\n+                    Pattern.compile(\"\\\\]\\\\]>\")\n+            },\n+            {\n+                    Pattern.compile(\"^<\/?(?:\" +\n+                            \"address|article|aside|\" +\n+                            \"base|basefont|blockquote|body|\" +\n+                            \"caption|center|col|colgroup|\" +\n+                            \"dd|details|dialog|dir|div|dl|dt|\" +\n+                            \"fieldset|figcaption|figure|footer|form|frame|frameset|\" +\n+                            \"h1|h2|h3|h4|h5|h6|head|header|hr|html|\" +\n+                            \"iframe|\" +\n+                            \"legend|li|link|\" +\n+                            \"main|menu|menuitem|\" +\n+                            \"nav|noframes|\" +\n+                            \"ol|optgroup|option|\" +\n+                            \"p|param|\" +\n+                            \"search|section|summary|\" +\n+                            \"table|tbody|td|tfoot|th|thead|title|tr|track|\" +\n+                            \"ul\" +\n+                            \")(?:\\\\s|[\/]?[>]|$)\", Pattern.CASE_INSENSITIVE),\n+                    null \/\/ terminated by blank line\n+            },\n+            {\n+                    Pattern.compile(\"^(?:\" + OPENTAG + '|' + CLOSETAG + \")\\\\s*$\", Pattern.CASE_INSENSITIVE),\n+                    null \/\/ terminated by blank line\n+            }\n+    };\n+\n+    private final HtmlBlock block = new HtmlBlock();\n+    private final Pattern closingPattern;\n+\n+    private boolean finished = false;\n+    private BlockContent content = new BlockContent();\n+\n+    private HtmlBlockParser(Pattern closingPattern) {\n+        this.closingPattern = closingPattern;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (finished) {\n+            return BlockContinue.none();\n+        }\n+\n+        \/\/ Blank line ends type 6 and type 7 blocks\n+        if (state.isBlank() && closingPattern == null) {\n+            return BlockContinue.none();\n+        } else {\n+            return BlockContinue.atIndex(state.getIndex());\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        content.add(line.getContent());\n+\n+        if (closingPattern != null && closingPattern.matcher(line.getContent()).find()) {\n+            finished = true;\n+        }\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        block.setLiteral(content.getString());\n+        content = null;\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            CharSequence line = state.getLine().getContent();\n+\n+            if (state.getIndent() < 4 && line.charAt(nextNonSpace) == '<') {\n+                for (int blockType = 1; blockType <= 7; blockType++) {\n+                    \/\/ Type 7 can not interrupt a paragraph (not even a lazy one)\n+                    if (blockType == 7 && (\n+                            matchedBlockParser.getMatchedBlockParser().getBlock() instanceof Paragraph ||\n+                                    state.getActiveBlockParser().canHaveLazyContinuationLines())) {\n+                        continue;\n+                    }\n+                    Pattern opener = BLOCK_PATTERNS[blockType][0];\n+                    Pattern closer = BLOCK_PATTERNS[blockType][1];\n+                    boolean matches = opener.matcher(line.subSequence(nextNonSpace, line.length())).find();\n+                    if (matches) {\n+                        return BlockStart.of(new HtmlBlockParser(closer)).atIndex(state.getIndex());\n+                    }\n+                }\n+            }\n+            return BlockStart.none();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/HtmlBlockParser.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.IndentedCodeBlock;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.block.*;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class IndentedCodeBlockParser extends AbstractBlockParser {\n+\n+    private final IndentedCodeBlock block = new IndentedCodeBlock();\n+    private final List<CharSequence> lines = new ArrayList<>();\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT) {\n+            return BlockContinue.atColumn(state.getColumn() + Parsing.CODE_BLOCK_INDENT);\n+        } else if (state.isBlank()) {\n+            return BlockContinue.atIndex(state.getNextNonSpaceIndex());\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        lines.add(line.getContent());\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        int lastNonBlank = lines.size() - 1;\n+        while (lastNonBlank >= 0) {\n+            if (!Characters.isBlank(lines.get(lastNonBlank))) {\n+                break;\n+            }\n+            lastNonBlank--;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < lastNonBlank + 1; i++) {\n+            sb.append(lines.get(i));\n+            sb.append('\\n');\n+        }\n+\n+        String literal = sb.toString();\n+        block.setLiteral(literal);\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            \/\/ An indented code block cannot interrupt a paragraph.\n+            if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT && !state.isBlank() && !(state.getActiveBlockParser().getBlock() instanceof Paragraph)) {\n+                return BlockStart.of(new IndentedCodeBlockParser()).atColumn(state.getColumn() + Parsing.CODE_BLOCK_INDENT);\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+}\n+\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/IndentedCodeBlockParser.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.parser.InlineParserContext;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class InlineParserContextImpl implements InlineParserContext {\n+\n+    private final List<DelimiterProcessor> delimiterProcessors;\n+    private final LinkReferenceDefinitions linkReferenceDefinitions;\n+\n+    public InlineParserContextImpl(List<DelimiterProcessor> delimiterProcessors,\n+                                   LinkReferenceDefinitions linkReferenceDefinitions) {\n+        this.delimiterProcessors = delimiterProcessors;\n+        this.linkReferenceDefinitions = linkReferenceDefinitions;\n+    }\n+\n+    @Override\n+    public List<DelimiterProcessor> getCustomDelimiterProcessors() {\n+        return delimiterProcessors;\n+    }\n+\n+    @Override\n+    public LinkReferenceDefinition getLinkReferenceDefinition(String label) {\n+        return linkReferenceDefinitions.get(label);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/InlineParserContextImpl.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,787 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.inline.*;\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.internal.util.LinkScanner;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.InlineParserContext;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+import java.util.*;\n+\n+public class InlineParserImpl implements InlineParser, InlineParserState {\n+\n+    private final BitSet specialCharacters;\n+    private final Map<Character, DelimiterProcessor> delimiterProcessors;\n+    private final InlineParserContext context;\n+    private final Map<Character, List<InlineContentParser>> inlineParsers;\n+\n+    private Scanner scanner;\n+    private boolean includeSourceSpans;\n+    private int trailingSpaces;\n+\n+    \/**\n+     * Top delimiter (emphasis, strong emphasis or custom emphasis). (Brackets are on a separate stack, different\n+     * from the algorithm described in the spec.)\n+     *\/\n+    private Delimiter lastDelimiter;\n+\n+    \/**\n+     * Top opening bracket (<code>[<\/code> or <code>![)<\/code>).\n+     *\/\n+    private Bracket lastBracket;\n+\n+    public InlineParserImpl(InlineParserContext inlineParserContext) {\n+        this.delimiterProcessors = calculateDelimiterProcessors(inlineParserContext.getCustomDelimiterProcessors());\n+\n+        this.context = inlineParserContext;\n+        this.inlineParsers = new HashMap<>();\n+        this.inlineParsers.put('\\\\', Collections.<InlineContentParser>singletonList(new BackslashInlineParser()));\n+        this.inlineParsers.put('`', Collections.<InlineContentParser>singletonList(new BackticksInlineParser()));\n+        this.inlineParsers.put('&', Collections.<InlineContentParser>singletonList(new EntityInlineParser()));\n+        this.inlineParsers.put('<', Arrays.asList(new AutolinkInlineParser(), new HtmlInlineParser()));\n+\n+        this.specialCharacters = calculateSpecialCharacters(this.delimiterProcessors.keySet(), inlineParsers.keySet());\n+    }\n+\n+    public static BitSet calculateSpecialCharacters(Set<Character> delimiterCharacters, Set<Character> characters) {\n+        BitSet bitSet = new BitSet();\n+        for (Character c : delimiterCharacters) {\n+            bitSet.set(c);\n+        }\n+        for (Character c : characters) {\n+            bitSet.set(c);\n+        }\n+        bitSet.set('[');\n+        bitSet.set(']');\n+        bitSet.set('!');\n+        bitSet.set('\\n');\n+        return bitSet;\n+    }\n+\n+    public static Map<Character, DelimiterProcessor> calculateDelimiterProcessors(List<DelimiterProcessor> delimiterProcessors) {\n+        Map<Character, DelimiterProcessor> map = new HashMap<>();\n+        addDelimiterProcessors(Arrays.<DelimiterProcessor>asList(new AsteriskDelimiterProcessor(), new UnderscoreDelimiterProcessor()), map);\n+        addDelimiterProcessors(delimiterProcessors, map);\n+        return map;\n+    }\n+\n+    @Override\n+    public Scanner scanner() {\n+        return scanner;\n+    }\n+\n+    private static void addDelimiterProcessors(Iterable<DelimiterProcessor> delimiterProcessors, Map<Character, DelimiterProcessor> map) {\n+        for (DelimiterProcessor delimiterProcessor : delimiterProcessors) {\n+            char opening = delimiterProcessor.getOpeningCharacter();\n+            char closing = delimiterProcessor.getClosingCharacter();\n+            if (opening == closing) {\n+                DelimiterProcessor old = map.get(opening);\n+                if (old != null && old.getOpeningCharacter() == old.getClosingCharacter()) {\n+                    StaggeredDelimiterProcessor s;\n+                    if (old instanceof StaggeredDelimiterProcessor) {\n+                        s = (StaggeredDelimiterProcessor) old;\n+                    } else {\n+                        s = new StaggeredDelimiterProcessor(opening);\n+                        s.add(old);\n+                    }\n+                    s.add(delimiterProcessor);\n+                    map.put(opening, s);\n+                } else {\n+                    addDelimiterProcessorForChar(opening, delimiterProcessor, map);\n+                }\n+            } else {\n+                addDelimiterProcessorForChar(opening, delimiterProcessor, map);\n+                addDelimiterProcessorForChar(closing, delimiterProcessor, map);\n+            }\n+        }\n+    }\n+\n+    private static void addDelimiterProcessorForChar(char delimiterChar, DelimiterProcessor toAdd, Map<Character, DelimiterProcessor> delimiterProcessors) {\n+        DelimiterProcessor existing = delimiterProcessors.put(delimiterChar, toAdd);\n+        if (existing != null) {\n+            throw new IllegalArgumentException(\"Delimiter processor conflict with delimiter char '\" + delimiterChar + \"'\");\n+        }\n+    }\n+\n+    \/**\n+     * Parse content in block into inline children, appending them to the block node.\n+     *\/\n+    @Override\n+    public void parse(SourceLines lines, Node block) {\n+        reset(lines);\n+\n+        while (true) {\n+            List<? extends Node> nodes = parseInline();\n+            if (nodes != null) {\n+                for (Node node : nodes) {\n+                    block.appendChild(node);\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        processDelimiters(null);\n+        mergeChildTextNodes(block);\n+    }\n+\n+    void reset(SourceLines lines) {\n+        this.scanner = Scanner.of(lines);\n+        this.includeSourceSpans = !lines.getSourceSpans().isEmpty();\n+        this.trailingSpaces = 0;\n+        this.lastDelimiter = null;\n+        this.lastBracket = null;\n+    }\n+\n+    private Text text(SourceLines sourceLines) {\n+        Text text = new Text(sourceLines.getContent());\n+        text.setSourceSpans(sourceLines.getSourceSpans());\n+        return text;\n+    }\n+\n+    \/**\n+     * Parse the next inline element in subject, advancing our position.\n+     * On success, return the new inline node.\n+     * On failure, return null.\n+     *\/\n+    private List<? extends Node> parseInline() {\n+        char c = scanner.peek();\n+\n+        switch (c) {\n+            case '[':\n+                return Collections.singletonList(parseOpenBracket());\n+            case '!':\n+                return Collections.singletonList(parseBang());\n+            case ']':\n+                return Collections.singletonList(parseCloseBracket());\n+            case '\\n':\n+                return Collections.singletonList(parseLineBreak());\n+            case Scanner.END:\n+                return null;\n+        }\n+\n+        \/\/ No inline parser, delimiter or other special handling.\n+        if (!specialCharacters.get(c)) {\n+            return Collections.singletonList(parseText());\n+        }\n+\n+        List<InlineContentParser> inlineParsers = this.inlineParsers.get(c);\n+        if (inlineParsers != null) {\n+            Position position = scanner.position();\n+            for (InlineContentParser inlineParser : inlineParsers) {\n+                ParsedInline parsedInline = inlineParser.tryParse(this);\n+                if (parsedInline instanceof ParsedInlineImpl) {\n+                    ParsedInlineImpl parsedInlineImpl = (ParsedInlineImpl) parsedInline;\n+                    Node node = parsedInlineImpl.getNode();\n+                    scanner.setPosition(parsedInlineImpl.getPosition());\n+                    if (includeSourceSpans && node.getSourceSpans().isEmpty()) {\n+                        node.setSourceSpans(scanner.getSource(position, scanner.position()).getSourceSpans());\n+                    }\n+                    return Collections.singletonList(node);\n+                } else {\n+                    \/\/ Reset position\n+                    scanner.setPosition(position);\n+                }\n+            }\n+        }\n+\n+        DelimiterProcessor delimiterProcessor = delimiterProcessors.get(c);\n+        if (delimiterProcessor != null) {\n+            List<? extends Node> nodes = parseDelimiters(delimiterProcessor, c);\n+            if (nodes != null) {\n+                return nodes;\n+            }\n+        }\n+\n+        \/\/ If we get here, even for a special\/delimiter character, we will just treat it as text.\n+        return Collections.singletonList(parseText());\n+    }\n+\n+    \/**\n+     * Attempt to parse delimiters like emphasis, strong emphasis or custom delimiters.\n+     *\/\n+    private List<? extends Node> parseDelimiters(DelimiterProcessor delimiterProcessor, char delimiterChar) {\n+        DelimiterData res = scanDelimiters(delimiterProcessor, delimiterChar);\n+        if (res == null) {\n+            return null;\n+        }\n+\n+        List<Text> characters = res.characters;\n+\n+        \/\/ Add entry to stack for this opener\n+        lastDelimiter = new Delimiter(characters, delimiterChar, res.canOpen, res.canClose, lastDelimiter);\n+        if (lastDelimiter.previous != null) {\n+            lastDelimiter.previous.next = lastDelimiter;\n+        }\n+\n+        return characters;\n+    }\n+\n+    \/**\n+     * Add open bracket to delimiter stack and add a text node to block's children.\n+     *\/\n+    private Node parseOpenBracket() {\n+        Position start = scanner.position();\n+        scanner.next();\n+        Position contentPosition = scanner.position();\n+\n+        Text node = text(scanner.getSource(start, contentPosition));\n+\n+        \/\/ Add entry to stack for this opener\n+        addBracket(Bracket.link(node, start, contentPosition, lastBracket, lastDelimiter));\n+\n+        return node;\n+    }\n+\n+    \/**\n+     * If next character is [, and ! delimiter to delimiter stack and add a text node to block's children.\n+     * Otherwise just add a text node.\n+     *\/\n+    private Node parseBang() {\n+        Position start = scanner.position();\n+        scanner.next();\n+        if (scanner.next('[')) {\n+            Position contentPosition = scanner.position();\n+            Text node = text(scanner.getSource(start, contentPosition));\n+\n+            \/\/ Add entry to stack for this opener\n+            addBracket(Bracket.image(node, start, contentPosition, lastBracket, lastDelimiter));\n+            return node;\n+        } else {\n+            return text(scanner.getSource(start, scanner.position()));\n+        }\n+    }\n+\n+    \/**\n+     * Try to match close bracket against an opening in the delimiter stack. Return either a link or image, or a\n+     * plain [ character. If there is a matching delimiter, remove it from the delimiter stack.\n+     *\/\n+    private Node parseCloseBracket() {\n+        Position beforeClose = scanner.position();\n+        scanner.next();\n+        Position afterClose = scanner.position();\n+\n+        \/\/ Get previous `[` or `![`\n+        Bracket opener = lastBracket;\n+        if (opener == null) {\n+            \/\/ No matching opener, just return a literal.\n+            return text(scanner.getSource(beforeClose, afterClose));\n+        }\n+\n+        if (!opener.allowed) {\n+            \/\/ Matching opener but it's not allowed, just return a literal.\n+            removeLastBracket();\n+            return text(scanner.getSource(beforeClose, afterClose));\n+        }\n+\n+        \/\/ Check to see if we have a link\/image\n+        String dest = null;\n+        String title = null;\n+\n+        \/\/ Maybe a inline link like `[foo](\/uri \"title\")`\n+        if (scanner.next('(')) {\n+            scanner.whitespace();\n+            dest = parseLinkDestination(scanner);\n+            if (dest == null) {\n+                scanner.setPosition(afterClose);\n+            } else {\n+                int whitespace = scanner.whitespace();\n+                \/\/ title needs a whitespace before\n+                if (whitespace >= 1) {\n+                    title = parseLinkTitle(scanner);\n+                    scanner.whitespace();\n+                }\n+                if (!scanner.next(')')) {\n+                    \/\/ Don't have a closing `)`, so it's not a destination and title -> reset.\n+                    \/\/ Note that something like `[foo](` could be valid, `(` will just be text.\n+                    scanner.setPosition(afterClose);\n+                    dest = null;\n+                    title = null;\n+                }\n+            }\n+        }\n+\n+        \/\/ Maybe a reference link like `[foo][bar]`, `[foo][]` or `[foo]`.\n+        \/\/ Note that even `[foo](` could be a valid link if there's a reference, which is why this is not just an `else`\n+        \/\/ here.\n+        if (dest == null) {\n+            \/\/ See if there's a link label like `[bar]` or `[]`\n+            String ref = parseLinkLabel(scanner);\n+            if (ref == null) {\n+                scanner.setPosition(afterClose);\n+            }\n+            if ((ref == null || ref.isEmpty()) && !opener.bracketAfter) {\n+                \/\/ If the second label is empty `[foo][]` or missing `[foo]`, then the first label is the reference.\n+                \/\/ But it can only be a reference when there's no (unescaped) bracket in it.\n+                \/\/ If there is, we don't even need to try to look up the reference. This is an optimization.\n+                ref = scanner.getSource(opener.contentPosition, beforeClose).getContent();\n+            }\n+\n+            if (ref != null) {\n+                LinkReferenceDefinition definition = context.getLinkReferenceDefinition(ref);\n+                if (definition != null) {\n+                    dest = definition.getDestination();\n+                    title = definition.getTitle();\n+                }\n+            }\n+        }\n+\n+        if (dest != null) {\n+            \/\/ If we got here, we have a link or image\n+            Node linkOrImage = opener.image ? new Image(dest, title) : new Link(dest, title);\n+\n+            \/\/ Add all nodes between the opening bracket and now (closing bracket) as child nodes of the link\n+            Node node = opener.node.getNext();\n+            while (node != null) {\n+                Node next = node.getNext();\n+                linkOrImage.appendChild(node);\n+                node = next;\n+            }\n+\n+            if (includeSourceSpans) {\n+                linkOrImage.setSourceSpans(scanner.getSource(opener.markerPosition, scanner.position()).getSourceSpans());\n+            }\n+\n+            \/\/ Process delimiters such as emphasis inside link\/image\n+            processDelimiters(opener.previousDelimiter);\n+            mergeChildTextNodes(linkOrImage);\n+            \/\/ We don't need the corresponding text node anymore, we turned it into a link\/image node\n+            opener.node.unlink();\n+            removeLastBracket();\n+\n+            \/\/ Links within links are not allowed. We found this link, so there can be no other link around it.\n+            if (!opener.image) {\n+                Bracket bracket = lastBracket;\n+                while (bracket != null) {\n+                    if (!bracket.image) {\n+                        \/\/ Disallow link opener. It will still get matched, but will not result in a link.\n+                        bracket.allowed = false;\n+                    }\n+                    bracket = bracket.previous;\n+                }\n+            }\n+\n+            return linkOrImage;\n+\n+        } else {\n+            \/\/ No link or image, parse just the bracket as text and continue\n+            removeLastBracket();\n+\n+            scanner.setPosition(afterClose);\n+            return text(scanner.getSource(beforeClose, afterClose));\n+        }\n+    }\n+\n+    private void addBracket(Bracket bracket) {\n+        if (lastBracket != null) {\n+            lastBracket.bracketAfter = true;\n+        }\n+        lastBracket = bracket;\n+    }\n+\n+    private void removeLastBracket() {\n+        lastBracket = lastBracket.previous;\n+    }\n+\n+    \/**\n+     * Attempt to parse link destination, returning the string or null if no match.\n+     *\/\n+    private String parseLinkDestination(Scanner scanner) {\n+        char delimiter = scanner.peek();\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkDestination(scanner)) {\n+            return null;\n+        }\n+\n+        String dest;\n+        if (delimiter == '<') {\n+            \/\/ chop off surrounding <..>:\n+            String rawDestination = scanner.getSource(start, scanner.position()).getContent();\n+            dest = rawDestination.substring(1, rawDestination.length() - 1);\n+        } else {\n+            dest = scanner.getSource(start, scanner.position()).getContent();\n+        }\n+\n+        return Escaping.unescapeString(dest);\n+    }\n+\n+    \/**\n+     * Attempt to parse link title (sans quotes), returning the string or null if no match.\n+     *\/\n+    private String parseLinkTitle(Scanner scanner) {\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkTitle(scanner)) {\n+            return null;\n+        }\n+\n+        \/\/ chop off ', \" or parens\n+        String rawTitle = scanner.getSource(start, scanner.position()).getContent();\n+        String title = rawTitle.substring(1, rawTitle.length() - 1);\n+        return Escaping.unescapeString(title);\n+    }\n+\n+    \/**\n+     * Attempt to parse a link label, returning the label between the brackets or null.\n+     *\/\n+    String parseLinkLabel(Scanner scanner) {\n+        if (!scanner.next('[')) {\n+            return null;\n+        }\n+\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkLabelContent(scanner)) {\n+            return null;\n+        }\n+        Position end = scanner.position();\n+\n+        if (!scanner.next(']')) {\n+            return null;\n+        }\n+\n+        String content = scanner.getSource(start, end).getContent();\n+        \/\/ spec: A link label can have at most 999 characters inside the square brackets.\n+        if (content.length() > 999) {\n+            return null;\n+        }\n+\n+        return content;\n+    }\n+\n+    private Node parseLineBreak() {\n+        scanner.next();\n+\n+        if (trailingSpaces >= 2) {\n+            return new HardLineBreak();\n+        } else {\n+            return new SoftLineBreak();\n+        }\n+    }\n+\n+    \/**\n+     * Parse the next character as plain text, and possibly more if the following characters are non-special.\n+     *\/\n+    private Node parseText() {\n+        Position start = scanner.position();\n+        scanner.next();\n+        char c;\n+        while (true) {\n+            c = scanner.peek();\n+            if (c == Scanner.END || specialCharacters.get(c)) {\n+                break;\n+            }\n+            scanner.next();\n+        }\n+\n+        SourceLines source = scanner.getSource(start, scanner.position());\n+        String content = source.getContent();\n+\n+        if (c == '\\n') {\n+            \/\/ We parsed until the end of the line. Trim any trailing spaces and remember them (for hard line breaks).\n+            int end = Characters.skipBackwards(' ', content, content.length() - 1, 0) + 1;\n+            trailingSpaces = content.length() - end;\n+            content = content.substring(0, end);\n+        } else if (c == Scanner.END) {\n+            \/\/ For the last line, both tabs and spaces are trimmed for some reason (checked with commonmark.js).\n+            int end = Characters.skipSpaceTabBackwards(content, content.length() - 1, 0) + 1;\n+            content = content.substring(0, end);\n+        }\n+\n+        Text text = new Text(content);\n+        text.setSourceSpans(source.getSourceSpans());\n+        return text;\n+    }\n+\n+    \/**\n+     * Scan a sequence of characters with code delimiterChar, and return information about the number of delimiters\n+     * and whether they are positioned such that they can open and\/or close emphasis or strong emphasis.\n+     *\n+     * @return information about delimiter run, or {@code null}\n+     *\/\n+    private DelimiterData scanDelimiters(DelimiterProcessor delimiterProcessor, char delimiterChar) {\n+        int before = scanner.peekPreviousCodePoint();\n+        Position start = scanner.position();\n+\n+        \/\/ Quick check to see if we have enough delimiters.\n+        int delimiterCount = scanner.matchMultiple(delimiterChar);\n+        if (delimiterCount < delimiterProcessor.getMinLength()) {\n+            scanner.setPosition(start);\n+            return null;\n+        }\n+\n+        \/\/ We do have enough, extract a text node for each delimiter character.\n+        List<Text> delimiters = new ArrayList<>();\n+        scanner.setPosition(start);\n+        Position positionBefore = start;\n+        while (scanner.next(delimiterChar)) {\n+            delimiters.add(text(scanner.getSource(positionBefore, scanner.position())));\n+            positionBefore = scanner.position();\n+        }\n+\n+        int after = scanner.peekCodePoint();\n+\n+        \/\/ We could be more lazy here, in most cases we don't need to do every match case.\n+        boolean beforeIsPunctuation = before == Scanner.END || Characters.isPunctuationCodePoint(before);\n+        boolean beforeIsWhitespace = before == Scanner.END || Characters.isWhitespaceCodePoint(before);\n+        boolean afterIsPunctuation = after == Scanner.END || Characters.isPunctuationCodePoint(after);\n+        boolean afterIsWhitespace = after == Scanner.END || Characters.isWhitespaceCodePoint(after);\n+\n+        boolean leftFlanking = !afterIsWhitespace &&\n+                (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n+        boolean rightFlanking = !beforeIsWhitespace &&\n+                (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n+        boolean canOpen;\n+        boolean canClose;\n+        if (delimiterChar == '_') {\n+            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n+            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n+        } else {\n+            canOpen = leftFlanking && delimiterChar == delimiterProcessor.getOpeningCharacter();\n+            canClose = rightFlanking && delimiterChar == delimiterProcessor.getClosingCharacter();\n+        }\n+\n+        return new DelimiterData(delimiters, canOpen, canClose);\n+    }\n+\n+    private void processDelimiters(Delimiter stackBottom) {\n+\n+        Map<Character, Delimiter> openersBottom = new HashMap<>();\n+\n+        \/\/ find first closer above stackBottom:\n+        Delimiter closer = lastDelimiter;\n+        while (closer != null && closer.previous != stackBottom) {\n+            closer = closer.previous;\n+        }\n+        \/\/ move forward, looking for closers, and handling each\n+        while (closer != null) {\n+            char delimiterChar = closer.delimiterChar;\n+\n+            DelimiterProcessor delimiterProcessor = delimiterProcessors.get(delimiterChar);\n+            if (!closer.canClose() || delimiterProcessor == null) {\n+                closer = closer.next;\n+                continue;\n+            }\n+\n+            char openingDelimiterChar = delimiterProcessor.getOpeningCharacter();\n+\n+            \/\/ Found delimiter closer. Now look back for first matching opener.\n+            int usedDelims = 0;\n+            boolean openerFound = false;\n+            boolean potentialOpenerFound = false;\n+            Delimiter opener = closer.previous;\n+            while (opener != null && opener != stackBottom && opener != openersBottom.get(delimiterChar)) {\n+                if (opener.canOpen() && opener.delimiterChar == openingDelimiterChar) {\n+                    potentialOpenerFound = true;\n+                    usedDelims = delimiterProcessor.process(opener, closer);\n+                    if (usedDelims > 0) {\n+                        openerFound = true;\n+                        break;\n+                    }\n+                }\n+                opener = opener.previous;\n+            }\n+\n+            if (!openerFound) {\n+                if (!potentialOpenerFound) {\n+                    \/\/ Set lower bound for future searches for openers.\n+                    \/\/ Only do this when we didn't even have a potential\n+                    \/\/ opener (one that matches the character and can open).\n+                    \/\/ If an opener was rejected because of the number of\n+                    \/\/ delimiters (e.g. because of the \"multiple of 3\" rule),\n+                    \/\/ we want to consider it next time because the number\n+                    \/\/ of delimiters can change as we continue processing.\n+                    openersBottom.put(delimiterChar, closer.previous);\n+                    if (!closer.canOpen()) {\n+                        \/\/ We can remove a closer that can't be an opener,\n+                        \/\/ once we've seen there's no matching opener:\n+                        removeDelimiterKeepNode(closer);\n+                    }\n+                }\n+                closer = closer.next;\n+                continue;\n+            }\n+\n+            \/\/ Remove number of used delimiters nodes.\n+            for (int i = 0; i < usedDelims; i++) {\n+                Text delimiter = opener.characters.remove(opener.characters.size() - 1);\n+                delimiter.unlink();\n+            }\n+            for (int i = 0; i < usedDelims; i++) {\n+                Text delimiter = closer.characters.remove(0);\n+                delimiter.unlink();\n+            }\n+\n+            removeDelimitersBetween(opener, closer);\n+\n+            \/\/ No delimiter characters left to process, so we can remove delimiter and the now empty node.\n+            if (opener.length() == 0) {\n+                removeDelimiterAndNodes(opener);\n+            }\n+\n+            if (closer.length() == 0) {\n+                Delimiter next = closer.next;\n+                removeDelimiterAndNodes(closer);\n+                closer = next;\n+            }\n+        }\n+\n+        \/\/ remove all delimiters\n+        while (lastDelimiter != null && lastDelimiter != stackBottom) {\n+            removeDelimiterKeepNode(lastDelimiter);\n+        }\n+    }\n+\n+    private void removeDelimitersBetween(Delimiter opener, Delimiter closer) {\n+        Delimiter delimiter = closer.previous;\n+        while (delimiter != null && delimiter != opener) {\n+            Delimiter previousDelimiter = delimiter.previous;\n+            removeDelimiterKeepNode(delimiter);\n+            delimiter = previousDelimiter;\n+        }\n+    }\n+\n+    \/**\n+     * Remove the delimiter and the corresponding text node. For used delimiters, e.g. `*` in `*foo*`.\n+     *\/\n+    private void removeDelimiterAndNodes(Delimiter delim) {\n+        removeDelimiter(delim);\n+    }\n+\n+    \/**\n+     * Remove the delimiter but keep the corresponding node as text. For unused delimiters such as `_` in `foo_bar`.\n+     *\/\n+    private void removeDelimiterKeepNode(Delimiter delim) {\n+        removeDelimiter(delim);\n+    }\n+\n+    private void removeDelimiter(Delimiter delim) {\n+        if (delim.previous != null) {\n+            delim.previous.next = delim.next;\n+        }\n+        if (delim.next == null) {\n+            \/\/ top of stack\n+            lastDelimiter = delim.previous;\n+        } else {\n+            delim.next.previous = delim.previous;\n+        }\n+    }\n+\n+    private void mergeChildTextNodes(Node node) {\n+        \/\/ No children, no need for merging\n+        if (node.getFirstChild() == null) {\n+            return;\n+        }\n+\n+        mergeTextNodesInclusive(node.getFirstChild(), node.getLastChild());\n+    }\n+\n+    private void mergeTextNodesInclusive(Node fromNode, Node toNode) {\n+        Text first = null;\n+        Text last = null;\n+        int length = 0;\n+\n+        Node node = fromNode;\n+        while (node != null) {\n+            if (node instanceof Text) {\n+                Text text = (Text) node;\n+                if (first == null) {\n+                    first = text;\n+                }\n+                length += text.getLiteral().length();\n+                last = text;\n+            } else {\n+                mergeIfNeeded(first, last, length);\n+                first = null;\n+                last = null;\n+                length = 0;\n+\n+                mergeChildTextNodes(node);\n+            }\n+            if (node == toNode) {\n+                break;\n+            }\n+            node = node.getNext();\n+        }\n+\n+        mergeIfNeeded(first, last, length);\n+    }\n+\n+    private void mergeIfNeeded(Text first, Text last, int textLength) {\n+        if (first != null && last != null && first != last) {\n+            StringBuilder sb = new StringBuilder(textLength);\n+            sb.append(first.getLiteral());\n+            SourceSpans sourceSpans = null;\n+            if (includeSourceSpans) {\n+                sourceSpans = new SourceSpans();\n+                sourceSpans.addAll(first.getSourceSpans());\n+            }\n+            Node node = first.getNext();\n+            Node stop = last.getNext();\n+            while (node != stop) {\n+                sb.append(((Text) node).getLiteral());\n+                if (sourceSpans != null) {\n+                    sourceSpans.addAll(node.getSourceSpans());\n+                }\n+\n+                Node unlink = node;\n+                node = node.getNext();\n+                unlink.unlink();\n+            }\n+            String literal = sb.toString();\n+            first.setLiteral(literal);\n+            if (sourceSpans != null) {\n+                first.setSourceSpans(sourceSpans.getSourceSpans());\n+            }\n+        }\n+    }\n+\n+    private static class DelimiterData {\n+\n+        final List<Text> characters;\n+        final boolean canClose;\n+        final boolean canOpen;\n+\n+        DelimiterData(List<Text> characters, boolean canOpen, boolean canClose) {\n+            this.characters = characters;\n+            this.canOpen = canOpen;\n+            this.canClose = canClose;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/InlineParserImpl.java","additions":787,"deletions":0,"binary":false,"changes":787,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.internal.util.LinkScanner;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Parser for link reference definitions at the beginning of a paragraph.\n+ *\n+ * @see <a href=\"https:\/\/spec.commonmark.org\/0.29\/#link-reference-definition\">Link reference definitions<\/a>\n+ *\/\n+public class LinkReferenceDefinitionParser {\n+\n+    private State state = State.START_DEFINITION;\n+\n+    private final List<SourceLine> paragraphLines = new ArrayList<>();\n+    private final List<LinkReferenceDefinition> definitions = new ArrayList<>();\n+    private final List<SourceSpan> sourceSpans = new ArrayList<>();\n+\n+    private StringBuilder label;\n+    private String destination;\n+    private char titleDelimiter;\n+    private StringBuilder title;\n+    private boolean referenceValid = false;\n+\n+    public void parse(SourceLine line) {\n+        paragraphLines.add(line);\n+        if (state == State.PARAGRAPH) {\n+            \/\/ We're in a paragraph now. Link reference definitions can only appear at the beginning, so once\n+            \/\/ we're in a paragraph, there's no going back.\n+            return;\n+        }\n+\n+        Scanner scanner = Scanner.of(SourceLines.of(line));\n+        while (scanner.hasNext()) {\n+            boolean success;\n+            switch (state) {\n+                case START_DEFINITION: {\n+                    success = startDefinition(scanner);\n+                    break;\n+                }\n+                case LABEL: {\n+                    success = label(scanner);\n+                    break;\n+                }\n+                case DESTINATION: {\n+                    success = destination(scanner);\n+                    break;\n+                }\n+                case START_TITLE: {\n+                    success = startTitle(scanner);\n+                    break;\n+                }\n+                case TITLE: {\n+                    success = title(scanner);\n+                    break;\n+                }\n+                default: {\n+                    throw new IllegalStateException(\"Unknown parsing state: \" + state);\n+                }\n+            }\n+            \/\/ Parsing failed, which means we fall back to treating text as a paragraph.\n+            if (!success) {\n+                state = State.PARAGRAPH;\n+                return;\n+            }\n+        }\n+    }\n+\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        sourceSpans.add(sourceSpan);\n+    }\n+\n+    \/**\n+     * @return the lines that are normal paragraph content, without newlines\n+     *\/\n+    SourceLines getParagraphLines() {\n+        return SourceLines.of(paragraphLines);\n+    }\n+\n+    List<SourceSpan> getParagraphSourceSpans() {\n+        return sourceSpans;\n+    }\n+\n+    List<LinkReferenceDefinition> getDefinitions() {\n+        finishReference();\n+        return definitions;\n+    }\n+\n+    State getState() {\n+        return state;\n+    }\n+\n+    private boolean startDefinition(Scanner scanner) {\n+        \/\/ Finish any outstanding references now. We don't do this earlier because we need addSourceSpan to have been\n+        \/\/ called before we do it.\n+        finishReference();\n+\n+        scanner.whitespace();\n+        if (!scanner.next('[')) {\n+            return false;\n+        }\n+\n+        state = State.LABEL;\n+        label = new StringBuilder();\n+\n+        if (!scanner.hasNext()) {\n+            label.append('\\n');\n+        }\n+        return true;\n+    }\n+\n+    private boolean label(Scanner scanner) {\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkLabelContent(scanner)) {\n+            return false;\n+        }\n+\n+        label.append(scanner.getSource(start, scanner.position()).getContent());\n+\n+        if (!scanner.hasNext()) {\n+            \/\/ label might continue on next line\n+            label.append('\\n');\n+            return true;\n+        } else if (scanner.next(']')) {\n+            \/\/ end of label\n+            if (!scanner.next(':')) {\n+                return false;\n+            }\n+\n+            \/\/ spec: A link label can have at most 999 characters inside the square brackets.\n+            if (label.length() > 999) {\n+                return false;\n+            }\n+\n+            String normalizedLabel = Escaping.normalizeLabelContent(label.toString());\n+            if (normalizedLabel.isEmpty()) {\n+                return false;\n+            }\n+\n+            state = State.DESTINATION;\n+\n+            scanner.whitespace();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private boolean destination(Scanner scanner) {\n+        scanner.whitespace();\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkDestination(scanner)) {\n+            return false;\n+        }\n+\n+        String rawDestination = scanner.getSource(start, scanner.position()).getContent();\n+        destination = rawDestination.startsWith(\"<\") ?\n+                rawDestination.substring(1, rawDestination.length() - 1) :\n+                rawDestination;\n+\n+        int whitespace = scanner.whitespace();\n+        if (!scanner.hasNext()) {\n+            \/\/ Destination was at end of line, so this is a valid reference for sure (and maybe a title).\n+            \/\/ If not at end of line, wait for title to be valid first.\n+            referenceValid = true;\n+            paragraphLines.clear();\n+        } else if (whitespace == 0) {\n+            \/\/ spec: The title must be separated from the link destination by whitespace\n+            return false;\n+        }\n+\n+        state = State.START_TITLE;\n+        return true;\n+    }\n+\n+    private boolean startTitle(Scanner scanner) {\n+        scanner.whitespace();\n+        if (!scanner.hasNext()) {\n+            state = State.START_DEFINITION;\n+            return true;\n+        }\n+\n+        titleDelimiter = '\\0';\n+        char c = scanner.peek();\n+        switch (c) {\n+            case '\"':\n+            case '\\'':\n+                titleDelimiter = c;\n+                break;\n+            case '(':\n+                titleDelimiter = ')';\n+                break;\n+        }\n+\n+        if (titleDelimiter != '\\0') {\n+            state = State.TITLE;\n+            title = new StringBuilder();\n+            scanner.next();\n+            if (!scanner.hasNext()) {\n+                title.append('\\n');\n+            }\n+        } else {\n+            \/\/ There might be another reference instead, try that for the same character.\n+            state = State.START_DEFINITION;\n+        }\n+        return true;\n+    }\n+\n+    private boolean title(Scanner scanner) {\n+        Position start = scanner.position();\n+        if (!LinkScanner.scanLinkTitleContent(scanner, titleDelimiter)) {\n+            \/\/ Invalid title, stop\n+            return false;\n+        }\n+\n+        title.append(scanner.getSource(start, scanner.position()).getContent());\n+\n+        if (!scanner.hasNext()) {\n+            \/\/ Title ran until the end of line, so continue on next line (until we find the delimiter)\n+            title.append('\\n');\n+            return true;\n+        }\n+\n+        \/\/ Skip delimiter character\n+        scanner.next();\n+        scanner.whitespace();\n+        if (scanner.hasNext()) {\n+            \/\/ spec: No further non-whitespace characters may occur on the line.\n+            return false;\n+        }\n+        referenceValid = true;\n+        paragraphLines.clear();\n+\n+        \/\/ See if there's another definition.\n+        state = State.START_DEFINITION;\n+        return true;\n+    }\n+\n+    private void finishReference() {\n+        if (!referenceValid) {\n+            return;\n+        }\n+\n+        String d = Escaping.unescapeString(destination);\n+        String t = title != null ? Escaping.unescapeString(title.toString()) : null;\n+        LinkReferenceDefinition definition = new LinkReferenceDefinition(label.toString(), d, t);\n+        definition.setSourceSpans(sourceSpans);\n+        sourceSpans.clear();\n+        definitions.add(definition);\n+\n+        label = null;\n+        referenceValid = false;\n+        destination = null;\n+        title = null;\n+    }\n+\n+    enum State {\n+        \/\/ Looking for the start of a definition, i.e. `[`\n+        START_DEFINITION,\n+        \/\/ Parsing the label, i.e. `foo` within `[foo]`\n+        LABEL,\n+        \/\/ Parsing the destination, i.e. `\/url` in `[foo]: \/url`\n+        DESTINATION,\n+        \/\/ Looking for the start of a title, i.e. the first `\"` in `[foo]: \/url \"title\"`\n+        START_TITLE,\n+        \/\/ Parsing the content of the title, i.e. `title` in `[foo]: \/url \"title\"`\n+        TITLE,\n+\n+        \/\/ End state, no matter what kind of lines we add, they won't be references\n+        PARAGRAPH,\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/LinkReferenceDefinitionParser.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+public class LinkReferenceDefinitions {\n+\n+    \/\/ LinkedHashMap for determinism and to preserve document order\n+    private final Map<String, LinkReferenceDefinition> definitions = new LinkedHashMap<>();\n+\n+    public void add(LinkReferenceDefinition definition) {\n+        String normalizedLabel = Escaping.normalizeLabelContent(definition.getLabel());\n+\n+        \/\/ spec: When there are multiple matching link reference definitions, the first is used\n+        if (!definitions.containsKey(normalizedLabel)) {\n+            definitions.put(normalizedLabel, definition);\n+        }\n+    }\n+\n+    public LinkReferenceDefinition get(String label) {\n+        String normalizedLabel = Escaping.normalizeLabelContent(label);\n+        return definitions.get(normalizedLabel);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/LinkReferenceDefinitions.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.internal.util.Parsing;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+import java.util.Objects;\n+\n+public class ListBlockParser extends AbstractBlockParser {\n+\n+    private final ListBlock block;\n+\n+    private boolean hadBlankLine;\n+    private int linesAfterBlank;\n+\n+    public ListBlockParser(ListBlock block) {\n+        this.block = block;\n+    }\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block childBlock) {\n+        if (childBlock instanceof ListItem) {\n+            \/\/ Another list item is added to this list block. If the previous line was blank, that means this list block\n+            \/\/ is \"loose\" (not tight).\n+            \/\/\n+            \/\/ spec: A list is loose if any of its constituent list items are separated by blank lines\n+            if (hadBlankLine && linesAfterBlank == 1) {\n+                block.setTight(false);\n+                hadBlankLine = false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (state.isBlank()) {\n+            hadBlankLine = true;\n+            linesAfterBlank = 0;\n+        } else if (hadBlankLine) {\n+            linesAfterBlank++;\n+        }\n+        \/\/ List blocks themselves don't have any markers, only list items. So try to stay in the list.\n+        \/\/ If there is a block start other than list item, canContain makes sure that this list is closed.\n+        return BlockContinue.atIndex(state.getIndex());\n+    }\n+\n+    \/**\n+     * Parse a list marker and return data on the marker or null.\n+     *\/\n+    private static ListData parseList(CharSequence line, final int markerIndex, final int markerColumn,\n+                                      final boolean inParagraph) {\n+        ListMarkerData listMarker = parseListMarker(line, markerIndex);\n+        if (listMarker == null) {\n+            return null;\n+        }\n+        ListBlock listBlock = listMarker.listBlock;\n+\n+        int indexAfterMarker = listMarker.indexAfterMarker;\n+        int markerLength = indexAfterMarker - markerIndex;\n+        \/\/ marker doesn't include tabs, so counting them as columns directly is ok\n+        int columnAfterMarker = markerColumn + markerLength;\n+        \/\/ the column within the line where the content starts\n+        int contentColumn = columnAfterMarker;\n+\n+        \/\/ See at which column the content starts if there is content\n+        boolean hasContent = false;\n+        int length = line.length();\n+        for (int i = indexAfterMarker; i < length; i++) {\n+            char c = line.charAt(i);\n+            if (c == '\\t') {\n+                contentColumn += Parsing.columnsToNextTabStop(contentColumn);\n+            } else if (c == ' ') {\n+                contentColumn++;\n+            } else {\n+                hasContent = true;\n+                break;\n+            }\n+        }\n+\n+        if (inParagraph) {\n+            \/\/ If the list item is ordered, the start number must be 1 to interrupt a paragraph.\n+            if (listBlock instanceof OrderedList && ((OrderedList) listBlock).getMarkerStartNumber() != 1) {\n+                return null;\n+            }\n+            \/\/ Empty list item can not interrupt a paragraph.\n+            if (!hasContent) {\n+                return null;\n+            }\n+        }\n+\n+        if (!hasContent || (contentColumn - columnAfterMarker) > Parsing.CODE_BLOCK_INDENT) {\n+            \/\/ If this line is blank or has a code block, default to 1 space after marker\n+            contentColumn = columnAfterMarker + 1;\n+        }\n+\n+        return new ListData(listBlock, contentColumn);\n+    }\n+\n+    private static ListMarkerData parseListMarker(CharSequence line, int index) {\n+        char c = line.charAt(index);\n+        switch (c) {\n+            \/\/ spec: A bullet list marker is a -, +, or * character.\n+            case '-':\n+            case '+':\n+            case '*':\n+                if (isSpaceTabOrEnd(line, index + 1)) {\n+                    BulletList bulletList = new BulletList();\n+                    bulletList.setMarker(String.valueOf(c));\n+                    return new ListMarkerData(bulletList, index + 1);\n+                } else {\n+                    return null;\n+                }\n+            default:\n+                return parseOrderedList(line, index);\n+        }\n+    }\n+\n+    \/\/ spec: An ordered list marker is a sequence of 1\\u20139 arabic digits (0-9), followed by either a `.` character or a\n+    \/\/ `)` character.\n+    private static ListMarkerData parseOrderedList(CharSequence line, int index) {\n+        int digits = 0;\n+        int length = line.length();\n+        for (int i = index; i < length; i++) {\n+            char c = line.charAt(i);\n+            switch (c) {\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    digits++;\n+                    if (digits > 9) {\n+                        return null;\n+                    }\n+                    break;\n+                case '.':\n+                case ')':\n+                    if (digits >= 1 && isSpaceTabOrEnd(line, i + 1)) {\n+                        String number = line.subSequence(index, i).toString();\n+                        OrderedList orderedList = new OrderedList();\n+                        orderedList.setMarkerStartNumber(Integer.parseInt(number));\n+                        orderedList.setMarkerDelimiter(String.valueOf(c));\n+                        return new ListMarkerData(orderedList, i + 1);\n+                    } else {\n+                        return null;\n+                    }\n+                default:\n+                    return null;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isSpaceTabOrEnd(CharSequence line, int index) {\n+        if (index < line.length()) {\n+            switch (line.charAt(index)) {\n+                case ' ':\n+                case '\\t':\n+                    return true;\n+                default:\n+                    return false;\n+            }\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if the two list items are of the same type,\n+     * with the same delimiter and bullet character. This is used\n+     * in agglomerating list items into lists.\n+     *\/\n+    private static boolean listsMatch(ListBlock a, ListBlock b) {\n+        if (a instanceof BulletList && b instanceof BulletList) {\n+            return Objects.equals(((BulletList) a).getMarker(), ((BulletList) b).getMarker());\n+        } else if (a instanceof OrderedList && b instanceof OrderedList) {\n+            return Objects.equals(((OrderedList) a).getMarkerDelimiter(), ((OrderedList) b).getMarkerDelimiter());\n+        }\n+        return false;\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            BlockParser matched = matchedBlockParser.getMatchedBlockParser();\n+\n+            if (state.getIndent() >= Parsing.CODE_BLOCK_INDENT) {\n+                return BlockStart.none();\n+            }\n+            int markerIndex = state.getNextNonSpaceIndex();\n+            int markerColumn = state.getColumn() + state.getIndent();\n+            boolean inParagraph = !matchedBlockParser.getParagraphLines().isEmpty();\n+            ListData listData = parseList(state.getLine().getContent(), markerIndex, markerColumn, inParagraph);\n+            if (listData == null) {\n+                return BlockStart.none();\n+            }\n+\n+            int newColumn = listData.contentColumn;\n+            ListItemParser listItemParser = new ListItemParser(state.getIndent(), newColumn - state.getColumn());\n+\n+            \/\/ prepend the list block if needed\n+            if (!(matched instanceof ListBlockParser) ||\n+                    !(listsMatch((ListBlock) matched.getBlock(), listData.listBlock))) {\n+\n+                ListBlockParser listBlockParser = new ListBlockParser(listData.listBlock);\n+                \/\/ We start out with assuming a list is tight. If we find a blank line, we set it to loose later.\n+                listData.listBlock.setTight(true);\n+\n+                return BlockStart.of(listBlockParser, listItemParser).atColumn(newColumn);\n+            } else {\n+                return BlockStart.of(listItemParser).atColumn(newColumn);\n+            }\n+        }\n+    }\n+\n+    private static class ListData {\n+        final ListBlock listBlock;\n+        final int contentColumn;\n+\n+        ListData(ListBlock listBlock, int contentColumn) {\n+            this.listBlock = listBlock;\n+            this.contentColumn = contentColumn;\n+        }\n+    }\n+\n+    private static class ListMarkerData {\n+        final ListBlock listBlock;\n+        final int indexAfterMarker;\n+\n+        ListMarkerData(ListBlock listBlock, int indexAfterMarker) {\n+            this.listBlock = listBlock;\n+            this.indexAfterMarker = indexAfterMarker;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ListBlockParser.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.ListBlock;\n+import jdk.internal.org.commonmark.node.ListItem;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.parser.block.AbstractBlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+import jdk.internal.org.commonmark.parser.block.ParserState;\n+\n+public class ListItemParser extends AbstractBlockParser {\n+\n+    private final ListItem block = new ListItem();\n+\n+    \/**\n+     * Minimum number of columns that the content has to be indented (relative to the containing block) to be part of\n+     * this list item.\n+     *\/\n+    private int contentIndent;\n+\n+    private boolean hadBlankLine;\n+\n+    public ListItemParser(int markerIndent, int contentIndent) {\n+        this.contentIndent = contentIndent;\n+        block.setMarkerIndent(markerIndent);\n+        block.setContentIndent(contentIndent);\n+    }\n+\n+    @Override\n+    public boolean isContainer() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block childBlock) {\n+        if (hadBlankLine) {\n+            \/\/ We saw a blank line in this list item, that means the list block is loose.\n+            \/\/\n+            \/\/ spec: if any of its constituent list items directly contain two block-level elements with a blank line\n+            \/\/ between them\n+            Block parent = block.getParent();\n+            if (parent instanceof ListBlock) {\n+                ((ListBlock) parent).setTight(false);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (state.isBlank()) {\n+            if (block.getFirstChild() == null) {\n+                \/\/ Blank line after empty list item\n+                return BlockContinue.none();\n+            } else {\n+                Block activeBlock = state.getActiveBlockParser().getBlock();\n+                \/\/ If the active block is a code block, blank lines in it should not affect if the list is tight.\n+                hadBlankLine = activeBlock instanceof Paragraph || activeBlock instanceof ListItem;\n+                return BlockContinue.atIndex(state.getNextNonSpaceIndex());\n+            }\n+        }\n+\n+        if (state.getIndent() >= contentIndent) {\n+            return BlockContinue.atColumn(state.getColumn() + contentIndent);\n+        } else {\n+            \/\/ Note: We'll hit this case for lazy continuation lines, they will get added later.\n+            return BlockContinue.none();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ListItemParser.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.block.AbstractBlockParser;\n+import jdk.internal.org.commonmark.parser.block.BlockContinue;\n+import jdk.internal.org.commonmark.parser.block.ParserState;\n+\n+import java.util.List;\n+\n+public class ParagraphParser extends AbstractBlockParser {\n+\n+    private final Paragraph block = new Paragraph();\n+    private final LinkReferenceDefinitionParser linkReferenceDefinitionParser = new LinkReferenceDefinitionParser();\n+\n+    @Override\n+    public boolean canHaveLazyContinuationLines() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        if (!state.isBlank()) {\n+            return BlockContinue.atIndex(state.getIndex());\n+        } else {\n+            return BlockContinue.none();\n+        }\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+        linkReferenceDefinitionParser.parse(line);\n+    }\n+\n+    @Override\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        \/\/ Some source spans might belong to link reference definitions, others to the paragraph.\n+        \/\/ The parser will handle that.\n+        linkReferenceDefinitionParser.addSourceSpan(sourceSpan);\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+        if (linkReferenceDefinitionParser.getParagraphLines().isEmpty()) {\n+            block.unlink();\n+        } else {\n+            block.setSourceSpans(linkReferenceDefinitionParser.getParagraphSourceSpans());\n+        }\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+        SourceLines lines = linkReferenceDefinitionParser.getParagraphLines();\n+        if (!lines.isEmpty()) {\n+            inlineParser.parse(lines, block);\n+        }\n+    }\n+\n+    public SourceLines getParagraphLines() {\n+        return linkReferenceDefinitionParser.getParagraphLines();\n+    }\n+\n+    public List<LinkReferenceDefinition> getDefinitions() {\n+        return linkReferenceDefinitionParser.getDefinitions();\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ParagraphParser.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterRun;\n+\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+\/**\n+ * An implementation of DelimiterProcessor that dispatches all calls to two or more other DelimiterProcessors\n+ * depending on the length of the delimiter run. All child DelimiterProcessors must have different minimum\n+ * lengths. A given delimiter run is dispatched to the child with the largest acceptable minimum length. If no\n+ * child is applicable, the one with the largest minimum length is chosen.\n+ *\/\n+class StaggeredDelimiterProcessor implements DelimiterProcessor {\n+\n+    private final char delim;\n+    private int minLength = 0;\n+    private LinkedList<DelimiterProcessor> processors = new LinkedList<>(); \/\/ in reverse getMinLength order\n+\n+    StaggeredDelimiterProcessor(char delim) {\n+        this.delim = delim;\n+    }\n+\n+\n+    @Override\n+    public char getOpeningCharacter() {\n+        return delim;\n+    }\n+\n+    @Override\n+    public char getClosingCharacter() {\n+        return delim;\n+    }\n+\n+    @Override\n+    public int getMinLength() {\n+        return minLength;\n+    }\n+\n+    void add(DelimiterProcessor dp) {\n+        final int len = dp.getMinLength();\n+        ListIterator<DelimiterProcessor> it = processors.listIterator();\n+        boolean added = false;\n+        while (it.hasNext()) {\n+            DelimiterProcessor p = it.next();\n+            int pLen = p.getMinLength();\n+            if (len > pLen) {\n+                it.previous();\n+                it.add(dp);\n+                added = true;\n+                break;\n+            } else if (len == pLen) {\n+                throw new IllegalArgumentException(\"Cannot add two delimiter processors for char '\" + delim + \"' and minimum length \" + len + \"; conflicting processors: \" + p + \", \" + dp);\n+            }\n+        }\n+        if (!added) {\n+            processors.add(dp);\n+            this.minLength = len;\n+        }\n+    }\n+\n+    private DelimiterProcessor findProcessor(int len) {\n+        for (DelimiterProcessor p : processors) {\n+            if (p.getMinLength() <= len) {\n+                return p;\n+            }\n+        }\n+        return processors.getFirst();\n+    }\n+\n+    @Override\n+    public int process(DelimiterRun openingRun, DelimiterRun closingRun) {\n+        return findProcessor(openingRun.length()).process(openingRun, closingRun);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/StaggeredDelimiterProcessor.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.ThematicBreak;\n+import jdk.internal.org.commonmark.parser.block.*;\n+\n+public class ThematicBreakParser extends AbstractBlockParser {\n+\n+    private final ThematicBreak block = new ThematicBreak();\n+\n+    public ThematicBreakParser(String literal) {\n+        block.setLiteral(literal);\n+    }\n+\n+    @Override\n+    public Block getBlock() {\n+        return block;\n+    }\n+\n+    @Override\n+    public BlockContinue tryContinue(ParserState state) {\n+        \/\/ a horizontal rule can never container > 1 line, so fail to match\n+        return BlockContinue.none();\n+    }\n+\n+    public static class Factory extends AbstractBlockParserFactory {\n+\n+        @Override\n+        public BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser) {\n+            if (state.getIndent() >= 4) {\n+                return BlockStart.none();\n+            }\n+            int nextNonSpace = state.getNextNonSpaceIndex();\n+            CharSequence line = state.getLine().getContent();\n+            if (isThematicBreak(line, nextNonSpace)) {\n+                var literal = String.valueOf(line.subSequence(state.getIndex(), line.length()));\n+                return BlockStart.of(new ThematicBreakParser(literal)).atIndex(line.length());\n+            } else {\n+                return BlockStart.none();\n+            }\n+        }\n+    }\n+\n+    \/\/ spec: A line consisting of 0-3 spaces of indentation, followed by a sequence of three or more matching -, _, or *\n+    \/\/ characters, each followed optionally by any number of spaces, forms a thematic break.\n+    private static boolean isThematicBreak(CharSequence line, int index) {\n+        int dashes = 0;\n+        int underscores = 0;\n+        int asterisks = 0;\n+        int length = line.length();\n+        for (int i = index; i < length; i++) {\n+            switch (line.charAt(i)) {\n+                case '-':\n+                    dashes++;\n+                    break;\n+                case '_':\n+                    underscores++;\n+                    break;\n+                case '*':\n+                    asterisks++;\n+                    break;\n+                case ' ':\n+                case '\\t':\n+                    \/\/ Allowed, even between markers\n+                    break;\n+                default:\n+                    return false;\n+            }\n+        }\n+\n+        return ((dashes >= 3 && underscores == 0 && asterisks == 0) ||\n+                (underscores >= 3 && dashes == 0 && asterisks == 0) ||\n+                (asterisks >= 3 && dashes == 0 && underscores == 0));\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/ThematicBreakParser.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+public class AsteriskDelimiterProcessor extends EmphasisDelimiterProcessor {\n+\n+    public AsteriskDelimiterProcessor() {\n+        super('*');\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/AsteriskDelimiterProcessor.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Attempt to parse an autolink (URL or email in pointy brackets).\n+ *\/\n+public class AutolinkInlineParser implements InlineContentParser {\n+\n+    private static final Pattern URI = Pattern\n+            .compile(\"^[a-zA-Z][a-zA-Z0-9.+-]{1,31}:[^<>\\u0000-\\u0020]*$\");\n+\n+    private static final Pattern EMAIL = Pattern\n+            .compile(\"^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$\");\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        scanner.next();\n+        Position textStart = scanner.position();\n+        if (scanner.find('>') > 0) {\n+            SourceLines textSource = scanner.getSource(textStart, scanner.position());\n+            String content = textSource.getContent();\n+            scanner.next();\n+\n+            String destination = null;\n+            if (URI.matcher(content).matches()) {\n+                destination = content;\n+            } else if (EMAIL.matcher(content).matches()) {\n+                destination = \"mailto:\" + content;\n+            }\n+\n+            if (destination != null) {\n+                Link link = new Link(destination, null);\n+                Text text = new Text(content);\n+                text.setSourceSpans(textSource.getSourceSpans());\n+                link.appendChild(text);\n+                return ParsedInline.of(link, scanner.position());\n+            }\n+        }\n+        return ParsedInline.none();\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/AutolinkInlineParser.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.node.HardLineBreak;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Parse a backslash-escaped special character, adding either the escaped  character, a hard line break\n+ * (if the backslash is followed by a newline), or a literal backslash to the block's children.\n+ *\/\n+public class BackslashInlineParser implements InlineContentParser {\n+\n+    private static final Pattern ESCAPABLE = Pattern.compile('^' + Escaping.ESCAPABLE);\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        \/\/ Backslash\n+        scanner.next();\n+\n+        char next = scanner.peek();\n+        if (next == '\\n') {\n+            scanner.next();\n+            return ParsedInline.of(new HardLineBreak(), scanner.position());\n+        } else if (ESCAPABLE.matcher(String.valueOf(next)).matches()) {\n+            scanner.next();\n+            return ParsedInline.of(new Text(String.valueOf(next)), scanner.position());\n+        } else {\n+            return ParsedInline.of(new Text(\"\\\\\"), scanner.position());\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/BackslashInlineParser.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.Code;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+\/**\n+ * Attempt to parse backticks, returning either a backtick code span or a literal sequence of backticks.\n+ *\/\n+public class BackticksInlineParser implements InlineContentParser {\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        Position start = scanner.position();\n+        int openingTicks = scanner.matchMultiple('`');\n+        Position afterOpening = scanner.position();\n+\n+        while (scanner.find('`') > 0) {\n+            Position beforeClosing = scanner.position();\n+            int count = scanner.matchMultiple('`');\n+            if (count == openingTicks) {\n+                Code node = new Code();\n+\n+                String content = scanner.getSource(afterOpening, beforeClosing).getContent();\n+                content = content.replace('\\n', ' ');\n+\n+                \/\/ spec: If the resulting string both begins and ends with a space character, but does not consist\n+                \/\/ entirely of space characters, a single space character is removed from the front and back.\n+                if (content.length() >= 3 &&\n+                        content.charAt(0) == ' ' &&\n+                        content.charAt(content.length() - 1) == ' ' &&\n+                        Characters.hasNonSpace(content)) {\n+                    content = content.substring(1, content.length() - 1);\n+                }\n+\n+                node.setLiteral(content);\n+                return ParsedInline.of(node, scanner.position());\n+            }\n+        }\n+\n+        \/\/ If we got here, we didn't find a matching closing backtick sequence.\n+        SourceLines source = scanner.getSource(start, afterOpening);\n+        Text text = new Text(source.getContent());\n+        return ParsedInline.of(text, afterOpening);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/BackticksInlineParser.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterRun;\n+\n+public abstract class EmphasisDelimiterProcessor implements DelimiterProcessor {\n+\n+    private final char delimiterChar;\n+\n+    protected EmphasisDelimiterProcessor(char delimiterChar) {\n+        this.delimiterChar = delimiterChar;\n+    }\n+\n+    @Override\n+    public char getOpeningCharacter() {\n+        return delimiterChar;\n+    }\n+\n+    @Override\n+    public char getClosingCharacter() {\n+        return delimiterChar;\n+    }\n+\n+    @Override\n+    public int getMinLength() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public int process(DelimiterRun openingRun, DelimiterRun closingRun) {\n+        \/\/ \"multiple of 3\" rule for internal delimiter runs\n+        if ((openingRun.canClose() || closingRun.canOpen()) &&\n+                closingRun.originalLength() % 3 != 0 &&\n+                (openingRun.originalLength() + closingRun.originalLength()) % 3 == 0) {\n+            return 0;\n+        }\n+\n+        int usedDelimiters;\n+        Node emphasis;\n+        \/\/ calculate actual number of delimiters used from this closer\n+        if (openingRun.length() >= 2 && closingRun.length() >= 2) {\n+            usedDelimiters = 2;\n+            emphasis = new StrongEmphasis(String.valueOf(delimiterChar) + delimiterChar);\n+        } else {\n+            usedDelimiters = 1;\n+            emphasis = new Emphasis(String.valueOf(delimiterChar));\n+        }\n+\n+        SourceSpans sourceSpans = SourceSpans.empty();\n+        sourceSpans.addAllFrom(openingRun.getOpeners(usedDelimiters));\n+\n+        Text opener = openingRun.getOpener();\n+        for (Node node : Nodes.between(opener, closingRun.getCloser())) {\n+            emphasis.appendChild(node);\n+            sourceSpans.addAll(node.getSourceSpans());\n+        }\n+\n+        sourceSpans.addAllFrom(closingRun.getClosers(usedDelimiters));\n+\n+        emphasis.setSourceSpans(sourceSpans.getSourceSpans());\n+        opener.insertAfter(emphasis);\n+\n+        return usedDelimiters;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/EmphasisDelimiterProcessor.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n+import jdk.internal.org.commonmark.internal.util.Html5Entities;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n+\/**\n+ * Attempts to parse a HTML entity or numeric character reference.\n+ *\/\n+public class EntityInlineParser implements InlineContentParser {\n+\n+    private static final AsciiMatcher hex = AsciiMatcher.builder().range('0', '9').range('A', 'F').range('a', 'f').build();\n+    private static final AsciiMatcher dec = AsciiMatcher.builder().range('0', '9').build();\n+    private static final AsciiMatcher entityStart = AsciiMatcher.builder().range('A', 'Z').range('a', 'z').build();\n+    private static final AsciiMatcher entityContinue = entityStart.newBuilder().range('0', '9').build();\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        Position start = scanner.position();\n+        \/\/ Skip `&`\n+        scanner.next();\n+\n+        char c = scanner.peek();\n+        if (c == '#') {\n+            \/\/ Numeric\n+            scanner.next();\n+            if (scanner.next('x') || scanner.next('X')) {\n+                int digits = scanner.match(hex);\n+                if (1 <= digits && digits <= 6 && scanner.next(';')) {\n+                    return entity(scanner, start);\n+                }\n+            } else {\n+                int digits = scanner.match(dec);\n+                if (1 <= digits && digits <= 7 && scanner.next(';')) {\n+                    return entity(scanner, start);\n+                }\n+            }\n+        } else if (entityStart.matches(c)) {\n+            scanner.match(entityContinue);\n+            if (scanner.next(';')) {\n+                return entity(scanner, start);\n+            }\n+        }\n+\n+        return ParsedInline.none();\n+    }\n+\n+    private ParsedInline entity(Scanner scanner, Position start) {\n+        String text = scanner.getSource(start, scanner.position()).getContent();\n+        return ParsedInline.of(new Text(Html5Entities.entityToString(text)), scanner.position());\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/EntityInlineParser.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n+import jdk.internal.org.commonmark.node.HtmlInline;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n+\/**\n+ * Attempt to parse inline HTML.\n+ *\/\n+public class HtmlInlineParser implements InlineContentParser {\n+\n+    private static final AsciiMatcher asciiLetter = AsciiMatcher.builder().range('A', 'Z').range('a', 'z').build();\n+\n+    \/\/ spec: A tag name consists of an ASCII letter followed by zero or more ASCII letters, digits, or hyphens (-).\n+    private static final AsciiMatcher tagNameStart = asciiLetter;\n+    private static final AsciiMatcher tagNameContinue = tagNameStart.newBuilder().range('0', '9').c('-').build();\n+\n+    \/\/ spec: An attribute name consists of an ASCII letter, _, or :, followed by zero or more ASCII letters, digits,\n+    \/\/ _, ., :, or -. (Note: This is the XML specification restricted to ASCII. HTML5 is laxer.)\n+    private static final AsciiMatcher attributeStart = asciiLetter.newBuilder().c('_').c(':').build();\n+    private static final AsciiMatcher attributeContinue = attributeStart.newBuilder().range('0', '9').c('.').c('-').build();\n+    \/\/ spec: An unquoted attribute value is a nonempty string of characters not including whitespace, \", ', =, <, >, or `.\n+    private static final AsciiMatcher attributeValueEnd = AsciiMatcher.builder()\n+            .c(' ').c('\\t').c('\\n').c('\\u000B').c('\\f').c('\\r')\n+            .c('\"').c('\\'').c('=').c('<').c('>').c('`')\n+            .build();\n+\n+    @Override\n+    public ParsedInline tryParse(InlineParserState inlineParserState) {\n+        Scanner scanner = inlineParserState.scanner();\n+        Position start = scanner.position();\n+        \/\/ Skip over `<`\n+        scanner.next();\n+\n+        char c = scanner.peek();\n+        if (tagNameStart.matches(c)) {\n+            if (tryOpenTag(scanner)) {\n+                return htmlInline(start, scanner);\n+            }\n+        } else if (c == '\/') {\n+            if (tryClosingTag(scanner)) {\n+                return htmlInline(start, scanner);\n+            }\n+        } else if (c == '?') {\n+            if (tryProcessingInstruction(scanner)) {\n+                return htmlInline(start, scanner);\n+            }\n+        } else if (c == '!') {\n+            \/\/ comment, declaration or CDATA\n+            scanner.next();\n+            c = scanner.peek();\n+            if (c == '-') {\n+                if (tryComment(scanner)) {\n+                    return htmlInline(start, scanner);\n+                }\n+            } else if (c == '[') {\n+                if (tryCdata(scanner)) {\n+                    return htmlInline(start, scanner);\n+                }\n+            } else if (asciiLetter.matches(c)) {\n+                if (tryDeclaration(scanner)) {\n+                    return htmlInline(start, scanner);\n+                }\n+            }\n+        }\n+\n+        return ParsedInline.none();\n+    }\n+\n+    private static ParsedInline htmlInline(Position start, Scanner scanner) {\n+        String text = scanner.getSource(start, scanner.position()).getContent();\n+        HtmlInline node = new HtmlInline();\n+        node.setLiteral(text);\n+        return ParsedInline.of(node, scanner.position());\n+    }\n+\n+    private static boolean tryOpenTag(Scanner scanner) {\n+        \/\/ spec: An open tag consists of a < character, a tag name, zero or more attributes, optional whitespace,\n+        \/\/ an optional \/ character, and a > character.\n+        scanner.next();\n+        scanner.match(tagNameContinue);\n+        boolean whitespace = scanner.whitespace() >= 1;\n+        \/\/ spec: An attribute consists of whitespace, an attribute name, and an optional attribute value specification.\n+        while (whitespace && scanner.match(attributeStart) >= 1) {\n+            scanner.match(attributeContinue);\n+            \/\/ spec: An attribute value specification consists of optional whitespace, a = character,\n+            \/\/ optional whitespace, and an attribute value.\n+            whitespace = scanner.whitespace() >= 1;\n+            if (scanner.next('=')) {\n+                scanner.whitespace();\n+                char valueStart = scanner.peek();\n+                if (valueStart == '\\'') {\n+                    scanner.next();\n+                    if (scanner.find('\\'') < 0) {\n+                        return false;\n+                    }\n+                    scanner.next();\n+                } else if (valueStart == '\"') {\n+                    scanner.next();\n+                    if (scanner.find('\"') < 0) {\n+                        return false;\n+                    }\n+                    scanner.next();\n+                } else {\n+                    if (scanner.find(attributeValueEnd) <= 0) {\n+                        return false;\n+                    }\n+                }\n+\n+                \/\/ Whitespace is required between attributes\n+                whitespace = scanner.whitespace() >= 1;\n+            }\n+        }\n+\n+        scanner.next('\/');\n+        return scanner.next('>');\n+    }\n+\n+    private static boolean tryClosingTag(Scanner scanner) {\n+        \/\/ spec: A closing tag consists of the string <\/, a tag name, optional whitespace, and the character >.\n+        scanner.next();\n+        if (scanner.match(tagNameStart) >= 1) {\n+            scanner.match(tagNameContinue);\n+            scanner.whitespace();\n+            return scanner.next('>');\n+        }\n+        return false;\n+    }\n+\n+    private static boolean tryProcessingInstruction(Scanner scanner) {\n+        \/\/ spec: A processing instruction consists of the string <?, a string of characters not including the string ?>,\n+        \/\/ and the string ?>.\n+        scanner.next();\n+        while (scanner.find('?') > 0) {\n+            scanner.next();\n+            if (scanner.next('>')) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean tryComment(Scanner scanner) {\n+        \/\/ spec: An [HTML comment](@) consists of `<!-->`, `<!--->`, or  `<!--`, a string of\n+        \/\/ characters not including the string `-->`, and `-->` (see the\n+        \/\/ [HTML spec](https:\/\/html.spec.whatwg.org\/multipage\/parsing.html#markup-declaration-open-state)).\n+\n+        \/\/ Skip first `-`\n+        scanner.next();\n+        if (!scanner.next('-')) {\n+            return false;\n+        }\n+\n+        if (scanner.next('>') || scanner.next(\"->\")) {\n+            return true;\n+        }\n+\n+        while (scanner.find('-') >= 0) {\n+            if (scanner.next(\"-->\")) {\n+                return true;\n+            } else {\n+                scanner.next();\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private static boolean tryCdata(Scanner scanner) {\n+        \/\/ spec: A CDATA section consists of the string <![CDATA[, a string of characters not including the string ]]>,\n+        \/\/ and the string ]]>.\n+\n+        \/\/ Skip `[`\n+        scanner.next();\n+\n+        if (scanner.next(\"CDATA[\")) {\n+            while (scanner.find(']') >= 0) {\n+                if (scanner.next(\"]]>\")) {\n+                    return true;\n+                } else {\n+                    scanner.next();\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private static boolean tryDeclaration(Scanner scanner) {\n+        \/\/ spec: A declaration consists of the string <!, an ASCII letter, zero or more characters not including\n+        \/\/ the character >, and the character >.\n+        scanner.match(asciiLetter);\n+        if (scanner.whitespace() <= 0) {\n+            return false;\n+        }\n+        if (scanner.find('>') >= 0) {\n+            scanner.next();\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/HtmlInlineParser.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+public interface InlineContentParser {\n+\n+    ParsedInline tryParse(InlineParserState inlineParserState);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/InlineContentParser.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n+public interface InlineParserState {\n+\n+    \/**\n+     * Return a scanner for the input for the current position (on the character that the inline parser registered\n+     * interest for).\n+     * <p>\n+     * Note that this always returns the same instance, if you want to backtrack you need to use\n+     * {@link Scanner#position()} and {@link Scanner#setPosition(Position)}.\n+     *\/\n+    Scanner scanner();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/InlineParserState.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+\n+public abstract class ParsedInline {\n+\n+    protected ParsedInline() {\n+    }\n+\n+    public static ParsedInline none() {\n+        return null;\n+    }\n+\n+    public static ParsedInline of(Node node, Position position) {\n+        if (node == null) {\n+            throw new NullPointerException(\"node must not be null\");\n+        }\n+        if (position == null) {\n+            throw new NullPointerException(\"position must not be null\");\n+        }\n+        return new ParsedInlineImpl(node, position);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/ParsedInline.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.parser.beta.Position;\n+\n+public class ParsedInlineImpl extends ParsedInline {\n+    private final Node node;\n+    private final Position position;\n+\n+    ParsedInlineImpl(Node node, Position position) {\n+        this.node = node;\n+        this.position = position;\n+    }\n+\n+    public Node getNode() {\n+        return node;\n+    }\n+\n+    public Position getPosition() {\n+        return position;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/ParsedInlineImpl.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+\/**\n+ * Position within a {@link Scanner}. This is intentionally kept opaque so as not to expose the internal structure of\n+ * the Scanner.\n+ *\/\n+public class Position {\n+\n+    final int lineIndex;\n+    final int index;\n+\n+    Position(int lineIndex, int index) {\n+        this.lineIndex = lineIndex;\n+        this.index = index;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/Position.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+import jdk.internal.org.commonmark.internal.util.CharMatcher;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+\n+import java.util.List;\n+\n+public class Scanner {\n+\n+    \/**\n+     * Character representing the end of input source (or outside of the text in case of the \"previous\" methods).\n+     * <p>\n+     * Note that we can use NULL to represent this because CommonMark does not allow those in the input (we replace them\n+     * in the beginning of parsing).\n+     *\/\n+    public static final char END = '\\0';\n+\n+    \/\/ Lines without newlines at the end. The scanner will yield `\\n` between lines because they're significant for\n+    \/\/ parsing and the final output. There is no `\\n` after the last line.\n+    private final List<SourceLine> lines;\n+    \/\/ Which line we're at.\n+    private int lineIndex;\n+    \/\/ The index within the line. If index == length(), we pretend that there's a `\\n` and only advance after we yield\n+    \/\/ that.\n+    private int index;\n+\n+    \/\/ Current line or \"\" if at the end of the lines (using \"\" instead of null saves a null check)\n+    private SourceLine line = SourceLine.of(\"\", null);\n+    private int lineLength = 0;\n+\n+    Scanner(List<SourceLine> lines, int lineIndex, int index) {\n+        this.lines = lines;\n+        this.lineIndex = lineIndex;\n+        this.index = index;\n+        if (!lines.isEmpty()) {\n+            checkPosition(lineIndex, index);\n+            setLine(lines.get(lineIndex));\n+        }\n+    }\n+\n+    public static Scanner of(SourceLines lines) {\n+        return new Scanner(lines.getLines(), 0, 0);\n+    }\n+\n+    public char peek() {\n+        if (index < lineLength) {\n+            return line.getContent().charAt(index);\n+        } else {\n+            if (lineIndex < lines.size() - 1) {\n+                return '\\n';\n+            } else {\n+                \/\/ Don't return newline for end of last line\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public int peekCodePoint() {\n+        if (index < lineLength) {\n+            char c = line.getContent().charAt(index);\n+            if (Character.isHighSurrogate(c) && index + 1 < lineLength) {\n+                char low = line.getContent().charAt(index + 1);\n+                if (Character.isLowSurrogate(low)) {\n+                    return Character.toCodePoint(c, low);\n+                }\n+            }\n+            return c;\n+        } else {\n+            if (lineIndex < lines.size() - 1) {\n+                return '\\n';\n+            } else {\n+                \/\/ Don't return newline for end of last line\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public int peekPreviousCodePoint() {\n+        if (index > 0) {\n+            int prev = index - 1;\n+            char c = line.getContent().charAt(prev);\n+            if (Character.isLowSurrogate(c) && prev > 0) {\n+                char high = line.getContent().charAt(prev - 1);\n+                if (Character.isHighSurrogate(high)) {\n+                    return Character.toCodePoint(high, c);\n+                }\n+            }\n+            return c;\n+        } else {\n+            if (lineIndex > 0) {\n+                return '\\n';\n+            } else {\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public boolean hasNext() {\n+        if (index < lineLength) {\n+            return true;\n+        } else {\n+            \/\/ No newline at end of last line\n+            return lineIndex < lines.size() - 1;\n+        }\n+    }\n+\n+    public void next() {\n+        index++;\n+        if (index > lineLength) {\n+            lineIndex++;\n+            if (lineIndex < lines.size()) {\n+                setLine(lines.get(lineIndex));\n+            } else {\n+                setLine(SourceLine.of(\"\", null));\n+            }\n+            index = 0;\n+        }\n+    }\n+\n+    \/**\n+     * Check if the specified char is next and advance the position.\n+     *\n+     * @param c the char to check (including newline characters)\n+     * @return true if matched and position was advanced, false otherwise\n+     *\/\n+    public boolean next(char c) {\n+        if (peek() == c) {\n+            next();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Check if we have the specified content on the line and advanced the position. Note that if you want to match\n+     * newline characters, use {@link #next(char)}.\n+     *\n+     * @param content the text content to match on a single line (excluding newline characters)\n+     * @return true if matched and position was advanced, false otherwise\n+     *\/\n+    public boolean next(String content) {\n+        if (index < lineLength && index + content.length() <= lineLength) {\n+            \/\/ Can't use startsWith because it's not available on CharSequence\n+            for (int i = 0; i < content.length(); i++) {\n+                if (line.getContent().charAt(index + i) != content.charAt(i)) {\n+                    return false;\n+                }\n+            }\n+            index += content.length();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int matchMultiple(char c) {\n+        int count = 0;\n+        while (peek() == c) {\n+            count++;\n+            next();\n+        }\n+        return count;\n+    }\n+\n+    public int match(CharMatcher matcher) {\n+        int count = 0;\n+        while (matcher.matches(peek())) {\n+            count++;\n+            next();\n+        }\n+        return count;\n+    }\n+\n+    public int whitespace() {\n+        int count = 0;\n+        while (true) {\n+            switch (peek()) {\n+                case ' ':\n+                case '\\t':\n+                case '\\n':\n+                case '\\u000B':\n+                case '\\f':\n+                case '\\r':\n+                    count++;\n+                    next();\n+                    break;\n+                default:\n+                    return count;\n+            }\n+        }\n+    }\n+\n+    public int find(char c) {\n+        int count = 0;\n+        while (true) {\n+            char cur = peek();\n+            if (cur == Scanner.END) {\n+                return -1;\n+            } else if (cur == c) {\n+                return count;\n+            }\n+            count++;\n+            next();\n+        }\n+    }\n+\n+    public int find(CharMatcher matcher) {\n+        int count = 0;\n+        while (true) {\n+            char c = peek();\n+            if (c == END) {\n+                return -1;\n+            } else if (matcher.matches(c)) {\n+                return count;\n+            }\n+            count++;\n+            next();\n+        }\n+    }\n+\n+    \/\/ Don't expose the int index, because it would be good if we could switch input to a List<String> of lines later\n+    \/\/ instead of one contiguous String.\n+    public Position position() {\n+        return new Position(lineIndex, index);\n+    }\n+\n+    public void setPosition(Position position) {\n+        checkPosition(position.lineIndex, position.index);\n+        this.lineIndex = position.lineIndex;\n+        this.index = position.index;\n+        setLine(lines.get(this.lineIndex));\n+    }\n+\n+    \/\/ For cases where the caller appends the result to a StringBuilder, we could offer another method to avoid some\n+    \/\/ unnecessary copying.\n+    public SourceLines getSource(Position begin, Position end) {\n+        if (begin.lineIndex == end.lineIndex) {\n+            \/\/ Shortcut for common case of text from a single line\n+            SourceLine line = lines.get(begin.lineIndex);\n+            CharSequence newContent = line.getContent().subSequence(begin.index, end.index);\n+            SourceSpan newSourceSpan = null;\n+            SourceSpan sourceSpan = line.getSourceSpan();\n+            if (sourceSpan != null) {\n+                newSourceSpan = SourceSpan.of(sourceSpan.getLineIndex(), sourceSpan.getColumnIndex() + begin.index, newContent.length());\n+            }\n+            return SourceLines.of(SourceLine.of(newContent, newSourceSpan));\n+        } else {\n+            SourceLines sourceLines = SourceLines.empty();\n+\n+            SourceLine firstLine = lines.get(begin.lineIndex);\n+            sourceLines.addLine(firstLine.substring(begin.index, firstLine.getContent().length()));\n+\n+            \/\/ Lines between begin and end (we are appending the full line)\n+            for (int line = begin.lineIndex + 1; line < end.lineIndex; line++) {\n+                sourceLines.addLine(lines.get(line));\n+            }\n+\n+            SourceLine lastLine = lines.get(end.lineIndex);\n+            sourceLines.addLine(lastLine.substring(0, end.index));\n+            return sourceLines;\n+        }\n+    }\n+\n+    private void setLine(SourceLine line) {\n+        this.line = line;\n+        this.lineLength = line.getContent().length();\n+    }\n+\n+    private void checkPosition(int lineIndex, int index) {\n+        if (lineIndex < 0 || lineIndex >= lines.size()) {\n+            throw new IllegalArgumentException(\"Line index \" + lineIndex + \" out of range, number of lines: \" + lines.size());\n+        }\n+        SourceLine line = lines.get(lineIndex);\n+        if (index < 0 || index > line.getContent().length()) {\n+            throw new IllegalArgumentException(\"Index \" + index + \" out of range, line length: \" + line.getContent().length());\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/Scanner.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.inline;\n+\n+public class UnderscoreDelimiterProcessor extends EmphasisDelimiterProcessor {\n+\n+    public UnderscoreDelimiterProcessor() {\n+        super('_');\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/inline\/UnderscoreDelimiterProcessor.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class NodeRendererMap {\n+\n+    private final Map<Class<? extends Node>, NodeRenderer> renderers = new HashMap<>(32);\n+\n+    public void add(NodeRenderer nodeRenderer) {\n+        for (Class<? extends Node> nodeType : nodeRenderer.getNodeTypes()) {\n+            \/\/ Overwrite existing renderer\n+            renderers.put(nodeType, nodeRenderer);\n+        }\n+    }\n+\n+    public void render(Node node) {\n+        NodeRenderer nodeRenderer = renderers.get(node.getClass());\n+        if (nodeRenderer != null) {\n+            nodeRenderer.render(node);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/NodeRendererMap.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.BulletList;\n+\n+public class BulletListHolder extends ListHolder {\n+    private final String marker;\n+\n+    public BulletListHolder(ListHolder parent, BulletList list) {\n+        super(parent);\n+        marker = list.getMarker();\n+    }\n+\n+    public String getMarker() {\n+        return marker;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/BulletListHolder.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer.text;\n+\n+public abstract class ListHolder {\n+    private static final String INDENT_DEFAULT = \"   \";\n+    private static final String INDENT_EMPTY = \"\";\n+\n+    private final ListHolder parent;\n+    private final String indent;\n+\n+    ListHolder(ListHolder parent) {\n+        this.parent = parent;\n+\n+        if (parent != null) {\n+            indent = parent.indent + INDENT_DEFAULT;\n+        } else {\n+            indent = INDENT_EMPTY;\n+        }\n+    }\n+\n+    public ListHolder getParent() {\n+        return parent;\n+    }\n+\n+    public String getIndent() {\n+        return indent;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/ListHolder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.OrderedList;\n+\n+public class OrderedListHolder extends ListHolder {\n+    private final String delimiter;\n+    private int counter;\n+\n+    public OrderedListHolder(ListHolder parent, OrderedList list) {\n+        super(parent);\n+        delimiter = list.getMarkerDelimiter() != null ? list.getMarkerDelimiter() : \".\";\n+        counter = list.getMarkerStartNumber() != null ? list.getMarkerStartNumber() : 1;\n+    }\n+\n+    public String getDelimiter() {\n+        return delimiter;\n+    }\n+\n+    public int getCounter() {\n+        return counter;\n+    }\n+\n+    public void increaseCounter() {\n+        counter++;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/renderer\/text\/OrderedListHolder.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import java.util.BitSet;\n+\n+public class AsciiMatcher implements CharMatcher {\n+    private final BitSet set;\n+\n+    private AsciiMatcher(Builder builder) {\n+        this.set = builder.set;\n+    }\n+\n+    @Override\n+    public boolean matches(char c) {\n+        return set.get(c);\n+    }\n+\n+    public Builder newBuilder() {\n+        return new Builder((BitSet) set.clone());\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder(new BitSet());\n+    }\n+\n+    public static class Builder {\n+        private final BitSet set;\n+\n+        private Builder(BitSet set) {\n+            this.set = set;\n+        }\n+\n+        public Builder c(char c) {\n+            if (c > 127) {\n+                throw new IllegalArgumentException(\"Can only match ASCII characters\");\n+            }\n+            set.set(c);\n+            return this;\n+        }\n+\n+        public Builder range(char from, char toInclusive) {\n+            for (char c = from; c <= toInclusive; c++) {\n+                c(c);\n+            }\n+            return this;\n+        }\n+\n+        public AsciiMatcher build() {\n+            return new AsciiMatcher(this);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/AsciiMatcher.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+public interface CharMatcher {\n+\n+    boolean matches(char c);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/CharMatcher.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import java.nio.charset.Charset;\n+import java.util.Locale;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class Escaping {\n+\n+    public static final String ESCAPABLE = \"[!\\\"#$%&\\'()*+,.\/:;<=>?@\\\\[\\\\\\\\\\\\]^_`{|}~-]\";\n+\n+    public static final String ENTITY = \"&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});\";\n+\n+    private static final Pattern BACKSLASH_OR_AMP = Pattern.compile(\"[\\\\\\\\&]\");\n+\n+    private static final Pattern ENTITY_OR_ESCAPED_CHAR =\n+            Pattern.compile(\"\\\\\\\\\" + ESCAPABLE + '|' + ENTITY, Pattern.CASE_INSENSITIVE);\n+\n+    \/\/ From RFC 3986 (see \"reserved\", \"unreserved\") except don't escape '[' or ']' to be compatible with JS encodeURI\n+    private static final Pattern ESCAPE_IN_URI =\n+            Pattern.compile(\"(%[a-fA-F0-9]{0,2}|[^:\/?#@!$&'()*+,;=a-zA-Z0-9\\\\-._~])\");\n+\n+    private static final char[] HEX_DIGITS =\n+            new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n+\n+    private static final Pattern WHITESPACE = Pattern.compile(\"[ \\t\\r\\n]+\");\n+\n+    private static final Replacer UNESCAPE_REPLACER = new Replacer() {\n+        @Override\n+        public void replace(String input, StringBuilder sb) {\n+            if (input.charAt(0) == '\\\\') {\n+                sb.append(input, 1, input.length());\n+            } else {\n+                sb.append(Html5Entities.entityToString(input));\n+            }\n+        }\n+    };\n+\n+    private static final Replacer URI_REPLACER = new Replacer() {\n+        @Override\n+        public void replace(String input, StringBuilder sb) {\n+            if (input.startsWith(\"%\")) {\n+                if (input.length() == 3) {\n+                    \/\/ Already percent-encoded, preserve\n+                    sb.append(input);\n+                } else {\n+                    \/\/ %25 is the percent-encoding for %\n+                    sb.append(\"%25\");\n+                    sb.append(input, 1, input.length());\n+                }\n+            } else {\n+                byte[] bytes = input.getBytes(Charset.forName(\"UTF-8\"));\n+                for (byte b : bytes) {\n+                    sb.append('%');\n+                    sb.append(HEX_DIGITS[(b >> 4) & 0xF]);\n+                    sb.append(HEX_DIGITS[b & 0xF]);\n+                }\n+            }\n+        }\n+    };\n+\n+    public static String escapeHtml(String input) {\n+        \/\/ Avoid building a new string in the majority of cases (nothing to escape)\n+        StringBuilder sb = null;\n+\n+        loop:\n+        for (int i = 0; i < input.length(); i++) {\n+            char c = input.charAt(i);\n+            String replacement;\n+            switch (c) {\n+                case '&':\n+                    replacement = \"&amp;\";\n+                    break;\n+                case '<':\n+                    replacement = \"&lt;\";\n+                    break;\n+                case '>':\n+                    replacement = \"&gt;\";\n+                    break;\n+                case '\\\"':\n+                    replacement = \"&quot;\";\n+                    break;\n+                default:\n+                    if (sb != null) {\n+                        sb.append(c);\n+                    }\n+                    continue loop;\n+            }\n+            if (sb == null) {\n+                sb = new StringBuilder();\n+                sb.append(input, 0, i);\n+            }\n+            sb.append(replacement);\n+        }\n+\n+        return sb != null ? sb.toString() : input;\n+    }\n+\n+    \/**\n+     * Replace entities and backslash escapes with literal characters.\n+     *\/\n+    public static String unescapeString(String s) {\n+        if (BACKSLASH_OR_AMP.matcher(s).find()) {\n+            return replaceAll(ENTITY_OR_ESCAPED_CHAR, s, UNESCAPE_REPLACER);\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    public static String percentEncodeUrl(String s) {\n+        return replaceAll(ESCAPE_IN_URI, s, URI_REPLACER);\n+    }\n+\n+    public static String normalizeLabelContent(String input) {\n+        String trimmed = input.trim();\n+\n+        \/\/ This is necessary to correctly case fold \"\\u1e9e\" to \"SS\":\n+        \/\/ \"\\u1e9e\".toLowerCase(Locale.ROOT)  -> \"\\u00df\"\n+        \/\/ \"\\u00df\".toUpperCase(Locale.ROOT)  -> \"SS\"\n+        \/\/ Note that doing upper first (or only upper without lower) wouldn't work because:\n+        \/\/ \"\\u1e9e\".toUpperCase(Locale.ROOT)  -> \"\\u1e9e\"\n+        String caseFolded = trimmed.toLowerCase(Locale.ROOT).toUpperCase(Locale.ROOT);\n+\n+        return WHITESPACE.matcher(caseFolded).replaceAll(\" \");\n+    }\n+\n+    private static String replaceAll(Pattern p, String s, Replacer replacer) {\n+        Matcher matcher = p.matcher(s);\n+\n+        if (!matcher.find()) {\n+            return s;\n+        }\n+\n+        StringBuilder sb = new StringBuilder(s.length() + 16);\n+        int lastEnd = 0;\n+        do {\n+            sb.append(s, lastEnd, matcher.start());\n+            replacer.replace(matcher.group(), sb);\n+            lastEnd = matcher.end();\n+        } while (matcher.find());\n+\n+        if (lastEnd != s.length()) {\n+            sb.append(s, lastEnd, s.length());\n+        }\n+        return sb.toString();\n+    }\n+\n+    private interface Replacer {\n+        void replace(String input, StringBuilder sb);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Escaping.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class Html5Entities {\n+\n+    private static final Map<String, String> NAMED_CHARACTER_REFERENCES = readEntities();\n+    private static final String ENTITY_PATH = \"\/jdk\/internal\/org\/commonmark\/internal\/util\/entities.txt\";\n+\n+    public static String entityToString(String input) {\n+        if (!input.startsWith(\"&\") || !input.endsWith(\";\")) {\n+            return input;\n+        }\n+\n+        String value = input.substring(1, input.length() - 1);\n+        if (value.startsWith(\"#\")) {\n+            value = value.substring(1);\n+            int base = 10;\n+            if (value.startsWith(\"x\") || value.startsWith(\"X\")) {\n+                value = value.substring(1);\n+                base = 16;\n+            }\n+\n+            try {\n+                int codePoint = Integer.parseInt(value, base);\n+                if (codePoint == 0) {\n+                    return \"\\uFFFD\";\n+                }\n+                return new String(Character.toChars(codePoint));\n+            } catch (IllegalArgumentException e) {\n+                return \"\\uFFFD\";\n+            }\n+        } else {\n+            String s = NAMED_CHARACTER_REFERENCES.get(value);\n+            if (s != null) {\n+                return s;\n+            } else {\n+                return input;\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> readEntities() {\n+        Map<String, String> entities = new HashMap<>();\n+        InputStream stream = Html5Entities.class.getResourceAsStream(ENTITY_PATH);\n+        Charset charset = StandardCharsets.UTF_8;\n+        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(stream, charset))) {\n+            String line;\n+            while ((line = bufferedReader.readLine()) != null) {\n+                if (line.length() == 0) {\n+                    continue;\n+                }\n+                int equal = line.indexOf(\"=\");\n+                String key = line.substring(0, equal);\n+                String value = line.substring(equal + 1);\n+                entities.put(key, value);\n+            }\n+        } catch (IOException e) {\n+            throw new IllegalStateException(\"Failed reading data for HTML named character references\", e);\n+        }\n+        entities.put(\"NewLine\", \"\\n\");\n+        return entities;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Html5Entities.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+import jdk.internal.org.commonmark.parser.beta.Scanner;\n+\n+public class LinkScanner {\n+\n+    \/**\n+     * Attempt to scan the contents of a link label (inside the brackets), stopping after the content or returning false.\n+     * The stopped position can bei either the closing {@code ]}, or the end of the line if the label continues on\n+     * the next line.\n+     *\/\n+    public static boolean scanLinkLabelContent(Scanner scanner) {\n+        while (scanner.hasNext()) {\n+            switch (scanner.peek()) {\n+                case '\\\\':\n+                    scanner.next();\n+                    if (isEscapable(scanner.peek())) {\n+                        scanner.next();\n+                    }\n+                    break;\n+                case ']':\n+                    return true;\n+                case '[':\n+                    \/\/ spec: Unescaped square bracket characters are not allowed inside the opening and closing\n+                    \/\/ square brackets of link labels.\n+                    return false;\n+                default:\n+                    scanner.next();\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Attempt to scan a link destination, stopping after the destination or returning false.\n+     *\/\n+    public static boolean scanLinkDestination(Scanner scanner) {\n+        if (!scanner.hasNext()) {\n+            return false;\n+        }\n+\n+        if (scanner.next('<')) {\n+            while (scanner.hasNext()) {\n+                switch (scanner.peek()) {\n+                    case '\\\\':\n+                        scanner.next();\n+                        if (isEscapable(scanner.peek())) {\n+                            scanner.next();\n+                        }\n+                        break;\n+                    case '\\n':\n+                    case '<':\n+                        return false;\n+                    case '>':\n+                        scanner.next();\n+                        return true;\n+                    default:\n+                        scanner.next();\n+                }\n+            }\n+            return false;\n+        } else {\n+            return scanLinkDestinationWithBalancedParens(scanner);\n+        }\n+    }\n+\n+    public static boolean scanLinkTitle(Scanner scanner) {\n+        if (!scanner.hasNext()) {\n+            return false;\n+        }\n+\n+        char endDelimiter;\n+        switch (scanner.peek()) {\n+            case '\"':\n+                endDelimiter = '\"';\n+                break;\n+            case '\\'':\n+                endDelimiter = '\\'';\n+                break;\n+            case '(':\n+                endDelimiter = ')';\n+                break;\n+            default:\n+                return false;\n+        }\n+        scanner.next();\n+\n+        if (!scanLinkTitleContent(scanner, endDelimiter)) {\n+            return false;\n+        }\n+        if (!scanner.hasNext()) {\n+            return false;\n+        }\n+        scanner.next();\n+        return true;\n+    }\n+\n+    public static boolean scanLinkTitleContent(Scanner scanner, char endDelimiter) {\n+        while (scanner.hasNext()) {\n+            char c = scanner.peek();\n+            if (c == '\\\\') {\n+                scanner.next();\n+                if (isEscapable(scanner.peek())) {\n+                    scanner.next();\n+                }\n+            } else if (c == endDelimiter) {\n+                return true;\n+            } else if (endDelimiter == ')' && c == '(') {\n+                \/\/ unescaped '(' in title within parens is invalid\n+                return false;\n+            } else {\n+                scanner.next();\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ spec: a nonempty sequence of characters that does not start with <, does not include ASCII space or control\n+    \/\/ characters, and includes parentheses only if (a) they are backslash-escaped or (b) they are part of a balanced\n+    \/\/ pair of unescaped parentheses\n+    private static boolean scanLinkDestinationWithBalancedParens(Scanner scanner) {\n+        int parens = 0;\n+        boolean empty = true;\n+        while (scanner.hasNext()) {\n+            char c = scanner.peek();\n+            switch (c) {\n+                case ' ':\n+                    return !empty;\n+                case '\\\\':\n+                    scanner.next();\n+                    if (isEscapable(scanner.peek())) {\n+                        scanner.next();\n+                    }\n+                    break;\n+                case '(':\n+                    parens++;\n+                    \/\/ Limit to 32 nested parens for pathological cases\n+                    if (parens > 32) {\n+                        return false;\n+                    }\n+                    scanner.next();\n+                    break;\n+                case ')':\n+                    if (parens == 0) {\n+                        return true;\n+                    } else {\n+                        parens--;\n+                    }\n+                    scanner.next();\n+                    break;\n+                default:\n+                    \/\/ or control character\n+                    if (Character.isISOControl(c)) {\n+                        return !empty;\n+                    }\n+                    scanner.next();\n+                    break;\n+            }\n+            empty = false;\n+        }\n+        return true;\n+    }\n+\n+    private static boolean isEscapable(char c) {\n+        switch (c) {\n+            case '!':\n+            case '\"':\n+            case '#':\n+            case '$':\n+            case '%':\n+            case '&':\n+            case '\\'':\n+            case '(':\n+            case ')':\n+            case '*':\n+            case '+':\n+            case ',':\n+            case '-':\n+            case '.':\n+            case '\/':\n+            case ':':\n+            case ';':\n+            case '<':\n+            case '=':\n+            case '>':\n+            case '?':\n+            case '@':\n+            case '[':\n+            case '\\\\':\n+            case ']':\n+            case '^':\n+            case '_':\n+            case '`':\n+            case '{':\n+            case '|':\n+            case '}':\n+            case '~':\n+                return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/LinkScanner.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.internal.util;\n+\n+public class Parsing {\n+    public static int CODE_BLOCK_INDENT = 4;\n+\n+    public static int columnsToNextTabStop(int column) {\n+        \/\/ Tab stop is 4\n+        return 4 - (column % 4);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/Parsing.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,2126 @@\n+Aacute=Á\n+aacute=á\n+Abreve=Ă\n+abreve=ă\n+ac=∾\n+acd=∿\n+acE=∾̳\n+Acirc=Â\n+acirc=â\n+acute=´\n+Acy=А\n+acy=а\n+AElig=Æ\n+aelig=æ\n+af=⁡\n+Afr=𝔄\n+afr=𝔞\n+Agrave=À\n+agrave=à\n+alefsym=ℵ\n+aleph=ℵ\n+Alpha=Α\n+alpha=α\n+Amacr=Ā\n+amacr=ā\n+amalg=⨿\n+amp=&\n+AMP=&\n+andand=⩕\n+And=⩓\n+and=∧\n+andd=⩜\n+andslope=⩘\n+andv=⩚\n+ang=∠\n+ange=⦤\n+angle=∠\n+angmsdaa=⦨\n+angmsdab=⦩\n+angmsdac=⦪\n+angmsdad=⦫\n+angmsdae=⦬\n+angmsdaf=⦭\n+angmsdag=⦮\n+angmsdah=⦯\n+angmsd=∡\n+angrt=∟\n+angrtvb=⊾\n+angrtvbd=⦝\n+angsph=∢\n+angst=Å\n+angzarr=⍼\n+Aogon=Ą\n+aogon=ą\n+Aopf=𝔸\n+aopf=𝕒\n+apacir=⩯\n+ap=≈\n+apE=⩰\n+ape=≊\n+apid=≋\n+apos='\n+ApplyFunction=⁡\n+approx=≈\n+approxeq=≊\n+Aring=Å\n+aring=å\n+Ascr=𝒜\n+ascr=𝒶\n+Assign=≔\n+ast=*\n+asymp=≈\n+asympeq=≍\n+Atilde=Ã\n+atilde=ã\n+Auml=Ä\n+auml=ä\n+awconint=∳\n+awint=⨑\n+backcong=≌\n+backepsilon=϶\n+backprime=‵\n+backsim=∽\n+backsimeq=⋍\n+Backslash=∖\n+Barv=⫧\n+barvee=⊽\n+barwed=⌅\n+Barwed=⌆\n+barwedge=⌅\n+bbrk=⎵\n+bbrktbrk=⎶\n+bcong=≌\n+Bcy=Б\n+bcy=б\n+bdquo=„\n+becaus=∵\n+because=∵\n+Because=∵\n+bemptyv=⦰\n+bepsi=϶\n+bernou=ℬ\n+Bernoullis=ℬ\n+Beta=Β\n+beta=β\n+beth=ℶ\n+between=≬\n+Bfr=𝔅\n+bfr=𝔟\n+bigcap=⋂\n+bigcirc=◯\n+bigcup=⋃\n+bigodot=⨀\n+bigoplus=⨁\n+bigotimes=⨂\n+bigsqcup=⨆\n+bigstar=★\n+bigtriangledown=▽\n+bigtriangleup=△\n+biguplus=⨄\n+bigvee=⋁\n+bigwedge=⋀\n+bkarow=⤍\n+blacklozenge=⧫\n+blacksquare=▪\n+blacktriangle=▴\n+blacktriangledown=▾\n+blacktriangleleft=◂\n+blacktriangleright=▸\n+blank=␣\n+blk12=▒\n+blk14=░\n+blk34=▓\n+block=█\n+bne==⃥\n+bnequiv=≡⃥\n+bNot=⫭\n+bnot=⌐\n+Bopf=𝔹\n+bopf=𝕓\n+bot=⊥\n+bottom=⊥\n+bowtie=⋈\n+boxbox=⧉\n+boxdl=┐\n+boxdL=╕\n+boxDl=╖\n+boxDL=╗\n+boxdr=┌\n+boxdR=╒\n+boxDr=╓\n+boxDR=╔\n+boxh=─\n+boxH=═\n+boxhd=┬\n+boxHd=╤\n+boxhD=╥\n+boxHD=╦\n+boxhu=┴\n+boxHu=╧\n+boxhU=╨\n+boxHU=╩\n+boxminus=⊟\n+boxplus=⊞\n+boxtimes=⊠\n+boxul=┘\n+boxuL=╛\n+boxUl=╜\n+boxUL=╝\n+boxur=└\n+boxuR=╘\n+boxUr=╙\n+boxUR=╚\n+boxv=│\n+boxV=║\n+boxvh=┼\n+boxvH=╪\n+boxVh=╫\n+boxVH=╬\n+boxvl=┤\n+boxvL=╡\n+boxVl=╢\n+boxVL=╣\n+boxvr=├\n+boxvR=╞\n+boxVr=╟\n+boxVR=╠\n+bprime=‵\n+breve=˘\n+Breve=˘\n+brvbar=¦\n+bscr=𝒷\n+Bscr=ℬ\n+bsemi=⁏\n+bsim=∽\n+bsime=⋍\n+bsolb=⧅\n+bsol=\\\n+bsolhsub=⟈\n+bull=•\n+bullet=•\n+bump=≎\n+bumpE=⪮\n+bumpe=≏\n+Bumpeq=≎\n+bumpeq=≏\n+Cacute=Ć\n+cacute=ć\n+capand=⩄\n+capbrcup=⩉\n+capcap=⩋\n+cap=∩\n+Cap=⋒\n+capcup=⩇\n+capdot=⩀\n+CapitalDifferentialD=ⅅ\n+caps=∩︀\n+caret=⁁\n+caron=ˇ\n+Cayleys=ℭ\n+ccaps=⩍\n+Ccaron=Č\n+ccaron=č\n+Ccedil=Ç\n+ccedil=ç\n+Ccirc=Ĉ\n+ccirc=ĉ\n+Cconint=∰\n+ccups=⩌\n+ccupssm=⩐\n+Cdot=Ċ\n+cdot=ċ\n+cedil=¸\n+Cedilla=¸\n+cemptyv=⦲\n+cent=¢\n+centerdot=·\n+CenterDot=·\n+cfr=𝔠\n+Cfr=ℭ\n+CHcy=Ч\n+chcy=ч\n+check=✓\n+checkmark=✓\n+Chi=Χ\n+chi=χ\n+circ=ˆ\n+circeq=≗\n+circlearrowleft=↺\n+circlearrowright=↻\n+circledast=⊛\n+circledcirc=⊚\n+circleddash=⊝\n+CircleDot=⊙\n+circledR=®\n+circledS=Ⓢ\n+CircleMinus=⊖\n+CirclePlus=⊕\n+CircleTimes=⊗\n+cir=○\n+cirE=⧃\n+cire=≗\n+cirfnint=⨐\n+cirmid=⫯\n+cirscir=⧂\n+ClockwiseContourIntegral=∲\n+CloseCurlyDoubleQuote=”\n+CloseCurlyQuote=’\n+clubs=♣\n+clubsuit=♣\n+colon=:\n+Colon=∷\n+Colone=⩴\n+colone=≔\n+coloneq=≔\n+comma=,\n+commat=@\n+comp=∁\n+compfn=∘\n+complement=∁\n+complexes=ℂ\n+cong=≅\n+congdot=⩭\n+Congruent=≡\n+conint=∮\n+Conint=∯\n+ContourIntegral=∮\n+copf=𝕔\n+Copf=ℂ\n+coprod=∐\n+Coproduct=∐\n+copy=©\n+COPY=©\n+copysr=℗\n+CounterClockwiseContourIntegral=∳\n+crarr=↵\n+cross=✗\n+Cross=⨯\n+Cscr=𝒞\n+cscr=𝒸\n+csub=⫏\n+csube=⫑\n+csup=⫐\n+csupe=⫒\n+ctdot=⋯\n+cudarrl=⤸\n+cudarrr=⤵\n+cuepr=⋞\n+cuesc=⋟\n+cularr=↶\n+cularrp=⤽\n+cupbrcap=⩈\n+cupcap=⩆\n+CupCap=≍\n+cup=∪\n+Cup=⋓\n+cupcup=⩊\n+cupdot=⊍\n+cupor=⩅\n+cups=∪︀\n+curarr=↷\n+curarrm=⤼\n+curlyeqprec=⋞\n+curlyeqsucc=⋟\n+curlyvee=⋎\n+curlywedge=⋏\n+curren=¤\n+curvearrowleft=↶\n+curvearrowright=↷\n+cuvee=⋎\n+cuwed=⋏\n+cwconint=∲\n+cwint=∱\n+cylcty=⌭\n+dagger=†\n+Dagger=‡\n+daleth=ℸ\n+darr=↓\n+Darr=↡\n+dArr=⇓\n+dash=‐\n+Dashv=⫤\n+dashv=⊣\n+dbkarow=⤏\n+dblac=˝\n+Dcaron=Ď\n+dcaron=ď\n+Dcy=Д\n+dcy=д\n+ddagger=‡\n+ddarr=⇊\n+DD=ⅅ\n+dd=ⅆ\n+DDotrahd=⤑\n+ddotseq=⩷\n+deg=°\n+Del=∇\n+Delta=Δ\n+delta=δ\n+demptyv=⦱\n+dfisht=⥿\n+Dfr=𝔇\n+dfr=𝔡\n+dHar=⥥\n+dharl=⇃\n+dharr=⇂\n+DiacriticalAcute=´\n+DiacriticalDot=˙\n+DiacriticalDoubleAcute=˝\n+DiacriticalGrave=`\n+DiacriticalTilde=˜\n+diam=⋄\n+diamond=⋄\n+Diamond=⋄\n+diamondsuit=♦\n+diams=♦\n+die=¨\n+DifferentialD=ⅆ\n+digamma=ϝ\n+disin=⋲\n+div=÷\n+divide=÷\n+divideontimes=⋇\n+divonx=⋇\n+DJcy=Ђ\n+djcy=ђ\n+dlcorn=⌞\n+dlcrop=⌍\n+dollar=$\n+Dopf=𝔻\n+dopf=𝕕\n+Dot=¨\n+dot=˙\n+DotDot=⃜\n+doteq=≐\n+doteqdot=≑\n+DotEqual=≐\n+dotminus=∸\n+dotplus=∔\n+dotsquare=⊡\n+doublebarwedge=⌆\n+DoubleContourIntegral=∯\n+DoubleDot=¨\n+DoubleDownArrow=⇓\n+DoubleLeftArrow=⇐\n+DoubleLeftRightArrow=⇔\n+DoubleLeftTee=⫤\n+DoubleLongLeftArrow=⟸\n+DoubleLongLeftRightArrow=⟺\n+DoubleLongRightArrow=⟹\n+DoubleRightArrow=⇒\n+DoubleRightTee=⊨\n+DoubleUpArrow=⇑\n+DoubleUpDownArrow=⇕\n+DoubleVerticalBar=∥\n+DownArrowBar=⤓\n+downarrow=↓\n+DownArrow=↓\n+Downarrow=⇓\n+DownArrowUpArrow=⇵\n+DownBreve=̑\n+downdownarrows=⇊\n+downharpoonleft=⇃\n+downharpoonright=⇂\n+DownLeftRightVector=⥐\n+DownLeftTeeVector=⥞\n+DownLeftVectorBar=⥖\n+DownLeftVector=↽\n+DownRightTeeVector=⥟\n+DownRightVectorBar=⥗\n+DownRightVector=⇁\n+DownTeeArrow=↧\n+DownTee=⊤\n+drbkarow=⤐\n+drcorn=⌟\n+drcrop=⌌\n+Dscr=𝒟\n+dscr=𝒹\n+DScy=Ѕ\n+dscy=ѕ\n+dsol=⧶\n+Dstrok=Đ\n+dstrok=đ\n+dtdot=⋱\n+dtri=▿\n+dtrif=▾\n+duarr=⇵\n+duhar=⥯\n+dwangle=⦦\n+DZcy=Џ\n+dzcy=џ\n+dzigrarr=⟿\n+Eacute=É\n+eacute=é\n+easter=⩮\n+Ecaron=Ě\n+ecaron=ě\n+Ecirc=Ê\n+ecirc=ê\n+ecir=≖\n+ecolon=≕\n+Ecy=Э\n+ecy=э\n+eDDot=⩷\n+Edot=Ė\n+edot=ė\n+eDot=≑\n+ee=ⅇ\n+efDot=≒\n+Efr=𝔈\n+efr=𝔢\n+eg=⪚\n+Egrave=È\n+egrave=è\n+egs=⪖\n+egsdot=⪘\n+el=⪙\n+Element=∈\n+elinters=⏧\n+ell=ℓ\n+els=⪕\n+elsdot=⪗\n+Emacr=Ē\n+emacr=ē\n+empty=∅\n+emptyset=∅\n+EmptySmallSquare=◻\n+emptyv=∅\n+EmptyVerySmallSquare=▫\n+emsp13= \n+emsp14= \n+emsp= \n+ENG=Ŋ\n+eng=ŋ\n+ensp= \n+Eogon=Ę\n+eogon=ę\n+Eopf=𝔼\n+eopf=𝕖\n+epar=⋕\n+eparsl=⧣\n+eplus=⩱\n+epsi=ε\n+Epsilon=Ε\n+epsilon=ε\n+epsiv=ϵ\n+eqcirc=≖\n+eqcolon=≕\n+eqsim=≂\n+eqslantgtr=⪖\n+eqslantless=⪕\n+Equal=⩵\n+equals==\n+EqualTilde=≂\n+equest=≟\n+Equilibrium=⇌\n+equiv=≡\n+equivDD=⩸\n+eqvparsl=⧥\n+erarr=⥱\n+erDot=≓\n+escr=ℯ\n+Escr=ℰ\n+esdot=≐\n+Esim=⩳\n+esim=≂\n+Eta=Η\n+eta=η\n+ETH=Ð\n+eth=ð\n+Euml=Ë\n+euml=ë\n+euro=€\n+excl=!\n+exist=∃\n+Exists=∃\n+expectation=ℰ\n+exponentiale=ⅇ\n+ExponentialE=ⅇ\n+fallingdotseq=≒\n+Fcy=Ф\n+fcy=ф\n+female=♀\n+ffilig=ﬃ\n+fflig=ﬀ\n+ffllig=ﬄ\n+Ffr=𝔉\n+ffr=𝔣\n+filig=ﬁ\n+FilledSmallSquare=◼\n+FilledVerySmallSquare=▪\n+fjlig=fj\n+flat=♭\n+fllig=ﬂ\n+fltns=▱\n+fnof=ƒ\n+Fopf=𝔽\n+fopf=𝕗\n+forall=∀\n+ForAll=∀\n+fork=⋔\n+forkv=⫙\n+Fouriertrf=ℱ\n+fpartint=⨍\n+frac12=½\n+frac13=⅓\n+frac14=¼\n+frac15=⅕\n+frac16=⅙\n+frac18=⅛\n+frac23=⅔\n+frac25=⅖\n+frac34=¾\n+frac35=⅗\n+frac38=⅜\n+frac45=⅘\n+frac56=⅚\n+frac58=⅝\n+frac78=⅞\n+frasl=⁄\n+frown=⌢\n+fscr=𝒻\n+Fscr=ℱ\n+gacute=ǵ\n+Gamma=Γ\n+gamma=γ\n+Gammad=Ϝ\n+gammad=ϝ\n+gap=⪆\n+Gbreve=Ğ\n+gbreve=ğ\n+Gcedil=Ģ\n+Gcirc=Ĝ\n+gcirc=ĝ\n+Gcy=Г\n+gcy=г\n+Gdot=Ġ\n+gdot=ġ\n+ge=≥\n+gE=≧\n+gEl=⪌\n+gel=⋛\n+geq=≥\n+geqq=≧\n+geqslant=⩾\n+gescc=⪩\n+ges=⩾\n+gesdot=⪀\n+gesdoto=⪂\n+gesdotol=⪄\n+gesl=⋛︀\n+gesles=⪔\n+Gfr=𝔊\n+gfr=𝔤\n+gg=≫\n+Gg=⋙\n+ggg=⋙\n+gimel=ℷ\n+GJcy=Ѓ\n+gjcy=ѓ\n+gla=⪥\n+gl=≷\n+glE=⪒\n+glj=⪤\n+gnap=⪊\n+gnapprox=⪊\n+gne=⪈\n+gnE=≩\n+gneq=⪈\n+gneqq=≩\n+gnsim=⋧\n+Gopf=𝔾\n+gopf=𝕘\n+grave=`\n+GreaterEqual=≥\n+GreaterEqualLess=⋛\n+GreaterFullEqual=≧\n+GreaterGreater=⪢\n+GreaterLess=≷\n+GreaterSlantEqual=⩾\n+GreaterTilde=≳\n+Gscr=𝒢\n+gscr=ℊ\n+gsim=≳\n+gsime=⪎\n+gsiml=⪐\n+gtcc=⪧\n+gtcir=⩺\n+gt=>\n+GT=>\n+Gt=≫\n+gtdot=⋗\n+gtlPar=⦕\n+gtquest=⩼\n+gtrapprox=⪆\n+gtrarr=⥸\n+gtrdot=⋗\n+gtreqless=⋛\n+gtreqqless=⪌\n+gtrless=≷\n+gtrsim=≳\n+gvertneqq=≩︀\n+gvnE=≩︀\n+Hacek=ˇ\n+hairsp= \n+half=½\n+hamilt=ℋ\n+HARDcy=Ъ\n+hardcy=ъ\n+harrcir=⥈\n+harr=↔\n+hArr=⇔\n+harrw=↭\n+Hat=^\n+hbar=ℏ\n+Hcirc=Ĥ\n+hcirc=ĥ\n+hearts=♥\n+heartsuit=♥\n+hellip=…\n+hercon=⊹\n+hfr=𝔥\n+Hfr=ℌ\n+HilbertSpace=ℋ\n+hksearow=⤥\n+hkswarow=⤦\n+hoarr=⇿\n+homtht=∻\n+hookleftarrow=↩\n+hookrightarrow=↪\n+hopf=𝕙\n+Hopf=ℍ\n+horbar=―\n+HorizontalLine=─\n+hscr=𝒽\n+Hscr=ℋ\n+hslash=ℏ\n+Hstrok=Ħ\n+hstrok=ħ\n+HumpDownHump=≎\n+HumpEqual=≏\n+hybull=⁃\n+hyphen=‐\n+Iacute=Í\n+iacute=í\n+ic=⁣\n+Icirc=Î\n+icirc=î\n+Icy=И\n+icy=и\n+Idot=İ\n+IEcy=Е\n+iecy=е\n+iexcl=¡\n+iff=⇔\n+ifr=𝔦\n+Ifr=ℑ\n+Igrave=Ì\n+igrave=ì\n+ii=ⅈ\n+iiiint=⨌\n+iiint=∭\n+iinfin=⧜\n+iiota=℩\n+IJlig=Ĳ\n+ijlig=ĳ\n+Imacr=Ī\n+imacr=ī\n+image=ℑ\n+ImaginaryI=ⅈ\n+imagline=ℐ\n+imagpart=ℑ\n+imath=ı\n+Im=ℑ\n+imof=⊷\n+imped=Ƶ\n+Implies=⇒\n+incare=℅\n+in=∈\n+infin=∞\n+infintie=⧝\n+inodot=ı\n+intcal=⊺\n+int=∫\n+Int=∬\n+integers=ℤ\n+Integral=∫\n+intercal=⊺\n+Intersection=⋂\n+intlarhk=⨗\n+intprod=⨼\n+InvisibleComma=⁣\n+InvisibleTimes=⁢\n+IOcy=Ё\n+iocy=ё\n+Iogon=Į\n+iogon=į\n+Iopf=𝕀\n+iopf=𝕚\n+Iota=Ι\n+iota=ι\n+iprod=⨼\n+iquest=¿\n+iscr=𝒾\n+Iscr=ℐ\n+isin=∈\n+isindot=⋵\n+isinE=⋹\n+isins=⋴\n+isinsv=⋳\n+isinv=∈\n+it=⁢\n+Itilde=Ĩ\n+itilde=ĩ\n+Iukcy=І\n+iukcy=і\n+Iuml=Ï\n+iuml=ï\n+Jcirc=Ĵ\n+jcirc=ĵ\n+Jcy=Й\n+jcy=й\n+Jfr=𝔍\n+jfr=𝔧\n+jmath=ȷ\n+Jopf=𝕁\n+jopf=𝕛\n+Jscr=𝒥\n+jscr=𝒿\n+Jsercy=Ј\n+jsercy=ј\n+Jukcy=Є\n+jukcy=є\n+Kappa=Κ\n+kappa=κ\n+kappav=ϰ\n+Kcedil=Ķ\n+kcedil=ķ\n+Kcy=К\n+kcy=к\n+Kfr=𝔎\n+kfr=𝔨\n+kgreen=ĸ\n+KHcy=Х\n+khcy=х\n+KJcy=Ќ\n+kjcy=ќ\n+Kopf=𝕂\n+kopf=𝕜\n+Kscr=𝒦\n+kscr=𝓀\n+lAarr=⇚\n+Lacute=Ĺ\n+lacute=ĺ\n+laemptyv=⦴\n+lagran=ℒ\n+Lambda=Λ\n+lambda=λ\n+lang=⟨\n+Lang=⟪\n+langd=⦑\n+langle=⟨\n+lap=⪅\n+Laplacetrf=ℒ\n+laquo=«\n+larrb=⇤\n+larrbfs=⤟\n+larr=←\n+Larr=↞\n+lArr=⇐\n+larrfs=⤝\n+larrhk=↩\n+larrlp=↫\n+larrpl=⤹\n+larrsim=⥳\n+larrtl=↢\n+latail=⤙\n+lAtail=⤛\n+lat=⪫\n+late=⪭\n+lates=⪭︀\n+lbarr=⤌\n+lBarr=⤎\n+lbbrk=❲\n+lbrace={\n+lbrack=[\n+lbrke=⦋\n+lbrksld=⦏\n+lbrkslu=⦍\n+Lcaron=Ľ\n+lcaron=ľ\n+Lcedil=Ļ\n+lcedil=ļ\n+lceil=⌈\n+lcub={\n+Lcy=Л\n+lcy=л\n+ldca=⤶\n+ldquo=“\n+ldquor=„\n+ldrdhar=⥧\n+ldrushar=⥋\n+ldsh=↲\n+le=≤\n+lE=≦\n+LeftAngleBracket=⟨\n+LeftArrowBar=⇤\n+leftarrow=←\n+LeftArrow=←\n+Leftarrow=⇐\n+LeftArrowRightArrow=⇆\n+leftarrowtail=↢\n+LeftCeiling=⌈\n+LeftDoubleBracket=⟦\n+LeftDownTeeVector=⥡\n+LeftDownVectorBar=⥙\n+LeftDownVector=⇃\n+LeftFloor=⌊\n+leftharpoondown=↽\n+leftharpoonup=↼\n+leftleftarrows=⇇\n+leftrightarrow=↔\n+LeftRightArrow=↔\n+Leftrightarrow=⇔\n+leftrightarrows=⇆\n+leftrightharpoons=⇋\n+leftrightsquigarrow=↭\n+LeftRightVector=⥎\n+LeftTeeArrow=↤\n+LeftTee=⊣\n+LeftTeeVector=⥚\n+leftthreetimes=⋋\n+LeftTriangleBar=⧏\n+LeftTriangle=⊲\n+LeftTriangleEqual=⊴\n+LeftUpDownVector=⥑\n+LeftUpTeeVector=⥠\n+LeftUpVectorBar=⥘\n+LeftUpVector=↿\n+LeftVectorBar=⥒\n+LeftVector=↼\n+lEg=⪋\n+leg=⋚\n+leq=≤\n+leqq=≦\n+leqslant=⩽\n+lescc=⪨\n+les=⩽\n+lesdot=⩿\n+lesdoto=⪁\n+lesdotor=⪃\n+lesg=⋚︀\n+lesges=⪓\n+lessapprox=⪅\n+lessdot=⋖\n+lesseqgtr=⋚\n+lesseqqgtr=⪋\n+LessEqualGreater=⋚\n+LessFullEqual=≦\n+LessGreater=≶\n+lessgtr=≶\n+LessLess=⪡\n+lesssim=≲\n+LessSlantEqual=⩽\n+LessTilde=≲\n+lfisht=⥼\n+lfloor=⌊\n+Lfr=𝔏\n+lfr=𝔩\n+lg=≶\n+lgE=⪑\n+lHar=⥢\n+lhard=↽\n+lharu=↼\n+lharul=⥪\n+lhblk=▄\n+LJcy=Љ\n+ljcy=љ\n+llarr=⇇\n+ll=≪\n+Ll=⋘\n+llcorner=⌞\n+Lleftarrow=⇚\n+llhard=⥫\n+lltri=◺\n+Lmidot=Ŀ\n+lmidot=ŀ\n+lmoustache=⎰\n+lmoust=⎰\n+lnap=⪉\n+lnapprox=⪉\n+lne=⪇\n+lnE=≨\n+lneq=⪇\n+lneqq=≨\n+lnsim=⋦\n+loang=⟬\n+loarr=⇽\n+lobrk=⟦\n+longleftarrow=⟵\n+LongLeftArrow=⟵\n+Longleftarrow=⟸\n+longleftrightarrow=⟷\n+LongLeftRightArrow=⟷\n+Longleftrightarrow=⟺\n+longmapsto=⟼\n+longrightarrow=⟶\n+LongRightArrow=⟶\n+Longrightarrow=⟹\n+looparrowleft=↫\n+looparrowright=↬\n+lopar=⦅\n+Lopf=𝕃\n+lopf=𝕝\n+loplus=⨭\n+lotimes=⨴\n+lowast=∗\n+lowbar=_\n+LowerLeftArrow=↙\n+LowerRightArrow=↘\n+loz=◊\n+lozenge=◊\n+lozf=⧫\n+lpar=(\n+lparlt=⦓\n+lrarr=⇆\n+lrcorner=⌟\n+lrhar=⇋\n+lrhard=⥭\n+lrm=‎\n+lrtri=⊿\n+lsaquo=‹\n+lscr=𝓁\n+Lscr=ℒ\n+lsh=↰\n+Lsh=↰\n+lsim=≲\n+lsime=⪍\n+lsimg=⪏\n+lsqb=[\n+lsquo=‘\n+lsquor=‚\n+Lstrok=Ł\n+lstrok=ł\n+ltcc=⪦\n+ltcir=⩹\n+lt=<\n+LT=<\n+Lt=≪\n+ltdot=⋖\n+lthree=⋋\n+ltimes=⋉\n+ltlarr=⥶\n+ltquest=⩻\n+ltri=◃\n+ltrie=⊴\n+ltrif=◂\n+ltrPar=⦖\n+lurdshar=⥊\n+luruhar=⥦\n+lvertneqq=≨︀\n+lvnE=≨︀\n+macr=¯\n+male=♂\n+malt=✠\n+maltese=✠\n+Map=⤅\n+map=↦\n+mapsto=↦\n+mapstodown=↧\n+mapstoleft=↤\n+mapstoup=↥\n+marker=▮\n+mcomma=⨩\n+Mcy=М\n+mcy=м\n+mdash=—\n+mDDot=∺\n+measuredangle=∡\n+MediumSpace= \n+Mellintrf=ℳ\n+Mfr=𝔐\n+mfr=𝔪\n+mho=℧\n+micro=µ\n+midast=*\n+midcir=⫰\n+mid=∣\n+middot=·\n+minusb=⊟\n+minus=−\n+minusd=∸\n+minusdu=⨪\n+MinusPlus=∓\n+mlcp=⫛\n+mldr=…\n+mnplus=∓\n+models=⊧\n+Mopf=𝕄\n+mopf=𝕞\n+mp=∓\n+mscr=𝓂\n+Mscr=ℳ\n+mstpos=∾\n+Mu=Μ\n+mu=μ\n+multimap=⊸\n+mumap=⊸\n+nabla=∇\n+Nacute=Ń\n+nacute=ń\n+nang=∠⃒\n+nap=≉\n+napE=⩰̸\n+napid=≋̸\n+napos=ŉ\n+napprox=≉\n+natural=♮\n+naturals=ℕ\n+natur=♮\n+nbsp= \n+nbump=≎̸\n+nbumpe=≏̸\n+ncap=⩃\n+Ncaron=Ň\n+ncaron=ň\n+Ncedil=Ņ\n+ncedil=ņ\n+ncong=≇\n+ncongdot=⩭̸\n+ncup=⩂\n+Ncy=Н\n+ncy=н\n+ndash=–\n+nearhk=⤤\n+nearr=↗\n+neArr=⇗\n+nearrow=↗\n+ne=≠\n+nedot=≐̸\n+NegativeMediumSpace=​\n+NegativeThickSpace=​\n+NegativeThinSpace=​\n+NegativeVeryThinSpace=​\n+nequiv=≢\n+nesear=⤨\n+nesim=≂̸\n+NestedGreaterGreater=≫\n+NestedLessLess=≪\n+NewLine=\n+\n+nexist=∄\n+nexists=∄\n+Nfr=𝔑\n+nfr=𝔫\n+ngE=≧̸\n+nge=≱\n+ngeq=≱\n+ngeqq=≧̸\n+ngeqslant=⩾̸\n+nges=⩾̸\n+nGg=⋙̸\n+ngsim=≵\n+nGt=≫⃒\n+ngt=≯\n+ngtr=≯\n+nGtv=≫̸\n+nharr=↮\n+nhArr=⇎\n+nhpar=⫲\n+ni=∋\n+nis=⋼\n+nisd=⋺\n+niv=∋\n+NJcy=Њ\n+njcy=њ\n+nlarr=↚\n+nlArr=⇍\n+nldr=‥\n+nlE=≦̸\n+nle=≰\n+nleftarrow=↚\n+nLeftarrow=⇍\n+nleftrightarrow=↮\n+nLeftrightarrow=⇎\n+nleq=≰\n+nleqq=≦̸\n+nleqslant=⩽̸\n+nles=⩽̸\n+nless=≮\n+nLl=⋘̸\n+nlsim=≴\n+nLt=≪⃒\n+nlt=≮\n+nltri=⋪\n+nltrie=⋬\n+nLtv=≪̸\n+nmid=∤\n+NoBreak=⁠\n+NonBreakingSpace= \n+nopf=𝕟\n+Nopf=ℕ\n+Not=⫬\n+not=¬\n+NotCongruent=≢\n+NotCupCap=≭\n+NotDoubleVerticalBar=∦\n+NotElement=∉\n+NotEqual=≠\n+NotEqualTilde=≂̸\n+NotExists=∄\n+NotGreater=≯\n+NotGreaterEqual=≱\n+NotGreaterFullEqual=≧̸\n+NotGreaterGreater=≫̸\n+NotGreaterLess=≹\n+NotGreaterSlantEqual=⩾̸\n+NotGreaterTilde=≵\n+NotHumpDownHump=≎̸\n+NotHumpEqual=≏̸\n+notin=∉\n+notindot=⋵̸\n+notinE=⋹̸\n+notinva=∉\n+notinvb=⋷\n+notinvc=⋶\n+NotLeftTriangleBar=⧏̸\n+NotLeftTriangle=⋪\n+NotLeftTriangleEqual=⋬\n+NotLess=≮\n+NotLessEqual=≰\n+NotLessGreater=≸\n+NotLessLess=≪̸\n+NotLessSlantEqual=⩽̸\n+NotLessTilde=≴\n+NotNestedGreaterGreater=⪢̸\n+NotNestedLessLess=⪡̸\n+notni=∌\n+notniva=∌\n+notnivb=⋾\n+notnivc=⋽\n+NotPrecedes=⊀\n+NotPrecedesEqual=⪯̸\n+NotPrecedesSlantEqual=⋠\n+NotReverseElement=∌\n+NotRightTriangleBar=⧐̸\n+NotRightTriangle=⋫\n+NotRightTriangleEqual=⋭\n+NotSquareSubset=⊏̸\n+NotSquareSubsetEqual=⋢\n+NotSquareSuperset=⊐̸\n+NotSquareSupersetEqual=⋣\n+NotSubset=⊂⃒\n+NotSubsetEqual=⊈\n+NotSucceeds=⊁\n+NotSucceedsEqual=⪰̸\n+NotSucceedsSlantEqual=⋡\n+NotSucceedsTilde=≿̸\n+NotSuperset=⊃⃒\n+NotSupersetEqual=⊉\n+NotTilde=≁\n+NotTildeEqual=≄\n+NotTildeFullEqual=≇\n+NotTildeTilde=≉\n+NotVerticalBar=∤\n+nparallel=∦\n+npar=∦\n+nparsl=⫽⃥\n+npart=∂̸\n+npolint=⨔\n+npr=⊀\n+nprcue=⋠\n+nprec=⊀\n+npreceq=⪯̸\n+npre=⪯̸\n+nrarrc=⤳̸\n+nrarr=↛\n+nrArr=⇏\n+nrarrw=↝̸\n+nrightarrow=↛\n+nRightarrow=⇏\n+nrtri=⋫\n+nrtrie=⋭\n+nsc=⊁\n+nsccue=⋡\n+nsce=⪰̸\n+Nscr=𝒩\n+nscr=𝓃\n+nshortmid=∤\n+nshortparallel=∦\n+nsim=≁\n+nsime=≄\n+nsimeq=≄\n+nsmid=∤\n+nspar=∦\n+nsqsube=⋢\n+nsqsupe=⋣\n+nsub=⊄\n+nsubE=⫅̸\n+nsube=⊈\n+nsubset=⊂⃒\n+nsubseteq=⊈\n+nsubseteqq=⫅̸\n+nsucc=⊁\n+nsucceq=⪰̸\n+nsup=⊅\n+nsupE=⫆̸\n+nsupe=⊉\n+nsupset=⊃⃒\n+nsupseteq=⊉\n+nsupseteqq=⫆̸\n+ntgl=≹\n+Ntilde=Ñ\n+ntilde=ñ\n+ntlg=≸\n+ntriangleleft=⋪\n+ntrianglelefteq=⋬\n+ntriangleright=⋫\n+ntrianglerighteq=⋭\n+Nu=Ν\n+nu=ν\n+num=#\n+numero=№\n+numsp= \n+nvap=≍⃒\n+nvdash=⊬\n+nvDash=⊭\n+nVdash=⊮\n+nVDash=⊯\n+nvge=≥⃒\n+nvgt=>⃒\n+nvHarr=⤄\n+nvinfin=⧞\n+nvlArr=⤂\n+nvle=≤⃒\n+nvlt=<⃒\n+nvltrie=⊴⃒\n+nvrArr=⤃\n+nvrtrie=⊵⃒\n+nvsim=∼⃒\n+nwarhk=⤣\n+nwarr=↖\n+nwArr=⇖\n+nwarrow=↖\n+nwnear=⤧\n+Oacute=Ó\n+oacute=ó\n+oast=⊛\n+Ocirc=Ô\n+ocirc=ô\n+ocir=⊚\n+Ocy=О\n+ocy=о\n+odash=⊝\n+Odblac=Ő\n+odblac=ő\n+odiv=⨸\n+odot=⊙\n+odsold=⦼\n+OElig=Œ\n+oelig=œ\n+ofcir=⦿\n+Ofr=𝔒\n+ofr=𝔬\n+ogon=˛\n+Ograve=Ò\n+ograve=ò\n+ogt=⧁\n+ohbar=⦵\n+ohm=Ω\n+oint=∮\n+olarr=↺\n+olcir=⦾\n+olcross=⦻\n+oline=‾\n+olt=⧀\n+Omacr=Ō\n+omacr=ō\n+Omega=Ω\n+omega=ω\n+Omicron=Ο\n+omicron=ο\n+omid=⦶\n+ominus=⊖\n+Oopf=𝕆\n+oopf=𝕠\n+opar=⦷\n+OpenCurlyDoubleQuote=“\n+OpenCurlyQuote=‘\n+operp=⦹\n+oplus=⊕\n+orarr=↻\n+Or=⩔\n+or=∨\n+ord=⩝\n+order=ℴ\n+orderof=ℴ\n+ordf=ª\n+ordm=º\n+origof=⊶\n+oror=⩖\n+orslope=⩗\n+orv=⩛\n+oS=Ⓢ\n+Oscr=𝒪\n+oscr=ℴ\n+Oslash=Ø\n+oslash=ø\n+osol=⊘\n+Otilde=Õ\n+otilde=õ\n+otimesas=⨶\n+Otimes=⨷\n+otimes=⊗\n+Ouml=Ö\n+ouml=ö\n+ovbar=⌽\n+OverBar=‾\n+OverBrace=⏞\n+OverBracket=⎴\n+OverParenthesis=⏜\n+para=¶\n+parallel=∥\n+par=∥\n+parsim=⫳\n+parsl=⫽\n+part=∂\n+PartialD=∂\n+Pcy=П\n+pcy=п\n+percnt=%\n+period=.\n+permil=‰\n+perp=⊥\n+pertenk=‱\n+Pfr=𝔓\n+pfr=𝔭\n+Phi=Φ\n+phi=φ\n+phiv=ϕ\n+phmmat=ℳ\n+phone=☎\n+Pi=Π\n+pi=π\n+pitchfork=⋔\n+piv=ϖ\n+planck=ℏ\n+planckh=ℎ\n+plankv=ℏ\n+plusacir=⨣\n+plusb=⊞\n+pluscir=⨢\n+plus=+\n+plusdo=∔\n+plusdu=⨥\n+pluse=⩲\n+PlusMinus=±\n+plusmn=±\n+plussim=⨦\n+plustwo=⨧\n+pm=±\n+Poincareplane=ℌ\n+pointint=⨕\n+popf=𝕡\n+Popf=ℙ\n+pound=£\n+prap=⪷\n+Pr=⪻\n+pr=≺\n+prcue=≼\n+precapprox=⪷\n+prec=≺\n+preccurlyeq=≼\n+Precedes=≺\n+PrecedesEqual=⪯\n+PrecedesSlantEqual=≼\n+PrecedesTilde=≾\n+preceq=⪯\n+precnapprox=⪹\n+precneqq=⪵\n+precnsim=⋨\n+pre=⪯\n+prE=⪳\n+precsim=≾\n+prime=′\n+Prime=″\n+primes=ℙ\n+prnap=⪹\n+prnE=⪵\n+prnsim=⋨\n+prod=∏\n+Product=∏\n+profalar=⌮\n+profline=⌒\n+profsurf=⌓\n+prop=∝\n+Proportional=∝\n+Proportion=∷\n+propto=∝\n+prsim=≾\n+prurel=⊰\n+Pscr=𝒫\n+pscr=𝓅\n+Psi=Ψ\n+psi=ψ\n+puncsp= \n+Qfr=𝔔\n+qfr=𝔮\n+qint=⨌\n+qopf=𝕢\n+Qopf=ℚ\n+qprime=⁗\n+Qscr=𝒬\n+qscr=𝓆\n+quaternions=ℍ\n+quatint=⨖\n+quest=?\n+questeq=≟\n+quot=\"\n+QUOT=\"\n+rAarr=⇛\n+race=∽̱\n+Racute=Ŕ\n+racute=ŕ\n+radic=√\n+raemptyv=⦳\n+rang=⟩\n+Rang=⟫\n+rangd=⦒\n+range=⦥\n+rangle=⟩\n+raquo=»\n+rarrap=⥵\n+rarrb=⇥\n+rarrbfs=⤠\n+rarrc=⤳\n+rarr=→\n+Rarr=↠\n+rArr=⇒\n+rarrfs=⤞\n+rarrhk=↪\n+rarrlp=↬\n+rarrpl=⥅\n+rarrsim=⥴\n+Rarrtl=⤖\n+rarrtl=↣\n+rarrw=↝\n+ratail=⤚\n+rAtail=⤜\n+ratio=∶\n+rationals=ℚ\n+rbarr=⤍\n+rBarr=⤏\n+RBarr=⤐\n+rbbrk=❳\n+rbrace=}\n+rbrack=]\n+rbrke=⦌\n+rbrksld=⦎\n+rbrkslu=⦐\n+Rcaron=Ř\n+rcaron=ř\n+Rcedil=Ŗ\n+rcedil=ŗ\n+rceil=⌉\n+rcub=}\n+Rcy=Р\n+rcy=р\n+rdca=⤷\n+rdldhar=⥩\n+rdquo=”\n+rdquor=”\n+rdsh=↳\n+real=ℜ\n+realine=ℛ\n+realpart=ℜ\n+reals=ℝ\n+Re=ℜ\n+rect=▭\n+reg=®\n+REG=®\n+ReverseElement=∋\n+ReverseEquilibrium=⇋\n+ReverseUpEquilibrium=⥯\n+rfisht=⥽\n+rfloor=⌋\n+rfr=𝔯\n+Rfr=ℜ\n+rHar=⥤\n+rhard=⇁\n+rharu=⇀\n+rharul=⥬\n+Rho=Ρ\n+rho=ρ\n+rhov=ϱ\n+RightAngleBracket=⟩\n+RightArrowBar=⇥\n+rightarrow=→\n+RightArrow=→\n+Rightarrow=⇒\n+RightArrowLeftArrow=⇄\n+rightarrowtail=↣\n+RightCeiling=⌉\n+RightDoubleBracket=⟧\n+RightDownTeeVector=⥝\n+RightDownVectorBar=⥕\n+RightDownVector=⇂\n+RightFloor=⌋\n+rightharpoondown=⇁\n+rightharpoonup=⇀\n+rightleftarrows=⇄\n+rightleftharpoons=⇌\n+rightrightarrows=⇉\n+rightsquigarrow=↝\n+RightTeeArrow=↦\n+RightTee=⊢\n+RightTeeVector=⥛\n+rightthreetimes=⋌\n+RightTriangleBar=⧐\n+RightTriangle=⊳\n+RightTriangleEqual=⊵\n+RightUpDownVector=⥏\n+RightUpTeeVector=⥜\n+RightUpVectorBar=⥔\n+RightUpVector=↾\n+RightVectorBar=⥓\n+RightVector=⇀\n+ring=˚\n+risingdotseq=≓\n+rlarr=⇄\n+rlhar=⇌\n+rlm=‏\n+rmoustache=⎱\n+rmoust=⎱\n+rnmid=⫮\n+roang=⟭\n+roarr=⇾\n+robrk=⟧\n+ropar=⦆\n+ropf=𝕣\n+Ropf=ℝ\n+roplus=⨮\n+rotimes=⨵\n+RoundImplies=⥰\n+rpar=)\n+rpargt=⦔\n+rppolint=⨒\n+rrarr=⇉\n+Rrightarrow=⇛\n+rsaquo=›\n+rscr=𝓇\n+Rscr=ℛ\n+rsh=↱\n+Rsh=↱\n+rsqb=]\n+rsquo=’\n+rsquor=’\n+rthree=⋌\n+rtimes=⋊\n+rtri=▹\n+rtrie=⊵\n+rtrif=▸\n+rtriltri=⧎\n+RuleDelayed=⧴\n+ruluhar=⥨\n+rx=℞\n+Sacute=Ś\n+sacute=ś\n+sbquo=‚\n+scap=⪸\n+Scaron=Š\n+scaron=š\n+Sc=⪼\n+sc=≻\n+sccue=≽\n+sce=⪰\n+scE=⪴\n+Scedil=Ş\n+scedil=ş\n+Scirc=Ŝ\n+scirc=ŝ\n+scnap=⪺\n+scnE=⪶\n+scnsim=⋩\n+scpolint=⨓\n+scsim=≿\n+Scy=С\n+scy=с\n+sdotb=⊡\n+sdot=⋅\n+sdote=⩦\n+searhk=⤥\n+searr=↘\n+seArr=⇘\n+searrow=↘\n+sect=§\n+semi=;\n+seswar=⤩\n+setminus=∖\n+setmn=∖\n+sext=✶\n+Sfr=𝔖\n+sfr=𝔰\n+sfrown=⌢\n+sharp=♯\n+SHCHcy=Щ\n+shchcy=щ\n+SHcy=Ш\n+shcy=ш\n+ShortDownArrow=↓\n+ShortLeftArrow=←\n+shortmid=∣\n+shortparallel=∥\n+ShortRightArrow=→\n+ShortUpArrow=↑\n+shy=­\n+Sigma=Σ\n+sigma=σ\n+sigmaf=ς\n+sigmav=ς\n+sim=∼\n+simdot=⩪\n+sime=≃\n+simeq=≃\n+simg=⪞\n+simgE=⪠\n+siml=⪝\n+simlE=⪟\n+simne=≆\n+simplus=⨤\n+simrarr=⥲\n+slarr=←\n+SmallCircle=∘\n+smallsetminus=∖\n+smashp=⨳\n+smeparsl=⧤\n+smid=∣\n+smile=⌣\n+smt=⪪\n+smte=⪬\n+smtes=⪬︀\n+SOFTcy=Ь\n+softcy=ь\n+solbar=⌿\n+solb=⧄\n+sol=\/\n+Sopf=𝕊\n+sopf=𝕤\n+spades=♠\n+spadesuit=♠\n+spar=∥\n+sqcap=⊓\n+sqcaps=⊓︀\n+sqcup=⊔\n+sqcups=⊔︀\n+Sqrt=√\n+sqsub=⊏\n+sqsube=⊑\n+sqsubset=⊏\n+sqsubseteq=⊑\n+sqsup=⊐\n+sqsupe=⊒\n+sqsupset=⊐\n+sqsupseteq=⊒\n+square=□\n+Square=□\n+SquareIntersection=⊓\n+SquareSubset=⊏\n+SquareSubsetEqual=⊑\n+SquareSuperset=⊐\n+SquareSupersetEqual=⊒\n+SquareUnion=⊔\n+squarf=▪\n+squ=□\n+squf=▪\n+srarr=→\n+Sscr=𝒮\n+sscr=𝓈\n+ssetmn=∖\n+ssmile=⌣\n+sstarf=⋆\n+Star=⋆\n+star=☆\n+starf=★\n+straightepsilon=ϵ\n+straightphi=ϕ\n+strns=¯\n+sub=⊂\n+Sub=⋐\n+subdot=⪽\n+subE=⫅\n+sube=⊆\n+subedot=⫃\n+submult=⫁\n+subnE=⫋\n+subne=⊊\n+subplus=⪿\n+subrarr=⥹\n+subset=⊂\n+Subset=⋐\n+subseteq=⊆\n+subseteqq=⫅\n+SubsetEqual=⊆\n+subsetneq=⊊\n+subsetneqq=⫋\n+subsim=⫇\n+subsub=⫕\n+subsup=⫓\n+succapprox=⪸\n+succ=≻\n+succcurlyeq=≽\n+Succeeds=≻\n+SucceedsEqual=⪰\n+SucceedsSlantEqual=≽\n+SucceedsTilde=≿\n+succeq=⪰\n+succnapprox=⪺\n+succneqq=⪶\n+succnsim=⋩\n+succsim=≿\n+SuchThat=∋\n+sum=∑\n+Sum=∑\n+sung=♪\n+sup1=¹\n+sup2=²\n+sup3=³\n+sup=⊃\n+Sup=⋑\n+supdot=⪾\n+supdsub=⫘\n+supE=⫆\n+supe=⊇\n+supedot=⫄\n+Superset=⊃\n+SupersetEqual=⊇\n+suphsol=⟉\n+suphsub=⫗\n+suplarr=⥻\n+supmult=⫂\n+supnE=⫌\n+supne=⊋\n+supplus=⫀\n+supset=⊃\n+Supset=⋑\n+supseteq=⊇\n+supseteqq=⫆\n+supsetneq=⊋\n+supsetneqq=⫌\n+supsim=⫈\n+supsub=⫔\n+supsup=⫖\n+swarhk=⤦\n+swarr=↙\n+swArr=⇙\n+swarrow=↙\n+swnwar=⤪\n+szlig=ß\n+Tab=\t\n+target=⌖\n+Tau=Τ\n+tau=τ\n+tbrk=⎴\n+Tcaron=Ť\n+tcaron=ť\n+Tcedil=Ţ\n+tcedil=ţ\n+Tcy=Т\n+tcy=т\n+tdot=⃛\n+telrec=⌕\n+Tfr=𝔗\n+tfr=𝔱\n+there4=∴\n+therefore=∴\n+Therefore=∴\n+Theta=Θ\n+theta=θ\n+thetasym=ϑ\n+thetav=ϑ\n+thickapprox=≈\n+thicksim=∼\n+ThickSpace=  \n+ThinSpace= \n+thinsp= \n+thkap=≈\n+thksim=∼\n+THORN=Þ\n+thorn=þ\n+tilde=˜\n+Tilde=∼\n+TildeEqual=≃\n+TildeFullEqual=≅\n+TildeTilde=≈\n+timesbar=⨱\n+timesb=⊠\n+times=×\n+timesd=⨰\n+tint=∭\n+toea=⤨\n+topbot=⌶\n+topcir=⫱\n+top=⊤\n+Topf=𝕋\n+topf=𝕥\n+topfork=⫚\n+tosa=⤩\n+tprime=‴\n+trade=™\n+TRADE=™\n+triangle=▵\n+triangledown=▿\n+triangleleft=◃\n+trianglelefteq=⊴\n+triangleq=≜\n+triangleright=▹\n+trianglerighteq=⊵\n+tridot=◬\n+trie=≜\n+triminus=⨺\n+TripleDot=⃛\n+triplus=⨹\n+trisb=⧍\n+tritime=⨻\n+trpezium=⏢\n+Tscr=𝒯\n+tscr=𝓉\n+TScy=Ц\n+tscy=ц\n+TSHcy=Ћ\n+tshcy=ћ\n+Tstrok=Ŧ\n+tstrok=ŧ\n+twixt=≬\n+twoheadleftarrow=↞\n+twoheadrightarrow=↠\n+Uacute=Ú\n+uacute=ú\n+uarr=↑\n+Uarr=↟\n+uArr=⇑\n+Uarrocir=⥉\n+Ubrcy=Ў\n+ubrcy=ў\n+Ubreve=Ŭ\n+ubreve=ŭ\n+Ucirc=Û\n+ucirc=û\n+Ucy=У\n+ucy=у\n+udarr=⇅\n+Udblac=Ű\n+udblac=ű\n+udhar=⥮\n+ufisht=⥾\n+Ufr=𝔘\n+ufr=𝔲\n+Ugrave=Ù\n+ugrave=ù\n+uHar=⥣\n+uharl=↿\n+uharr=↾\n+uhblk=▀\n+ulcorn=⌜\n+ulcorner=⌜\n+ulcrop=⌏\n+ultri=◸\n+Umacr=Ū\n+umacr=ū\n+uml=¨\n+UnderBar=_\n+UnderBrace=⏟\n+UnderBracket=⎵\n+UnderParenthesis=⏝\n+Union=⋃\n+UnionPlus=⊎\n+Uogon=Ų\n+uogon=ų\n+Uopf=𝕌\n+uopf=𝕦\n+UpArrowBar=⤒\n+uparrow=↑\n+UpArrow=↑\n+Uparrow=⇑\n+UpArrowDownArrow=⇅\n+updownarrow=↕\n+UpDownArrow=↕\n+Updownarrow=⇕\n+UpEquilibrium=⥮\n+upharpoonleft=↿\n+upharpoonright=↾\n+uplus=⊎\n+UpperLeftArrow=↖\n+UpperRightArrow=↗\n+upsi=υ\n+Upsi=ϒ\n+upsih=ϒ\n+Upsilon=Υ\n+upsilon=υ\n+UpTeeArrow=↥\n+UpTee=⊥\n+upuparrows=⇈\n+urcorn=⌝\n+urcorner=⌝\n+urcrop=⌎\n+Uring=Ů\n+uring=ů\n+urtri=◹\n+Uscr=𝒰\n+uscr=𝓊\n+utdot=⋰\n+Utilde=Ũ\n+utilde=ũ\n+utri=▵\n+utrif=▴\n+uuarr=⇈\n+Uuml=Ü\n+uuml=ü\n+uwangle=⦧\n+vangrt=⦜\n+varepsilon=ϵ\n+varkappa=ϰ\n+varnothing=∅\n+varphi=ϕ\n+varpi=ϖ\n+varpropto=∝\n+varr=↕\n+vArr=⇕\n+varrho=ϱ\n+varsigma=ς\n+varsubsetneq=⊊︀\n+varsubsetneqq=⫋︀\n+varsupsetneq=⊋︀\n+varsupsetneqq=⫌︀\n+vartheta=ϑ\n+vartriangleleft=⊲\n+vartriangleright=⊳\n+vBar=⫨\n+Vbar=⫫\n+vBarv=⫩\n+Vcy=В\n+vcy=в\n+vdash=⊢\n+vDash=⊨\n+Vdash=⊩\n+VDash=⊫\n+Vdashl=⫦\n+veebar=⊻\n+vee=∨\n+Vee=⋁\n+veeeq=≚\n+vellip=⋮\n+verbar=|\n+Verbar=‖\n+vert=|\n+Vert=‖\n+VerticalBar=∣\n+VerticalLine=|\n+VerticalSeparator=❘\n+VerticalTilde=≀\n+VeryThinSpace= \n+Vfr=𝔙\n+vfr=𝔳\n+vltri=⊲\n+vnsub=⊂⃒\n+vnsup=⊃⃒\n+Vopf=𝕍\n+vopf=𝕧\n+vprop=∝\n+vrtri=⊳\n+Vscr=𝒱\n+vscr=𝓋\n+vsubnE=⫋︀\n+vsubne=⊊︀\n+vsupnE=⫌︀\n+vsupne=⊋︀\n+Vvdash=⊪\n+vzigzag=⦚\n+Wcirc=Ŵ\n+wcirc=ŵ\n+wedbar=⩟\n+wedge=∧\n+Wedge=⋀\n+wedgeq=≙\n+weierp=℘\n+Wfr=𝔚\n+wfr=𝔴\n+Wopf=𝕎\n+wopf=𝕨\n+wp=℘\n+wr=≀\n+wreath=≀\n+Wscr=𝒲\n+wscr=𝓌\n+xcap=⋂\n+xcirc=◯\n+xcup=⋃\n+xdtri=▽\n+Xfr=𝔛\n+xfr=𝔵\n+xharr=⟷\n+xhArr=⟺\n+Xi=Ξ\n+xi=ξ\n+xlarr=⟵\n+xlArr=⟸\n+xmap=⟼\n+xnis=⋻\n+xodot=⨀\n+Xopf=𝕏\n+xopf=𝕩\n+xoplus=⨁\n+xotime=⨂\n+xrarr=⟶\n+xrArr=⟹\n+Xscr=𝒳\n+xscr=𝓍\n+xsqcup=⨆\n+xuplus=⨄\n+xutri=△\n+xvee=⋁\n+xwedge=⋀\n+Yacute=Ý\n+yacute=ý\n+YAcy=Я\n+yacy=я\n+Ycirc=Ŷ\n+ycirc=ŷ\n+Ycy=Ы\n+ycy=ы\n+yen=¥\n+Yfr=𝔜\n+yfr=𝔶\n+YIcy=Ї\n+yicy=ї\n+Yopf=𝕐\n+yopf=𝕪\n+Yscr=𝒴\n+yscr=𝓎\n+YUcy=Ю\n+yucy=ю\n+yuml=ÿ\n+Yuml=Ÿ\n+Zacute=Ź\n+zacute=ź\n+Zcaron=Ž\n+zcaron=ž\n+Zcy=З\n+zcy=з\n+Zdot=Ż\n+zdot=ż\n+zeetrf=ℨ\n+ZeroWidthSpace=​\n+Zeta=Ζ\n+zeta=ζ\n+zfr=𝔷\n+Zfr=ℨ\n+ZHcy=Ж\n+zhcy=ж\n+zigrarr=⇝\n+zopf=𝕫\n+Zopf=ℤ\n+Zscr=𝒵\n+zscr=𝓏\n+zwj=‍\n+zwnj=‌\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/internal\/util\/entities.txt","additions":2126,"deletions":0,"binary":false,"changes":2126,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Abstract visitor that visits all children by default.\n+ * <p>\n+ * Can be used to only process certain nodes. If you override a method and want visiting to descend into children,\n+ * call {@link #visitChildren}.\n+ *\/\n+public abstract class AbstractVisitor implements Visitor {\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        visitChildren(blockQuote);\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        visitChildren(bulletList);\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        visitChildren(code);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        visitChildren(document);\n+    }\n+\n+    @Override\n+    public void visit(Emphasis emphasis) {\n+        visitChildren(emphasis);\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock fencedCodeBlock) {\n+        visitChildren(fencedCodeBlock);\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        visitChildren(hardLineBreak);\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        visitChildren(heading);\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        visitChildren(thematicBreak);\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        visitChildren(htmlInline);\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        visitChildren(htmlBlock);\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        visitChildren(image);\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        visitChildren(indentedCodeBlock);\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        visitChildren(link);\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        visitChildren(listItem);\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        visitChildren(orderedList);\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        visitChildren(paragraph);\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        visitChildren(softLineBreak);\n+    }\n+\n+    @Override\n+    public void visit(StrongEmphasis strongEmphasis) {\n+        visitChildren(strongEmphasis);\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        visitChildren(text);\n+    }\n+\n+    @Override\n+    public void visit(LinkReferenceDefinition linkReferenceDefinition) {\n+        visitChildren(linkReferenceDefinition);\n+    }\n+\n+    @Override\n+    public void visit(CustomBlock customBlock) {\n+        visitChildren(customBlock);\n+    }\n+\n+    @Override\n+    public void visit(CustomNode customNode) {\n+        visitChildren(customNode);\n+    }\n+\n+    \/**\n+     * Visit the child nodes.\n+     *\n+     * @param parent the parent node whose children should be visited\n+     *\/\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            \/\/ A subclass of this visitor might modify the node, resulting in getNext returning a different node or no\n+            \/\/ node after visiting it. So get the next node before visiting.\n+            Node next = node.getNext();\n+            node.accept(this);\n+            node = next;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/AbstractVisitor.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Block nodes such as paragraphs, list blocks, code blocks etc.\n+ *\/\n+public abstract class Block extends Node {\n+\n+    public Block getParent() {\n+        return (Block) super.getParent();\n+    }\n+\n+    @Override\n+    protected void setParent(Node parent) {\n+        if (!(parent instanceof Block)) {\n+            throw new IllegalArgumentException(\"Parent of block must also be block (can not be inline)\");\n+        }\n+        super.setParent(parent);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Block.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class BlockQuote extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/BlockQuote.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class BulletList extends ListBlock {\n+\n+    private String marker;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    \/**\n+     * @return the bullet list marker that was used, e.g. {@code -}, {@code *} or {@code +}, if available, or null otherwise\n+     *\/\n+    public String getMarker() {\n+        return marker;\n+    }\n+\n+    public void setMarker(String marker) {\n+        this.marker = marker;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getMarker()} instead\n+     *\/\n+    @Deprecated\n+    public char getBulletMarker() {\n+        return marker != null && !marker.isEmpty() ? marker.charAt(0) : '\\0';\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getMarker()} instead\n+     *\/\n+    @Deprecated\n+    public void setBulletMarker(char bulletMarker) {\n+        this.marker = bulletMarker != '\\0' ? String.valueOf(bulletMarker) : null;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/BulletList.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Code extends Node {\n+\n+    private String literal;\n+\n+    public Code() {\n+    }\n+\n+    public Code(String literal) {\n+        this.literal = literal;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Code.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public abstract class CustomBlock extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/CustomBlock.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public abstract class CustomNode extends Node {\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/CustomNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A node that uses delimiters in the source form (e.g. <code>*bold*<\/code>).\n+ *\/\n+public interface Delimited {\n+\n+    \/**\n+     * @return the opening (beginning) delimiter, e.g. <code>*<\/code>\n+     *\/\n+    String getOpeningDelimiter();\n+\n+    \/**\n+     * @return the closing (ending) delimiter, e.g. <code>*<\/code>\n+     *\/\n+    String getClosingDelimiter();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Delimited.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Document extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Document.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Emphasis extends Node implements Delimited {\n+\n+    private String delimiter;\n+\n+    public Emphasis() {\n+    }\n+\n+    public Emphasis(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    public void setDelimiter(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    @Override\n+    public String getOpeningDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public String getClosingDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Emphasis.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class FencedCodeBlock extends Block {\n+\n+    private String fenceCharacter;\n+    private Integer openingFenceLength;\n+    private Integer closingFenceLength;\n+    private int fenceIndent;\n+\n+    private String info;\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    \/**\n+     * @return the fence character that was used, e.g. {@code `} or {@code ~}, if available, or null otherwise\n+     *\/\n+    public String getFenceCharacter() {\n+        return fenceCharacter;\n+    }\n+\n+    public void setFenceCharacter(String fenceCharacter) {\n+        this.fenceCharacter = fenceCharacter;\n+    }\n+\n+    \/**\n+     * @return the length of the opening fence (how many of {{@link #getFenceCharacter()}} were used to start the code\n+     * block) if available, or null otherwise\n+     *\/\n+    public Integer getOpeningFenceLength() {\n+        return openingFenceLength;\n+    }\n+\n+    public void setOpeningFenceLength(Integer openingFenceLength) {\n+        if (openingFenceLength != null && openingFenceLength < 3) {\n+            throw new IllegalArgumentException(\"openingFenceLength needs to be >= 3\");\n+        }\n+        checkFenceLengths(openingFenceLength, closingFenceLength);\n+        this.openingFenceLength = openingFenceLength;\n+    }\n+\n+    \/**\n+     * @return the length of the closing fence (how many of {@link #getFenceCharacter()} were used to end the code\n+     * block) if available, or null otherwise\n+     *\/\n+    public Integer getClosingFenceLength() {\n+        return closingFenceLength;\n+    }\n+\n+    public void setClosingFenceLength(Integer closingFenceLength) {\n+        if (closingFenceLength != null && closingFenceLength < 3) {\n+            throw new IllegalArgumentException(\"closingFenceLength needs to be >= 3\");\n+        }\n+        checkFenceLengths(openingFenceLength, closingFenceLength);\n+        this.closingFenceLength = closingFenceLength;\n+    }\n+\n+    public int getFenceIndent() {\n+        return fenceIndent;\n+    }\n+\n+    public void setFenceIndent(int fenceIndent) {\n+        this.fenceIndent = fenceIndent;\n+    }\n+\n+    \/**\n+     * @see <a href=\"http:\/\/spec.commonmark.org\/0.18\/#info-string\">CommonMark spec<\/a>\n+     *\/\n+    public String getInfo() {\n+        return info;\n+    }\n+\n+    public void setInfo(String info) {\n+        this.info = info;\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getFenceCharacter()} instead\n+     *\/\n+    @Deprecated\n+    public char getFenceChar() {\n+        return fenceCharacter != null && !fenceCharacter.isEmpty() ? fenceCharacter.charAt(0) : '\\0';\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #setFenceCharacter} instead\n+     *\/\n+    @Deprecated\n+    public void setFenceChar(char fenceChar) {\n+        this.fenceCharacter = fenceChar != '\\0' ? String.valueOf(fenceChar) : null;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getOpeningFenceLength} instead\n+     *\/\n+    @Deprecated\n+    public int getFenceLength() {\n+        return openingFenceLength != null ? openingFenceLength : 0;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #setOpeningFenceLength} instead\n+     *\/\n+    @Deprecated\n+    public void setFenceLength(int fenceLength) {\n+        this.openingFenceLength = fenceLength != 0 ? fenceLength : null;\n+    }\n+\n+    private static void checkFenceLengths(Integer openingFenceLength, Integer closingFenceLength) {\n+        if (openingFenceLength != null && closingFenceLength != null) {\n+            if (closingFenceLength < openingFenceLength) {\n+                throw new IllegalArgumentException(\"fence lengths required to be: closingFenceLength >= openingFenceLength\");\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/FencedCodeBlock.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class HardLineBreak extends Node {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/HardLineBreak.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Heading extends Block {\n+\n+    private int level;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public int getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(int level) {\n+        this.level = level;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Heading.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * HTML block\n+ *\n+ * @see <a href=\"http:\/\/spec.commonmark.org\/0.18\/#html-blocks\">CommonMark Spec<\/a>\n+ *\/\n+public class HtmlBlock extends Block {\n+\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/HtmlBlock.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Inline HTML element.\n+ *\n+ * @see <a href=\"http:\/\/spec.commonmark.org\/0.24\/#raw-html\">CommonMark Spec<\/a>\n+ *\/\n+public class HtmlInline extends Node {\n+\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/HtmlInline.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Image extends Node {\n+\n+    private String destination;\n+    private String title;\n+\n+    public Image() {\n+    }\n+\n+    public Image(String destination, String title) {\n+        this.destination = destination;\n+        this.title = title;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getDestination() {\n+        return destination;\n+    }\n+\n+    public void setDestination(String destination) {\n+        this.destination = destination;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n+\n+    @Override\n+    protected String toStringAttributes() {\n+        return \"destination=\" + destination + \", title=\" + title;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Image.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class IndentedCodeBlock extends Block {\n+\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/IndentedCodeBlock.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A link with a destination and an optional title; the link text is in child nodes.\n+ * <p>\n+ * Example for an inline link in a CommonMark document:\n+ * <pre><code>\n+ * [link](\/uri \"title\")\n+ * <\/code><\/pre>\n+ * <p>\n+ * The corresponding Link node would look like this:\n+ * <ul>\n+ * <li>{@link #getDestination()} returns {@code \"\/uri\"}\n+ * <li>{@link #getTitle()} returns {@code \"title\"}\n+ * <li>A {@link Text} child node with {@link Text#getLiteral() getLiteral} that returns {@code \"link\"}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Note that the text in the link can contain inline formatting, so it could also contain an {@link Image} or\n+ * {@link Emphasis}, etc.\n+ *\n+ * @see <a href=\"http:\/\/spec.commonmark.org\/0.26\/#links\">CommonMark Spec for links<\/a>\n+ *\/\n+public class Link extends Node {\n+\n+    private String destination;\n+    private String title;\n+\n+    public Link() {\n+    }\n+\n+    public Link(String destination, String title) {\n+        this.destination = destination;\n+        this.title = title;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getDestination() {\n+        return destination;\n+    }\n+\n+    public void setDestination(String destination) {\n+        this.destination = destination;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n+\n+    @Override\n+    protected String toStringAttributes() {\n+        return \"destination=\" + destination + \", title=\" + title;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Link.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A link reference definition, e.g.:\n+ * <pre><code>\n+ * [foo]: \/url \"title\"\n+ * <\/code><\/pre>\n+ * <p>\n+ * They can be referenced anywhere else in the document to produce a link using <code>[foo]<\/code>. The definitions\n+ * themselves are usually not rendered in the final output.\n+ *\n+ * @see <a href=\"https:\/\/spec.commonmark.org\/0.29\/#link-reference-definition\">Link reference definitions<\/a>\n+ *\/\n+public class LinkReferenceDefinition extends Node {\n+\n+    private String label;\n+    private String destination;\n+    private String title;\n+\n+    public LinkReferenceDefinition() {\n+    }\n+\n+    public LinkReferenceDefinition(String label, String destination, String title) {\n+        this.label = label;\n+        this.destination = destination;\n+        this.title = title;\n+    }\n+\n+    public String getLabel() {\n+        return label;\n+    }\n+\n+    public void setLabel(String label) {\n+        this.label = label;\n+    }\n+\n+    public String getDestination() {\n+        return destination;\n+    }\n+\n+    public void setDestination(String destination) {\n+        this.destination = destination;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/LinkReferenceDefinition.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public abstract class ListBlock extends Block {\n+\n+    private boolean tight;\n+\n+    \/**\n+     * @return whether this list is tight or loose\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.28\/#tight\">CommonMark Spec for tight lists<\/a>\n+     *\/\n+    public boolean isTight() {\n+        return tight;\n+    }\n+\n+    public void setTight(boolean tight) {\n+        this.tight = tight;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ListBlock.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class ListItem extends Block {\n+\n+    private Integer markerIndent;\n+    private Integer contentIndent;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    \/**\n+     * Returns the indent of the marker such as \"-\" or \"1.\" in columns (spaces or tab stop of 4) if available, or null\n+     * otherwise.\n+     * <p>\n+     * Some examples and their marker indent:\n+     * <pre>- Foo<\/pre>\n+     * Marker indent: 0\n+     * <pre> - Foo<\/pre>\n+     * Marker indent: 1\n+     * <pre>  1. Foo<\/pre>\n+     * Marker indent: 2\n+     *\/\n+    public Integer getMarkerIndent() {\n+        return markerIndent;\n+    }\n+\n+    public void setMarkerIndent(Integer markerIndent) {\n+        this.markerIndent = markerIndent;\n+    }\n+\n+    \/**\n+     * Returns the indent of the content in columns (spaces or tab stop of 4) if available, or null otherwise.\n+     * The content indent is counted from the beginning of the line and includes the marker on the first line.\n+     * <p>\n+     * Some examples and their content indent:\n+     * <pre>- Foo<\/pre>\n+     * Content indent: 2\n+     * <pre> - Foo<\/pre>\n+     * Content indent: 3\n+     * <pre>  1. Foo<\/pre>\n+     * Content indent: 5\n+     * <p>\n+     * Note that subsequent lines in the same list item need to be indented by at least the content indent to be counted\n+     * as part of the list item.\n+     *\/\n+    public Integer getContentIndent() {\n+        return contentIndent;\n+    }\n+\n+    public void setContentIndent(Integer contentIndent) {\n+        this.contentIndent = contentIndent;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ListItem.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * The base class of all CommonMark AST nodes ({@link Block} and inlines).\n+ * <p>\n+ * A node can have multiple children, and a parent (except for the root node).\n+ *\/\n+public abstract class Node {\n+\n+    private Node parent = null;\n+    private Node firstChild = null;\n+    private Node lastChild = null;\n+    private Node prev = null;\n+    private Node next = null;\n+    private List<SourceSpan> sourceSpans = null;\n+\n+    public abstract void accept(Visitor visitor);\n+\n+    public Node getNext() {\n+        return next;\n+    }\n+\n+    public Node getPrevious() {\n+        return prev;\n+    }\n+\n+    public Node getFirstChild() {\n+        return firstChild;\n+    }\n+\n+    public Node getLastChild() {\n+        return lastChild;\n+    }\n+\n+    public Node getParent() {\n+        return parent;\n+    }\n+\n+    protected void setParent(Node parent) {\n+        this.parent = parent;\n+    }\n+\n+    public void appendChild(Node child) {\n+        child.unlink();\n+        child.setParent(this);\n+        if (this.lastChild != null) {\n+            this.lastChild.next = child;\n+            child.prev = this.lastChild;\n+            this.lastChild = child;\n+        } else {\n+            this.firstChild = child;\n+            this.lastChild = child;\n+        }\n+    }\n+\n+    public void prependChild(Node child) {\n+        child.unlink();\n+        child.setParent(this);\n+        if (this.firstChild != null) {\n+            this.firstChild.prev = child;\n+            child.next = this.firstChild;\n+            this.firstChild = child;\n+        } else {\n+            this.firstChild = child;\n+            this.lastChild = child;\n+        }\n+    }\n+\n+    public void unlink() {\n+        if (this.prev != null) {\n+            this.prev.next = this.next;\n+        } else if (this.parent != null) {\n+            this.parent.firstChild = this.next;\n+        }\n+        if (this.next != null) {\n+            this.next.prev = this.prev;\n+        } else if (this.parent != null) {\n+            this.parent.lastChild = this.prev;\n+        }\n+        this.parent = null;\n+        this.next = null;\n+        this.prev = null;\n+    }\n+\n+    public void insertAfter(Node sibling) {\n+        sibling.unlink();\n+        sibling.next = this.next;\n+        if (sibling.next != null) {\n+            sibling.next.prev = sibling;\n+        }\n+        sibling.prev = this;\n+        this.next = sibling;\n+        sibling.parent = this.parent;\n+        if (sibling.next == null) {\n+            sibling.parent.lastChild = sibling;\n+        }\n+    }\n+\n+    public void insertBefore(Node sibling) {\n+        sibling.unlink();\n+        sibling.prev = this.prev;\n+        if (sibling.prev != null) {\n+            sibling.prev.next = sibling;\n+        }\n+        sibling.next = this;\n+        this.prev = sibling;\n+        sibling.parent = this.parent;\n+        if (sibling.prev == null) {\n+            sibling.parent.firstChild = sibling;\n+        }\n+    }\n+\n+\n+    \/**\n+     * @return the source spans of this node if included by the parser, an empty list otherwise\n+     * @since 0.16.0\n+     *\/\n+    public List<SourceSpan> getSourceSpans() {\n+        return sourceSpans != null ? Collections.unmodifiableList(sourceSpans) : Collections.<SourceSpan>emptyList();\n+    }\n+\n+    \/**\n+     * Replace the current source spans with the provided list.\n+     *\n+     * @param sourceSpans the new source spans to set\n+     * @since 0.16.0\n+     *\/\n+    public void setSourceSpans(List<SourceSpan> sourceSpans) {\n+        if (sourceSpans.isEmpty()) {\n+            this.sourceSpans = null;\n+        } else {\n+            this.sourceSpans = new ArrayList<>(sourceSpans);\n+        }\n+    }\n+\n+    \/**\n+     * Add a source span to the end of the list.\n+     *\n+     * @param sourceSpan the source span to add\n+     * @since 0.16.0\n+     *\/\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        if (sourceSpans == null) {\n+            this.sourceSpans = new ArrayList<>();\n+        }\n+        this.sourceSpans.add(sourceSpan);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName() + \"{\" + toStringAttributes() + \"}\";\n+    }\n+\n+    protected String toStringAttributes() {\n+        return \"\";\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Node.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.Iterator;\n+\n+\/**\n+ * Utility class for working with multiple {@link Node}s.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class Nodes {\n+\n+    private Nodes() {\n+    }\n+\n+    \/**\n+     * The nodes between (not including) start and end.\n+     *\/\n+    public static Iterable<Node> between(Node start, Node end) {\n+        return new NodeIterable(start.getNext(), end);\n+    }\n+\n+    private static class NodeIterable implements Iterable<Node> {\n+\n+        private final Node first;\n+        private final Node end;\n+\n+        private NodeIterable(Node first, Node end) {\n+            this.first = first;\n+            this.end = end;\n+        }\n+\n+        @Override\n+        public Iterator<Node> iterator() {\n+            return new NodeIterator(first, end);\n+        }\n+    }\n+\n+    private static class NodeIterator implements Iterator<Node> {\n+\n+        private Node node;\n+        private final Node end;\n+\n+        private NodeIterator(Node first, Node end) {\n+            node = first;\n+            this.end = end;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return node != null && node != end;\n+        }\n+\n+        @Override\n+        public Node next() {\n+            Node result = node;\n+            node = node.getNext();\n+            return result;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException(\"remove\");\n+        }\n+    }\n+}\n+\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Nodes.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class OrderedList extends ListBlock {\n+\n+    private String markerDelimiter;\n+    private Integer markerStartNumber;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    \/**\n+     * @return the start number used in the marker, e.g. {@code 1}, if available, or null otherwise\n+     *\/\n+    public Integer getMarkerStartNumber() {\n+        return markerStartNumber;\n+    }\n+\n+    public void setMarkerStartNumber(Integer markerStartNumber) {\n+        this.markerStartNumber = markerStartNumber;\n+    }\n+\n+    \/**\n+     * @return the delimiter used in the marker, e.g. {@code .} or {@code )}, if available, or null otherwise\n+     *\/\n+    public String getMarkerDelimiter() {\n+        return markerDelimiter;\n+    }\n+\n+    public void setMarkerDelimiter(String markerDelimiter) {\n+        this.markerDelimiter = markerDelimiter;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getMarkerStartNumber()} instead\n+     *\/\n+    @Deprecated\n+    public int getStartNumber() {\n+        return markerStartNumber != null ? markerStartNumber : 0;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #setMarkerStartNumber} instead\n+     *\/\n+    @Deprecated\n+    public void setStartNumber(int startNumber) {\n+        this.markerStartNumber = startNumber != 0 ? startNumber : null;\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #getMarkerDelimiter()} instead\n+     *\/\n+    @Deprecated\n+    public char getDelimiter() {\n+        return markerDelimiter != null && !markerDelimiter.isEmpty() ? markerDelimiter.charAt(0) : '\\0';\n+    }\n+\n+    \/**\n+     * @deprecated use {@link #setMarkerDelimiter} instead\n+     *\/\n+    @Deprecated\n+    public void setDelimiter(char delimiter) {\n+        this.markerDelimiter = delimiter != '\\0' ? String.valueOf(delimiter) : null;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/OrderedList.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * A paragraph block, contains inline nodes such as {@link Text}\n+ *\/\n+public class Paragraph extends Block {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Paragraph.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class SoftLineBreak extends Node {\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/SoftLineBreak.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * A source span references a snippet of text from the source input.\n+ * <p>\n+ * It has a starting position (line and column index) and a length of how many characters it spans.\n+ * <p>\n+ * For example, this CommonMark source text:\n+ * <pre><code>\n+ * &gt; foo\n+ * <\/code><\/pre>\n+ * The {@link BlockQuote} node would have this source span: line 0, column 0, length 5.\n+ * <p>\n+ * The {@link Paragraph} node inside it would have: line 0, column 2, length 3.\n+ * <p>\n+ * If a block has multiple lines, it will have a source span for each line.\n+ * <p>\n+ * Note that the column index and length are measured in Java characters (UTF-16 code units). If you're outputting them\n+ * to be consumed by another programming language, e.g. one that uses UTF-8 strings, you will need to translate them,\n+ * otherwise characters such as emojis will result in incorrect positions.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceSpan {\n+\n+    private final int lineIndex;\n+    private final int columnIndex;\n+    private final int length;\n+\n+    public static SourceSpan of(int lineIndex, int columnIndex, int length) {\n+        return new SourceSpan(lineIndex, columnIndex, length);\n+    }\n+\n+    private SourceSpan(int lineIndex, int columnIndex, int length) {\n+        this.lineIndex = lineIndex;\n+        this.columnIndex = columnIndex;\n+        this.length = length;\n+    }\n+\n+    \/**\n+     * @return 0-based index of line in source\n+     *\/\n+    public int getLineIndex() {\n+        return lineIndex;\n+    }\n+\n+    \/**\n+     * @return 0-based index of column (character on line) in source\n+     *\/\n+    public int getColumnIndex() {\n+        return columnIndex;\n+    }\n+\n+    \/**\n+     * @return length of the span in characters\n+     *\/\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        SourceSpan that = (SourceSpan) o;\n+        return lineIndex == that.lineIndex &&\n+                columnIndex == that.columnIndex &&\n+                length == that.length;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(lineIndex, columnIndex, length);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SourceSpan{\" +\n+                \"line=\" + lineIndex +\n+                \", column=\" + columnIndex +\n+                \", length=\" + length +\n+                \"}\";\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/SourceSpan.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * A list of source spans that can be added to. Takes care of merging adjacent source spans.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceSpans {\n+\n+    private List<SourceSpan> sourceSpans;\n+\n+    public static SourceSpans empty() {\n+        return new SourceSpans();\n+    }\n+\n+    public List<SourceSpan> getSourceSpans() {\n+        return sourceSpans != null ? sourceSpans : Collections.<SourceSpan>emptyList();\n+    }\n+\n+    public void addAllFrom(Iterable<? extends Node> nodes) {\n+        for (Node node : nodes) {\n+            addAll(node.getSourceSpans());\n+        }\n+    }\n+\n+    public void addAll(List<SourceSpan> other) {\n+        if (other.isEmpty()) {\n+            return;\n+        }\n+\n+        if (sourceSpans == null) {\n+            sourceSpans = new ArrayList<>();\n+        }\n+\n+        if (sourceSpans.isEmpty()) {\n+            sourceSpans.addAll(other);\n+        } else {\n+            int lastIndex = sourceSpans.size() - 1;\n+            SourceSpan a = sourceSpans.get(lastIndex);\n+            SourceSpan b = other.get(0);\n+            if (a.getLineIndex() == b.getLineIndex() && a.getColumnIndex() + a.getLength() == b.getColumnIndex()) {\n+                sourceSpans.set(lastIndex, SourceSpan.of(a.getLineIndex(), a.getColumnIndex(), a.getLength() + b.getLength()));\n+                sourceSpans.addAll(other.subList(1, other.size()));\n+            } else {\n+                sourceSpans.addAll(other);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/SourceSpans.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class StrongEmphasis extends Node implements Delimited {\n+\n+    private String delimiter;\n+\n+    public StrongEmphasis() {\n+    }\n+\n+    public StrongEmphasis(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    public void setDelimiter(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    @Override\n+    public String getOpeningDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public String getClosingDelimiter() {\n+        return delimiter;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/StrongEmphasis.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class Text extends Node {\n+\n+    private String literal;\n+\n+    public Text() {\n+    }\n+\n+    public Text(String literal) {\n+        this.literal = literal;\n+    }\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+\n+    @Override\n+    protected String toStringAttributes() {\n+        return \"literal=\" + literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Text.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+public class ThematicBreak extends Block {\n+\n+    private String literal;\n+\n+    @Override\n+    public void accept(Visitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    \/**\n+     * @return the source literal that represents this node, if available\n+     *\/\n+    public String getLiteral() {\n+        return literal;\n+    }\n+\n+    public void setLiteral(String literal) {\n+        this.literal = literal;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/ThematicBreak.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.node;\n+\n+\/**\n+ * Node visitor.\n+ * <p>\n+ * Implementations should subclass {@link AbstractVisitor} instead of implementing this directly.\n+ *\/\n+public interface Visitor {\n+\n+    void visit(BlockQuote blockQuote);\n+\n+    void visit(BulletList bulletList);\n+\n+    void visit(Code code);\n+\n+    void visit(Document document);\n+\n+    void visit(Emphasis emphasis);\n+\n+    void visit(FencedCodeBlock fencedCodeBlock);\n+\n+    void visit(HardLineBreak hardLineBreak);\n+\n+    void visit(Heading heading);\n+\n+    void visit(ThematicBreak thematicBreak);\n+\n+    void visit(HtmlInline htmlInline);\n+\n+    void visit(HtmlBlock htmlBlock);\n+\n+    void visit(Image image);\n+\n+    void visit(IndentedCodeBlock indentedCodeBlock);\n+\n+    void visit(Link link);\n+\n+    void visit(ListItem listItem);\n+\n+    void visit(OrderedList orderedList);\n+\n+    void visit(Paragraph paragraph);\n+\n+    void visit(SoftLineBreak softLineBreak);\n+\n+    void visit(StrongEmphasis strongEmphasis);\n+\n+    void visit(Text text);\n+\n+    void visit(LinkReferenceDefinition linkReferenceDefinition);\n+\n+    void visit(CustomBlock customBlock);\n+\n+    void visit(CustomNode customNode);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/Visitor.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * AST node types (see {@link org.commonmark.node.Node}) and visitors (see {@link org.commonmark.node.AbstractVisitor})\n+ *\/\n+package jdk.internal.org.commonmark.node;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/node\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Root package of commonmark-java\n+ * <ul>\n+ * <li>{@link org.commonmark.parser} for parsing input text to AST nodes<\/li>\n+ * <li>{@link org.commonmark.node} for AST node types and visitors<\/li>\n+ * <li>{@link org.commonmark.renderer.html} for HTML rendering<\/li>\n+ * <li>{@link org.commonmark.renderer.markdown} for Markdown rendering<\/li>\n+ * <\/ul>\n+ *\/\n+package jdk.internal.org.commonmark;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/package-info.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+\/**\n+ * Whether to include {@link org.commonmark.node.SourceSpan} or not while parsing,\n+ * see {@link Parser.Builder#includeSourceSpans(IncludeSourceSpans)}.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public enum IncludeSourceSpans {\n+    \/**\n+     * Do not include source spans.\n+     *\/\n+    NONE,\n+    \/**\n+     * Include source spans on {@link org.commonmark.node.Block} nodes.\n+     *\/\n+    BLOCKS,\n+    \/**\n+     * Include source spans on block nodes and inline nodes.\n+     *\/\n+    BLOCKS_AND_INLINES,\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/IncludeSourceSpans.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+\/**\n+ * Parser for inline content (text, links, emphasized text, etc).\n+ *\/\n+public interface InlineParser {\n+\n+    \/**\n+     * @param lines the source content to parse as inline\n+     * @param node the node to append resulting nodes to (as children)\n+     *\/\n+    void parse(SourceLines lines, Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/InlineParser.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.util.List;\n+\n+\/**\n+ * Context for inline parsing.\n+ *\/\n+public interface InlineParserContext {\n+\n+    \/**\n+     * @return custom delimiter processors that have been configured with {@link Parser.Builder#customDelimiterProcessor(DelimiterProcessor)}\n+     *\/\n+    List<DelimiterProcessor> getCustomDelimiterProcessors();\n+\n+    \/**\n+     * Look up a {@link LinkReferenceDefinition} for a given label.\n+     * <p>\n+     * Note that the label is not normalized yet; implementations are responsible for normalizing before lookup.\n+     *\n+     * @param label the link label to look up\n+     * @return the definition if one exists, {@code null} otherwise\n+     *\/\n+    LinkReferenceDefinition getLinkReferenceDefinition(String label);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/InlineParserContext.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+\/**\n+ * Factory for custom inline parser.\n+ *\/\n+public interface InlineParserFactory {\n+    InlineParser create(InlineParserContext inlineParserContext);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/InlineParserFactory.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.DocumentParser;\n+import jdk.internal.org.commonmark.internal.InlineParserContextImpl;\n+import jdk.internal.org.commonmark.internal.InlineParserImpl;\n+import jdk.internal.org.commonmark.internal.LinkReferenceDefinitions;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.parser.block.BlockParserFactory;\n+import jdk.internal.org.commonmark.parser.delimiter.DelimiterProcessor;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+\n+\/**\n+ * Parses input text to a tree of nodes.\n+ * <p>\n+ * Start with the {@link #builder} method, configure the parser and build it. Example:\n+ * <pre><code>\n+ * Parser parser = Parser.builder().build();\n+ * Node document = parser.parse(\"input text\");\n+ * <\/code><\/pre>\n+ *\/\n+public class Parser {\n+\n+    private final List<BlockParserFactory> blockParserFactories;\n+    private final List<DelimiterProcessor> delimiterProcessors;\n+    private final InlineParserFactory inlineParserFactory;\n+    private final List<PostProcessor> postProcessors;\n+    private final IncludeSourceSpans includeSourceSpans;\n+\n+    private Parser(Builder builder) {\n+        this.blockParserFactories = DocumentParser.calculateBlockParserFactories(builder.blockParserFactories, builder.enabledBlockTypes);\n+        this.inlineParserFactory = builder.getInlineParserFactory();\n+        this.postProcessors = builder.postProcessors;\n+        this.delimiterProcessors = builder.delimiterProcessors;\n+        this.includeSourceSpans = builder.includeSourceSpans;\n+\n+        \/\/ Try to construct an inline parser. Invalid configuration might result in an exception, which we want to\n+        \/\/ detect as soon as possible.\n+        this.inlineParserFactory.create(new InlineParserContextImpl(delimiterProcessors, new LinkReferenceDefinitions()));\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring a {@link Parser}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    \/**\n+     * Parse the specified input text into a tree of nodes.\n+     * <p>\n+     * This method is thread-safe (a new parser state is used for each invocation).\n+     *\n+     * @param input the text to parse - must not be null\n+     * @return the root node\n+     *\/\n+    public Node parse(String input) {\n+        if (input == null) {\n+            throw new NullPointerException(\"input must not be null\");\n+        }\n+        DocumentParser documentParser = createDocumentParser();\n+        Node document = documentParser.parse(input);\n+        return postProcess(document);\n+    }\n+\n+    \/**\n+     * Parse the specified reader into a tree of nodes. The caller is responsible for closing the reader.\n+     * <pre><code>\n+     * Parser parser = Parser.builder().build();\n+     * try (InputStreamReader reader = new InputStreamReader(new FileInputStream(\"file.md\"), StandardCharsets.UTF_8)) {\n+     *     Node document = parser.parseReader(reader);\n+     *     \/\/ ...\n+     * }\n+     * <\/code><\/pre>\n+     * Note that if you have a file with a byte order mark (BOM), you need to skip it before handing the reader to this\n+     * library. There's existing classes that do that, e.g. see {@code BOMInputStream} in Commons IO.\n+     * <p>\n+     * This method is thread-safe (a new parser state is used for each invocation).\n+     *\n+     * @param input the reader to parse - must not be null\n+     * @return the root node\n+     * @throws IOException when reading throws an exception\n+     *\/\n+    public Node parseReader(Reader input) throws IOException {\n+        if (input == null) {\n+            throw new NullPointerException(\"input must not be null\");\n+        }\n+\n+        DocumentParser documentParser = createDocumentParser();\n+        Node document = documentParser.parse(input);\n+        return postProcess(document);\n+    }\n+\n+    private DocumentParser createDocumentParser() {\n+        return new DocumentParser(blockParserFactories, inlineParserFactory, delimiterProcessors, includeSourceSpans);\n+    }\n+\n+    private Node postProcess(Node document) {\n+        for (PostProcessor postProcessor : postProcessors) {\n+            document = postProcessor.process(document);\n+        }\n+        return document;\n+    }\n+\n+    \/**\n+     * Builder for configuring a {@link Parser}.\n+     *\/\n+    public static class Builder {\n+        private final List<BlockParserFactory> blockParserFactories = new ArrayList<>();\n+        private final List<DelimiterProcessor> delimiterProcessors = new ArrayList<>();\n+        private final List<PostProcessor> postProcessors = new ArrayList<>();\n+        private Set<Class<? extends Block>> enabledBlockTypes = DocumentParser.getDefaultBlockParserTypes();\n+        private InlineParserFactory inlineParserFactory;\n+        private IncludeSourceSpans includeSourceSpans = IncludeSourceSpans.NONE;\n+\n+        \/**\n+         * @return the configured {@link Parser}\n+         *\/\n+        public Parser build() {\n+            return new Parser(this);\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this parser\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            if (extensions == null) {\n+                throw new NullPointerException(\"extensions must not be null\");\n+            }\n+            for (Extension extension : extensions) {\n+                if (extension instanceof ParserExtension) {\n+                    ParserExtension parserExtension = (ParserExtension) extension;\n+                    parserExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Describe the list of markdown features the parser will recognize and parse.\n+         * <p>\n+         * By default, CommonMark will recognize and parse the following set of \"block\" elements:\n+         * <ul>\n+         * <li>{@link Heading} ({@code #})\n+         * <li>{@link HtmlBlock} ({@code <html><\/html>})\n+         * <li>{@link ThematicBreak} (Horizontal Rule) ({@code ---})\n+         * <li>{@link FencedCodeBlock} ({@code ```})\n+         * <li>{@link IndentedCodeBlock}\n+         * <li>{@link BlockQuote} ({@code >})\n+         * <li>{@link ListBlock} (Ordered \/ Unordered List) ({@code 1. \/ *})\n+         * <\/ul>\n+         * <p>\n+         * To parse only a subset of the features listed above, pass a list of each feature's associated {@link Block} class.\n+         * <p>\n+         * E.g., to only parse headings and lists:\n+         * <pre>\n+         *     {@code\n+         *     Parser.builder().enabledBlockTypes(new HashSet<>(Arrays.asList(Heading.class, ListBlock.class)));\n+         *     }\n+         * <\/pre>\n+         *\n+         * @param enabledBlockTypes A list of block nodes the parser will parse.\n+         * If this list is empty, the parser will not recognize any CommonMark core features.\n+         * @return {@code this}\n+         *\/\n+        public Builder enabledBlockTypes(Set<Class<? extends Block>> enabledBlockTypes) {\n+            if (enabledBlockTypes == null) {\n+                throw new NullPointerException(\"enabledBlockTypes must not be null\");\n+            }\n+            DocumentParser.checkEnabledBlockTypes(enabledBlockTypes);\n+            this.enabledBlockTypes = enabledBlockTypes;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether to calculate {@link org.commonmark.node.SourceSpan} for {@link Node}.\n+         * <p>\n+         * By default, source spans are disabled.\n+         *\n+         * @param includeSourceSpans which kind of source spans should be included\n+         * @return {@code this}\n+         * @since 0.16.0\n+         *\/\n+        public Builder includeSourceSpans(IncludeSourceSpans includeSourceSpans) {\n+            this.includeSourceSpans = includeSourceSpans;\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a custom block parser factory.\n+         * <p>\n+         * Note that custom factories are applied <em>before<\/em> the built-in factories. This is so that\n+         * extensions can change how some syntax is parsed that would otherwise be handled by built-in factories.\n+         * \"With great power comes great responsibility.\"\n+         *\n+         * @param blockParserFactory a block parser factory implementation\n+         * @return {@code this}\n+         *\/\n+        public Builder customBlockParserFactory(BlockParserFactory blockParserFactory) {\n+            if (blockParserFactory == null) {\n+                throw new NullPointerException(\"blockParserFactory must not be null\");\n+            }\n+            blockParserFactories.add(blockParserFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a custom delimiter processor.\n+         * <p>\n+         * Note that multiple delimiter processors with the same characters can be added, as long as they have a\n+         * different minimum length. In that case, the processor with the shortest matching length is used. Adding more\n+         * than one delimiter processor with the same character and minimum length is invalid.\n+         *\n+         * @param delimiterProcessor a delimiter processor implementation\n+         * @return {@code this}\n+         *\/\n+        public Builder customDelimiterProcessor(DelimiterProcessor delimiterProcessor) {\n+            if (delimiterProcessor == null) {\n+                throw new NullPointerException(\"delimiterProcessor must not be null\");\n+            }\n+            delimiterProcessors.add(delimiterProcessor);\n+            return this;\n+        }\n+\n+        public Builder postProcessor(PostProcessor postProcessor) {\n+            if (postProcessor == null) {\n+                throw new NullPointerException(\"postProcessor must not be null\");\n+            }\n+            postProcessors.add(postProcessor);\n+            return this;\n+        }\n+\n+        \/**\n+         * Overrides the parser used for inline markdown processing.\n+         * <p>\n+         * Provide an implementation of InlineParserFactory which provides a custom inline parser\n+         * to modify how the following are parsed:\n+         * bold (**)\n+         * italic (*)\n+         * strikethrough (~~)\n+         * backtick quote (`)\n+         * link ([title](http:\/\/))\n+         * image (![alt](http:\/\/))\n+         * <p>\n+         * Note that if this method is not called or the inline parser factory is set to null, then the default\n+         * implementation will be used.\n+         *\n+         * @param inlineParserFactory an inline parser factory implementation\n+         * @return {@code this}\n+         *\/\n+        public Builder inlineParserFactory(InlineParserFactory inlineParserFactory) {\n+            this.inlineParserFactory = inlineParserFactory;\n+            return this;\n+        }\n+\n+        private InlineParserFactory getInlineParserFactory() {\n+            if (inlineParserFactory != null) {\n+                return inlineParserFactory;\n+            }\n+            return new InlineParserFactory() {\n+                @Override\n+                public InlineParser create(InlineParserContext inlineParserContext) {\n+                    return new InlineParserImpl(inlineParserContext);\n+                }\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link Parser}.\n+     *\/\n+    public interface ParserExtension extends Extension {\n+        void extend(Builder parserBuilder);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/Parser.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public interface PostProcessor {\n+\n+    \/**\n+     * @param node the node to post-process\n+     * @return the result of post-processing, may be a modified {@code node} argument\n+     *\/\n+    Node process(Node node);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/PostProcessor.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+\n+\/**\n+ * A line or part of a line from the input source.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceLine {\n+\n+    private final CharSequence content;\n+    private final SourceSpan sourceSpan;\n+\n+    public static SourceLine of(CharSequence content, SourceSpan sourceSpan) {\n+        return new SourceLine(content, sourceSpan);\n+    }\n+\n+    private SourceLine(CharSequence content, SourceSpan sourceSpan) {\n+        if (content == null) {\n+            throw new NullPointerException(\"content must not be null\");\n+        }\n+        this.content = content;\n+        this.sourceSpan = sourceSpan;\n+    }\n+\n+    public CharSequence getContent() {\n+        return content;\n+    }\n+\n+    public SourceSpan getSourceSpan() {\n+        return sourceSpan;\n+    }\n+\n+    public SourceLine substring(int beginIndex, int endIndex) {\n+        CharSequence newContent = content.subSequence(beginIndex, endIndex);\n+        SourceSpan newSourceSpan = null;\n+        if (sourceSpan != null) {\n+            int columnIndex = sourceSpan.getColumnIndex() + beginIndex;\n+            int length = endIndex - beginIndex;\n+            if (length != 0) {\n+                newSourceSpan = SourceSpan.of(sourceSpan.getLineIndex(), columnIndex, length);\n+            }\n+        }\n+        return SourceLine.of(newContent, newSourceSpan);\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/SourceLine.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser;\n+\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * A set of lines ({@link SourceLine}) from the input source.\n+ *\n+ * @since 0.16.0\n+ *\/\n+public class SourceLines {\n+\n+    private final List<SourceLine> lines = new ArrayList<>();\n+\n+    public static SourceLines empty() {\n+        return new SourceLines();\n+    }\n+\n+    public static SourceLines of(SourceLine sourceLine) {\n+        SourceLines sourceLines = new SourceLines();\n+        sourceLines.addLine(sourceLine);\n+        return sourceLines;\n+    }\n+\n+    public static SourceLines of(List<SourceLine> sourceLines) {\n+        SourceLines result = new SourceLines();\n+        result.lines.addAll(sourceLines);\n+        return result;\n+    }\n+\n+    public void addLine(SourceLine sourceLine) {\n+        lines.add(sourceLine);\n+    }\n+\n+    public List<SourceLine> getLines() {\n+        return lines;\n+    }\n+\n+    public boolean isEmpty() {\n+        return lines.isEmpty();\n+    }\n+\n+    public String getContent() {\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < lines.size(); i++) {\n+            if (i != 0) {\n+                sb.append('\\n');\n+            }\n+            sb.append(lines.get(i).getContent());\n+        }\n+        return sb.toString();\n+    }\n+\n+    public List<SourceSpan> getSourceSpans() {\n+        List<SourceSpan> sourceSpans = new ArrayList<>();\n+        for (SourceLine line : lines) {\n+            SourceSpan sourceSpan = line.getSourceSpan();\n+            if (sourceSpan != null) {\n+                sourceSpans.add(sourceSpan);\n+            }\n+        }\n+        return sourceSpans;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/SourceLines.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.beta;\n+\n+\/**\n+ * Position within a {@link Scanner}. This is intentionally kept opaque so as not to expose the internal structure of\n+ * the Scanner.\n+ *\/\n+public class Position {\n+\n+    final int lineIndex;\n+    final int index;\n+\n+    Position(int lineIndex, int index) {\n+        this.lineIndex = lineIndex;\n+        this.index = index;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/beta\/Position.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.beta;\n+\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+import jdk.internal.org.commonmark.text.CharMatcher;\n+\n+import java.util.List;\n+\n+public class Scanner {\n+\n+    \/**\n+     * Character representing the end of input source (or outside of the text in case of the \"previous\" methods).\n+     * <p>\n+     * Note that we can use NULL to represent this because CommonMark does not allow those in the input (we replace them\n+     * in the beginning of parsing).\n+     *\/\n+    public static final char END = '\\0';\n+\n+    \/\/ Lines without newlines at the end. The scanner will yield `\\n` between lines because they're significant for\n+    \/\/ parsing and the final output. There is no `\\n` after the last line.\n+    private final List<SourceLine> lines;\n+    \/\/ Which line we're at.\n+    private int lineIndex;\n+    \/\/ The index within the line. If index == length(), we pretend that there's a `\\n` and only advance after we yield\n+    \/\/ that.\n+    private int index;\n+\n+    \/\/ Current line or \"\" if at the end of the lines (using \"\" instead of null saves a null check)\n+    private SourceLine line = SourceLine.of(\"\", null);\n+    private int lineLength = 0;\n+\n+    Scanner(List<SourceLine> lines, int lineIndex, int index) {\n+        this.lines = lines;\n+        this.lineIndex = lineIndex;\n+        this.index = index;\n+        if (!lines.isEmpty()) {\n+            checkPosition(lineIndex, index);\n+            setLine(lines.get(lineIndex));\n+        }\n+    }\n+\n+    public static Scanner of(SourceLines lines) {\n+        return new Scanner(lines.getLines(), 0, 0);\n+    }\n+\n+    public char peek() {\n+        if (index < lineLength) {\n+            return line.getContent().charAt(index);\n+        } else {\n+            if (lineIndex < lines.size() - 1) {\n+                return '\\n';\n+            } else {\n+                \/\/ Don't return newline for end of last line\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public int peekCodePoint() {\n+        if (index < lineLength) {\n+            char c = line.getContent().charAt(index);\n+            if (Character.isHighSurrogate(c) && index + 1 < lineLength) {\n+                char low = line.getContent().charAt(index + 1);\n+                if (Character.isLowSurrogate(low)) {\n+                    return Character.toCodePoint(c, low);\n+                }\n+            }\n+            return c;\n+        } else {\n+            if (lineIndex < lines.size() - 1) {\n+                return '\\n';\n+            } else {\n+                \/\/ Don't return newline for end of last line\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public int peekPreviousCodePoint() {\n+        if (index > 0) {\n+            int prev = index - 1;\n+            char c = line.getContent().charAt(prev);\n+            if (Character.isLowSurrogate(c) && prev > 0) {\n+                char high = line.getContent().charAt(prev - 1);\n+                if (Character.isHighSurrogate(high)) {\n+                    return Character.toCodePoint(high, c);\n+                }\n+            }\n+            return c;\n+        } else {\n+            if (lineIndex > 0) {\n+                return '\\n';\n+            } else {\n+                return END;\n+            }\n+        }\n+    }\n+\n+    public boolean hasNext() {\n+        if (index < lineLength) {\n+            return true;\n+        } else {\n+            \/\/ No newline at end of last line\n+            return lineIndex < lines.size() - 1;\n+        }\n+    }\n+\n+    public void next() {\n+        index++;\n+        if (index > lineLength) {\n+            lineIndex++;\n+            if (lineIndex < lines.size()) {\n+                setLine(lines.get(lineIndex));\n+            } else {\n+                setLine(SourceLine.of(\"\", null));\n+            }\n+            index = 0;\n+        }\n+    }\n+\n+    \/**\n+     * Check if the specified char is next and advance the position.\n+     *\n+     * @param c the char to check (including newline characters)\n+     * @return true if matched and position was advanced, false otherwise\n+     *\/\n+    public boolean next(char c) {\n+        if (peek() == c) {\n+            next();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Check if we have the specified content on the line and advanced the position. Note that if you want to match\n+     * newline characters, use {@link #next(char)}.\n+     *\n+     * @param content the text content to match on a single line (excluding newline characters)\n+     * @return true if matched and position was advanced, false otherwise\n+     *\/\n+    public boolean next(String content) {\n+        if (index < lineLength && index + content.length() <= lineLength) {\n+            \/\/ Can't use startsWith because it's not available on CharSequence\n+            for (int i = 0; i < content.length(); i++) {\n+                if (line.getContent().charAt(index + i) != content.charAt(i)) {\n+                    return false;\n+                }\n+            }\n+            index += content.length();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int matchMultiple(char c) {\n+        int count = 0;\n+        while (peek() == c) {\n+            count++;\n+            next();\n+        }\n+        return count;\n+    }\n+\n+    public int match(CharMatcher matcher) {\n+        int count = 0;\n+        while (matcher.matches(peek())) {\n+            count++;\n+            next();\n+        }\n+        return count;\n+    }\n+\n+    public int whitespace() {\n+        int count = 0;\n+        while (true) {\n+            switch (peek()) {\n+                case ' ':\n+                case '\\t':\n+                case '\\n':\n+                case '\\u000B':\n+                case '\\f':\n+                case '\\r':\n+                    count++;\n+                    next();\n+                    break;\n+                default:\n+                    return count;\n+            }\n+        }\n+    }\n+\n+    public int find(char c) {\n+        int count = 0;\n+        while (true) {\n+            char cur = peek();\n+            if (cur == Scanner.END) {\n+                return -1;\n+            } else if (cur == c) {\n+                return count;\n+            }\n+            count++;\n+            next();\n+        }\n+    }\n+\n+    public int find(CharMatcher matcher) {\n+        int count = 0;\n+        while (true) {\n+            char c = peek();\n+            if (c == END) {\n+                return -1;\n+            } else if (matcher.matches(c)) {\n+                return count;\n+            }\n+            count++;\n+            next();\n+        }\n+    }\n+\n+    \/\/ Don't expose the int index, because it would be good if we could switch input to a List<String> of lines later\n+    \/\/ instead of one contiguous String.\n+    public Position position() {\n+        return new Position(lineIndex, index);\n+    }\n+\n+    public void setPosition(Position position) {\n+        checkPosition(position.lineIndex, position.index);\n+        this.lineIndex = position.lineIndex;\n+        this.index = position.index;\n+        setLine(lines.get(this.lineIndex));\n+    }\n+\n+    \/\/ For cases where the caller appends the result to a StringBuilder, we could offer another method to avoid some\n+    \/\/ unnecessary copying.\n+    public SourceLines getSource(Position begin, Position end) {\n+        if (begin.lineIndex == end.lineIndex) {\n+            \/\/ Shortcut for common case of text from a single line\n+            SourceLine line = lines.get(begin.lineIndex);\n+            CharSequence newContent = line.getContent().subSequence(begin.index, end.index);\n+            SourceSpan newSourceSpan = null;\n+            SourceSpan sourceSpan = line.getSourceSpan();\n+            if (sourceSpan != null) {\n+                newSourceSpan = SourceSpan.of(sourceSpan.getLineIndex(), sourceSpan.getColumnIndex() + begin.index, newContent.length());\n+            }\n+            return SourceLines.of(SourceLine.of(newContent, newSourceSpan));\n+        } else {\n+            SourceLines sourceLines = SourceLines.empty();\n+\n+            SourceLine firstLine = lines.get(begin.lineIndex);\n+            sourceLines.addLine(firstLine.substring(begin.index, firstLine.getContent().length()));\n+\n+            \/\/ Lines between begin and end (we are appending the full line)\n+            for (int line = begin.lineIndex + 1; line < end.lineIndex; line++) {\n+                sourceLines.addLine(lines.get(line));\n+            }\n+\n+            SourceLine lastLine = lines.get(end.lineIndex);\n+            sourceLines.addLine(lastLine.substring(0, end.index));\n+            return sourceLines;\n+        }\n+    }\n+\n+    private void setLine(SourceLine line) {\n+        this.line = line;\n+        this.lineLength = line.getContent().length();\n+    }\n+\n+    private void checkPosition(int lineIndex, int index) {\n+        if (lineIndex < 0 || lineIndex >= lines.size()) {\n+            throw new IllegalArgumentException(\"Line index \" + lineIndex + \" out of range, number of lines: \" + lines.size());\n+        }\n+        SourceLine line = lines.get(lineIndex);\n+        if (index < 0 || index > line.getContent().length()) {\n+            throw new IllegalArgumentException(\"Index \" + index + \" out of range, line length: \" + line.getContent().length());\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/beta\/Scanner.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Experimental APIs to use for extensions. APIs are subject to change if necessary.\n+ *\/\n+package jdk.internal.org.commonmark.parser.beta;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/beta\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+\n+public abstract class AbstractBlockParser implements BlockParser {\n+\n+    @Override\n+    public boolean isContainer() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean canHaveLazyContinuationLines() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean canContain(Block childBlock) {\n+        return false;\n+    }\n+\n+    @Override\n+    public void addLine(SourceLine line) {\n+    }\n+\n+    @Override\n+    public void addSourceSpan(SourceSpan sourceSpan) {\n+        getBlock().addSourceSpan(sourceSpan);\n+    }\n+\n+    @Override\n+    public void closeBlock() {\n+    }\n+\n+    @Override\n+    public void parseInlines(InlineParser inlineParser) {\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/AbstractBlockParser.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+public abstract class AbstractBlockParserFactory implements BlockParserFactory {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/AbstractBlockParserFactory.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.internal.BlockContinueImpl;\n+\n+\/**\n+ * Result object for continuing parsing of a block, see static methods for constructors.\n+ *\/\n+public class BlockContinue {\n+\n+    protected BlockContinue() {\n+    }\n+\n+    public static BlockContinue none() {\n+        return null;\n+    }\n+\n+    public static BlockContinue atIndex(int newIndex) {\n+        return new BlockContinueImpl(newIndex, -1, false);\n+    }\n+\n+    public static BlockContinue atColumn(int newColumn) {\n+        return new BlockContinueImpl(-1, newColumn, false);\n+    }\n+\n+    public static BlockContinue finished() {\n+        return new BlockContinueImpl(-1, -1, true);\n+    }\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockContinue.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.node.Block;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.parser.InlineParser;\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+\n+\/**\n+ * Parser for a specific block node.\n+ * <p>\n+ * Implementations should subclass {@link AbstractBlockParser} instead of implementing this directly.\n+ *\/\n+public interface BlockParser {\n+\n+    \/**\n+     * Return true if the block that is parsed is a container (contains other blocks), or false if it's a leaf.\n+     *\/\n+    boolean isContainer();\n+\n+    \/**\n+     * Return true if the block can have lazy continuation lines.\n+     * <p>\n+     * Lazy continuation lines are lines that were rejected by this {@link #tryContinue(ParserState)} but didn't match\n+     * any other block parsers either.\n+     * <p>\n+     * If true is returned here, those lines will get added via {@link #addLine(SourceLine)}. For false, the block is\n+     * closed instead.\n+     *\/\n+    boolean canHaveLazyContinuationLines();\n+\n+    boolean canContain(Block childBlock);\n+\n+    Block getBlock();\n+\n+    BlockContinue tryContinue(ParserState parserState);\n+\n+    \/**\n+     * Add the part of a line that belongs to this block parser to parse (i.e. without any container block markers).\n+     * Note that the line will only include a {@link SourceLine#getSourceSpan()} if source spans are enabled for inlines.\n+     *\/\n+    void addLine(SourceLine line);\n+\n+    \/**\n+     * Add a source span of the currently parsed block. The default implementation in {@link AbstractBlockParser} adds\n+     * it to the block. Unless you have some complicated parsing where you need to check source positions, you don't\n+     * need to override this.\n+     *\n+     * @since 0.16.0\n+     *\/\n+    void addSourceSpan(SourceSpan sourceSpan);\n+\n+    void closeBlock();\n+\n+    void parseInlines(InlineParser inlineParser);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockParser.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+\/**\n+ * Parser factory for a block node for determining when a block starts.\n+ * <p>\n+ * Implementations should subclass {@link AbstractBlockParserFactory} instead of implementing this directly.\n+ *\/\n+public interface BlockParserFactory {\n+\n+    BlockStart tryStart(ParserState state, MatchedBlockParser matchedBlockParser);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockParserFactory.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.internal.BlockStartImpl;\n+\n+\/**\n+ * Result object for starting parsing of a block, see static methods for constructors.\n+ *\/\n+public abstract class BlockStart {\n+\n+    protected BlockStart() {\n+    }\n+\n+    public static BlockStart none() {\n+        return null;\n+    }\n+\n+    public static BlockStart of(BlockParser... blockParsers) {\n+        return new BlockStartImpl(blockParsers);\n+    }\n+\n+    public abstract BlockStart atIndex(int newIndex);\n+\n+    public abstract BlockStart atColumn(int newColumn);\n+\n+    public abstract BlockStart replaceActiveBlockParser();\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/BlockStart.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.parser.SourceLines;\n+\n+\/**\n+ * Open block parser that was last matched during the continue phase. This is different from the currently active\n+ * block parser, as an unmatched block is only closed when a new block is started.\n+ * <p><em>This interface is not intended to be implemented by clients.<\/em><\/p>\n+ *\/\n+public interface MatchedBlockParser {\n+\n+    BlockParser getMatchedBlockParser();\n+\n+    \/**\n+     * Returns the current paragraph lines if the matched block is a paragraph.\n+     *\n+     * @return paragraph content or an empty list\n+     *\/\n+    SourceLines getParagraphLines();\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/MatchedBlockParser.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.block;\n+\n+import jdk.internal.org.commonmark.parser.SourceLine;\n+\n+\/**\n+ * State of the parser that is used in block parsers.\n+ * <p><em>This interface is not intended to be implemented by clients.<\/em><\/p>\n+ *\/\n+public interface ParserState {\n+\n+    \/**\n+     * @return the current source line being parsed (full line)\n+     *\/\n+    SourceLine getLine();\n+\n+    \/**\n+     * @return the current index within the line (0-based)\n+     *\/\n+    int getIndex();\n+\n+    \/**\n+     * @return the index of the next non-space character starting from {@link #getIndex()} (may be the same) (0-based)\n+     *\/\n+    int getNextNonSpaceIndex();\n+\n+    \/**\n+     * The column is the position within the line after tab characters have been processed as 4-space tab stops.\n+     * If the line doesn't contain any tabs, it's the same as the {@link #getIndex()}. If the line starts with a tab,\n+     * followed by text, then the column for the first character of the text is 4 (the index is 1).\n+     *\n+     * @return the current column within the line (0-based)\n+     *\/\n+    int getColumn();\n+\n+    \/**\n+     * @return the indentation in columns (either by spaces or tab stop of 4), starting from {@link #getColumn()}\n+     *\/\n+    int getIndent();\n+\n+    \/**\n+     * @return true if the current line is blank starting from the index\n+     *\/\n+    boolean isBlank();\n+\n+    \/**\n+     * @return the deepest open block parser\n+     *\/\n+    BlockParser getActiveBlockParser();\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/ParserState.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Types for extending block parsing\n+ *\/\n+package jdk.internal.org.commonmark.parser.block;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/block\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.delimiter;\n+\n+import jdk.internal.org.commonmark.node.Text;\n+\n+\/**\n+ * Custom delimiter processor for additional delimiters besides {@code _} and {@code *}.\n+ * <p>\n+ * Note that implementations of this need to be thread-safe, the same instance may be used by multiple parsers.\n+ *\/\n+public interface DelimiterProcessor {\n+\n+    \/**\n+     * @return the character that marks the beginning of a delimited node, must not clash with any built-in special\n+     * characters\n+     *\/\n+    char getOpeningCharacter();\n+\n+    \/**\n+     * @return the character that marks the the ending of a delimited node, must not clash with any built-in special\n+     * characters. Note that for a symmetric delimiter such as \"*\", this is the same as the opening.\n+     *\/\n+    char getClosingCharacter();\n+\n+    \/**\n+     * Minimum number of delimiter characters that are needed to activate this. Must be at least 1.\n+     *\/\n+    int getMinLength();\n+\n+    \/**\n+     * Process the delimiter runs.\n+     * <p>\n+     * The processor can examine the runs and the nodes and decide if it wants to process or not. If not, it should not\n+     * change any nodes and return 0. If yes, it should do the processing (wrapping nodes, etc) and then return how many\n+     * delimiters were used.\n+     * <p>\n+     * Note that removal (unlinking) of the used delimiter {@link Text} nodes is done by the caller.\n+     *\n+     * @param openingRun the opening delimiter run\n+     * @param closingRun the closing delimiter run\n+     * @return how many delimiters were used; must not be greater than length of either opener or closer\n+     *\/\n+    int process(DelimiterRun openingRun, DelimiterRun closingRun);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/delimiter\/DelimiterProcessor.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.parser.delimiter;\n+\n+import jdk.internal.org.commonmark.node.Text;\n+\n+\/**\n+ * A delimiter run is one or more of the same delimiter character, e.g. {@code ***}.\n+ *\/\n+public interface DelimiterRun {\n+\n+    \/**\n+     * @return whether this can open a delimiter\n+     *\/\n+    boolean canOpen();\n+\n+    \/**\n+     * @return whether this can close a delimiter\n+     *\/\n+    boolean canClose();\n+\n+    \/**\n+     * @return the number of characters in this delimiter run (that are left for processing)\n+     *\/\n+    int length();\n+\n+    \/**\n+     * @return the number of characters originally in this delimiter run; at the start of processing, this is the same\n+     * as {{@link #length()}}\n+     *\/\n+    int originalLength();\n+\n+    \/**\n+     * @return the innermost opening delimiter, e.g. for {@code ***} this is the last {@code *}\n+     *\/\n+    Text getOpener();\n+\n+    \/**\n+     * @return the innermost closing delimiter, e.g. for {@code ***} this is the first {@code *}\n+     *\/\n+    Text getCloser();\n+\n+    \/**\n+     * Get the opening delimiter nodes for the specified length of delimiters. Length must be between 1 and\n+     * {@link #length()}.\n+     * <p>\n+     * For example, for a delimiter run {@code ***}, calling this with 1 would return the last {@code *}.\n+     * Calling it with 2 would return the second last {@code *} and the last {@code *}.\n+     *\/\n+    Iterable<Text> getOpeners(int length);\n+\n+    \/**\n+     * Get the closing delimiter nodes for the specified length of delimiters. Length must be between 1 and\n+     * {@link #length()}.\n+     * <p>\n+     * For example, for a delimiter run {@code ***}, calling this with 1 would return the first {@code *}.\n+     * Calling it with 2 would return the first {@code *} and the second {@code *}.\n+     *\/\n+    Iterable<Text> getClosers(int length);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/delimiter\/DelimiterRun.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Parsing input text to AST nodes (see {@link org.commonmark.parser.Parser})\n+ *\/\n+package jdk.internal.org.commonmark.parser;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/parser\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Set;\n+\n+\/**\n+ * A renderer for a set of node types.\n+ *\/\n+public interface NodeRenderer {\n+\n+    \/**\n+     * @return the types of nodes that this renderer handles\n+     *\/\n+    Set<Class<? extends Node>> getNodeTypes();\n+\n+    \/**\n+     * Render the specified node.\n+     *\n+     * @param node the node to render, will be an instance of one of {@link #getNodeTypes()}\n+     *\/\n+    void render(Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/NodeRenderer.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public interface Renderer {\n+\n+    \/**\n+     * Render the tree of nodes to output.\n+     *\n+     * @param node the root node\n+     * @param output output for rendering\n+     *\/\n+    void render(Node node, Appendable output);\n+\n+    \/**\n+     * Render the tree of nodes to string.\n+     *\n+     * @param node the root node\n+     * @return the rendered string\n+     *\/\n+    String render(Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/Renderer.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Map;\n+\n+\/**\n+ * Extension point for adding\/changing attributes on HTML tags for a node.\n+ *\/\n+public interface AttributeProvider {\n+\n+    \/**\n+     * Set the attributes for a HTML tag of the specified node by modifying the provided map.\n+     * <p>\n+     * This allows to change or even remove default attributes. With great power comes great responsibility.\n+     * <p>\n+     * The attribute key and values will be escaped (preserving character entities), so don't escape them here,\n+     * otherwise they will be double-escaped.\n+     * <p>\n+     * This method may be called multiple times for the same node, if the node is rendered using multiple nested\n+     * tags (e.g. code blocks).\n+     *\n+     * @param node the node to set attributes for\n+     * @param tagName the HTML tag name that these attributes are for (e.g. {@code h1}, {@code pre}, {@code code}).\n+     * @param attributes the attributes, with any default attributes already set in the map\n+     *\/\n+    void setAttributes(Node node, String tagName, Map<String, String> attributes);\n+\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/AttributeProvider.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+\/**\n+ * The context for attribute providers.\n+ * <p>Note: There are currently no methods here, this is for future extensibility.<\/p>\n+ * <p><em>This interface is not intended to be implemented by clients.<\/em><\/p>\n+ *\/\n+public interface AttributeProviderContext {\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/AttributeProviderContext.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+\/**\n+ * Factory for instantiating new attribute providers when rendering is done.\n+ *\/\n+public interface AttributeProviderFactory {\n+\n+    \/**\n+     * Create a new attribute provider.\n+     *\n+     * @param context for this attribute provider\n+     * @return an AttributeProvider\n+     *\/\n+    AttributeProvider create(AttributeProviderContext context);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/AttributeProviderFactory.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+import java.util.*;\n+\n+\/**\n+ * The node renderer that renders all the core nodes (comes last in the order of node renderers).\n+ *\/\n+public class CoreHtmlNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+\n+    protected final HtmlNodeRendererContext context;\n+    private final HtmlWriter html;\n+\n+    public CoreHtmlNodeRenderer(HtmlNodeRendererContext context) {\n+        this.context = context;\n+        this.html = context.getWriter();\n+    }\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                Document.class,\n+                Heading.class,\n+                Paragraph.class,\n+                BlockQuote.class,\n+                BulletList.class,\n+                FencedCodeBlock.class,\n+                HtmlBlock.class,\n+                ThematicBreak.class,\n+                IndentedCodeBlock.class,\n+                Link.class,\n+                ListItem.class,\n+                OrderedList.class,\n+                Image.class,\n+                Emphasis.class,\n+                StrongEmphasis.class,\n+                Text.class,\n+                Code.class,\n+                HtmlInline.class,\n+                SoftLineBreak.class,\n+                HardLineBreak.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        \/\/ No rendering itself\n+        visitChildren(document);\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        String htag = \"h\" + heading.getLevel();\n+        html.line();\n+        html.tag(htag, getAttrs(heading, htag));\n+        visitChildren(heading);\n+        html.tag('\/' + htag);\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        boolean inTightList = isInTightList(paragraph);\n+        if (!inTightList) {\n+            html.line();\n+            html.tag(\"p\", getAttrs(paragraph, \"p\"));\n+        }\n+        visitChildren(paragraph);\n+        if (!inTightList) {\n+            html.tag(\"\/p\");\n+            html.line();\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        html.line();\n+        html.tag(\"blockquote\", getAttrs(blockQuote, \"blockquote\"));\n+        html.line();\n+        visitChildren(blockQuote);\n+        html.line();\n+        html.tag(\"\/blockquote\");\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        renderListBlock(bulletList, \"ul\", getAttrs(bulletList, \"ul\"));\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock fencedCodeBlock) {\n+        String literal = fencedCodeBlock.getLiteral();\n+        Map<String, String> attributes = new LinkedHashMap<>();\n+        String info = fencedCodeBlock.getInfo();\n+        if (info != null && !info.isEmpty()) {\n+            int space = info.indexOf(\" \");\n+            String language;\n+            if (space == -1) {\n+                language = info;\n+            } else {\n+                language = info.substring(0, space);\n+            }\n+            attributes.put(\"class\", \"language-\" + language);\n+        }\n+        renderCodeBlock(literal, fencedCodeBlock, attributes);\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        html.line();\n+        if (context.shouldEscapeHtml()) {\n+            html.tag(\"p\", getAttrs(htmlBlock, \"p\"));\n+            html.text(htmlBlock.getLiteral());\n+            html.tag(\"\/p\");\n+        } else {\n+            html.raw(htmlBlock.getLiteral());\n+        }\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        html.line();\n+        html.tag(\"hr\", getAttrs(thematicBreak, \"hr\"), true);\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        renderCodeBlock(indentedCodeBlock.getLiteral(), indentedCodeBlock, Collections.<String, String>emptyMap());\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        Map<String, String> attrs = new LinkedHashMap<>();\n+        String url = link.getDestination();\n+\n+        if (context.shouldSanitizeUrls()) {\n+            url = context.urlSanitizer().sanitizeLinkUrl(url);\n+            attrs.put(\"rel\", \"nofollow\");\n+        }\n+\n+        url = context.encodeUrl(url);\n+        attrs.put(\"href\", url);\n+        if (link.getTitle() != null) {\n+            attrs.put(\"title\", link.getTitle());\n+        }\n+        html.tag(\"a\", getAttrs(link, \"a\", attrs));\n+        visitChildren(link);\n+        html.tag(\"\/a\");\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        html.tag(\"li\", getAttrs(listItem, \"li\"));\n+        visitChildren(listItem);\n+        html.tag(\"\/li\");\n+        html.line();\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        int start = orderedList.getMarkerStartNumber() != null ? orderedList.getMarkerStartNumber() : 1;\n+        Map<String, String> attrs = new LinkedHashMap<>();\n+        if (start != 1) {\n+            attrs.put(\"start\", String.valueOf(start));\n+        }\n+        renderListBlock(orderedList, \"ol\", getAttrs(orderedList, \"ol\", attrs));\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        String url = image.getDestination();\n+\n+        AltTextVisitor altTextVisitor = new AltTextVisitor();\n+        image.accept(altTextVisitor);\n+        String altText = altTextVisitor.getAltText();\n+\n+        Map<String, String> attrs = new LinkedHashMap<>();\n+        if (context.shouldSanitizeUrls()) {\n+            url = context.urlSanitizer().sanitizeImageUrl(url);\n+        }\n+\n+        attrs.put(\"src\", context.encodeUrl(url));\n+        attrs.put(\"alt\", altText);\n+        if (image.getTitle() != null) {\n+            attrs.put(\"title\", image.getTitle());\n+        }\n+\n+        html.tag(\"img\", getAttrs(image, \"img\", attrs), true);\n+    }\n+\n+    @Override\n+    public void visit(Emphasis emphasis) {\n+        html.tag(\"em\", getAttrs(emphasis, \"em\"));\n+        visitChildren(emphasis);\n+        html.tag(\"\/em\");\n+    }\n+\n+    @Override\n+    public void visit(StrongEmphasis strongEmphasis) {\n+        html.tag(\"strong\", getAttrs(strongEmphasis, \"strong\"));\n+        visitChildren(strongEmphasis);\n+        html.tag(\"\/strong\");\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        html.text(text.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        html.tag(\"code\", getAttrs(code, \"code\"));\n+        html.text(code.getLiteral());\n+        html.tag(\"\/code\");\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        if (context.shouldEscapeHtml()) {\n+            html.text(htmlInline.getLiteral());\n+        } else {\n+            html.raw(htmlInline.getLiteral());\n+        }\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        html.raw(context.getSoftbreak());\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        html.tag(\"br\", getAttrs(hardLineBreak, \"br\"), true);\n+        html.line();\n+    }\n+\n+    @Override\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+\n+    private void renderCodeBlock(String literal, Node node, Map<String, String> attributes) {\n+        html.line();\n+        html.tag(\"pre\", getAttrs(node, \"pre\"));\n+        html.tag(\"code\", getAttrs(node, \"code\", attributes));\n+        html.text(literal);\n+        html.tag(\"\/code\");\n+        html.tag(\"\/pre\");\n+        html.line();\n+    }\n+\n+    private void renderListBlock(ListBlock listBlock, String tagName, Map<String, String> attributes) {\n+        html.line();\n+        html.tag(tagName, attributes);\n+        html.line();\n+        visitChildren(listBlock);\n+        html.line();\n+        html.tag('\/' + tagName);\n+        html.line();\n+    }\n+\n+    private boolean isInTightList(Paragraph paragraph) {\n+        Node parent = paragraph.getParent();\n+        if (parent != null) {\n+            Node gramps = parent.getParent();\n+            if (gramps instanceof ListBlock) {\n+                ListBlock list = (ListBlock) gramps;\n+                return list.isTight();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private Map<String, String> getAttrs(Node node, String tagName) {\n+        return getAttrs(node, tagName, Collections.<String, String>emptyMap());\n+    }\n+\n+    private Map<String, String> getAttrs(Node node, String tagName, Map<String, String> defaultAttributes) {\n+        return context.extendAttributes(node, tagName, defaultAttributes);\n+    }\n+\n+    private static class AltTextVisitor extends AbstractVisitor {\n+\n+        private final StringBuilder sb = new StringBuilder();\n+\n+        String getAltText() {\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public void visit(Text text) {\n+            sb.append(text.getLiteral());\n+        }\n+\n+        @Override\n+        public void visit(SoftLineBreak softLineBreak) {\n+            sb.append('\\n');\n+        }\n+\n+        @Override\n+        public void visit(HardLineBreak hardLineBreak) {\n+            sb.append('\\n');\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/CoreHtmlNodeRenderer.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/**\n+ *\n+ * Allows http, https and mailto protocols for url.\n+ * Also allows protocol relative urls, and relative urls.\n+ * Implementation based on https:\/\/github.com\/OWASP\/java-html-sanitizer\/blob\/f07e44b034a45d94d6fd010279073c38b6933072\/src\/main\/java\/org\/owasp\/html\/FilterUrlByProtocolAttributePolicy.java\n+ *\/\n+public class DefaultUrlSanitizer implements UrlSanitizer {\n+    private Set<String> protocols;\n+\n+    public DefaultUrlSanitizer() {\n+        this(Arrays.asList(\"http\", \"https\", \"mailto\"));\n+    }\n+\n+    public DefaultUrlSanitizer(Collection<String> protocols) {\n+        this.protocols = new HashSet<>(protocols);\n+    }\n+\n+    @Override\n+    public String sanitizeLinkUrl(String url) {\n+        url = stripHtmlSpaces(url);\n+        protocol_loop:\n+        for (int i = 0, n = url.length(); i < n; ++i) {\n+            switch (url.charAt(i)) {\n+                case '\/':\n+                case '#':\n+                case '?':  \/\/ No protocol.\n+                    break protocol_loop;\n+                case ':':\n+                    String protocol = url.substring(0, i).toLowerCase();\n+                    if (!protocols.contains(protocol)) {\n+                        return \"\";\n+                    }\n+                    break protocol_loop;\n+            }\n+        }\n+        return url;\n+    }\n+\n+\n+    @Override\n+    public String sanitizeImageUrl(String url) {\n+        return sanitizeLinkUrl(url);\n+    }\n+\n+    private String stripHtmlSpaces(String s) {\n+        int i = 0, n = s.length();\n+        for (; n > i; --n) {\n+            if (!isHtmlSpace(s.charAt(n - 1))) {\n+                break;\n+            }\n+        }\n+        for (; i < n; ++i) {\n+            if (!isHtmlSpace(s.charAt(i))) {\n+                break;\n+            }\n+        }\n+        if (i == 0 && n == s.length()) {\n+            return s;\n+        }\n+        return s.substring(i, n);\n+    }\n+\n+    private boolean isHtmlSpace(int ch) {\n+        switch (ch) {\n+            case ' ':\n+            case '\\t':\n+            case '\\n':\n+            case '\\u000c':\n+            case '\\r':\n+                return true;\n+            default:\n+                return false;\n+\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/DefaultUrlSanitizer.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.Image;\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Map;\n+\n+public interface HtmlNodeRendererContext {\n+\n+    \/**\n+     * @param url to be encoded\n+     * @return an encoded URL (depending on the configuration)\n+     *\/\n+    String encodeUrl(String url);\n+\n+    \/**\n+     * Let extensions modify the HTML tag attributes.\n+     *\n+     * @param node the node for which the attributes are applied\n+     * @param tagName the HTML tag name that these attributes are for (e.g. {@code h1}, {@code pre}, {@code code}).\n+     * @param attributes the attributes that were calculated by the renderer\n+     * @return the extended attributes with added\/updated\/removed entries\n+     *\/\n+    Map<String, String> extendAttributes(Node node, String tagName, Map<String, String> attributes);\n+\n+    \/**\n+     * @return the HTML writer to use\n+     *\/\n+    HtmlWriter getWriter();\n+\n+    \/**\n+     * @return HTML that should be rendered for a soft line break\n+     *\/\n+    String getSoftbreak();\n+\n+    \/**\n+     * Render the specified node and its children using the configured renderers. This should be used to render child\n+     * nodes; be careful not to pass the node that is being rendered, that would result in an endless loop.\n+     *\n+     * @param node the node to render\n+     *\/\n+    void render(Node node);\n+\n+    \/**\n+     * @return whether HTML blocks and tags should be escaped or not\n+     *\/\n+    boolean shouldEscapeHtml();\n+\n+    \/**\n+     * @return true if the {@link UrlSanitizer} should be used.\n+     * @since 0.14.0\n+     *\/\n+    boolean shouldSanitizeUrls();\n+\n+    \/**\n+     * @return Sanitizer to use for securing {@link Link} href and {@link Image} src if {@link #shouldSanitizeUrls()} is true.\n+     * @since 0.14.0\n+     *\/\n+    UrlSanitizer urlSanitizer();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlNodeRendererContext.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+\/**\n+ * Factory for instantiating new node renderers when rendering is done.\n+ *\/\n+public interface HtmlNodeRendererFactory {\n+\n+    \/**\n+     * Create a new node renderer for the specified rendering context.\n+     *\n+     * @param context the context for rendering (normally passed on to the node renderer)\n+     * @return a node renderer\n+     *\/\n+    NodeRenderer create(HtmlNodeRendererContext context);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlNodeRendererFactory.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.renderer.NodeRendererMap;\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.Renderer;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * Renders a tree of nodes to HTML.\n+ * <p>\n+ * Start with the {@link #builder} method to configure the renderer. Example:\n+ * <pre><code>\n+ * HtmlRenderer renderer = HtmlRenderer.builder().escapeHtml(true).build();\n+ * renderer.render(node);\n+ * <\/code><\/pre>\n+ *\/\n+public class HtmlRenderer implements Renderer {\n+\n+    private final String softbreak;\n+    private final boolean escapeHtml;\n+    private final boolean sanitizeUrls;\n+    private final UrlSanitizer urlSanitizer;\n+    private final boolean percentEncodeUrls;\n+    private final List<AttributeProviderFactory> attributeProviderFactories;\n+    private final List<HtmlNodeRendererFactory> nodeRendererFactories;\n+\n+    private HtmlRenderer(Builder builder) {\n+        this.softbreak = builder.softbreak;\n+        this.escapeHtml = builder.escapeHtml;\n+        this.sanitizeUrls = builder.sanitizeUrls;\n+        this.percentEncodeUrls = builder.percentEncodeUrls;\n+        this.urlSanitizer = builder.urlSanitizer;\n+        this.attributeProviderFactories = new ArrayList<>(builder.attributeProviderFactories);\n+\n+        this.nodeRendererFactories = new ArrayList<>(builder.nodeRendererFactories.size() + 1);\n+        this.nodeRendererFactories.addAll(builder.nodeRendererFactories);\n+        \/\/ Add as last. This means clients can override the rendering of core nodes if they want.\n+        this.nodeRendererFactories.add(new HtmlNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(HtmlNodeRendererContext context) {\n+                return new CoreHtmlNodeRenderer(context);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring an {@link HtmlRenderer}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public void render(Node node, Appendable output) {\n+        if (node == null) {\n+            throw new NullPointerException(\"node must not be null\");\n+        }\n+        RendererContext context = new RendererContext(new HtmlWriter(output));\n+        context.render(node);\n+    }\n+\n+    @Override\n+    public String render(Node node) {\n+        if (node == null) {\n+            throw new NullPointerException(\"node must not be null\");\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        render(node, sb);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Builder for configuring an {@link HtmlRenderer}. See methods for default configuration.\n+     *\/\n+    public static class Builder {\n+\n+        private String softbreak = \"\\n\";\n+        private boolean escapeHtml = false;\n+        private boolean sanitizeUrls = false;\n+        private UrlSanitizer urlSanitizer = new DefaultUrlSanitizer();\n+        private boolean percentEncodeUrls = false;\n+        private List<AttributeProviderFactory> attributeProviderFactories = new ArrayList<>();\n+        private List<HtmlNodeRendererFactory> nodeRendererFactories = new ArrayList<>();\n+\n+        \/**\n+         * @return the configured {@link HtmlRenderer}\n+         *\/\n+        public HtmlRenderer build() {\n+            return new HtmlRenderer(this);\n+        }\n+\n+        \/**\n+         * The HTML to use for rendering a softbreak, defaults to {@code \"\\n\"} (meaning the rendered result doesn't have\n+         * a line break).\n+         * <p>\n+         * Set it to {@code \"<br>\"} (or {@code \"<br \/>\"} to make them hard breaks.\n+         * <p>\n+         * Set it to {@code \" \"} to ignore line wrapping in the source.\n+         *\n+         * @param softbreak HTML for softbreak\n+         * @return {@code this}\n+         *\/\n+        public Builder softbreak(String softbreak) {\n+            this.softbreak = softbreak;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether {@link HtmlInline} and {@link HtmlBlock} should be escaped, defaults to {@code false}.\n+         * <p>\n+         * Note that {@link HtmlInline} is only a tag itself, not the text between an opening tag and a closing tag. So\n+         * markup in the text will be parsed as normal and is not affected by this option.\n+         *\n+         * @param escapeHtml true for escaping, false for preserving raw HTML\n+         * @return {@code this}\n+         *\/\n+        public Builder escapeHtml(boolean escapeHtml) {\n+            this.escapeHtml = escapeHtml;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether {@link Image} src and {@link Link} href should be sanitized, defaults to {@code false}.\n+         *\n+         * @param sanitizeUrls true for sanitization, false for preserving raw attribute\n+         * @return {@code this}\n+         * @since 0.14.0\n+         *\/\n+        public Builder sanitizeUrls(boolean sanitizeUrls) {\n+            this.sanitizeUrls = sanitizeUrls;\n+            return this;\n+        }\n+\n+        \/**\n+         * {@link UrlSanitizer} used to filter URL's if {@link #sanitizeUrls} is true.\n+         *\n+         * @param urlSanitizer Filterer used to filter {@link Image} src and {@link Link}.\n+         * @return {@code this}\n+         * @since 0.14.0\n+         *\/\n+        public Builder urlSanitizer(UrlSanitizer urlSanitizer) {\n+            this.urlSanitizer = urlSanitizer;\n+            return this;\n+        }\n+\n+        \/**\n+         * Whether URLs of link or images should be percent-encoded, defaults to {@code false}.\n+         * <p>\n+         * If enabled, the following is done:\n+         * <ul>\n+         * <li>Existing percent-encoded parts are preserved (e.g. \"%20\" is kept as \"%20\")<\/li>\n+         * <li>Reserved characters such as \"\/\" are preserved, except for \"[\" and \"]\" (see encodeURI in JS)<\/li>\n+         * <li>Unreserved characters such as \"a\" are preserved<\/li>\n+         * <li>Other characters such umlauts are percent-encoded<\/li>\n+         * <\/ul>\n+         *\n+         * @param percentEncodeUrls true to percent-encode, false for leaving as-is\n+         * @return {@code this}\n+         *\/\n+        public Builder percentEncodeUrls(boolean percentEncodeUrls) {\n+            this.percentEncodeUrls = percentEncodeUrls;\n+            return this;\n+        }\n+\n+        \/**\n+         * Add a factory for an attribute provider for adding\/changing HTML attributes to the rendered tags.\n+         *\n+         * @param attributeProviderFactory the attribute provider factory to add\n+         * @return {@code this}\n+         *\/\n+        public Builder attributeProviderFactory(AttributeProviderFactory attributeProviderFactory) {\n+            if (attributeProviderFactory == null) {\n+                throw new NullPointerException(\"attributeProviderFactory must not be null\");\n+            }\n+            this.attributeProviderFactories.add(attributeProviderFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * Add a factory for instantiating a node renderer (done when rendering). This allows to override the rendering\n+         * of node types or define rendering for custom node types.\n+         * <p>\n+         * If multiple node renderers for the same node type are created, the one from the factory that was added first\n+         * \"wins\". (This is how the rendering for core node types can be overridden; the default rendering comes last.)\n+         *\n+         * @param nodeRendererFactory the factory for creating a node renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder nodeRendererFactory(HtmlNodeRendererFactory nodeRendererFactory) {\n+            if (nodeRendererFactory == null) {\n+                throw new NullPointerException(\"nodeRendererFactory must not be null\");\n+            }\n+            this.nodeRendererFactories.add(nodeRendererFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this HTML renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            if (extensions == null) {\n+                throw new NullPointerException(\"extensions must not be null\");\n+            }\n+            for (Extension extension : extensions) {\n+                if (extension instanceof HtmlRendererExtension) {\n+                    HtmlRendererExtension htmlRendererExtension = (HtmlRendererExtension) extension;\n+                    htmlRendererExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link HtmlRenderer}.\n+     *\/\n+    public interface HtmlRendererExtension extends Extension {\n+        void extend(Builder rendererBuilder);\n+    }\n+\n+    private class RendererContext implements HtmlNodeRendererContext, AttributeProviderContext {\n+\n+        private final HtmlWriter htmlWriter;\n+        private final List<AttributeProvider> attributeProviders;\n+        private final NodeRendererMap nodeRendererMap = new NodeRendererMap();\n+\n+        private RendererContext(HtmlWriter htmlWriter) {\n+            this.htmlWriter = htmlWriter;\n+\n+            attributeProviders = new ArrayList<>(attributeProviderFactories.size());\n+            for (AttributeProviderFactory attributeProviderFactory : attributeProviderFactories) {\n+                attributeProviders.add(attributeProviderFactory.create(this));\n+            }\n+\n+            \/\/ The first node renderer for a node type \"wins\".\n+            for (int i = nodeRendererFactories.size() - 1; i >= 0; i--) {\n+                HtmlNodeRendererFactory nodeRendererFactory = nodeRendererFactories.get(i);\n+                NodeRenderer nodeRenderer = nodeRendererFactory.create(this);\n+                nodeRendererMap.add(nodeRenderer);\n+            }\n+        }\n+\n+        @Override\n+        public boolean shouldEscapeHtml() {\n+            return escapeHtml;\n+        }\n+\n+        @Override\n+        public boolean shouldSanitizeUrls() {\n+            return sanitizeUrls;\n+        }\n+\n+        @Override\n+        public UrlSanitizer urlSanitizer() {\n+            return urlSanitizer;\n+        }\n+\n+        @Override\n+        public String encodeUrl(String url) {\n+            if (percentEncodeUrls) {\n+                return Escaping.percentEncodeUrl(url);\n+            } else {\n+                return url;\n+            }\n+        }\n+\n+        @Override\n+        public Map<String, String> extendAttributes(Node node, String tagName, Map<String, String> attributes) {\n+            Map<String, String> attrs = new LinkedHashMap<>(attributes);\n+            setCustomAttributes(node, tagName, attrs);\n+            return attrs;\n+        }\n+\n+        @Override\n+        public HtmlWriter getWriter() {\n+            return htmlWriter;\n+        }\n+\n+        @Override\n+        public String getSoftbreak() {\n+            return softbreak;\n+        }\n+\n+        @Override\n+        public void render(Node node) {\n+            nodeRendererMap.render(node);\n+        }\n+\n+        private void setCustomAttributes(Node node, String tagName, Map<String, String> attrs) {\n+            for (AttributeProvider attributeProvider : attributeProviders) {\n+                attributeProvider.setAttributes(node, tagName, attrs);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlRenderer.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.internal.util.Escaping;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public class HtmlWriter {\n+\n+    private static final Map<String, String> NO_ATTRIBUTES = Collections.emptyMap();\n+\n+    private final Appendable buffer;\n+    private char lastChar = 0;\n+\n+    public HtmlWriter(Appendable out) {\n+        if (out == null) {\n+            throw new NullPointerException(\"out must not be null\");\n+        }\n+        this.buffer = out;\n+    }\n+\n+    public void raw(String s) {\n+        append(s);\n+    }\n+\n+    public void text(String text) {\n+        append(Escaping.escapeHtml(text));\n+    }\n+\n+    public void tag(String name) {\n+        tag(name, NO_ATTRIBUTES);\n+    }\n+\n+    public void tag(String name, Map<String, String> attrs) {\n+        tag(name, attrs, false);\n+    }\n+\n+    public void tag(String name, Map<String, String> attrs, boolean voidElement) {\n+        append(\"<\");\n+        append(name);\n+        if (attrs != null && !attrs.isEmpty()) {\n+            for (Map.Entry<String, String> attrib : attrs.entrySet()) {\n+                append(\" \");\n+                append(Escaping.escapeHtml(attrib.getKey()));\n+                append(\"=\\\"\");\n+                append(Escaping.escapeHtml(attrib.getValue()));\n+                append(\"\\\"\");\n+            }\n+        }\n+        if (voidElement) {\n+            append(\" \/\");\n+        }\n+\n+        append(\">\");\n+    }\n+\n+    public void line() {\n+        if (lastChar != 0 && lastChar != '\\n') {\n+            append(\"\\n\");\n+        }\n+    }\n+\n+    protected void append(String s) {\n+        try {\n+            buffer.append(s);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        int length = s.length();\n+        if (length != 0) {\n+            lastChar = s.charAt(length - 1);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/HtmlWriter.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.html;\n+\n+import jdk.internal.org.commonmark.node.Image;\n+import jdk.internal.org.commonmark.node.Link;\n+\n+\/**\n+ * Sanitizes urls for img and a elements by whitelisting protocols.\n+ * This is intended to prevent XSS payloads like [Click this totally safe url](javascript:document.xss=true;)\n+ * <p>\n+ * Implementation based on https:\/\/github.com\/OWASP\/java-html-sanitizer\/blob\/f07e44b034a45d94d6fd010279073c38b6933072\/src\/main\/java\/org\/owasp\/html\/FilterUrlByProtocolAttributePolicy.java\n+ *\n+ * @since 0.14.0\n+ *\/\n+public interface UrlSanitizer {\n+    \/**\n+     * Sanitize a url for use in the href attribute of a {@link Link}.\n+     *\n+     * @param url Link to sanitize\n+     * @return Sanitized link\n+     *\/\n+    String sanitizeLinkUrl(String url);\n+\n+    \/**\n+     * Sanitize a url for use in the src attribute of a {@link Image}.\n+     *\n+     * @param url Link to sanitize\n+     * @return Sanitized link {@link Image}\n+     *\/\n+    String sanitizeImageUrl(String url);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/UrlSanitizer.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * HTML rendering (see {@link org.commonmark.renderer.html.HtmlRenderer})\n+ *\/\n+package jdk.internal.org.commonmark.renderer.html;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/html\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.text.AsciiMatcher;\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.text.CharMatcher;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.text.Characters;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * The node renderer that renders all the core nodes (comes last in the order of node renderers).\n+ * <p>\n+ * Note that while sometimes it would be easier to record what kind of syntax was used on parsing (e.g. ATX vs Setext\n+ * heading), this renderer is intended to also work for documents that were created by directly creating\n+ * {@link Node Nodes} instead. So in order to support that, it sometimes needs to do a bit more work.\n+ *\/\n+public class CoreMarkdownNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+\n+    private final AsciiMatcher textEscape;\n+    private final CharMatcher textEscapeInHeading;\n+    private final CharMatcher linkDestinationNeedsAngleBrackets =\n+            AsciiMatcher.builder().c(' ').c('(').c(')').c('<').c('>').c('\\n').c('\\\\').build();\n+    private final CharMatcher linkDestinationEscapeInAngleBrackets =\n+            AsciiMatcher.builder().c('<').c('>').c('\\n').c('\\\\').build();\n+    private final CharMatcher linkTitleEscapeInQuotes =\n+            AsciiMatcher.builder().c('\"').c('\\n').c('\\\\').build();\n+\n+    private final Pattern orderedListMarkerPattern = Pattern.compile(\"^([0-9]{1,9})([.)])\");\n+\n+    protected final MarkdownNodeRendererContext context;\n+    private final MarkdownWriter writer;\n+    \/**\n+     * If we're currently within a {@link BulletList} or {@link OrderedList}, this keeps the context of that list.\n+     * It has a parent field so that it can represent a stack (for nested lists).\n+     *\/\n+    private ListHolder listHolder;\n+\n+    public CoreMarkdownNodeRenderer(MarkdownNodeRendererContext context) {\n+        this.context = context;\n+        this.writer = context.getWriter();\n+\n+        textEscape = AsciiMatcher.builder().anyOf(\"[]<>`*_&\\n\\\\\").anyOf(context.getSpecialCharacters()).build();\n+        textEscapeInHeading = AsciiMatcher.builder(textEscape).anyOf(\"#\").build();\n+    }\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                BlockQuote.class,\n+                BulletList.class,\n+                Code.class,\n+                Document.class,\n+                Emphasis.class,\n+                FencedCodeBlock.class,\n+                HardLineBreak.class,\n+                Heading.class,\n+                HtmlBlock.class,\n+                HtmlInline.class,\n+                Image.class,\n+                IndentedCodeBlock.class,\n+                Link.class,\n+                ListItem.class,\n+                OrderedList.class,\n+                Paragraph.class,\n+                SoftLineBreak.class,\n+                StrongEmphasis.class,\n+                Text.class,\n+                ThematicBreak.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        \/\/ No rendering itself\n+        visitChildren(document);\n+        writer.line();\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        \/\/ Let's use ___ as it doesn't introduce ambiguity with * or - list item markers\n+        writer.raw(\"___\");\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        if (heading.getLevel() <= 2) {\n+            LineBreakVisitor lineBreakVisitor = new LineBreakVisitor();\n+            heading.accept(lineBreakVisitor);\n+            boolean isMultipleLines = lineBreakVisitor.hasLineBreak();\n+\n+            if (isMultipleLines) {\n+                \/\/ Setext headings: Can have multiple lines, but only level 1 or 2\n+                visitChildren(heading);\n+                writer.line();\n+                if (heading.getLevel() == 1) {\n+                    \/\/ Note that it would be nice to match the length of the contents instead of just using 3, but that's\n+                    \/\/ not easy.\n+                    writer.raw(\"===\");\n+                } else {\n+                    writer.raw(\"---\");\n+                }\n+                writer.block();\n+                return;\n+            }\n+        }\n+\n+        \/\/ ATX headings: Can't have multiple lines, but up to level 6.\n+        for (int i = 0; i < heading.getLevel(); i++) {\n+            writer.raw('#');\n+        }\n+        writer.raw(' ');\n+        visitChildren(heading);\n+\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        String literal = indentedCodeBlock.getLiteral();\n+        \/\/ We need to respect line prefixes which is why we need to write it line by line (e.g. an indented code block\n+        \/\/ within a block quote)\n+        writer.writePrefix(\"    \");\n+        writer.pushPrefix(\"    \");\n+        List<String> lines = getLines(literal);\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            writer.raw(line);\n+            if (i != lines.size() - 1) {\n+                writer.line();\n+            }\n+        }\n+        writer.popPrefix();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock codeBlock) {\n+        String literal = codeBlock.getLiteral();\n+        String fenceChar = codeBlock.getFenceCharacter() != null ? codeBlock.getFenceCharacter() : \"`\";\n+        int openingFenceLength;\n+        if (codeBlock.getOpeningFenceLength() != null) {\n+            \/\/ If we have a known fence length, use it\n+            openingFenceLength = codeBlock.getOpeningFenceLength();\n+        } else {\n+            \/\/ Otherwise, calculate the closing fence length pessimistically, e.g. if the code block itself contains a\n+            \/\/ line with ```, we need to use a fence of length 4. If ``` occurs with non-whitespace characters on a\n+            \/\/ line, we technically don't need a longer fence, but it's not incorrect to do so.\n+            int fenceCharsInLiteral = findMaxRunLength(fenceChar, literal);\n+            openingFenceLength = Math.max(fenceCharsInLiteral + 1, 3);\n+        }\n+        int closingFenceLength = codeBlock.getClosingFenceLength() != null ? codeBlock.getClosingFenceLength() : openingFenceLength;\n+\n+        String openingFence = repeat(fenceChar, openingFenceLength);\n+        String closingFence = repeat(fenceChar, closingFenceLength);\n+        int indent = codeBlock.getFenceIndent();\n+\n+        if (indent > 0) {\n+            String indentPrefix = repeat(\" \", indent);\n+            writer.writePrefix(indentPrefix);\n+            writer.pushPrefix(indentPrefix);\n+        }\n+\n+        writer.raw(openingFence);\n+        if (codeBlock.getInfo() != null) {\n+            writer.raw(codeBlock.getInfo());\n+        }\n+        writer.line();\n+        if (!literal.isEmpty()) {\n+            List<String> lines = getLines(literal);\n+            for (String line : lines) {\n+                writer.raw(line);\n+                writer.line();\n+            }\n+        }\n+        writer.raw(closingFence);\n+        if (indent > 0) {\n+            writer.popPrefix();\n+        }\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        List<String> lines = getLines(htmlBlock.getLiteral());\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            writer.raw(line);\n+            if (i != lines.size() - 1) {\n+                writer.line();\n+            }\n+        }\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        visitChildren(paragraph);\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        writer.writePrefix(\"> \");\n+        writer.pushPrefix(\"> \");\n+        visitChildren(blockQuote);\n+        writer.popPrefix();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        writer.pushTight(bulletList.isTight());\n+        listHolder = new BulletListHolder(listHolder, bulletList);\n+        visitChildren(bulletList);\n+        listHolder = listHolder.parent;\n+        writer.popTight();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        writer.pushTight(orderedList.isTight());\n+        listHolder = new OrderedListHolder(listHolder, orderedList);\n+        visitChildren(orderedList);\n+        listHolder = listHolder.parent;\n+        writer.popTight();\n+        writer.block();\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        int markerIndent = listItem.getMarkerIndent() != null ? listItem.getMarkerIndent() : 0;\n+        String marker;\n+        if (listHolder instanceof BulletListHolder) {\n+            BulletListHolder bulletListHolder = (BulletListHolder) listHolder;\n+            marker = repeat(\" \", markerIndent) + bulletListHolder.marker;\n+        } else if (listHolder instanceof OrderedListHolder) {\n+            OrderedListHolder orderedListHolder = (OrderedListHolder) listHolder;\n+            marker = repeat(\" \", markerIndent) + orderedListHolder.number + orderedListHolder.delimiter;\n+            orderedListHolder.number++;\n+        } else {\n+            throw new IllegalStateException(\"Unknown list holder type: \" + listHolder);\n+        }\n+        Integer contentIndent = listItem.getContentIndent();\n+        String spaces = contentIndent != null ? repeat(\" \", contentIndent - marker.length()) : \" \";\n+        writer.writePrefix(marker);\n+        writer.writePrefix(spaces);\n+        writer.pushPrefix(repeat(\" \", marker.length() + spaces.length()));\n+\n+        if (listItem.getFirstChild() == null) {\n+            \/\/ Empty list item\n+            writer.block();\n+        } else {\n+            visitChildren(listItem);\n+        }\n+\n+        writer.popPrefix();\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        String literal = code.getLiteral();\n+        \/\/ If the literal includes backticks, we can surround them by using one more backtick.\n+        int backticks = findMaxRunLength(\"`\", literal);\n+        for (int i = 0; i < backticks + 1; i++) {\n+            writer.raw('`');\n+        }\n+        \/\/ If the literal starts or ends with a backtick, surround it with a single space.\n+        \/\/ If it starts and ends with a space (but is not only spaces), add an additional space (otherwise they would\n+        \/\/ get removed on parsing).\n+        boolean addSpace = literal.startsWith(\"`\") || literal.endsWith(\"`\") ||\n+                (literal.startsWith(\" \") && literal.endsWith(\" \") && Characters.hasNonSpace(literal));\n+        if (addSpace) {\n+            writer.raw(' ');\n+        }\n+        writer.raw(literal);\n+        if (addSpace) {\n+            writer.raw(' ');\n+        }\n+        for (int i = 0; i < backticks + 1; i++) {\n+            writer.raw('`');\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Emphasis emphasis) {\n+        String delimiter = emphasis.getOpeningDelimiter();\n+        \/\/ Use delimiter that was parsed if available\n+        if (delimiter == null) {\n+            \/\/ When emphasis is nested, a different delimiter needs to be used\n+            delimiter = writer.getLastChar() == '*' ? \"_\" : \"*\";\n+        }\n+        writer.raw(delimiter);\n+        super.visit(emphasis);\n+        writer.raw(delimiter);\n+    }\n+\n+    @Override\n+    public void visit(StrongEmphasis strongEmphasis) {\n+        writer.raw(\"**\");\n+        super.visit(strongEmphasis);\n+        writer.raw(\"**\");\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        writeLinkLike(link.getTitle(), link.getDestination(), link, \"[\");\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        writeLinkLike(image.getTitle(), image.getDestination(), image, \"![\");\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        writer.raw(htmlInline.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        writer.raw(\"  \");\n+        writer.line();\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        writer.line();\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        \/\/ Text is tricky. In Markdown special characters (`-`, `#` etc.) can be escaped (`\\-`, `\\#` etc.) so that\n+        \/\/ they're parsed as plain text. Currently, whether a character was escaped or not is not recorded in the Node,\n+        \/\/ so here we don't know. If we just wrote out those characters unescaped, the resulting Markdown would change\n+        \/\/ meaning (turn into a list item, heading, etc.).\n+        \/\/ You might say \"Why not store that in the Node when parsing\", but that wouldn't work for the use case where\n+        \/\/ nodes are constructed directly instead of via parsing. This renderer needs to work for that too.\n+        \/\/ So currently, when in doubt, we escape. For special characters only occurring at the beginning of a line,\n+        \/\/ we only escape them then (we wouldn't want to escape every `.` for example).\n+        String literal = text.getLiteral();\n+        if (writer.isAtLineStart() && !literal.isEmpty()) {\n+            char c = literal.charAt(0);\n+            switch (c) {\n+                case '-': {\n+                    \/\/ Would be ambiguous with a bullet list marker, escape\n+                    writer.raw(\"\\\\-\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case '#': {\n+                    \/\/ Would be ambiguous with an ATX heading, escape\n+                    writer.raw(\"\\\\#\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case '=': {\n+                    \/\/ Would be ambiguous with a Setext heading, escape\n+                    writer.raw(\"\\\\=\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9': {\n+                    \/\/ Check for ordered list marker\n+                    Matcher m = orderedListMarkerPattern.matcher(literal);\n+                    if (m.find()) {\n+                        writer.raw(m.group(1));\n+                        writer.raw(\"\\\\\" + m.group(2));\n+                        literal = literal.substring(m.end());\n+                    }\n+                    break;\n+                }\n+                case '\\t': {\n+                    writer.raw(\"&#9;\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+                case ' ': {\n+                    writer.raw(\"&#32;\");\n+                    literal = literal.substring(1);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        CharMatcher escape = text.getParent() instanceof Heading ? textEscapeInHeading : textEscape;\n+\n+        if (literal.endsWith(\"!\") && text.getNext() instanceof Link) {\n+            \/\/ If we wrote the `!` unescaped, it would turn the link into an image instead.\n+            writer.text(literal.substring(0, literal.length() - 1), escape);\n+            writer.raw(\"\\\\!\");\n+        } else {\n+            writer.text(literal, escape);\n+        }\n+    }\n+\n+    @Override\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+\n+    private static int findMaxRunLength(String needle, String s) {\n+        int maxRunLength = 0;\n+        int pos = 0;\n+        while (pos < s.length()) {\n+            pos = s.indexOf(needle, pos);\n+            if (pos == -1) {\n+                return maxRunLength;\n+            }\n+            int runLength = 0;\n+            do {\n+                pos += needle.length();\n+                runLength++;\n+            } while (s.startsWith(needle, pos));\n+            maxRunLength = Math.max(runLength, maxRunLength);\n+        }\n+        return maxRunLength;\n+    }\n+\n+    private static boolean contains(String s, CharMatcher charMatcher) {\n+        for (int i = 0; i < s.length(); i++) {\n+            if (charMatcher.matches(s.charAt(i))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ Keep for Android compat (String.repeat only available on Android 12 and later)\n+    private static String repeat(String s, int count) {\n+        StringBuilder sb = new StringBuilder(s.length() * count);\n+        for (int i = 0; i < count; i++) {\n+            sb.append(s);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static List<String> getLines(String literal) {\n+        \/\/ Without -1, split would discard all trailing empty strings, which is not what we want, e.g. it would\n+        \/\/ return the same result for \"abc\", \"abc\\n\" and \"abc\\n\\n\".\n+        \/\/ With -1, it returns [\"abc\"], [\"abc\", \"\"] and [\"abc\", \"\", \"\"].\n+        String[] parts = literal.split(\"\\n\", -1);\n+        if (parts[parts.length - 1].isEmpty()) {\n+            \/\/ But we don't want the last empty string, as \"\\n\" is used as a line terminator (not a separator),\n+            \/\/ so return without the last element.\n+            return Arrays.asList(parts).subList(0, parts.length - 1);\n+        } else {\n+            return Arrays.asList(parts);\n+        }\n+    }\n+\n+    private void writeLinkLike(String title, String destination, Node node, String opener) {\n+        writer.raw(opener);\n+        visitChildren(node);\n+        writer.raw(']');\n+        writer.raw('(');\n+        if (contains(destination, linkDestinationNeedsAngleBrackets)) {\n+            writer.raw('<');\n+            writer.text(destination, linkDestinationEscapeInAngleBrackets);\n+            writer.raw('>');\n+        } else {\n+            writer.raw(destination);\n+        }\n+        if (title != null) {\n+            writer.raw(' ');\n+            writer.raw('\"');\n+            writer.text(title, linkTitleEscapeInQuotes);\n+            writer.raw('\"');\n+        }\n+        writer.raw(')');\n+    }\n+\n+    private static class ListHolder {\n+        final ListHolder parent;\n+\n+        protected ListHolder(ListHolder parent) {\n+            this.parent = parent;\n+        }\n+    }\n+\n+    private static class BulletListHolder extends ListHolder {\n+        final String marker;\n+\n+        public BulletListHolder(ListHolder parent, BulletList bulletList) {\n+            super(parent);\n+            this.marker = bulletList.getMarker() != null ? bulletList.getMarker() : \"-\";\n+        }\n+    }\n+\n+    private static class OrderedListHolder extends ListHolder {\n+        final String delimiter;\n+        private int number;\n+\n+        protected OrderedListHolder(ListHolder parent, OrderedList orderedList) {\n+            super(parent);\n+            delimiter = orderedList.getMarkerDelimiter() != null ? orderedList.getMarkerDelimiter() : \".\";\n+            number = orderedList.getMarkerStartNumber() != null ? orderedList.getMarkerStartNumber() : 1;\n+        }\n+    }\n+\n+    \/**\n+     * Visits nodes to check if there are any soft or hard line breaks.\n+     *\/\n+    private static class LineBreakVisitor extends AbstractVisitor {\n+        private boolean lineBreak = false;\n+\n+        public boolean hasLineBreak() {\n+            return lineBreak;\n+        }\n+\n+        @Override\n+        public void visit(SoftLineBreak softLineBreak) {\n+            super.visit(softLineBreak);\n+            lineBreak = true;\n+        }\n+\n+        @Override\n+        public void visit(HardLineBreak hardLineBreak) {\n+            super.visit(hardLineBreak);\n+            lineBreak = true;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/CoreMarkdownNodeRenderer.java","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Context that is passed to custom node renderers, see {@link MarkdownNodeRendererFactory#create}.\n+ *\/\n+public interface MarkdownNodeRendererContext {\n+\n+    \/**\n+     * @return the writer to use\n+     *\/\n+    MarkdownWriter getWriter();\n+\n+    \/**\n+     * Render the specified node and its children using the configured renderers. This should be used to render child\n+     * nodes; be careful not to pass the node that is being rendered, that would result in an endless loop.\n+     *\n+     * @param node the node to render\n+     *\/\n+    void render(Node node);\n+\n+    \/**\n+     * @return additional special characters that need to be escaped if they occur in normal text; currently only ASCII\n+     * characters are allowed\n+     *\/\n+    Set<Character> getSpecialCharacters();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownNodeRendererContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Factory for instantiating new node renderers for rendering custom nodes.\n+ *\/\n+public interface MarkdownNodeRendererFactory {\n+\n+    \/**\n+     * Create a new node renderer for the specified rendering context.\n+     *\n+     * @param context the context for rendering (normally passed on to the node renderer)\n+     * @return a node renderer\n+     *\/\n+    NodeRenderer create(MarkdownNodeRendererContext context);\n+\n+    \/**\n+     * @return the additional special characters that this factory would like to have escaped in normal text; currently\n+     * only ASCII characters are allowed\n+     *\/\n+    Set<Character> getSpecialCharacters();\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownNodeRendererFactory.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.renderer.NodeRendererMap;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.Renderer;\n+\n+import java.util.*;\n+\n+\/**\n+ * Renders nodes to Markdown (CommonMark syntax); use {@link #builder()} to create a renderer.\n+ * <p>\n+ * Note that it doesn't currently preserve the exact syntax of the original input Markdown (if any):\n+ * <ul>\n+ *     <li>Headings are output as ATX headings if possible (multi-line headings need Setext headings)<\/li>\n+ *     <li>Links are always rendered as inline links (no support for reference links yet)<\/li>\n+ *     <li>Escaping might be over-eager, e.g. a plain {@code *} might be escaped\n+ *     even though it doesn't need to be in that particular context<\/li>\n+ *     <li>Leading whitespace in paragraphs is not preserved<\/li>\n+ * <\/ul>\n+ * However, it should produce Markdown that is semantically equivalent to the input, i.e. if the Markdown was parsed\n+ * again and compared against the original AST, it should be the same (minus bugs).\n+ *\/\n+public class MarkdownRenderer implements Renderer {\n+\n+    private final List<MarkdownNodeRendererFactory> nodeRendererFactories;\n+\n+    private MarkdownRenderer(Builder builder) {\n+        this.nodeRendererFactories = new ArrayList<>(builder.nodeRendererFactories.size() + 1);\n+        this.nodeRendererFactories.addAll(builder.nodeRendererFactories);\n+        \/\/ Add as last. This means clients can override the rendering of core nodes if they want.\n+        this.nodeRendererFactories.add(new MarkdownNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(MarkdownNodeRendererContext context) {\n+                return new CoreMarkdownNodeRenderer(context);\n+            }\n+\n+            @Override\n+            public Set<Character> getSpecialCharacters() {\n+                return Collections.emptySet();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring a {@link MarkdownRenderer}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public void render(Node node, Appendable output) {\n+        RendererContext context = new RendererContext(new MarkdownWriter(output));\n+        context.render(node);\n+    }\n+\n+    @Override\n+    public String render(Node node) {\n+        StringBuilder sb = new StringBuilder();\n+        render(node, sb);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Builder for configuring a {@link MarkdownRenderer}. See methods for default configuration.\n+     *\/\n+    public static class Builder {\n+\n+        private final List<MarkdownNodeRendererFactory> nodeRendererFactories = new ArrayList<>();\n+\n+        \/**\n+         * @return the configured {@link MarkdownRenderer}\n+         *\/\n+        public MarkdownRenderer build() {\n+            return new MarkdownRenderer(this);\n+        }\n+\n+        \/**\n+         * Add a factory for instantiating a node renderer (done when rendering). This allows to override the rendering\n+         * of node types or define rendering for custom node types.\n+         * <p>\n+         * If multiple node renderers for the same node type are created, the one from the factory that was added first\n+         * \"wins\". (This is how the rendering for core node types can be overridden; the default rendering comes last.)\n+         *\n+         * @param nodeRendererFactory the factory for creating a node renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder nodeRendererFactory(MarkdownNodeRendererFactory nodeRendererFactory) {\n+            this.nodeRendererFactories.add(nodeRendererFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            for (Extension extension : extensions) {\n+                if (extension instanceof MarkdownRendererExtension) {\n+                    MarkdownRendererExtension markdownRendererExtension = (MarkdownRendererExtension) extension;\n+                    markdownRendererExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link MarkdownRenderer} for rendering custom nodes.\n+     *\/\n+    public interface MarkdownRendererExtension extends Extension {\n+\n+        \/**\n+         * Extend Markdown rendering, usually by registering custom node renderers using {@link Builder#nodeRendererFactory}.\n+         *\n+         * @param rendererBuilder the renderer builder to extend\n+         *\/\n+        void extend(Builder rendererBuilder);\n+    }\n+\n+    private class RendererContext implements MarkdownNodeRendererContext {\n+        private final MarkdownWriter writer;\n+        private final NodeRendererMap nodeRendererMap = new NodeRendererMap();\n+        private final Set<Character> additionalTextEscapes;\n+\n+        private RendererContext(MarkdownWriter writer) {\n+            \/\/ Set fields that are used by interface\n+            this.writer = writer;\n+            Set<Character> escapes = new HashSet<Character>();\n+            for (MarkdownNodeRendererFactory factory : nodeRendererFactories) {\n+                escapes.addAll(factory.getSpecialCharacters());\n+            }\n+            additionalTextEscapes = Collections.unmodifiableSet(escapes);\n+\n+            \/\/ The first node renderer for a node type \"wins\".\n+            for (int i = nodeRendererFactories.size() - 1; i >= 0; i--) {\n+                MarkdownNodeRendererFactory nodeRendererFactory = nodeRendererFactories.get(i);\n+                \/\/ Pass in this as context here, which uses the fields set above\n+                NodeRenderer nodeRenderer = nodeRendererFactory.create(this);\n+                nodeRendererMap.add(nodeRenderer);\n+            }\n+        }\n+\n+        @Override\n+        public MarkdownWriter getWriter() {\n+            return writer;\n+        }\n+\n+        @Override\n+        public void render(Node node) {\n+            nodeRendererMap.render(node);\n+        }\n+\n+        @Override\n+        public Set<Character> getSpecialCharacters() {\n+            return additionalTextEscapes;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownRenderer.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.markdown;\n+\n+import jdk.internal.org.commonmark.text.CharMatcher;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+\n+\/**\n+ * Writer for Markdown (CommonMark) text.\n+ *\/\n+public class MarkdownWriter {\n+\n+    private final Appendable buffer;\n+\n+    private int blockSeparator = 0;\n+    private char lastChar;\n+    private boolean atLineStart = true;\n+\n+    \/\/ Stacks of settings that affect various rendering behaviors. The common pattern here is that callers use \"push\" to\n+    \/\/ change a setting, render some nodes, and then \"pop\" the setting off the stack again to restore previous state.\n+    private final LinkedList<String> prefixes = new LinkedList<>();\n+    private final LinkedList<Boolean> tight = new LinkedList<>();\n+    private final LinkedList<CharMatcher> rawEscapes = new LinkedList<>();\n+\n+    public MarkdownWriter(Appendable out) {\n+        buffer = out;\n+    }\n+\n+    \/**\n+     * Write the supplied string (raw\/unescaped except if {@link #pushRawEscape} was used).\n+     *\/\n+    public void raw(String s) {\n+        flushBlockSeparator();\n+        write(s, null);\n+    }\n+\n+    \/**\n+     * Write the supplied character (raw\/unescaped except if {@link #pushRawEscape} was used).\n+     *\/\n+    public void raw(char c) {\n+        flushBlockSeparator();\n+        write(c);\n+    }\n+\n+    \/**\n+     * Write the supplied string with escaping.\n+     *\n+     * @param s      the string to write\n+     * @param escape which characters to escape\n+     *\/\n+    public void text(String s, CharMatcher escape) {\n+        if (s.isEmpty()) {\n+            return;\n+        }\n+        flushBlockSeparator();\n+        write(s, escape);\n+\n+        lastChar = s.charAt(s.length() - 1);\n+        atLineStart = false;\n+    }\n+\n+    \/**\n+     * Write a newline (line terminator).\n+     *\/\n+    public void line() {\n+        write('\\n');\n+        writePrefixes();\n+        atLineStart = true;\n+    }\n+\n+    \/**\n+     * Enqueue a block separator to be written before the next text is written. Block separators are not written\n+     * straight away because if there are no more blocks to write we don't want a separator (at the end of the document).\n+     *\/\n+    public void block() {\n+        \/\/ Remember whether this should be a tight or loose separator now because tight could get changed in between\n+        \/\/ this and the next flush.\n+        blockSeparator = isTight() ? 1 : 2;\n+        atLineStart = true;\n+    }\n+\n+    \/**\n+     * Push a prefix onto the top of the stack. All prefixes are written at the beginning of each line, until the\n+     * prefix is popped again.\n+     *\n+     * @param prefix the raw prefix string\n+     *\/\n+    public void pushPrefix(String prefix) {\n+        prefixes.addLast(prefix);\n+    }\n+\n+    \/**\n+     * Write a prefix.\n+     *\n+     * @param prefix the raw prefix string to write\n+     *\/\n+    public void writePrefix(String prefix) {\n+        boolean tmp = atLineStart;\n+        raw(prefix);\n+        atLineStart = tmp;\n+    }\n+\n+    \/**\n+     * Remove the last prefix from the top of the stack.\n+     *\/\n+    public void popPrefix() {\n+        prefixes.removeLast();\n+    }\n+\n+    \/**\n+     * Change whether blocks are tight or loose. Loose is the default where blocks are separated by a blank line. Tight\n+     * is where blocks are not separated by a blank line. Tight blocks are used in lists, if there are no blank lines\n+     * within the list.\n+     * <p>\n+     * Note that changing this does not affect block separators that have already been enqueued with {@link #block()},\n+     * only future ones.\n+     *\/\n+    public void pushTight(boolean tight) {\n+        this.tight.addLast(tight);\n+    }\n+\n+    \/**\n+     * Remove the last \"tight\" setting from the top of the stack.\n+     *\/\n+    public void popTight() {\n+        this.tight.removeLast();\n+    }\n+\n+    \/**\n+     * Escape the characters matching the supplied matcher, in all text (text and raw). This might be useful to\n+     * extensions that add another layer of syntax, e.g. the tables extension that uses `|` to separate cells and needs\n+     * all `|` characters to be escaped (even in code spans).\n+     *\n+     * @param rawEscape the characters to escape in raw text\n+     *\/\n+    public void pushRawEscape(CharMatcher rawEscape) {\n+        rawEscapes.add(rawEscape);\n+    }\n+\n+    \/**\n+     * Remove the last raw escape from the top of the stack.\n+     *\/\n+    public void popRawEscape() {\n+        rawEscapes.removeLast();\n+    }\n+\n+    \/**\n+     * @return the last character that was written\n+     *\/\n+    public char getLastChar() {\n+        return lastChar;\n+    }\n+\n+    \/**\n+     * @return whether we're at the line start (not counting any prefixes), i.e. after a {@link #line} or {@link #block}.\n+     *\/\n+    public boolean isAtLineStart() {\n+        return atLineStart;\n+    }\n+\n+    private void write(String s, CharMatcher escape) {\n+        try {\n+            if (rawEscapes.isEmpty() && escape == null) {\n+                \/\/ Normal fast path\n+                buffer.append(s);\n+            } else {\n+                for (int i = 0; i < s.length(); i++) {\n+                    append(s.charAt(i), escape);\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        int length = s.length();\n+        if (length != 0) {\n+            lastChar = s.charAt(length - 1);\n+        }\n+        atLineStart = false;\n+    }\n+\n+    private void write(char c) {\n+        try {\n+            append(c, null);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        lastChar = c;\n+        atLineStart = false;\n+    }\n+\n+    private void writePrefixes() {\n+        if (!prefixes.isEmpty()) {\n+            for (String prefix : prefixes) {\n+                write(prefix, null);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * If a block separator has been enqueued with {@link #block()} but not yet written, write it now.\n+     *\/\n+    private void flushBlockSeparator() {\n+        if (blockSeparator != 0) {\n+            write('\\n');\n+            writePrefixes();\n+            if (blockSeparator > 1) {\n+                write('\\n');\n+                writePrefixes();\n+            }\n+            blockSeparator = 0;\n+        }\n+    }\n+\n+    private void append(char c, CharMatcher escape) throws IOException {\n+        if (needsEscaping(c, escape)) {\n+            if (c == '\\n') {\n+                \/\/ Can't escape this with \\, use numeric character reference\n+                buffer.append(\"&#10;\");\n+            } else {\n+                buffer.append('\\\\');\n+                buffer.append(c);\n+            }\n+        } else {\n+            buffer.append(c);\n+        }\n+    }\n+\n+    private boolean isTight() {\n+        return !tight.isEmpty() && tight.getLast();\n+    }\n+\n+    private boolean needsEscaping(char c, CharMatcher escape) {\n+        return (escape != null && escape.matches(c)) || rawNeedsEscaping(c);\n+    }\n+\n+    private boolean rawNeedsEscaping(char c) {\n+        for (CharMatcher rawEscape : rawEscapes) {\n+            if (rawEscape.matches(c)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/MarkdownWriter.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Markdown rendering (see {@link org.commonmark.renderer.markdown.MarkdownRenderer})\n+ *\/\n+package jdk.internal.org.commonmark.renderer.markdown;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/markdown\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.*;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.internal.renderer.text.BulletListHolder;\n+import jdk.internal.org.commonmark.internal.renderer.text.ListHolder;\n+import jdk.internal.org.commonmark.internal.renderer.text.OrderedListHolder;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/**\n+ * The node renderer that renders all the core nodes (comes last in the order of node renderers).\n+ *\/\n+public class CoreTextContentNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+\n+    protected final TextContentNodeRendererContext context;\n+    private final TextContentWriter textContent;\n+\n+    private ListHolder listHolder;\n+\n+    public CoreTextContentNodeRenderer(TextContentNodeRendererContext context) {\n+        this.context = context;\n+        this.textContent = context.getWriter();\n+    }\n+\n+    @Override\n+    public Set<Class<? extends Node>> getNodeTypes() {\n+        return new HashSet<>(Arrays.asList(\n+                Document.class,\n+                Heading.class,\n+                Paragraph.class,\n+                BlockQuote.class,\n+                BulletList.class,\n+                FencedCodeBlock.class,\n+                HtmlBlock.class,\n+                ThematicBreak.class,\n+                IndentedCodeBlock.class,\n+                Link.class,\n+                ListItem.class,\n+                OrderedList.class,\n+                Image.class,\n+                Emphasis.class,\n+                StrongEmphasis.class,\n+                Text.class,\n+                Code.class,\n+                HtmlInline.class,\n+                SoftLineBreak.class,\n+                HardLineBreak.class\n+        ));\n+    }\n+\n+    @Override\n+    public void render(Node node) {\n+        node.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(Document document) {\n+        \/\/ No rendering itself\n+        visitChildren(document);\n+    }\n+\n+    @Override\n+    public void visit(BlockQuote blockQuote) {\n+        textContent.write('\\u00ab');\n+        visitChildren(blockQuote);\n+        textContent.write('\\u00bb');\n+\n+        writeEndOfLineIfNeeded(blockQuote, null);\n+    }\n+\n+    @Override\n+    public void visit(BulletList bulletList) {\n+        if (listHolder != null) {\n+            writeEndOfLine();\n+        }\n+        listHolder = new BulletListHolder(listHolder, bulletList);\n+        visitChildren(bulletList);\n+        writeEndOfLineIfNeeded(bulletList, null);\n+        if (listHolder.getParent() != null) {\n+            listHolder = listHolder.getParent();\n+        } else {\n+            listHolder = null;\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Code code) {\n+        textContent.write('\\\"');\n+        textContent.write(code.getLiteral());\n+        textContent.write('\\\"');\n+    }\n+\n+    @Override\n+    public void visit(FencedCodeBlock fencedCodeBlock) {\n+        if (context.stripNewlines()) {\n+            textContent.writeStripped(fencedCodeBlock.getLiteral());\n+            writeEndOfLineIfNeeded(fencedCodeBlock, null);\n+        } else {\n+            textContent.write(fencedCodeBlock.getLiteral());\n+        }\n+    }\n+\n+    @Override\n+    public void visit(HardLineBreak hardLineBreak) {\n+        writeEndOfLineIfNeeded(hardLineBreak, null);\n+    }\n+\n+    @Override\n+    public void visit(Heading heading) {\n+        visitChildren(heading);\n+        writeEndOfLineIfNeeded(heading, ':');\n+    }\n+\n+    @Override\n+    public void visit(ThematicBreak thematicBreak) {\n+        if (!context.stripNewlines()) {\n+            textContent.write(\"***\");\n+        }\n+        writeEndOfLineIfNeeded(thematicBreak, null);\n+    }\n+\n+    @Override\n+    public void visit(HtmlInline htmlInline) {\n+        writeText(htmlInline.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(HtmlBlock htmlBlock) {\n+        writeText(htmlBlock.getLiteral());\n+    }\n+\n+    @Override\n+    public void visit(Image image) {\n+        writeLink(image, image.getTitle(), image.getDestination());\n+    }\n+\n+    @Override\n+    public void visit(IndentedCodeBlock indentedCodeBlock) {\n+        if (context.stripNewlines()) {\n+            textContent.writeStripped(indentedCodeBlock.getLiteral());\n+            writeEndOfLineIfNeeded(indentedCodeBlock, null);\n+        } else {\n+            textContent.write(indentedCodeBlock.getLiteral());\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Link link) {\n+        writeLink(link, link.getTitle(), link.getDestination());\n+    }\n+\n+    @Override\n+    public void visit(ListItem listItem) {\n+        if (listHolder != null && listHolder instanceof OrderedListHolder) {\n+            OrderedListHolder orderedListHolder = (OrderedListHolder) listHolder;\n+            String indent = context.stripNewlines() ? \"\" : orderedListHolder.getIndent();\n+            textContent.write(indent + orderedListHolder.getCounter() + orderedListHolder.getDelimiter() + \" \");\n+            visitChildren(listItem);\n+            writeEndOfLineIfNeeded(listItem, null);\n+            orderedListHolder.increaseCounter();\n+        } else if (listHolder != null && listHolder instanceof BulletListHolder) {\n+            BulletListHolder bulletListHolder = (BulletListHolder) listHolder;\n+            if (!context.stripNewlines()) {\n+                textContent.write(bulletListHolder.getIndent() + bulletListHolder.getMarker() + \" \");\n+            }\n+            visitChildren(listItem);\n+            writeEndOfLineIfNeeded(listItem, null);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(OrderedList orderedList) {\n+        if (listHolder != null) {\n+            writeEndOfLine();\n+        }\n+        listHolder = new OrderedListHolder(listHolder, orderedList);\n+        visitChildren(orderedList);\n+        writeEndOfLineIfNeeded(orderedList, null);\n+        if (listHolder.getParent() != null) {\n+            listHolder = listHolder.getParent();\n+        } else {\n+            listHolder = null;\n+        }\n+    }\n+\n+    @Override\n+    public void visit(Paragraph paragraph) {\n+        visitChildren(paragraph);\n+        \/\/ Add \"end of line\" only if its \"root paragraph.\n+        if (paragraph.getParent() == null || paragraph.getParent() instanceof Document) {\n+            writeEndOfLineIfNeeded(paragraph, null);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(SoftLineBreak softLineBreak) {\n+        writeEndOfLineIfNeeded(softLineBreak, null);\n+    }\n+\n+    @Override\n+    public void visit(Text text) {\n+        writeText(text.getLiteral());\n+    }\n+\n+    @Override\n+    protected void visitChildren(Node parent) {\n+        Node node = parent.getFirstChild();\n+        while (node != null) {\n+            Node next = node.getNext();\n+            context.render(node);\n+            node = next;\n+        }\n+    }\n+\n+    private void writeText(String text) {\n+        if (context.stripNewlines()) {\n+            textContent.writeStripped(text);\n+        } else {\n+            textContent.write(text);\n+        }\n+    }\n+\n+    private void writeLink(Node node, String title, String destination) {\n+        boolean hasChild = node.getFirstChild() != null;\n+        boolean hasTitle = title != null && !title.equals(destination);\n+        boolean hasDestination = destination != null && !destination.equals(\"\");\n+\n+        if (hasChild) {\n+            textContent.write('\"');\n+            visitChildren(node);\n+            textContent.write('\"');\n+            if (hasTitle || hasDestination) {\n+                textContent.whitespace();\n+                textContent.write('(');\n+            }\n+        }\n+\n+        if (hasTitle) {\n+            textContent.write(title);\n+            if (hasDestination) {\n+                textContent.colon();\n+                textContent.whitespace();\n+            }\n+        }\n+\n+        if (hasDestination) {\n+            textContent.write(destination);\n+        }\n+\n+        if (hasChild && (hasTitle || hasDestination)) {\n+            textContent.write(')');\n+        }\n+    }\n+\n+    private void writeEndOfLineIfNeeded(Node node, Character c) {\n+        if (context.stripNewlines()) {\n+            if (c != null) {\n+                textContent.write(c);\n+            }\n+            if (node.getNext() != null) {\n+                textContent.whitespace();\n+            }\n+        } else {\n+            if (node.getNext() != null) {\n+                textContent.line();\n+            }\n+        }\n+    }\n+\n+    private void writeEndOfLine() {\n+        if (context.stripNewlines()) {\n+            textContent.whitespace();\n+        } else {\n+            textContent.line();\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/CoreTextContentNodeRenderer.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.node.Node;\n+\n+public interface TextContentNodeRendererContext {\n+\n+    \/**\n+     * @return true for stripping new lines and render text as \"single line\",\n+     * false for keeping all line breaks.\n+     *\/\n+    boolean stripNewlines();\n+\n+    \/**\n+     * @return the writer to use\n+     *\/\n+    TextContentWriter getWriter();\n+\n+    \/**\n+     * Render the specified node and its children using the configured renderers. This should be used to render child\n+     * nodes; be careful not to pass the node that is being rendered, that would result in an endless loop.\n+     *\n+     * @param node the node to render\n+     *\/\n+    void render(Node node);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentNodeRendererContext.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+\n+\/**\n+ * Factory for instantiating new node renderers when rendering is done.\n+ *\/\n+public interface TextContentNodeRendererFactory {\n+\n+    \/**\n+     * Create a new node renderer for the specified rendering context.\n+     *\n+     * @param context the context for rendering (normally passed on to the node renderer)\n+     * @return a node renderer\n+     *\/\n+    NodeRenderer create(TextContentNodeRendererContext context);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentNodeRendererFactory.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.internal.renderer.NodeRendererMap;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.Renderer;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Renders nodes to plain text content with minimal markup-like additions.\n+ *\/\n+public class TextContentRenderer implements Renderer {\n+\n+    private final boolean stripNewlines;\n+\n+    private final List<TextContentNodeRendererFactory> nodeRendererFactories;\n+\n+    private TextContentRenderer(Builder builder) {\n+        this.stripNewlines = builder.stripNewlines;\n+\n+        this.nodeRendererFactories = new ArrayList<>(builder.nodeRendererFactories.size() + 1);\n+        this.nodeRendererFactories.addAll(builder.nodeRendererFactories);\n+        \/\/ Add as last. This means clients can override the rendering of core nodes if they want.\n+        this.nodeRendererFactories.add(new TextContentNodeRendererFactory() {\n+            @Override\n+            public NodeRenderer create(TextContentNodeRendererContext context) {\n+                return new CoreTextContentNodeRenderer(context);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create a new builder for configuring a {@link TextContentRenderer}.\n+     *\n+     * @return a builder\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public void render(Node node, Appendable output) {\n+        RendererContext context = new RendererContext(new TextContentWriter(output));\n+        context.render(node);\n+    }\n+\n+    @Override\n+    public String render(Node node) {\n+        StringBuilder sb = new StringBuilder();\n+        render(node, sb);\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Builder for configuring a {@link TextContentRenderer}. See methods for default configuration.\n+     *\/\n+    public static class Builder {\n+\n+        private boolean stripNewlines = false;\n+        private List<TextContentNodeRendererFactory> nodeRendererFactories = new ArrayList<>();\n+\n+        \/**\n+         * @return the configured {@link TextContentRenderer}\n+         *\/\n+        public TextContentRenderer build() {\n+            return new TextContentRenderer(this);\n+        }\n+\n+        \/**\n+         * Set the value of flag for stripping new lines.\n+         *\n+         * @param stripNewlines true for stripping new lines and render text as \"single line\",\n+         *                      false for keeping all line breaks\n+         * @return {@code this}\n+         *\/\n+        public Builder stripNewlines(boolean stripNewlines) {\n+            this.stripNewlines = stripNewlines;\n+            return this;\n+        }\n+\n+        \/**\n+         * Add a factory for instantiating a node renderer (done when rendering). This allows to override the rendering\n+         * of node types or define rendering for custom node types.\n+         * <p>\n+         * If multiple node renderers for the same node type are created, the one from the factory that was added first\n+         * \"wins\". (This is how the rendering for core node types can be overridden; the default rendering comes last.)\n+         *\n+         * @param nodeRendererFactory the factory for creating a node renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder nodeRendererFactory(TextContentNodeRendererFactory nodeRendererFactory) {\n+            this.nodeRendererFactories.add(nodeRendererFactory);\n+            return this;\n+        }\n+\n+        \/**\n+         * @param extensions extensions to use on this text content renderer\n+         * @return {@code this}\n+         *\/\n+        public Builder extensions(Iterable<? extends Extension> extensions) {\n+            for (Extension extension : extensions) {\n+                if (extension instanceof TextContentRenderer.TextContentRendererExtension) {\n+                    TextContentRenderer.TextContentRendererExtension textContentRendererExtension =\n+                            (TextContentRenderer.TextContentRendererExtension) extension;\n+                    textContentRendererExtension.extend(this);\n+                }\n+            }\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Extension for {@link TextContentRenderer}.\n+     *\/\n+    public interface TextContentRendererExtension extends Extension {\n+        void extend(TextContentRenderer.Builder rendererBuilder);\n+    }\n+\n+    private class RendererContext implements TextContentNodeRendererContext {\n+        private final TextContentWriter textContentWriter;\n+        private final NodeRendererMap nodeRendererMap = new NodeRendererMap();\n+\n+        private RendererContext(TextContentWriter textContentWriter) {\n+            this.textContentWriter = textContentWriter;\n+\n+            \/\/ The first node renderer for a node type \"wins\".\n+            for (int i = nodeRendererFactories.size() - 1; i >= 0; i--) {\n+                TextContentNodeRendererFactory nodeRendererFactory = nodeRendererFactories.get(i);\n+                NodeRenderer nodeRenderer = nodeRendererFactory.create(this);\n+                nodeRendererMap.add(nodeRenderer);\n+            }\n+        }\n+\n+        @Override\n+        public boolean stripNewlines() {\n+            return stripNewlines;\n+        }\n+\n+        @Override\n+        public TextContentWriter getWriter() {\n+            return textContentWriter;\n+        }\n+\n+        @Override\n+        public void render(Node node) {\n+            nodeRendererMap.render(node);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentRenderer.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.renderer.text;\n+\n+import java.io.IOException;\n+\n+public class TextContentWriter {\n+\n+    private final Appendable buffer;\n+\n+    private char lastChar;\n+\n+    public TextContentWriter(Appendable out) {\n+        buffer = out;\n+    }\n+\n+    public void whitespace() {\n+        if (lastChar != 0 && lastChar != ' ') {\n+            append(' ');\n+        }\n+    }\n+\n+    public void colon() {\n+        if (lastChar != 0 && lastChar != ':') {\n+            append(':');\n+        }\n+    }\n+\n+    public void line() {\n+        if (lastChar != 0 && lastChar != '\\n') {\n+            append('\\n');\n+        }\n+    }\n+\n+    public void writeStripped(String s) {\n+        append(s.replaceAll(\"[\\\\r\\\\n\\\\s]+\", \" \"));\n+    }\n+\n+    public void write(String s) {\n+        append(s);\n+    }\n+\n+    public void write(char c) {\n+        append(c);\n+    }\n+\n+    private void append(String s) {\n+        try {\n+            buffer.append(s);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        int length = s.length();\n+        if (length != 0) {\n+            lastChar = s.charAt(length - 1);\n+        }\n+    }\n+\n+    private void append(char c) {\n+        try {\n+            buffer.append(c);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        lastChar = c;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/TextContentWriter.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Plain text rendering with minimal markup (see {@link org.commonmark.renderer.text.TextContentRenderer})\n+ *\/\n+package jdk.internal.org.commonmark.renderer.text;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/renderer\/text\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.text;\n+\n+import java.util.BitSet;\n+import java.util.Set;\n+\n+\/**\n+ * Char matcher that can match ASCII characters efficiently.\n+ *\/\n+public class AsciiMatcher implements CharMatcher {\n+    private final BitSet set;\n+\n+    private AsciiMatcher(Builder builder) {\n+        this.set = builder.set;\n+    }\n+\n+    @Override\n+    public boolean matches(char c) {\n+        return set.get(c);\n+    }\n+\n+    public Builder newBuilder() {\n+        return new Builder((BitSet) set.clone());\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder(new BitSet());\n+    }\n+\n+    public static Builder builder(AsciiMatcher matcher) {\n+        return new Builder((BitSet) matcher.set.clone());\n+    }\n+\n+    public static class Builder {\n+        private final BitSet set;\n+\n+        private Builder(BitSet set) {\n+            this.set = set;\n+        }\n+\n+        public Builder c(char c) {\n+            if (c > 127) {\n+                throw new IllegalArgumentException(\"Can only match ASCII characters\");\n+            }\n+            set.set(c);\n+            return this;\n+        }\n+\n+        public Builder anyOf(String s) {\n+            for (int i = 0; i < s.length(); i++) {\n+                c(s.charAt(i));\n+            }\n+            return this;\n+        }\n+\n+        public Builder anyOf(Set<Character> characters) {\n+            for (Character c : characters) {\n+                c(c);\n+            }\n+            return this;\n+        }\n+\n+        public Builder range(char from, char toInclusive) {\n+            for (char c = from; c <= toInclusive; c++) {\n+                c(c);\n+            }\n+            return this;\n+        }\n+\n+        public AsciiMatcher build() {\n+            return new AsciiMatcher(this);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/AsciiMatcher.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.text;\n+\n+\/**\n+ * Matcher interface for {@code char} values.\n+ * <p>\n+ * Note that because this matches on {@code char} values only (as opposed to {@code int} code points),\n+ * this only operates on the level of code units and doesn't support supplementary characters\n+ * (see {@link Character#isSupplementaryCodePoint(int)}).\n+ *\/\n+public interface CharMatcher {\n+\n+    boolean matches(char c);\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/CharMatcher.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+package jdk.internal.org.commonmark.text;\n+\n+\/**\n+ * Functions for finding characters in strings or checking characters.\n+ *\/\n+public class Characters {\n+\n+    public static int find(char c, CharSequence s, int startIndex) {\n+        int length = s.length();\n+        for (int i = startIndex; i < length; i++) {\n+            if (s.charAt(i) == c) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static int findLineBreak(CharSequence s, int startIndex) {\n+        int length = s.length();\n+        for (int i = startIndex; i < length; i++) {\n+            switch (s.charAt(i)) {\n+                case '\\n':\n+                case '\\r':\n+                    return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.31.2\/#blank-line\">blank line<\/a>\n+     *\/\n+    public static boolean isBlank(CharSequence s) {\n+        return skipSpaceTab(s, 0, s.length()) == s.length();\n+    }\n+\n+    public static boolean hasNonSpace(CharSequence s) {\n+        int length = s.length();\n+        int skipped = skip(' ', s, 0, length);\n+        return skipped != length;\n+    }\n+\n+    public static boolean isLetter(CharSequence s, int index) {\n+        int codePoint = Character.codePointAt(s, index);\n+        return Character.isLetter(codePoint);\n+    }\n+\n+    public static boolean isSpaceOrTab(CharSequence s, int index) {\n+        if (index < s.length()) {\n+            switch (s.charAt(index)) {\n+                case ' ':\n+                case '\\t':\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.31.2\/#unicode-punctuation-character\">Unicode punctuation character<\/a>\n+     *\/\n+    public static boolean isPunctuationCodePoint(int codePoint) {\n+        switch (Character.getType(codePoint)) {\n+            \/\/ General category \"P\" (punctuation)\n+            case Character.DASH_PUNCTUATION:\n+            case Character.START_PUNCTUATION:\n+            case Character.END_PUNCTUATION:\n+            case Character.CONNECTOR_PUNCTUATION:\n+            case Character.OTHER_PUNCTUATION:\n+            case Character.INITIAL_QUOTE_PUNCTUATION:\n+            case Character.FINAL_QUOTE_PUNCTUATION:\n+                \/\/ General category \"S\" (symbol)\n+            case Character.MATH_SYMBOL:\n+            case Character.CURRENCY_SYMBOL:\n+            case Character.MODIFIER_SYMBOL:\n+            case Character.OTHER_SYMBOL:\n+                return true;\n+            default:\n+                switch (codePoint) {\n+                    case '$':\n+                    case '+':\n+                    case '<':\n+                    case '=':\n+                    case '>':\n+                    case '^':\n+                    case '`':\n+                    case '|':\n+                    case '~':\n+                        return true;\n+                    default:\n+                        return false;\n+                }\n+        }\n+    }\n+\n+    \/**\n+     * Check whether the provided code point is a Unicode whitespace character as defined in the spec.\n+     *\n+     * @see <a href=\"https:\/\/spec.commonmark.org\/0.31.2\/#unicode-whitespace-character\">Unicode whitespace character<\/a>\n+     *\/\n+    public static boolean isWhitespaceCodePoint(int codePoint) {\n+        switch (codePoint) {\n+            case ' ':\n+            case '\\t':\n+            case '\\n':\n+            case '\\f':\n+            case '\\r':\n+                return true;\n+            default:\n+                return Character.getType(codePoint) == Character.SPACE_SEPARATOR;\n+        }\n+    }\n+\n+    public static int skip(char skip, CharSequence s, int startIndex, int endIndex) {\n+        for (int i = startIndex; i < endIndex; i++) {\n+            if (s.charAt(i) != skip) {\n+                return i;\n+            }\n+        }\n+        return endIndex;\n+    }\n+\n+    public static int skipBackwards(char skip, CharSequence s, int startIndex, int lastIndex) {\n+        for (int i = startIndex; i >= lastIndex; i--) {\n+            if (s.charAt(i) != skip) {\n+                return i;\n+            }\n+        }\n+        return lastIndex - 1;\n+    }\n+\n+    public static int skipSpaceTab(CharSequence s, int startIndex, int endIndex) {\n+        for (int i = startIndex; i < endIndex; i++) {\n+            switch (s.charAt(i)) {\n+                case ' ':\n+                case '\\t':\n+                    break;\n+                default:\n+                    return i;\n+            }\n+        }\n+        return endIndex;\n+    }\n+\n+    public static int skipSpaceTabBackwards(CharSequence s, int startIndex, int lastIndex) {\n+        for (int i = startIndex; i >= lastIndex; i--) {\n+            switch (s.charAt(i)) {\n+                case ' ':\n+                case '\\t':\n+                    break;\n+                default:\n+                    return i;\n+            }\n+        }\n+        return lastIndex - 1;\n+    }\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/Characters.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, a notice that is now available elsewhere in this distribution\n+ * accompanied the original version of this file, and, per its terms,\n+ * should not be removed.\n+ *\/\n+\n+\/**\n+ * Text processing utilities for parsing and rendering, exported for use by extensions\n+ *\/\n+package jdk.internal.org.commonmark.text;\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/org\/commonmark\/text\/package-info.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ This module is primarily an import from a recent tagged version of\n+\/\/     https:\/\/github.com\/commonmark\/commonmark-java\n+\/\/\n+\/\/ The following parts are imported:\n+\/\/\n+\/\/ * commonmark\/src\/main\/java\n+\/\/ * commonmark\/src\/main\/resources\n+\/\/ * commonmark-ext-gfm-tables\/src\/main\/java\n+\/\/ * commonmark-ext-gfm-tables\/src\/main\/resources\n+\/\/\n+\/\/ For source and resource files, the following transformations are applied:\n+\/\/\n+\/\/ * legal headers are added\n+\/\/ * package and import statements are updated\n+\/\/ * characters outside the ASCII range are converted to Unicode escapes\n+\/\/ * @SuppressWarnings(\"fallthrough\") is added to getSetextHeadingLevel\n+\/\/ * the value for ENTITY_PATH is updated with the modified package\n+\/\/ * the file `entities.properties` is renamed to `entities.txt`\n+\n+\/**\n+ * Internal support for Markdown.\n+ *\n+ * @since 23\n+ *\/\n+module jdk.internal.md {\n+    requires jdk.compiler;\n+\n+    exports jdk.internal.markdown to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.ext.gfm.tables to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.node to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.parser to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.renderer to\n+            jdk.javadoc,\n+            jdk.jshell;\n+    exports jdk.internal.org.commonmark.renderer.html to\n+            jdk.javadoc,\n+            jdk.jshell;\n+\n+    provides com.sun.tools.javac.api.JavacTrees.DocCommentTreeTransformer\n+            with jdk.internal.markdown.MarkdownTransformer;\n+}\n","filename":"src\/jdk.internal.md\/share\/classes\/module-info.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+## CommonMark 0.22.0\n+\n+### CommonMark License\n+```\n+Copyright (c) 2015, Atlassian Pty Ltd\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+* Redistributions of source code must retain the above copyright notice, this\n+  list of conditions and the following disclaimer.\n+\n+* Redistributions in binary form must reproduce the above copyright notice,\n+  this list of conditions and the following disclaimer in the documentation\n+  and\/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+```\n","filename":"src\/jdk.internal.md\/share\/legal\/commonmark.md","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @since 9\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/package-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -189,1 +189,2 @@\n-Reads \\f[V]jar\\f[R] options and file names from a text file.\n+Reads \\f[V]jar\\f[R] options and file names from a text file as if they\n+were supplied on the command line\n@@ -333,3 +334,3 @@\n-To shorten or simplify the \\f[V]jar\\f[R] command, you can specify\n-arguments in a separate text file and pass it to the \\f[V]jar\\f[R]\n-command with the at sign (\\f[V]\\[at]\\f[R]) as a prefix.\n+To shorten or simplify the \\f[V]jar\\f[R] command, you can provide an arg\n+file that lists the files to include in the JAR file and pass it to the\n+\\f[V]jar\\f[R] command with the at sign (\\f[V]\\[at]\\f[R]) as a prefix.\n@@ -340,0 +341,3 @@\n+.PP\n+If one or more entries in the arg file cannot be found then the jar\n+command fails without creating the JAR file.\n","filename":"src\/jdk.jartool\/share\/man\/jar.1","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,11 @@\n+\n+    \/**\n+     * {@return true if the content is \"phrasing content\"}\n+     *\n+     * Phrasing content is content that may appear in a paragraph, such as text, or certain HTML elements.\n+     *\n+     * @see <a href=\"https:\/\/html.spec.whatwg.org\/multipage\/dom.html#phrasing-content\">Phrasing content<\/a>\n+     *\/\n+    public boolean isPhrasingContent() {\n+        return false;\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Content.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -161,2 +161,3 @@\n-                    if (Utils.toLowerCase(srcfile.getPath()).endsWith(\".html\")) {\n-                        handleHtmlFile(srcfile, dstDocPath);\n+                    var path = Utils.toLowerCase(srcfile.getPath());\n+                    if (path.endsWith(\".html\") || path.endsWith(\".md\")) {\n+                        handleDocFile(srcfile, dstDocPath);\n@@ -189,1 +190,1 @@\n-    private void handleHtmlFile(DocFile srcFile, DocPath dstPath) throws DocletException {\n+    private void handleDocFile(DocFile srcFile, DocPath dstPath) throws DocletException {\n@@ -192,1 +193,1 @@\n-        var path = dstPath.resolve(srcFile.getName());\n+        var path = dstPath.resolve(srcFile.getName().replaceAll(\"\\\\.[a-z]+$\", \".html\"));\n@@ -249,2 +250,2 @@\n-        private String getWindowTitle(HtmlDocletWriter docletWriter, Element element) {\n-            String t = configuration.utils.getHTMLTitle(element);\n+        private String getWindowTitle(HtmlDocletWriter docletWriter, DocFileElement element) {\n+            var t = docletWriter.getFileTitle(element);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandler.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.DocFileElement;\n@@ -73,1 +73,1 @@\n-    final Map<Element, String> titles = new WeakHashMap<>();\n+    final Map<DocFileElement, String> titles = new WeakHashMap<>();\n@@ -277,1 +277,1 @@\n-        Element element = i.getElement();\n+        var element = i.getElement();\n@@ -281,5 +281,3 @@\n-        } else if (element instanceof DocletElement e) {\n-            \/\/ Implementations of DocletElement do not override equals and\n-            \/\/ hashCode; putting instances of DocletElement in a map is not\n-            \/\/ incorrect, but might well be inefficient\n-            String t = titles.computeIfAbsent(element, utils::getHTMLTitle);\n+        } else if (element instanceof DocFileElement e) {\n+            var fo = e.getFileObject();\n+            var t = titles.computeIfAbsent(e, this::getFileTitle);\n@@ -289,1 +287,1 @@\n-                Path p = Path.of(e.getFileObject().toUri());\n+                Path p = Path.of(fo.toUri());\n@@ -292,4 +290,4 @@\n-            ContentBuilder b = new ContentBuilder();\n-            b.add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")));\n-            \/\/ non-program elements should be displayed using a normal font\n-            b.add(t);\n+            var b = new ContentBuilder()\n+                    .add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")))\n+                    \/\/ non-program elements should be displayed using a normal font\n+                    .add(t);\n@@ -299,1 +297,1 @@\n-            Content link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n+            var link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ExternalSpecsWriter.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.BufferedReader;\n@@ -30,0 +31,2 @@\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n@@ -44,0 +47,1 @@\n+import java.util.regex.Pattern;\n@@ -67,0 +71,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n@@ -201,0 +206,12 @@\n+    \/**\n+     * List of additional JavaScript files\n+     *\/\n+    private List<JavaScriptFile> additionalScripts;\n+\n+    \/**\n+     * Record for JavaScript file and module flag.\n+     * @param path file path\n+     * @param isModule module flag\n+     *\/\n+    public record JavaScriptFile(DocPath path, boolean isModule) {}\n+\n@@ -319,0 +336,3 @@\n+        additionalScripts = options.additionalScripts().stream()\n+                .map(this::detectJSModule)\n+                .collect(Collectors.toList());\n@@ -329,0 +349,20 @@\n+    private JavaScriptFile detectJSModule(String fileName) {\n+        DocFile file = DocFile.createFileForInput(this, fileName);\n+        boolean isModule = fileName.toLowerCase(Locale.ROOT).endsWith(\".mjs\");\n+        if (!isModule) {\n+            \/\/ Regex to detect JavaScript modules\n+            Pattern modulePattern = Pattern.compile(\"\"\"\n+                    (?:^|[;}])\\\\s*(?:\\\n+                    import\\\\s*[\"']|\\\n+                    import[\\\\s{*][^()]*from\\\\s*[\"']|\\\n+                    export(?:\\\\s+(?:let|const|function|class|var|default|async)|\\\\s*[{*]))\"\"\");\n+            try (InputStream in = file.openInputStream();\n+                 BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n+                isModule = reader.lines().anyMatch(s -> modulePattern.matcher(s).find());\n+            } catch (DocFileIOException | IOException e) {\n+                \/\/ Errors are handled when copying resources\n+            }\n+        }\n+        return new JavaScriptFile(DocPath.create(file.getName()), isModule);\n+    }\n+\n@@ -424,5 +464,2 @@\n-    public List<DocPath> getAdditionalScripts() {\n-        return options.additionalScripts().stream()\n-                .map(sf -> DocFile.createFileForInput(this, sf))\n-                .map(file -> DocPath.create(file.getName()))\n-                .collect(Collectors.toCollection(ArrayList::new));\n+    public List<JavaScriptFile> getAdditionalScripts() {\n+        return additionalScripts;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import javax.lang.model.element.ElementKind;\n@@ -78,0 +79,1 @@\n+import com.sun.source.doctree.RawTextTree;\n@@ -83,0 +85,13 @@\n+import jdk.internal.org.commonmark.Extension;\n+import jdk.internal.org.commonmark.ext.gfm.tables.TablesExtension;\n+import jdk.internal.org.commonmark.node.AbstractVisitor;\n+import jdk.internal.org.commonmark.node.Code;\n+import jdk.internal.org.commonmark.node.Heading;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.renderer.NodeRenderer;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererContext;\n+import jdk.internal.org.commonmark.renderer.html.HtmlNodeRendererFactory;\n+import jdk.internal.org.commonmark.renderer.html.HtmlRenderer;\n+import jdk.internal.org.commonmark.renderer.html.HtmlWriter;\n+\n@@ -98,0 +113,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.DocFileElement;\n@@ -208,1 +224,1 @@\n-     * @param generating whether to write a \"Geneterating ...\" message to the console\n+     * @param generating whether to write a \"Generating ...\" message to the console\n@@ -506,1 +522,4 @@\n-     * Get the window title.\n+     * Returns the window title.\n+     *\n+     * The window title is the composition of the given title and\n+     * any value set by the window-title option.\n@@ -518,0 +537,99 @@\n+    \/**\n+     * {@return the title for a doc-file element}\n+     *\n+     * For an HTML file, the title is as given in the {@code <title>} element,\n+     * as found in the preamble of the doc-comment tree.\n+     *\n+     * For a Markdown file, there is no direct representation of the page title,\n+     * and so the content of the {@code <h1>} heading is used.\n+     *\n+     * @param element the doc-file element\n+     *\/\n+    public String getFileTitle(DocFileElement element) {\n+        var fileName = element.getFileObject().getName();\n+        if (fileName.endsWith(\".html\")) {\n+            return getTextContent(utils.getPreamble(element), \"title\");\n+        } else if (fileName.endsWith(\".md\")) {\n+            var c = commentTagsToContent(element, utils.getBody(element), false);\n+            return getHeadingText(c);\n+        } else {\n+            throw new IllegalArgumentException(fileName);\n+        }\n+    }\n+\n+    \/**\n+     * {@return the plain-text content of a named HTML element in a list of content}\n+     *\n+     * @param trees the list of content\n+     * @param name the name og the HTML element\n+     *\/\n+    private String getTextContent(List<? extends DocTree> trees, String name) {\n+        var sb = new StringBuilder();\n+        var collectText = false;\n+        loop:\n+        for (DocTree dt : trees) {\n+            switch (dt.getKind()) {\n+                case START_ELEMENT -> {\n+                    var nodeStart = (StartElementTree) dt;\n+                    if (nodeStart.getName().toString().equalsIgnoreCase(name)) {\n+                        collectText = true;\n+                    }\n+                }\n+                case END_ELEMENT -> {\n+                    var nodeEnd = (EndElementTree) dt;\n+                    if (nodeEnd.getName().toString().equalsIgnoreCase(name)) {\n+                        break loop;\n+                    }\n+                }\n+                case TEXT -> {\n+                    var nodeText = (TextTree) dt;\n+                    if (collectText)\n+                        sb.append(nodeText.getBody());\n+                }\n+                default -> {\n+                }\n+                \/\/ do nothing\n+            }\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    \/**\n+     * {@return the content of the {@code <h1>} heading in the given content,\n+     * or an empty string if there is no such heading}\n+     *\n+     * The heading must be at the beginning of the content.\n+     * It may be represented in either an HTML tree with tag name {@code h1}\n+     * or in a raw HTML node.\n+     *\n+     * @param c the content\n+     *\/\n+    private String getHeadingText(Content c) {\n+        var sb = new StringBuilder();\n+        if (c instanceof ContentBuilder cb) {\n+            var contents = cb.getContents();\n+            if (!contents.isEmpty()) {\n+                var first = contents.get(0);\n+                if (first instanceof HtmlTree htmlTree && htmlTree.tagName.equals(TagName.H1)) {\n+                    for (var c2 : htmlTree.getContents()) {\n+                        if (c2 instanceof Text t) {\n+                            sb.append(t.toString());\n+                        } else if (c2 instanceof TextBuilder tb) {\n+                            sb.append(tb.toString());\n+                        }\n+                    }\n+                    return sb.toString();\n+                } else if (first instanceof RawHtml rawHtml) {\n+                    Pattern h1 = Pattern.compile(\"<h1[^>]*>(.*)<\/h1>\");\n+                    Matcher m = h1.matcher(rawHtml.toString());\n+                    if (m.lookingAt()) {\n+                        var heading = m.group(1);\n+                        var headingText = heading.replaceAll(\"<\/?[^>]+>\", \"\");\n+                        return headingText;\n+                    }\n+                }\n+            }\n+        }\n+        return \"\";\n+    }\n+\n@@ -1270,1 +1388,4 @@\n-        for (ListIterator<? extends DocTree> iterator = trees.listIterator(); iterator.hasNext();) {\n+        var useMarkdown = trees.stream().anyMatch(t -> t.getKind() == Kind.MARKDOWN);\n+        var markdownHandler = useMarkdown ? new MarkdownHandler(element) : null;\n+\n+        for (ListIterator<? extends DocTree> iterator = trees.listIterator(); iterator.hasNext(); ) {\n@@ -1273,1 +1394,1 @@\n-            boolean isLastNode  = !iterator.hasNext();\n+            boolean isLastNode = !iterator.hasNext();\n@@ -1296,2 +1417,3 @@\n-\n-            boolean allDone = docTreeVisitor.visit(tag, result);\n+            boolean allDone = useMarkdown\n+                    ? markdownHandler.handle(tag, docTreeVisitor)\n+                    : docTreeVisitor.visit(tag, result);\n@@ -1303,0 +1425,5 @@\n+\n+        if (useMarkdown) {\n+            markdownHandler.addContent(result);\n+        }\n+\n@@ -1310,0 +1437,213 @@\n+    private class MarkdownHandler {\n+        \/**\n+         * Placeholder for non-HTML nodes that are phrasing content.\n+         * The character (\\uFFFC) is the Unicode Object Replacement Character, {@code U+FFFC}.\n+         *\/\n+        private static final char PLACEHOLDER_CHAR = '\\uFFFC';\n+        \/**\n+         * Placeholder for non-HTML nodes that are not phrasing content.\n+         * The placeholder is an HTML block, according to CommonMark 4.6 rule 2,\n+         * and so will not be wrapped into with {@code <p>...<\/p>} tags.\n+         * @see <a href=\"https:\/\/spec.commonmark.org\/0.30\/#html-blocks\">HTML blocks<\/a>\n+         *\/\n+        private static final String PLACEHOLDER_BLOCK = \"<!--\\uFFFC-->\";\n+        private static final Pattern PLACEHOLDERS = Pattern.compile(PLACEHOLDER_CHAR + \"|\" + PLACEHOLDER_BLOCK);\n+\n+        private final StringBuilder markdownInput = new StringBuilder() ;\n+        private final ArrayList<Content> fffcObjects = new ArrayList<>();\n+\n+        private final Extension tablesExtn = TablesExtension.create();\n+        private final HtmlNodeRendererFactory headingRendererFactory = HeadingNodeRenderer::new;\n+\n+        private final Element element;\n+\n+        private final Parser parser = Parser.builder()\n+                .extensions(List.of(tablesExtn))\n+                .build();\n+        private final HtmlRenderer renderer = HtmlRenderer.builder()\n+                .nodeRendererFactory(headingRendererFactory)\n+                .extensions(List.of(tablesExtn))\n+                .build();\n+\n+        MarkdownHandler(Element element) {\n+            this.element = element;\n+        }\n+\n+        boolean handle(DocTree tree, InlineVisitor visitor) {\n+            boolean allDone;\n+            if (tree instanceof RawTextTree t) {\n+                if (t.getKind() != Kind.MARKDOWN) {\n+                    throw new IllegalStateException(t.getKind().toString());\n+                }\n+                String code = t.getContent();\n+                \/\/ handle the (unlikely) case of FFFC characters existing in the code\n+                int start = 0;\n+                int pos;\n+                while ((pos = code.indexOf(PLACEHOLDER_CHAR, start)) != -1) {\n+                    markdownInput.append(code.substring(start, pos));\n+                    markdownInput.append(PLACEHOLDER_CHAR);\n+                    fffcObjects.add(Text.of(String.valueOf(PLACEHOLDER_CHAR)));\n+                    start = pos + 1;\n+                }\n+                markdownInput.append(code.substring(start));\n+                allDone = false;\n+            } else {\n+                Content embeddedContent = new ContentBuilder();\n+                allDone = visitor.visit(tree, embeddedContent);\n+                fffcObjects.add(embeddedContent);\n+                if (embeddedContent.isPhrasingContent()) {\n+                    markdownInput.append(PLACEHOLDER_CHAR);\n+                } else {\n+                    if (!markdownInput.isEmpty() && markdownInput.charAt(markdownInput.length() - 1) != '\\n') {\n+                        markdownInput.append('\\n');\n+                    }\n+                    markdownInput.append(PLACEHOLDER_BLOCK);\n+                }\n+            }\n+            return allDone;\n+        }\n+\n+        void addContent(Content result) {\n+            Node document = parser.parse(markdownInput.toString());\n+            String markdownOutput = unwrap(renderer.render(document));\n+            Matcher m = PLACEHOLDERS.matcher(markdownOutput);\n+            int start = 0;\n+            int pos;\n+            int fffcObjectIndex = 0;\n+            while (m.find()) {\n+                result.add(RawHtml.markdown(markdownOutput.substring(start, m.start())));\n+                result.add(fffcObjects.get(fffcObjectIndex++));\n+                start = m.end();\n+            }\n+            if (start < markdownOutput.length()) {\n+                result.add(RawHtml.of(markdownOutput.substring(start)));\n+            }\n+        }\n+\n+        \/*\n+         * If a string contains a simple HTML paragraph, beginning with <p>\n+         * and ending with <\/p> and optional whitespace, return the content\n+         * of the paragraph between the tags.\n+         * Otherwise, return the string unmodified.\n+         *\/\n+        private static String unwrap(String s) {\n+            var prefix = \"<p>\";\n+            if (s.startsWith(prefix)) {\n+                var suffix = \"<\/p>\";\n+                var suffixPos = s.indexOf(suffix);\n+                if (suffixPos > 0) {\n+                    var endSuffixPos = suffixPos + suffix.length();\n+                    if (isBlank(s, endSuffixPos, s.length())) {\n+                        return s.substring(prefix.length(), suffixPos);\n+                    }\n+                }\n+            }\n+            return s;\n+        }\n+\n+        \/**\n+         * A renderer for Markdown {@code Heading} nodes, which represent\n+         * both ATX headings (using {@code ####}) and Setext (using underlines).\n+         * The mapping to HTML takes into account the context within the overall\n+         * generated page, and automatically includes an id, to allow the heading\n+         * to be referenced from elsewhere.\n+         *\/\n+        private class HeadingNodeRenderer extends AbstractVisitor implements NodeRenderer {\n+            private final HtmlWriter htmlWriter;\n+            private final HtmlNodeRendererContext context;\n+\n+            HeadingNodeRenderer(HtmlNodeRendererContext context) {\n+                this.htmlWriter = context.getWriter();\n+                this.context = context;\n+            }\n+\n+            @Override\n+            public Set<Class<? extends Node>> getNodeTypes() {\n+                return Set.of(Heading.class);\n+            }\n+\n+            @Override\n+            public void render(Node node) {\n+                node.accept(this);\n+            }\n+\n+            @Override\n+            public void visit(Heading heading) {\n+                var htag = getTag(heading);\n+                var id = getId(heading);\n+\n+                htmlWriter.line();\n+                htmlWriter.tag(htag, Map.of(\"id\", id.name()));\n+                visitChildren(heading);\n+                htmlWriter.tag('\/' + htag);\n+                htmlWriter.line();\n+\n+                if (includeHeadingInTableOfContents(htag)) {\n+                    StringBuilder headingContent = new StringBuilder();\n+                    new AbstractVisitor() {\n+                        @Override\n+                        public void visit(jdk.internal.org.commonmark.node.Code code) {\n+                            headingContent.append(code.getLiteral());\n+                            super.visit(code);\n+                        }\n+\n+                        @Override\n+                        public void visit(jdk.internal.org.commonmark.node.Text text) {\n+                            headingContent.append(text.getLiteral());\n+                            super.visit(text);\n+                        }\n+                    }.visit(heading);\n+                    tableOfContents.addLink(id, Text.of(headingContent));\n+                }\n+            }\n+\n+            @Override\n+            protected void visitChildren(Node parent) {\n+                Node node = parent.getFirstChild();\n+                while (node != null) {\n+                    Node next = node.getNext();\n+                    context.render(node);\n+                    node = next;\n+                }\n+            }\n+\n+            private String getTag(Heading heading) {\n+                \/\/ offset the heading level to allow for its position in the overall page\n+                var eKind = element.getKind();\n+                var offset = eKind.isField() || eKind.isExecutable() ? 3 \/\/ members\n+                        : eKind != ElementKind.OTHER ? 1   \/\/ module, package, class, interface\n+                        : 0; \/\/ doc file\n+                return \"h\" + Math.min(heading.getLevel() + offset, 6);\n+            }\n+\n+            private HtmlId getId(Heading heading) {\n+                var list = new ArrayList<String>();\n+                heading.accept(new AbstractVisitor() {\n+                    @Override\n+                    public void visit(jdk.internal.org.commonmark.node.Text text) {\n+                        list.add(text.getLiteral());\n+                    }\n+\n+                    @Override\n+                    public void visit(Code code) {\n+                        list.add(code.getLiteral());\n+                    }\n+                });\n+                return htmlIds.forHeading(String.join(\" \", list), headingIds);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Returns whether a substring of a string is blank.\n+     * Avoid creating a substring or using regular expressions.\n+     *\/\n+    private static boolean isBlank(String s, int start, int end) {\n+        for (int i = start; i < end; i++) {\n+            if (!Character.isWhitespace(s.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -1409,0 +1749,6 @@\n+        @Override\n+        public Boolean visitDocRoot(DocRootTree node, Content content) {\n+            content.add(getInlineTagOutput(element, node, context));\n+            return false;\n+        }\n+\n@@ -1530,0 +1876,2 @@\n+            } else if (docTree instanceof RawTextTree raw) {\n+                sb.append(raw.getContent().replaceAll(\"[^A-Za-z0-9]+\", \" \"));\n@@ -1571,2 +1919,1 @@\n-        \/\/ Record second-level headings for use in table of contents\n-        if (tableOfContents != null && node.getName().toString().equalsIgnoreCase(\"h2\")) {\n+        if (includeHeadingInTableOfContents(node.getName())) {\n@@ -1577,0 +1924,7 @@\n+    private boolean includeHeadingInTableOfContents(CharSequence tag) {\n+        \/\/ Record second-level headings for use in table of contents\n+        \/\/ TODO: maybe extend this to all headings up to a given level\n+        return tableOfContents != null\n+                && tag.toString().equalsIgnoreCase(\"h2\");\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":362,"deletions":8,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SinceTree;\n@@ -110,1 +110,1 @@\n-                            List<? extends DocTree> since = getSinceTree(element);\n+                            List<? extends SinceTree> since = utils.getBlockTags(element, SINCE, SinceTree.class);\n@@ -133,4 +133,4 @@\n-        List<? extends DocTree> sinceTree = getSinceTree(element);\n-        if (!sinceTree.isEmpty()) {\n-            CommentHelper ch = utils.getCommentHelper(element);\n-            return Text.of(ch.getBody(sinceTree.get(0)).toString());\n+        var sinceTrees = utils.getBlockTags(element, SINCE, SinceTree.class);\n+        if (!sinceTrees.isEmpty()) {\n+            \/\/ assumes a simple string value with no formatting\n+            return Text.of(sinceTrees.getFirst().getBody().getFirst().toString());\n@@ -155,4 +155,0 @@\n-    private List<? extends DocTree> getSinceTree(Element element) {\n-        return utils.hasDocCommentTree(element) ? utils.getBlockTags(element, SINCE) : List.of();\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NewAPIListWriter.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import javax.lang.model.element.Element;\n-\n@@ -47,1 +45,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.DocFileElement;\n@@ -63,1 +61,1 @@\n-    final Map<Element, String> titles = new WeakHashMap<>();\n+    final Map<DocFileElement, String> titles = new WeakHashMap<>();\n@@ -136,1 +134,1 @@\n-        Element element = i.getElement();\n+        var element = i.getElement();\n@@ -140,5 +138,3 @@\n-        } else if (element instanceof DocletElement e) {\n-            \/\/ Implementations of DocletElement do not override equals and\n-            \/\/ hashCode; putting instances of DocletElement in a map is not\n-            \/\/ incorrect, but might well be inefficient\n-            String t = titles.computeIfAbsent(element, utils::getHTMLTitle);\n+        } else if (element instanceof DocFileElement e) {\n+            var fo = e.getFileObject();\n+            var t = titles.computeIfAbsent(e, this::getFileTitle);\n@@ -148,1 +144,1 @@\n-                Path p = Path.of(e.getFileObject().toUri());\n+                var p = Path.of(fo.toUri());\n@@ -151,4 +147,3 @@\n-            ContentBuilder b = new ContentBuilder();\n-            b.add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")));\n-            \/\/ non-program elements should be displayed using a normal font\n-            b.add(t);\n+            var b = new ContentBuilder()\n+                    .add(HtmlTree.CODE(Text.of(i.getHolder() + \": \")))\n+                    .add(t);\n@@ -158,1 +153,1 @@\n-            Content link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n+            var link = links.createLink(pathToRoot.resolve(i.getUrl()), i.getHolder());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SystemPropertiesWriter.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,7 @@\n+    \/**\n+     * {@return the contents of this builder}\n+     *\/\n+    public List<Content> getContents() {\n+        return contents;\n+    }\n+\n@@ -103,0 +110,5 @@\n+    @Override\n+    public boolean isPhrasingContent() {\n+        return contents.stream().allMatch(Content::isPhrasingContent);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/ContentBuilder.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -71,0 +71,5 @@\n+    @Override\n+    public boolean isPhrasingContent() {\n+        return true;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Entity.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n@@ -63,1 +64,1 @@\n-    private List<DocPath> additionalScripts = List.of();\n+    private List<HtmlConfiguration.JavaScriptFile> additionalScripts = List.of();\n@@ -179,1 +180,1 @@\n-    public Head setAdditionalScripts(List<DocPath> scripts) {\n+    public Head setAdditionalScripts(List<HtmlConfiguration.JavaScriptFile> scripts) {\n@@ -349,1 +350,1 @@\n-            addScriptElement(head, DocPaths.SCRIPT_FILES.resolve(DocPaths.SCRIPT_JS));\n+            addScriptElement(head, DocPaths.SCRIPT_JS);\n@@ -359,2 +360,2 @@\n-            addScriptElement(head, DocPaths.SCRIPT_FILES.resolve(DocPaths.JQUERY_JS));\n-            addScriptElement(head, DocPaths.SCRIPT_FILES.resolve(DocPaths.JQUERY_UI_JS));\n+            addScriptElement(head, DocPaths.JQUERY_JS);\n+            addScriptElement(head, DocPaths.JQUERY_UI_JS);\n@@ -362,2 +363,2 @@\n-        for (DocPath path : additionalScripts) {\n-            addScriptElement(head, DocPaths.SCRIPT_FILES.resolve(path));\n+        for (HtmlConfiguration.JavaScriptFile javaScriptFile : additionalScripts) {\n+            addScriptElement(head, javaScriptFile);\n@@ -371,1 +372,1 @@\n-        DocPath scriptFile = pathToRoot.resolve(filePath);\n+        DocPath scriptFile = pathToRoot.resolve(DocPaths.SCRIPT_FILES).resolve(filePath);\n@@ -374,0 +375,6 @@\n+\n+    private void addScriptElement(HtmlTree head, HtmlConfiguration.JavaScriptFile script) {\n+        DocPath scriptFile = pathToRoot.resolve(DocPaths.SCRIPT_FILES).resolve(script.path());\n+        HtmlTree scriptTag = HtmlTree.SCRIPT(scriptFile.getPath());\n+        head.add(script.isModule() ? scriptTag.put(HtmlAttr.TYPE, \"module\") : scriptTag);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -236,0 +236,14 @@\n+    \/**\n+     * {@return the attributes of this node}\n+     *\/\n+    public Map<HtmlAttr, String> getAttrs() {\n+        return attrs;\n+    }\n+\n+    \/**\n+     * {@return the contents of this node}\n+     *\/\n+    public List<Content> getContents() {\n+        return content;\n+    }\n+\n@@ -1012,0 +1026,5 @@\n+    @Override\n+    public boolean isPhrasingContent() {\n+        return tagName.phrasingContent;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlTree.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -58,0 +60,10 @@\n+    \/**\n+     * Creates HTML for a fragment of Markdown output.\n+     *\n+     * @param markdownOutput the fragment\n+     * @return the HTML\n+     *\/\n+    public static RawHtml markdown(CharSequence markdownOutput) {\n+        return of(markdownOutput);\n+    }\n+\n@@ -132,0 +144,18 @@\n+    Pattern tag = Pattern.compile(\"<(?<tag>[A-Za-z0-9]+)(\\\\s|>)\");\n+    @Override\n+    public boolean isPhrasingContent() {\n+        Matcher m = tag.matcher(rawHtmlContent);\n+        while (m.find()) {\n+            try {\n+                var tn = TagName.of(m.group(\"tag\"));\n+                if (!tn.phrasingContent) {\n+                    return false;\n+                }\n+            } catch (IllegalArgumentException e) {\n+                \/\/ unknown tag\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/RawHtml.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Locale;\n+\n@@ -37,1 +39,1 @@\n-    A,\n+    A(true),\n@@ -39,1 +41,1 @@\n-    BUTTON,\n+    BUTTON(true),\n@@ -42,1 +44,1 @@\n-    BR,\n+    BR(true),\n@@ -44,1 +46,1 @@\n-    CODE,\n+    CODE(true),\n@@ -50,1 +52,1 @@\n-    EM,\n+    EM(true),\n@@ -63,4 +65,4 @@\n-    I,\n-    IMG,\n-    INPUT,\n-    LABEL,\n+    I(true),\n+    IMG(true),\n+    INPUT(true),\n+    LABEL(true),\n@@ -69,1 +71,1 @@\n-    LINK,\n+    LINK(true),\n@@ -74,1 +76,1 @@\n-    NOSCRIPT,\n+    NOSCRIPT(true),\n@@ -78,1 +80,1 @@\n-    SCRIPT,\n+    SCRIPT(true),\n@@ -80,4 +82,4 @@\n-    SMALL,\n-    SPAN,\n-    STRONG,\n-    SUB,\n+    SMALL(true),\n+    SPAN(true),\n+    STRONG(true),\n+    SUB(true),\n@@ -85,1 +87,1 @@\n-    SUP,\n+    SUP(true),\n@@ -94,1 +96,1 @@\n-    WBR;\n+    WBR(true);\n@@ -97,0 +99,5 @@\n+    public final boolean phrasingContent;\n+\n+    static TagName of(String s) {\n+        return valueOf(s.toUpperCase(Locale.ROOT));\n+    }\n@@ -99,0 +106,4 @@\n+        this(false);\n+    }\n+\n+    TagName(boolean phrasingContent) {\n@@ -100,0 +111,1 @@\n+        this.phrasingContent = phrasingContent;\n@@ -105,0 +117,1 @@\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/TagName.java","additions":31,"deletions":18,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,5 @@\n+    @Override\n+    public boolean isPhrasingContent() {\n+        return true;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Text.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-     * Constructor to construct StringContent object.\n+     * Constructor to construct an empty TextBuilder object.\n@@ -51,1 +51,1 @@\n-     * Constructor to construct StringContent object with some initial content.\n+     * Constructor to construct a TextBuilder object with some initial content.\n@@ -61,1 +61,1 @@\n-     * Adds content for the StringContent object.\n+     * Adds content for the TextBuilder object.\n@@ -77,0 +77,5 @@\n+    @Override\n+    public boolean isPhrasingContent() {\n+        return true;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/TextBuilder.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-    margin:5px 10px 10px 0;\n+    margin:5px 10px 10px 15px;\n@@ -377,1 +377,5 @@\n-    font-family:var(--block-font-family)\n+    font-family:var(--block-font-family);\n+}\n+dl.notes > dd > ul, dl.notes > dd > ol {\n+    margin-bottom: 1em;\n+    margin-top: 1em;\n@@ -550,1 +554,1 @@\n-ul.tag-list, ul.tag-list-long {\n+dl.notes > dd > ul.tag-list, dl.notes > dd > ul.tag-list-long {\n@@ -552,0 +556,1 @@\n+    margin: 0;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-            case TEXT, START_ELEMENT -> {\n+            case TEXT, MARKDOWN, START_ELEMENT -> {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import com.sun.source.doctree.TextTree;\n@@ -47,0 +46,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n@@ -48,0 +48,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n@@ -50,0 +51,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.TextBuilder;\n@@ -125,1 +127,1 @@\n-                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label);\n+                textOf(label).replaceAll(\"\\\\s+\", \" \"), label);\n@@ -128,5 +130,26 @@\n-    private String textOf(List<? extends DocTree> trees) {\n-        return trees.stream()\n-                .filter(dt -> dt instanceof TextTree)\n-                .map(dt -> ((TextTree) dt).getBody().trim())\n-                .collect(Collectors.joining(\" \"));\n+    \/\/ this is here, for now, but might be a useful addition elsewhere,\n+    \/\/ perhaps as a method on Content\n+    private String textOf(Content c) {\n+        return appendText(new StringBuilder(), c).toString();\n+    }\n+\n+    private StringBuilder appendText(StringBuilder sb, Content c) {\n+        if (c instanceof ContentBuilder cb) {\n+            appendText(sb, cb.getContents());\n+        } else if (c instanceof HtmlTree ht) {\n+            appendText(sb, ht.getContents());\n+        } else if (c instanceof RawHtml rh) {\n+            sb.append(rh.toString().replaceAll(\"<[^>]*>\", \"\"));\n+        } else if (c instanceof TextBuilder tb) {\n+            sb.append(tb.toString());\n+        } else if (c instanceof Text t) {\n+            sb.append(t.toString());\n+        } else if (c instanceof Entity e) {\n+            sb.append(e.toString());\n+        }\n+        return sb;\n+    }\n+\n+    private StringBuilder appendText(StringBuilder sb, List<? extends Content> contents) {\n+        contents.forEach(c -> appendText(sb, c));\n+        return sb;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,1 +570,1 @@\n-    private DocLint doclint;\n+    protected DocLint doclint;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -629,1 +629,1 @@\n-                uri, JavaFileObject.Kind.SOURCE) {\n+                uri, JavaFileObject.Kind.HTML) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.Objects;\n+\n@@ -46,1 +48,1 @@\n-     * Creates a pseudo-element that wraps a {@code doc-files} HTML file.\n+     * Creates a pseudo-element that wraps a {@code doc-files} documentation file.\n@@ -92,0 +94,13 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        DocFileElement that = (DocFileElement) o;\n+        return element.equals(that.element) && fo.equals(that.fo);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(element, fo);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/DocFileElement.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import com.sun.source.doctree.RawTextTree;\n@@ -431,0 +432,6 @@\n+            @Override\n+            public List<? extends DocTree> visitRawText(RawTextTree node, Void p) {\n+                \/\/ not ideal, but better than returning an empty list\n+                return asList(node.getContent());\n+            }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SinceTree;\n+\n@@ -57,2 +58,2 @@\n-        List<? extends DocTree> since = utils.getBlockTags(e, SINCE);\n-        if (since.isEmpty()) {\n+        var sinceTrees = utils.getBlockTags(e, SINCE, SinceTree.class);\n+        if (sinceTrees.isEmpty()) {\n@@ -61,2 +62,4 @@\n-        CommentHelper ch = utils.getCommentHelper(e);\n-        return since.stream().anyMatch(tree -> releases.contains(ch.getBody(tree).toString()));\n+\n+        \/\/ assumes a simple string value with no formatting\n+        return sinceTrees.stream()\n+                .anyMatch(tree -> releases.contains(tree.getBody().getFirst().toString()));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/NewAPIBuilder.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,0 @@\n-import com.sun.source.doctree.EndElementTree;\n@@ -109,2 +108,0 @@\n-import com.sun.source.doctree.StartElementTree;\n-import com.sun.source.doctree.TextTree;\n@@ -1334,32 +1331,0 @@\n-    public String getHTMLTitle(Element element) {\n-        List<? extends DocTree> preamble = getPreamble(element);\n-        StringBuilder sb = new StringBuilder();\n-        boolean titleFound = false;\n-        loop:\n-        for (DocTree dt : preamble) {\n-            switch (dt.getKind()) {\n-                case START_ELEMENT -> {\n-                    StartElementTree nodeStart = (StartElementTree) dt;\n-                    if (Utils.toLowerCase(nodeStart.getName().toString()).equals(\"title\")) {\n-                        titleFound = true;\n-                    }\n-                }\n-                case END_ELEMENT -> {\n-                    EndElementTree nodeEnd = (EndElementTree) dt;\n-                    if (Utils.toLowerCase(nodeEnd.getName().toString()).equals(\"title\")) {\n-                        break loop;\n-                    }\n-                }\n-                case TEXT -> {\n-                    TextTree nodeText = (TextTree) dt;\n-                    if (titleFound)\n-                        sb.append(nodeText.getBody());\n-                }\n-                default -> {\n-                }\n-                \/\/ do nothing\n-            }\n-        }\n-        return sb.toString().trim();\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+import com.sun.source.doctree.RawTextTree;\n@@ -314,0 +315,6 @@\n+    @Override\n+    public Void scan(DocTreePath path, Void unused) {\n+        \/\/ interposition point for all scans\n+        return super.scan(path, unused);\n+    }\n+\n@@ -1009,2 +1016,5 @@\n-            DocCommentTree dct = getCurrentPath().getDocComment();\n-            if (dct.getFirstSentence().isEmpty() || tree != dct.getFirstSentence().get(0)) {\n+            var dct = getCurrentPath().getDocComment();\n+            var first = dct.getFirstSentence().stream()\n+                    .filter(t -> !isBlank(t))\n+                    .findFirst();\n+            if (first.isEmpty() || first.get() != tree) {\n@@ -1024,0 +1034,8 @@\n+    private static boolean isBlank(DocTree t) {\n+        return switch (t.getKind()) {\n+            case TEXT -> ((TextTree) t).getBody().isBlank();\n+            case MARKDOWN -> ((RawTextTree) t).getContent().isBlank();\n+            default -> false;\n+        };\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-\n@@ -31,1 +30,0 @@\n-import java.util.Collections;\n@@ -48,1 +46,0 @@\n-import javax.lang.model.element.Modifier;\n@@ -64,1 +61,0 @@\n-import com.sun.tools.javac.util.StringUtils;\n@@ -138,0 +134,1 @@\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Env.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import com.sun.tools.javac.util.ModuleHelper;\n@@ -564,0 +565,11 @@\n+        \/\/ Allow doclets to access internal API if the appropriate\n+        \/\/ option is given on the command line.\n+        \/\/ A better solution would be to modify the javadoc API to\n+        \/\/ permit an instance of an appropriately configured instance\n+        \/\/ of a doclet to be specified instead of the name of the\n+        \/\/ doclet class and optional doclet path.\n+        \/\/ See https:\/\/bugs.openjdk.org\/browse\/JDK-8263219\n+        if (options.compilerOptions().isSet(\"accessInternalAPI\")) {\n+            ModuleHelper.addExports(ModuleHelper.class.getModule(), doclet.getClass().getModule());\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/Start.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,0 +405,7 @@\n+            new ToolOption(\"--disable-line-doc-comments\", EXTENDED) {\n+                @Override\n+                public void process() throws InvalidValueException {\n+                    processCompilerOption(Option.DISABLE_LINE_DOC_COMMENTS, primaryName);\n+                }\n+            },\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -273,0 +273,4 @@\n+main.opt.disable.line.doc.comments.desc=\\\n+    Disable support for documentation comments with lines\\n\\\n+    beginning '\/\/\/'\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n- *\n@@ -60,1 +59,0 @@\n-    requires java.xml;\n@@ -64,0 +62,2 @@\n+\n+    requires jdk.internal.md;\n","filename":"src\/jdk.javadoc\/share\/classes\/module-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-Within a source file, you may use suppress any warnings generated by\n-these options by using\n+Within a source file, you may suppress any warnings generated by these\n+options by using\n@@ -157,0 +157,2 @@\n+\\f[V]--disable-line-doc-comments\\f[R]\n+.IP \\[bu] 2\n@@ -185,11 +187,5 @@\n-Computes the first sentence with \\f[V]BreakIterator\\f[R].\n-The first sentence is copied to the package, class, or member summary\n-and to the alphabetic index.\n-The \\f[V]BreakIterator\\f[R] class is used to determine the end of a\n-sentence for all languages except for English.\n-.RS\n-.IP \\[bu] 2\n-English default sentence-break algorithm --- Stops at a period followed\n-by a space or an HTML block tag, such as \\f[V]<P>\\f[R].\n-.IP \\[bu] 2\n-Breakiterator sentence-break algorithm --- Stops at a period, question\n+Computes the first sentence of the description in a documentation\n+comment using an instance of \\f[V]java.text.BreakIterator\\f[R] to detect\n+\\f[I]sentence breaks\\f[R].\n+The rules that are used depend on the \\f[B]current locale\\f[R]: for\n+example, for English, a sentence break occurs after a period, question\n@@ -198,1 +194,1 @@\n-This is meant to handle most abbreviations (such as \\[dq]The serial no.\n+(This is meant to handle most abbreviations, such as \\[dq]The serial no.\n@@ -200,5 +196,26 @@\n-Smith\\[dq]).\n-The \\f[V]-breakiterator\\f[R] option doesn\\[aq]t stop at HTML tags or\n-sentences that begin with numbers or symbols.\n-The algorithm stops at the last period in \\f[V]..\/filename\\f[R], even\n-when embedded in an HTML tag.\n+Smith\\[dq].)\n+.RS\n+.PP\n+The option is enabled by default if the language of the current locale\n+is not English.\n+If the language of the current locale is English, and the\n+\\f[V]-breakiterator\\f[R] option is not given, a simple default algorithm\n+is used, which just looks for a period followed by a space.\n+.PP\n+In a traditional \\f[V]\/**...*\/\\f[R] comment, the search for the end of\n+the first sentence is terminated by an HTML block tag, such as\n+\\f[V]<p>\\f[R], \\f[V]<pre>\\f[R], or the tag for a heading.\n+.PP\n+In a Markdown \\f[V]\/\/\/\\f[R] comment, the search for the end of the first\n+sentence skips over any characters enclosed in code spans and links, and\n+is terminated by the end of the initial block, as indicated by a blank\n+line or the beginning of the next block, such as a list, thematic break,\n+or an HTML block.\n+.PP\n+The first sentence of the description in a documentation comment is used\n+in summary tables, index pages, and other situations where a short\n+summary is required.\n+For more explicit control in any individual documentation comment,\n+enclose the contents of the first sentence in a\n+\\f[V]{\\[at]summary ...}\\f[R] tag, or when applicable, in a\n+\\[ga]{\\[at]return ...} tag.\n@@ -508,2 +525,1 @@\n-Includes the text of any \\f[V]author\\f[R] tags in the generated\n-documentation.\n+Includes the \\f[V]\\[at]author\\f[R] text in the generated docs.\n@@ -923,0 +939,5 @@\n+\\f[V]--no-fonts\\f[R]\n+Prevents inclusion of font files in the generated documentation.\n+This can be useful if the documentation uses a custom stylesheet which\n+does not use the default fonts.\n+.TP\n@@ -968,2 +989,2 @@\n-Omits from the generated documentation the \\f[V]Since\\f[R] sections\n-derived from any \\f[V]since\\f[R] tags.\n+Omits from the generated documents the \\f[V]Since\\f[R] sections\n+associated with the \\f[V]\\[at]since\\f[R] tags.\n@@ -992,3 +1013,3 @@\n-Specifies that the \\f[V]javadoc\\f[R] tool should retrieve the text for\n-the overview documentation from the source file specified by\n-\\f[V]filename\\f[R] and place it on the Overview page\n+Specifies that the \\f[V]javadoc\\f[R] tool should retrieve the content\n+for the overview documentation from the file specified by\n+\\f[I]filename\\f[R] and place it on the Overview page\n@@ -996,2 +1017,2 @@\n-A relative path specified with the file name is relative to the current\n-working directory.\n+If the \\f[I]filename\\f[R] is a relative path, it is evaluated relative\n+to the current working directory.\n@@ -1000,16 +1021,10 @@\n-While you can use any name you want for the \\f[I]filename\\f[R] value and\n-place it anywhere you want, it is typical to name it\n-\\f[V]overview.html\\f[R] and place it in the source tree at the directory\n-that contains the topmost package directories.\n-In this location, no path is needed when documenting packages, because\n-the \\f[V]-sourcepath\\f[R] option points to this file.\n-.IP \\[bu] 2\n-\\f[B]Linux and macOS:\\f[R] For example, if the source tree for the\n-\\f[V]java.lang\\f[R] package is \\f[V]src\/classes\/java\/lang\/\\f[R], then\n-you could place the overview file at\n-\\f[V]src\/classes\/overview.html\\f[R].\n-.IP \\[bu] 2\n-\\f[B]Windows:\\f[R] For example, if the source tree for the\n-\\f[V]java.lang\\f[R] package is\n-\\f[V]src\\[rs]classes\\[rs]java\\[rs]lang\\[rs]\\f[R], then you could place\n-the overview file at \\f[V]src\\[rs]classes\\[rs]overview.html\\f[R]\n+The file may be an HTML file, with a filename ending in \\f[V].html\\f[R],\n+or a Markdown file, with a filename ending in \\f[V].md\\f[R].\n+.PD 0\n+.P\n+.PD\n+If the file is an HTML file, the content for the overview documentation\n+is taken from the \\f[V]<main>\\f[R] element in the file, if one is\n+present, or from the \\f[V]<body>\\f[R] element is there is no\n+\\f[V]<main>\\f[R] element.\n+If the file is a Markdown file, the entire content of the file is used.\n@@ -1017,2 +1032,0 @@\n-The overview page is created only when you pass two or more package\n-names to the \\f[V]javadoc\\f[R] tool.\n@@ -1020,0 +1033,4 @@\n+.PP\n+\\f[I]Note:\\f[R] older versions of the \\f[V]javadoc\\f[R] tool assumed\n+that any use of this option was for an HTML file, and allowed any\n+extension for the \\f[I]filename\\f[R].\n@@ -1199,2 +1216,1 @@\n-Includes the text of any \\f[V]version\\f[R] tags in the generated\n-documentation.\n+Includes the version text in the generated docs.\n@@ -1202,2 +1218,2 @@\n-Note: To find out what version of the \\f[V]javadoc\\f[R] tool you are\n-using, use the \\f[V]--version\\f[R] option (with two hyphens).\n+To find out what version of the \\f[V]javadoc\\f[R] tool you are using,\n+use the \\f[V]--version\\f[R] option (with two hyphens).\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.1","additions":66,"deletions":50,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -1,804 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.regex.Pattern;\n-\n-import com.sun.tools.classfile.Dependency.Filter;\n-import com.sun.tools.classfile.Dependency.Finder;\n-import com.sun.tools.classfile.Dependency.Location;\n-import com.sun.tools.classfile.Type.ArrayType;\n-import com.sun.tools.classfile.Type.ClassSigType;\n-import com.sun.tools.classfile.Type.ClassType;\n-import com.sun.tools.classfile.Type.MethodType;\n-import com.sun.tools.classfile.Type.SimpleType;\n-import com.sun.tools.classfile.Type.TypeParamType;\n-import com.sun.tools.classfile.Type.WildcardType;\n-\n-import static com.sun.tools.classfile.ConstantPool.*;\n-\n-\/**\n- * A framework for determining {@link Dependency dependencies} between class files.\n- *\n- * A {@link Dependency.Finder finder} is used to identify the dependencies of\n- * individual classes. Some finders may return subtypes of {@code Dependency} to\n- * further characterize the type of dependency, such as a dependency on a\n- * method within a class.\n- *\n- * A {@link Dependency.Filter filter} may be used to restrict the set of\n- * dependencies found by a finder.\n- *\n- * Dependencies that are found may be passed to a {@link Dependencies.Recorder\n- * recorder} so that the dependencies can be stored in a custom data structure.\n- *\/\n-public class Dependencies {\n-    \/**\n-     * Thrown when a class file cannot be found.\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    public static class ClassFileNotFoundException extends Exception {\n-        private static final long serialVersionUID = 3632265927794475048L;\n-\n-        public ClassFileNotFoundException(String className) {\n-            super(className);\n-            this.className = className;\n-        }\n-\n-        public ClassFileNotFoundException(String className, Throwable cause) {\n-            this(className);\n-            initCause(cause);\n-        }\n-\n-        public final String className;\n-    }\n-\n-    \/**\n-     * Thrown when an exception is found processing a class file.\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    public static class ClassFileError extends Error {\n-        private static final long serialVersionUID = 4111110813961313203L;\n-\n-        public ClassFileError(Throwable cause) {\n-            initCause(cause);\n-        }\n-    }\n-\n-    \/**\n-     * Service provider interface to locate and read class files.\n-     *\/\n-    public interface ClassFileReader {\n-        \/**\n-         * Get the ClassFile object for a specified class.\n-         * @param className the name of the class to be returned.\n-         * @return the ClassFile for the given class\n-         * @throws Dependencies.ClassFileNotFoundException if the classfile cannot be\n-         *   found\n-         *\/\n-        public ClassFile getClassFile(String className)\n-                throws ClassFileNotFoundException;\n-    }\n-\n-    \/**\n-     * Service provide interface to handle results.\n-     *\/\n-    public interface Recorder {\n-        \/**\n-         * Record a dependency that has been found.\n-         * @param d\n-         *\/\n-        public void addDependency(Dependency d);\n-    }\n-\n-    \/**\n-     * Get the  default finder used to locate the dependencies for a class.\n-     * @return the default finder\n-     *\/\n-    public static Finder getDefaultFinder() {\n-        return new APIDependencyFinder(AccessFlags.ACC_PRIVATE);\n-    }\n-\n-    \/**\n-     * Get a finder used to locate the API dependencies for a class.\n-     * These include the superclass, superinterfaces, and classes referenced in\n-     * the declarations of fields and methods.  The fields and methods that\n-     * are checked can be limited according to a specified access.\n-     * The access parameter must be one of {@link AccessFlags#ACC_PUBLIC ACC_PUBLIC},\n-     * {@link AccessFlags#ACC_PRIVATE ACC_PRIVATE},\n-     * {@link AccessFlags#ACC_PROTECTED ACC_PROTECTED}, or 0 for\n-     * package private access. Members with greater than or equal accessibility\n-     * to that specified will be searched for dependencies.\n-     * @param access the access of members to be checked\n-     * @return an API finder\n-     *\/\n-    public static Finder getAPIFinder(int access) {\n-        return new APIDependencyFinder(access);\n-    }\n-\n-    \/**\n-     * Get a finder to do class dependency analysis.\n-     *\n-     * @return a Class dependency finder\n-     *\/\n-    public static Finder getClassDependencyFinder() {\n-        return new ClassDependencyFinder();\n-    }\n-\n-    \/**\n-     * Get the finder used to locate the dependencies for a class.\n-     * @return the finder\n-     *\/\n-    public Finder getFinder() {\n-        if (finder == null)\n-            finder = getDefaultFinder();\n-        return finder;\n-    }\n-\n-    \/**\n-     * Set the finder used to locate the dependencies for a class.\n-     * @param f the finder\n-     *\/\n-    public void setFinder(Finder f) {\n-        finder = Objects.requireNonNull(f);\n-    }\n-\n-    \/**\n-     * Get the default filter used to determine included when searching\n-     * the transitive closure of all the dependencies.\n-     * Unless overridden, the default filter accepts all dependencies.\n-     * @return the default filter.\n-     *\/\n-    public static Filter getDefaultFilter() {\n-        return DefaultFilter.instance();\n-    }\n-\n-    \/**\n-     * Get a filter which uses a regular expression on the target's class name\n-     * to determine if a dependency is of interest.\n-     * @param pattern the pattern used to match the target's class name\n-     * @return a filter for matching the target class name with a regular expression\n-     *\/\n-    public static Filter getRegexFilter(Pattern pattern) {\n-        return new TargetRegexFilter(pattern);\n-    }\n-\n-    \/**\n-     * Get a filter which checks the package of a target's class name\n-     * to determine if a dependency is of interest. The filter checks if the\n-     * package of the target's class matches any of a set of given package\n-     * names. The match may optionally match subpackages of the given names as well.\n-     * @param packageNames the package names used to match the target's class name\n-     * @param matchSubpackages whether or not to match subpackages as well\n-     * @return a filter for checking the target package name against a list of package names\n-     *\/\n-    public static Filter getPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n-        return new TargetPackageFilter(packageNames, matchSubpackages);\n-    }\n-\n-    \/**\n-     * Get the filter used to determine the dependencies included when searching\n-     * the transitive closure of all the dependencies.\n-     * Unless overridden, the default filter accepts all dependencies.\n-     * @return the filter\n-     *\/\n-    public Filter getFilter() {\n-        if (filter == null)\n-            filter = getDefaultFilter();\n-        return filter;\n-    }\n-\n-    \/**\n-     * Set the filter used to determine the dependencies included when searching\n-     * the transitive closure of all the dependencies.\n-     * @param f the filter\n-     *\/\n-    public void setFilter(Filter f) {\n-        filter = Objects.requireNonNull(f);\n-    }\n-\n-    \/**\n-     * Find the dependencies of a class, using the current\n-     * {@link Dependencies#getFinder finder} and\n-     * {@link Dependencies#getFilter filter}.\n-     * The search may optionally include the transitive closure of all the\n-     * filtered dependencies, by also searching in the classes named in those\n-     * dependencies.\n-     * @param classFinder a finder to locate class files\n-     * @param rootClassNames the names of the root classes from which to begin\n-     *      searching\n-     * @param transitiveClosure whether or not to also search those classes\n-     *      named in any filtered dependencies that are found.\n-     * @return the set of dependencies that were found\n-     * @throws ClassFileNotFoundException if a required class file cannot be found\n-     * @throws ClassFileError if an error occurs while processing a class file,\n-     *      such as an error in the internal class file structure.\n-     *\/\n-    public Set<Dependency> findAllDependencies(\n-            ClassFileReader classFinder, Set<String> rootClassNames,\n-            boolean transitiveClosure)\n-            throws ClassFileNotFoundException {\n-        final Set<Dependency> results = new HashSet<>();\n-        Recorder r = results::add;\n-        findAllDependencies(classFinder, rootClassNames, transitiveClosure, r);\n-        return results;\n-    }\n-\n-    \/**\n-     * Find the dependencies of a class, using the current\n-     * {@link Dependencies#getFinder finder} and\n-     * {@link Dependencies#getFilter filter}.\n-     * The search may optionally include the transitive closure of all the\n-     * filtered dependencies, by also searching in the classes named in those\n-     * dependencies.\n-     * @param classFinder a finder to locate class files\n-     * @param rootClassNames the names of the root classes from which to begin\n-     *      searching\n-     * @param transitiveClosure whether or not to also search those classes\n-     *      named in any filtered dependencies that are found.\n-     * @param recorder a recorder for handling the results\n-     * @throws ClassFileNotFoundException if a required class file cannot be found\n-     * @throws ClassFileError if an error occurs while processing a class file,\n-     *      such as an error in the internal class file structure.\n-     *\/\n-    public void findAllDependencies(\n-            ClassFileReader classFinder, Set<String> rootClassNames,\n-            boolean transitiveClosure, Recorder recorder)\n-            throws ClassFileNotFoundException {\n-        Set<String> doneClasses = new HashSet<>();\n-\n-        getFinder();  \/\/ ensure initialized\n-        getFilter();  \/\/ ensure initialized\n-\n-        \/\/ Work queue of names of classfiles to be searched.\n-        \/\/ Entries will be unique, and for classes that do not yet have\n-        \/\/ dependencies in the results map.\n-        Deque<String> deque = new LinkedList<>(rootClassNames);\n-\n-        String className;\n-        while ((className = deque.poll()) != null) {\n-            assert (!doneClasses.contains(className));\n-            doneClasses.add(className);\n-\n-            ClassFile cf = classFinder.getClassFile(className);\n-\n-            \/\/ The following code just applies the filter to the dependencies\n-            \/\/ followed for the transitive closure.\n-            for (Dependency d: finder.findDependencies(cf)) {\n-                recorder.addDependency(d);\n-                if (transitiveClosure && filter.accepts(d)) {\n-                    String cn = d.getTarget().getClassName();\n-                    if (!doneClasses.contains(cn))\n-                        deque.add(cn);\n-                }\n-            }\n-        }\n-    }\n-\n-    private Filter filter;\n-    private Finder finder;\n-\n-    \/**\n-     * A location identifying a class.\n-     *\/\n-    static class SimpleLocation implements Location {\n-        public SimpleLocation(String name) {\n-            this.name = name;\n-            this.className = name.replace('\/', '.');\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        public String getClassName() {\n-            return className;\n-        }\n-\n-        public String getPackageName() {\n-            int i = name.lastIndexOf('\/');\n-            return (i > 0) ? name.substring(0, i).replace('\/', '.') : \"\";\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (this == other)\n-                return true;\n-            if (!(other instanceof SimpleLocation))\n-                return false;\n-            return (name.equals(((SimpleLocation) other).name));\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return name.hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-\n-        private String name;\n-        private String className;\n-    }\n-\n-    \/**\n-     * A dependency of one class on another.\n-     *\/\n-    static class SimpleDependency implements Dependency {\n-        public SimpleDependency(Location origin, Location target) {\n-            this.origin = origin;\n-            this.target = target;\n-        }\n-\n-        public Location getOrigin() {\n-            return origin;\n-        }\n-\n-        public Location getTarget() {\n-            return target;\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (this == other)\n-                return true;\n-            if (!(other instanceof SimpleDependency))\n-                return false;\n-            SimpleDependency o = (SimpleDependency) other;\n-            return (origin.equals(o.origin) && target.equals(o.target));\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return origin.hashCode() * 31 + target.hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return origin + \":\" + target;\n-        }\n-\n-        private Location origin;\n-        private Location target;\n-    }\n-\n-\n-    \/**\n-     * This class accepts all dependencies.\n-     *\/\n-    static class DefaultFilter implements Filter {\n-        private static DefaultFilter instance;\n-\n-        static DefaultFilter instance() {\n-            if (instance == null)\n-                instance = new DefaultFilter();\n-            return instance;\n-        }\n-\n-        public boolean accepts(Dependency dependency) {\n-            return true;\n-        }\n-    }\n-\n-    \/**\n-     * This class accepts those dependencies whose target's class name matches a\n-     * regular expression.\n-     *\/\n-    static class TargetRegexFilter implements Filter {\n-        TargetRegexFilter(Pattern pattern) {\n-            this.pattern = pattern;\n-        }\n-\n-        public boolean accepts(Dependency dependency) {\n-            return pattern.matcher(dependency.getTarget().getClassName()).matches();\n-        }\n-\n-        private final Pattern pattern;\n-    }\n-\n-    \/**\n-     * This class accepts those dependencies whose class name is in a given\n-     * package.\n-     *\/\n-    static class TargetPackageFilter implements Filter {\n-        TargetPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n-            for (String pn: packageNames) {\n-                if (pn.length() == 0) \/\/ implies null check as well\n-                    throw new IllegalArgumentException();\n-            }\n-            this.packageNames = packageNames;\n-            this.matchSubpackages = matchSubpackages;\n-        }\n-\n-        public boolean accepts(Dependency dependency) {\n-            String pn = dependency.getTarget().getPackageName();\n-            if (packageNames.contains(pn))\n-                return true;\n-\n-            if (matchSubpackages) {\n-                for (String n: packageNames) {\n-                    if (pn.startsWith(n + \".\"))\n-                        return true;\n-                }\n-            }\n-\n-            return false;\n-        }\n-\n-        private final Set<String> packageNames;\n-        private final boolean matchSubpackages;\n-    }\n-\n-    \/**\n-     * This class identifies class names directly or indirectly in the constant pool.\n-     *\/\n-    static class ClassDependencyFinder extends BasicDependencyFinder {\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile) {\n-            Visitor v = new Visitor(classfile);\n-            for (CPInfo cpInfo: classfile.constant_pool.entries()) {\n-                v.scan(cpInfo);\n-            }\n-            try {\n-                v.addClass(classfile.super_class);\n-                v.addClasses(classfile.interfaces);\n-                v.scan(classfile.attributes);\n-\n-                for (Field f : classfile.fields) {\n-                    v.scan(f.descriptor, f.attributes);\n-                }\n-                for (Method m : classfile.methods) {\n-                    v.scan(m.descriptor, m.attributes);\n-                    Exceptions_attribute e =\n-                        (Exceptions_attribute)m.attributes.get(Attribute.Exceptions);\n-                    if (e != null) {\n-                        v.addClasses(e.exception_index_table);\n-                    }\n-                }\n-            } catch (ConstantPoolException e) {\n-                throw new ClassFileError(e);\n-            }\n-\n-            return v.deps;\n-        }\n-    }\n-\n-    \/**\n-     * This class identifies class names in the signatures of classes, fields,\n-     * and methods in a class.\n-     *\/\n-    static class APIDependencyFinder extends BasicDependencyFinder {\n-        APIDependencyFinder(int access) {\n-            switch (access) {\n-                case AccessFlags.ACC_PUBLIC:\n-                case AccessFlags.ACC_PROTECTED:\n-                case AccessFlags.ACC_PRIVATE:\n-                case 0:\n-                    showAccess = access;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"invalid access 0x\"\n-                            + Integer.toHexString(access));\n-            }\n-        }\n-\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile) {\n-            try {\n-                Visitor v = new Visitor(classfile);\n-                v.addClass(classfile.super_class);\n-                v.addClasses(classfile.interfaces);\n-                \/\/ inner classes?\n-                for (Field f : classfile.fields) {\n-                    if (checkAccess(f.access_flags))\n-                        v.scan(f.descriptor, f.attributes);\n-                }\n-                for (Method m : classfile.methods) {\n-                    if (checkAccess(m.access_flags)) {\n-                        v.scan(m.descriptor, m.attributes);\n-                        Exceptions_attribute e =\n-                                (Exceptions_attribute) m.attributes.get(Attribute.Exceptions);\n-                        if (e != null)\n-                            v.addClasses(e.exception_index_table);\n-                    }\n-                }\n-                return v.deps;\n-            } catch (ConstantPoolException e) {\n-                throw new ClassFileError(e);\n-            }\n-        }\n-\n-        boolean checkAccess(AccessFlags flags) {\n-            \/\/ code copied from javap.Options.checkAccess\n-            boolean isPublic = flags.is(AccessFlags.ACC_PUBLIC);\n-            boolean isProtected = flags.is(AccessFlags.ACC_PROTECTED);\n-            boolean isPrivate = flags.is(AccessFlags.ACC_PRIVATE);\n-            boolean isPackage = !(isPublic || isProtected || isPrivate);\n-\n-            if ((showAccess == AccessFlags.ACC_PUBLIC) && (isProtected || isPrivate || isPackage))\n-                return false;\n-            else if ((showAccess == AccessFlags.ACC_PROTECTED) && (isPrivate || isPackage))\n-                return false;\n-            else if ((showAccess == 0) && (isPrivate))\n-                return false;\n-            else\n-                return true;\n-        }\n-\n-        private int showAccess;\n-    }\n-\n-    abstract static class BasicDependencyFinder implements Finder {\n-        private Map<String,Location> locations = new ConcurrentHashMap<>();\n-\n-        Location getLocation(String className) {\n-            return locations.computeIfAbsent(className, SimpleLocation::new);\n-        }\n-\n-        class Visitor implements ConstantPool.Visitor<Void,Void>, Type.Visitor<Void, Void> {\n-            private ConstantPool constant_pool;\n-            private Location origin;\n-            Set<Dependency> deps;\n-\n-            Visitor(ClassFile classFile) {\n-                try {\n-                    constant_pool = classFile.constant_pool;\n-                    origin = getLocation(classFile.getName());\n-                    deps = new HashSet<>();\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            void scan(Descriptor d, Attributes attrs) {\n-                try {\n-                    scan(new Signature(d.index).getType(constant_pool));\n-                    scan(attrs);\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            void scan(CPInfo cpInfo) {\n-                cpInfo.accept(this, null);\n-            }\n-\n-            void scan(Type t) {\n-                t.accept(this, null);\n-            }\n-\n-            void scan(Attributes attrs) {\n-                try {\n-                    Signature_attribute sa = (Signature_attribute)attrs.get(Attribute.Signature);\n-                    if (sa != null)\n-                        scan(sa.getParsedSignature().getType(constant_pool));\n-\n-                    scan((RuntimeVisibleAnnotations_attribute)\n-                            attrs.get(Attribute.RuntimeVisibleAnnotations));\n-                    scan((RuntimeVisibleParameterAnnotations_attribute)\n-                            attrs.get(Attribute.RuntimeVisibleParameterAnnotations));\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            private void scan(RuntimeAnnotations_attribute attr) throws ConstantPoolException {\n-                if (attr == null) {\n-                    return;\n-                }\n-                for (int i = 0; i < attr.annotations.length; i++) {\n-                    int index = attr.annotations[i].type_index;\n-                    scan(new Signature(index).getType(constant_pool));\n-                }\n-            }\n-\n-            private void scan(RuntimeParameterAnnotations_attribute attr) throws ConstantPoolException {\n-                if (attr == null) {\n-                    return;\n-                }\n-                for (int param = 0; param < attr.parameter_annotations.length; param++) {\n-                    for (int i = 0; i < attr.parameter_annotations[param].length; i++) {\n-                        int index = attr.parameter_annotations[param][i].type_index;\n-                        scan(new Signature(index).getType(constant_pool));\n-                    }\n-                }\n-            }\n-\n-            void addClass(int index) throws ConstantPoolException {\n-                if (index != 0) {\n-                    String name = constant_pool.getClassInfo(index).getBaseName();\n-                    if (name != null)\n-                        addDependency(name);\n-                }\n-            }\n-\n-            void addClasses(int[] indices) throws ConstantPoolException {\n-                for (int i: indices)\n-                    addClass(i);\n-            }\n-\n-            private void addDependency(String name) {\n-                deps.add(new SimpleDependency(origin, getLocation(name)));\n-            }\n-\n-            \/\/ ConstantPool.Visitor methods\n-\n-            public Void visitClass(CONSTANT_Class_info info, Void p) {\n-                try {\n-                    if (info.getName().startsWith(\"[\"))\n-                        new Signature(info.name_index).getType(constant_pool).accept(this, null);\n-                    else\n-                        addDependency(info.getBaseName());\n-                    return null;\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            public Void visitDouble(CONSTANT_Double_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitFieldref(CONSTANT_Fieldref_info info, Void p) {\n-                return visitRef(info, p);\n-            }\n-\n-            public Void visitFloat(CONSTANT_Float_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitInteger(CONSTANT_Integer_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, Void p) {\n-                return visitRef(info, p);\n-            }\n-\n-            public Void visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, Void p) {\n-                return null;\n-            }\n-\n-            @Override\n-            public Void visitDynamicConstant(CONSTANT_Dynamic_info info, Void aVoid) {\n-                return null;\n-            }\n-\n-            public Void visitLong(CONSTANT_Long_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitMethodHandle(CONSTANT_MethodHandle_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitMethodType(CONSTANT_MethodType_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitMethodref(CONSTANT_Methodref_info info, Void p) {\n-                return visitRef(info, p);\n-            }\n-\n-            public Void visitModule(CONSTANT_Module_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitNameAndType(CONSTANT_NameAndType_info info, Void p) {\n-                try {\n-                    new Signature(info.type_index).getType(constant_pool).accept(this, null);\n-                    return null;\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            public Void visitPackage(CONSTANT_Package_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitString(CONSTANT_String_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitUtf8(CONSTANT_Utf8_info info, Void p) {\n-                return null;\n-            }\n-\n-            private Void visitRef(CPRefInfo info, Void p) {\n-                try {\n-                    visitClass(info.getClassInfo(), p);\n-                    return null;\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            \/\/ Type.Visitor methods\n-\n-            private void findDependencies(Type t) {\n-                if (t != null)\n-                    t.accept(this, null);\n-            }\n-\n-            private void findDependencies(List<? extends Type> ts) {\n-                if (ts != null) {\n-                    for (Type t: ts)\n-                        t.accept(this, null);\n-                }\n-            }\n-\n-            public Void visitSimpleType(SimpleType type, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitArrayType(ArrayType type, Void p) {\n-                findDependencies(type.elemType);\n-                return null;\n-            }\n-\n-            public Void visitMethodType(MethodType type, Void p) {\n-                findDependencies(type.paramTypes);\n-                findDependencies(type.returnType);\n-                findDependencies(type.throwsTypes);\n-                findDependencies(type.typeParamTypes);\n-                return null;\n-            }\n-\n-            public Void visitClassSigType(ClassSigType type, Void p) {\n-                findDependencies(type.superclassType);\n-                findDependencies(type.superinterfaceTypes);\n-                return null;\n-            }\n-\n-            public Void visitClassType(ClassType type, Void p) {\n-                findDependencies(type.outerType);\n-                addDependency(type.getBinaryName());\n-                findDependencies(type.typeArgs);\n-                return null;\n-            }\n-\n-            public Void visitTypeParamType(TypeParamType type, Void p) {\n-                findDependencies(type.classBound);\n-                findDependencies(type.interfaceBounds);\n-                return null;\n-            }\n-\n-            public Void visitWildcardType(WildcardType type, Void p) {\n-                findDependencies(type.boundType);\n-                return null;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Dependencies.java","additions":0,"deletions":804,"binary":false,"changes":804,"status":"deleted"},{"patch":"@@ -371,10 +371,14 @@\n-            switch (ta.wildcardIndicator()) {\n-                case DEFAULT -> print(sb, ta.boundType().get());\n-                case UNBOUNDED -> sb.append('?');\n-                case EXTENDS -> {\n-                    sb.append(\"? extends \");\n-                    print(sb, ta.boundType().get());\n-                }\n-                case SUPER -> {\n-                    sb.append(\"? super \");\n-                    print(sb, ta.boundType().get());\n+            switch (ta) {\n+                case Signature.TypeArg.Unbounded _ -> sb.append('?');\n+                case Signature.TypeArg.Bounded bta -> {\n+                    switch (bta.wildcardIndicator()) {\n+                        case NONE -> print(sb, bta.boundType());\n+                        case EXTENDS -> {\n+                            sb.append(\"? extends \");\n+                            print(sb, bta.boundType());\n+                        }\n+                        case SUPER -> {\n+                            sb.append(\"? super \");\n+                            print(sb, bta.boundType());\n+                        }\n+                    }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.constantpool.*;\n@@ -33,5 +35,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-\n-import static com.sun.tools.classfile.ConstantPool.CPInfo;\n-\n@@ -48,4 +45,4 @@\n-    final List<ConstantPool.CONSTANT_Class_info> classes = new ArrayList<>();\n-    final List<ConstantPool.CONSTANT_Fieldref_info> fieldRefs = new ArrayList<>();\n-    final List<ConstantPool.CONSTANT_Methodref_info> methodRefs = new ArrayList<>();\n-    final List<ConstantPool.CONSTANT_InterfaceMethodref_info> intfMethodRefs = new ArrayList<>();\n+    final List<ClassEntry> classes = new ArrayList<>();\n+    final List<FieldRefEntry> fieldRefs = new ArrayList<>();\n+    final List<MethodRefEntry> methodRefs = new ArrayList<>();\n+    final List<InterfaceMethodRefEntry> intfMethodRefs = new ArrayList<>();\n@@ -53,1 +50,1 @@\n-    public static CPEntries loadFrom(ClassFile cf) {\n+    public static CPEntries loadFrom(ClassModel cf) {\n@@ -55,2 +52,8 @@\n-        for (CPInfo cpi : cf.constant_pool.entries()) {\n-            cpi.accept(new CPSelector(), entries);\n+        for (PoolEntry cpi : cf.constantPool()) {\n+            switch (cpi) {\n+                case ClassEntry ce -> entries.classes.add(ce);\n+                case MethodRefEntry mref -> entries.methodRefs.add(mref);\n+                case InterfaceMethodRefEntry imref -> entries.intfMethodRefs.add(imref);\n+                case FieldRefEntry fref -> entries.fieldRefs.add(fref);\n+                default -> {}\n+            }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/CPEntries.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.jdeprscan.scan;\n-\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Dynamic_info;\n-\n-\/**\n- * A visitor that selects constant pool entries by type and adds\n- * them to the given CPEntries object.\n- *\/\n-class CPSelector implements ConstantPool.Visitor<Void,CPEntries> {\n-    @Override\n-    public Void visitClass(ConstantPool.CONSTANT_Class_info info, CPEntries p) {\n-        p.classes.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitDouble(ConstantPool.CONSTANT_Double_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFieldref(ConstantPool.CONSTANT_Fieldref_info info, CPEntries p) {\n-        p.fieldRefs.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFloat(ConstantPool.CONSTANT_Float_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitInteger(ConstantPool.CONSTANT_Integer_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitInterfaceMethodref(ConstantPool.CONSTANT_InterfaceMethodref_info info, CPEntries p) {\n-        p.intfMethodRefs.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitInvokeDynamic(ConstantPool.CONSTANT_InvokeDynamic_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    public Void visitDynamicConstant(CONSTANT_Dynamic_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitLong(ConstantPool.CONSTANT_Long_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitMethodref(ConstantPool.CONSTANT_Methodref_info info, CPEntries p) {\n-        p.methodRefs.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitMethodHandle(ConstantPool.CONSTANT_MethodHandle_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitMethodType(ConstantPool.CONSTANT_MethodType_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModule(ConstantPool.CONSTANT_Module_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitNameAndType(ConstantPool.CONSTANT_NameAndType_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitPackage(ConstantPool.CONSTANT_Package_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitString(ConstantPool.CONSTANT_String_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitUtf8(ConstantPool.CONSTANT_Utf8_info info, CPEntries p) {\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/CPSelector.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-\n@@ -32,0 +29,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n@@ -95,1 +94,1 @@\n-    public ClassFile find(String className) {\n+    public ClassModel find(String className) {\n@@ -97,1 +96,1 @@\n-            ClassFile cf = pe.find(className);\n+            ClassModel cf = pe.find(className);\n@@ -116,1 +115,1 @@\n-        ClassFile find(String className);\n+        ClassModel find(String className);\n@@ -130,1 +129,1 @@\n-        public ClassFile find(String className) {\n+        public ClassModel find(String className) {\n@@ -136,2 +135,2 @@\n-                return ClassFile.read(jarFile.getInputStream(entry));\n-            } catch (IOException | ConstantPoolException ex) {\n+                return ClassFile.of().parse(jarFile.getInputStream(entry).readAllBytes());\n+            } catch (IOException | IllegalArgumentException ex) {\n@@ -157,1 +156,1 @@\n-        public ClassFile find(String className) {\n+        public ClassModel find(String className) {\n@@ -160,1 +159,1 @@\n-                return ClassFile.read(classFileName);\n+                return ClassFile.of().parse(classFileName);\n@@ -163,1 +162,1 @@\n-            } catch (IOException | ConstantPoolException ex) {\n+            } catch (IOException | IllegalArgumentException ex) {\n@@ -184,1 +183,1 @@\n-        public ClassFile find(String className) {\n+        public ClassModel find(String className) {\n@@ -197,1 +196,1 @@\n-                    return ClassFile.read(opath.get());\n+                    return ClassFile.of().parse(opath.get());\n@@ -203,1 +202,1 @@\n-            } catch (IOException | ConstantPoolException ex) {\n+            } catch (IOException | IllegalArgumentException ex) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/ClassFinder.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.jdeprscan.scan;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-\/**\n- * Represents a method's signature, that is, its parameter types\n- * and its return type.\n- *\/\n-public class MethodSig {\n-    final List<String> parameters;\n-    final String returnType;\n-\n-    \/**\n-     * Parses the method descriptor and returns a MethodSig instance.\n-     *\n-     * @param desc the descriptor to parse\n-     * @return the new MethodSig instance\n-     *\/\n-    public static MethodSig fromDesc(String desc) {\n-        return parse(desc, 0, desc.length());\n-    }\n-\n-    \/**\n-     * Returns this method's return type.\n-     *\n-     * @return the return type\n-     *\/\n-    public String getReturnType() {\n-        return returnType;\n-    }\n-\n-    \/**\n-     * Returns a list of parameters of this method.\n-     *\n-     * @return the parameter list\n-     *\/\n-    public List<String> getParameters() {\n-        return parameters;\n-    }\n-\n-    \/**\n-     * Returns a string describing this method.\n-     *\n-     * @return the string description\n-     *\/\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"parameters\");\n-        if (parameters.isEmpty()) {\n-            sb.append(\" none\");\n-        } else {\n-            int i = 0;\n-            for (String p : parameters) {\n-                sb.append(String.format(\" %d=%s\", i++, p));\n-            }\n-        }\n-        sb.append(String.format(\" return %s\", returnType));\n-        return sb.toString();\n-    }\n-\n-    private MethodSig(List<String> parameters, String returnType) {\n-        this.parameters = Collections.unmodifiableList(parameters);\n-        this.returnType = returnType;\n-    }\n-\n-    private static IllegalArgumentException ex(String desc, int pos) {\n-        return new IllegalArgumentException(String.format(\n-            \"illegal descriptor \\\"%s\\\" at position %d\", desc, pos));\n-    }\n-\n-    private static MethodSig parse(String desc, int start, int end)\n-            throws IllegalArgumentException {\n-        int p = start;\n-        int dims = 0;\n-        boolean inReturnType = false;\n-        String returnType = null;\n-        List<String> parameters = new ArrayList<>();\n-\n-        while (p < end) {\n-            String type;\n-            char ch;\n-            switch (ch = desc.charAt(p)) {\n-                case '(':\n-                    p++;\n-                    continue;\n-\n-                case ')':\n-                    p++;\n-                    inReturnType = true;\n-                    continue;\n-\n-                case '[':\n-                    p++;\n-                    dims++;\n-                    continue;\n-\n-                case 'B': \/\/ byte\n-                case 'C': \/\/ char\n-                case 'D': \/\/ double\n-                case 'F': \/\/ float\n-                case 'I': \/\/ int\n-                case 'J': \/\/ long\n-                case 'S': \/\/ short\n-                case 'Z': \/\/ boolean\n-                case 'V': \/\/ void\n-                    type = Character.toString(ch);\n-                    p++;\n-                    break;\n-\n-                case 'L':\n-                    int sep = desc.indexOf(';', p);\n-                    if (sep == -1 || sep >= end)\n-                        throw ex(desc, p);\n-                    type = desc.substring(p, ++sep);\n-                    p = sep;\n-                    break;\n-\n-                default:\n-                    throw ex(desc, p);\n-            }\n-\n-            StringBuilder sb = new StringBuilder();\n-            for ( ; dims > 0; dims-- )\n-                sb.append(\"[\");\n-            sb.append(type);\n-            if (inReturnType) {\n-                returnType = sb.toString();\n-            } else {\n-                parameters.add(sb.toString());\n-            }\n-        }\n-\n-        if (returnType == null) {\n-            throw ex(desc, end);\n-        }\n-\n-        return new MethodSig(parameters, returnType);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/MethodSig.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,7 @@\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -44,1 +51,0 @@\n-import java.util.stream.Collectors;\n@@ -47,1 +53,0 @@\n-import com.sun.tools.classfile.*;\n@@ -52,3 +57,0 @@\n-import static com.sun.tools.classfile.AccessFlags.*;\n-import static com.sun.tools.classfile.ConstantPool.*;\n-\n@@ -88,1 +90,1 @@\n-        \/\/ manager; and b) the symbol file includes .sig files, not class files, which ClassFile\n+        \/\/ manager; and b) the symbol file includes .sig files, not class files, which ClassModel\n@@ -167,3 +169,3 @@\n-    String typeKind(ClassFile cf) {\n-        AccessFlags flags = cf.access_flags;\n-        if (flags.is(ACC_ENUM)) {\n+    String typeKind(ClassModel cf) {\n+        AccessFlags flags = cf.flags();\n+        if (flags.has(AccessFlag.ENUM)) {\n@@ -171,1 +173,1 @@\n-        } else if (flags.is(ACC_ANNOTATION)) {\n+        } else if (flags.has(AccessFlag.ANNOTATION)) {\n@@ -173,1 +175,1 @@\n-        } else if (flags.is(ACC_INTERFACE)) {\n+        } else if (flags.has(AccessFlag.INTERFACE)) {\n@@ -184,3 +186,2 @@\n-    void printType(String key, ClassFile cf, String cname, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, dep(r)));\n+    void printType(String key, ClassModel cf, String cname, boolean r) {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, dep(r)));\n@@ -189,3 +190,3 @@\n-    void printMethod(String key, ClassFile cf, String cname, String mname, String rtype,\n-                     boolean r) throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, mname, rtype, dep(r)));\n+    void printMethod(String key, ClassModel cf, String cname, String mname, String rtype,\n+                     boolean r)  {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, mname, rtype, dep(r)));\n@@ -194,3 +195,3 @@\n-    void printField(String key, ClassFile cf, String cname, String fname,\n-                     boolean r) throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, fname, dep(r)));\n+    void printField(String key, ClassModel cf, String cname, String fname,\n+                     boolean r)  {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, fname, dep(r)));\n@@ -199,3 +200,3 @@\n-    void printFieldType(String key, ClassFile cf, String cname, String fname, String type,\n-                     boolean r) throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, fname, type, dep(r)));\n+    void printFieldType(String key, ClassModel cf, String cname, String fname, String type,\n+                     boolean r)  {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, fname, type, dep(r)));\n@@ -204,3 +205,3 @@\n-    void printHasField(ClassFile cf, String fname, String type, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.hasfield\", typeKind(cf), cf.getName(), fname, type, dep(r)));\n+    void printHasField(ClassModel cf, String fname, String type, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.hasfield\", typeKind(cf), cf.thisClass().asInternalName(), fname, type, dep(r)));\n@@ -209,3 +210,3 @@\n-    void printHasMethodParmType(ClassFile cf, String mname, String parmType, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.methodparmtype\", typeKind(cf), cf.getName(), mname, parmType, dep(r)));\n+    void printHasMethodParmType(ClassModel cf, String mname, String parmType, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.methodparmtype\", typeKind(cf), cf.thisClass().asInternalName(), mname, parmType, dep(r)));\n@@ -214,3 +215,3 @@\n-    void printHasMethodRetType(ClassFile cf, String mname, String retType, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.methodrettype\", typeKind(cf), cf.getName(), mname, retType, dep(r)));\n+    void printHasMethodRetType(ClassModel cf, String mname, String retType, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.methodrettype\", typeKind(cf), cf.thisClass().asInternalName(), mname, retType, dep(r)));\n@@ -219,3 +220,3 @@\n-    void printHasOverriddenMethod(ClassFile cf, String overridden, String mname, String desc, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.methodoverride\", typeKind(cf), cf.getName(), overridden,\n+    void printHasOverriddenMethod(ClassModel cf, String overridden, String mname, String desc, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.methodoverride\", typeKind(cf), cf.thisClass().asInternalName(), overridden,\n@@ -256,1 +257,1 @@\n-     * @param targetClass the ClassFile of the class to search\n+     * @param targetClass the ClassModel of the class to search\n@@ -261,1 +262,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -263,1 +264,1 @@\n-    boolean isMemberPresent(ClassFile targetClass,\n+    boolean isMemberPresent(ClassModel targetClass,\n@@ -267,1 +268,1 @@\n-            throws ConstantPoolException {\n+             {\n@@ -269,3 +270,3 @@\n-            for (Method m : targetClass.methods) {\n-                String mname = m.getName(targetClass.constant_pool);\n-                String mdesc = targetClass.constant_pool.getUTF8Value(m.descriptor.index);\n+            for (var m : targetClass.methods()) {\n+                String mname = m.methodName().stringValue();\n+                String mdesc = m.methodType().stringValue();\n@@ -277,2 +278,2 @@\n-            for (Field f : targetClass.fields) {\n-                String fname = f.getName(targetClass.constant_pool);\n+            for (var f : targetClass.fields()) {\n+                String fname = f.fieldName().stringValue();\n@@ -291,2 +292,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -294,5 +295,3 @@\n-    void addInterfaces(Deque<String> intfs, ClassFile cf)\n-            throws ConstantPoolException {\n-        int count = cf.interfaces.length;\n-        for (int i = 0; i < count; i++) {\n-            intfs.addLast(cf.getInterfaceName(i));\n+    void addInterfaces(Deque<String> intfs, ClassModel cf) {\n+        for (var itf : cf.interfaces()) {\n+            intfs.addLast(itf.asInternalName());\n@@ -310,1 +309,1 @@\n-     * @param cf the ClassFile of this class\n+     * @param cf the ClassModel of this class\n@@ -318,1 +317,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -321,1 +320,1 @@\n-            ClassFile cf, String startClassName, String findName, String findDesc,\n+            ClassModel cf, String startClassName, String findName, String findDesc,\n@@ -323,2 +322,2 @@\n-            throws ConstantPoolException {\n-        ClassFile startClass;\n+             {\n+        ClassModel startClass;\n@@ -326,1 +325,1 @@\n-        if (cf.getName().equals(startClassName)) {\n+        if (cf.thisClass().asInternalName().equals(startClassName)) {\n@@ -339,1 +338,1 @@\n-        ClassFile curClass = startClass;\n+        ClassModel curClass = startClass;\n@@ -347,1 +346,2 @@\n-            if (curClass.super_class == 0) { \/\/ reached Object\n+            var superclass = curClass.superclass();\n+            if (superclass.isEmpty()) { \/\/ reached Object\n@@ -352,1 +352,1 @@\n-            String superName = curClass.getSuperclassName();\n+            String superName = superclass.get().asInternalName();\n@@ -394,1 +394,1 @@\n-            String foundClassName = curClass.getName();\n+            String foundClassName = curClass.thisClass().asInternalName();\n@@ -402,2 +402,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -405,2 +405,6 @@\n-    void checkSuper(ClassFile cf) throws ConstantPoolException {\n-        String sname = cf.getSuperclassName();\n+    void checkSuper(ClassModel cf)  {\n+        var superclass = cf.superclass();\n+        if (superclass.isEmpty()) {\n+            return;\n+        }\n+        String sname = superclass.get().asInternalName();\n@@ -416,2 +420,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -419,4 +423,3 @@\n-    void checkInterfaces(ClassFile cf) throws ConstantPoolException {\n-        int ni = cf.interfaces.length;\n-        for (int i = 0; i < ni; i++) {\n-            String iname = cf.getInterfaceName(i);\n+    void checkInterfaces(ClassModel cf)  {\n+        for (var itf : cf.interfaces()) {\n+            String iname = itf.asInternalName();\n@@ -433,1 +436,1 @@\n-     * @param cf the ClassFile of this class\n+     * @param cf the ClassModel of this class\n@@ -435,1 +438,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -437,3 +440,3 @@\n-    void checkClasses(ClassFile cf, CPEntries entries) throws ConstantPoolException {\n-        for (ConstantPool.CONSTANT_Class_info ci : entries.classes) {\n-            String name = nameFromRefType(ci.getName());\n+    void checkClasses(ClassModel cf, CPEntries entries)  {\n+        for (var ci : entries.classes) {\n+            String name = nameFromRefType(ci.asInternalName());\n@@ -452,1 +455,1 @@\n-     * @param cf the ClassFile of this class\n+     * @param cf the ClassModel of this class\n@@ -456,1 +459,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -458,1 +461,1 @@\n-    void checkMethodRef(ClassFile cf,\n+    void checkMethodRef(ClassModel cf,\n@@ -460,4 +463,4 @@\n-                        CONSTANT_NameAndType_info nti,\n-                        String msgKey) throws ConstantPoolException {\n-        String name = nti.getName();\n-        String type = nti.getType();\n+                        NameAndTypeEntry nti,\n+                        String msgKey)  {\n+        String name = nti.name().stringValue();\n+        String type = nti.type().stringValue();\n@@ -477,2 +480,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -480,6 +483,6 @@\n-    void checkFieldRef(ClassFile cf,\n-                       ConstantPool.CONSTANT_Fieldref_info fri) throws ConstantPoolException {\n-        String clname = nameFromRefType(fri.getClassName());\n-        CONSTANT_NameAndType_info nti = fri.getNameAndTypeInfo();\n-        String name = nti.getName();\n-        String type = nti.getType();\n+    void checkFieldRef(ClassModel cf,\n+                       FieldRefEntry fri)  {\n+        String clname = nameFromRefType(fri.owner().asInternalName());\n+        var nti = fri.nameAndType();\n+        String name = nti.name().stringValue();\n+        String type = nti.type().stringValue();\n@@ -499,2 +502,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -502,3 +505,3 @@\n-    void checkFields(ClassFile cf) throws ConstantPoolException {\n-        for (Field f : cf.fields) {\n-            String type = nameFromDescType(cf.constant_pool.getUTF8Value(f.descriptor.index));\n+    void checkFields(ClassModel cf)  {\n+        for (var f : cf.fields()) {\n+            String type = nameFromDescType(f.fieldType().stringValue());\n@@ -508,1 +511,1 @@\n-                    printHasField(cf, f.getName(cf.constant_pool), type, dd.isForRemoval());\n+                    printHasField(cf, f.fieldName().stringValue(), type, dd.isForRemoval());\n@@ -517,2 +520,2 @@\n-     * @param cf the ClassFile object of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel object of this class\n+     * @ if a constant pool entry cannot be found\n@@ -520,5 +523,5 @@\n-    void checkMethods(ClassFile cf) throws ConstantPoolException {\n-        for (Method m : cf.methods) {\n-            String mname = m.getName(cf.constant_pool);\n-            String desc = cf.constant_pool.getUTF8Value(m.descriptor.index);\n-            MethodSig sig = MethodSig.fromDesc(desc);\n+    void checkMethods(ClassModel cf)  {\n+        for (var m : cf.methods()) {\n+            String mname = m.methodName().stringValue();\n+            var desc = m.methodType().stringValue();\n+            MethodTypeDesc sig = m.methodTypeSymbol();\n@@ -527,1 +530,2 @@\n-            for (String parm : sig.getParameters()) {\n+            for (var parmDesc : sig.parameterArray()) {\n+                var parm = parmDesc.descriptorString();\n@@ -537,1 +541,1 @@\n-            String ret = nameFromDescType(sig.getReturnType());\n+            String ret = nameFromDescType(sig.returnType().descriptorString());\n@@ -546,1 +550,1 @@\n-            String overridden = resolveMember(cf, cf.getName(), mname, desc, true, false);\n+            String overridden = resolveMember(cf, cf.thisClass().asInternalName(), mname, desc, true, false);\n@@ -559,2 +563,2 @@\n-     * @param cf the ClassFile of the class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of the class\n+     * @ if a constant pool entry cannot be found\n@@ -562,1 +566,1 @@\n-    void processClass(ClassFile cf) throws ConstantPoolException {\n+    void processClass(ClassModel cf)  {\n@@ -564,1 +568,1 @@\n-            out.println(Messages.get(\"scan.process.class\", cf.getName()));\n+            out.println(Messages.get(\"scan.process.class\", cf.thisClass().asInternalName()));\n@@ -573,3 +577,3 @@\n-        for (ConstantPool.CONSTANT_Methodref_info mri : entries.methodRefs) {\n-            String clname = mri.getClassName();\n-            CONSTANT_NameAndType_info nti = mri.getNameAndTypeInfo();\n+        for (var mri : entries.methodRefs) {\n+            String clname = mri.owner().asInternalName();\n+            var nti = mri.nameAndType();\n@@ -579,3 +583,3 @@\n-        for (ConstantPool.CONSTANT_InterfaceMethodref_info imri : entries.intfMethodRefs) {\n-            String clname = imri.getClassName();\n-            CONSTANT_NameAndType_info nti = imri.getNameAndTypeInfo();\n+        for (var imri : entries.intfMethodRefs) {\n+            String clname = imri.owner().asInternalName();\n+            var nti = imri.nameAndType();\n@@ -585,1 +589,1 @@\n-        for (ConstantPool.CONSTANT_Fieldref_info fri : entries.fieldRefs) {\n+        for (var fri : entries.fieldRefs) {\n@@ -610,1 +614,2 @@\n-                    processClass(ClassFile.read(jf.getInputStream(entry)));\n+                    processClass(ClassFile.of().parse(jf\n+                            .getInputStream(entry).readAllBytes()));\n@@ -616,1 +621,1 @@\n-        } catch (IOException | ConstantPoolException ex) {\n+        } catch (IOException | IllegalArgumentException ex) {\n@@ -643,1 +648,1 @@\n-                processClass(ClassFile.read(p));\n+                processClass(ClassFile.of().parse(p));\n@@ -646,1 +651,1 @@\n-        } catch (IOException | ConstantPoolException ex) {\n+        } catch (IOException | IllegalArgumentException ex) {\n@@ -660,1 +665,1 @@\n-            ClassFile cf = finder.find(className);\n+            ClassModel cf = finder.find(className);\n@@ -668,1 +673,1 @@\n-        } catch (ConstantPoolException ex) {\n+        } catch (IllegalArgumentException ex) {\n@@ -683,1 +688,1 @@\n-            ClassFile cf = ClassFile.read(path);\n+            ClassModel cf = ClassFile.of().parse(path);\n@@ -688,1 +693,1 @@\n-        } catch (IOException | ConstantPoolException ex) {\n+        } catch (IOException | IllegalArgumentException ex) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/Scan.java","additions":132,"deletions":127,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Analyzer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Archive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,1 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Dependencies.ClassFileError;\n+import com.sun.tools.jdeps.Dependencies.ClassFileError;\n@@ -39,0 +36,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n@@ -45,1 +44,0 @@\n-import java.util.Enumeration;\n@@ -57,1 +55,1 @@\n- * ClassFileReader reads ClassFile(s) of a given path that can be\n+ * ClassFileReader reads ClassModel(s) of a given path that can be\n@@ -120,1 +118,1 @@\n-     * Returns the ClassFile matching the given binary name\n+     * Returns the ClassModel matching the given binary name\n@@ -123,1 +121,1 @@\n-    public ClassFile getClassFile(String name) throws IOException {\n+    public ClassModel getClassFile(String name) throws IOException {\n@@ -140,1 +138,1 @@\n-    public Iterable<ClassFile> getClassFiles() throws IOException {\n+    public Iterable<ClassModel> getClassFiles() throws IOException {\n@@ -144,2 +142,1 @@\n-    protected ClassFile readClassFile(Path p) throws IOException {\n-        InputStream is = null;\n+    protected ClassModel readClassFile(Path p) throws IOException {\n@@ -147,3 +144,2 @@\n-            is = Files.newInputStream(p);\n-            return ClassFile.read(is);\n-        } catch (ConstantPoolException e) {\n+            return ClassFile.of().parse(p);\n+        } catch (IllegalArgumentException e) {\n@@ -151,4 +147,0 @@\n-        } finally {\n-            if (is != null) {\n-                is.close();\n-            }\n@@ -160,3 +152,3 @@\n-            ClassFile cf = ClassFile.read(path);\n-            String name = cf.access_flags.is(AccessFlags.ACC_MODULE)\n-                ? \"module-info\" : cf.getName();\n+            ClassModel cf = ClassFile.of().parse(path);\n+            String name = cf.isModuleInfo()\n+                ? \"module-info\" : cf.thisClass().asInternalName();\n@@ -164,1 +156,1 @@\n-        } catch (ConstantPoolException|IOException e) {\n+        } catch (IllegalArgumentException|IOException e) {\n@@ -178,1 +170,1 @@\n-    class FileIterator implements Iterator<ClassFile> {\n+    class FileIterator implements Iterator<ClassModel> {\n@@ -187,1 +179,1 @@\n-        public ClassFile next() {\n+        public ClassModel next() {\n@@ -192,1 +184,1 @@\n-                ClassFile cf = readClassFile(path);\n+                ClassModel cf = readClassFile(path);\n@@ -231,1 +223,1 @@\n-        public ClassFile getClassFile(String name) throws IOException {\n+        public ClassModel getClassFile(String name) throws IOException {\n@@ -252,2 +244,2 @@\n-        public Iterable<ClassFile> getClassFiles() throws IOException {\n-            final Iterator<ClassFile> iter = new DirectoryIterator();\n+        public Iterable<ClassModel> getClassFiles() throws IOException {\n+            final Iterator<ClassModel> iter = new DirectoryIterator();\n@@ -257,1 +249,1 @@\n-        class DirectoryIterator implements Iterator<ClassFile> {\n+        class DirectoryIterator implements Iterator<ClassModel> {\n@@ -274,1 +266,1 @@\n-            public ClassFile next() {\n+            public ClassModel next() {\n@@ -335,1 +327,1 @@\n-        public ClassFile getClassFile(String name) throws IOException {\n+        public ClassModel getClassFile(String name) throws IOException {\n@@ -356,1 +348,1 @@\n-        protected ClassFile readClassFile(JarFile jarfile, JarEntry e) throws IOException {\n+        protected ClassModel readClassFile(JarFile jarfile, JarEntry e) throws IOException {\n@@ -358,1 +350,1 @@\n-                ClassFile cf = ClassFile.read(is);\n+                ClassModel cf = ClassFile.of().parse(is.readAllBytes());\n@@ -360,1 +352,1 @@\n-                if (jarfile.isMultiRelease() && !cf.getName().equals(\"module-info\")) {\n+                if (jarfile.isMultiRelease() && !cf.isModuleInfo()) {\n@@ -364,1 +356,1 @@\n-            } catch (ConstantPoolException ex) {\n+            } catch (IllegalArgumentException ex) {\n@@ -369,2 +361,2 @@\n-        public Iterable<ClassFile> getClassFiles() throws IOException {\n-            final Iterator<ClassFile> iter = new JarFileIterator(this, jarfile);\n+        public Iterable<ClassModel> getClassFiles() throws IOException {\n+            final Iterator<ClassModel> iter = new JarFileIterator(this, jarfile);\n@@ -375,1 +367,1 @@\n-    class JarFileIterator implements Iterator<ClassFile> {\n+    class JarFileIterator implements Iterator<ClassModel> {\n@@ -380,1 +372,1 @@\n-        protected ClassFile cf;\n+        protected ClassModel cf;\n@@ -416,1 +408,1 @@\n-        public ClassFile next() {\n+        public ClassModel next() {\n@@ -420,1 +412,1 @@\n-            ClassFile classFile = cf;\n+            ClassModel classFile = cf;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ClassFileReader.java","additions":34,"deletions":42,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,709 @@\n+\/*\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.jdeps;\n+\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.regex.Pattern;\n+\n+import com.sun.tools.jdeps.Dependency.Filter;\n+import com.sun.tools.jdeps.Dependency.Finder;\n+import com.sun.tools.jdeps.Dependency.Location;\n+\n+\/**\n+ * A framework for determining {@link Dependency dependencies} between class files.\n+ *\n+ * A {@link Dependency.Finder finder} is used to identify the dependencies of\n+ * individual classes. Some finders may return subtypes of {@code Dependency} to\n+ * further characterize the type of dependency, such as a dependency on a\n+ * method within a class.\n+ *\n+ * A {@link Dependency.Filter filter} may be used to restrict the set of\n+ * dependencies found by a finder.\n+ *\n+ * Dependencies that are found may be passed to a {@link Dependencies.Recorder\n+ * recorder} so that the dependencies can be stored in a custom data structure.\n+ *\/\n+public class Dependencies {\n+    \/**\n+     * Thrown when a class file cannot be found.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    public static class ClassFileNotFoundException extends Exception {\n+        private static final long serialVersionUID = 3632265927794475048L;\n+\n+        public ClassFileNotFoundException(String className) {\n+            super(className);\n+            this.className = className;\n+        }\n+\n+        public ClassFileNotFoundException(String className, Throwable cause) {\n+            this(className);\n+            initCause(cause);\n+        }\n+\n+        public final String className;\n+    }\n+\n+    \/**\n+     * Thrown when an exception is found processing a class file.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    public static class ClassFileError extends Error {\n+        private static final long serialVersionUID = 4111110813961313203L;\n+\n+        public ClassFileError(Throwable cause) {\n+            initCause(cause);\n+        }\n+    }\n+\n+    \/**\n+     * Service provider interface to locate and read class files.\n+     *\/\n+    public interface ClassFileReader {\n+        \/**\n+         * Get the ClassFile object for a specified class.\n+         * @param className the name of the class to be returned.\n+         * @return the ClassFile for the given class\n+         * @throws Dependencies.ClassFileNotFoundException if the classfile cannot be\n+         *   found\n+         *\/\n+        public ClassModel getClassFile(String className)\n+                throws ClassFileNotFoundException;\n+    }\n+\n+    \/**\n+     * Service provide interface to handle results.\n+     *\/\n+    public interface Recorder {\n+        \/**\n+         * Record a dependency that has been found.\n+         * @param d\n+         *\/\n+        public void addDependency(Dependency d);\n+    }\n+\n+    \/**\n+     * Get the  default finder used to locate the dependencies for a class.\n+     * @return the default finder\n+     *\/\n+    public static Finder getDefaultFinder() {\n+        return new APIDependencyFinder(ClassFile.ACC_PRIVATE);\n+    }\n+\n+    \/**\n+     * Get a finder used to locate the API dependencies for a class.\n+     * These include the superclass, superinterfaces, and classes referenced in\n+     * the declarations of fields and methods.  The fields and methods that\n+     * are checked can be limited according to a specified access.\n+     * The access parameter must be one of {@link ClassFile#ACC_PUBLIC ACC_PUBLIC},\n+     * {@link ClassFile#ACC_PRIVATE ACC_PRIVATE},\n+     * {@link ClassFile#ACC_PROTECTED ACC_PROTECTED}, or 0 for\n+     * package private access. Members with greater than or equal accessibility\n+     * to that specified will be searched for dependencies.\n+     * @param access the access of members to be checked\n+     * @return an API finder\n+     *\/\n+    public static Finder getAPIFinder(int access) {\n+        return new APIDependencyFinder(access);\n+    }\n+\n+    \/**\n+     * Get a finder to do class dependency analysis.\n+     *\n+     * @return a Class dependency finder\n+     *\/\n+    public static Finder getClassDependencyFinder() {\n+        return new ClassDependencyFinder();\n+    }\n+\n+    \/**\n+     * Get the finder used to locate the dependencies for a class.\n+     * @return the finder\n+     *\/\n+    public Finder getFinder() {\n+        if (finder == null)\n+            finder = getDefaultFinder();\n+        return finder;\n+    }\n+\n+    \/**\n+     * Set the finder used to locate the dependencies for a class.\n+     * @param f the finder\n+     *\/\n+    public void setFinder(Finder f) {\n+        finder = Objects.requireNonNull(f);\n+    }\n+\n+    \/**\n+     * Get the default filter used to determine included when searching\n+     * the transitive closure of all the dependencies.\n+     * Unless overridden, the default filter accepts all dependencies.\n+     * @return the default filter.\n+     *\/\n+    public static Filter getDefaultFilter() {\n+        return DefaultFilter.instance();\n+    }\n+\n+    \/**\n+     * Get a filter which uses a regular expression on the target's class name\n+     * to determine if a dependency is of interest.\n+     * @param pattern the pattern used to match the target's class name\n+     * @return a filter for matching the target class name with a regular expression\n+     *\/\n+    public static Filter getRegexFilter(Pattern pattern) {\n+        return new TargetRegexFilter(pattern);\n+    }\n+\n+    \/**\n+     * Get a filter which checks the package of a target's class name\n+     * to determine if a dependency is of interest. The filter checks if the\n+     * package of the target's class matches any of a set of given package\n+     * names. The match may optionally match subpackages of the given names as well.\n+     * @param packageNames the package names used to match the target's class name\n+     * @param matchSubpackages whether or not to match subpackages as well\n+     * @return a filter for checking the target package name against a list of package names\n+     *\/\n+    public static Filter getPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n+        return new TargetPackageFilter(packageNames, matchSubpackages);\n+    }\n+\n+    \/**\n+     * Get the filter used to determine the dependencies included when searching\n+     * the transitive closure of all the dependencies.\n+     * Unless overridden, the default filter accepts all dependencies.\n+     * @return the filter\n+     *\/\n+    public Filter getFilter() {\n+        if (filter == null)\n+            filter = getDefaultFilter();\n+        return filter;\n+    }\n+\n+    \/**\n+     * Set the filter used to determine the dependencies included when searching\n+     * the transitive closure of all the dependencies.\n+     * @param f the filter\n+     *\/\n+    public void setFilter(Filter f) {\n+        filter = Objects.requireNonNull(f);\n+    }\n+\n+    \/**\n+     * Find the dependencies of a class, using the current\n+     * {@link Dependencies#getFinder finder} and\n+     * {@link Dependencies#getFilter filter}.\n+     * The search may optionally include the transitive closure of all the\n+     * filtered dependencies, by also searching in the classes named in those\n+     * dependencies.\n+     * @param classFinder a finder to locate class files\n+     * @param rootClassNames the names of the root classes from which to begin\n+     *      searching\n+     * @param transitiveClosure whether or not to also search those classes\n+     *      named in any filtered dependencies that are found.\n+     * @return the set of dependencies that were found\n+     * @throws ClassFileNotFoundException if a required class file cannot be found\n+     * @throws ClassFileError if an error occurs while processing a class file,\n+     *      such as an error in the internal class file structure.\n+     *\/\n+    public Set<Dependency> findAllDependencies(\n+            ClassFileReader classFinder, Set<String> rootClassNames,\n+            boolean transitiveClosure)\n+            throws ClassFileNotFoundException {\n+        final Set<Dependency> results = new HashSet<>();\n+        Recorder r = results::add;\n+        findAllDependencies(classFinder, rootClassNames, transitiveClosure, r);\n+        return results;\n+    }\n+\n+    \/**\n+     * Find the dependencies of a class, using the current\n+     * {@link Dependencies#getFinder finder} and\n+     * {@link Dependencies#getFilter filter}.\n+     * The search may optionally include the transitive closure of all the\n+     * filtered dependencies, by also searching in the classes named in those\n+     * dependencies.\n+     * @param classFinder a finder to locate class files\n+     * @param rootClassNames the names of the root classes from which to begin\n+     *      searching\n+     * @param transitiveClosure whether or not to also search those classes\n+     *      named in any filtered dependencies that are found.\n+     * @param recorder a recorder for handling the results\n+     * @throws ClassFileNotFoundException if a required class file cannot be found\n+     * @throws ClassFileError if an error occurs while processing a class file,\n+     *      such as an error in the internal class file structure.\n+     *\/\n+    public void findAllDependencies(\n+            ClassFileReader classFinder, Set<String> rootClassNames,\n+            boolean transitiveClosure, Recorder recorder)\n+            throws ClassFileNotFoundException {\n+        Set<String> doneClasses = new HashSet<>();\n+\n+        getFinder();  \/\/ ensure initialized\n+        getFilter();  \/\/ ensure initialized\n+\n+        \/\/ Work queue of names of classfiles to be searched.\n+        \/\/ Entries will be unique, and for classes that do not yet have\n+        \/\/ dependencies in the results map.\n+        Deque<String> deque = new LinkedList<>(rootClassNames);\n+\n+        String className;\n+        while ((className = deque.poll()) != null) {\n+            assert (!doneClasses.contains(className));\n+            doneClasses.add(className);\n+\n+            ClassModel cf = classFinder.getClassFile(className);\n+\n+            \/\/ The following code just applies the filter to the dependencies\n+            \/\/ followed for the transitive closure.\n+            for (Dependency d: finder.findDependencies(cf)) {\n+                recorder.addDependency(d);\n+                if (transitiveClosure && filter.accepts(d)) {\n+                    String cn = d.getTarget().getClassName();\n+                    if (!doneClasses.contains(cn))\n+                        deque.add(cn);\n+                }\n+            }\n+        }\n+    }\n+\n+    private Filter filter;\n+    private Finder finder;\n+\n+    \/**\n+     * A location identifying a class.\n+     *\/\n+    static class SimpleLocation implements Location {\n+        public SimpleLocation(String name) {\n+            this.name = name;\n+            this.className = name.replace('\/', '.');\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public String getClassName() {\n+            return className;\n+        }\n+\n+        public String getPackageName() {\n+            int i = name.lastIndexOf('\/');\n+            return (i > 0) ? name.substring(0, i).replace('\/', '.') : \"\";\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other)\n+                return true;\n+            if (!(other instanceof SimpleLocation))\n+                return false;\n+            return (name.equals(((SimpleLocation) other).name));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return name.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        private String name;\n+        private String className;\n+    }\n+\n+    \/**\n+     * A dependency of one class on another.\n+     *\/\n+    static class SimpleDependency implements Dependency {\n+        public SimpleDependency(Location origin, Location target) {\n+            this.origin = origin;\n+            this.target = target;\n+        }\n+\n+        public Location getOrigin() {\n+            return origin;\n+        }\n+\n+        public Location getTarget() {\n+            return target;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other)\n+                return true;\n+            if (!(other instanceof SimpleDependency))\n+                return false;\n+            SimpleDependency o = (SimpleDependency) other;\n+            return (origin.equals(o.origin) && target.equals(o.target));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return origin.hashCode() * 31 + target.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return origin + \":\" + target;\n+        }\n+\n+        private Location origin;\n+        private Location target;\n+    }\n+\n+\n+    \/**\n+     * This class accepts all dependencies.\n+     *\/\n+    static class DefaultFilter implements Filter {\n+        private static DefaultFilter instance;\n+\n+        static DefaultFilter instance() {\n+            if (instance == null)\n+                instance = new DefaultFilter();\n+            return instance;\n+        }\n+\n+        public boolean accepts(Dependency dependency) {\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * This class accepts those dependencies whose target's class name matches a\n+     * regular expression.\n+     *\/\n+    static class TargetRegexFilter implements Filter {\n+        TargetRegexFilter(Pattern pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public boolean accepts(Dependency dependency) {\n+            return pattern.matcher(dependency.getTarget().getClassName()).matches();\n+        }\n+\n+        private final Pattern pattern;\n+    }\n+\n+    \/**\n+     * This class accepts those dependencies whose class name is in a given\n+     * package.\n+     *\/\n+    static class TargetPackageFilter implements Filter {\n+        TargetPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n+            for (String pn: packageNames) {\n+                if (pn.length() == 0) \/\/ implies null check as well\n+                    throw new IllegalArgumentException();\n+            }\n+            this.packageNames = packageNames;\n+            this.matchSubpackages = matchSubpackages;\n+        }\n+\n+        public boolean accepts(Dependency dependency) {\n+            String pn = dependency.getTarget().getPackageName();\n+            if (packageNames.contains(pn))\n+                return true;\n+\n+            if (matchSubpackages) {\n+                for (String n: packageNames) {\n+                    if (pn.startsWith(n + \".\"))\n+                        return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private final Set<String> packageNames;\n+        private final boolean matchSubpackages;\n+    }\n+\n+    \/**\n+     * This class identifies class names directly or indirectly in the constant pool.\n+     *\/\n+    static class ClassDependencyFinder extends BasicDependencyFinder {\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile) {\n+            Visitor v = new Visitor(classfile);\n+            for (var cpInfo: classfile.constantPool()) {\n+                v.scan(cpInfo);\n+            }\n+            try {\n+                classfile.superclass().ifPresent(v::addClass);\n+                v.addClasses(classfile.interfaces());\n+                v.scanAttributes(classfile);\n+\n+                for (var f : classfile.fields()) {\n+                    v.scan(f.fieldTypeSymbol());\n+                    v.scanAttributes(f);\n+                }\n+                for (var m : classfile.methods()) {\n+                    v.scan(m.methodTypeSymbol());\n+                    v.scanAttributes(m);\n+                }\n+            } catch (IllegalArgumentException e) {\n+                throw new ClassFileError(e);\n+            }\n+\n+            return v.deps;\n+        }\n+    }\n+\n+    \/**\n+     * This class identifies class names in the signatures of classes, fields,\n+     * and methods in a class.\n+     *\/\n+    static class APIDependencyFinder extends BasicDependencyFinder {\n+        APIDependencyFinder(int access) {\n+            switch (access) {\n+                case ClassFile.ACC_PUBLIC:\n+                case ClassFile.ACC_PROTECTED:\n+                case ClassFile.ACC_PRIVATE:\n+                case 0:\n+                    showAccess = access;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"invalid access 0x\"\n+                            + Integer.toHexString(access));\n+            }\n+        }\n+\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile) {\n+            try {\n+                Visitor v = new Visitor(classfile);\n+                classfile.superclass().ifPresent(v::addClass);\n+                v.addClasses(classfile.interfaces());\n+                \/\/ inner classes?\n+                for (var f : classfile.fields()) {\n+                    if (checkAccess(f.flags())) {\n+                        v.scan(f.fieldTypeSymbol());\n+                        v.scanAttributes(f);\n+                    }\n+                }\n+                for (var m : classfile.methods()) {\n+                    if (checkAccess(m.flags())) {\n+                        v.scan(m.methodTypeSymbol());\n+                        v.scanAttributes(m);\n+                    }\n+                }\n+                return v.deps;\n+            } catch (IllegalArgumentException e) {\n+                throw new ClassFileError(e);\n+            }\n+        }\n+\n+        boolean checkAccess(AccessFlags flags) {\n+            \/\/ code copied from javap.Options.checkAccess\n+            boolean isPublic = flags.has(AccessFlag.PUBLIC);\n+            boolean isProtected = flags.has(AccessFlag.PROTECTED);\n+            boolean isPrivate = flags.has(AccessFlag.PRIVATE);\n+            boolean isPackage = !(isPublic || isProtected || isPrivate);\n+\n+            if ((showAccess == ClassFile.ACC_PUBLIC) && (isProtected || isPrivate || isPackage))\n+                return false;\n+            else if ((showAccess == ClassFile.ACC_PROTECTED) && (isPrivate || isPackage))\n+                return false;\n+            else if ((showAccess == 0) && (isPrivate))\n+                return false;\n+            else\n+                return true;\n+        }\n+\n+        private int showAccess;\n+    }\n+\n+    abstract static class BasicDependencyFinder implements Finder {\n+        private Map<String,Location> locations = new ConcurrentHashMap<>();\n+\n+        Location getLocation(String className) {\n+            return locations.computeIfAbsent(className, SimpleLocation::new);\n+        }\n+\n+        class Visitor {\n+            private final Location origin;\n+            final Set<Dependency> deps;\n+\n+            Visitor(ClassModel classFile) {\n+                try {\n+                    origin = getLocation(classFile.thisClass().asInternalName());\n+                } catch (IllegalArgumentException e) {\n+                    throw new ClassFileError(e);\n+                }\n+                deps = new HashSet<>();\n+            }\n+\n+            private void addDependency(String internalName) {\n+                deps.add(new SimpleDependency(origin, getLocation(internalName)));\n+            }\n+\n+            private void addClass(ClassEntry ce) throws IllegalArgumentException {\n+                assert ce.name().charAt(0) != '[';\n+                addDependency(ce.asInternalName());\n+            }\n+\n+            private void addClasses(Collection<? extends ClassEntry> ces) throws IllegalArgumentException {\n+                for (var i: ces)\n+                    addClass(i);\n+            }\n+\n+            private void scan(ClassDesc cd) {\n+                while (cd.isArray()) {\n+                    cd = cd.componentType();\n+                }\n+                if (cd.isClassOrInterface()) {\n+                    var desc = cd.descriptorString();\n+                    addDependency(desc.substring(1, desc.length() - 1));\n+                }\n+            }\n+\n+            private void scan(MethodTypeDesc mtd) {\n+                scan(mtd.returnType());\n+                for (int i = 0; i < mtd.parameterCount(); i++) {\n+                    scan(mtd.parameterType(i));\n+                }\n+            }\n+\n+            void scanAttributes(AttributedElement attrs) {\n+                try {\n+                    var sa = attrs.findAttribute(Attributes.SIGNATURE).orElse(null);\n+                    if (sa != null) {\n+                        switch (attrs) {\n+                            case ClassModel _ -> scan(sa.asClassSignature());\n+                            case MethodModel _ -> scan(sa.asMethodSignature());\n+                            default -> scan(sa.asTypeSignature());\n+                        }\n+                    }\n+\n+                    var rvaa = attrs.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+                    if (rvaa != null) {\n+                        for (var anno : rvaa.annotations()) {\n+                            scan(anno.classSymbol());\n+                        }\n+                    }\n+\n+                    var rvpaa = attrs.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS).orElse(null);\n+                    if (rvpaa != null) {\n+                        for (var parameter : rvpaa.parameterAnnotations()) {\n+                            for (var anno : parameter) {\n+                                scan(anno.classSymbol());\n+                            }\n+                        }\n+                    }\n+\n+                    var exceptions = attrs.findAttribute(Attributes.EXCEPTIONS).orElse(null);\n+                    if (exceptions != null) {\n+                        for (var e : exceptions.exceptions()) {\n+                            addClass(e);\n+                        }\n+                    }\n+                } catch (IllegalArgumentException e) {\n+                    throw new ClassFileError(e);\n+                }\n+            }\n+\n+            \/\/ ConstantPool scanning\n+\n+            void scan(PoolEntry cpInfo) {\n+                try {\n+                    switch (cpInfo) {\n+                        case ClassEntry clazz -> scan(clazz.asSymbol());\n+                        case FieldRefEntry field -> scan(field.owner().asSymbol());\n+                        case MethodRefEntry method -> scan(method.owner().asSymbol());\n+                        case InterfaceMethodRefEntry interfaceMethod -> scan(interfaceMethod.owner().asSymbol());\n+                        case NameAndTypeEntry nat -> {\n+                            var desc = nat.type();\n+                            if (desc.charAt(0) == '(') {\n+                                scan(MethodTypeDesc.ofDescriptor(desc.stringValue()));\n+                            } else {\n+                                scan(ClassDesc.ofDescriptor(desc.stringValue()));\n+                            }\n+                        }\n+                        default -> {}\n+                    }\n+                } catch (IllegalArgumentException e) {\n+                    throw new ClassFileError(e);\n+                }\n+            }\n+\n+            \/\/ Signature scanning\n+\n+            private void scan(MethodSignature sig) {\n+                for (var param : sig.typeParameters()) {\n+                    scan(param);\n+                }\n+                for (var param : sig.arguments()) {\n+                    scan(param);\n+                }\n+                scan(sig.result());\n+                for (var thrown : sig.throwableSignatures()) {\n+                    scan(thrown);\n+                }\n+            }\n+\n+            private void scan(ClassSignature sig) {\n+                for (var param : sig.typeParameters()) {\n+                    scan(param);\n+                }\n+                scan(sig.superclassSignature());\n+                for (var itf : sig.superinterfaceSignatures()) {\n+                    scan(itf);\n+                }\n+            }\n+\n+            private void scan(Signature.TypeParam param) {\n+                param.classBound().ifPresent(this::scan);\n+                for (var itf : param.interfaceBounds()) {\n+                    scan(itf);\n+                }\n+            }\n+\n+            private void scan(Signature sig) {\n+                switch (sig) {\n+                    case Signature.ClassTypeSig ct -> {\n+                        ct.outerType().ifPresent(this::scan);\n+                        scan(ct.classDesc());\n+                        for (var arg : ct.typeArgs()) {\n+                            if (arg instanceof Signature.TypeArg.Bounded bounded) {\n+                                scan(bounded.boundType());\n+                            }\n+                        }\n+                    }\n+                    case Signature.ArrayTypeSig at -> scan(at.componentSignature());\n+                    case Signature.BaseTypeSig _, Signature.TypeVarSig _ -> {}\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Dependencies.java","additions":709,"deletions":0,"binary":false,"changes":709,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.classfile;\n+package com.sun.tools.jdeps;\n@@ -29,0 +29,2 @@\n+import java.lang.classfile.ClassModel;\n+\n@@ -59,1 +61,1 @@\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile);\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Dependency.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Dependency.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,7 +31,2 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Dependencies;\n-import com.sun.tools.classfile.Dependencies.ClassFileError;\n-import com.sun.tools.classfile.Dependency;\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependencies.ClassFileError;\n+import com.sun.tools.jdeps.Dependency.Location;\n@@ -41,1 +36,4 @@\n-import java.nio.file.Paths;\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.reflect.AccessFlag;\n@@ -49,1 +47,0 @@\n-import java.util.concurrent.Callable;\n@@ -179,2 +176,2 @@\n-            for (ClassFile cf : archive.reader().getClassFiles()) {\n-                if (cf.access_flags.is(AccessFlags.ACC_MODULE))\n+            for (var cf : archive.reader().getClassFiles()) {\n+                if (cf.isModuleInfo())\n@@ -185,2 +182,2 @@\n-                    classFileName = cf.getName();\n-                } catch (ConstantPoolException e) {\n+                    classFileName = cf.thisClass().asInternalName();\n+                } catch (IllegalArgumentException e) {\n@@ -192,1 +189,1 @@\n-                if (!finder.accept(archive, cn, cf.access_flags))\n+                if (!finder.accept(archive, cn, cf.flags()))\n@@ -220,1 +217,1 @@\n-        ClassFile cf = archive.reader().getClassFile(name);\n+        var cf = archive.reader().getClassFile(name);\n@@ -226,1 +223,1 @@\n-        if (cf.access_flags.is(AccessFlags.ACC_MODULE))\n+        if (cf.isModuleInfo())\n@@ -232,2 +229,2 @@\n-            cn =  cf.getName().replace('\/', '.');\n-        } catch (ConstantPoolException e) {\n+            cn =  cf.thisClass().asInternalName().replace('\/', '.');\n+        } catch (IllegalArgumentException e) {\n@@ -237,1 +234,1 @@\n-        if (!finder.accept(archive, cn, cf.access_flags))\n+        if (!finder.accept(archive, cn, cf.flags()))\n@@ -299,1 +296,1 @@\n-                ? Dependencies.getAPIFinder(AccessFlags.ACC_PROTECTED)\n+                ? Dependencies.getAPIFinder(ClassFile.ACC_PROTECTED)\n@@ -312,1 +309,1 @@\n-                                 accessFlags.is(AccessFlags.ACC_PUBLIC)\n+                                 accessFlags.has(AccessFlag.PUBLIC)\n@@ -317,1 +314,1 @@\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile) {\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DependencyFinder.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n@@ -31,1 +31,0 @@\n-import java.util.Collection;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DepsAnalyzer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import com.sun.tools.classfile.Dependency;\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/JdepsConfiguration.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n-import com.sun.tools.classfile.Dependencies;\n-import com.sun.tools.classfile.Dependency;\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/JdepsFilter.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import com.sun.tools.classfile.Dependency;\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ModuleAnalyzer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-\n+import java.lang.classfile.ClassModel;\n@@ -47,2 +45,2 @@\n-    public static void add(JarFile jarfile, JarEntry e, ClassFile cf)\n-            throws ConstantPoolException\n+    public static void add(JarFile jarfile, JarEntry e, ClassModel cf)\n+            throws IllegalArgumentException\n@@ -57,1 +55,1 @@\n-                String name = cf.getName().replace('\/', '.');\n+                String name = cf.thisClass().asInternalName().replace('\/', '.');\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/VersionHelper.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/connect\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ *\n+ * @since 1.5\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/connect\/spi\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/event\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+ *\n+ * @since 1.3\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/request\/package-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    private static final List<String> UNCATEGORIZED = List.of(\"Uncategorized\");\n+    private static final String[] UNCATEGORIZED = { \"Uncategorized\" };\n@@ -238,5 +238,2 @@\n-        Category c = platformEventType.getAnnotation(Category.class);\n-        if (c == null) {\n-            return UNCATEGORIZED;\n-        }\n-        return List.of(c.value());\n+        String[] categories = platformEventType.getAnnotationValue(Category.class, UNCATEGORIZED);\n+        return List.of(categories);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,5 +75,1 @@\n-        Label label = getAnnotation(Label.class);\n-        if (label == null) {\n-            return null;\n-        }\n-        return label.value();\n+        return getAnnotationValue(Label.class, null);\n@@ -83,5 +79,1 @@\n-        Description description = getAnnotation(Description.class);\n-        if (description == null) {\n-            return null;\n-        }\n-        return description.value();\n+        return getAnnotationValue(Description.class, null);\n@@ -103,1 +95,14 @@\n-    private AnnotationElement getAnnotationElement(Class<? extends Annotation> clazz) {\n+    \/**\n+     * Convenience method that returns the annotation value, or a default value\n+     * if the type lacks the annotation.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T getAnnotationValue(Class<? extends java.lang.annotation.Annotation> clazz, T defaultValue) {\n+        AnnotationElement ae = getAnnotationElement(clazz);\n+        if (ae == null) {\n+            return defaultValue;\n+        }\n+        return (T) ae.getValues().get(0);\n+    }\n+\n+    AnnotationElement getAnnotationElement(Class<? extends Annotation> clazz) {\n@@ -126,2 +131,2 @@\n-            Unsigned unsigned = getAnnotation(Unsigned.class);\n-            unsignedFlag = (byte) (unsigned == null ? 0 :1);\n+            AnnotationElement ae = getAnnotationElement(Unsigned.class);\n+            unsignedFlag = (byte) (ae == null ? 0 :1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/AnnotationConstruct.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,0 @@\n-        Enabled enabled = type.getAnnotation(Enabled.class);\n@@ -297,4 +296,2 @@\n-        String def = type.isJVM() ? \"false\" : \"true\";\n-        if (enabled != null) {\n-            def = Boolean.toString(enabled.value());\n-        }\n+        Boolean defaultValue = Boolean.valueOf(!type.isJVM());\n+        String def = type.getAnnotationValue(Enabled.class, defaultValue).toString();\n@@ -306,5 +303,1 @@\n-        Threshold threshold = type.getAnnotation(Threshold.class);\n-        String def = \"0 ns\";\n-        if (threshold != null) {\n-            def = threshold.value();\n-        }\n+        String def = type.getAnnotationValue(Threshold.class, \"0 ns\");\n@@ -316,5 +309,1 @@\n-        StackTrace stackTrace = type.getAnnotation(StackTrace.class);\n-        String def = \"true\";\n-        if (stackTrace != null) {\n-            def = Boolean.toString(stackTrace.value());\n-        }\n+        String def = type.getAnnotationValue(StackTrace.class, Boolean.TRUE).toString();\n@@ -326,5 +315,1 @@\n-        Cutoff cutoff = type.getAnnotation(Cutoff.class);\n-        String def = Cutoff.INFINITY;\n-        if (cutoff != null) {\n-            def = cutoff.value();\n-        }\n+        String def = type.getAnnotationValue(Cutoff.class, Cutoff.INFINITY);\n@@ -336,5 +321,1 @@\n-        Throttle throttle = type.getAnnotation(Throttle.class);\n-        String def = Throttle.DEFAULT;\n-        if (throttle != null) {\n-            def = throttle.value();\n-        }\n+        String def = type.getAnnotationValue(Throttle.class, Throttle.DEFAULT);\n@@ -346,3 +327,2 @@\n-        Level level = type.getAnnotation(Level.class);\n-        String[] values = level.value();\n-        String def = values[0];\n+        String[] levels = type.getAnnotationValue(Level.class, new String[0]);\n+        String def = levels[0]; \/\/ Level value always exists\n@@ -350,1 +330,1 @@\n-        return new Control(new LevelSetting(type, values), def);\n+        return new Control(new LevelSetting(type, levels), def);\n@@ -354,5 +334,1 @@\n-        Period period = type.getAnnotation(Period.class);\n-        String def = \"everyChunk\";\n-        if (period != null) {\n-            def = period.value();\n-        }\n+        String def = type.getAnnotationValue(Period.class, \"everyChunk\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":11,"deletions":35,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-                    catchAllHandler.throwInstruction();\n+                    catchAllHandler.athrow();\n@@ -565,1 +565,1 @@\n-        blockCodeBuilder.constantInstruction(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n@@ -575,1 +575,1 @@\n-        blockCodeBuilder.loadInstruction(tk, slotIndex);\n+        blockCodeBuilder.loadLocal(tk, slotIndex);\n@@ -586,1 +586,1 @@\n-            blockCodeBuilder.loadInstruction(tk, slotIndex);\n+            blockCodeBuilder.loadLocal(tk, slotIndex);\n@@ -612,1 +612,1 @@\n-            blockCodeBuilder.loadInstruction(tk, slotIndex);\n+            blockCodeBuilder.loadLocal(tk, slotIndex);\n@@ -679,1 +679,1 @@\n-        blockCodeBuilder.constantInstruction(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n@@ -741,1 +741,1 @@\n-                codeBuilder.branchInstruction(Opcode.IFNULL, nullLabel);\n+                codeBuilder.if_null(nullLabel);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -76,4 +76,4 @@\n-                pEventType.setHasCutoff(eventType.getAnnotation(Cutoff.class) != null);\n-                pEventType.setHasThrottle(eventType.getAnnotation(Throttle.class) != null);\n-                pEventType.setHasLevel(eventType.getAnnotation(Level.class) != null);\n-                pEventType.setHasPeriod(eventType.getAnnotation(Period.class) != null);\n+                pEventType.setHasCutoff(type.hasAnnotation(Cutoff.class));\n+                pEventType.setHasThrottle(type.hasAnnotation(Throttle.class));\n+                pEventType.setHasLevel(type.hasAnnotation(Level.class));\n+                pEventType.setHasPeriod(type.hasAnnotation(Period.class));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,1 +290,1 @@\n-        try (var ds = doPrivilegedIOWithReturn(() -> Files.newDirectoryStream(JFC_DIRECTORY.toPath(), \"*.jfc\"))) {\n+        try (var ds = doPrivilegedIOWithReturn(() -> Files.newDirectoryStream(JFC_DIRECTORY.toPath()))) {\n@@ -293,1 +293,2 @@\n-                if (!SecuritySupport.isDirectory(s)) {\n+                String text = s.toString();\n+                if (text.endsWith(\".jfc\") && !SecuritySupport.isDirectory(s)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -267,0 +267,4 @@\n+    public <T> T getAnnotationValue(Class<? extends java.lang.annotation.Annotation> clazz, T defaultValue) {\n+       return annos.getAnnotationValue(clazz, defaultValue);\n+    }\n+\n@@ -362,0 +366,4 @@\n+\n+    public boolean hasAnnotation(Class<? extends java.lang.annotation.Annotation> clazz) {\n+        return annos.getAnnotationElement(clazz) != null;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Type.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    public abstract String[] printHelp();\n+    public abstract String[] getHelp();\n@@ -236,1 +236,1 @@\n-        for (String line : printHelp()) {\n+        for (String line : getHelp()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-    public String[] printHelp() {\n+    public String[] getHelp() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdCheck.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,1 +251,1 @@\n-    public String[] printHelp() {\n+    public String[] getHelp() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-    public String[] printHelp() {\n+    public String[] getHelp() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-    public String[] printHelp() {\n+    public String[] getHelp() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdQuery.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    public String[] printStartupHelp() {\n+    public String[] getStartupHelp() {\n@@ -324,0 +324,1 @@\n+            \"$SOURCE_NO_ARGUMENTS\", \"-XX:StartFlightRecording\",\n@@ -334,1 +335,1 @@\n-    public String[] printHelp() {\n+    public String[] getHelp() {\n@@ -337,0 +338,1 @@\n+           \"$SOURCE_NO_ARGUMENTS\", \"$ jcmd <pid> JFR.start\",\n@@ -443,1 +445,1 @@\n-                $SOURCE\n+                $SOURCE_NO_ARGUMENTS\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    public String[] printHelp() {\n+    public String[] getHelp() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    public String[] printHelp() {\n+    public String[] getHelp() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.Array;\n@@ -40,1 +41,0 @@\n-import java.util.Collection;\n@@ -246,0 +246,4 @@\n+        Class<?> componentType = makePrimitiveType(typeName);\n+        if (componentType == null) {\n+            return null;\n+        }\n@@ -247,58 +251,3 @@\n-        switch (typeName) {\n-        case \"int\":\n-            int[] ints = new int[length];\n-            for (int i = 0; i < length; i++) {\n-                ints[i] = (int) values.get(i);\n-            }\n-            return ints;\n-        case \"long\":\n-            long[] longs = new long[length];\n-            for (int i = 0; i < length; i++) {\n-                longs[i] = (long) values.get(i);\n-            }\n-            return longs;\n-\n-        case \"float\":\n-            float[] floats = new float[length];\n-            for (int i = 0; i < length; i++) {\n-                floats[i] = (float) values.get(i);\n-            }\n-            return floats;\n-\n-        case \"double\":\n-            double[] doubles = new double[length];\n-            for (int i = 0; i < length; i++) {\n-                doubles[i] = (double) values.get(i);\n-            }\n-            return doubles;\n-\n-        case \"short\":\n-            short[] shorts = new short[length];\n-            for (int i = 0; i < length; i++) {\n-                shorts[i] = (short) values.get(i);\n-            }\n-            return shorts;\n-        case \"char\":\n-            char[] chars = new char[length];\n-            for (int i = 0; i < length; i++) {\n-                chars[i] = (char) values.get(i);\n-            }\n-            return chars;\n-        case \"byte\":\n-            byte[] bytes = new byte[length];\n-            for (int i = 0; i < length; i++) {\n-                bytes[i] = (byte) values.get(i);\n-            }\n-            return bytes;\n-        case \"boolean\":\n-            boolean[] booleans = new boolean[length];\n-            for (int i = 0; i < length; i++) {\n-                booleans[i] = (boolean) values.get(i);\n-            }\n-            return booleans;\n-        case \"java.lang.String\":\n-            String[] strings = new String[length];\n-            for (int i = 0; i < length; i++) {\n-                strings[i] = (String) values.get(i);\n-            }\n-            return strings;\n+        Object array =  Array.newInstance(componentType, length);\n+        for (int index = 0; index < length; index++) {\n+            Array.set(array, index, values.get(index));\n@@ -306,1 +255,9 @@\n-        return null;\n+        return array;\n+    }\n+\n+    private static Class<?> makePrimitiveType(String typeName) {\n+        return switch(typeName) {\n+            case \"void\" -> null;\n+            case \"java.lang.String\" -> String.class;\n+            default -> Class.forPrimitiveName(typeName);\n+        };\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":17,"deletions":60,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-                    cob -> cob.constantInstruction(hasSplitPackages ? 1 : 0)\n+                    cob -> cob.loadConstant(hasSplitPackages ? 1 : 0)\n@@ -689,1 +689,1 @@\n-                    cob -> cob.constantInstruction(hasIncubatorModules ? 1 : 0)\n+                    cob -> cob.loadConstant(hasIncubatorModules ? 1 : 0)\n@@ -703,1 +703,1 @@\n-                            cob.constantInstruction(moduleInfos.size())\n+                            cob.loadConstant(moduleInfos.size())\n@@ -767,1 +767,1 @@\n-                        cob.constantInstruction(moduleInfos.size())\n+                        cob.loadConstant(moduleInfos.size())\n@@ -773,1 +773,1 @@\n-                           .constantInstruction(moduleInfos.size())\n+                           .loadConstant(moduleInfos.size())\n@@ -800,1 +800,1 @@\n-                                       .constantInstruction(i - dedupVarStart)\n+                                       .loadConstant(i - dedupVarStart)\n@@ -848,1 +848,1 @@\n-                        cob.constantInstruction(moduleInfos.size())\n+                        cob.loadConstant(moduleInfos.size())\n@@ -871,1 +871,1 @@\n-                                   .constantInstruction(index);\n+                                   .loadConstant(index);\n@@ -876,1 +876,1 @@\n-                                   .constantInstruction(minfo.target().targetPlatform())\n+                                   .loadConstant(minfo.target().targetPlatform())\n@@ -899,1 +899,1 @@\n-                        cob.constantInstruction(moduleInfos.size())\n+                        cob.loadConstant(moduleInfos.size())\n@@ -926,1 +926,1 @@\n-                        cob.constantInstruction(moduleInfos.size())\n+                        cob.loadConstant(moduleInfos.size())\n@@ -934,1 +934,1 @@\n-                                   .constantInstruction(index)\n+                                   .loadConstant(index)\n@@ -937,1 +937,1 @@\n-                                   .constantInstruction(minfo.moduleResolution().value())\n+                                   .loadConstant(minfo.moduleResolution().value())\n@@ -1003,1 +1003,1 @@\n-                        cob.constantInstruction(map.size())\n+                        cob.loadConstant(map.size())\n@@ -1012,2 +1012,2 @@\n-                               .constantInstruction(index)\n-                               .constantInstruction(name);\n+                               .loadConstant(index)\n+                               .loadConstant(name);\n@@ -1049,1 +1049,1 @@\n-                cob.constantInstruction(size)\n+                cob.loadConstant(size)\n@@ -1054,2 +1054,2 @@\n-                       .constantInstruction(i)\n-                       .constantInstruction(element)\n+                       .loadConstant(i)\n+                       .loadConstant(element)\n@@ -1065,1 +1065,1 @@\n-                    cob.constantInstruction(element);\n+                    cob.loadConstant(element);\n@@ -1169,1 +1169,1 @@\n-                   .constantInstruction(md.name())\n+                   .loadConstant(md.name())\n@@ -1191,1 +1191,1 @@\n-                   .constantInstruction(value ? 1 : 0)\n+                   .loadConstant(value ? 1 : 0)\n@@ -1203,1 +1203,1 @@\n-                   .constantInstruction(index)\n+                   .loadConstant(index)\n@@ -1205,1 +1205,1 @@\n-                   .constantInstruction(md.hashCode())\n+                   .loadConstant(md.hashCode())\n@@ -1220,1 +1220,1 @@\n-                   .constantInstruction(requires.size())\n+                   .loadConstant(requires.size())\n@@ -1230,1 +1230,1 @@\n-                       .constantInstruction(arrayIndex++);\n+                       .loadConstant(arrayIndex++);\n@@ -1249,1 +1249,1 @@\n-                   .constantInstruction(name);\n+                   .loadConstant(name);\n@@ -1251,1 +1251,1 @@\n-                    cob.constantInstruction(compiledVersion)\n+                    cob.loadConstant(compiledVersion)\n@@ -1270,1 +1270,1 @@\n-                   .constantInstruction(exports.size())\n+                   .loadConstant(exports.size())\n@@ -1275,1 +1275,1 @@\n-                       .constantInstruction(arrayIndex++);\n+                       .loadConstant(arrayIndex++);\n@@ -1305,1 +1305,1 @@\n-                       .constantInstruction(pn)\n+                       .loadConstant(pn)\n@@ -1312,1 +1312,1 @@\n-                       .constantInstruction(pn)\n+                       .loadConstant(pn)\n@@ -1327,1 +1327,1 @@\n-                   .constantInstruction(opens.size())\n+                   .loadConstant(opens.size())\n@@ -1332,1 +1332,1 @@\n-                       .constantInstruction(arrayIndex++);\n+                       .loadConstant(arrayIndex++);\n@@ -1362,1 +1362,1 @@\n-                       .constantInstruction(pn)\n+                       .loadConstant(pn)\n@@ -1369,1 +1369,1 @@\n-                       .constantInstruction(pn)\n+                       .loadConstant(pn)\n@@ -1397,1 +1397,1 @@\n-                   .constantInstruction(provides.size())\n+                   .loadConstant(provides.size())\n@@ -1402,1 +1402,1 @@\n-                       .constantInstruction(arrayIndex++);\n+                       .loadConstant(arrayIndex++);\n@@ -1422,2 +1422,2 @@\n-                cob.constantInstruction(service)\n-                   .constantInstruction(providers.size())\n+                cob.loadConstant(service)\n+                   .loadConstant(providers.size())\n@@ -1428,2 +1428,2 @@\n-                       .constantInstruction(arrayIndex++)\n-                       .constantInstruction(provider)\n+                       .loadConstant(arrayIndex++)\n+                       .loadConstant(provider)\n@@ -1459,1 +1459,1 @@\n-                   .constantInstruction(cn)\n+                   .loadConstant(cn)\n@@ -1471,1 +1471,1 @@\n-                   .constantInstruction(v.toString())\n+                   .loadConstant(v.toString())\n@@ -1480,1 +1480,1 @@\n-                   .constantInstruction(value)\n+                   .loadConstant(value)\n@@ -1534,2 +1534,2 @@\n-                   .constantInstruction(recordedHashes.algorithm())\n-                   .constantInstruction(((4 * recordedHashes.names().size()) \/ 3) + 1)\n+                   .loadConstant(recordedHashes.algorithm())\n+                   .loadConstant(((4 * recordedHashes.names().size()) \/ 3) + 1)\n@@ -1550,1 +1550,1 @@\n-                   .constantInstruction(index)\n+                   .loadConstant(index)\n@@ -1563,2 +1563,2 @@\n-                   .constantInstruction(name)\n-                   .constantInstruction(hash.length)\n+                   .loadConstant(name)\n+                   .loadConstant(hash.length)\n@@ -1568,2 +1568,2 @@\n-                       .constantInstruction(i)\n-                       .constantInstruction((int)hash[i])\n+                       .loadConstant(i)\n+                       .loadConstant((int)hash[i])\n@@ -1732,1 +1732,1 @@\n-                cob.constantInstruction((ConstantDesc)element);\n+                cob.loadConstant((ConstantDesc)element);\n@@ -1775,1 +1775,1 @@\n-                    cob.constantInstruction(elements.size())\n+                    cob.loadConstant(elements.size())\n@@ -1780,1 +1780,1 @@\n-                           .constantInstruction(arrayIndex);\n+                           .loadConstant(arrayIndex);\n@@ -1879,1 +1879,1 @@\n-                                      cob.constantInstruction(map.size());\n+                                      cob.loadConstant(map.size());\n@@ -1885,2 +1885,2 @@\n-                                             .constantInstruction(index)\n-                                             .constantInstruction(entry.getKey())\n+                                             .loadConstant(index)\n+                                             .loadConstant(entry.getKey())\n@@ -1900,1 +1900,1 @@\n-                                      cob.constantInstruction(map.size())\n+                                      cob.loadConstant(map.size())\n@@ -1906,2 +1906,2 @@\n-                                             .constantInstruction(index)\n-                                             .constantInstruction(entry.getValue().replace('\/', '.'))\n+                                             .loadConstant(index)\n+                                             .loadConstant(entry.getValue().replace('\/', '.'))\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-                                        cob.constantInstruction(value);\n+                                        cob.loadConstant(value);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/VersionPropsPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-            return in.readLine(prompt, mask);\n+            return in.readLine(prompt.replace(\"%\", \"%%\"), mask);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -341,0 +341,4 @@\n+        boolean hasOption(OptionKind kind) {\n+            return optMap.containsKey(kind);\n+        }\n+\n@@ -473,1 +477,1 @@\n-            if (options.has(argEnablePreview)) {\n+            if (previewEnabled(options)) {\n@@ -493,0 +497,4 @@\n+        boolean previewEnabled(OptionSet options) {\n+            return options.has(argEnablePreview);\n+        }\n+\n@@ -630,1 +638,2 @@\n-                initialStartup = Startup.unpack(packedStartup, new InitMessageHandler());\n+                boolean preview = previewEnabled(options);\n+                initialStartup = Startup.unpack(packedStartup, preview, new InitMessageHandler());\n@@ -2288,1 +2297,2 @@\n-            startup = Startup.defaultStartup(this);\n+            boolean preview = options.hasOption(OptionKind.ENABLE_PREVIEW);\n+            startup = Startup.defaultStartup(preview, this);\n@@ -2305,1 +2315,2 @@\n-            Startup retainedStart = Startup.unpack(retained, this);\n+            boolean preview = options.hasOption(OptionKind.ENABLE_PREVIEW);\n+            Startup retainedStart = Startup.unpack(retained, preview, this);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,1 @@\n+    private static final String PREVIEW_DEFAULT_STARTUP_NAME = \"PREVIEW_DEFAULT\";\n@@ -123,1 +124,4 @@\n-    private static Startup defaultStartup = null;\n+    private static Startup[] defaultStartup = new Startup[] {\n+        null, \/\/standard startup\n+        null  \/\/preview  startup\n+    };\n@@ -169,1 +173,2 @@\n-            if (sue.isBuiltIn && sue.name.equals(DEFAULT_STARTUP_NAME)) {\n+            if (sue.isBuiltIn && (sue.name.equals(DEFAULT_STARTUP_NAME) ||\n+                                  sue.name.equals(PREVIEW_DEFAULT_STARTUP_NAME))) {\n@@ -220,1 +225,1 @@\n-    static Startup unpack(String storedForm, MessageHandler mh) {\n+    static Startup unpack(String storedForm, boolean preview, MessageHandler mh) {\n@@ -258,1 +263,1 @@\n-        return defaultStartup(mh);\n+        return defaultStartup(preview, mh);\n@@ -327,3 +332,5 @@\n-    static Startup defaultStartup(MessageHandler mh) {\n-        if (defaultStartup != null) {\n-            return defaultStartup;\n+    static Startup defaultStartup(boolean preview, MessageHandler mh) {\n+        int idx = preview ? 1 : 0;\n+\n+        if (defaultStartup[idx] != null) {\n+            return defaultStartup[idx];\n@@ -331,0 +338,2 @@\n+        String resourceName = preview ? PREVIEW_DEFAULT_STARTUP_NAME\n+                                      : DEFAULT_STARTUP_NAME;\n@@ -332,3 +341,3 @@\n-            String content = readResource(DEFAULT_STARTUP_NAME);\n-            return defaultStartup = new Startup(\n-                    new StartupEntry(true, DEFAULT_STARTUP_NAME, content));\n+            String content = readResource(resourceName);\n+            return defaultStartup[idx] = new Startup(\n+                    new StartupEntry(true, resourceName, content));\n@@ -336,1 +345,1 @@\n-            mh.errormsg(\"jshell.err.file.not.accessible\", \"jshell\", DEFAULT_STARTUP_NAME, e.getMessage());\n+            mh.errormsg(\"jshell.err.file.not.accessible\", \"jshell\", resourceName, e.getMessage());\n@@ -338,1 +347,1 @@\n-            mh.errormsg(\"jshell.err.file.not.found\", \"jshell\", DEFAULT_STARTUP_NAME);\n+            mh.errormsg(\"jshell.err.file.not.found\", \"jshell\", resourceName);\n@@ -340,1 +349,1 @@\n-            mh.errormsg(\"jshell.err.file.exception\", \"jshell\", DEFAULT_STARTUP_NAME, e);\n+            mh.errormsg(\"jshell.err.file.exception\", \"jshell\", resourceName, e);\n@@ -342,1 +351,1 @@\n-        return defaultStartup = noStartup();\n+        return defaultStartup[idx] = noStartup();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/Startup.java","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,1 @@\n+import static jdk.jshell.Snippet.SubKind.MODULE_IMPORT_SUBKIND;\n@@ -99,1 +100,1 @@\n-    private static final Pattern IMPORT_PATTERN = Pattern.compile(\"import\\\\p{javaWhitespace}+(?<static>static\\\\p{javaWhitespace}+)?(?<fullname>[\\\\p{L}\\\\p{N}_\\\\$\\\\.]+\\\\.(?<name>[\\\\p{L}\\\\p{N}_\\\\$]+|\\\\*))\");\n+    private static final Pattern IMPORT_PATTERN = Pattern.compile(\"import\\\\p{javaWhitespace}+(?<module>module\\\\p{javaWhitespace}+)?(?<static>static\\\\p{javaWhitespace}+)?(?<fullname>[\\\\p{L}\\\\p{N}_\\\\$\\\\.]+\\\\.(?<name>[\\\\p{L}\\\\p{N}_\\\\$]+|\\\\*))\");\n@@ -247,0 +248,1 @@\n+        boolean isModule;\n@@ -249,0 +251,1 @@\n+            isModule = mat.group(\"module\") != null;\n@@ -250,1 +253,0 @@\n-            name = mat.group(\"name\");\n@@ -252,0 +254,5 @@\n+            if (isModule) {\n+                name = fullname;\n+            } else {\n+                name = mat.group(\"name\");\n+            }\n@@ -254,0 +261,1 @@\n+            isModule = compileSource.contains(\" module \");\n@@ -262,3 +270,8 @@\n-        SubKind snippetKind = isStar\n-                ? (isStatic ? STATIC_IMPORT_ON_DEMAND_SUBKIND : TYPE_IMPORT_ON_DEMAND_SUBKIND)\n-                : (isStatic ? SINGLE_STATIC_IMPORT_SUBKIND : SINGLE_TYPE_IMPORT_SUBKIND);\n+        SubKind snippetKind;\n+        if (isModule) {\n+            snippetKind = MODULE_IMPORT_SUBKIND;\n+        } else if (isStar) {\n+            snippetKind = isStatic ? STATIC_IMPORT_ON_DEMAND_SUBKIND : TYPE_IMPORT_ON_DEMAND_SUBKIND;\n+        } else {\n+            snippetKind = isStatic ? SINGLE_STATIC_IMPORT_SUBKIND : SINGLE_TYPE_IMPORT_SUBKIND;\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Eval.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -217,0 +218,9 @@\n+        \/**\n+         * Import Module Declaration.\n+         * An import declaration of a module.\n+         * @jls 7.5.5 Import Module Declarations\n+         * @since 23\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.MODULE_IMPORTS, reflective=true)\n+        MODULE_IMPORT_SUBKIND(Kind.IMPORT),\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Snippet.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import java.util.Locale;\n+\n@@ -196,2 +198,2 @@\n-        public JdkConsole format(String fmt, Object... args) {\n-            writer().format(fmt, args).flush();\n+        public JdkConsole format(Locale locale, String format, Object... args) {\n+            writer().format(locale, format, args).flush();\n@@ -205,9 +207,1 @@\n-        public JdkConsole printf(String format, Object... args) {\n-            return format(format, args);\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         *\/\n-        @Override\n-        public String readLine(String fmt, Object... args) {\n+        public String readLine(Locale locale, String format, Object... args) {\n@@ -217,1 +211,1 @@\n-                    String prompt = fmt.formatted(args);\n+                    String prompt = String.format(locale, format, args);\n@@ -233,1 +227,1 @@\n-            return readLine(\"\");\n+            return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n@@ -240,1 +234,1 @@\n-        public char[] readPassword(String fmt, Object... args) {\n+        public char[] readPassword(Locale locale, String format, Object... args) {\n@@ -244,1 +238,1 @@\n-                    String prompt = fmt.formatted(args);\n+                    String prompt = String.format(locale, format, args);\n@@ -259,1 +253,1 @@\n-            return readPassword(\"\");\n+            return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/impl\/ConsoleImpl.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+import module java.base;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/resources\/PREVIEW_DEFAULT.jsh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.internal.util.random.RandomSupport;\n-\n-\/**\n- * Defines implementations of the\n- * {@linkplain java.util.random.RandomGenerator RandomGenerator Interface}.\n- *\n- * @provides jdk.random.L128X1024MixRandom\n- * @provides jdk.random.L128X128MixRandom\n- * @provides jdk.random.L128X256MixRandom\n- * @provides jdk.random.L32X64MixRandom\n- * @provides jdk.random.L64X1024MixRandom\n- * @provides jdk.random.L64X128MixRandom\n- * @provides jdk.random.L64X128StarStarRandom\n- * @provides jdk.random.L64X256MixRandom\n- * @provides jdk.random.Xoroshiro128PlusPlus\n- * @provides jdk.random.Xoshiro256PlusPlus\n- *\n- * @uses java.util.random.RandomGenerator\n- *\n- * @moduleGraph\n- * @since 16\n- *\/\n-module jdk.random {\n-    exports jdk.random to\n-            java.base;\n-\n-    provides java.util.random.RandomGenerator with\n-        jdk.random.L32X64MixRandom,\n-        jdk.random.L64X128MixRandom,\n-        jdk.random.L64X128StarStarRandom,\n-        jdk.random.L64X256MixRandom,\n-        jdk.random.L64X1024MixRandom,\n-        jdk.random.L128X128MixRandom,\n-        jdk.random.L128X256MixRandom,\n-        jdk.random.L128X1024MixRandom,\n-        jdk.random.Xoroshiro128PlusPlus,\n-        jdk.random.Xoshiro256PlusPlus;\n-}\n","filename":"src\/jdk.random\/share\/classes\/module-info.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -44,4 +44,1 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n+import java.nio.file.*;\n@@ -51,0 +48,3 @@\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+import java.util.zip.ZipInputStream;\n@@ -54,0 +54,1 @@\n+import javax.swing.filechooser.FileNameExtensionFilter;\n@@ -69,0 +70,3 @@\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+\n@@ -79,11 +83,1 @@\n-    private static final FileFilter xmlFileFilter = new FileFilter() {\n-        @Override\n-        public boolean accept(File f) {\n-            return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n-        }\n-\n-        @Override\n-        public String getDescription() {\n-            return \"Graph files (*.xml)\";\n-        }\n-    };\n+    private static final FileFilter graphFileFilter = new FileNameExtensionFilter(\"Graph files (*.xml, *.igv)\", \"xml\", \"igv\");\n@@ -164,2 +158,20 @@\n-        try (Writer writer = new OutputStreamWriter(new FileOutputStream(path))) {\n-            Printer.exportGraphDocument(writer, doc, saveContexts);\n+        if (path.endsWith(\".igv\")) {\n+            File zipFile = new File(path);\n+            String fileName = zipFile.getName();\n+            try (FileOutputStream fos = new FileOutputStream(zipFile);\n+                 ZipOutputStream zos = new ZipOutputStream(fos);\n+                 Writer writer = new OutputStreamWriter(zos)) {\n+\n+                \/\/ Replace the '.igv' extension with '.xml's\n+                String zipEntryName = fileName.substring(0, fileName.length() - 4) + \".xml\";\n+                ZipEntry zipEntry = new ZipEntry(zipEntryName);\n+                zos.putNextEntry(zipEntry);\n+\n+                Printer.exportGraphDocument(writer, doc, saveContexts);\n+\n+                zos.closeEntry();\n+            }\n+        } else {\n+            try (Writer writer = new OutputStreamWriter(new FileOutputStream(path))) {\n+                Printer.exportGraphDocument(writer, doc, saveContexts);\n+            }\n@@ -361,1 +373,1 @@\n-        fc.setFileFilter(xmlFileFilter);\n+        fc.setFileFilter(graphFileFilter);\n@@ -406,1 +418,14 @@\n-        JFileChooser fc = new JFileChooser();\n+        JFileChooser fc = new JFileChooser() {\n+            @Override\n+            public void approveSelection() {\n+                File selectedFile = getSelectedFile();\n+                if (selectedFile != null) {\n+                    String fileName = selectedFile.getName().toLowerCase();\n+                    if (!fileName.endsWith(\".xml\") && !fileName.endsWith(\".igv\")) {\n+                        JOptionPane.showMessageDialog(this, \"Please select a graph file with .xml or .igv extension.\", \"Invalid File\", JOptionPane.ERROR_MESSAGE);\n+                        return;\n+                    }\n+                }\n+                super.approveSelection();\n+            }\n+        };\n@@ -408,1 +433,1 @@\n-        fc.setFileFilter(xmlFileFilter);\n+        fc.setFileFilter(graphFileFilter);\n@@ -435,1 +460,1 @@\n-        fc.setFileFilter(xmlFileFilter);\n+        fc.setFileFilter(graphFileFilter);\n@@ -485,2 +510,2 @@\n-     * Loads a graph document from the given file path, updating progress via a ProgressHandle.\n-     * Parse the XML file, add the parsed document to the workspace, and load associated contexts if specified.\n+     * Loads a graph document from the specified path, either as an XML file or from a ZIP archive.\n+     * If loading the context is requested, it loads the context along with the document.\n@@ -493,8 +518,11 @@\n-        final FileChannel channel;\n-        final long start;\n-        try {\n-            channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n-            start = channel.size();\n-        } catch (Exception ex) {\n-            Exceptions.printStackTrace(ex);\n-            return;\n+        if (file.getName().endsWith(\".xml\")) {\n+            try (FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.READ)) {\n+                loadFile(channel, file, loadContext);\n+            }\n+        } else if (file.getName().endsWith(\".igv\")) {\n+            try (ZipInputStream zis = new ZipInputStream(new FileInputStream(file))) {\n+                ZipEntry entry = zis.getNextEntry();\n+                if (entry != null && entry.getName().endsWith(\".xml\")) {\n+                    loadFile(Channels.newChannel(zis), file, loadContext);\n+                }\n+            }\n@@ -502,0 +530,1 @@\n+    }\n@@ -503,0 +532,4 @@\n+    \/**\n+     * Loads an XML or ZIP document from the provided channel, while monitoring the progress of the operation.\n+     *\/\n+    private void loadFile(ReadableByteChannel channel,  File file, boolean loadContext) throws IOException {\n@@ -506,7 +539,10 @@\n-        ParseMonitor monitor = new ParseMonitor() {\n-            @Override\n-            public void updateProgress() {\n-                try {\n-                    int prog = (int) (WORK_UNITS * (double) channel.position() \/ (double) start);\n-                    handle.progress(prog);\n-                } catch (IOException ignored) {\n+        ParseMonitor monitor;\n+        if (channel instanceof FileChannel fileChannel) {\n+            final long start = fileChannel.size();\n+            monitor = new ParseMonitor() {\n+                @Override\n+                public void updateProgress() {\n+                    try {\n+                        int prog = (int) (WORK_UNITS * (double) fileChannel.position() \/ (double) start);\n+                        handle.progress(prog);\n+                    } catch (IOException ignored) {}\n@@ -514,1 +550,0 @@\n-            }\n@@ -516,6 +551,21 @@\n-            @Override\n-            public void setState(String state) {\n-                updateProgress();\n-                handle.progress(state);\n-            }\n-        };\n+                @Override\n+                public void setState(String state) {\n+                    updateProgress();\n+                    handle.progress(state);\n+                }\n+            };\n+        } else {\n+            monitor = new ParseMonitor() {\n+                @Override\n+                public void updateProgress() {\n+                    handle.progress(\"Processing...\");\n+                }\n+\n+                @Override\n+                public void setState(String state) {\n+                    updateProgress();\n+                    handle.progress(state);\n+                }\n+            };\n+        }\n+\n@@ -523,12 +573,10 @@\n-            if (file.getName().endsWith(\".xml\")) {\n-                ArrayList<GraphContext> contexts = new ArrayList<>();\n-                final Parser parser = new Parser(channel, monitor, document, loadContext ? contexts::add : null);\n-                parser.parse();\n-                SwingUtilities.invokeLater(() -> {\n-                    for (Node child : manager.getRootContext().getChildren().getNodes(true)) {\n-                        \/\/ Nodes are lazily created. By expanding and collapsing they are all initialized\n-                        ((BeanTreeView) this.treeView).expandNode(child);\n-                        ((BeanTreeView) this.treeView).collapseNode(child);\n-                    }\n-                    requestActive();\n-                });\n+            ArrayList<GraphContext> contexts = new ArrayList<>();\n+            final Parser parser = new Parser(channel, monitor, document, loadContext ? contexts::add : null);\n+            parser.parse();\n+            SwingUtilities.invokeLater(() -> {\n+                for (Node child : manager.getRootContext().getChildren().getNodes(true)) {\n+                    \/\/ Nodes are lazily created. By expanding and collapsing they are all initialized\n+                    ((BeanTreeView) this.treeView).expandNode(child);\n+                    ((BeanTreeView) this.treeView).collapseNode(child);\n+                }\n+                requestActive();\n@@ -538,1 +586,1 @@\n-            }\n+            });\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":106,"deletions":58,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.Objects;\n+\n@@ -52,2 +54,5 @@\n-    public boolean equals(Object o) {\n-        if (!(o instanceof InputNode)) {\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || getClass() != obj.getClass()) {\n@@ -56,2 +61,3 @@\n-        InputNode n = (InputNode) o;\n-        return n.id == id;\n+        InputNode other = (InputNode) obj;\n+        return id == other.id &&\n+                Objects.equals(getProperties(), other.getProperties());\n@@ -62,1 +68,1 @@\n-        return id * 13;\n+        return Objects.hash(id, getProperties());\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -106,4 +106,9 @@\n-        }\n-\n-        for (InputNode n : graph.getNodes()) {\n-            if (!difference || !equal.contains(n)) {\n+            for (InputNode n : graph.getNodes()) {\n+                if (!equal.contains(n)) {\n+                    writer.startTag(Parser.NODE_ELEMENT, new Properties(Parser.NODE_ID_PROPERTY, Integer.toString(n.getId())));\n+                    writer.writeProperties(n.getProperties());\n+                    writer.endTag(); \/\/ Parser.NODE_ELEMENT\n+                }\n+            }\n+        } else {\n+            for (InputNode n : graph.getNodes()) {\n@@ -230,0 +235,4 @@\n+            b.append(\" \");\n+            b.append(code.getOperands());\n+            b.append(\" \");\n+            b.append(code.getComment());\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,451 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp\"\n+\n+#include <iostream>\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+#include \"utilities\/vmassert_reinstall.hpp\"\n+#include \"unittest.hpp\"\n+\n+static bool _success;\n+static size_t _assertion_failures;\n+\n+#define BitMapAssertEqual(a, b)  ASSERT_EQ((a), (b)); if ((a) != (b)) { _assertion_failures++; }\n+\n+class ShenandoahSimpleBitMapTest: public ::testing::Test {\n+protected:\n+\n+  static const ssize_t SMALL_BITMAP_SIZE =  512;\n+  static const ssize_t LARGE_BITMAP_SIZE = 4096;\n+\n+  \/\/ set_bits[] is an array of indexes holding bits that are supposed to be set, in increasing order.\n+  static void verifyBitMapState(ShenandoahSimpleBitMap& bm, ssize_t size, ssize_t set_bits[], ssize_t num_set_bits) {\n+    \/\/ Verify number of bits\n+    BitMapAssertEqual(bm.size(), size);\n+\n+    ssize_t set_bit_index = 0;\n+    \/\/ Check that is_set(idx) for every possible idx\n+    for (ssize_t i = 0; i < size; i++) {\n+      bool is_set = bm.is_set(i);\n+      bool intended_value = false;;\n+      if (set_bit_index < num_set_bits) {\n+        if (set_bits[set_bit_index] == i) {\n+          intended_value = true;\n+          set_bit_index++;\n+        }\n+      } else {\n+        \/\/ If we've exhausted set_bits array, there should be no more set_bits\n+        BitMapAssertEqual(is_set, false);\n+        BitMapAssertEqual(set_bit_index, num_set_bits);\n+      }\n+      BitMapAssertEqual(is_set, intended_value);\n+    }\n+    BitMapAssertEqual(set_bit_index, num_set_bits);\n+\n+    \/\/ Check that bits_at(array_idx) matches intended value for every valid array_idx value\n+    set_bit_index = 0;\n+    ssize_t alignment = bm.alignment();\n+    for (ssize_t i = 0; i < size; i += alignment) {\n+      size_t bits = bm.bits_at(i);\n+      for (ssize_t b = 0; b < alignment; b++) {\n+        ssize_t bit_value = i + b;\n+        bool intended_value = false;;\n+        if (set_bit_index < num_set_bits) {\n+          if (set_bits[set_bit_index] == bit_value) {\n+            intended_value = true;\n+            set_bit_index++;\n+          }\n+        }\n+        size_t bit_mask = ((size_t) 0x01) << b;\n+        bool is_set = (bits & bit_mask) != 0;\n+        BitMapAssertEqual(is_set, intended_value);\n+      }\n+    }\n+\n+    \/\/ Make sure find_first_set_bit() works correctly\n+    ssize_t probe_point = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_first_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, next_expected_bit);\n+      probe_point++;            \/\/ Prepare to look beyond the most recent bit.\n+    }\n+    if (probe_point < size) {\n+      probe_point = bm.find_first_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, size); \/\/ Verify that last failed search returns sentinel value: num bits in bit map\n+    }\n+\n+    \/\/ Confirm that find_first_set_bit() with a bounded search space works correctly\n+    \/\/ Limit this search to the first 3\/4 of the full bit map\n+    ssize_t boundary_idx = 3 * size \/ 4;\n+    probe_point = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      if (next_expected_bit >= boundary_idx) {\n+        break;\n+      } else {\n+        probe_point = bm.find_first_set_bit(probe_point, boundary_idx);\n+        BitMapAssertEqual(probe_point, next_expected_bit);\n+        probe_point++;            \/\/ Prepare to look beyond the most recent bit.\n+      }\n+    }\n+    if (probe_point < boundary_idx) {\n+      \/\/ In case there are no set bits in the last 1\/4 of bit map, confirm that last failed search returns sentinel: boundary_idx\n+      probe_point = bm.find_first_set_bit(probe_point, boundary_idx);\n+      BitMapAssertEqual(probe_point, boundary_idx);\n+    }\n+\n+    \/\/ Make sure find_last_set_bit() works correctly\n+    probe_point = size - 1;\n+    for (ssize_t i = num_set_bits - 1; i >= 0; i--) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      probe_point = bm.find_last_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, next_expected_bit);\n+      probe_point--;            \/\/ Prepare to look before the most recent bit.\n+    }\n+    if (probe_point >= 0) {\n+      probe_point = bm.find_last_set_bit(probe_point);\n+      BitMapAssertEqual(probe_point, (ssize_t) -1); \/\/ Verify that last failed search returns sentinel value: -1\n+    }\n+\n+    \/\/ Confirm that find_last_set_bit() with a bounded search space works correctly\n+    \/\/ Limit this search to the last 3\/4 of the full bit map\n+    boundary_idx = size \/ 4;\n+    probe_point = size - 1;\n+    for (ssize_t i = num_set_bits - 1; i >= 0; i--) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      if (next_expected_bit > boundary_idx) {\n+        probe_point = bm.find_last_set_bit(boundary_idx, probe_point);\n+        BitMapAssertEqual(probe_point, next_expected_bit);\n+        probe_point--;\n+      } else {\n+        break;\n+      }\n+    }\n+    if (probe_point > boundary_idx) {\n+      probe_point = bm.find_last_set_bit(boundary_idx, probe_point);\n+        \/\/ Verify that last failed search returns sentinel value: boundary_idx\n+      BitMapAssertEqual(probe_point, boundary_idx);\n+    }\n+\n+    \/\/ What's the longest cluster of consecutive bits\n+    ssize_t previous_value = -2;\n+    ssize_t longest_run = 0;\n+    ssize_t current_run = 0;\n+    for (ssize_t i = 0; i < num_set_bits; i++) {\n+      ssize_t next_expected_bit = set_bits[i];\n+      if (next_expected_bit == previous_value + 1) {\n+        current_run++;\n+      } else {\n+        previous_value = next_expected_bit;\n+        current_run = 1;\n+      }\n+      if (current_run > longest_run) {\n+        longest_run = current_run;\n+      }\n+      previous_value = next_expected_bit;\n+    }\n+\n+    \/\/ Confirm that find_first_consecutive_set_bits() works for each cluster size known to have at least one match\n+    for (ssize_t cluster_size = 1; cluster_size <= longest_run; cluster_size++) {\n+      \/\/ Verify that find_first_consecutive_set_bits() works\n+      ssize_t bit_idx = 0;\n+      ssize_t probe_point = 0;\n+      while ((probe_point <= size - cluster_size) && (bit_idx <= num_set_bits - cluster_size)) {\n+        bool cluster_found = false;\n+        while (!cluster_found && (bit_idx + cluster_size <= num_set_bits)) {\n+          cluster_found = true;\n+          for (ssize_t i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] + i != set_bits[bit_idx + i]) {\n+              cluster_found = false;\n+              bit_idx++;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          ssize_t orig_probe_point = probe_point;\n+          probe_point = bm.find_first_consecutive_set_bits(orig_probe_point, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point++;\n+          bit_idx++;\n+        } else {\n+          bit_idx++;\n+          break;\n+        }\n+      }\n+      if (probe_point < size) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: num_bits\n+        probe_point = bm.find_first_consecutive_set_bits(probe_point, cluster_size);\n+        BitMapAssertEqual(probe_point, size);\n+      }\n+\n+      \/\/ Repeat the above experiment, using 3\/4 size as the search boundary_idx\n+      bit_idx = 0;\n+      probe_point = 0;\n+      boundary_idx = 4 * size \/ 4;\n+      while ((probe_point <= boundary_idx - cluster_size) && (bit_idx <= num_set_bits - cluster_size)) {\n+        bool cluster_found = false;\n+        while (!cluster_found && (bit_idx + cluster_size <= num_set_bits)) {\n+          cluster_found = true;\n+          for (int i = 1; i < cluster_size; i++) {\n+            if (set_bits[bit_idx] + i != set_bits[bit_idx + i]) {\n+              cluster_found = false;\n+              bit_idx++;\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx];\n+          probe_point = bm.find_first_consecutive_set_bits(probe_point, boundary_idx, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point++;\n+          bit_idx++;\n+        } else {\n+          bit_idx++;\n+        }\n+      }\n+      if (probe_point < boundary_idx) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_first_consecutive_set_bits(probe_point, boundary_idx, cluster_size);\n+        BitMapAssertEqual(probe_point, boundary_idx);\n+      }\n+\n+      \/\/ Verify that find_last_consecutive_set_bits() works\n+      bit_idx = num_set_bits - 1;\n+      probe_point = size - 1;\n+      \/\/ Iterate over all set bits in reverse order\n+      while (bit_idx + 1 >= cluster_size) {\n+        bool cluster_found = true;\n+        for (int i = 1; i < cluster_size; i++) {\n+          if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n+            cluster_found = false;\n+            break;\n+          }\n+        }\n+        if (cluster_found) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx] + 1 - cluster_size;\n+          probe_point = bm.find_last_consecutive_set_bits(probe_point, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point = probe_point + cluster_size - 2;\n+          bit_idx--;\n+        } else {\n+          bit_idx--;\n+        }\n+      }\n+      if (probe_point >= 0) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n+        BitMapAssertEqual(probe_point, (ssize_t) boundary_idx);\n+      }\n+\n+      \/\/ Verify that find_last_consecutive_set_bits() works with the search range bounded at 1\/4 size\n+      bit_idx = num_set_bits - 1;\n+      probe_point = size - 1;\n+      boundary_idx = size \/ 4;\n+      while (bit_idx + 1 >= cluster_size) {\n+        bool cluster_found = true;\n+        for (int i = 1; i < cluster_size; i++) {\n+          if (set_bits[bit_idx] - i != set_bits[bit_idx - i]) {\n+            cluster_found = false;\n+            break;\n+          }\n+        }\n+        if (cluster_found && (set_bits[bit_idx] + 1 - cluster_size > boundary_idx)) {\n+          ssize_t next_expected_cluster = set_bits[bit_idx] + 1 - cluster_size;\n+          probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n+          BitMapAssertEqual(next_expected_cluster, probe_point);\n+          probe_point = probe_point + cluster_size - 2;\n+          bit_idx--;\n+        } else if (set_bits[bit_idx] + 1 - cluster_size <= boundary_idx) {\n+          break;\n+        } else {\n+          bit_idx--;\n+        }\n+      }\n+      if (probe_point > boundary_idx) {\n+        \/\/ Confirm that the last request, which fails to find a cluster, returns sentinel value: boundary_idx\n+        probe_point = bm.find_last_consecutive_set_bits(boundary_idx, probe_point, cluster_size);\n+        BitMapAssertEqual(probe_point, boundary_idx);\n+      }\n+    }\n+\n+    \/\/ Confirm that find_first_consecutive_set_bits() works for a cluster size known not to have any matches\n+    probe_point = bm.find_first_consecutive_set_bits(0, longest_run + 1);\n+    BitMapAssertEqual(probe_point, size);  \/\/ Confirm: failed search returns sentinel: size\n+\n+    probe_point = bm.find_last_consecutive_set_bits(size - 1, longest_run + 1);\n+    BitMapAssertEqual(probe_point, (ssize_t) -1);    \/\/ Confirm: failed search returns sentinel: -1\n+\n+    boundary_idx = 3 * size \/ 4;\n+    probe_point = bm.find_first_consecutive_set_bits(0, boundary_idx, longest_run + 1);\n+    BitMapAssertEqual(probe_point, boundary_idx); \/\/ Confirm: failed search returns sentinel: boundary_idx\n+\n+    boundary_idx = size \/ 4;\n+    probe_point = bm.find_last_consecutive_set_bits(boundary_idx, size - 1, longest_run + 1);\n+    BitMapAssertEqual(probe_point, boundary_idx);           \/\/ Confirm: failed search returns sentinel: boundary_idx\n+  }\n+\n+public:\n+\n+  static bool run_test() {\n+\n+    _success = false;\n+    _assertion_failures = 0;\n+\n+    ShenandoahSimpleBitMap bm_small(SMALL_BITMAP_SIZE);\n+    ShenandoahSimpleBitMap bm_large(LARGE_BITMAP_SIZE);\n+\n+    \/\/ Initial state of each bitmap is all bits are clear.  Confirm this:\n+    ssize_t set_bits_0[1] = { 0 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_0, 0);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_0, 0);\n+\n+    bm_small.set_bit(5);\n+    bm_small.set_bit(63);\n+    bm_small.set_bit(128);\n+    ssize_t set_bits_1[3] = { 5, 63, 128 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_1, 3);\n+\n+    bm_large.set_bit(5);\n+    bm_large.set_bit(63);\n+    bm_large.set_bit(128);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_1, 3);\n+\n+    \/\/ Test some consecutive bits\n+    bm_small.set_bit(140);\n+    bm_small.set_bit(141);\n+    bm_small.set_bit(142);\n+\n+    bm_small.set_bit(253);\n+    bm_small.set_bit(254);\n+    bm_small.set_bit(255);\n+\n+    bm_small.set_bit(271);\n+    bm_small.set_bit(272);\n+\n+    bm_small.set_bit(320);\n+    bm_small.set_bit(321);\n+    bm_small.set_bit(322);\n+\n+    bm_small.set_bit(361);\n+\n+    ssize_t set_bits_2[15] = { 5, 63, 128, 140, 141, 142, 253, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_2, 15);\n+\n+    bm_large.set_bit(140);\n+    bm_large.set_bit(141);\n+    bm_large.set_bit(142);\n+\n+    bm_large.set_bit(1021);\n+    bm_large.set_bit(1022);\n+    bm_large.set_bit(1023);\n+\n+    bm_large.set_bit(1051);\n+\n+    bm_large.set_bit(1280);\n+    bm_large.set_bit(1281);\n+    bm_large.set_bit(1282);\n+\n+    bm_large.set_bit(1300);\n+    bm_large.set_bit(1301);\n+    bm_large.set_bit(1302);\n+\n+    ssize_t set_bits_3[16] = { 5, 63, 128, 140, 141, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_3, 16);\n+\n+    \/\/ Test clear_bit\n+    bm_small.clear_bit(141);\n+    bm_small.clear_bit(253);\n+    ssize_t set_bits_4[13] = { 5, 63, 128, 140, 142, 254, 255, 271, 272, 320, 321, 322, 361 };\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_4, 13);\n+\n+    bm_large.clear_bit(5);\n+    bm_large.clear_bit(63);\n+    bm_large.clear_bit(128);\n+    bm_large.clear_bit(141);\n+    ssize_t set_bits_5[12] = { 140, 142, 1021, 1022, 1023, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_5, 12);\n+\n+    \/\/ Look for large island of contiguous surrounded by smaller islands of contiguous\n+    bm_large.set_bit(1024);\n+    bm_large.set_bit(1025);  \/\/ size-5 island from 1021 to 1025\n+    bm_large.set_bit(1027);\n+    bm_large.set_bit(1028);\n+    bm_large.set_bit(1029);\n+    bm_large.set_bit(1030);\n+    bm_large.set_bit(1031);\n+    bm_large.set_bit(1032);  \/\/ size-6 island from 1027 to 1032\n+    bm_large.set_bit(1034);\n+    bm_large.set_bit(1035);\n+    bm_large.set_bit(1036);  \/\/ size-3 island from 1034 to 1036\n+    ssize_t set_bits_6[23] = {  140,  142, 1021, 1022, 1023, 1024, 1025, 1027, 1028, 1029, 1030,\n+                               1031, 1032, 1034, 1035, 1036, 1051, 1280, 1281, 1282, 1300, 1301, 1302 };\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_6, 23);\n+\n+    \/\/ Test that entire bitmap word (from 1024 to 1088) is 1's\n+    ssize_t set_bits_7[76];\n+    set_bits_7[0] = 140;\n+    set_bits_7[1] = 142;\n+    set_bits_7[2] = 1021;\n+    set_bits_7[3] = 1022;\n+    set_bits_7[4] = 1023;\n+    size_t bit_idx = 5;\n+    for (ssize_t i = 1024; i <= 1088; i++) {\n+      bm_large.set_bit(i);\n+      set_bits_7[bit_idx++] = i;\n+    }\n+    set_bits_7[bit_idx++] = 1280;\n+    set_bits_7[bit_idx++] = 1281;\n+    set_bits_7[bit_idx++] = 1282;\n+    set_bits_7[bit_idx++] = 1300;\n+    set_bits_7[bit_idx++] = 1301;\n+    set_bits_7[bit_idx++] = 1302;\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_7, bit_idx);\n+\n+    \/\/ Test clear_all()\n+    bm_small.clear_all();\n+    bm_large.clear_all();\n+\n+    verifyBitMapState(bm_small, SMALL_BITMAP_SIZE, set_bits_0, 0);\n+    verifyBitMapState(bm_large, LARGE_BITMAP_SIZE, set_bits_0, 0);\n+\n+    _success = true;\n+    return true;\n+  }\n+\n+};\n+\n+TEST(BasicShenandoahSimpleBitMapTest, minimum_test) {\n+\n+  bool result = ShenandoahSimpleBitMapTest::run_test();\n+  ASSERT_EQ(result, true);\n+  ASSERT_EQ(_success, true);\n+  ASSERT_EQ(_assertion_failures, (size_t) 0);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":451,"deletions":0,"binary":false,"changes":451,"status":"added"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/istream.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename BlockClass>\n+class BlockInputStream : public inputStream {\n+  BlockClass _input;\n+ public:\n+  template<typename... Arg>\n+  BlockInputStream(Arg... arg)\n+    : _input(arg...) {\n+    set_input(&_input);\n+  }\n+};\n+\n+#define EXPECT_MEMEQ(s1, s2, len) \\\n+  EXPECT_PRED_FORMAT3(CmpHelperMEMEQ, s1, s2, len)\n+\/\/ cf. ::testing::internal::CmpHelperSTREQ\n+\n+testing::AssertionResult CmpHelperMEMEQ(const char* s1_expression,\n+                                        const char* s2_expression,\n+                                        const char* len_expression,\n+                                        const char* s1, const char* s2,\n+                                        size_t len) {\n+  if (s1 == nullptr || s2 == nullptr) {\n+    return testing::internal::CmpHelperEQ(s1_expression, s2_expression,\n+                                          s1, s2);\n+  }\n+  int c = ::memcmp(s1, s2, len);\n+  if (c == 0) {\n+    return testing::AssertionSuccess();\n+  }\n+  ::std::string str1, str2;\n+  for (auto which = 0; which <= 1; which++) {\n+    auto  s   = which ? s1   : s2;\n+    auto &str = which ? str1 : str2;\n+    std::stringstream buf;\n+    buf << \"{\";\n+    for (size_t i = 0; i < len; i++) {\n+      char c = s[i];\n+      switch (c) {\n+      case '\\0':  buf << \"\\\\0\"; break;\n+      case '\\n':  buf << \"\\\\n\"; break;\n+      case '\\\\':  buf << \"\\\\\\\\\"; break;\n+      default:    buf << c; break;\n+      }\n+    }\n+    buf << \"}[\" << len_expression << \"=\" << len << \"]\";\n+    str = buf.str();\n+  }\n+  return testing::internal::CmpHelperSTREQ(s1_expression, s2_expression,\n+                                           str1.c_str(), str2.c_str());\n+}\n+\n+static int firstdiff(char* b1, char* b2, int blen) {\n+  for (int i = 0; i < blen; i++) {\n+    if (b1[i] != b2[i])  return i;\n+  }\n+  return -1;\n+}\n+\n+static char* get_temp_file(bool VERBOSE, const char* filename) {\n+  const char* tmp_dir = os::get_temp_directory();\n+  const char* file_sep = os::file_separator();\n+  size_t temp_file_len = strlen(tmp_dir) + strlen(file_sep) + strlen(filename) + 28;\n+  char* temp_file = NEW_C_HEAP_ARRAY(char, temp_file_len, mtInternal);\n+  int ret = jio_snprintf(temp_file, temp_file_len, \"%s%spid%d.%s\",\n+                         tmp_dir, file_sep,\n+                         os::current_process_id(), filename);\n+  if (VERBOSE)  tty->print_cr(\"temp_file = %s\", temp_file);\n+  return temp_file;\n+}\n+\n+static const char* get_temp_file(bool VERBOSE) {\n+  static const char* temp_file = get_temp_file(VERBOSE, \"test_istream\");\n+  return temp_file;\n+}\n+\n+#define EIGHTY 80\n+#define LC0(x)     ('\/' + (((unsigned)(x)+1) % EIGHTY))\n+#define LC(line,col)  LC0((col) * (line))\n+\n+#define COLS 30\n+\n+static int cases, total, zeroes;\n+#ifdef ASSERT\n+#define istream_coverage_mode(mode, a,b,c) \\\n+  inputStream::coverage_mode(mode, a,b,c)\n+#else\n+#define istream_coverage_mode(mode, a,b,c)\n+#endif\n+\n+\/\/ Fill in a test pattern of ascii characters.\n+\/\/ Each line is ncols long, plus a line termination of lelen (1 or 2).\n+\/\/ Each character is a fixed, static function of the line and column.\n+\/\/ This enables test logic to predict exactly what will be read in each line.\n+static void fill_pattern(bool VERBOSE,\n+                         char* pat, int patlen, int ncols, int lelen,\n+                         int& full_lines, int& partial_line,\n+                         const char* &line_end,\n+                         const char* &partial_line_end) {\n+  full_lines = partial_line = 0;\n+  for (int i = 0; i < patlen; i++) {\n+    int line = (i \/ (ncols+lelen)) + 1;  \/\/ 1-based line number\n+    int col  = (i % (ncols+lelen)) + 1;  \/\/ 1-based column number\n+    if (col <= ncols) {\n+      pat[i] = LC(line, col);\n+      partial_line = 1;\n+    } else if (col < ncols+lelen) {\n+      pat[i] = i == patlen - 1 ? '!' : '%';\n+      partial_line = 1;\n+    } else {\n+      assert(col == ncols+lelen, \"\");\n+      pat[i] = '!';\n+      full_lines++;\n+      partial_line = 0;\n+    }\n+  }\n+  pat[patlen] = '\\0';\n+  if (VERBOSE)  tty->print_cr(\"PATTERN=%d+%d[%s]\",\n+                              full_lines, partial_line, pat);\n+  for (int i = 0; i < patlen; i++) {\n+    assert(pat[i] != '%' || (i+1 < patlen && pat[i+1] == '!'), \"\");\n+    if (pat[i] == '!')  pat[i] = '\\n';\n+    if (pat[i] == '%')  pat[i] = '\\r';\n+  }\n+  assert(pat[patlen-1] != '\\r', \"\");\n+\n+  line_end = (lelen == 2 ? \"\\r\\n\" : \"\\n\");\n+  int partial_line_bytes = patlen - (full_lines * (ncols + lelen));\n+  assert(partial_line_bytes < ncols + lelen, \"\");\n+  partial_line_end = (partial_line_bytes == ncols + 1) ? \"\\n\" : \"\";\n+}\n+\n+static const int MAX_PATLEN = COLS * (COLS-1);\n+\n+static void istream_test_driver(const bool VERBOSE,\n+                                const int patlen,\n+                                const int ncols,\n+                                const int lelen,\n+                                const bool TEST_SET_POSITION,\n+                                const bool TEST_PUSH_BACK,\n+                                const bool TEST_EXPAND_REDUCE) {\n+  DEBUG_ONLY( istream_coverage_mode(VERBOSE ? 2 : 1, cases, total, zeroes) );\n+  const char* temp_file = get_temp_file(VERBOSE);\n+  unlink(temp_file);\n+  char pat[MAX_PATLEN+1];\n+  int full_lines = 0, partial_line = 0;\n+  const char* line_end = \"\\n\";\n+  const char* partial_line_end = \"\";\n+  fill_pattern(VERBOSE, pat, patlen, ncols, lelen,\n+               full_lines, partial_line,\n+               line_end, partial_line_end);\n+\n+  char pat2[sizeof(pat)];  \/\/ copy of pat to help detect scribbling\n+  memcpy(pat2, pat, sizeof(pat));\n+  \/\/ Make three kinds of stream and test them all.\n+  MemoryInput _min(pat2, patlen);\n+  inputStream sin(&_min);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&sin);\n+    sin.dump(\"sin\");\n+  }\n+  {\n+    fileStream tfs(temp_file);\n+    guarantee(tfs.is_open(), \"cannot open temp file\");\n+    tfs.write(pat, patlen);\n+  }\n+  BlockInputStream<FileInput> fin(temp_file);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&fin);\n+    fin.dump(\"fin\");\n+  }\n+  BlockInputStream<MemoryInput> min(&pat2[0], patlen);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&min);\n+    sin.dump(\"min\");\n+  }\n+  inputStream* ins[] = { &sin, &fin, &min };\n+  const char* in_names[] = { \"sin\", \"fin\", \"min\" };\n+  const char* test_mode = (TEST_SET_POSITION\n+                           ? (!TEST_PUSH_BACK ? \"(seek)\" : \"(seek\/push)\")\n+                           : TEST_EXPAND_REDUCE\n+                           ? (!TEST_PUSH_BACK ? \"(exp\/red)\" : \"(exp\/red\/push)\")\n+                           : (!TEST_PUSH_BACK ? \"(plain)\" : \"(push)\"));\n+  for (int which = 0; which < 3; which++) {\n+    inputStream& in = *ins[which];\n+    const char* in_name = in_names[which];\n+    int lineno;\n+    char* lp = (char*)\"--\";\n+#define LPEQ                                                    \\\n+    in_name << test_mode                                        \\\n+            << \" ncols=\" << ncols << \" lelen=\" << lelen         \\\n+            << \" full=\" << full_lines << \" lineno=\" << lineno   \\\n+            << \" [\" << lp << \"]\" << (in.dump(\"expect\"), \"\")\n+    if (VERBOSE)\n+      tty->print_cr(\"testing %s%s patlen=%d ncols=%d full_lines=%d partial_line=%d\",\n+                    in_name, test_mode,\n+                    patlen, ncols, full_lines, partial_line);\n+    int pos_to_set = 0, line_to_set = 1;  \/\/ for TEST_SET_POSITION only\n+    for (int phase = 0; phase <= (TEST_SET_POSITION ? 1 : 0); phase++) {\n+      lineno = 1;\n+      for (; lineno <= full_lines + partial_line; lineno++) {\n+        EXPECT_EQ(-1, firstdiff(pat, pat2, patlen + 1));\n+        if (VERBOSE)  in.dump(\"!done?\");\n+        bool done = in.done();\n+        EXPECT_TRUE(!done)  <<LPEQ;\n+        if (done)  break;\n+        lp = in.current_line();\n+        const char* expect_endl =\n+          (lineno <= full_lines) ? line_end : partial_line_end;\n+\n+        bool verify_lp = true;\n+        if (verify_lp) {\n+          int actual_lineno = (int) in.lineno();\n+          if (VERBOSE)  in.dump(\"CL    \");\n+          EXPECT_EQ(actual_lineno, lineno)  <<LPEQ;\n+          int len = (int) in.current_line_length();\n+          EXPECT_EQ(len, (int) strlen(lp))  <<LPEQ;\n+          int expect_len = ncols;\n+          if (lineno > full_lines)\n+            expect_len = MIN2(ncols, patlen % (ncols+lelen));\n+          EXPECT_EQ(len, expect_len)  <<LPEQ;\n+          for (int j = 0; j < len; j++) {\n+            int lc = LC(lineno, j+1);   \/\/ 1-based column\n+            EXPECT_EQ(lc, lp[j])  <<LPEQ;\n+          }\n+          if (len != expect_len || len != (int)strlen(lp)) {\n+            return;  \/\/ no error cascades please\n+          }\n+        }\n+        if (VERBOSE)  in.dump(\"next  \");\n+        in.next();\n+      }\n+\n+      for (int done_test = 0; done_test <= 3; done_test++) {\n+        if (done_test == 2)  in.set_done();\n+        lp = in.current_line();  \/\/ should be empty line\n+        if (VERBOSE)  in.dump(\"done!!\");\n+        EXPECT_TRUE(lp != nullptr);\n+        EXPECT_TRUE(in.done())  <<LPEQ;\n+        if (!in.done())  break;\n+        EXPECT_EQ((int)in.current_line_length(), 0)   <<LPEQ;\n+        EXPECT_EQ(strlen(lp), in.current_line_length())  <<LPEQ;\n+        bool extra_next = in.next();\n+        EXPECT_TRUE(!extra_next)  <<LPEQ;\n+      }\n+\n+      \/\/ no memory side effects\n+      EXPECT_EQ(-1, firstdiff(pat, pat2, patlen + 1));\n+    }\n+  }\n+  unlink(temp_file);\n+}\n+\n+static void istream_test_driver(const bool VERBOSE,\n+                                const bool TEST_SET_POSITION,\n+                                const bool TEST_PUSH_BACK,\n+                                const bool TEST_EXPAND_REDUCE) {\n+  ResourceMark rm;\n+  int patlen = MAX_PATLEN;\n+  const bool SHORT_TEST = false;\n+  const int SHORT_NCOLS = 1, SHORT_PATLEN = 37;\n+  if (SHORT_TEST)  patlen = SHORT_PATLEN;\n+  for (int ncols = 0; ncols <= patlen; ncols++) {\n+    if (SHORT_TEST) {\n+      if (ncols < SHORT_NCOLS)  ncols = SHORT_NCOLS;\n+      if (ncols > SHORT_NCOLS)  break;\n+    } else if (ncols > COLS && ncols < patlen - COLS) {\n+      ncols += ncols \/ 7;\n+      if (ncols > patlen - COLS)  ncols = (patlen - COLS);\n+    }\n+    for (int lelen = 1; lelen <= 2; lelen++) {  \/\/ try both kinds of newline\n+      istream_test_driver(VERBOSE,\n+                          patlen, ncols, lelen,\n+                          TEST_SET_POSITION, TEST_PUSH_BACK, TEST_EXPAND_REDUCE);\n+    }\n+  }\n+}\n+\n+TEST_VM(istream, basic) {\n+  const bool VERBOSE = false;\n+  istream_test_driver(VERBOSE, false, false, false);\n+}\n+\n+TEST_VM(istream, coverage) {\n+  const bool VERBOSE = false;\n+#ifdef ASSERT\n+  istream_coverage_mode(0, cases, total, zeroes);\n+  if (cases == 0)  return;\n+  if (VERBOSE || zeroes != 0)\n+    istream_coverage_mode(-1, cases, total, zeroes);\n+  EXPECT_EQ(zeroes, 0) << \"zeroes: \" << zeroes << \"\/\" << cases;\n+#endif \/\/ASSERT\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_istream.cpp","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,0 @@\n-serviceability\/dcmd\/thread\/PrintConcurrentLocksTest.java 8308033 generic-all\n-serviceability\/dcmd\/thread\/PrintTest.java 8308033 generic-all\n-serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java 8308033 generic-all\n-serviceability\/tmtools\/jstack\/DaemonThreadTest.java 8308033 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isCollectionUsageThresholdExceeded\/isexceeded002\/TestDescription.java 8298302 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isCollectionUsageThresholdExceeded\/isexceeded002\/TestDescription.java 8298302 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+compiler\/codecache\/CheckLargePages.java 8332654 linux-x64\n@@ -83,0 +84,2 @@\n+compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java 8332369 generic-all\n+\n@@ -145,1 +148,1 @@\n-serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 linux-all,windows-x64,aix-ppc64\n+serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,7 @@\n+hotspot_runtime_non_cds_mode = \\\n+  runtime \\\n+  -runtime\/cds\/CheckSharingWithDefaultArchive.java \\\n+  -runtime\/cds\/appcds\/dynamicArchive\/DynamicSharedSymbols.java \\\n+  -runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java \\\n+  -runtime\/cds\/appcds\/jcmd\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy;\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8310159\n+ * @summary Test large arrayCopy.\n+ *\n+ * @run main\/timeout=600 compiler.arraycopy.TestArrayCopyDisjointLarge\n+ *\n+ *\/\n+\n+public class TestArrayCopyDisjointLarge {\n+\n+    public static final int ARRLEN = 4194304;\n+    public static int fromPos, toPos;\n+    public static byte[] fromByteArr, toByteArr;\n+\n+    public static void setup() {\n+        fromPos = 0;\n+        toPos = 0;\n+\n+        fromByteArr = new byte[ARRLEN];\n+        toByteArr = new byte[ARRLEN];\n+        for (int i = 0 ; i < ARRLEN ; i++) {\n+            fromByteArr[i] = (byte)i;\n+        }\n+    }\n+\n+    public static void validate(String msg, byte[] toByteArr, int length, int fromPos, int toPos) {\n+        for(int i = 0 ; i < length; i++) {\n+            if (fromByteArr[i + fromPos] != toByteArr[i + toPos]) {\n+                System.out.println(msg + \"[\" + toByteArr.getClass() + \"] Result mismtach at i = \" + i\n+                                + \" expected = \" + fromByteArr[i + fromPos]\n+                                + \" actual   = \" + toByteArr[i + toPos]\n+                                + \" fromPos = \" + fromPos\n+                                + \" toPos = \" + toPos);\n+                throw new Error(\"Fail\");\n+            }\n+        }\n+    }\n+\n+    public static void testByte(int length, int fromPos, int toPos) {\n+        System.arraycopy(fromByteArr, fromPos, toByteArr, toPos, length);\n+        validate(\" Test ByteArr \", toByteArr, length, fromPos, toPos);\n+    }\n+\n+    public static void main(String [] args) {\n+        int base_size = 2621440;\n+        Random r = new Random(1024);\n+        int [] lengths = {base_size - 1, base_size, base_size + 1, base_size + 63, base_size + 64,\n+                                base_size + 65, base_size + 255, base_size + 256, base_size + 257,\n+                                base_size + r.nextInt(2048)};\n+        setup();\n+\n+        for (int i = 0 ; i < 20 ; i++ ) {\n+            testByte(lengths[i % lengths.length], 0, 0);\n+            testByte(lengths[i % lengths.length], 0, 9);\n+            testByte(lengths[i % lengths.length], 9, 0);\n+            testByte(lengths[i % lengths.length], 9, 9);\n+            testByte(lengths[i % lengths.length], r.nextInt(2048) , r.nextInt(2048));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyDisjointLarge.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8329258\n+ * @summary Test correct execution of the tail call at the end of the arraycopy stub.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test\n+ *                   compiler.arraycopy.TestTailCallInArrayCopyStub\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+StressGCM -XX:+StressLCM -XX:StressSeed=75451718\n+ *                   -XX:CompileCommand=quiet -XX:CompileCommand=compileonly,*::test\n+ *                   compiler.arraycopy.TestTailCallInArrayCopyStub\n+ *\/\n+\n+package compiler.arraycopy;\n+\n+public class TestTailCallInArrayCopyStub {\n+\n+    public static void test(byte[] src, byte[] dst) {\n+        try {\n+            System.arraycopy(src, -1, dst, 0, src.length);\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        byte[] array = new byte[5];\n+        for (int i = 0; i < 10_000; ++i) {\n+            test(array, array);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestTailCallInArrayCopyStub.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302850\n+ * @summary Tests that an array clone call that has been compiled with C1\n+ *          handles null values correctly.\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:TieredStopAtLevel=1\n+ *                   -XX:CompileOnly=compiler.c1.TestNullArrayClone::testClone* -XX:+UnlockExperimentalVMOptions\n+ *                   compiler.c1.TestNullArrayClone\n+ *\/\n+package compiler.c1;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class TestNullArrayClone {\n+    static final int ITER = 2000; \/\/ ~ Tier3CompileThreshold\n+    static final int ARRAY_SIZE = 999;\n+\n+    public static void main(String[] args) {\n+        testInts();\n+        testLongs();\n+        testBytes();\n+    }\n+\n+    private static void testInts() {\n+        final int[] arr = new int[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            int[] result = testClonePrimitiveInt(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveInt(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    private static void testLongs() {\n+        final long[] arr = new long[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = ThreadLocalRandom.current().nextLong();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            long[] result = testClonePrimitiveLong(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveLong(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    private static void testBytes() {\n+        final byte[] arr = new byte[ARRAY_SIZE];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte) ThreadLocalRandom.current().nextInt();\n+        }\n+\n+        for (int i = 0; i < ITER; i++) {\n+            byte[] result = testClonePrimitiveBytes(arr);\n+            if (result.length != arr.length) {\n+                throw new RuntimeException(\"Unexpected clone length: source array length \" + arr.length + \" != clone array length \" + result.length);\n+            }\n+            for (int j = 0; j < arr.length; j++) {\n+                if (result[j] != arr[j]) {\n+                    throw new RuntimeException(\"Unexpected result: \" + result[j] + \" != \" + j);\n+                }\n+            }\n+        }\n+\n+        try {\n+            testClonePrimitiveBytes(null);\n+            throw new RuntimeException(\"Expected NullPointerException to be thrown\");\n+        } catch (NullPointerException e) {\n+        }\n+    }\n+\n+    static int[] testClonePrimitiveInt(int[] ints) {\n+        return ints.clone();\n+    }\n+\n+    static long[] testClonePrimitiveLong(long[] longs) {\n+        return longs.clone();\n+    }\n+\n+    static byte[] testClonePrimitiveBytes(byte[] bytes) {\n+        return bytes.clone();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestNullArrayClone.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -30,1 +30,2 @@\n- * @run main\/othervm -Xbatch -XX:CompileCommand=option,*::*,bool,Vectorize,true -XX:+PrintOpto -XX:+TraceLoopOpts compiler.c2.TestFindNode\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=option,*::*,bool,Vectorize,true -XX:CompileCommand=memlimit,compiler.c2.TestFindNode::*,0\n+ *                   -XX:+PrintOpto -XX:+TraceLoopOpts compiler.c2.TestFindNode\n@@ -34,0 +35,2 @@\n+\/\/ Note; we disable the implicit memory limit of 1G in debug JVMs until JDK-8331283 is fixed\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestFindNode.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+\/*\n+ * @test\n+ * @bug 8318446 8331085\n+ * @summary Test merge stores, when \"adr_type() == nullptr\" because of TOP somewhere in the address.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresNullAdrType::test\n+ *                   -XX:-TieredCompilation -Xcomp\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+StressCCP\n+ *                   -XX:RepeatCompilation=1000\n+ *                   compiler.c2.TestMergeStoresNullAdrType\n+ * @run main compiler.c2.TestMergeStoresNullAdrType\n+ *\/\n+\n+public class TestMergeStoresNullAdrType {\n+    static int arr[] = new int[100];\n+\n+    static void test() {\n+        boolean b = false;\n+        for (int k = 269; k > 10; --k) {\n+            b = b;\n+            int j = 6;\n+            while ((j -= 3) > 0) {\n+                if (b) {\n+                } else {\n+                    arr[j] >>= 2;\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresNullAdrType.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330795\n+ * @summary Check that Reduce Allocation Merges doesn't crash when CompressedClassPointers\n+ *          is disabled and there is an access to Klass \"field\" through the phi.\n+ * @requires vm.bits == 64 & vm.flagless & vm.compiler2.enabled & vm.opt.final.EliminateAllocations\n+ * @run main\/othervm -XX:CompileCommand=dontinline,*TestReduceAllocationAndLoadKlass*::test\n+ *                   -XX:CompileCommand=compileonly,*TestReduceAllocationAndLoadKlass*::test\n+ *                   -XX:CompileCommand=compileonly,*Shape*::*init*\n+ *                   -XX:CompileCommand=compileonly,*Point*::*init*\n+ *                   -XX:CompileCommand=exclude,*TestReduceAllocationAndLoadKlass*::dummy\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:-UseCompressedClassPointers\n+ *                   -Xbatch\n+ *                   -Xcomp\n+ *                   -server\n+ *                   compiler.c2.TestReduceAllocationAndLoadKlass\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestReduceAllocationAndLoadKlass {\n+    public static void main(String[] args) {\n+        Point p = new Point();\n+        Line q = new Line();\n+\n+        test(true);\n+        test(false);\n+    }\n+\n+    static Class test(boolean cond) {\n+        Object p = cond ? dummy() : new Line();\n+        return p.getClass();\n+    }\n+\n+    static Point dummy() { return new Point(); }\n+\n+    static class Shape { }\n+    static class Point extends Shape { }\n+    static class Line extends Shape { }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReduceAllocationAndLoadKlass.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330247\n+ * @summary Check that Reduce Allocation Merges doesn't try to reduce non-exact allocations.\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires vm.debug & vm.flagless & vm.compiler2.enabled & vm.opt.final.EliminateAllocations\n+ * @run main\/othervm -XX:CompileCommand=compileonly,*TestReduceAllocationAndNonExactAllocate*::test\n+ *                   -XX:CompileCommand=compileonly,*::allocateInstance\n+ *                   -XX:CompileCommand=dontinline,*TestReduceAllocationAndNonExactAllocate*::*\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+TraceReduceAllocationMerges\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -Xcomp\n+ *                   -server\n+ *                   compiler.c2.TestReduceAllocationAndNonExactAllocate\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestReduceAllocationAndNonExactAllocate {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) {\n+        try {\n+            if (test(20, Integer.class) != 2032) {\n+                throw new RuntimeException(\"Expected the value to be 2032.\");\n+            }\n+        }\n+        catch (InstantiationException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public static int test(int val, Class<?> c) throws InstantiationException {\n+        Object p = null;\n+\n+        if (val == 20) {\n+            p = UNSAFE.allocateInstance(c);\n+        }\n+\n+        dummy();\n+        return p != null ? 2032 : 3242;\n+    }\n+\n+    static int dummy() { return 42; }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReduceAllocationAndNonExactAllocate.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8330565\n+ * @summary Check that Reduce Allocation Merges does not crash when legacy\n+ *          string concatenation optimization is applied.\n+ * @requires vm.flagless & vm.compiler2.enabled & vm.opt.final.EliminateAllocations\n+ * @compile -XDstringConcat=inline TestReduceAllocationAndNullableLoads.java\n+ * @run main\/othervm -XX:CompileCommand=compileonly,*TestReduceAllocationAndNullableLoads*::*\n+ *                   -XX:CompileCommand=dontinline,*TestReduceAllocationAndNullableLoads*::*\n+ *                   -XX:-TieredCompilation -Xcomp -server\n+ *                   compiler.c2.TestReduceAllocationAndNullableLoads\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestReduceAllocationAndNullableLoads {\n+    public static void main(String[] args) {\n+        try {\n+            \/\/ Load \/ initialize these classes\n+            IllegalArgumentException e = new IllegalArgumentException(\"Reason is: \");\n+            StringBuilder xixi = new StringBuilder(\"abc\");\n+\n+            \/\/ The actual test\n+            test(new char[] { 'a', 'b', 'c' });\n+        } catch (IllegalArgumentException e) { }\n+    }\n+\n+    public static void test(char[] chars) throws IllegalArgumentException {\n+        String reason = null;\n+\n+        for (int i = 0; i < chars.length; i++) {\n+            char c = chars[i];\n+\n+            if (c == 'a') {\n+                reason = \"first entry\" + i;\n+                break;\n+            }\n+        }\n+\n+        if (reason != null) {\n+            throw new IllegalArgumentException(\"Reason is: \" + reason);\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReduceAllocationAndNullableLoads.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUninitializedKlassField.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -484,0 +484,3 @@\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -493,0 +496,3 @@\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -525,0 +531,8 @@\n+    @IR(counts = { IRNode.ADD_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.RSHIFT_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.SUB_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -545,0 +559,8 @@\n+    @IR(counts = { IRNode.ADD_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.RSHIFT_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.SUB_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -665,0 +687,3 @@\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -674,0 +699,3 @@\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -686,0 +714,5 @@\n+    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -698,0 +731,5 @@\n+    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -707,0 +745,3 @@\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -716,0 +757,3 @@\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -725,0 +769,3 @@\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -737,0 +784,5 @@\n+    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -749,0 +801,5 @@\n+    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -758,0 +815,3 @@\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -767,0 +827,3 @@\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -776,0 +839,3 @@\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -788,0 +854,5 @@\n+    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -800,0 +871,5 @@\n+    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n@@ -809,0 +885,3 @@\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestIntVect.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332245\n+ * @summary C2: missing record_for_ign() call in GraphKit::must_be_not_null()\n+ *\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestBackToBackMustBeNotNull\n+ *\/\n+\n+package compiler.c2.irTests;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Field;\n+import compiler.lib.ir_framework.*;\n+\n+\n+public class TestBackToBackMustBeNotNull {\n+    static final jdk.internal.misc.Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static final long F_OFFSET;\n+    private static A fieldA = new A();\n+\n+    static {\n+        try {\n+            Field fField = A.class.getDeclaredField(\"f\");\n+            F_OFFSET = UNSAFE.objectFieldOffset(fField);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.ITER_GVN1 }, counts = { IRNode.IF, \"1\" })\n+    private static void test1() {\n+        final Object o1 = UNSAFE.getReference(fieldA, F_OFFSET);\n+        final Object o2 = UNSAFE.getReference(fieldA, F_OFFSET);\n+        notInlined(o1, o2);\n+    }\n+\n+    @DontInline\n+    private static void notInlined(Object o1, Object o2) {\n+\n+    }\n+\n+    static class A {\n+        Object f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestBackToBackMustBeNotNull.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -120,1 +120,1 @@\n-    @IR(failOn = {IRNode.COUNTTRAILINGZEROS_VL})\n+    @IR(failOn = {IRNode.COUNT_TRAILING_ZEROS_VL})\n@@ -128,1 +128,1 @@\n-    @IR(failOn = {IRNode.COUNTLEADINGZEROS_VL})\n+    @IR(failOn = {IRNode.COUNT_LEADING_ZEROS_VL})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDisableAutoVectOpcodes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n- * @requires ((os.arch==\"amd64\" | os.arch==\"x86_64\") & (vm.opt.UseSSE == \"null\" | vm.opt.UseSSE > 3)) | os.arch==\"aarch64\"\n+ * @requires ((os.arch==\"amd64\" | os.arch==\"x86_64\") & (vm.opt.UseSSE == \"null\" | vm.opt.UseSSE > 3)) | os.arch==\"aarch64\" |\n+ *           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*v,.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizeURShiftSubword.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires vm.debug == true & vm.bits == 64 & vm.compiler2.enabled & vm.opt.final.UseCompressedOops & vm.opt.final.EliminateAllocations\n+ * @requires vm.debug == true & vm.flagless & vm.bits == 64 & vm.compiler2.enabled & vm.opt.final.EliminateAllocations\n@@ -42,9 +42,38 @@\n-        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\",\n-                                   \"-XX:+ReduceAllocationMerges\",\n-                                   \"-XX:+TraceReduceAllocationMerges\",\n-                                   \"-XX:+DeoptimizeALot\",\n-                                   \"-XX:CompileCommand=inline,*::charAt*\",\n-                                   \"-XX:CompileCommand=inline,*PicturePositions::*\",\n-                                   \"-XX:CompileCommand=inline,*Point::*\",\n-                                   \"-XX:CompileCommand=inline,*Nested::*\",\n-                                   \"-XX:CompileCommand=exclude,*::dummy*\");\n+        TestFramework framework = new TestFramework();\n+\n+        Scenario scenario0 = new Scenario(0, \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:+UseCompressedOops\",\n+                                             \"-XX:+UseCompressedClassPointers\",\n+                                             \"-XX:CompileCommand=inline,*::charAt*\",\n+                                             \"-XX:CompileCommand=inline,*PicturePositions::*\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        Scenario scenario1 = new Scenario(1, \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:+UseCompressedOops\",\n+                                             \"-XX:-UseCompressedClassPointers\",\n+                                             \"-XX:CompileCommand=inline,*::charAt*\",\n+                                             \"-XX:CompileCommand=inline,*PicturePositions::*\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        Scenario scenario2 = new Scenario(2, \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:-UseCompressedOops\",\n+                                             \"-XX:CompileCommand=inline,*::charAt*\",\n+                                             \"-XX:CompileCommand=inline,*PicturePositions::*\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        framework.addScenarios(scenario0, scenario1, scenario2).start();\n@@ -97,1 +126,2 @@\n-                 \"testLoadNarrowKlass_C2\",\n+                 \"testLoadKlassFromCast_C2\",\n+                 \"testLoadKlassFromPhi_C2\",\n@@ -153,1 +183,2 @@\n-        Asserts.assertEQ(testLoadNarrowKlass_Interp(cond1),                         testLoadNarrowKlass_C2(cond1));\n+        Asserts.assertEQ(testLoadKlassFromCast_Interp(cond1),                       testLoadKlassFromCast_C2(cond1));\n+        Asserts.assertEQ(testLoadKlassFromPhi_Interp(cond1),                        testLoadKlassFromPhi_C2(cond1));\n@@ -774,1 +805,2 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" } )\n+    @IR(counts = { IRNode.ALLOC, \"2\" }, applyIf = {\"UseCompressedOops\", \"true\"} )\n+    @IR(failOn = { IRNode.ALLOC }, applyIf = {\"UseCompressedOops\", \"false\"} )\n@@ -776,2 +808,2 @@\n-    \/\/ be removed because the Phi merging them will have a DecodeN user - which\n-    \/\/ currently isn't supported.\n+    \/\/ be removed, if CompressedOops is enabled, because the Phi merging them will\n+    \/\/ have a DecodeN user - which currently isn't supported.\n@@ -1261,1 +1293,1 @@\n-    Class testLoadNarrowKlass(boolean cond1) {\n+    Class testLoadKlassFromCast(boolean cond1) {\n@@ -1273,3 +1305,2 @@\n-    \/\/ The allocation won't be reduced because we don't support NarrowKlass\n-    \/\/ loads under CastPPs.\n-    Class testLoadNarrowKlass_C2(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+    \/\/ The allocation won't be reduced because we don't support [Narrow]Klass loads\n+    Class testLoadKlassFromCast_C2(boolean cond1) { return testLoadKlassFromCast(cond1); }\n@@ -1278,1 +1309,22 @@\n-    Class testLoadNarrowKlass_Interp(boolean cond1) { return testLoadNarrowKlass(cond1); }\n+    Class testLoadKlassFromCast_Interp(boolean cond1) { return testLoadKlassFromCast(cond1); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    Class testLoadKlassFromPhi(boolean cond1) {\n+        Shape p = new Square(20);\n+\n+        if (cond1) {\n+            p = new Circle(10);\n+        }\n+\n+        return p.getClass();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The allocation won't be reduced because we don't support [Narrow]Klass loads\n+    Class testLoadKlassFromPhi_C2(boolean cond1) { return testLoadKlassFromPhi(cond1); }\n+\n+    @DontCompile\n+    Class testLoadKlassFromPhi_Interp(boolean cond1) { return testLoadKlassFromPhi(cond1); }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":72,"deletions":20,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestConvertImplicitNullCheck.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331033\n+ * @summary EA fails with \"EA unexpected CallLeaf unsafe_setmemory\" after JDK-8329331\n+ * @requires vm.compMode != \"Xint\"\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation  Test8331033\n+ *\n+ *\/\n+import java.lang.foreign.*;\n+\n+class MyClass {\n+  public int field1;\n+  public int field2;\n+  public int field3;\n+  public int field4;\n+\n+  public MyClass(int field1, int field2, int field3, int field4) {\n+    this.field1 = field1;\n+    this.field2 = field2;\n+    this.field3 = field3;\n+    this.field4 = field4;\n+  }\n+}\n+\n+public class Test8331033 {\n+\n+  public static int micro1(int ctr) {\n+    \/\/ non-escaping object, EA sweepable, values are forwarded to users, additional\n+    \/\/ bookeeping (SafepointScalarObjectNode) for eliminated objects at SafePoints\n+    \/\/ With -XX:-Inline, constructor will not be inlined and hence AllocateNode are\n+    \/\/ considered escapable.\n+    MyClass obj = new MyClass(10, 20, 30, 40);\n+    return obj.field1 * ctr + obj.field2 + obj.field3 + obj.field4;\n+  }\n+\n+  public static int micro2(int ctr) {\n+    \/\/ small known length arrays of size less than\n+    \/\/ -XX:+EliminateAllocationArraySizeLimit are eliminatable if non-escaping.\n+    int[] arr = new int[5];\n+    arr[0] = 10;\n+    arr[1] = 10;\n+    arr[2] = 10;\n+    arr[3] = 10;\n+    arr[4] = 10;\n+    \/\/ value forwarding will forward constants to expressions.\n+    return ctr * arr[0] + arr[1] + arr[2] + arr[3] + arr[4];\n+  }\n+\n+  public static int micro3(int ctr) {\n+    int[] arr = new int[8];\n+    MemorySegment ms = MemorySegment.ofArray(arr);\n+    ms.fill((byte) 10);\n+    return ctr * ms.get(ValueLayout.JAVA_INT, 12) +\n+        ms.get(ValueLayout.JAVA_INT, 16) +\n+        ms.get(ValueLayout.JAVA_INT, 20) +\n+        ms.get(ValueLayout.JAVA_INT, 24);\n+  }\n+\n+  public static void main(String[] args) {\n+    {\n+      int res = 0;\n+      for (int i = 0; i < 100000; i++) {\n+        res += micro1(i);\n+      }\n+      System.out.println(\"[res] \" + res);\n+    }\n+    {\n+      int res = 0;\n+      for (int i = 0; i < 100000; i++) {\n+        res += micro2(i);\n+      }\n+      System.out.println(\"[res] \" + res);\n+    }\n+    {\n+      int res = 0;\n+      for (int i = 0; i < 100000; i++) {\n+        res += micro3(i);\n+      }\n+      System.out.println(\"[res] \" + res);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/Test8331033.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8136421\n- * @requires vm.jvmci\n- * @library \/test\/lib \/\n- * @library ..\/common\/patches\n- * @modules java.base\/jdk.internal.misc\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.org.objectweb.asm.tree\n- *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n- *          jdk.internal.vm.ci\/jdk.vm.ci.code\n- *          jdk.internal.vm.ci\/jdk.vm.ci.code.site\n- *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n- *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n- *\n- * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper\n- *        jdk.test.whitebox.WhiteBox jdk.test.whitebox.parser.DiagnosticCommand\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *                                jdk.test.whitebox.parser.DiagnosticCommand\n- * @run junit\/othervm -Xbootclasspath\/a:.\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n- *                   compiler.jvmci.compilerToVM.InvalidateInstalledCodeTest\n- *\/\n-\n-package compiler.jvmci.compilerToVM;\n-\n-import compiler.jvmci.common.CodeInstallerTest;\n-import compiler.jvmci.common.CTVMUtilities;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.vm.ci.code.InstalledCode;\n-import jdk.vm.ci.code.site.Site;\n-import jdk.vm.ci.code.site.DataPatch;\n-import jdk.vm.ci.hotspot.CompilerToVMHelper;\n-import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;\n-import jdk.vm.ci.hotspot.HotSpotNmethod;\n-import jdk.vm.ci.meta.Assumptions.Assumption;\n-\n-import java.util.List;\n-import org.junit.Test;\n-\n-public class InvalidateInstalledCodeTest extends CodeInstallerTest {\n-\n-    @Test\n-    public void testInvalidation() {\n-        List<CompileCodeTestCase> testCases\n-                = CompileCodeTestCase.generate(\/* bci = *\/ 0);\n-        testCases.addAll(CompileCodeTestCase.generate(\/* bci = *\/ -1));\n-        testCases.forEach(t -> check(t));\n-        checkNull();\n-    }\n-\n-    private void checkNull() {\n-        Utils.runAndCheckException(\n-                () -> CompilerToVMHelper.invalidateHotSpotNmethod(null, true),\n-                NullPointerException.class);\n-    }\n-\n-    private void check(CompileCodeTestCase testCase) {\n-        HotSpotResolvedJavaMethod javaMethod = CTVMUtilities.getResolvedMethod(testCase.executable);\n-        HotSpotNmethod nmethod = (HotSpotNmethod) installEmptyCode(new Site[0], new Assumption[0],\n-                new Comment[0], 8, new DataPatch[0], null);\n-\n-        Asserts.assertTrue(nmethod.isValid(), testCase + \" : code is invalid even before invalidation\");\n-\n-        Asserts.assertTrue(nmethod.isValid(), testCase + \" : code is not valid, i = \" + nmethod);\n-        Asserts.assertTrue(nmethod.isAlive(), testCase + \" : code is not alive, i = \" + nmethod);\n-        Asserts.assertNotEquals(nmethod.getStart(), 0L);\n-\n-        \/\/ Make nmethod non-entrant but still alive\n-        CompilerToVMHelper.invalidateHotSpotNmethod(nmethod, false);\n-        Asserts.assertFalse(nmethod.isValid(), testCase + \" : code is valid, i = \" + nmethod);\n-        Asserts.assertTrue(nmethod.isAlive(), testCase + \" : code is not alive, i = \" + nmethod);\n-        Asserts.assertEquals(nmethod.getStart(), 0L);\n-\n-        \/\/ Deoptimize the nmethod and cut the link to it from the HotSpotNmethod\n-        CompilerToVMHelper.invalidateHotSpotNmethod(nmethod, true);\n-        Asserts.assertFalse(nmethod.isValid(), testCase + \" : code is valid, i = \" + nmethod);\n-        Asserts.assertFalse(nmethod.isAlive(), testCase + \" : code is alive, i = \" + nmethod);\n-        Asserts.assertEquals(nmethod.getStart(), 0L);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/InvalidateInstalledCodeTest.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-compiler.jvmci.events.JvmciNotifyInstallEventTest\n-compiler.jvmci.common.JVMCIHelpers\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/events\/JvmciNotifyInstallEventTest.config","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8136421\n- * @requires vm.jvmci & !vm.graal.enabled & vm.compMode == \"Xmixed\"\n- * @library \/ \/test\/lib\n- * @library ..\/common\/patches\n- * @modules java.base\/jdk.internal.misc\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.org.objectweb.asm.tree\n- *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n- *          jdk.internal.vm.ci\/jdk.vm.ci.code\n- *          jdk.internal.vm.ci\/jdk.vm.ci.code.site\n- *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n- *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n- *          jdk.internal.vm.ci\/jdk.vm.ci.services\n- *\n- * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper\n- * @build compiler.jvmci.common.JVMCIHelpers\n- * @run driver jdk.test.lib.FileInstaller .\/JvmciNotifyInstallEventTest.config\n- *     .\/META-INF\/services\/jdk.vm.ci.services.JVMCIServiceLocator\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller\n- *      compiler.jvmci.common.JVMCIHelpers$EmptyHotspotCompiler\n- *      compiler.jvmci.common.JVMCIHelpers$EmptyCompilerFactory\n- *      compiler.jvmci.common.JVMCIHelpers$EmptyCompilationRequestResult\n- *      compiler.jvmci.common.JVMCIHelpers$EmptyVMEventListener\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions\n- *     -Djvmci.Compiler=EmptyCompiler -Xbootclasspath\/a:.\n- *     -XX:+UseJVMCICompiler -XX:-BootstrapJVMCI\n- *     -XX:-UseJVMCINativeLibrary -XX:JVMCITraceLevel=1\n- *     -Dtest.jvmci.forceRuntimeStubAllocFail=test_stub_that_fails_to_be_allocated\n- *     compiler.jvmci.events.JvmciNotifyInstallEventTest\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions\n- *     -Djvmci.Compiler=EmptyCompiler -Xbootclasspath\/a:.\n- *     -XX:+UseJVMCICompiler -XX:-BootstrapJVMCI -XX:JVMCINMethodSizeLimit=0\n- *     -XX:-UseJVMCINativeLibrary\n- *     compiler.jvmci.events.JvmciNotifyInstallEventTest\n- *\/\n-\n-package compiler.jvmci.events;\n-\n-import compiler.jvmci.common.CTVMUtilities;\n-import compiler.jvmci.common.testcases.SimpleClass;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.Utils;\n-import jdk.vm.ci.services.JVMCIServiceLocator;\n-import jdk.vm.ci.code.BailoutException;\n-import jdk.vm.ci.code.CompiledCode;\n-import jdk.vm.ci.code.InstalledCode;\n-import jdk.vm.ci.code.site.DataPatch;\n-import jdk.vm.ci.code.site.Site;\n-import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;\n-import jdk.vm.ci.hotspot.HotSpotCompiledNmethod;\n-import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.hotspot.HotSpotVMEventListener;\n-import jdk.vm.ci.meta.Assumptions.Assumption;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-\n-import java.lang.reflect.Method;\n-\n-public class JvmciNotifyInstallEventTest extends JVMCIServiceLocator implements HotSpotVMEventListener {\n-    private static final String METHOD_NAME = \"testMethod\";\n-    private static volatile int gotInstallNotification = 0;\n-\n-    public static void main(String args[]) {\n-        new JvmciNotifyInstallEventTest().runTest();\n-    }\n-\n-    @Override\n-    public <S> S getProvider(Class<S> service) {\n-        if (service == HotSpotVMEventListener.class) {\n-            return service.cast(this);\n-        }\n-        return null;\n-    }\n-\n-    private void runTest() {\n-        if (gotInstallNotification != 0) {\n-            throw new Error(\"Got install notification before test actions\");\n-        }\n-        HotSpotCodeCacheProvider codeCache;\n-        try {\n-            codeCache = (HotSpotCodeCacheProvider) HotSpotJVMCIRuntime.runtime()\n-                    .getHostJVMCIBackend().getCodeCache();\n-        } catch (InternalError ie) {\n-            \/\/ passed\n-            return;\n-        }\n-        Method testMethod;\n-        try {\n-            testMethod = SimpleClass.class.getDeclaredMethod(METHOD_NAME);\n-        } catch (NoSuchMethodException e) {\n-            throw new Error(\"TEST BUG: Can't find \" + METHOD_NAME, e);\n-        }\n-        HotSpotResolvedJavaMethod method = CTVMUtilities\n-                .getResolvedMethod(SimpleClass.class, testMethod);\n-        int dataSectionAlignment = 8; \/\/ CodeBuffer::SECT_CONSTS code section alignment\n-        HotSpotCompiledCode compiledCode = new HotSpotCompiledNmethod(METHOD_NAME,\n-                new byte[0], 0, new Site[0], new Assumption[0],\n-                new ResolvedJavaMethod[]{method}, new Comment[0], new byte[0],\n-                dataSectionAlignment, new DataPatch[0], false, 0, null,\n-                method, 0, 1, 0L, false);\n-        codeCache.installCode(method, compiledCode, \/* installedCode = *\/ null,\n-                \/* speculationLog = *\/ null, \/* isDefault = *\/ false);\n-        Asserts.assertEQ(gotInstallNotification, 1,\n-                \"Got unexpected event count after 1st install attempt\");\n-        \/\/ since \"empty\" compilation result is ok, a second attempt should be ok\n-        codeCache.installCode(method, compiledCode, \/* installedCode = *\/ null,\n-                \/* speculationLog = *\/ null, \/* isDefault = *\/ false);\n-        Asserts.assertEQ(gotInstallNotification, 2,\n-                \"Got unexpected event count after 2nd install attempt\");\n-        \/\/ and an incorrect cases\n-        Utils.runAndCheckException(() -> {\n-            codeCache.installCode(method, null, null, null, true);\n-        }, NullPointerException.class);\n-        Asserts.assertEQ(gotInstallNotification, 2,\n-                \"Got unexpected event count after 3rd install attempt\");\n-        Utils.runAndCheckException(() -> {\n-            codeCache.installCode(null, null, null, null, true);\n-        }, NullPointerException.class);\n-        Asserts.assertEQ(gotInstallNotification, 2,\n-                \"Got unexpected event count after 4th install attempt\");\n-\n-        String stubToFail = System.getProperty(\"test.jvmci.forceRuntimeStubAllocFail\");\n-        if (Platform.isDebugBuild() && stubToFail != null) {\n-            HotSpotCompiledCode stub = new HotSpotCompiledCode(stubToFail,\n-                    \/* targetCode *\/ new byte[0],\n-                    \/* targetCodeSize *\/ 0,\n-                    \/* sites *\/ new Site[0],\n-                    \/* assumptions *\/ new Assumption[0],\n-                    \/* methods *\/ new ResolvedJavaMethod[0],\n-                    \/* comments *\/ new Comment[0],\n-                    \/* dataSection *\/ new byte[0],\n-                    dataSectionAlignment,\n-                    \/* dataSectionPatches *\/ new DataPatch[0],\n-                    \/* isImmutablePIC *\/ false,\n-                    \/* totalFrameSize *\/ 0,\n-                    \/* deoptRescueSlot *\/ null);\n-            try {\n-                codeCache.installCode(null, stub, null, null, true);\n-                throw new AssertionError(\"Didn't get expected \" + BailoutException.class.getName());\n-            } catch (BailoutException e) {\n-                Asserts.assertEQ(e.getMessage(), \"Error installing \" + stubToFail + \": code cache is full\");\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void notifyInstall(HotSpotCodeCacheProvider hotSpotCodeCacheProvider,\n-            InstalledCode installedCode, CompiledCode compiledCode) {\n-        gotInstallNotification++;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/events\/JvmciNotifyInstallEventTest.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.vm.ci.hotspot.HotSpotNmethod;\n@@ -98,1 +99,1 @@\n-    protected void test(TestCompiler compiler, Method method, Object... args) {\n+    protected HotSpotNmethod test(TestCompiler compiler, Method method, Object... args) {\n@@ -118,0 +119,1 @@\n+            return (HotSpotNmethod) installed;\n@@ -119,2 +121,1 @@\n-            e.printStackTrace();\n-            Assert.fail(e.toString());\n+            throw new AssertionError(e);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.jvmci & !vm.graal.enabled & vm.compMode == \"Xmixed\"\n+ * @library \/ \/test\/lib\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code.site\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions\n+ *     -Xbootclasspath\/a:.\n+ *     -XX:+EnableJVMCI -XX:JVMCITraceLevel=1\n+ *     -Dtest.jvmci.forceRuntimeStubAllocFail=test_stub_that_fails_to_be_allocated\n+ *     jdk.vm.ci.code.test.RuntimeStubAllocFailTest\n+ *\/\n+\n+package jdk.vm.ci.code.test;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.vm.ci.code.BailoutException;\n+import jdk.vm.ci.code.site.DataPatch;\n+import jdk.vm.ci.code.site.Site;\n+import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;\n+import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n+import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;\n+import jdk.vm.ci.meta.Assumptions.Assumption;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.runtime.JVMCI;\n+import jdk.vm.ci.runtime.JVMCIRuntime;\n+import jdk.vm.ci.runtime.JVMCIBackend;\n+\n+public class RuntimeStubAllocFailTest {\n+\n+    public static void main(String args[]) {\n+        JVMCIBackend backend = JVMCI.getRuntime().getHostJVMCIBackend();\n+        HotSpotCodeCacheProvider codeCache = (HotSpotCodeCacheProvider) backend.getCodeCache();\n+        int dataSectionAlignment = 8; \/\/ CodeBuffer::SECT_CONSTS code section alignment\n+        String stubToFail = System.getProperty(\"test.jvmci.forceRuntimeStubAllocFail\");\n+        if (Platform.isDebugBuild() && stubToFail != null) {\n+            HotSpotCompiledCode stub = new HotSpotCompiledCode(stubToFail,\n+                    \/* targetCode *\/ new byte[0],\n+                    \/* targetCodeSize *\/ 0,\n+                    \/* sites *\/ new Site[0],\n+                    \/* assumptions *\/ new Assumption[0],\n+                    \/* methods *\/ new ResolvedJavaMethod[0],\n+                    \/* comments *\/ new Comment[0],\n+                    \/* dataSection *\/ new byte[0],\n+                    dataSectionAlignment,\n+                    \/* dataSectionPatches *\/ new DataPatch[0],\n+                    \/* isImmutablePIC *\/ false,\n+                    \/* totalFrameSize *\/ 0,\n+                    \/* deoptRescueSlot *\/ null);\n+            try {\n+                codeCache.installCode(null, stub, null, null, true);\n+                throw new AssertionError(\"Didn't get expected \" + BailoutException.class.getName());\n+            } catch (BailoutException e) {\n+                Asserts.assertEQ(e.getMessage(), \"Error installing \" + stubToFail + \": code cache is full\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/RuntimeStubAllocFailTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @library \/\n+ * @library \/test\/lib \/\n@@ -42,0 +42,1 @@\n+import jdk.test.lib.Asserts;\n@@ -44,0 +45,1 @@\n+import jdk.vm.ci.hotspot.HotSpotNmethod;\n@@ -64,1 +66,18 @@\n-        test(SimpleCodeInstallationTest::compileAdd, getMethod(\"add\", int.class, int.class), 5, 7);\n+        HotSpotNmethod nmethod = test(SimpleCodeInstallationTest::compileAdd, getMethod(\"add\", int.class, int.class), 5, 7);\n+\n+        \/\/ Test code invalidation\n+        Asserts.assertTrue(nmethod.isValid(), \"code is not valid, i = \" + nmethod);\n+        Asserts.assertTrue(nmethod.isAlive(), \"code is not alive, i = \" + nmethod);\n+        Asserts.assertNotEquals(nmethod.getStart(), 0L);\n+\n+        \/\/ Make nmethod non-entrant but still alive\n+        nmethod.invalidate(false);\n+        Asserts.assertFalse(nmethod.isValid(), \"code is valid, i = \" + nmethod);\n+        Asserts.assertTrue(nmethod.isAlive(), \"code is not alive, i = \" + nmethod);\n+        Asserts.assertEquals(nmethod.getStart(), 0L);\n+\n+        \/\/ Deoptimize the nmethod and cut the link to it from the HotSpotNmethod\n+        nmethod.invalidate(true);\n+        Asserts.assertFalse(nmethod.isValid(), \"code is valid, i = \" + nmethod);\n+        Asserts.assertFalse(nmethod.isAlive(), \"code is alive, i = \" + nmethod);\n+        Asserts.assertEquals(nmethod.getStart(), 0L);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleCodeInstallationTest.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -246,0 +246,21 @@\n+    public class Bookmark implements AutoCloseable {\n+        private final int registerMark = nextRegister;\n+        private final int codePos = code.position();\n+        private final int dataPos = data.position();\n+\n+        @Override\n+        public void close() {\n+            nextRegister = registerMark;\n+            code.data.position(codePos);\n+            data.data.position(dataPos);\n+        }\n+    }\n+\n+    \/**\n+     * Enters a scope in which the current register, code and data emitting state\n+     * is restored upon leaving the scope.\n+     *\/\n+    public Bookmark bookmark() {\n+        return new Bookmark();\n+    }\n+\n@@ -299,0 +320,12 @@\n+    \/**\n+     * Emits the 32 bit constant `c` into the data section.\n+     *\/\n+    public DataSectionReference emitDataItem(int c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+\n+        recordDataPatchInCode(ref);\n+        data.emitInt(c);\n+        return ref;\n+    }\n+\n@@ -324,0 +357,44 @@\n+    \/**\n+     * @param n Number of bits that should be set to 1. Must be between 0 and 32 (inclusive).\n+     * @return A number with n bits set to 1.\n+     *\/\n+    public static int getNbitNumberInt(int n) {\n+        assert n >= 0 && n <= 32 : \"0 <= n <= 32; instead: \" + n;\n+        if (n < 32) {\n+            return (1 << n) - 1;\n+        } else {\n+            return 0xFFFFFFFF;\n+        }\n+    }\n+\n+    public static boolean isSignedNbit(int n, int value) {\n+        assert n > 0 && n < 32 : n;\n+        int min = -(1 << (n - 1));\n+        int max = (1 << (n - 1)) - 1;\n+        return value >= min && value <= max;\n+    }\n+\n+    public static boolean isUnsignedNbit(int n, int value) {\n+        assert n > 0 && n < 32 : n;\n+        return 32 - Integer.numberOfLeadingZeros(value) <= n;\n+    }\n+\n+    \/**\n+     * Determines if `x` is in the range of signed byte values.\n+     *\/\n+    public static boolean isByte(int x) {\n+        return (byte) x == x;\n+    }\n+\n+    \/**\n+     * Determines if `l` is in the range of signed int values.\n+     *\/\n+    public static boolean isInt(long l) {\n+        return (int) l == l;\n+    }\n+\n+    public static void check(boolean condition, String errorMessage, Object... args) {\n+        if (!condition) {\n+            throw new AssertionError(errorMessage.formatted(args));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/TestAssembler.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+        nmethodEntryBarrierConcurrentPatch = initNmethodEntryBarrierConcurrentPatch(arch);\n@@ -50,0 +51,2 @@\n+    public final int MARKID_FRAME_COMPLETE = getConstant(\"CodeInstaller::FRAME_COMPLETE\", Integer.class);\n+    public final int MARKID_ENTRY_BARRIER_PATCH = getConstant(\"CodeInstaller::ENTRY_BARRIER_PATCH\", Integer.class);\n@@ -56,0 +59,25 @@\n+\n+    private Boolean initNmethodEntryBarrierConcurrentPatch(Architecture arch) {\n+        Boolean patchConcurrent = null;\n+        if (arch instanceof AArch64 && nmethodEntryBarrier != 0) {\n+            Integer patchingType = getFieldValue(\"CompilerToVM::Data::BarrierSetAssembler_nmethod_patching_type\", Integer.class, \"int\");\n+            if (patchingType != null) {\n+                \/\/ There currently only 2 variants in use that differ only by the presence of a\n+                \/\/ dmb instruction\n+                int stw = getConstant(\"NMethodPatchingType::stw_instruction_and_data_patch\", Integer.class);\n+                int conc = getConstant(\"NMethodPatchingType::conc_data_patch\", Integer.class);\n+                if (patchingType == stw) {\n+                    patchConcurrent = false;\n+                } else if (patchingType == conc) {\n+                    patchConcurrent = true;\n+                } else {\n+                    throw new IllegalArgumentException(\"unsupported barrier sequence \" + patchingType);\n+                }\n+            }\n+        }\n+        return patchConcurrent;\n+    }\n+\n+    public final int threadDisarmedOffset = getFieldValue(\"CompilerToVM::Data::thread_disarmed_guard_value_offset\", Integer.class, \"int\");\n+    public final long nmethodEntryBarrier = getFieldValue(\"CompilerToVM::Data::nmethod_entry_barrier\", Long.class, \"address\");\n+    public final Boolean nmethodEntryBarrierConcurrentPatch;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/TestHotSpotVMConfig.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    private static final Register scratchRegister2 = AArch64.rscratch2;\n@@ -51,0 +52,60 @@\n+    \/**\n+     * Condition Flags for branches. See C1.2.4\n+     *\/\n+    public enum ConditionFlag {\n+        \/\/ Integer | Floating-point meanings\n+        \/** Equal | Equal. *\/\n+        EQ(0x0),\n+\n+        \/** Not Equal | Not equal or unordered. *\/\n+        NE(0x1),\n+\n+        \/** Unsigned Higher or Same | Greater than, equal or unordered. *\/\n+        HS(0x2),\n+\n+        \/** Unsigned lower | less than. *\/\n+        LO(0x3),\n+\n+        \/** Minus (negative) | less than. *\/\n+        MI(0x4),\n+\n+        \/** Plus (positive or zero) | greater than, equal or unordered. *\/\n+        PL(0x5),\n+\n+        \/** Overflow set | unordered. *\/\n+        VS(0x6),\n+\n+        \/** Overflow clear | ordered. *\/\n+        VC(0x7),\n+\n+        \/** Unsigned higher | greater than or unordered. *\/\n+        HI(0x8),\n+\n+        \/** Unsigned lower or same | less than or equal. *\/\n+        LS(0x9),\n+\n+        \/** Signed greater than or equal | greater than or equal. *\/\n+        GE(0xA),\n+\n+        \/** Signed less than | less than or unordered. *\/\n+        LT(0xB),\n+\n+        \/** Signed greater than | greater than. *\/\n+        GT(0xC),\n+\n+        \/** Signed less than or equal | less than, equal or unordered. *\/\n+        LE(0xD),\n+\n+        \/** Always | always. *\/\n+        AL(0xE),\n+\n+        \/** Always | always (identical to AL, just to have valid 0b1111 encoding). *\/\n+        NV(0xF);\n+\n+        public final int encoding;\n+\n+        ConditionFlag(int encoding) {\n+            this.encoding = encoding;\n+        }\n+    }\n+\n@@ -218,0 +279,16 @@\n+    \/**\n+     * C6.2.25 Branch conditionally.\n+     *\n+     * @param condition may not be null.\n+     * @param imm21 Signed 21-bit offset, has to be 4-byte aligned.\n+     *\/\n+    protected void emitBranch(ConditionFlag condition, int imm21) {\n+        \/\/ B.cond\n+        check(isSignedNbit(21, imm21) && (imm21 & 0b11) == 0,\n+              \"0x%x must be a 21-bit signed number and 4-byte aligned\", imm21);\n+        int imm19 = (imm21 & getNbitNumberInt(21)) >> 2;\n+        code.emitInt(f(0b001010100, 31, 24)\n+                     | f(imm19, 23, 4)\n+                     | f(condition.encoding, 3, 0));\n+    }\n+\n@@ -264,0 +341,2 @@\n+        emitNMethodEntryBarrier();\n+\n@@ -267,0 +346,14 @@\n+    private void emitNMethodEntryBarrier() {\n+        recordMark(config.MARKID_ENTRY_BARRIER_PATCH);\n+        DataSectionReference ref = emitDataItem(0);\n+        emitLoadPointer(scratchRegister, AArch64Kind.DWORD, ref);\n+        if (config.nmethodEntryBarrierConcurrentPatch) {\n+            code.emitInt(0xd50339bf); \/\/ dmb ishld\n+        }\n+        Register thread = AArch64.r28;\n+        emitLoadPointer(scratchRegister2, AArch64Kind.DWORD, thread, config.threadDisarmedOffset);\n+        code.emitInt(0x6b09011f);             \/\/ cmp w8, w9\n+        emitBranch(ConditionFlag.EQ, 8);      \/\/ jump over slow path, runtime call\n+        emitCall(config.nmethodEntryBarrier);\n+    }\n+\n@@ -364,2 +457,5 @@\n-        Register ret = newRegister();\n-        emitLoadRegister(ret, AArch64Kind.QWORD, b, offset);\n+        return emitLoadPointer(newRegister(), AArch64Kind.QWORD, b, offset);\n+    }\n+\n+    public Register emitLoadPointer(Register ret, AArch64Kind kind, Register b, int offset) {\n+        emitLoadRegister(ret, kind, b, offset);\n@@ -380,0 +476,4 @@\n+        return emitLoadPointer(newRegister(), AArch64Kind.QWORD, ref);\n+    }\n+\n+    public Register emitLoadPointer(Register ret, AArch64Kind kind, DataSectionReference ref) {\n@@ -382,2 +482,1 @@\n-        Register ret = newRegister();\n-        emitLoadRegister(ret, AArch64Kind.QWORD, 0xdead);\n+        emitLoadRegister(ret, kind, 0xdead);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":103,"deletions":4,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -52,0 +52,34 @@\n+    \/**\n+     * The x86 condition codes used for conditional jumps\/moves.\n+     *\/\n+    public enum ConditionFlag {\n+        Zero(0x4, \"|zero|\"),\n+        NotZero(0x5, \"|nzero|\"),\n+        Equal(0x4, \"=\"),\n+        NotEqual(0x5, \"!=\"),\n+        Less(0xc, \"<\"),\n+        LessEqual(0xe, \"<=\"),\n+        Greater(0xf, \">\"),\n+        GreaterEqual(0xd, \">=\"),\n+        Below(0x2, \"|<|\"),\n+        BelowEqual(0x6, \"|<=|\"),\n+        Above(0x7, \"|>|\"),\n+        AboveEqual(0x3, \"|>=|\"),\n+        Overflow(0x0, \"|of|\"),\n+        NoOverflow(0x1, \"|nof|\"),\n+        CarrySet(0x2, \"|carry|\"),\n+        CarryClear(0x3, \"|ncarry|\"),\n+        Negative(0x8, \"|neg|\"),\n+        Positive(0x9, \"|pos|\"),\n+        Parity(0xa, \"|par|\"),\n+        NoParity(0xb, \"|npar|\");\n+\n+        public final int value;\n+        public final String operator;\n+\n+        ConditionFlag(int value, String operator) {\n+            this.value = value;\n+            this.operator = operator;\n+        }\n+    }\n+\n@@ -66,0 +100,56 @@\n+    \/**\n+     * Emit the expected patchable code sequence for the nmethod entry barrier. The int sized\n+     * payload must be naturally aligned so it can be patched atomically.\n+     *\/\n+    private void emitNMethodEntryCompare(int displacement) {\n+        \/\/ cmp dword ptr [r15 + <displacement>], 0x00000000\n+        \/\/ 41 81 7f <db> 00 00 00 00\n+        code.emitByte(0x41);\n+        code.emitByte(0x81);\n+        code.emitByte(0x7f);\n+        check(isByte(displacement), \"expected byte sized displacement: 0x%x\", displacement);\n+        code.emitByte(displacement & 0xff);\n+        check(code.position() % 4 == 0, \"must be aligned\");\n+        code.emitInt(0);\n+    }\n+\n+    \/**\n+     * Emits a long (i.e. 6 byte) format conditional branch.\n+     *\n+     * @param offset the offset of the branch target wrt the start of the branch instruction\n+     *\/\n+    private void emitBranch(ConditionFlag condition, int offset) {\n+        final int longSize = 6;\n+        int disp32 = offset - longSize;\n+\n+        \/\/ 0000 1111 1000 tttn #32-bit disp\n+        check(isInt(disp32), \"must be 32bit disp: %d\", disp32);\n+        code.emitByte(0x0F);\n+        code.emitByte(0x80 | condition.value);\n+        code.emitInt(disp32);\n+    }\n+\n+    public void emitAlign(int modulus) {\n+        while (code.position() % modulus != 0) {\n+            code.emitByte(0x90);\n+        }\n+    }\n+\n+    private void emitNMethodEntryBarrier() {\n+        \/\/ The following code sequence must be emitted in exactly this fashion as HotSpot\n+        \/\/ will check that the barrier is the expected code sequence.\n+        emitAlign(4);\n+        recordMark(config.MARKID_FRAME_COMPLETE);\n+        recordMark(config.MARKID_ENTRY_BARRIER_PATCH);\n+        emitNMethodEntryCompare(config.threadDisarmedOffset);\n+        int branchOffset;\n+        try (Bookmark bm = bookmark()) {\n+            int pos = code.position();\n+            emitBranch(ConditionFlag.Equal, 0);\n+            emitCall(config.nmethodEntryBarrier);\n+            branchOffset = code.position() - pos;\n+        }\n+        emitBranch(ConditionFlag.Equal, branchOffset);\n+        emitCall(config.nmethodEntryBarrier);\n+    }\n+\n@@ -74,0 +164,1 @@\n+        emitNMethodEntryBarrier();\n@@ -417,1 +508,1 @@\n-        Register target = emitLoadLong(addr);\n+        Register target = emitLoadLong(AMD64.rax, addr);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/amd64\/AMD64TestAssembler.java","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1167,1 +1167,1 @@\n-    public static final String COUNTTRAILINGZEROS_VL = VECTOR_PREFIX + \"COUNTTRAILINGZEROS_VL\" + POSTFIX;\n+    public static final String COUNT_TRAILING_ZEROS_VL = VECTOR_PREFIX + \"COUNT_TRAILING_ZEROS_VL\" + POSTFIX;\n@@ -1169,1 +1169,1 @@\n-        vectorNode(COUNTTRAILINGZEROS_VL, \"CountTrailingZerosV\", TYPE_LONG);\n+        vectorNode(COUNT_TRAILING_ZEROS_VL, \"CountTrailingZerosV\", TYPE_LONG);\n@@ -1172,1 +1172,1 @@\n-    public static final String COUNTLEADINGZEROS_VL = VECTOR_PREFIX + \"COUNTLEADINGZEROS_VL\" + POSTFIX;\n+    public static final String COUNT_TRAILING_ZEROS_VI = VECTOR_PREFIX + \"COUNT_TRAILING_ZEROS_VI\" + POSTFIX;\n@@ -1174,1 +1174,11 @@\n-        vectorNode(COUNTLEADINGZEROS_VL, \"CountLeadingZerosV\", TYPE_LONG);\n+        vectorNode(COUNT_TRAILING_ZEROS_VI, \"CountTrailingZerosV\", TYPE_INT);\n+    }\n+\n+    public static final String COUNT_LEADING_ZEROS_VL = VECTOR_PREFIX + \"COUNT_LEADING_ZEROS_VL\" + POSTFIX;\n+    static {\n+        vectorNode(COUNT_LEADING_ZEROS_VL, \"CountLeadingZerosV\", TYPE_LONG);\n+    }\n+\n+    public static final String COUNT_LEADING_ZEROS_VI = VECTOR_PREFIX + \"COUNT_LEADING_ZEROS_VI\" + POSTFIX;\n+    static {\n+        vectorNode(COUNT_LEADING_ZEROS_VI, \"CountLeadingZerosV\", TYPE_INT);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -105,1 +105,4 @@\n-        \"sve\"\n+        \"sve\",\n+        \/\/ Riscv64\n+        \"v\",\n+        \"zvbb\"\n@@ -159,1 +162,1 @@\n-        } else if (irAnno.applyIfPlatform().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatform())) {\n+        } else if (irAnno.applyIfPlatform().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatform(), \"applyIfPlatform\")) {\n@@ -162,1 +165,1 @@\n-        } else if (irAnno.applyIfPlatformAnd().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatformAnd())) {\n+        } else if (irAnno.applyIfPlatformAnd().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatformAnd(), \"applyIfPlatformAnd\")) {\n@@ -165,1 +168,1 @@\n-        } else if (irAnno.applyIfPlatformOr().length != 0 && !hasAnyRequiredPlatform(irAnno.applyIfPlatformOr())) {\n+        } else if (irAnno.applyIfPlatformOr().length != 0 && !hasAnyRequiredPlatform(irAnno.applyIfPlatformOr(), \"applyIfPlatformOr\")) {\n@@ -168,1 +171,1 @@\n-        } else if (irAnno.applyIfCPUFeature().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeature())) {\n+        } else if (irAnno.applyIfCPUFeature().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeature(), \"applyIfCPUFeature\")) {\n@@ -171,1 +174,1 @@\n-        } else if (irAnno.applyIfCPUFeatureAnd().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeatureAnd())) {\n+        } else if (irAnno.applyIfCPUFeatureAnd().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeatureAnd(), \"applyIfCPUFeatureAnd\")) {\n@@ -174,1 +177,1 @@\n-        } else if (irAnno.applyIfCPUFeatureOr().length != 0 && !hasAnyRequiredCPUFeature(irAnno.applyIfCPUFeatureOr())) {\n+        } else if (irAnno.applyIfCPUFeatureOr().length != 0 && !hasAnyRequiredCPUFeature(irAnno.applyIfCPUFeatureOr(), \"applyIfCPUFeatureOr\")) {\n@@ -286,1 +289,1 @@\n-    private boolean hasAllRequiredPlatform(String[] andRules) {\n+    private boolean hasAllRequiredPlatform(String[] andRules, String ruleType) {\n@@ -291,0 +294,1 @@\n+            TestFormat.check(i < andRules.length, \"Missing value for platform \" + platform + \" in \" + ruleType + failAt());\n@@ -297,1 +301,1 @@\n-    private boolean hasAnyRequiredPlatform(String[] orRules) {\n+    private boolean hasAnyRequiredPlatform(String[] orRules, String ruleType) {\n@@ -302,0 +306,1 @@\n+            TestFormat.check(i < orRules.length, \"Missing value for platform \" + platform + \" in \" + ruleType + failAt());\n@@ -362,1 +367,1 @@\n-    private boolean hasAllRequiredCPUFeature(String[] andRules) {\n+    private boolean hasAllRequiredCPUFeature(String[] andRules, String ruleType) {\n@@ -367,0 +372,1 @@\n+            TestFormat.check(i < andRules.length, \"Missing value for cpu feature \" + feature + \" in \" + ruleType + failAt());\n@@ -373,1 +379,1 @@\n-    private boolean hasAnyRequiredCPUFeature(String[] orRules) {\n+    private boolean hasAnyRequiredCPUFeature(String[] orRules, String ruleType) {\n@@ -378,0 +384,1 @@\n+            TestFormat.check(i < orRules.length, \"Missing value for cpu feature \" + feature + \" in \" + ruleType + failAt());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ *                               -XX:CompileCommand=memlimit,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::*,0\n@@ -36,0 +37,2 @@\n+\/\/ Note; we disable the implicit memory limit of 1G in debug JVMs until JDK-8331295 is fixed\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeepGraphVerifyIterativeGVN.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelingAtSingleInputRegion.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ *                                 -XX:CompileCommand=MemLimit,*.*,0\n@@ -47,0 +48,1 @@\n+ *                                 -XX:CompileCommand=MemLimit,*.*,0\n@@ -63,0 +65,1 @@\n+ *                                 -XX:CompileCommand=MemLimit,*.*,0\n@@ -79,0 +82,1 @@\n+ *                                 -XX:CompileCommand=MemLimit,*.*,0\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVectorFuzzer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,5 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\",\"UsePopCountInstruction\", \"true\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\",\n+                  IRNode.POPCOUNT_VL, \">= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestGeneralizedReductions.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,810 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test id=byte-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray\n+ *\/\n+\n+\/*\n+ * @test id=char-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment CharArray\n+ *\/\n+\n+\/*\n+ * @test id=short-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ShortArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment IntArray\n+ *\/\n+\n+\/*\n+ * @test id=long-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment LongArray\n+ *\/\n+\n+\/*\n+ * @test id=float-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment FloatArray\n+ *\/\n+\n+\/*\n+ * @test id=double-array\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment DoubleArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteBuffer\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteBufferDirect\n+ *\/\n+\n+\/*\n+ * @test id=native\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native\n+ *\/\n+\n+\/\/ FAILS: mixed providers currently do not vectorize. Maybe there is some inlining issue.\n+\/\/ \/*\n+\/\/  * @test id=mixed-array\n+\/\/  * @bug 8329273\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment MixedArray\n+\/\/  *\/\n+\/\/\n+\/\/ \/*\n+\/\/  * @test id=MixedBuffer\n+\/\/  * @bug 8329273\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment MixedBuffer\n+\/\/  *\/\n+\/\/\n+\/\/ \/*\n+\/\/  * @test id=mixed\n+\/\/  * @bug 8329273\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment Mixed\n+\/\/  *\/\n+\n+public class TestMemorySegment {\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMemorySegmentImpl.class);\n+        framework.addFlags(\"-DmemorySegmentProviderNameForTestVM=\" + args[0]);\n+        framework.setDefaultWarmup(100);\n+        framework.start();\n+    }\n+}\n+\n+class TestMemorySegmentImpl {\n+    static final int BACKING_SIZE = 1024 * 8;\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    interface MemorySegmentProvider {\n+        MemorySegment newMemorySegment();\n+    }\n+\n+    static MemorySegmentProvider provider;\n+\n+    static {\n+        String providerName = System.getProperty(\"memorySegmentProviderNameForTestVM\");\n+        provider = switch (providerName) {\n+            case \"ByteArray\"        -> TestMemorySegmentImpl::newMemorySegmentOfByteArray;\n+            case \"CharArray\"        -> TestMemorySegmentImpl::newMemorySegmentOfCharArray;\n+            case \"ShortArray\"       -> TestMemorySegmentImpl::newMemorySegmentOfShortArray;\n+            case \"IntArray\"         -> TestMemorySegmentImpl::newMemorySegmentOfIntArray;\n+            case \"LongArray\"        -> TestMemorySegmentImpl::newMemorySegmentOfLongArray;\n+            case \"FloatArray\"       -> TestMemorySegmentImpl::newMemorySegmentOfFloatArray;\n+            case \"DoubleArray\"      -> TestMemorySegmentImpl::newMemorySegmentOfDoubleArray;\n+            case \"ByteBuffer\"       -> TestMemorySegmentImpl::newMemorySegmentOfByteBuffer;\n+            case \"ByteBufferDirect\" -> TestMemorySegmentImpl::newMemorySegmentOfByteBufferDirect;\n+            case \"Native\"           -> TestMemorySegmentImpl::newMemorySegmentOfNative;\n+            case \"MixedArray\"       -> TestMemorySegmentImpl::newMemorySegmentOfMixedArray;\n+            case \"MixedBuffer\"      -> TestMemorySegmentImpl::newMemorySegmentOfMixedBuffer;\n+            case \"Mixed\"            -> TestMemorySegmentImpl::newMemorySegmentOfMixed;\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + providerName);\n+        };\n+    }\n+\n+    \/\/ List of tests\n+    Map<String, TestFunction> tests = new HashMap<>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String, Object[]> golds = new HashMap<>();\n+\n+    public TestMemorySegmentImpl () {\n+        \/\/ Generate two MemorySegments as inputs\n+        MemorySegment a = newMemorySegment();\n+        MemorySegment b = newMemorySegment();\n+        fillRandom(a);\n+        fillRandom(b);\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"testMemorySegmentBadExitCheck\",                 () -> testMemorySegmentBadExitCheck(copy(a)));\n+        tests.put(\"testIntLoop_iv_byte\",                           () -> testIntLoop_iv_byte(copy(a)));\n+        tests.put(\"testIntLoop_longIndex_intInvar_sameAdr_byte\",   () -> testIntLoop_longIndex_intInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_sameAdr_byte\",  () -> testIntLoop_longIndex_longInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_intInvar_byte\",           () -> testIntLoop_longIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_byte\",          () -> testIntLoop_longIndex_longInvar_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_intIndex_intInvar_byte\",            () -> testIntLoop_intIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testIntLoop_iv_int\",                            () -> testIntLoop_iv_int(copy(a)));\n+        tests.put(\"testIntLoop_longIndex_intInvar_sameAdr_int\",    () -> testIntLoop_longIndex_intInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_sameAdr_int\",   () -> testIntLoop_longIndex_longInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_intInvar_int\",            () -> testIntLoop_longIndex_intInvar_int(copy(a), 0));\n+        tests.put(\"testIntLoop_longIndex_longInvar_int\",           () -> testIntLoop_longIndex_longInvar_int(copy(a), 0));\n+        tests.put(\"testIntLoop_intIndex_intInvar_int\",             () -> testIntLoop_intIndex_intInvar_int(copy(a), 0));\n+        tests.put(\"testLongLoop_iv_byte\",                          () -> testLongLoop_iv_byte(copy(a)));\n+        tests.put(\"testLongLoop_longIndex_intInvar_sameAdr_byte\",  () -> testLongLoop_longIndex_intInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_sameAdr_byte\", () -> testLongLoop_longIndex_longInvar_sameAdr_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_intInvar_byte\",          () -> testLongLoop_longIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_byte\",         () -> testLongLoop_longIndex_longInvar_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_intIndex_intInvar_byte\",           () -> testLongLoop_intIndex_intInvar_byte(copy(a), 0));\n+        tests.put(\"testLongLoop_iv_int\",                           () -> testLongLoop_iv_int(copy(a)));\n+        tests.put(\"testLongLoop_longIndex_intInvar_sameAdr_int\",   () -> testLongLoop_longIndex_intInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_sameAdr_int\",  () -> testLongLoop_longIndex_longInvar_sameAdr_int(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_intInvar_int\",           () -> testLongLoop_longIndex_intInvar_int(copy(a), 0));\n+        tests.put(\"testLongLoop_longIndex_longInvar_int\",          () -> testLongLoop_longIndex_longInvar_int(copy(a), 0));\n+        tests.put(\"testLongLoop_intIndex_intInvar_int\",            () -> testLongLoop_intIndex_intInvar_int(copy(a), 0));\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    MemorySegment newMemorySegment() {\n+        return provider.newMemorySegment();\n+    }\n+\n+    MemorySegment copy(MemorySegment src) {\n+        MemorySegment dst = newMemorySegment();\n+        MemorySegment.copy(src, 0, dst, 0, src.byteSize());\n+        return dst;\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteArray() {\n+        return MemorySegment.ofArray(new byte[BACKING_SIZE]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfCharArray() {\n+        return MemorySegment.ofArray(new char[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfShortArray() {\n+        return MemorySegment.ofArray(new short[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfIntArray() {\n+        return MemorySegment.ofArray(new int[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfLongArray() {\n+        return MemorySegment.ofArray(new long[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfFloatArray() {\n+        return MemorySegment.ofArray(new float[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfDoubleArray() {\n+        return MemorySegment.ofArray(new double[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBuffer() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocate(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBufferDirect() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocateDirect(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfNative() {\n+        \/\/ Auto arena: GC decides when there is no reference to the MemorySegment,\n+        \/\/ and then it deallocates the backing memory.\n+        return Arena.ofAuto().allocate(BACKING_SIZE, 1);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedArray() {\n+        switch(RANDOM.nextInt(7)) {\n+            case 0  -> { return newMemorySegmentOfByteArray(); }\n+            case 1  -> { return newMemorySegmentOfCharArray(); }\n+            case 2  -> { return newMemorySegmentOfShortArray(); }\n+            case 3  -> { return newMemorySegmentOfIntArray(); }\n+            case 4  -> { return newMemorySegmentOfLongArray(); }\n+            case 5  -> { return newMemorySegmentOfFloatArray(); }\n+            default -> { return newMemorySegmentOfDoubleArray(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedBuffer() {\n+        switch (RANDOM.nextInt(2)) {\n+            case 0  -> { return newMemorySegmentOfByteBuffer(); }\n+            default -> { return newMemorySegmentOfByteBufferDirect(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixed() {\n+        switch (RANDOM.nextInt(3)) {\n+            case 0  -> { return newMemorySegmentOfMixedArray(); }\n+            case 1  -> { return newMemorySegmentOfMixedBuffer(); }\n+            default -> { return newMemorySegmentOfNative(); }\n+        }\n+    }\n+\n+    static void fillRandom(MemorySegment data) {\n+        for (int i = 0; i < (int)data.byteSize(); i += 8) {\n+            data.set(ValueLayout.JAVA_LONG_UNALIGNED, i, RANDOM.nextLong());\n+        }\n+    }\n+\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate objects (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+\n+            if (!(g instanceof MemorySegment && r instanceof MemorySegment)) {\n+                throw new RuntimeException(\"verify \" + name + \": only MemorySegment supported, i=\" + i);\n+            }\n+\n+            MemorySegment mg = (MemorySegment)g;\n+            MemorySegment mr = (MemorySegment)r;\n+\n+            if (mg.byteSize() != mr.byteSize()) {\n+                throw new RuntimeException(\"verify \" + name + \": MemorySegment must have same byteSize:\" +\n+                                       \" gold[\" + i + \"].byteSize = \" + mg.byteSize() +\n+                                       \" result[\" + i + \"].byteSize = \" + mr.byteSize());\n+            }\n+\n+            for (int j = 0; j < (int)mg.byteSize(); j++) {\n+                byte vg = mg.get(ValueLayout.JAVA_BYTE, j);\n+                byte vr = mr.get(ValueLayout.JAVA_BYTE, j);\n+                if (vg != vr) {\n+                    throw new RuntimeException(\"verify \" + name + \": MemorySegment must have same content:\" +\n+                                               \" gold[\" + i + \"][\" + j + \"] = \" + vg +\n+                                               \" result[\" + i + \"][\" + j + \"] = \" + vr);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = {\"testMemorySegmentBadExitCheck\",\n+                 \"testIntLoop_iv_byte\",\n+                 \"testIntLoop_longIndex_intInvar_sameAdr_byte\",\n+                 \"testIntLoop_longIndex_longInvar_sameAdr_byte\",\n+                 \"testIntLoop_longIndex_intInvar_byte\",\n+                 \"testIntLoop_longIndex_longInvar_byte\",\n+                 \"testIntLoop_intIndex_intInvar_byte\",\n+                 \"testIntLoop_iv_int\",\n+                 \"testIntLoop_longIndex_intInvar_sameAdr_int\",\n+                 \"testIntLoop_longIndex_longInvar_sameAdr_int\",\n+                 \"testIntLoop_longIndex_intInvar_int\",\n+                 \"testIntLoop_longIndex_longInvar_int\",\n+                 \"testIntLoop_intIndex_intInvar_int\",\n+                 \"testLongLoop_iv_byte\",\n+                 \"testLongLoop_longIndex_intInvar_sameAdr_byte\",\n+                 \"testLongLoop_longIndex_longInvar_sameAdr_byte\",\n+                 \"testLongLoop_longIndex_intInvar_byte\",\n+                 \"testLongLoop_longIndex_longInvar_byte\",\n+                 \"testLongLoop_intIndex_intInvar_byte\",\n+                 \"testLongLoop_iv_int\",\n+                 \"testLongLoop_longIndex_intInvar_sameAdr_int\",\n+                 \"testLongLoop_longIndex_longInvar_sameAdr_int\",\n+                 \"testLongLoop_longIndex_intInvar_int\",\n+                 \"testLongLoop_longIndex_longInvar_int\",\n+                 \"testLongLoop_intIndex_intInvar_int\"})\n+    void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS\n+    \/\/ Exit check: iv < long_limit      ->     (long)iv < long_limit\n+    \/\/ Thus, we have an int-iv, but a long-exit-check.\n+    \/\/ Is not properly recognized by either CountedLoop or LongCountedLoop\n+    static Object[] testMemorySegmentBadExitCheck(MemorySegment a) {\n+        for (int i = 0; i < a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_iv_byte(MemorySegment a) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_intInvar_sameAdr_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_longInvar_sameAdr_byte(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_longInvar_byte(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testIntLoop_intIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            int int_index = i + invar;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, int_index);\n+            a.set(ValueLayout.JAVA_BYTE, int_index, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_iv_int(MemorySegment a) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++ ) {\n+            long adr = 4L * i;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_intInvar_sameAdr_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_longInvar_sameAdr_int(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_longInvar_int(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testIntLoop_intIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            int int_index = i + invar;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_iv_byte(MemorySegment a) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_longIndex_intInvar_sameAdr_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_longIndex_longInvar_sameAdr_byte(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_longInvar_byte(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testLongLoop_intIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            int int_index = (int)(i + invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, int_index);\n+            a.set(ValueLayout.JAVA_BYTE, int_index, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_iv_int(MemorySegment a) {\n+        for (long i = 0; i < a.byteSize()\/4; i++ ) {\n+            long adr = 4L * i;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+    \/\/              IRNode.ADD_VI,        \"> 0\",\n+    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/    applyIf = {\"AlignVector\", \"false\"},\n+    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n+    \/\/        The long -> int loop conversion introduces extra invariants.\n+    static Object[] testLongLoop_longIndex_intInvar_sameAdr_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+    \/\/              IRNode.ADD_VI,        \"> 0\",\n+    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/    applyIf = {\"AlignVector\", \"false\"},\n+    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n+    \/\/        The long -> int loop conversion introduces extra invariants.\n+    static Object[] testLongLoop_longIndex_longInvar_sameAdr_int(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_longInvar_int(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testLongLoop_intIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            int int_index = (int)(i + invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":810,"deletions":0,"binary":false,"changes":810,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8310886 8325252\n+ * @bug 8310886 8325252 8320622\n@@ -71,6 +71,2 @@\n-        if (Platform.isX64() || Platform.isX86()) {\n-            TestFramework.runWithFlags(\"-XX:+UseUnalignedLoadStores\");\n-            TestFramework.runWithFlags(\"-XX:-UseUnalignedLoadStores\");\n-        } else {\n-            TestFramework.run();\n-        }\n+        TestFramework.runWithFlags(\"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:-AlignVector\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +59,1 @@\n+import jdk.test.lib.Platform;\n@@ -61,0 +63,1 @@\n+import java.io.File;\n@@ -66,0 +69,1 @@\n+    \/\/ Method we don't specify; default memlimit should apply\n@@ -67,0 +71,1 @@\n+    \/\/ Method we explicitly limit to 4K limit\n@@ -68,0 +73,2 @@\n+    \/\/ Method for which we explicitly disable a limit on the command line.\n+    final static String METHOD3 = \"method3\";\n@@ -79,7 +86,0 @@\n-        test(METHOD1, METHOD2);\n-        test(METHOD2, METHOD1);\n-    }\n-\n-    private static void test(String include, String exclude) throws Exception {\n-\n-        \/\/ A method that is known to cost compilers a bit of memory to compile\n@@ -91,0 +91,1 @@\n+        options.add(\"-XX:-CreateCoredumpOnCrash\");\n@@ -92,8 +93,9 @@\n-        \/\/ We pass a very small size to guarantee the crash\n-        options.add(\"-XX:CompileCommand=MemStat,\" + getTestMethod(include) + \",print\");\n-        if (test_crash) {\n-            options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(include) + \",4k~crash\");\n-            options.add(\"-XX:-CreateCoredumpOnCrash\");\n-        } else {\n-            options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(include) + \",4k\");\n-        }\n+\n+        \/\/ We want a final report\n+        options.add(\"-XX:CompileCommand=MemStat,*.*,print\");\n+\n+        \/\/ We limit method 2 to a very small limit that is guaranteed to trigger\n+        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(METHOD2) + \",4k\" + (test_crash ? \"~crash\" : \"\"));\n+\n+        \/\/ We disable any limit set on method 3\n+        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(METHOD3) + \",0\");\n@@ -112,7 +114,3 @@\n-        String expectedNameIncl = getTestMethod(include)\n-                .replace('.', '\/')\n-                .replace(\"$\", \"\\\\$\");\n-        String expectedNameExcl = getTestMethod(exclude)\n-                .replace('.', '\/')\n-                .replace(\"$\", \"\\\\$\");\n-\n+        String method1regex = testMethodNameForRegex(getTestMethod(METHOD1));\n+        String method2regex = testMethodNameForRegex(getTestMethod(METHOD2));\n+        String method3regex = testMethodNameForRegex(getTestMethod(METHOD3));\n@@ -124,2 +122,21 @@\n-            oa.shouldMatch(\"# *fatal error: \" + ct + \" *\" + expectedNameIncl + \".*: Hit MemLimit .*limit: 4096.*\");\n-            oa.shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+\n+            \/\/ method 2 should have hit its tiny limit\n+            oa.shouldMatch(\"# *fatal error: \" + ct + \" *\" + method2regex + \".*: Hit MemLimit .*limit: 4096.*\");\n+\n+            \/\/ none of the other ones should have hit a limit\n+            oa.shouldNotMatch(method1regex + \".*Hit MemLimit\");\n+            oa.shouldNotMatch(method3regex + \".*Hit MemLimit\");\n+\n+            \/\/ Make sure we get a non-zero-sized replay file (JDK-8331314)\n+            oa.shouldContain(\"# Compiler replay data is saved as:\");\n+            String replayfile = oa.firstMatch(\"# (\\\\S+replay_pid\\\\d+\\\\.log)\", 1);\n+            if (replayfile == null) {\n+                throw new RuntimeException(\"Found no replay file in output\");\n+            }\n+            File f = new File(replayfile);\n+            if (!f.exists()) {\n+                throw new RuntimeException(\"Replayfile \" + replayfile + \" not found\");\n+            }\n+            if (f.length() == 0) {\n+                throw new RuntimeException(\"Replayfile \" + replayfile + \" has size 0\");\n+            }\n@@ -127,4 +144,11 @@\n-            \/\/ Should see trace output when methods are compiled\n-            oa.shouldHaveExitValue(0)\n-                    .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n-                    .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+            oa.shouldHaveExitValue(0);\n+\n+            \/\/ In debug builds we have an inbuilt MemLimit. It is very high, so we don't expect it to fire in this test.\n+            \/\/ But it will still show up in the final report.\n+            String implicitMemoryLimit = Platform.isDebugBuild() ? \"1024M\" : \"-\";\n+\n+            \/\/ With C2, we print number of nodes, with C1 we don't\n+            String numberNodesRegex = c2 ? \"\\\\d+\" : \"-\";\n+\n+            \/\/ method 2 should have hit its tiny limit\n+            oa.shouldMatch(ct + \" \" + method2regex + \".*: Hit MemLimit \\\\(limit: 4096 now: \\\\d+\\\\)\");\n@@ -132,2 +156,3 @@\n-            \/\/ Expect this log line\n-            oa.shouldMatch(\".*\" + expectedNameIncl + \".*Hit MemLimit.*\");\n+            \/\/ neither of the other ones should have hit a limit\n+            oa.shouldNotMatch(method1regex + \".*Hit MemLimit\");\n+            oa.shouldNotMatch(method3regex + \".*Hit MemLimit\");\n@@ -135,2 +160,15 @@\n-            \/\/ Expect final output to contain \"oom\"\n-            oa.shouldMatch(\".*oom.*\" + expectedNameIncl + \".*\");\n+            \/\/ Final report:\n+            \/\/ Method 1 should show up as \"ok\" and with the default limit, e.g.\n+            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+            \/\/ 32728     0         32728     ok     -       1024M   0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +\" + numberNodesRegex + \" +\" + implicitMemoryLimit + \" +.* +\" + method1regex);\n+\n+            \/\/ Method 2 should show up as \"oom\" and with its tiny limit, e.g.\n+            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+            \/\/ 32728     0         32728     oom     -       4096B   0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +oom +\" + numberNodesRegex + \" +4096B +.* +\" + method2regex);\n+\n+            \/\/ Method 3 should show up as \"ok\", and with no limit, even in debug builds, e.g.\n+            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+            \/\/ 32728     0         32728     ok     -       -        0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +\" + numberNodesRegex + \" +- +.* +\" + method3regex);\n@@ -149,0 +187,5 @@\n+    private static String testMethodNameForRegex(String m) {\n+        return m.replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+    }\n+\n@@ -153,0 +196,1 @@\n+            method3();\n@@ -159,0 +203,1 @@\n+        static void method3() {}\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandMemLimit.java","additions":78,"deletions":33,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +35,1 @@\n+import jdk.test.lib.Platform;\n@@ -71,3 +73,4 @@\n-        oa.shouldHaveExitValue(0)\n-          .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n-          .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+        oa.shouldHaveExitValue(0).\n+                shouldMatch(\"Arena usage.*\" + expectedNameIncl + \".*\").\n+                shouldNotMatch(\"Arena usage.*\" + expectedNameExcl + \".*\");\n+\n@@ -77,5 +80,13 @@\n-        \/\/ total     NA        RA        result  #nodes  time    type  #rc thread              method\n-        \/\/ 211488    66440     77624     ok      13      0.057   c2    2   0x00007fb49428db70  compiler\/print\/CompileCommandPrintMemStat$TestMain::method1(()V)\n-        oa.shouldMatch(\"total.*method\");\n-        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*\" + expectedNameIncl + \".*\");\n-        oa.shouldNotMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*\" + expectedNameExcl + \".*\");\n+        \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+        \/\/ 2149912   0         1986272   ok      -       -       0.101   c1    1   0x000000015180a600  jdk\/internal\/org\/objectweb\/asm\/Frame::execute((IILjdk\/internal\/org\/objectweb\/asm\/Symbol;Ljdk\/internal\/org\/objectweb\/asm\/SymbolTable;)V)        oa.shouldMatch(\"total.*method\");\n+        \/\/ or\n+        \/\/ 537784    98184     208536    ok      267     -       0.096   c2    1   0x0000000153019c00  jdk\/internal\/classfile\/impl\/BufWriterImpl::writeU1((I)V) 4521912   0         1986272   ok      -       -       0.101   c1    1   0x000000015180a600  jdk\/internal\/org\/objectweb\/asm\/Frame::execute((IILjdk\/internal\/org\/objectweb\/asm\/Symbol;Ljdk\/internal\/org\/objectweb\/asm\/SymbolTable;)V)        oa.shouldMatch(\"total.*method\");\n+        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +(\\\\d+|-) +.*\" + expectedNameIncl + \".*\");\n+\n+        \/\/ In debug builds, we have a default memory limit enabled. That implies MemStat. Therefore we\n+        \/\/ expect to see all methods, not just the one we specified on the command line.\n+        if (Platform.isDebugBuild()) {\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +(\\\\d+|-) +.*\" + expectedNameExcl + \".*\");\n+        } else {\n+            oa.shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8324517\n+ * @summary C2: out of bound array load because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ *\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n+    private static int intField;\n+    private static long longField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(9, 10, 1, true);\n+            test1(9, 10, 1, false);\n+            test2(9, 10, 1, true);\n+            test2(9, 10, 1, false);\n+            test3(9, 10, 1, true);\n+            test3(9, 10, 1, false);\n+            test4(9, 10, 1, true);\n+            test4(9, 10, 1, false);\n+            test5(9, 10, 1, true);\n+            test5(9, 10, 1, false);\n+            test6(9, 10, 1, true);\n+            test6(9, 10, 1, false);\n+            test7(9, 10, 1, true);\n+            test7(9, 10, 1, false);\n+            test8(9, 10, 1, true);\n+            test8(9, 10, 1, false);\n+            test9(9, 10, 1, true);\n+            test9(9, 10, 1, false);\n+            test10(9, 10, 1, true);\n+            test10(9, 10, 1, false);\n+            test11(9, 10, 1, true);\n+            test11(9, 10, 1, false);\n+            test12(9, 10, 1, true);\n+            test12(9, 10, 1, false);\n+            test13(9, 10, 1, true);\n+            test13(9, 10, 1, false);\n+        }\n+        try {\n+            test1(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test3(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test4(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test5(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test6(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test7(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test8(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test9(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test10(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test11(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test12(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test13(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static void test1(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test2(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test3(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test4(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test5(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test6(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test7(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+    private static void test8(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test9(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test10(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test11(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test12(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test13(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void notInlined(int[] array) {\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8322726\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *\n+ * @compile TestMHUnloaded.java TestMHUnloadedHelper.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller compiler.runtime.unloaded.TestMHUnloadedHelper\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -Xbatch -XX:-TieredCompilation -XX:CompileCommand=exclude,*::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining\n+ *                      compiler.runtime.unloaded.TestMHUnloaded\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -Xbatch -XX:-TieredCompilation -XX:CompileCommand=exclude,*::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                      compiler.runtime.unloaded.TestMHUnloaded\n+ *\/\n+\n+package compiler.runtime.unloaded;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+public class TestMHUnloaded {\n+    public static void main(String[] args) {\n+        TestMHUnloadedHelper.test(MethodHandles.lookup()); \/\/ launch test in bootstrap loader context\n+        TestMHUnloadedHelper.testConstant(MethodHandles.lookup()); \/\/ launch test in bootstrap loader context\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/unloaded\/TestMHUnloaded.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.runtime.unloaded;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.BiPredicate;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+\/\/ Operates in bootstrap loader context.\n+public class TestMHUnloadedHelper {\n+    private static final MethodType METHOD_TYPE = MethodType.methodType(BiPredicate.class,\n+                                                                        BiPredicate.class, BiPredicate.class);\n+\n+    static byte[] generateClassFile(Class<?> caller) {\n+        var cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        String name = caller.getName().replace('.', '\/');\n+        cw.visit(V19, ACC_PUBLIC | ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n+        {\n+            var mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"test\", METHOD_TYPE.toMethodDescriptorString(), null, null);\n+            mv.visitCode();\n+            mv.visitIntInsn(ALOAD, 1);\n+            mv.visitInsn(ARETURN);\n+            mv.visitMaxs(0, 0);\n+        }\n+        return cw.toByteArray();\n+    }\n+\n+    public static MethodHandle generateTest(MethodHandles.Lookup caller) {\n+        \/\/ Loaded in the caller context.\n+        byte[] classBytes = generateClassFile(caller.lookupClass());\n+        try {\n+            MethodHandles.Lookup lookup = caller.defineHiddenClass(classBytes, true);\n+            MethodHandle test = lookup.findStatic(lookup.lookupClass(), \"test\", METHOD_TYPE);\n+            test = MethodHandles.permuteArguments(test, test.type(), 1, 0); \/\/ mix arguments\n+            return test;\n+        } catch (Throwable e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    static BiPredicate[] ps = new BiPredicate[] { (a, b) -> false,\n+                                                  (a, b) -> true };\n+\n+    public static void test(MethodHandles.Lookup caller) {\n+        MethodHandle test = generateTest(caller);\n+\n+        for (int i = 0; i < 20_000; i++) {\n+            try {\n+                BiPredicate pr = (BiPredicate)test.invokeExact(ps[1], ps[0]);\n+                if (pr != ps[1]) {\n+                    throw new AssertionError(\"mismatch\");\n+                }\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+    }\n+\n+    public static void testConstant(MethodHandles.Lookup caller) {\n+        MethodHandle test = generateTest(caller);\n+\n+        \/\/ testMH() { return test(ps2, ps1); } where test(a, b) { return b; }.\n+        test = test.bindTo(ps[1]).bindTo(ps[0]); \/\/ make argument concrete types visible to the JIT-compiler\n+\n+        for (int i = 0; i < 20_000; i++) {\n+            try {\n+                BiPredicate pr = (BiPredicate)test.invokeExact();\n+                if (pr != ps[1]) {\n+                    throw new AssertionError(\"mismatch\");\n+                }\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/unloaded\/TestMHUnloadedHelper.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331575\n+ * @summary C2: crash when ConvL2I is split thru phi at LongCountedLoop\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=92643864 TestLongCountedLoopConvL2I\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestLongCountedLoopConvL2I\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestLongCountedLoopConvL2I\n+ *\/\n+\n+public class TestLongCountedLoopConvL2I {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper1(42);\n+            test1(0);\n+        }\n+    }\n+\n+    private static int test1(int res) {\n+        int k = 1;\n+        for (; k < 2; k *= 2) {\n+        }\n+        long i = testHelper1(k);\n+        for (; i > 0; i--) {\n+            res += 42 \/ ((int) i);\n+            for (int j = 1; j < 10; j *= 2) {\n+\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private static long testHelper1(int k) {\n+        if (k == 2) {\n+            return 100;\n+        } else {\n+            return 99;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestLongCountedLoopConvL2I.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331575\n+ * @summary C2: crash when ConvL2I is split thru phi at LongCountedLoop\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestLongCountedLoopConvL2I2.* TestLongCountedLoopConvL2I2\n+ *\/\n+\n+public class TestLongCountedLoopConvL2I2 {\n+    static int x = 34;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 2; i++) {\n+            test();\n+        }\n+    }\n+\n+    static int test() {\n+        int a = 5, b = 6;\n+        long lArr[] = new long[2];\n+\n+        for (long i = 159; i > 1; i -= 3) {\n+            a += 3;\n+            for (int j = 1; j < 4; j++) {\n+                if (a == 9) {\n+                    if (x == 73) {\n+                        try {\n+                            b = 10 \/ (int) i;\n+                        } catch (ArithmeticException a_e) {\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return b;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestLongCountedLoopConvL2I2.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -45,1 +45,2 @@\n- * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.arch == \"aarch64\"\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.arch == \"aarch64\" |\n+ *           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReverseBytesTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\")\n+*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\") |\n+*           (os.simpleArch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n@@ -42,2 +43,4 @@\n-    private long[] input;\n-    private int[] output;\n+    private long[] inputLong;\n+    private int[] outputLong;\n+    private int[] inputInt;\n+    private int[] outputInt;\n@@ -52,2 +55,4 @@\n-        input = new long[LEN];\n-        output = new int[LEN];\n+        inputLong = new long[LEN];\n+        outputLong = new int[LEN];\n+        inputInt = new int[LEN];\n+        outputInt = new int[LEN];\n@@ -56,1 +61,2 @@\n-            input[i] = rng.nextLong();\n+            inputLong[i] = rng.nextLong();\n+            inputInt[i] = rng.nextInt();\n@@ -61,2 +67,2 @@\n-    @IR(counts = {IRNode.COUNTTRAILINGZEROS_VL, \"> 0\"})\n-    public void vectorizeNumberOfTrailingZeros() {\n+    @IR(counts = {IRNode.COUNT_TRAILING_ZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfTrailingZerosLong() {\n@@ -64,1 +70,1 @@\n-            output[i] = Long.numberOfTrailingZeros(input[i]);\n+            outputLong[i] = Long.numberOfTrailingZeros(inputLong[i]);\n@@ -69,2 +75,2 @@\n-    @IR(counts = {IRNode.COUNTLEADINGZEROS_VL, \"> 0\"})\n-    public void vectorizeNumberOfLeadingZeros() {\n+    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfLeadingZerosLong() {\n@@ -72,1 +78,1 @@\n-            output[i] = Long.numberOfLeadingZeros(input[i]);\n+            outputLong[i] = Long.numberOfLeadingZeros(inputLong[i]);\n@@ -76,3 +82,3 @@\n-    @Run(test = {\"vectorizeNumberOfTrailingZeros\", \"vectorizeNumberOfLeadingZeros\"})\n-    public void checkResult() {\n-        vectorizeNumberOfTrailingZeros();\n+    @Run(test = {\"vectorizeNumberOfTrailingZerosLong\", \"vectorizeNumberOfLeadingZerosLong\"})\n+    public void checkResultLong() {\n+        vectorizeNumberOfTrailingZerosLong();\n@@ -80,1 +86,1 @@\n-            Asserts.assertEquals(output[i], Long.numberOfTrailingZeros(input[i]));\n+            Asserts.assertEquals(outputLong[i], Long.numberOfTrailingZeros(inputLong[i]));\n@@ -82,1 +88,1 @@\n-        vectorizeNumberOfLeadingZeros();\n+        vectorizeNumberOfLeadingZerosLong();\n@@ -84,1 +90,30 @@\n-            Asserts.assertEquals(output[i], Long.numberOfLeadingZeros(input[i]));\n+            Asserts.assertEquals(outputLong[i], Long.numberOfLeadingZeros(inputLong[i]));\n+        }\n+    }\n+\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNT_TRAILING_ZEROS_VI, \"> 0\"})\n+    public void vectorizeNumberOfTrailingZerosInt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            outputInt[i] = Integer.numberOfTrailingZeros(inputInt[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VI, \"> 0\"})\n+    public void vectorizeNumberOfLeadingZerosInt() {\n+        for (int i = 0; i < LEN; ++i) {\n+            outputInt[i] = Integer.numberOfLeadingZeros(inputInt[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"vectorizeNumberOfTrailingZerosInt\", \"vectorizeNumberOfLeadingZerosInt\"})\n+    public void checkResultInt() {\n+        vectorizeNumberOfTrailingZerosInt();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(outputInt[i], Integer.numberOfTrailingZeros(inputInt[i]));\n+        }\n+        vectorizeNumberOfLeadingZerosInt();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(outputInt[i], Integer.numberOfLeadingZeros(inputInt[i]));\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":53,"deletions":18,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+        int err = 0;\n@@ -48,1 +49,1 @@\n-        test.checkResult();\n+        err += test.checkResult();\n@@ -54,1 +55,4 @@\n-        test.checkResult();\n+        err += test.checkResult();\n+        if (err > 0) {\n+            throw new RuntimeException(\"Error!\");\n+        }\n@@ -71,1 +75,2 @@\n-    public void checkResult() {\n+    public int checkResult() {\n+        int err = 0;\n@@ -75,1 +80,3 @@\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+                err++;\n+                System.err.println(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected +\n+                                   \", input[\" + i + \"] == \" + Integer.toBinaryString(input[i]));\n@@ -78,0 +85,1 @@\n+        return err;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVector.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-*           os.simpleArch == \"aarch64\"\n+*           os.simpleArch == \"aarch64\" |\n+*           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n@@ -35,0 +36,1 @@\n+\n@@ -65,1 +67,3 @@\n-        checkResult();\n+        if (checkResult() > 0) {\n+            throw new RuntimeException(\"Error!\");\n+        }\n@@ -68,1 +72,2 @@\n-    public void checkResult() {\n+    public int checkResult() {\n+        int err = 0;\n@@ -72,1 +77,3 @@\n-                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected);\n+                err++;\n+                System.err.println(\"Invalid result: output[\" + i + \"] = \" + output[i] + \" != \" + expected +\n+                                   \", input[\" + i + \"] == \" + Long.toBinaryString(input[i]));\n@@ -75,0 +82,1 @@\n+        return err;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.simpleArch == \"AArch64\"\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") | os.simpleArch == \"AArch64\" |\n+ *           (os.simpleArch == \"riscv64\" & vm.cpu.features ~= \".*zvbb.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestReverseBytes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n+ * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\") | (os.simpleArch == \"riscv64\")\n@@ -102,0 +102,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VI, \">0\"})\n@@ -113,0 +116,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VI, \">0\"})\n@@ -124,0 +130,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VS, \">0\"})\n@@ -135,0 +144,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VS, \">0\"})\n@@ -146,0 +158,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.LSHIFT_VL, \">0\"})\n@@ -157,0 +172,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.URSHIFT_VL, \">0\"})\n@@ -190,0 +208,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VS, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.LSHIFT_VB, \">0\"})\n@@ -205,0 +208,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VB, \">0\"})\n@@ -216,0 +222,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VB, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -196,0 +196,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.LSHIFT_VC, \">0\"})\n@@ -207,0 +210,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.URSHIFT_VC, \">0\"})\n@@ -218,0 +224,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.URSHIFT_VC, \">0\"})\n@@ -230,0 +239,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        counts = {IRNode.REVERSE_BYTES_VS, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.LSHIFT_VI, \">0\"})\n@@ -214,0 +217,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VI, \">0\"})\n@@ -225,0 +231,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.URSHIFT_VI, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n+ * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\") | (os.simpleArch == \"riscv64\")\n@@ -195,0 +195,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.LSHIFT_VL, \">0\"})\n@@ -206,0 +209,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VL, \">0\"})\n@@ -217,0 +223,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.URSHIFT_VL, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -194,0 +194,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.LSHIFT_VS, \">0\"})\n@@ -205,0 +208,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VS, \">0\"})\n@@ -241,0 +247,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"v\", \"true\"},\n+        counts = {IRNode.RSHIFT_VS, \">0\"})\n@@ -253,0 +262,3 @@\n+    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+        counts = {IRNode.REVERSE_BYTES_VS, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @key cgroups\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestContainerInfo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,7 +74,7 @@\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize }, values, -1, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + smallValue }, values, smallValue, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + largeValue }, values, largeValue, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=0\" }, values, -1, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:InitialHeapSize=\" + smallValue }, values, -1, smallValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:InitialHeapSize=\" + largeValue }, values, -1, largeValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:InitialHeapSize=0\" }, values, -1, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize }, -1, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + smallValue }, smallValue, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + largeValue }, largeValue, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=0\" }, -1, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:InitialHeapSize=\" + smallValue }, -1, smallValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:InitialHeapSize=\" + largeValue }, -1, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:InitialHeapSize=0\" }, -1, -1);\n@@ -82,3 +82,3 @@\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + smallValue }, values, smallValue, smallValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + largeValue }, values, smallValue, largeValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + largeValue, \"-XX:InitialHeapSize=\" + largeValue }, values, largeValue, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + smallValue }, smallValue, smallValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + largeValue }, smallValue, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-XX:MinHeapSize=\" + largeValue, \"-XX:InitialHeapSize=\" + largeValue }, largeValue, largeValue);\n@@ -87,10 +87,10 @@\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\" }, values, -1, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + smallValue }, values, smallValue, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + largeValue }, values, largeValue, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=0\" }, values, -1, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:InitialHeapSize=\" + smallValue }, values, -1, smallValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:InitialHeapSize=\" + largeValue }, values, -1, largeValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:InitialHeapSize=0\" }, values, -1, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + smallValue }, values, smallValue, smallValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + largeValue }, values, smallValue, largeValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + largeValue, \"-XX:InitialHeapSize=\" + largeValue }, values, largeValue, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\" }, -1, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + smallValue }, smallValue, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + largeValue }, largeValue, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=0\" }, -1, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:InitialHeapSize=\" + smallValue }, -1, smallValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:InitialHeapSize=\" + largeValue }, -1, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:InitialHeapSize=0\" }, -1, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + smallValue }, smallValue, smallValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + smallValue, \"-XX:InitialHeapSize=\" + largeValue }, smallValue, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms0\", \"-XX:MinHeapSize=\" + largeValue, \"-XX:InitialHeapSize=\" + largeValue }, largeValue, largeValue);\n@@ -99,6 +99,6 @@\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue }, values, -1, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:MinHeapSize=\" + smallValue }, values, smallValue, smallValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:MinHeapSize=0\" }, values, -1, smallValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:InitialHeapSize=\" + smallValue }, values, smallValue, smallValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:InitialHeapSize=\" + largeValue }, values, smallValue, largeValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:InitialHeapSize=0\" }, values, smallValue, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue }, -1, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:MinHeapSize=\" + smallValue }, smallValue, smallValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:MinHeapSize=0\" }, -1, smallValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:InitialHeapSize=\" + smallValue }, smallValue, smallValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:InitialHeapSize=\" + largeValue }, smallValue, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + smallValue, \"-XX:InitialHeapSize=0\" }, smallValue, -1);\n@@ -107,3 +107,3 @@\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + largeValue }, values, largeValue, largeValue);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + largeValue, \"-XX:InitialHeapSize=0\" }, values, largeValue, -1);\n-    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + largeValue, \"-XX:MinHeapSize=0\" }, values, -1, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + largeValue }, largeValue, largeValue);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + largeValue, \"-XX:InitialHeapSize=0\" }, largeValue, -1);\n+    checkErgonomics(new String[] { gcflag, \"-Xmx\" + maxHeapSize, \"-Xms\" + largeValue, \"-XX:MinHeapSize=0\" }, -1, largeValue);\n@@ -247,1 +247,1 @@\n-  public static void checkErgonomics(String[] args, long[] newoldsize,\n+  public static void checkErgonomics(String[] args,\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxHeapSizeTools.java","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.arguments;\n+\n+\/*\n+ * @test TestParallelGCErgo\n+ * @bug 8272364\n+ * @requires vm.gc.Parallel\n+ * @summary Verify ParallelGC minimum young and old ergonomics are setup correctly\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @library \/\n+ * @run driver gc.arguments.TestParallelGCErgo\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+\n+public class TestParallelGCErgo {\n+    private static final long HEAPWORD_SIZE = Platform.is64bit() ? 8 : 4;\n+    \/\/ Must be a power of 2\n+    private static final long GEN_ALIGNMENT = 64 * 1024 * HEAPWORD_SIZE;\n+\n+    private static final long MINIMUM_HEAP_SIZE = 256 * 1024 * 1024; \/\/ 256M\n+    private static final long EXPECTED_MIN_YOUNG = alignDown(MINIMUM_HEAP_SIZE \/ 3, GEN_ALIGNMENT);\n+    private static final long EXPECTED_MIN_OLD = MINIMUM_HEAP_SIZE - EXPECTED_MIN_YOUNG;  \/\/ heap size = young size + old size\n+\n+    \/\/ s has to be a power of 2\n+    private static long alignDown(long s, long align) {\n+        return s & (~(align-1));\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ArrayList<String> flagList = new ArrayList<String>();\n+        flagList.add(\"-XX:+UseParallelGC\");\n+        flagList.add(\"-Xms256m\");\n+        flagList.add(\"-Xmx1g\");\n+        flagList.add(\"-Xlog:gc+heap=trace\");\n+        flagList.add(\"-version\");\n+\n+        OutputAnalyzer output = GCArguments.executeTestJava(flagList);\n+        output.shouldHaveExitValue(0);\n+\n+        String stdout = output.getStdout();\n+        long minimumHeap = getFlagValue(\"Minimum heap\", stdout);\n+        if (minimumHeap != MINIMUM_HEAP_SIZE) {\n+            throw new RuntimeException(\"Wrong value for minimum heap. Expected \" + MINIMUM_HEAP_SIZE + \" but got \" + minimumHeap);\n+        }\n+\n+        long minimumYoung = getFlagValue(\"Minimum young\", stdout);\n+        if (minimumYoung != EXPECTED_MIN_YOUNG) {\n+            throw new RuntimeException(\"Wrong value for minimum young. Expected \" + EXPECTED_MIN_YOUNG + \" but got \" + minimumYoung);\n+        }\n+\n+        long minimumOld = getFlagValue(\"Minimum old\", stdout);\n+        if (minimumOld != EXPECTED_MIN_OLD) {\n+            throw new RuntimeException(\"Wrong value for minimum old. Expected \" + EXPECTED_MIN_OLD + \" but got \" + minimumOld);\n+        }\n+    }\n+\n+    private static long getFlagValue(String flag, String where) {\n+        Matcher m = Pattern.compile(flag + \" \\\\d+\").matcher(where);\n+        if (!m.find()) {\n+            throw new RuntimeException(\"Could not find value for flag \" + flag + \" in output string\");\n+        }\n+        String match = m.group();\n+        return Long.parseLong(match.substring(match.lastIndexOf(\" \") + 1, match.length()));\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCErgo.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.x;\n+\n+\/*\n+ * @test TestDeprecated\n+ * @requires vm.gc.ZSinglegen\n+ * @summary Test ZGenerational Deprecated\n+ * @library \/test\/lib\n+ * @run driver gc.x.TestDeprecated\n+ *\/\n+\n+import java.util.LinkedList;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestDeprecated {\n+    static class Test {\n+        public static void main(String[] args) throws Exception {}\n+    }\n+    public static void main(String[] args) throws Exception {\n+        ProcessTools.executeLimitedTestJava(\"-XX:+UseZGC\",\n+                                            \"-XX:-ZGenerational\",\n+                                            \"-Xlog:gc+init\",\n+                                            Test.class.getName())\n+                    .shouldContain(\"Option ZGenerational was deprecated\")\n+                    .shouldContain(\"Using deprecated non-generational mode\")\n+                    .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestDeprecated.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/*\n+ * @test TestDefault\n+ * @requires vm.gc.ZGenerational\n+ * @summary Test that ZGC Generational Mode is Default\n+ * @library \/test\/lib\n+ * @run driver gc.z.TestDefault\n+ *\/\n+\n+import java.util.LinkedList;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestDefault {\n+    static class Test {\n+        public static void main(String[] args) throws Exception {}\n+    }\n+    public static void main(String[] args) throws Exception {\n+        ProcessTools.executeLimitedTestJava(\"-XX:+UseZGC\",\n+                                            \"-Xlog:gc+init\",\n+                                            Test.class.getName())\n+                    .shouldNotContain(\"Option ZGenerational was deprecated\")\n+                    .shouldNotContain(\"Using deprecated non-generational mode\")\n+                    .shouldContain(\"GC Workers for Old Generation\")\n+                    .shouldContain(\"GC Workers for Young Generation\")\n+                    .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestDefault.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -64,0 +64,1 @@\n+            {\"ZGenerational\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-        runAndCheck(new Flags(\"-Xcomp\", \"-XX:CICrashAt=1\", \"--version\"));\n+        runAndCheck(new Flags(\"-Xcomp\", \"-XX:+CICountNative\", \"-XX:CICrashAt=1\", \"--version\"));\n@@ -115,1 +115,0 @@\n-        \/\/ Use -XX:-TieredCompilation as C1 is currently not aborting the VM (JDK-8264899).\n@@ -117,1 +116,1 @@\n-        runAndCheck(new Flags(\"-XX:-TieredCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AbortVMOnException=MyException\",\n+        runAndCheck(new Flags(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AbortVMOnException=MyException\",\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestDwarf.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test the NMT scale parameter\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary JcmdSummaryStatistics\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class JcmdSummaryStatistics {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        OutputAnalyzer output;\n+        \/\/ Grab my own PID\n+        String pid = Long.toString(jdk.test.lib.process.ProcessTools.getProcessId());\n+\n+        \/\/ Run 'jcmd <pid> VM.native_memory statistics=true'\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"statistics=true\"});\n+        output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContainMultiLinePattern(\n+                \"Native Memory Tracking Statistics:\",\n+                \"State: summary\",\n+                \"Preinit state:\",\n+                \"entries:\",\n+                \"pre-init mallocs:\",\n+                \"MallocLimit:\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/JcmdSummaryStatistics.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8216184\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LongClassListPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,6 @@\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n@@ -97,1 +103,1 @@\n-            \"TESTCASE A6: extraneous spaces, tab characters and trailing new line characters\",\n+            \"TESTCASE A6: extraneous spaces, tab characters, trailing new line characters, and trailing comment line\",\n@@ -104,1 +110,2 @@\n-                \"CustomLoadee2 id: 5 super: 1 interfaces: 3 4 source: \" + customJarPath      \/\/ preceding spaces\n+                \"CustomLoadee2 id: 5 super: 1 interfaces: 3 4 source: \" + customJarPath,      \/\/ preceding spaces\n+                \"#last line is a comment\"\n@@ -107,5 +114,6 @@\n-        int _max_allowed_line = 4096; \/\/ Must match ClassListParser::_max_allowed_line in C code.\n-        int _line_buf_extra = 10;     \/\/ Must match ClassListParser::_line_buf_extra in C code.\n-        StringBuffer sbuf = new StringBuffer();\n-        for (int i=0; i<_max_allowed_line+1; i++) {\n-          sbuf.append(\"x\");\n+        \/\/ Tests for corner cases in the C++ class LineReader, or invalid UTF8. These can't\n+        \/\/ be tested with dumpShouldPass\/dumpShouldFail as we need to prepare a special class\n+        \/\/ list file.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < 6500; i++) {\n+            sb.append(\"X123456789\");\n@@ -114,6 +122,12 @@\n-        dumpShouldFail(\n-            \"TESTCASE A7: bad input - line too long\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.1: Long line (65000 chars)\");\n+            String longName = sb.toString(); \/\/ 65000 chars long\n+            String classList = \"LongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(longName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find \" + longName);\n+        }\n@@ -121,2 +135,13 @@\n-        for (int i=0; i<_line_buf_extra + 1000; i++) {\n-          sbuf.append(\"X\");\n+        {\n+            System.out.println(\"TESTCASE A7.2: Name Length > Symbol::max_length()\");\n+            String tooLongName = sb.toString() + sb.toString();\n+            String classList = \"TooLongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"java\/lang\/Object\\n\");\n+                fw.write(tooLongName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(classList + \":2 class name too long\") \/\/ test line number as well.\n+                .shouldHaveExitValue(1);\n@@ -125,6 +150,24 @@\n-        dumpShouldFail(\n-            \"TESTCASE A8: bad input - line too long: try to overflow C buffer\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.3: File doesn't end with newline\");\n+            String classList = \"NoTrailingNewLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"No\/Such\/ClassABCD\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find No\/Such\/ClassABCD\");\n+        }\n+        {\n+            System.out.println(\"TESTCASE A7.4: invalid UTF8 character\");\n+            String classList = \"BadUTF8.classlist\";\n+            try (FileOutputStream fos = new FileOutputStream(classList)) {\n+                byte chars[] = new byte[] { (byte)0xa0, (byte)0xa1, '\\n'};\n+                fos.write(chars);\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(classList + \":1 class name is not valid UTF8\") \/\/ test line number as well.\n+                .shouldHaveExitValue(1);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java","additions":65,"deletions":22,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+\/**\n+ * This is launched from TestLambdaInvokers.\n+ *\/\n@@ -47,0 +50,4 @@\n+\n+        mh = MethodHandles.dropArguments(MethodHandles.zero(Object.class), 0, Object.class, int.class);\n+        MethodHandle inv = MethodHandles.invoker(mh.type());\n+        invoke(inv, mh, args, 3);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/CDSLambdaInvoker.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8280767\n+ * @bug 8280767 8327499\n@@ -62,0 +62,1 @@\n+             \"-Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true\",\n@@ -72,0 +73,4 @@\n+\n+                 \/\/ java.lang.invoke.Invokers$Holder has invoker(Object,Object,Object,int)Object available\n+                 \/\/ from the archives\n+                 output.shouldContain(\"[LF_RESOLVE] java.lang.invoke.Invokers$Holder invoker L3I_L (success)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestLambdaInvokers.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-                    .returnInstruction(TypeKind.BooleanType)\n+                    .return_(TypeKind.BooleanType)\n@@ -338,1 +338,1 @@\n-                    .returnInstruction(TypeKind.BooleanType);\n+                    .return_(TypeKind.BooleanType);\n@@ -411,1 +411,1 @@\n-                    .returnInstruction(TypeKind.BooleanType)\n+                    .return_(TypeKind.BooleanType)\n@@ -414,1 +414,1 @@\n-                    .returnInstruction(TypeKind.BooleanType);\n+                    .return_(TypeKind.BooleanType);\n@@ -494,1 +494,1 @@\n-                    .returnInstruction(TypeKind.BooleanType)\n+                    .return_(TypeKind.BooleanType)\n@@ -497,1 +497,1 @@\n-                    .returnInstruction(TypeKind.BooleanType);\n+                    .return_(TypeKind.BooleanType);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,8 +95,0 @@\n-        if (count != 3) {\n-            Assert.fail(\"Expected three directives - found \" + count);\n-        }\n-\n-        \/\/ Test replacement with some directives from file\n-        output = executor.execute(\"Compiler.directives_replace \" + filename);\n-        output = executor.execute(\"Compiler.directives_print\");\n-        count = find(output, \"Directive:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerDirectivesDCMDTest.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2023, BELLSOFT. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test DirectivesRefreshTest\n- * @summary Test of forced recompile after compiler directives changes by diagnostic command\n- * @requires vm.compiler1.enabled & vm.compiler2.enabled\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   -XX:-BackgroundCompilation\n- *                   serviceability.dcmd.compiler.DirectivesRefreshTest\n- *\/\n-\n-package serviceability.dcmd.compiler;\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.dcmd.CommandExecutor;\n-import jdk.test.lib.dcmd.JMXExecutor;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.lang.reflect.Method;\n-import java.util.Random;\n-\n-import static jdk.test.lib.Asserts.assertEQ;\n-\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_NONE;\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE;\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n-\n-public class DirectivesRefreshTest {\n-\n-    static Path cmdPath = Paths.get(System.getProperty(\"test.src\", \".\"), \"refresh_control.txt\");\n-    static WhiteBox wb = WhiteBox.getWhiteBox();\n-    static Random random = new Random();\n-\n-    static Method method;\n-    static CommandExecutor executor;\n-\n-    static int callable() {\n-        int result = 0;\n-        for (int i = 0; i < 100; i++) {\n-            result += random.nextInt(100);\n-        }\n-        return result;\n-    }\n-\n-    static void checkCompilationLevel(Method method, int level) {\n-        assertEQ(wb.getMethodCompilationLevel(method), level, \"Compilation level\");\n-    }\n-\n-    static void setup() throws Exception {\n-        method = DirectivesRefreshTest.class.getDeclaredMethod(\"callable\");\n-        executor = new JMXExecutor();\n-\n-        System.out.println(\"Compilation with C2\");\n-\n-        \/\/ Happens with fairly hot methods.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    static void testDirectivesAddRefresh() {\n-        System.out.println(\"Force forbid C2 via directive, method deoptimized\");\n-\n-        var output = executor.execute(\"Compiler.directives_add -r \" + cmdPath.toString());\n-        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n-        \/\/ Current handling of 'Exclude' for '-r' clears flags.\n-        checkCompilationLevel(method, COMP_LEVEL_NONE);\n-\n-        System.out.println(\"C2 is excluded, re-compilation with C1\");\n-\n-        \/\/ Sanity check for the directive.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-        checkCompilationLevel(method, COMP_LEVEL_NONE);\n-\n-        \/\/ Happens with fairly hot methods.\n-        wb.enqueueMethodForCompilation(method, COMP_LEVEL_SIMPLE);\n-        checkCompilationLevel(method, COMP_LEVEL_SIMPLE);\n-    }\n-\n-    static void testDirectivesClearRefresh() {\n-        System.out.println(\"Re-compilation with C2 due to removed restriction\");\n-\n-        var output = executor.execute(\"Compiler.directives_clear -r\");\n-        output.stderrShouldBeEmpty().stdoutShouldBeEmpty();\n-\n-        \/\/ No need to enqueue the method, \"immediate\" effect of '-r' without deoptimization.\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    static void testDirectivesAddRegular() {\n-        System.out.println(\"No changes if the restriction is not forced\");\n-\n-        \/\/ According to original JEP 165, the directive will be handled\n-        \/\/ \"when a method is submitted for a compilation\".\n-        var output = executor.execute(\"Compiler.directives_add \" + cmdPath.toString());\n-        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n-\n-        \/\/ In this program the method is not called, and here it is not enqueued.\n-        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        setup();\n-        testDirectivesAddRefresh();\n-        testDirectivesClearRefresh();\n-        testDirectivesAddRegular();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/DirectivesRefreshTest.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-[\n-  {\n-    match: \"serviceability.dcmd.compiler.DirectivesRefreshTest::callable\",\n-    c2: {\n-      Exclude: true\n-    }\n-  }\n-]\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/refresh_control.txt","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import org.testng.SkipException;\n@@ -174,0 +175,3 @@\n+        if (Thread.currentThread().isVirtual()) {\n+            throw new SkipException(\"skipping test since current thread is virtual thread\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/PrintTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+            setDaemon(false);\n","filename":"test\/hotspot\/jtreg\/serviceability\/tmtools\/jstack\/DaemonThreadTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/AttachConnector\/plugAttachConnect001\/plugAttachConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/AttachConnector\/plugAttachConnect002\/plugAttachConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/AttachConnector\/plugAttachConnect003\/plugAttachConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/LaunchConnector\/plugLaunchConnect001\/plugLaunchConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/LaunchConnector\/plugLaunchConnect002\/plugLaunchConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/LaunchConnector\/plugLaunchConnect003\/plugLaunchConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/ListenConnector\/plugListenConnect001\/plugListenConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/ListenConnector\/plugListenConnect002\/plugListenConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/ListenConnector\/plugListenConnect003\/plugListenConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect001\/plugMultiConnect001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect002\/plugMultiConnect002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect003\/plugMultiConnect003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,1 +236,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect004\/plugMultiConnect004.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -241,1 +241,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect005\/plugMultiConnect005.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/MultiConnectors\/plugMultiConnect006\/plugMultiConnect006.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/TransportService\/transportService001\/transportService001.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/TransportService\/transportService002\/transportService002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/PlugConnectors\/TransportService\/transportService003\/transportService003.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -161,1 +161,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature001a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature002a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -186,1 +186,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature001a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,1 +178,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/TypeComponent\/genericSignature\/genericSignature002a.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-        logHandler.enableErrorsSummary(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,0 @@\n- * Additionally, in verbose mode a summary of all occured errors will be printed\n- * at the program exit, by automatically invoking method\n- * <code>printErrorsSummary()<\/code>.\n@@ -72,1 +69,1 @@\n-public class Log extends FinalizableObject {\n+public class Log {\n@@ -75,2 +72,0 @@\n-     *\n-     * @deprecated  Tests should not use this field directly.\n@@ -78,2 +73,1 @@\n-    @Deprecated\n-    protected PrintStream out = null;\n+    private PrintStream out = null;\n@@ -117,1 +111,1 @@\n-            if ( level == null )\n+           if ( level == null )\n@@ -138,10 +132,0 @@\n-    \/**\n-     * Is printing errors summary enabled? Default value is <code>true<\/code>;\n-     *\/\n-    private boolean errorsSummaryEnabled = true;\n-\n-    \/**\n-     * Is printing saved verbose messages on error enabled? Default value is <code>true<\/code>;\n-     *\/\n-    private boolean verboseOnErrorEnabled = true;\n-\n@@ -191,2 +175,0 @@\n-        \/\/ install finalizer to print errors summary at exit\n-        registerCleanup();\n@@ -237,28 +219,0 @@\n-    \/**\n-     * Return <i>true<\/i> if printing errors summary at exit is enabled.\n-     *\/\n-    public boolean isErrorsSummaryEnabled() {\n-        return errorsSummaryEnabled;\n-    }\n-\n-    \/**\n-     * Enable or disable printing errors summary at exit.\n-     *\/\n-    public void enableErrorsSummary(boolean enable) {\n-        errorsSummaryEnabled = enable;\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if printing saved verbose messages on error is enabled.\n-     *\/\n-    public boolean isVerboseOnErrorEnabled() {\n-        return errorsSummaryEnabled;\n-    }\n-\n-    \/**\n-     * Enable or disable printing saved verbose messages on error.\n-     *\/\n-    public void enableVerboseOnError(boolean enable) {\n-        verboseOnErrorEnabled = enable;\n-    }\n-\n@@ -318,1 +272,1 @@\n-        if (!verbose() && isVerboseOnErrorEnabled()) {\n+        if (!verbose()) {\n@@ -374,2 +328,0 @@\n-        } else if (isVerboseOnErrorEnabled()) {\n-            keepLog(composeLine(message.toString()));\n@@ -377,1 +329,1 @@\n-            \/\/ ignore\n+            keepLog(composeLine(message.toString()));\n@@ -387,1 +339,1 @@\n-        if (!verbose() && isVerboseOnErrorEnabled()) {\n+        if (!verbose()) {\n@@ -398,3 +350,0 @@\n-        if (isErrorsSummaryEnabled()) {\n-            keepError(msgStr);\n-        }\n@@ -472,1 +421,3 @@\n-        cleanup(); \/\/ flush older log stream\n+        if (out != null) {\n+            out.flush();\n+        }\n@@ -576,53 +527,0 @@\n-    \/**\n-     * Keep the given error <code>message<\/code> into <code>errorsBuffer<\/code>.\n-     *\/\n-    private synchronized void keepError(String message) {\n-        errorsBuffer.addElement(message);\n-    }\n-\n-    \/**\n-     * Print errors messages summary from errors buffer if any;\n-     * print a warning message first.\n-     *\/\n-    private synchronized void printErrorsSummary() {\n-        if (errorsBuffer.size() <= 0)\n-            return;\n-\n-        PrintStream stream = findOutStream();\n-        stream.println();\n-        stream.println();\n-        stream.println(\"#>  \");\n-        stream.println(\"#>  SUMMARY: Following errors occured\");\n-        stream.println(\"#>      during test execution:\");\n-        stream.println(\"#>  \");\n-        stream.flush();\n-\n-        for (Enumeration e = errorsBuffer.elements(); e.hasMoreElements(); ) {\n-            printError((String) e.nextElement());\n-        }\n-    }\n-\n-    \/**\n-     * Print errors summary if mode is verbose, flush and cancel output stream.\n-     *\n-     * This is replacement of the finalize() method and is called when this\n-     * Log instance becomes unreachable.\n-     *\n-     *\/\n-    @Override\n-    public void cleanup() {\n-        if (verbose() && isErrorsSummaryEnabled()) {\n-            printErrorsSummary();\n-        }\n-        if (out != null)\n-            out.flush();\n-        out = null;\n-    }\n-\n-    \/**\n-     * Perform finalization at the exit.\n-     *\/\n-    public void finalizeAtExit() {\n-        cleanup();\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Log.java","additions":10,"deletions":112,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,2 +150,0 @@\n-        log.enableErrorsSummary(false);\n-        log.enableVerboseOnError(false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/BindServer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,1 +238,0 @@\n-        Env.getLog().enableVerboseOnError(true);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/MlvmTestExecutor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,6 +32,0 @@\n-com\/sun\/jdi\/cds\/CDSBreakpointTest.java 8307778 generic-all\n-com\/sun\/jdi\/cds\/CDSDeleteAllBkptsTest.java 8307778 generic-all\n-com\/sun\/jdi\/cds\/CDSFieldWatchpoints.java 8307778 generic-all\n-\n-sun\/tools\/jcmd\/JcmdOutputEncodingTest.java 8308033 generic-all\n-sun\/tools\/jstack\/BasicJStackTest.java 8308033 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -675,1 +675,0 @@\n-javax\/swing\/JRadioButton\/4314194\/bug4314194.java 8298153 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-            getPropOpt(\"test.classes\"),\n+            getPropOpt(\"test.class.path\"),\n","filename":"test\/jdk\/com\/sun\/jdi\/cds\/CDSJDITest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8144100\n+ * @summary checking token sent by client should be done in case-insensitive manner\n+ * @run main BasicAuthToken\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.Base64;\n+import com.sun.net.httpserver.Authenticator;\n+import com.sun.net.httpserver.BasicAuthenticator;\n+import com.sun.net.httpserver.HttpServer;\n+\n+public class BasicAuthToken {\n+    private static final String CRLF = \"\\r\\n\";\n+    private static final String someContext = \"\/test\";\n+\n+    public static void main(String[] args) throws Exception {\n+        HttpServer server = server();\n+        try {\n+            client(server.getAddress().getPort());\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    static HttpServer server() throws Exception {\n+        String realm = \"someRealm\";\n+        ServerAuthenticator authenticator = new ServerAuthenticator(realm);\n+        HttpServer server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        server.createContext(someContext, exchange -> {\n+            if (authenticator.authenticate(exchange) instanceof Authenticator.Failure) {\n+                exchange.sendResponseHeaders(401, -1);\n+                exchange.close();\n+                return;\n+            }\n+            exchange.sendResponseHeaders(200, -1);\n+            exchange.close();\n+        }).setAuthenticator(authenticator);\n+        server.start();\n+        return server;\n+    }\n+\n+    static void client(int port) throws Exception {\n+        try (Socket socket = new Socket(InetAddress.getLoopbackAddress(), port)) {\n+            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            String credentials = \"username:password\";\n+            String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes());\n+            writer.write(\"GET \" + someContext + \" HTTP\/1.1\" + CRLF);\n+            writer.write(\"Host: localhost:\" + port + CRLF);\n+            writer.write(\"User-Agent: Java\/\" + System.getProperty(\"java.version\") + CRLF);\n+            writer.write(\"Authorization: BAsIc \" + encodedCredentials + CRLF);\n+            writer.write(CRLF);\n+            writer.flush();\n+\n+            System.err.println(\"Server response\");\n+            String statusLine = reader.readLine();\n+            System.err.println(statusLine);\n+\n+            if (!statusLine.startsWith(\"HTTP\/1.1 200\")) {\n+                throw new RuntimeException(\"unexpected status line: \" + statusLine);\n+            }\n+            if (!ServerAuthenticator.wasChecked()) {\n+                throw new RuntimeException(\"Authenticator wasn't invoked\");\n+            }\n+        }\n+    }\n+\n+\n+    static class ServerAuthenticator extends BasicAuthenticator {\n+        private static volatile boolean invoked = false;\n+\n+        ServerAuthenticator(String realm) {\n+            super(realm);\n+        }\n+\n+        public static boolean wasChecked() {\n+            return invoked;\n+        }\n+\n+        @Override\n+        public boolean checkCredentials(String username, String password) {\n+            String validUsername = \"username\", validPassword = \"password\";\n+            invoked = true;\n+            return username.equals(validUsername) && password.equals(validPassword);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/BasicAuthToken.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -71,0 +72,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -77,0 +79,1 @@\n+    private static final boolean IS_WINDOWS = OperatingSystem.isWindows();\n@@ -223,1 +226,1 @@\n-                        Throwable cause = ioe;\n+                        Throwable cause = ioe.getCause();\n@@ -225,1 +228,3 @@\n-                            \/\/ either of SocketException or SSLHandshakeException are OK\n+                            \/\/ either of SocketException or SSLHandshakeException are OK.\n+                            \/\/ additionally on Windows we accept even IOException\n+                            \/\/ (caused by WSAECONNABORTED)\n@@ -238,0 +243,6 @@\n+                            } else if (IS_WINDOWS && cause instanceof IOException winIOE) {\n+                                \/\/ on Windows we sometimes receive this exception, which is\n+                                \/\/ acceptable\n+                                System.out.println(\"(windows) received the expected exception: \"\n+                                        + winIOE);\n+                                break;\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HttpsParametersClientAuthTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 6968351\n+ * @summary  tcp no delay not required for small payloads\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=5 -Dsun.net.httpserver.nodelay=false  TcpNoDelayNotRequired\n+ *\/\n+\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpContext;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.logging.SimpleFormatter;\n+import java.util.logging.StreamHandler;\n+\n+public class TcpNoDelayNotRequired {\n+\n+    public static final Logger LOGGER = Logger.getLogger(\"sun.net.www.protocol.http\");\n+\n+    public static void main (String[] args) throws Exception {\n+\n+        java.util.logging.Handler outHandler = new StreamHandler(System.out,\n+                new SimpleFormatter());\n+        outHandler.setLevel(Level.FINEST);\n+        LOGGER.setLevel(Level.FINEST);\n+        LOGGER.addHandler(outHandler);\n+\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        InetSocketAddress addr = new InetSocketAddress (loopback, 0);\n+\n+        SSLContext sslContext = new SimpleSSLContext().get();\n+\n+        HttpServer httpServer = HttpServer.create (addr, 0);\n+        testHttpServer(\"http\",httpServer,sslContext);\n+\n+        HttpsServer httpsServer = HttpsServer.create (addr, 0);\n+        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+\n+        testHttpServer(\"https\",httpsServer,sslContext);\n+    }\n+\n+    private static void testHttpServer(String scheme,HttpServer server,SSLContext sslContext) throws Exception {\n+        HttpContext ctx = server.createContext (\"\/test\", new Handler());\n+        HttpContext ctx2 = server.createContext (\"\/chunked\", new ChunkedHandler());\n+        ExecutorService executor = Executors.newCachedThreadPool();\n+        server.setExecutor (executor);\n+        server.start ();\n+        try {\n+            try (HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build()) {\n+                long start = System.currentTimeMillis();\n+                for (int i = 0; i < 1000; i++) {\n+                    var uri = URIBuilder.newBuilder().scheme(scheme).loopback().port(server.getAddress().getPort()).path(\"\/test\").build();\n+                    var response = client.send(HttpRequest.newBuilder(uri).build(), HttpResponse.BodyHandlers.ofString());\n+                    if (!response.body().equals(\"hello\"))\n+                        throw new IllegalStateException(\"incorrect body \" + response.body());\n+                }\n+                for (int i = 0; i < 1000; i++) {\n+                    var uri = URIBuilder.newBuilder().scheme(scheme).loopback().port(server.getAddress().getPort()).path(\"\/chunked\").build();\n+                    var response = client.send(HttpRequest.newBuilder(uri).build(), HttpResponse.BodyHandlers.ofString());\n+                    if (!response.body().equals(\"hello\"))\n+                        throw new IllegalStateException(\"incorrect body \" + response.body());\n+                }\n+                long time = System.currentTimeMillis() - start;\n+                System.out.println(\"time \" + time);\n+            }\n+        } finally {\n+            server.stop(0);\n+        }\n+        executor.shutdown();\n+    }\n+\n+    static class Handler implements HttpHandler {\n+        public void handle (HttpExchange t)\n+                throws IOException\n+        {\n+            Headers rmap = t.getResponseHeaders();\n+            try (var is = t.getRequestBody()) {\n+                is.readAllBytes();\n+            }\n+            rmap.add(\"content-type\",\"text\/plain\");\n+            t.sendResponseHeaders(200,5);\n+            try (var os = t.getResponseBody()) {\n+                os.write(\"hello\".getBytes(StandardCharsets.ISO_8859_1));\n+            }\n+        }\n+    }\n+    static class ChunkedHandler implements HttpHandler {\n+        public void handle (HttpExchange t)\n+                throws IOException\n+        {\n+            Headers rmap = t.getResponseHeaders();\n+            try (var is = t.getRequestBody()) {\n+                is.readAllBytes();\n+            }\n+            rmap.add(\"content-type\",\"text\/plain\");\n+            t.sendResponseHeaders(200,0);\n+            try (var os = t.getResponseBody()) {\n+                os.write(\"hello\".getBytes(StandardCharsets.ISO_8859_1));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/TcpNoDelayNotRequired.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,2 @@\n+    static final String EXPECTED_LAST_MODIFIED_OF_FAVICON = \"Mon, 23 May 1995 11:11:11 GMT\";\n+\n@@ -145,0 +147,59 @@\n+    @Test\n+    public void testFavIconGET() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testFavIconGET\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            \/\/ expect built-in icon\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"favicon.ico\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"image\/x-icon\");\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), EXPECTED_LAST_MODIFIED_OF_FAVICON);\n+\n+            \/\/ expect custom (and broken) icon\n+            var file = Files.writeString(root.resolve(\"favicon.ico\"), \"broken icon\", CREATE);\n+            try {\n+                var lastModified = getLastModified(file);\n+                var expectedLength = Long.toString(Files.size(file));\n+                response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 200);\n+                assertEquals(response.headers().firstValue(\"content-type\").get(), \"application\/octet-stream\");\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+                assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            } finally {\n+                Files.delete(file);\n+            }\n+\n+            \/\/ expect built-in icon\n+            response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"image\/x-icon\");\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), EXPECTED_LAST_MODIFIED_OF_FAVICON);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testFavIconHEAD() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testFavIconHEAD\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"favicon.ico\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"image\/x-icon\");\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), EXPECTED_LAST_MODIFIED_OF_FAVICON);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerTest.java","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm\/timeout=180 -Dsun.net.httpserver.nodelay=true StressDirListings\n+ * @run testng\/othervm\/timeout=180 StressDirListings\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/StressDirListings.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n+\n+import jdk.internal.util.OperatingSystem;\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 8332020\n+ * @summary verifies that when jwebserver is launched with a IPv6 bind address\n+ *          then the URL printed contains the correct host literal\n+ * @modules jdk.httpserver java.base\/jdk.internal.util\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.IPSupport\n+ * @run driver IPv6BoundHost\n+ *\/\n+public class IPv6BoundHost {\n+\n+    private static final Path JDK_BIN_DIR = Path.of(System.getProperty(\"java.home\")).resolve(\"bin\");\n+    private static final Path JWEBSERVER_BINARY = OperatingSystem.isWindows()\n+            ? JDK_BIN_DIR.resolve(\"jwebserver.exe\") : JDK_BIN_DIR.resolve(\"jwebserver\");\n+\n+    public static void main(final String[] args) throws Exception {\n+        IPSupport.printPlatformSupport(System.err); \/\/ for debug purposes\n+        if (!IPSupport.hasIPv6()) {\n+            throw new SkippedException(\"Skipping test - IPv6 is not supported\");\n+        }\n+        final String output = launchJwebserverAndExit(List.of(\"-b\", \"::1\", \"-p\", \"0\"));\n+        if (output.contains(\"URL http:\/\/[::1]:\")\n+                || output.contains(\"URL http:\/\/[0:0:0:0:0:0:0:1]:\")) {\n+            \/\/ found expected content\n+            System.out.println(\"found expected URL in jwebserver output\");\n+        } else {\n+            throw new AssertionError(\"missing IPv6 address in jwebserver process output\");\n+        }\n+    }\n+\n+    private static String launchJwebserverAndExit(final List<String> args) throws Exception {\n+        final Predicate<String> waitForLine = (s) -> s.startsWith(\"URL http:\/\/\");\n+        final StringBuilder sb = new StringBuilder();  \/\/ stdout & stderr\n+        final List<String> cmd = new ArrayList<>();\n+        cmd.add(JWEBSERVER_BINARY.toString());\n+        cmd.addAll(args);\n+        \/\/ start the process and await the waitForLine before returning\n+        final Process p = ProcessTools.startProcess(\"8332020-test\", new ProcessBuilder(cmd),\n+                line -> sb.append(line).append(\"\\n\"),\n+                waitForLine,\n+                30,  \/\/ suitably high default timeout, not expected to timeout\n+                TimeUnit.SECONDS);\n+        System.out.println(sb.toString()); \/\/ print the process' stdout\/stderr\n+        \/\/ the process has started and it is confirmed that the process output has the line\n+        \/\/ we were waiting for. now kill the process.\n+        p.destroy();\n+        final int exitCode = p.waitFor();\n+        if (!isNormalExitCode(exitCode)) {\n+            throw new AssertionError(\"jwebserver exited with unexpected exit code: \" + exitCode);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static boolean isNormalExitCode(final int exitCode) {\n+        final int SIGTERM = 15;\n+        if (OperatingSystem.isWindows()) {\n+            return exitCode == 1; \/\/ we expect exit code == 1 on Windows for Process.destroy()\n+        } else {\n+            \/\/ signal terminated exit code on Unix is 128 + signal value\n+            return exitCode == (128 + SIGTERM);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/jwebserver\/IPv6BoundHost.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.math.BigInteger;\n+import java.lang.reflect.Field;\n+import java.security.spec.ECParameterSpec;\n+import sun.security.ec.ECOperations;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.CurveDB;\n+import sun.security.ec.point.*;\n+import java.security.spec.ECPoint;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens\n+ *      java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:-UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @summary Unit test ECOperationsFuzzTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm\/timeout=1200 --add-opens\n+ *      java.base\/sun.security.ec=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseIntPolyIntrinsics ECOperationsFuzzTest\n+ * @summary Unit test ECOperationsFuzzTest.\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for\n+\/\/ pseudo-random number generator. If a failure occurs, hardcode the seed to\n+\/\/ make the test case deterministic\n+public class ECOperationsFuzzTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Note: it might be useful to increase this number during development\n+        final int repeat = 10000;\n+        test(repeat);\n+        System.out.println(\"Fuzz Success\");\n+    }\n+\n+    private static void check(MutablePoint reference, MutablePoint testValue,\n+            long seed, int iter) {\n+        AffinePoint affineRef = reference.asAffine();\n+        AffinePoint affine = testValue.asAffine();\n+        if (!affineRef.equals(affine)) {\n+            throw new RuntimeException(\n+                    \"Found error with seed \" + seed + \"at iteration \" + iter);\n+        }\n+    }\n+\n+    public static void test(int repeat) throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+\n+        int keySize = 256;\n+        ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+        NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+        ECPoint generator = curve.getGenerator();\n+        BigInteger b = curve.getCurve().getB();\n+        if (params == null || generator == null) {\n+            throw new RuntimeException(\n+                    \"No EC parameters available for key size \" + keySize + \" bits\");\n+        }\n+\n+        ECOperations ops = ECOperations.forParameters(params).get();\n+        ECOperations opsReference = new ECOperations(\n+                IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n+\n+        boolean instanceTest1 = ops\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean instanceTest2 = opsReference\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (instanceTest1 == false || instanceTest2 == true) {\n+            throw new RuntimeException(\"Bad Initialization: [\"\n+                + instanceTest1 + \",\" + instanceTest2 + \"]\");\n+        }\n+\n+        byte[] multiple = new byte[keySize \/ 8];\n+        rnd.nextBytes(multiple);\n+        multiple[keySize\/8 - 1] &= 0x7f; \/\/ from opsReference.seedToScalar(multiple);\n+\n+        MutablePoint referencePoint = opsReference.multiply(generator, multiple);\n+        MutablePoint point = ops.multiply(generator, multiple);\n+        check(referencePoint, point, seed, -1);\n+\n+        AffinePoint refAffineGenerator = AffinePoint.fromECPoint(generator,\n+                referencePoint.getField());\n+        AffinePoint montAffineGenerator = AffinePoint.fromECPoint(generator,\n+                point.getField());\n+\n+        MutablePoint refProjGenerator = new ProjectivePoint.Mutable(\n+                refAffineGenerator.getX(false).mutable(),\n+                refAffineGenerator.getY(false).mutable(),\n+                referencePoint.getField().get1().mutable());\n+\n+        MutablePoint projGenerator = new ProjectivePoint.Mutable(\n+                montAffineGenerator.getX(false).mutable(),\n+                montAffineGenerator.getY(false).mutable(),\n+                point.getField().get1().mutable());\n+\n+        for (int i = 0; i < repeat; i++) {\n+            rnd.nextBytes(multiple);\n+            multiple[keySize\/8 - 1] &= 0x7f; \/\/ opsReference.seedToScalar(multiple);\n+\n+            MutablePoint nextReferencePoint = opsReference\n+                    .multiply(referencePoint.asAffine(), multiple);\n+            MutablePoint nextPoint = ops.multiply(point.asAffine().toECPoint(),\n+                    multiple);\n+            check(nextReferencePoint, nextPoint, seed, i);\n+\n+            if (rnd.nextBoolean()) {\n+                opsReference.setSum(nextReferencePoint, referencePoint);\n+                ops.setSum(nextPoint, point);\n+                check(nextReferencePoint, nextPoint, seed, i);\n+            }\n+\n+            if (rnd.nextBoolean()) {\n+                opsReference.setSum(nextReferencePoint, refProjGenerator);\n+                ops.setSum(nextPoint, projGenerator);\n+                check(nextReferencePoint, nextPoint, seed, i);\n+            }\n+\n+            if (rnd.nextInt(100) < 10) { \/\/ 10% Reset point to generator, test\n+                                         \/\/ generator multiplier\n+                referencePoint = opsReference.multiply(generator, multiple);\n+                point = ops.multiply(generator, multiple);\n+                check(referencePoint, point, seed, i);\n+            } else {\n+                referencePoint = nextReferencePoint;\n+                point = nextPoint;\n+            }\n+        }\n+    }\n+\n+}\n+\n+\/\/ make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsFuzzTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.math.BigInteger;\n+import java.lang.reflect.Field;\n+import java.security.spec.ECParameterSpec;\n+import sun.security.ec.ECOperations;\n+import sun.security.util.ECUtil;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.CurveDB;\n+import sun.security.ec.point.*;\n+import java.security.spec.ECPoint;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm --add-opens java.base\/sun.security.ec=ALL-UNNAMED\n+ *      ECOperationsKATTest\n+ * @summary Unit test ECOperationsKATTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/sun.security.ec java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ *      -XX:-TieredCompilation --add-opens java.base\/sun.security.ec=ALL-UNNAMED\n+ *      -XX:+UnlockDiagnosticVMOptions ECOperationsKATTest\n+ * @summary Unit test ECOperationsKATTest.\n+ *\/\n+\n+ public class ECOperationsKATTest {\n+    final private static java.util.HexFormat hex = java.util.HexFormat.of();\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" + test.testName);\n+            if (runSingleTest(test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        if (testsPassed != testNumber) {\n+            throw new RuntimeException(\n+                    \"One or more tests failed. Check output for details\");\n+        }\n+    }\n+\n+    private static boolean check(MutablePoint testValue, ECPoint reference) {\n+        AffinePoint affine = testValue.asAffine();\n+        BigInteger x = affine.getX().asBigInteger();\n+        BigInteger y = affine.getY().asBigInteger();\n+        BigInteger refX = reference.getAffineX();\n+        BigInteger refY = reference.getAffineY();\n+\n+        if (!refX.equals(x) || !refY.equals(y)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected: X: \" + refX.toString(16) + \" Y: \"\n+                    + refY.toString(16));\n+            System.out.println(\n+                    \"Result:   X: \" + x.toString(16) + \" Y: \" + y.toString(16));\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static class TestData {\n+        public TestData(String name, String keyStr, String xStr1, String yStr1,\n+                String xStr2, String yStr2) {\n+            testName = name;\n+            \/\/ multiplier = (new BigInteger(keyStr, 16)).toByteArray();\n+            multiplier = hex.parseHex(keyStr);\n+            sun.security.util.ArrayUtil.reverse(multiplier);\n+            reference1 = new ECPoint(new BigInteger(xStr1, 16),\n+                    new BigInteger(yStr1, 16));\n+            reference2 = new ECPoint(new BigInteger(xStr2, 16),\n+                    new BigInteger(yStr2, 16));\n+        }\n+\n+        String testName;\n+        byte[] multiplier;\n+        ECPoint reference1; \/\/ For generator multiplier test\n+        ECPoint reference2; \/\/ For non-generator multiplier test\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+    \/\/ (x1,y1) = mult*generator\n+    \/\/ (x2,y2) = mult*mult*generator\n+    add(new TestData(\"Test Vector #1\",\n+        \"0000000000000000000000000000000000000000000000000000000000000012\", \/\/ mult\n+        \"1057E0AB5780F470DEFC9378D1C7C87437BB4C6F9EA55C63D936266DBD781FDA\", \/\/ x1\n+        \"F6F1645A15CBE5DC9FA9B7DFD96EE5A7DCC11B5C5EF4F1F78D83B3393C6A45A2\", \/\/ y1\n+        \"4954047A366A91E3FD94E574DB6F2B04F3A8465883DBC55A816EA563BF54A324\", \/\/ x2\n+        \"B5A54786FD9EA48C9FC38A0557B0C4D54F285908A7291B630D06BEE970F530D3\") \/\/ y2\n+    );\n+    add(new TestData(\"Test Vector #2\",\n+        \"1200000000000000000000000000000000000000000000000000000000000000\", \/\/ mult\n+        \"DF684E6D0D57AF8B89DA11E8F7436C3D360F531D62BDCE42C5A8B72D73D5C717\", \/\/ x\n+        \"9D3576BD03C09B8F416EE9C27D70AD4A425119271ACF549312CA48758F4E1FEC\", \/\/ y\n+        \"57C8257EEAABF5446DCFACB99DEE104367B6C9950C76797C372EB177D5FA23B3\", \/\/ x\n+        \"1CD3E8A34521C1C8E574EB4B99343CAA57E00725D8618F0231C7C79AA6837725\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #3\",\n+        \"0000000000000000000000000000000120000000000000000000000000000012\", \/\/ mult\n+        \"A69DFD47B24485E5F523BDA5FBACF03F5A7C3D22E0C2BC6705594B7B051A06D0\", \/\/ x\n+        \"ECF19629416BE5C9AF1E30988F3AA8B803809CF4D12944EB49C5E9892723798A\", \/\/ y\n+        \"1E28559F5B681C308632EE11A007B9891B3FD592C982C4926153795794295E58\", \/\/ x\n+        \"3C373046C27BB34609A43C91DF6D4B9AB9EB08F3B69A8F8FAE944211D8297F30\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #4\",\n+        \"0000000000000000000000000000000000000000000000000000000000000001\", \/\/ mult\n+        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", \/\/ y\n+        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", \/\/ x\n+        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #5\",\n+        \"EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \/\/ mult\n+        \"66B71D0BD47344197CCFB0C9578EAF0ADB609E05BB4E8F87D56BD34F24EE7C47\", \/\/ x\n+        \"14A0ECB7F708C02B2BAE238D2C4607BB9D04FCE64E10A428C911D6FA25B2F0FD\", \/\/ y\n+        \"D25AAFD0FCC5B5E95C84C0702C138BC4D7FEB4E5F9C2DFB4301E313507EFDF44\", \/\/ x\n+        \"F3F04EBC7D308511B0392BB7171CF92688D6484A95A8100EDFC933613A359133\") \/\/ y\n+    );\n+    add(new TestData(\"Test Vector #6\",\n+        \"1111111111111111111111111111111111111111111111111111111111111111\", \/\/ mult\n+        \"0217E617F0B6443928278F96999E69A23A4F2C152BDF6D6CDF66E5B80282D4ED\", \/\/ x\n+        \"194A7DEBCB97712D2DDA3CA85AA8765A56F45FC758599652F2897C65306E5794\", \/\/ y\n+        \"A83A07D6AE918359DEBCC385DA1E416EB83417435079CA8DB06005E107C309A0\", \/\/ x\n+        \"5AACDF816850C33EB3E54F3D0DD759B97B5E7065B2060016F73735E4A6AADE23\") \/\/ y\n+    );\n+    }};\n+\n+    private static boolean runSingleTest(TestData testData) {\n+        int keySize = 256;\n+        ECParameterSpec params = ECUtil.getECParameterSpec(keySize);\n+        NamedCurve curve = CurveDB.lookup(KnownOIDs.secp256r1.value());\n+        ECPoint generator = curve.getGenerator();\n+        BigInteger b = curve.getCurve().getB();\n+        if (params == null || generator == null) {\n+            throw new RuntimeException(\n+                    \"No EC parameters available for key size \" + keySize + \" bits\");\n+        }\n+\n+        ECOperations ops = ECOperations.forParameters(params).get();\n+        ECOperations opsReference = new ECOperations(\n+                IntegerPolynomialP256.ONE.getElement(b), P256OrderField.ONE);\n+\n+        boolean instanceTest1 = ops\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        boolean instanceTest2 = opsReference\n+                .getField() instanceof IntegerMontgomeryFieldModuloP;\n+        if (instanceTest1 == false || instanceTest2 == true) {\n+            throw new RuntimeException(\"Bad Initialization: [\" + instanceTest1 + \",\"\n+                    + instanceTest2 + \"]\");\n+        }\n+\n+        MutablePoint nextPoint = ops.multiply(generator, testData.multiplier);\n+        MutablePoint nextReferencePoint = opsReference.multiply(generator,\n+                testData.multiplier);\n+        if (!check(nextReferencePoint, testData.reference1)\n+                || !check(nextPoint, testData.reference1)) {\n+            return false;\n+        }\n+\n+        nextPoint = ops.multiply(nextPoint.asAffine(), testData.multiplier);\n+        nextReferencePoint = opsReference.multiply(nextReferencePoint.asAffine(),\n+                testData.multiplier);\n+        if (!check(nextReferencePoint, testData.reference2)\n+                || !check(nextPoint, testData.reference2)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/ec\/ECOperationsKATTest.java\"\n+\n+\/*\n+ * KAT generator using OpenSSL for reference vectors\n+ * g++ ecpoint.cpp -g -lcrypto -Wno-deprecated-declarations && .\/a.out\n+ * (Some OpenSSL EC operations are marked internal i.e. deprecated)\n+ *\n+\n+#include <openssl\/obj_mac.h>\n+#include <openssl\/ec.h>\n+\n+void check(int rc, const char* locator) {\n+  if (rc != 1) {\n+    printf(\"Failed at %s\\n\", locator);\n+    exit(55);\n+  }\n+}\n+\n+int main(){\n+  BN_CTX* ctx = BN_CTX_new();\n+  BIGNUM* k = BN_CTX_get(ctx);\n+  BIGNUM* x1 = BN_CTX_get(ctx);\n+  BIGNUM* y1 = BN_CTX_get(ctx);\n+  BIGNUM* x2 = BN_CTX_get(ctx);\n+  BIGNUM* y2 = BN_CTX_get(ctx);\n+  EC_GROUP *ec_group = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);\n+  EC_POINT* pubkey = EC_POINT_new(ec_group);\n+  EC_POINT* pubkey2 = EC_POINT_new(ec_group);\n+  int rc;\n+\n+  rc = BN_hex2bn(&k, \"1111111111111111111111111111111111111111111111111111111111111111\"); \/\/check(rc, \"set raw key\");\n+  rc = EC_POINT_mul(ec_group, pubkey, k, NULL, NULL, ctx);  check(rc, \"mult public key\");\n+  rc = EC_POINT_get_affine_coordinates(ec_group, pubkey, x1, y1, ctx);   check(rc, \"get affine coordinates\");\n+  rc = EC_POINT_mul(ec_group, pubkey2, NULL, pubkey, k, ctx);  check(rc, \"mult public key\");\n+  rc = EC_POINT_get_affine_coordinates(ec_group, pubkey2, x2, y2, ctx);   check(rc, \"get affine coordinates\");\n+  printf(\"k: %s\\n\", BN_bn2hex(k));\n+  printf(\"x: %s\\ny: %s\\n\", BN_bn2hex(x1), BN_bn2hex(y1));\n+  printf(\"x: %s\\ny: %s\\n\", BN_bn2hex(x2), BN_bn2hex(y2));\n+\n+  BN_CTX_free(ctx);\n+  return 0;\n+}\n+ *\/\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/ec\/ECOperationsKATTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import sun.security.util.math.*;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ * java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics\n+ * IntegerPolynomialTest\n+ * @summary Unit test\n+ * IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ * java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xcomp\n+ * -XX:-TieredCompilation -XX:+UseIntPolyIntrinsics IntegerPolynomialTest\n+ * @summary Unit test\n+ * IntegerPolynomial.MutableIntegerModuloP.conditionalAssign().\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for\n+\/\/ pseudo-random number generator. If a failure occurs, hardcode the seed to\n+\/\/ make the test case deterministic\n+public class IntegerPolynomialTest {\n+    public static void main(String[] args) throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+\n+        IntegerPolynomial testFields[] = new IntegerPolynomial[] {\n+                IntegerPolynomial1305.ONE, IntegerPolynomial25519.ONE,\n+                IntegerPolynomial448.ONE, IntegerPolynomialP256.ONE,\n+                MontgomeryIntegerPolynomialP256.ONE, IntegerPolynomialP384.ONE,\n+                IntegerPolynomialP521.ONE,\n+                new IntegerPolynomialModBinP.Curve25519OrderField(),\n+                new IntegerPolynomialModBinP.Curve448OrderField(),\n+                P256OrderField.ONE, P384OrderField.ONE, P521OrderField.ONE,\n+                Curve25519OrderField.ONE, Curve448OrderField.ONE };\n+\n+        for (IntegerPolynomial field : testFields) {\n+            ImmutableIntegerModuloP aRef = field\n+                    .getElement(new BigInteger(32 * 64, rnd));\n+            MutableIntegerModuloP a = aRef.mutable();\n+            ImmutableIntegerModuloP bRef = field\n+                    .getElement(new BigInteger(32 * 64, rnd));\n+            MutableIntegerModuloP b = bRef.mutable();\n+\n+            a.conditionalSet(b, 0); \/\/ Don't assign\n+            if (Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                throw new RuntimeException(\n+                        \"[SEED \" + seed + \"]: Incorrect assign for \" + field);\n+            }\n+            a.conditionalSet(b, 1); \/\/ Assign\n+            if (!Arrays.equals(a.getLimbs(), b.getLimbs())) {\n+                throw new RuntimeException(\n+                        \"[SEED \" + seed + \"]: Incorrect assign for \" + field);\n+            }\n+        }\n+        System.out.println(\"Test Success\");\n+    }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Intel Corporation. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Random;\n+import sun.security.util.math.IntegerMontgomeryFieldModuloP;\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+import java.math.BigInteger;\n+import sun.security.util.math.intpoly.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-UseIntPolyIntrinsics\n+ *      MontgomeryPolynomialFuzzTest\n+ * @summary Unit test MontgomeryPolynomialFuzzTest.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @modules java.base\/sun.security.util java.base\/sun.security.util.math\n+ *          java.base\/sun.security.util.math.intpoly\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UseIntPolyIntrinsics\n+ *      MontgomeryPolynomialFuzzTest\n+ * @summary Unit test MontgomeryPolynomialFuzzTest.\n+ *\/\n+\n+\/\/ This test case is NOT entirely deterministic, it uses a random seed for pseudo-random number generator\n+\/\/ If a failure occurs, hardcode the seed to make the test case deterministic\n+public class MontgomeryPolynomialFuzzTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Note: it might be useful to increase this number during development\n+        final int repeat = 1000000;\n+        for (int i = 0; i < repeat; i++) {\n+            run();\n+        }\n+        System.out.println(\"Fuzz Success\");\n+    }\n+\n+    private static void check(BigInteger reference,\n+            ImmutableIntegerModuloP testValue, long seed) {\n+        if (!reference.equals(testValue.asBigInteger())) {\n+            throw new RuntimeException(\"SEED: \" + seed);\n+        }\n+    }\n+\n+    public static void run() throws Exception {\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+\n+        IntegerMontgomeryFieldModuloP montField = MontgomeryIntegerPolynomialP256.ONE;\n+        BigInteger P = MontgomeryIntegerPolynomialP256.ONE.MODULUS;\n+        BigInteger r = BigInteger.ONE.shiftLeft(260).mod(P);\n+        BigInteger rInv = r.modInverse(P);\n+        BigInteger aRef = (new BigInteger(P.bitLength(), rnd)).mod(P);\n+\n+        \/\/ Test conversion to montgomery domain\n+        ImmutableIntegerModuloP a = montField.getElement(aRef);\n+        aRef = aRef.multiply(r).mod(P);\n+        check(aRef, a, seed);\n+\n+        if (rnd.nextBoolean()) {\n+            aRef = aRef.multiply(aRef).multiply(rInv).mod(P);\n+            a = a.multiply(a);\n+            check(aRef, a, seed);\n+        }\n+\n+        if (rnd.nextBoolean()) {\n+            aRef = aRef.add(aRef).mod(P);\n+            a = a.add(a);\n+            check(aRef, a, seed);\n+        }\n+    }\n+}\n+\n+\/\/make test TEST=\"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java\"\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/security\/util\/math\/intpoly\/MontgomeryPolynomialFuzzTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/regtesthelpers\n- * @build   Util\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build   Util jdk.test.lib.Platform\n@@ -44,2 +44,14 @@\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.AWTEvent;\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.WindowEvent;\n@@ -49,1 +61,5 @@\n-import javax.swing.*;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+import jdk.test.lib.Platform;\n@@ -75,1 +91,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -84,0 +100,1 @@\n+            robot.setAutoDelay(50);\n@@ -93,1 +110,1 @@\n-        f0.setBounds(0, 100, 400, 200);\n+        f0.setBounds(100, 100, 400, 200);\n@@ -96,1 +113,1 @@\n-        f1.setBounds(0, 400, 400, 200);\n+        f1.setBounds(100, 400, 400, 200);\n@@ -99,1 +116,1 @@\n-        f2.setBounds(0, 400, 400, 200);\n+        f2.setBounds(100, 400, 400, 200);\n@@ -118,0 +135,1 @@\n+        robot.delay(500);\n@@ -155,1 +173,1 @@\n-    public static void test(Component compToClick) {\n+    public static void test(Component compToClick) throws Exception {\n@@ -159,1 +177,0 @@\n-        robot.delay(50);\n@@ -161,1 +178,1 @@\n-        robot.delay(50);\n+        robot.waitForIdle();\n@@ -164,1 +181,0 @@\n-        robot.delay(50);\n@@ -166,1 +182,1 @@\n-        robot.delay(50);\n+        robot.waitForIdle();\n@@ -169,1 +185,0 @@\n-        robot.delay(50);\n@@ -171,0 +186,1 @@\n+        robot.waitForIdle();\n@@ -172,1 +188,0 @@\n-        robot.delay(50);\n@@ -175,2 +190,6 @@\n-        robot.delay(50);\n-        Util.clickOnTitle(f0, robot);\n+        robot.waitForIdle();\n+        SwingUtilities.invokeAndWait(f0::toFront);\n+\n+        if (!Platform.isOnWayland()) {\n+            Util.clickOnTitle(f0, robot);\n+        }\n","filename":"test\/jdk\/java\/awt\/Focus\/6981400\/Test1.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n-  @library   ..\/..\/regtesthelpers\n-  @build     Util\n+  @library \/java\/awt\/regtesthelpers \/test\/lib\n+  @build   Util jdk.test.lib.Platform\n@@ -34,2 +34,16 @@\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.AWTEvent;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.WindowEvent;\n+\n+import jdk.test.lib.Platform;\n@@ -47,1 +61,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -71,1 +85,1 @@\n-    public void start() {\n+    public void start() throws Exception {\n@@ -102,1 +116,6 @@\n-        Util.clickOnTitle(owner, robot);\n+        EventQueue.invokeAndWait(owner::toFront);\n+\n+        if (!Platform.isOnWayland()) {\n+            Util.clickOnTitle(owner, robot);\n+        }\n+\n@@ -120,0 +139,1 @@\n+        robot.delay(500);\n@@ -122,1 +142,1 @@\n-    void clickOnCheckFocus(Component c) {\n+    void clickOnCheckFocus(Component c) throws Exception {\n@@ -124,1 +144,4 @@\n-            Util.clickOnTitle((Frame)c, robot);\n+            EventQueue.invokeAndWait(() -> ((Frame) c).toFront());\n+            if (!Platform.isOnWayland()) {\n+                Util.clickOnTitle((Frame) c, robot);\n+            }\n","filename":"test\/jdk\/java\/awt\/Focus\/ActualFocusedWindowTest\/ActualFocusedWindowBlockingTest.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,2 @@\n-  test\n+  @test\n+  @key headful\n@@ -28,2 +29,1 @@\n-  @key headful\n-  @run main AutomaticAppletTest\n+  @run main ModalDialogInFocusEventTest\n@@ -71,0 +71,2 @@\n+    static boolean isOnWayland;\n+\n@@ -212,12 +214,15 @@\n-        System.out.println(\"click on title of \" + frame.getName());\n-        int[] point = new int[2];\n-        EventQueue.invokeAndWait(() -> {\n-            Point location = frame.getLocationOnScreen();\n-            Insets insets = frame.getInsets();\n-            int width = frame.getWidth();\n-            point[0] = location.x + width \/ 2;\n-            point[1] = location.y + insets.top \/ 2;\n-        });\n-        robot.mouseMove(point[0], point[1]);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        EventQueue.invokeAndWait(frame::toFront);\n+        if (!isOnWayland) {\n+            System.out.println(\"click on title of \" + frame.getName());\n+            int[] point = new int[2];\n+            EventQueue.invokeAndWait(() -> {\n+                Point location = frame.getLocationOnScreen();\n+                Insets insets = frame.getInsets();\n+                int width = frame.getWidth();\n+                point[0] = location.x + width \/ 2;\n+                point[1] = location.y + insets.top \/ 2;\n+            });\n+            robot.mouseMove(point[0], point[1]);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        }\n@@ -347,0 +352,1 @@\n+        isOnWayland = System.getenv(\"WAYLAND_DISPLAY\") != null;\n","filename":"test\/jdk\/java\/awt\/Focus\/ModalDialogInFocusEventTest.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -24,9 +24,0 @@\n-\/*\n- * FrameStateTest.java\n- *\n- * summary: Checks that when setState(Frame.ICONIFIED) is called before\n- *      setVisible(true) the Frame is shown in the proper iconified state.\n- *      The problem was that it did not honor the initial iconic state, but\n- *      instead was shown in the NORMAL state.\n- *\/\n-\n@@ -55,3 +46,3 @@\n- *       was set to. The bug was that if setState(Frame.ICONIFIED) was\n- *       called before setVisible(true) the Frame would be shown in NORMAL\n- *       state instead of ICONIFIED.\n+ *          was set to. The bug was that if setState(Frame.ICONIFIED) was\n+ *          called before setVisible(true) the Frame would be shown in NORMAL\n+ *          state instead of ICONIFIED.\n@@ -71,2 +62,1 @@\n-        <\/p><hr\/><p>\n-\n+        <\/p><hr\/>\n@@ -74,1 +64,1 @@\n-        <\/p><p>\n+        <p>\n@@ -77,1 +67,1 @@\n-                <li><i>{Normal, Non-resizalbe}<\/i><\/li>\n+                <li><i>{Normal, Non-resizable}<\/i><\/li>\n@@ -80,1 +70,1 @@\n-                <li><i>{Iconified, Non-resizalbe}<\/i><\/li>\n+                <li><i>{Iconified, Non-resizable}<\/i><\/li>\n@@ -84,3 +74,2 @@\n-        After the Frame (Frame State Test (Window2)) comes\n-        up make sure the proper behavior occurred<br>\n-        (Frame shown in proper state).<br>\n+        After the Frame (Frame State Test (Window2)) comes up make sure the\n+        proper behavior occurred (Frame shown in proper state).<br>\n@@ -88,1 +77,0 @@\n-\n@@ -91,3 +79,10 @@\n-        Do the above steps for all the different Frame state combinations available.<br>\n-        If you observe the proper behavior the test has passed, Press the Pass button.<br>\n-        Otherwise the test has failed, Press the Fail button.\n+        Do the above steps for all the different Frame state combinations\n+        available.<br>\n+        For \"Hide, Iconify and Show\" case, the frame is hidden then iconified\n+        hence Window2 is not seen on-screen when shown as the frame is still\n+        in the ICONIFIED state. Window2 is visible on-screen when it is restored\n+        to NORMAL state as observed with \"Hide, Iconify, Show and Restore\" case.\n+        <br><br>\n+\n+        If you observe the proper behavior for all the combinations,\n+        press PASS else FAIL.<br>\n@@ -109,3 +104,3 @@\n-    Checkbox cbIconState = new Checkbox(\"Frame state ICONIFIED\", cbgState, true);\n-    Checkbox cbNormState = new Checkbox(\"Frame state NORMAL\", cbgState, false);\n-    Checkbox cbNonResize = new Checkbox(\"Frame non-resizable\", cbgResize, false);\n+    Checkbox cbIconState = new Checkbox(\"Frame State ICONIFIED\", cbgState, true);\n+    Checkbox cbNormState = new Checkbox(\"Frame State NORMAL\", cbgState, false);\n+    Checkbox cbNonResize = new Checkbox(\"Frame Non-Resizable\", cbgResize, false);\n@@ -119,1 +114,1 @@\n-                .title(\"GetBoundsResizeTest Instructions\")\n+                .title(\"Frame State and Size Test Instructions\")\n@@ -122,1 +117,1 @@\n-                .rows(25)\n+                .rows(27)\n@@ -124,1 +119,1 @@\n-                .logArea(10)\n+                .logArea(6)\n@@ -152,1 +147,1 @@\n-            icontst =new CreateFrame(cbIconState.getState(), cbResize.getState());\n+            icontst = new CreateFrame(cbIconState.getState(), cbResize.getState());\n@@ -169,1 +164,1 @@\n-            setTitle(\"Frame State Test (Window 2)\");\n+            setTitle(\"Test Window (Window 2)\");\n@@ -178,7 +173,7 @@\n-            add(b1 = new Button(\"resizable\"));\n-            add(b2 = new Button(\"resize\"));\n-            add(b3 = new Button(\"iconify\"));\n-            add(b4 = new Button(\"iconify and restore\"));\n-            add(b5 = new Button(\"hide and show\"));\n-            add(b6 = new Button(\"hide, iconify and show\"));\n-            add(b7 = new Button(\"hide, iconify, show, and restore\"));\n+            add(b1 = new Button(\"Resizable\"));\n+            add(b2 = new Button(\"Resize\"));\n+            add(b3 = new Button(\"Iconify\"));\n+            add(b4 = new Button(\"Iconify and Restore\"));\n+            add(b5 = new Button(\"Hide and Show\"));\n+            add(b6 = new Button(\"Hide, Iconify and Show\"));\n+            add(b7 = new Button(\"Hide, Iconify, Show and Restore\"));\n@@ -194,1 +189,1 @@\n-            setBounds(100, 2, 200, 200);\n+            setBounds(100, 2, 300, 200);\n@@ -197,1 +192,0 @@\n-            pack();\n@@ -323,1 +317,1 @@\n-                .log(\"[State=%d] %s %s\".formatted(getState(), name, message));\n+                .log(\"[Current State = %d] %s %s\".formatted(getState(), name, message));\n@@ -327,1 +321,1 @@\n-            PassFailJFrame.log(\"[State=\" + getState() + \"]\");\n+            PassFailJFrame.log(\"[Current State = \" + getState() + \"]\");\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameStateTest\/FrameStateTest.java","additions":37,"deletions":43,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,23 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.HierarchyBoundsListener;\n+import java.awt.event.HierarchyEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n@@ -29,1 +49,2 @@\n-import java.io.*;\n+\n+import jdk.test.lib.Platform;\n@@ -40,1 +61,2 @@\n- * @build FrameBorderCounter\n+ * @library \/test\/lib\n+ * @build FrameBorderCounter jdk.test.lib.Platform\n@@ -140,1 +162,1 @@\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n@@ -142,1 +164,1 @@\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -180,15 +202,0 @@\n-        int x = (int) frame.getLocationOnScreen().x;\n-        int y = (int) frame.getLocationOnScreen().y;\n-        int w = frame.getSize().width;\n-        int h = frame.getSize().height;\n-\n-        robot.mouseMove(x + w + BORDER_SHIFT, y + h \/ 2);\n-        robot.delay(delay);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.delay(delay);\n-        for (int i = 0; i < 20; i++) {\n-            robot.mouseMove(x + w + i + BORDER_SHIFT, y + h \/ 2);\n-            robot.delay(50);\n-        }\n-        robot.delay(delay);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n@@ -196,5 +203,28 @@\n-        if (! resizeTriggered) {\n-            synchronized (resizeLock) {\n-                try {\n-                    resizeLock.wait(delay * 10);\n-                } catch (Exception e) {\n+        int x;\n+        int y;\n+        int w;\n+        int h;\n+\n+        if (!Platform.isOnWayland()) {\n+            x = frame.getLocationOnScreen().x;\n+            y = frame.getLocationOnScreen().y;\n+            w = frame.getSize().width;\n+            h = frame.getSize().height;\n+\n+            robot.mouseMove(x + w + BORDER_SHIFT, y + h \/ 2);\n+            robot.delay(delay);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(delay);\n+            for (int i = 0; i < 20; i++) {\n+                robot.mouseMove(x + w + i + BORDER_SHIFT, y + h \/ 2);\n+                robot.delay(50);\n+            }\n+            robot.delay(delay);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            if (!resizeTriggered) {\n+                synchronized (resizeLock) {\n+                    try {\n+                        resizeLock.wait(delay * 10);\n+                    } catch (Exception e) {\n+                    }\n@@ -203,1 +233,0 @@\n-        }\n@@ -205,5 +234,10 @@\n-        for (int i = 0; i < components.length; i++) {\n-            if (! ancestorResized[i]) {\n-                System.err.println(\"FAIL: Frame resized using mouse action. \" +\n-                                   \"Ancestor resized event did not occur for \" +\n-                                   components[i].getClass());\n+            for (int i = 0; i < components.length; i++) {\n+                if (!ancestorResized[i]) {\n+                    System.err.println(\"FAIL: Frame resized using mouse action. \" +\n+                            \"Ancestor resized event did not occur for \" +\n+                            components[i].getClass());\n+                    passed = false;\n+                }\n+            }\n+            if (moveCount > 0) {\n+                System.err.println(\"FAIL: Ancestor moved event occurred when Frame resized using mouse\");\n@@ -212,4 +246,2 @@\n-        }\n-        if (moveCount > 0) {\n-            System.err.println(\"FAIL: Ancestor moved event occured when Frame resized using mouse\");\n-            passed = false;\n+\n+            resetValues();\n@@ -218,1 +250,0 @@\n-        resetValues();\n@@ -253,14 +284,0 @@\n-        x = (int) frame.getLocationOnScreen().x;\n-        y = (int) frame.getLocationOnScreen().y;\n-        w = frame.getSize().width;\n-        h = frame.getSize().height;\n-\n-        \/\/Click on the dummy frame so that the test frame loses focus. This is to workaround\n-        \/\/a bug in Linux AS.\n-        robot.mouseMove((int) dummy.getLocationOnScreen().x + dummy.getSize().width \/ 2,\n-                        (int) dummy.getLocationOnScreen().y + dummy.getSize().height \/ 2);\n-        robot.delay(delay);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.delay(delay);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        robot.delay(delay);\n@@ -268,16 +285,33 @@\n-        robot.mouseMove(x + w \/ 2, y + 10);\n-        robot.delay(delay);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.delay(delay);\n-        for (int i = 1; i <= 20; i++) {\n-            robot.mouseMove(x + w \/ 2 + i, y + 10);\n-            robot.delay(50);\n-        }\n-        robot.delay(delay);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-\n-        if (! moveTriggered) {\n-            synchronized (moveLock) {\n-                try {\n-                    moveLock.wait(delay * 10);\n-                } catch (Exception e) {\n+        if (!Platform.isOnWayland()) {\n+            x = frame.getLocationOnScreen().x;\n+            y = frame.getLocationOnScreen().y;\n+            w = frame.getSize().width;\n+            h = frame.getSize().height;\n+\n+            \/\/Click on the dummy frame so that the test frame loses focus. This is to workaround\n+            \/\/a bug in Linux AS.\n+            robot.mouseMove((int) dummy.getLocationOnScreen().x + dummy.getSize().width \/ 2,\n+                            (int) dummy.getLocationOnScreen().y + dummy.getSize().height \/ 2);\n+            robot.delay(delay);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(delay);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(delay);\n+\n+            robot.mouseMove(x + w \/ 2, y + 10);\n+            robot.delay(delay);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(delay);\n+            for (int i = 1; i <= 20; i++) {\n+                robot.mouseMove(x + w \/ 2 + i, y + 10);\n+                robot.delay(50);\n+            }\n+            robot.delay(delay);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            if (! moveTriggered) {\n+                synchronized (moveLock) {\n+                    try {\n+                        moveLock.wait(delay * 10);\n+                    } catch (Exception e) {\n+                    }\n@@ -286,1 +320,0 @@\n-        }\n@@ -288,4 +321,9 @@\n-        for (int i = 0; i < components.length; i++) {\n-            if (! ancestorMoved[i]) {\n-                System.err.println(\"FAIL: Frame moved using mouse action. \" +\n-                                   \"Ancestor moved event did not occur for \" + components[i].getClass());\n+            for (int i = 0; i < components.length; i++) {\n+                if (! ancestorMoved[i]) {\n+                    System.err.println(\"FAIL: Frame moved using mouse action. \" +\n+                                       \"Ancestor moved event did not occur for \" + components[i].getClass());\n+                    passed = false;\n+                }\n+            }\n+            if (resizeCount > 0) {\n+                System.err.println(\"FAIL: Ancestor resized event occured when Frame moved using mouse\");\n@@ -295,4 +333,0 @@\n-        if (resizeCount > 0) {\n-            System.err.println(\"FAIL: Ancestor resized event occured when Frame moved using mouse\");\n-            passed = false;\n-        }\n@@ -453,1 +487,1 @@\n-    public static void main(String args[]) throws InterruptedException {\n+    public static void main(String[] args) throws InterruptedException {\n","filename":"test\/jdk\/java\/awt\/Mixing\/AWT_Mixing\/HierarchyBoundsListenerMixingTest.java","additions":113,"deletions":79,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8321489\n+ * @summary tests that the cmm id is not ignored\n+ *\/\n+public final class CustomCMMID {\n+\n+    private static final byte[] JAVA_ID = {\n+            (byte) 'j', (byte) 'a', (byte) 'v', (byte) 'a',\n+    };\n+\n+    private static final int[] CS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    public static void main(String[] args) {\n+        for (int cs : CS) {\n+            ICC_Profile p = createProfile(cs);\n+            validate(p);\n+        }\n+    }\n+\n+    private static ICC_Profile createProfile(int type) {\n+        byte[] data = ICC_Profile.getInstance(type).getData();\n+        System.arraycopy(JAVA_ID, 0, data, ICC_Profile.icHdrCmmId,\n+                         JAVA_ID.length);\n+        return ICC_Profile.getInstance(data);\n+    }\n+\n+    private static void validate(ICC_Profile p) {\n+        byte[] header = p.getData(ICC_Profile.icSigHead);\n+        byte[] id = new byte[JAVA_ID.length];\n+        System.arraycopy(header, ICC_Profile.icHdrCmmId, id, 0, JAVA_ID.length);\n+\n+        if (!java.util.Arrays.equals(id, JAVA_ID)) {\n+            System.err.println(\"Expected: \" + Arrays.toString(JAVA_ID));\n+            System.err.println(\"Actual: \" + Arrays.toString(id));\n+            throw new RuntimeException(\"Wrong cmm id\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/CustomCMMID.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionAdapter;\n+import java.awt.event.MouseMotionListener;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 4613903\n+ * @summary verifies that mouse events are not dispatched during drag\n+ * @key headful\n+ * @run main MouseEventAfterStartDragTest\n+ *\/\n+\n+public final class MouseEventAfterStartDragTest implements AWTEventListener {\n+    final Frame frame = new Frame();\n+    volatile Point srcPoint;\n+    volatile Dimension d;\n+    volatile MouseEvent lastMouseEvent = null;\n+    volatile boolean passed = true;\n+    final DragSource dragSource = DragSource.getDefaultDragSource();\n+    final Transferable transferable = new StringSelection(\"TEXT\");\n+\n+    final MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {\n+        public void mouseDragged(MouseEvent e) {\n+            System.out.println(\"mouseDragged: \" + e\n+                    + \", hash:\" + e.hashCode());\n+            if (lastMouseEvent != null && !e.equals(lastMouseEvent)) {\n+                System.out.println(\"Unexpected: \" + e\n+                        + \", hash:\" + e.hashCode());\n+                passed = false;\n+            }\n+        }\n+    };\n+\n+    final DragSourceListener dragSourceListener = new DragSourceAdapter() {\n+        public void dragDropEnd(DragSourceDragEvent dsde) {\n+            System.out.println(\"dragDropEnd: \" + dsde);\n+            lastMouseEvent = null;\n+        }\n+    };\n+\n+    final DragGestureListener dragGestureListener = new DragGestureListener() {\n+        public void dragGestureRecognized(DragGestureEvent dge) {\n+            System.out.println(\"dragGestureRecognized: \" + dge);\n+            Object[] events = dge.toArray();\n+            Object lastEvent = events[events.length - 1];\n+            if (lastEvent instanceof MouseEvent) {\n+                lastMouseEvent = (MouseEvent) lastEvent;\n+            }\n+            System.out.println(\"The last mouse event: \" + lastMouseEvent\n+                    + \", hash:\" + lastMouseEvent.hashCode());\n+            dge.startDrag(null, transferable, dragSourceListener);\n+        }\n+    };\n+\n+    static final Object SYNC_LOCK = new Object();\n+    static final int MOUSE_RELEASE_TIMEOUT = 1000;\n+    volatile Component clickedComponent = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"awt.dnd.drag.threshold\", \"0\");\n+        MouseEventAfterStartDragTest app = new MouseEventAfterStartDragTest();\n+        try {\n+            app.createAndShowGUI();\n+            app.test();\n+        } finally {\n+            app.dispose();\n+        }\n+    }\n+\n+    public void createAndShowGUI() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            frame.setTitle(\"Test frame\");\n+            frame.setBounds(100, 100, 200, 200);\n+            frame.setLocationRelativeTo(null);\n+            frame.addMouseMotionListener(mouseMotionListener);\n+            dragSource.createDefaultDragGestureRecognizer(frame, DnDConstants.ACTION_COPY_OR_MOVE,\n+                    dragGestureListener);\n+\n+            frame.getToolkit().addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n+            frame.setVisible(true);\n+        });\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void test() throws Exception {\n+        final Robot robot = new Robot();\n+        robot.setAutoDelay(45);\n+        robot.waitForIdle();\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            srcPoint = frame.getLocationOnScreen();\n+            d = frame.getSize();\n+        });\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!pointInComponent(robot, srcPoint, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate source frame.\");\n+            return;\n+        }\n+\n+        final Point dstPoint = new Point(srcPoint);\n+        dstPoint.translate(d.width \/ 4, d.height \/ 4);\n+\n+        if (!pointInComponent(robot, dstPoint, frame)) {\n+            System.err.println(\"WARNING: Couldn't locate target frame.\");\n+            return;\n+        }\n+\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.delay(250);\n+        System.out.println(\"srcPoint = \" + srcPoint);\n+        for (; !srcPoint.equals(dstPoint);\n+                srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            System.out.println(\"srcPoint = \" + srcPoint);\n+        }\n+\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        System.out.println(\"done\");\n+        robot.waitForIdle();\n+        robot.delay(MOUSE_RELEASE_TIMEOUT);\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    public void dispose() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        });\n+    }\n+\n+    public void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component) e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    boolean pointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/MouseEventAfterStartDragTest\/MouseEventAfterStartDragTest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/jdk\/java\/awt\/font\/GlyphVector\/LayoutCompatTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,5 +32,1 @@\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -53,2 +49,4 @@\n-    public void testAccessModes(MemorySegment segment, ValueLayout layout, AccessMode mode) throws Throwable {\n-        VarHandle varHandle = layout.varHandle();\n+    public void testAccessModes(MemorySegment segment, MemoryLayout layout, AccessMode mode) throws Throwable {\n+        VarHandle varHandle = layout instanceof ValueLayout ?\n+                layout.varHandle() :\n+                layout.varHandle(MemoryLayout.PathElement.groupElement(0));\n@@ -56,1 +54,1 @@\n-        boolean compatible = AccessModeKind.supportedModes(layout).contains(AccessModeKind.of(mode));\n+        boolean compatible = AccessModeKind.supportedModes(accessLayout(layout)).contains(AccessModeKind.of(mode));\n@@ -64,1 +62,2 @@\n-            assertTrue(compatible);\n+            assertTrue(compatible ||\n+                    (layout instanceof GroupLayout && segment.maxByteAlignment() < layout.byteAlignment()));\n@@ -68,0 +67,8 @@\n+    static ValueLayout accessLayout(MemoryLayout layout) {\n+        return switch (layout) {\n+            case ValueLayout vl -> vl;\n+            case GroupLayout gl -> accessLayout(gl.memberLayouts().get(0));\n+            default -> throw new IllegalStateException();\n+        };\n+    }\n+\n@@ -148,0 +155,1 @@\n+                layouts.add(MemoryLayout.structLayout(layout.withByteAlignment(align)));\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -41,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -314,0 +316,18 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testOffsetHandleOOBIndex(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                 long expectedByteOffset) throws Throwable {\n+        int[] badIndices = { -1, 10 };\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(badIndices[1], layout);\n+        for (int badIndex : badIndices) {\n+            PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+            long[] seqIndexes = new long[indexes.length + 1];\n+            System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+            System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+            seqPathElements[0] = PathElement.sequenceElement();\n+            seqIndexes[0] = badIndex;\n+            MethodHandle seqByteOffsetHandle = seqLayout.byteOffsetHandle(seqPathElements)\n+                    .asSpreader(long[].class, seqIndexes.length);\n+            assertThrows(IndexOutOfBoundsException.class, () -> seqByteOffsetHandle.invoke(0L, seqIndexes));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331681\n+ * @summary Verify the java.base's console provider handles the prompt correctly.\n+ * @library \/test\/lib\n+ * @run main\/othervm --limit-modules java.base ConsolePromptTest\n+ * @run main\/othervm -Djdk.console=java.base ConsolePromptTest\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ConsolePromptTest {\n+\n+    public static void main(String... args) throws Throwable {\n+        for (Method m : ConsolePromptTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                m.invoke(new ConsolePromptTest());\n+            }\n+        }\n+    }\n+\n+    void testCorrectOutputReadLine() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadLine\", \"inp\", \"%s\");\n+    }\n+\n+    void testCorrectOutputReadPassword() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadPassword\", \"inp\", \"%s\");\n+    }\n+\n+    void doRunConsoleTest(String testName,\n+                          String input,\n+                          String expectedOut) throws Exception {\n+        ProcessBuilder builder =\n+                ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName(),\n+                                                          testName);\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder, input);\n+\n+        output.waitFor();\n+\n+        if (output.getExitValue() != 0) {\n+            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n+                                     \", actualOut: \" + output.getStdout() +\n+                                     \", actualErr: \" + output.getStderr());\n+        }\n+\n+        String actualOut = output.getStdout();\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+\n+        String expectedErr = \"\";\n+        String actualErr = output.getStderr();\n+\n+        if (!Objects.equals(expectedErr, actualErr)) {\n+            throw new AssertionError(\"Unexpected stderr content. \" +\n+                                     \"Expected: '\" + expectedErr + \"'\" +\n+                                     \", got: '\" + actualErr + \"'\");\n+        }\n+    }\n+\n+    public static class ConsoleTest {\n+        public static void main(String... args) {\n+            switch (args[0]) {\n+                case \"testCorrectOutputReadLine\" ->\n+                    System.console().readLine(\"%%s\");\n+                case \"testCorrectOutputReadPassword\" ->\n+                    System.console().readPassword(\"%%s\");\n+                default -> throw new UnsupportedOperationException(args[0]);\n+            }\n+\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/ConsolePromptTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @bug 8330276\n+ * @summary Tests Console methods that have Locale as an argument\n+ * @library \/test\/lib\n+ * @modules jdk.internal.le jdk.localedata\n+ *\/\n+public class LocaleTest {\n+    private static Calendar TODAY  = new GregorianCalendar(2024, Calendar.APRIL, 22);\n+    private static String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n+    \/\/ We want to limit the expected strings within US-ASCII charset, as\n+    \/\/ the native encoding is determined as such, which is used by\n+    \/\/ the `Process` class under jtreg environment.\n+    private static List<String> EXPECTED = List.of(\n+        String.format(Locale.UK, FORMAT, TODAY),\n+        String.format(Locale.FRANCE, FORMAT, TODAY),\n+        String.format(Locale.GERMANY, FORMAT, TODAY),\n+        String.format(Locale.of(\"es\"), FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY),\n+        String.format((Locale)null, FORMAT, TODAY)\n+    );\n+\n+    public static void main(String... args) throws Throwable {\n+        if (args.length == 0) {\n+            \/\/ no arg will launch the child process that actually perform tests\n+            var pb = ProcessTools.createTestJavaProcessBuilder(\n+                    \"LocaleTest\", \"dummy\");\n+            var input = new File(System.getProperty(\"test.src\", \".\"), \"input.txt\");\n+            pb.redirectInput(input);\n+            var oa = ProcessTools.executeProcess(pb);\n+            if (oa.getExitValue() == -1) {\n+                System.out.println(\"System.console() returns null. Ignoring the test.\");\n+            } else {\n+                var output = oa.asLines();\n+                var resultText =\n+                    \"\"\"\n+                    Actual output: %s\n+                    Expected output: %s\n+                    \"\"\".formatted(output, EXPECTED);\n+                if (!output.equals(EXPECTED)) {\n+                    throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n+                } else {\n+                    oa.shouldHaveExitValue(0);\n+                    System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n+                }\n+            }\n+        } else {\n+            var con = System.console();\n+            if (con != null) {\n+                \/\/ tests these additional methods that take a Locale\n+                con.format(Locale.UK, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.printf(Locale.FRANCE, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readLine(Locale.GERMANY, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+\n+                \/\/ tests null locale\n+                con.format((Locale)null, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.printf((Locale)null, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readLine((Locale)null, FORMAT, TODAY);\n+                con.printf(\"\\n\");\n+                con.readPassword((Locale)null, FORMAT, TODAY);\n+            } else {\n+                \/\/ Exit with -1\n+                System.exit(-1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Console\/LocaleTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -248,1 +248,1 @@\n-                cob.constantInstruction(name + \" should not be invoked\");\n+                cob.loadConstant(name + \" should not be invoked\");\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ProhibitedMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                    cob.constantInstruction(osf.getName());\n+                    cob.loadConstant(osf.getName());\n@@ -275,1 +275,1 @@\n-                        cob.constantInstruction(DynamicConstantDesc.ofNamed(\n+                        cob.loadConstant(DynamicConstantDesc.ofNamed(\n@@ -279,1 +279,1 @@\n-                        cob.constantInstruction(osf.getType().describeConstable().orElseThrow());\n+                        cob.loadConstant(osf.getType().describeConstable().orElseThrow());\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialPersistentFieldsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.util.SerializationUtils;\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.ObjectStreamPrinter;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @bug 8331224\n+ * @summary Test missing class throws CNFE before creating record or setting class fields\n+ * @library \/test\/lib\n+ * @run junit SerialProxyClassNotFound\n+ *\/\n+\n+\/**\n+ * Verify the correct exception (CNFE) is thrown when the class is not found during\n+ * deserialization. Field values for objects should result in CNFE *before* creating the\n+ * record or initializing the fields of a class.\n+ * The issue is exposed by the use of serialization proxy classes; the proxies\n+ * typically have types that are different from the original object type and\n+ * result in ClassCastException.\n+ *\/\n+public class SerialProxyClassNotFound implements Serializable {\n+\n+    private static Stream<Arguments> Cases() {\n+        return Stream.of(\n+                Arguments.of(new Record1(Map.of(\"aaa\", new XX()))), \/\/ Map uses serial proxy\n+                Arguments.of(new Class2(Map.of(\"bbb\", new XX()))),  \/\/ Map uses serial proxy\n+                Arguments.of(new Record4(new Class3(new XX()))),       \/\/ Class3 uses serial proxy\n+                Arguments.of(new Class5(new Class3(new XX()))),        \/\/ Class3 uses serial proxy\n+                Arguments.of(new Class6(new Class3(new XX())))         \/\/ Class3 uses serial proxy\n+        );\n+    }\n+    @ParameterizedTest\n+    @MethodSource(\"Cases\")\n+    void checkForCNFE(Object obj) throws ClassNotFoundException, IOException {\n+        \/\/ A record with field containing a Map with an entry for a class that is not found\n+        byte[] bytes = SerializationUtils.serialize(obj);\n+\n+        \/\/ Scan bytes looking for \"$XX\"; replace all occurrences\n+        boolean replaced = false;\n+        for (int off = 0; off < bytes.length - 3; off++) {\n+            if (bytes[off] == '$' && bytes[off + 1] == 'X' && bytes[off + 2] == 'X') {\n+                \/\/ Modify bytes to change name of class to SerialProxyClassNotFound$YY\n+                bytes[off + 1] = 'Y';\n+                bytes[off + 2] = 'Y';\n+                replaced = true;\n+            }\n+        }\n+        if (!replaced) {\n+            \/\/ Not found, Debug dump the bytes to locate the index of the XX class name\n+            HexPrinter.simple()\n+                    .formatter(ObjectStreamPrinter.formatter())\n+                    .dest(System.err)\n+                    .format(bytes);\n+            fail(\"'$XX' of `SerialProxyClassNotFound$XX` not found in serialized bytes \");\n+        }\n+\n+        try {\n+            Object o = SerializationUtils.deserialize(bytes);\n+            System.out.println(\"Deserialized obj: \" + o);\n+            HexPrinter.simple()\n+                    .formatter(ObjectStreamPrinter.formatter())\n+                    .dest(System.err)\n+                    .format(bytes);\n+            fail(\"deserialize should have thrown ClassNotFoundException\");\n+        } catch (ClassNotFoundException cnfe) {\n+            assertEquals(cnfe.getMessage(),\n+                    \"SerialProxyClassNotFound$YY\",\n+                    \"CNFE message incorrect\");\n+        } catch (IOException ioe) {\n+            HexPrinter.simple()\n+                    .formatter(ObjectStreamPrinter.formatter())\n+                    .dest(System.err)\n+                    .format(bytes);\n+            throw ioe;\n+        }\n+    }\n+\n+    \/\/ A class with a readily identifiable name\n+    static class XX implements Serializable { }\n+\n+    \/\/ A record holding a Map holding a reference to a readily identifiable (but deleted) class\n+    record Record1(Map<String,XX> arg) implements Serializable {};\n+\n+    \/\/ Class holding a Map holding a reference to a (deleted) class\n+    static class Class2 implements Serializable {\n+        Map<String, XX> arg;\n+        Class2(Map<String,XX> arg) {\n+            this.arg = arg;\n+        }\n+        public String toString() {\n+            return \"Class2[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+    \/\/ Class3 a holder of a reference to a class that will be \"deleted\"\n+    static class Class3 implements Serializable {\n+        XX arg;\n+        Class3(XX arg) {\n+            this.arg = arg;\n+        }\n+        private Object writeReplace() {\n+            return new Class3Proxy(arg);\n+        }\n+        public String toString() {\n+            return \"Class3[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+    \/\/ Serial proxy for Class3\n+    record Class3Proxy(XX arg) implements Serializable {\n+        private Object readResolve() {\n+            return new Class3(arg);\n+        }\n+    }\n+\n+    \/\/ Record holding a Class3\n+    record Record4(Class3 arg) implements Serializable {}\n+\n+    \/\/ Holder class without custom readObject\n+    \/\/ Causes !hasSpecialReadMethod path through OIS.readSerialData\n+    static class Class5 implements Serializable {\n+        Class3 arg;\n+        Class5(Class3 arg) {\n+            this.arg = arg;\n+        }\n+        public String toString() {\n+            return \"Class5[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+    \/\/ Holder class with custom readObject\n+    \/\/ Causes hasSpecialReadMethod path taken through OIS.readSerialData\n+    static class Class6 implements Serializable {\n+        Class3 arg;\n+        Class6(Class3 arg) {\n+            this.arg = arg;\n+        }\n+        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n+            ois.defaultReadObject();\n+        }\n+        public String toString() {\n+            return \"Class6[arg=\" + arg + \"]\";\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/serialProxy\/SerialProxyClassNotFound.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/JspawnhelperWarnings.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @enablePreview\n@@ -32,8 +32,0 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.Method;\n-\n@@ -43,1 +35,5 @@\n-import java.util.Arrays;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.constant.MethodTypeDesc;\n@@ -69,1 +65,1 @@\n-    TestBCI(Class<?> c) throws ConstantPoolException, IOException {\n+    TestBCI(Class<?> c) throws IllegalArgumentException, IOException {\n@@ -73,2 +69,2 @@\n-            ClassFile cf = ClassFile.read(in);\n-            methods = Arrays.stream(cf.methods)\n+            var cf = ClassFile.of().parse(in.readAllBytes());\n+            methods = cf.methods().stream()\n@@ -132,1 +128,1 @@\n-        final Method method;\n+        final MethodModel method;\n@@ -134,2 +130,1 @@\n-        final String paramTypes;\n-        final String returnType;\n+        final MethodTypeDesc desc;\n@@ -137,1 +132,1 @@\n-        MethodInfo(ClassFile cf, Method m) {\n+        MethodInfo(ClassModel cf, MethodModel m) {\n@@ -139,24 +134,8 @@\n-\n-            String name;\n-            String paramTypes;\n-            String returnType;\n-            LineNumberTable_attribute.Entry[] lineNumberTable;\n-            try {\n-                \/\/ method name\n-                name = m.getName(cf.constant_pool);\n-                \/\/ signature\n-                paramTypes = m.descriptor.getParameterTypes(cf.constant_pool);\n-                returnType = m.descriptor.getReturnType(cf.constant_pool);\n-                Code_attribute codeAttr = (Code_attribute)\n-                    m.attributes.get(Attribute.Code);\n-                lineNumberTable = ((LineNumberTable_attribute)\n-                    codeAttr.attributes.get(Attribute.LineNumberTable)).line_number_table;\n-            } catch (ConstantPoolException|Descriptor.InvalidDescriptor e) {\n-                throw new RuntimeException(e);\n-            }\n-            this.name = name;\n-            this.paramTypes = paramTypes;\n-            this.returnType = returnType;\n-            Arrays.stream(lineNumberTable).forEach(entry ->\n-                bciToLineNumbers.computeIfAbsent(entry.start_pc, _n -> new TreeSet<>())\n-                    .add(entry.line_number));\n+            this.name = m.methodName().stringValue();\n+            this.desc = m.methodTypeSymbol();\n+            m.code().orElseThrow(() -> new IllegalArgumentException(\"Missing Code in \" + m))\n+                    .findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                    .orElseThrow(() -> new IllegalArgumentException(\"Missing LineNumberTable in \" + m))\n+                    .lineNumbers().forEach(entry ->\n+                            bciToLineNumbers.computeIfAbsent(entry.startPc(), _ -> new TreeSet<>())\n+                                    .add(entry.lineNumber()));\n@@ -181,1 +160,1 @@\n-            sb.append(paramTypes).append(returnType).append(\" \");\n+            sb.append(desc.displayDescriptor()).append(\" \");\n","filename":"test\/jdk\/java\/lang\/StackWalker\/TestBCI.java","additions":22,"deletions":43,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -240,0 +240,6 @@\n+        try {\n+            ConstantDescs.CD_void.arrayType();\n+            fail(\"Should throw IAE\");\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ Expected\n+        }\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package java.lang.constant;\n+package jdk.internal.constant;\n@@ -26,1 +26,0 @@\n-import java.lang.invoke.*;\n@@ -38,0 +37,1 @@\n+ * @modules java.base\/jdk.internal.constant\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/java\/lang\/constant\/ConstantUtilsTest.java","status":"renamed"},{"patch":"@@ -86,2 +86,2 @@\n-                                            h.constantInstruction(name);\n-                                            h.constantInstruction(transformId);\n+                                            h.loadConstant(name);\n+                                            h.loadConstant(transformId);\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-                                           cb.constantInstruction(fixedIndex);\n+                                           cb.loadConstant(fixedIndex);\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformAgent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                                    cb.loadInstruction(kind, ptr);\n+                                    cb.loadLocal(kind, ptr);\n@@ -129,1 +129,1 @@\n-                                cb.invokeInstruction(isStatic ? Opcode.INVOKESTATIC : Opcode.INVOKESPECIAL,\n+                                cb.invoke(isStatic ? Opcode.INVOKESTATIC : Opcode.INVOKESPECIAL,\n@@ -131,1 +131,1 @@\n-                                cb.returnInstruction(TypeKind.from(mt.returnType()));\n+                                cb.return_(TypeKind.from(mt.returnType()));\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                cob.constantInstruction(CD_Comparator);\n+                cob.loadConstant(CD_Comparator);\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -393,2 +393,2 @@\n-                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA, DEFAULT_NAME, returnDesc));\n-                    cob.returnInstruction(TypeKind.from(returnType));\n+                    cob.loadConstant(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA, DEFAULT_NAME, returnDesc));\n+                    cob.return_(TypeKind.from(returnType));\n@@ -408,2 +408,2 @@\n-                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, returnDesc, index));\n-                    cob.returnInstruction(TypeKind.from(returnType));\n+                    cob.loadConstant(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, returnDesc, index));\n+                    cob.return_(TypeKind.from(returnType));\n@@ -420,2 +420,2 @@\n-                    cob.constantInstruction(dynamic);\n-                    cob.returnInstruction(TypeKind.from(returnType));\n+                    cob.loadConstant(dynamic);\n+                    cob.return_(TypeKind.from(returnType));\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/classData\/ClassDataTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                                            codeBuilder.loadInstruction(TypeKind.from(type.parameterType(i)), i);\n+                                            codeBuilder.loadLocal(TypeKind.from(type.parameterType(i)), i);\n@@ -78,1 +78,1 @@\n-                                        codeBuilder.returnInstruction(TypeKind.from(type.returnType()));\n+                                        codeBuilder.return_(TypeKind.from(type.returnType()));\n@@ -120,1 +120,1 @@\n-                                    .returnInstruction(TypeKind.fromDescriptor(type))));\n+                                    .return_(TypeKind.fromDescriptor(type))));\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-\/\/                                                    .instanceof_(ConstantDescs.CD_MethodType)\n+\/\/                                                    .instanceOf(ConstantDescs.CD_MethodType)\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyNestedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-                cob.constantInstruction(MethodHandleDesc.ofMethod(SPECIAL, CD_T1, METHOD_NAME, MTD_int));\n+                cob.loadConstant(MethodHandleDesc.ofMethod(SPECIAL, CD_T1, METHOD_NAME, MTD_int));\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/SpecialStatic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                        cob.constantInstruction(EXPECTED);\n+                        cob.loadConstant(EXPECTED);\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/invoke\/TestPrivateInterfaceMethodReflect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,1 +358,1 @@\n-            exchange.sendResponseHeaders(407, 0);\n+            exchange.sendResponseHeaders(407, -1);\n","filename":"test\/jdk\/java\/net\/Authenticator\/B4769350.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/jdk\/java\/net\/httpclient\/RedirectTimeoutTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ExpectContinueResetTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @summary Block devices should not report size=0 on Linux\n- * @run main\/manual BlockDeviceSize\n+ * @summary FileChannel.size() should be equal to RandomAccessFile.size() and > 0 for block devs on Linux\n+ * @library \/test\/lib\n@@ -33,1 +33,0 @@\n-import java.nio.file.Paths;\n@@ -37,0 +36,2 @@\n+import java.util.List;\n+\n@@ -39,0 +40,1 @@\n+import jtreg.SkippedException;\n@@ -41,2 +43,1 @@\n-    private static final String BLK_FNAME = \"\/dev\/sda1\";\n-    private static final Path BLK_PATH = Paths.get(BLK_FNAME);\n+    private static final List<String> BLK_FNAMES = List.of(\"\/dev\/sda1\", \"\/dev\/nvme0n1\", \"\/dev\/xvda1\") ;\n@@ -45,2 +46,15 @@\n-        try (FileChannel ch = FileChannel.open(BLK_PATH, READ);\n-             RandomAccessFile file = new RandomAccessFile(BLK_FNAME, \"r\")) {\n+        for (String blkFname: BLK_FNAMES) {\n+            Path blkPath = Path.of(blkFname);\n+            try (FileChannel ch = FileChannel.open(blkPath, READ);\n+                 RandomAccessFile file = new RandomAccessFile(blkFname, \"r\")) {\n+\n+                long size1 = ch.size();\n+                long size2 = file.length();\n+                if (size1 != size2) {\n+                    throw new RuntimeException(\"size differs when retrieved\" +\n+                            \" in different ways: \" + size1 + \" != \" + size2);\n+                }\n+                if (size1 <= 0) {\n+                    throw new RuntimeException(\"size() for a block device size returns zero or a negative value\");\n+                }\n+                System.out.println(\"OK\");\n@@ -48,5 +62,6 @@\n-            long size1 = ch.size();\n-            long size2 = file.length();\n-            if (size1 != size2) {\n-                throw new RuntimeException(\"size differs when retrieved\" +\n-                        \" in different ways: \" + size1 + \" != \" + size2);\n+            } catch (NoSuchFileException nsfe) {\n+                System.err.println(\"File \" + blkFname + \" not found.\" +\n+                        \" Skipping test\");\n+            } catch (AccessDeniedException ade) {\n+                throw new SkippedException(\"Access to \" + blkFname + \" is denied.\"\n+                        + \" Run test as root.\", ade);\n@@ -54,1 +69,0 @@\n-            System.out.println(\"OK\");\n@@ -56,6 +70,0 @@\n-        } catch (NoSuchFileException nsfe) {\n-            System.err.println(\"File \" + BLK_FNAME + \" not found.\" +\n-                    \" Skipping test\");\n-        } catch (AccessDeniedException ade) {\n-            throw new RuntimeException(\"Access to \" + BLK_FNAME + \" is denied.\"\n-                    + \" Run test as root.\", ade);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/BlockDeviceSize.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8330077\n+ * @summary Tests WatchService behavior with more entries in a watched directory\n+ *     than the default event limit\n+ * @library ..\n+ * @run main\/othervm LotsOfEntries 600 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=invalid LotsOfEntries 600 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=-5 LotsOfEntries 5 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=5 LotsOfEntries 5 pass\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=5 LotsOfEntries 6 fail\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=700 LotsOfEntries 600 pass\n+ * @run main\/othervm -Djdk.nio.file.WatchService.maxEventsPerPoll=3000000000 LotsOfEntries 600 pass\n+ *\/\n+\n+import java.nio.file.*;\n+import static java.nio.file.StandardWatchEventKinds.*;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+public class LotsOfEntries {\n+\n+    static void testCreateLotsOfEntries(Path dir, int numEvents, boolean fail) throws Exception {\n+        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n+            System.out.format(\"register %s for events\\n\", dir);\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE);\n+\n+            System.out.format(\"create %d entries\\n\", numEvents);\n+            Set<Path> entries = new HashSet<>();\n+            for (int i = 0; i < numEvents; i++) {\n+                Path entry = dir.resolve(\"entry\" + i);\n+                entries.add(entry);\n+                Files.createFile(entry);\n+            }\n+\n+            \/\/ Wait for all events to be signalled - the timeout is long to\n+            \/\/ allow for polling implementations. Since we specifically want to\n+            \/\/ test the maximum number of events buffered for a single\n+            \/\/ WatchKey#pollEvents call, we need to poll on the WatchService\n+            \/\/ repeatedly until all (not just some) events have been signalled.\n+            System.out.println(\"poll watcher...\");\n+            WatchKey signalledKey;\n+            do {\n+              signalledKey = watcher.poll(10, TimeUnit.SECONDS);\n+              if (signalledKey != null && signalledKey != key) {\n+                throw new RuntimeException(\"Unexpected key returned from poll\");\n+              }\n+            } while (signalledKey != null);\n+\n+            if (fail) {\n+                System.out.println(\"poll expecting overflow...\");\n+                var events = key.pollEvents();\n+                if (events.size() != 1) {\n+                    throw new RuntimeException(\n+                        \"Expected overflow event, got: \" + toString(events));\n+                }\n+                if (!events.getFirst().kind().equals(OVERFLOW)) {\n+                    throw new RuntimeException(\n+                        \"Expected overflow event, got: \" + toString(events));\n+                }\n+            } else {\n+                System.out.println(\"poll not expecting overflow...\");\n+                List<WatchEvent<?>> events = key.pollEvents();\n+                Set<Path> contexts = events.stream()\n+                    .map(WatchEvent::context)\n+                    .map(Path.class::cast)\n+                    .map(entry -> dir.resolve(entry))\n+                    .collect(Collectors.toSet());\n+                if (!entries.equals(contexts)) {\n+                    throw new RuntimeException(\n+                        \"Expected events on: \" + entries + \", got: \" + toString(events));\n+                }\n+            }\n+        }\n+    }\n+\n+    static String toString(List<WatchEvent<?>> events) {\n+        return events.stream()\n+            .map(LotsOfEntries::toString)\n+            .collect(Collectors.joining(\", \"));\n+    }\n+\n+    static String toString(WatchEvent event) {\n+        return String.format(\"%s(%d): %s\", event.kind(), event.count(), event.context());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path dir = TestUtil.createTemporaryDirectory();\n+        int numEvents = Integer.parseInt(args[0]);\n+        boolean fail = args[1].equals(\"fail\");\n+        try {\n+            testCreateLotsOfEntries(dir, numEvents, fail);\n+        } finally {\n+            TestUtil.removeAll(dir);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/WatchService\/LotsOfEntries.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+import java.time.Duration;\n@@ -68,0 +69,1 @@\n+import static org.testng.Assert.assertThrows;\n@@ -71,1 +73,1 @@\n- * @bug 8273369\n+ * @bug 8273369 8331202\n@@ -123,0 +125,29 @@\n+\n+    @DataProvider\n+    private Object[][] provider_until_1arg() {\n+        Instant t1 = Instant.ofEpochSecond(0, 10);\n+        Instant t2 = Instant.ofEpochSecond(10, -20);\n+        return new Object[][] {\n+            {t1, t2},\n+            {t2, t1},\n+            {Instant.MIN, Instant.MAX},\n+            {Instant.MAX, Instant.MIN},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provider_until_1arg\")\n+    public void test_until_1arg(Instant start, Instant end) {\n+        Duration result = start.until(end);\n+        Duration expected = Duration.ofSeconds(end.getEpochSecond() - start.getEpochSecond(),\n+                end.getNano() - start.getNano());\n+        assertEquals(result, expected);\n+        expected = Duration.between(start, end);\n+        assertEquals(result, expected);\n+    }\n+\n+    @Test\n+    public void test_until_1arg_NPE() {\n+        assertThrows(NullPointerException.class, () -> {\n+            Instant.now().until(null);\n+        });\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstant.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,4 @@\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -28,1 +30,4 @@\n-\/**\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n@@ -30,6 +35,6 @@\n- * @bug 8210583 8217969 8218265\n- * @summary Tests Base64.Encoder.encode and Base64.Decoder.decode\n- *          with the large size of input array\/buffer\n- * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 10g)\n- * @run main\/othervm -Xms6g -Xmx8g TestEncodingDecodingLength\n- *\n+ * @bug 8210583 8217969 8218265 8295153\n+ * @summary White-box test that effectively checks Base64.Encoder.encode and\n+ *          Base64.Decoder.decode behavior with large, (Integer.MAX_VALUE) sized\n+ *          input array\/buffer. Tests the private methods \"encodedOutLength\" and\n+ *          \"decodedOutLength\".\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED TestEncodingDecodingLength\n@@ -38,0 +43,2 @@\n+\/\/ We perform a white-box test due to the heavy memory usage that testing\n+\/\/ the public API would require which has shown to cause intermittent issues\n@@ -40,4 +47,4 @@\n-    public static void main(String[] args) {\n-        int size = Integer.MAX_VALUE - 8;\n-        byte[] inputBytes = new byte[size];\n-        byte[] outputBytes = new byte[size];\n+    \/\/ A value large enough to test the desired memory conditions in encode and decode\n+    private static final int LARGE_MEM_SIZE = Integer.MAX_VALUE - 8;\n+    private static final Base64.Decoder DECODER = Base64.getDecoder();\n+    private static final Base64.Encoder ENCODER = Base64.getEncoder();\n@@ -45,14 +52,11 @@\n-        \/\/ Check encoder with large array length\n-        Base64.Encoder encoder = Base64.getEncoder();\n-        checkOOM(\"encode(byte[])\", () -> encoder.encode(inputBytes));\n-        checkIAE(\"encode(byte[] byte[])\", () -> encoder.encode(inputBytes, outputBytes));\n-        checkOOM(\"encodeToString(byte[])\", () -> encoder.encodeToString(inputBytes));\n-        checkOOM(\"encode(ByteBuffer)\", () -> encoder.encode(ByteBuffer.wrap(inputBytes)));\n-\n-        \/\/ Check decoder with large array length,\n-        \/\/ should not throw any exception\n-        Arrays.fill(inputBytes, (byte) 86);\n-        Base64.Decoder decoder = Base64.getDecoder();\n-        decoder.decode(inputBytes);\n-        decoder.decode(inputBytes, outputBytes);\n-        decoder.decode(ByteBuffer.wrap(inputBytes));\n+    \/\/ Effectively tests that encode(byte[] src, byte[] dst) throws an\n+    \/\/ IllegalArgumentException with array sized near Integer.MAX_VALUE. All the\n+    \/\/ encode() methods call encodedOutLength(), which is where the OOME is expected\n+    @Test\n+    public void largeEncodeIAETest() throws IllegalAccessException,\n+            InvocationTargetException, NoSuchMethodException {\n+        Method m = getMethod(ENCODER,\n+                \"encodedOutLength\", int.class, boolean.class);\n+        \/\/ When throwOOME param is false, encodedOutLength should return -1 in\n+        \/\/ this situation, which encode() uses to throw IAE\n+        assertEquals(-1, m.invoke(ENCODER, LARGE_MEM_SIZE, false));\n@@ -61,1 +65,6 @@\n-    private static final void checkOOM(String methodName, Runnable r) {\n+    \/\/ Effectively tests that the overloaded encode() and encodeToString() methods\n+    \/\/ throw OutOfMemoryError with array\/buffer sized near Integer.MAX_VALUE\n+    @Test\n+    public void largeEncodeOOMETest() throws IllegalAccessException, NoSuchMethodException {\n+        Method m = getMethod(ENCODER,\n+                \"encodedOutLength\", int.class, boolean.class);\n@@ -63,3 +72,7 @@\n-            r.run();\n-            throw new RuntimeException(\"OutOfMemoryError should have been thrown by: \" + methodName);\n-        } catch (OutOfMemoryError er) {}\n+            m.invoke(ENCODER, LARGE_MEM_SIZE, true);\n+        } catch (InvocationTargetException ex) {\n+            Throwable rootEx = ex.getCause();\n+            assertEquals(OutOfMemoryError.class, rootEx.getClass(),\n+                    \"OOME should be thrown with Integer.MAX_VALUE input\");\n+            assertEquals(\"Encoded size is too large\", rootEx.getMessage());\n+        }\n@@ -68,1 +81,9 @@\n-    private static final void checkIAE(String methodName, Runnable r) {\n+    \/\/ Effectively tests that the overloaded decode() methods do not throw\n+    \/\/ OOME nor NASE with array\/buffer sized near Integer.MAX_VALUE All the decode\n+    \/\/ methods call decodedOutLength(), which is where the previously thrown\n+    \/\/ OOME or NASE would occur at.\n+    @Test\n+    public void largeDecodeTest() throws IllegalAccessException, NoSuchMethodException {\n+        Method m = getMethod(DECODER,\n+                \"decodedOutLength\", byte[].class, int.class, int.class);\n+        byte[] src = {1};\n@@ -70,3 +91,15 @@\n-            r.run();\n-            throw new RuntimeException(\"IllegalArgumentException should have been thrown by: \" + methodName);\n-        } catch (IllegalArgumentException iae) {}\n+            \/*\n+             decodedOutLength() takes the src array, position, and limit as params.\n+             The src array will be indexed at limit-1 to search for padding.\n+             To avoid passing an array with Integer.MAX_VALUE memory allocated, we\n+             set position param to be -size. Since the initial length\n+             is calculated as limit - position. This mocks the potential overflow\n+             calculation and still allows the array to be indexed without an AIOBE.\n+            *\/\n+            m.invoke(DECODER, src, -LARGE_MEM_SIZE + 1, 1);\n+        } catch (InvocationTargetException ex) {\n+            \/\/ 8210583 - decode no longer throws NASE\n+            \/\/ 8217969 - decode no longer throws OOME\n+            fail(\"Decode threw an unexpected exception with \" +\n+                    \"Integer.MAX_VALUE sized input: \" + ex.getCause());\n+        }\n@@ -74,1 +107,0 @@\n-}\n@@ -76,0 +108,8 @@\n+    \/\/ Utility to get the private visibility method\n+    private static Method getMethod(Object obj, String methodName, Class<?>... params)\n+            throws NoSuchMethodException {\n+        Method m = obj.getClass().getDeclaredMethod(methodName, params);\n+        m.setAccessible(true);\n+        return m;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Base64\/TestEncodingDecodingLength.java","additions":77,"deletions":37,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331646\n+ * @summary confirm that Calendar.add() works correctly with leap year calculations\n+ * @run junit CalendarLeapYearAddTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static java.util.Calendar.APRIL;\n+import static java.util.Calendar.DATE;\n+import static java.util.Calendar.DAY_OF_MONTH;\n+import static java.util.Calendar.DAY_OF_WEEK;\n+import static java.util.Calendar.DAY_OF_WEEK_IN_MONTH;\n+import static java.util.Calendar.DAY_OF_YEAR;\n+import static java.util.Calendar.FEBRUARY;\n+import static java.util.Calendar.LONG;\n+import static java.util.Calendar.MARCH;\n+import static java.util.Calendar.MONTH;\n+import static java.util.Calendar.WEEK_OF_YEAR;\n+import static java.util.Calendar.YEAR;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CalendarLeapYearAddTest {\n+\n+    \/**\n+     * 8331646 Calendar add for leap year\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"calendarAddSource\")\n+    public void testAddLeapYear(String testName, int calendarDate, int calendarMonth, int calendarYear,\n+                                int value, int calendarField, int expectedDate, int expectedMonth,\n+                                int expectedYear) {\n+        Calendar calendar = new GregorianCalendar(calendarYear, calendarMonth, calendarDate);\n+        calendar.add(calendarField, value);\n+        assertEquals(expectedDate, calendar.get(DATE), testName\n+                + \" Expected \" + expectedDate + \" of \" + expectedMonth + expectedYear + \" but got \" + calendar.getTime());\n+        assertEquals(expectedMonth, calendar.get(MONTH), testName\n+                + \" Expected \" + expectedMonth + \" but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+    }\n+\n+    \/**\n+     * 8331646 Calendar month and year add\/subtract for leap\/non-leap year\n+     *\/\n+    @Test\n+    public void testMonthYearAddSubtractNonLeapYear() {\n+        Calendar calendar = new GregorianCalendar(2024, FEBRUARY, 29);\n+        calendar.add(MONTH, 1);\n+        calendar.add(YEAR, -1);\n+        calendar.add(MONTH, -1);\n+        \/* When month added date jumps to 29th of March 2024, after year subtracted date jumps to 29th of March 2023\n+           after month subtracted date jumps to 28th of Feb 2023 as non leap year\n+         *\/\n+        assertEquals(28, calendar.get(DATE),\n+                \"testMonthYearAddSubtractNonLeapYear Expected 28th of February 2024 but got \" + calendar.getTime());\n+        assertEquals(FEBRUARY, calendar.get(MONTH),\n+                \" testMonthYearAddSubtractNonLeapYear Expected February but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+    }\n+\n+    \/**\n+     * 8331646 Calendar add\/subtract for leap year\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"calendarAddSubtractSource\")\n+    public void testAddSubtractLeapYear(String testName, int calendarDate, int calendarMonth, int calendarYear,\n+                                        int firstValue, int secondValue, int calendarField, int expectedDate,\n+                                        int expectedMonth, int expectedYear) {\n+        Calendar calendar = new GregorianCalendar(calendarYear, calendarMonth, calendarDate);\n+        calendar.add(calendarField, firstValue);\n+        calendar.add(calendarField, secondValue);\n+        assertEquals(expectedDate, calendar.get(DATE), testName\n+                + \" Expected \" + expectedDate + \" of \" + expectedMonth + expectedYear + \" but got \" + calendar.getTime());\n+        assertEquals(expectedMonth, calendar.get(MONTH), testName\n+                + \" Expected \" + expectedMonth + \" but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+    }\n+\n+    private static Stream<Arguments> calendarAddSubtractSource() {\n+        return Stream.of(\n+                Arguments.of(\"testMonthAddSubtractLeapYearReversed\", 31, MARCH, 2024, -1, 1, MONTH, 29, MARCH, 2024),\n+                Arguments.of(\"testMonthAddSubtractLeapYear\", 29, FEBRUARY, 2024, 1, -1, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testYearAddSubtractLeapYear\", 29, FEBRUARY, 2024, 1, -1, YEAR, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfYearAddSubtractLeapYear\", 29, FEBRUARY, 2024, 365, -365, DAY_OF_YEAR, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDateAddSubtractLeapYear\", 29, FEBRUARY, 2024, 365, -365, DATE, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testWeekOfYearAddSubtractLeapYear\", 29, FEBRUARY, 2024, 52, -52, WEEK_OF_YEAR, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfMonthAddSubtractLeapYear\", 29, FEBRUARY, 2024, 31, -31, DAY_OF_MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekInMonthAddSubtractLeapYear\", 29, FEBRUARY, 2024, 6, -6, DAY_OF_WEEK_IN_MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekAddSubtractLeapYear\", 29, FEBRUARY, 2024, 6, -6, DAY_OF_WEEK, 29, FEBRUARY, 2024)\n+        );\n+    }\n+\n+    private static Stream<Arguments> calendarAddSource() {\n+        return Stream.of(\n+                Arguments.of(\"testMonthAddLeapYear\", 29, FEBRUARY, 2024, 1, MONTH, 29, MARCH, 2024),\n+                Arguments.of(\"testOneMonthSubtractLeapYear\", 31, MARCH, 2024, -1, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testTwoMonthSubtractLeapYear\", 30, APRIL, 2024, -2, MONTH, 29, FEBRUARY, 2024)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarLeapYearAddTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331851\n+ * @summary confirm that Calendar.roll() works correctly with leap year calculations\n+ * @run junit CalendarLeapYearRollTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static java.util.Calendar.APRIL;\n+import static java.util.Calendar.DATE;\n+import static java.util.Calendar.DAY_OF_MONTH;\n+import static java.util.Calendar.DAY_OF_WEEK;\n+import static java.util.Calendar.DAY_OF_WEEK_IN_MONTH;\n+import static java.util.Calendar.DAY_OF_YEAR;\n+import static java.util.Calendar.FEBRUARY;\n+import static java.util.Calendar.LONG;\n+import static java.util.Calendar.MARCH;\n+import static java.util.Calendar.MONTH;\n+import static java.util.Calendar.WEEK_OF_YEAR;\n+import static java.util.Calendar.YEAR;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CalendarLeapYearRollTest {\n+\n+    \/**\n+     * 8331851 Calendar roll for leap year\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"calendarRollSource\")\n+    public void testRollLeapYear(String testName, int calendarDate, int calendarMonth, int calendarYear,\n+                                 int value, int calendarField, int expectedDate, int expectedMonth,\n+                                 int expectedYear) {\n+        Calendar calendar = new GregorianCalendar(calendarYear, calendarMonth, calendarDate);\n+        calendar.roll(calendarField, value);\n+        assertEquals(expectedDate, calendar.get(DATE), testName\n+                + \" Expected \" + expectedDate + \" of \" + expectedMonth + expectedYear + \" but got \" + calendar.getTime());\n+        assertEquals(expectedMonth, calendar.get(MONTH), testName\n+                + \" Expected \" + expectedMonth + \" but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+        assertEquals(expectedYear, calendar.get(YEAR), testName\n+                + \" Expected \" + expectedYear + \" but got \" + calendar.get(YEAR));\n+    }\n+\n+    \/**\n+     * 8331851 Calendar roll up\/down for leap year\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"calendarRollUpDownSource\")\n+    public void testRollUpDownLeapYear(String testName, int calendarDate, int calendarMonth, int calendarYear,\n+                                       int firstValue, int secondValue, int calendarField, int expectedDate,\n+                                       int expectedMonth, int expectedYear) {\n+        Calendar calendar = new GregorianCalendar(calendarYear, calendarMonth, calendarDate);\n+        calendar.roll(calendarField, firstValue);\n+        calendar.roll(calendarField, secondValue);\n+        assertEquals(expectedDate, calendar.get(DATE), testName\n+                + \" Expected \" + expectedDate + \" of \" + expectedMonth + expectedYear + \" but got \" + calendar.getTime());\n+        assertEquals(expectedMonth, calendar.get(MONTH), testName\n+                + \" Expected \" + expectedMonth + \" but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+        assertEquals(expectedYear, calendar.get(YEAR), testName\n+                + \" Expected \" + expectedYear + \" but got \" + calendar.get(YEAR));\n+    }\n+\n+    \/**\n+     * 8331851 Calendar roll boolean for leap year\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"calendarBooleanRollSource\")\n+    public void testBooleanRollLeapYear(String testName, int calendarDate, int calendarMonth, int calendarYear,\n+                                        boolean value, int calendarField, int expectedDate,\n+                                        int expectedMonth, int expectedYear) {\n+        Calendar calendar = new GregorianCalendar(calendarYear, calendarMonth, calendarDate);\n+        calendar.roll(calendarField, value);\n+        assertEquals(expectedDate, calendar.get(DATE), testName\n+                + \" Expected \" + expectedDate + \" of \" + expectedMonth + expectedYear + \" but got \" + calendar.getTime());\n+        assertEquals(expectedMonth, calendar.get(MONTH), testName\n+                + \" Expected \" + expectedMonth + \" but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+        assertEquals(expectedYear, calendar.get(YEAR), testName\n+                + \" Expected \" + expectedYear + \" but got \" + calendar.get(YEAR));\n+    }\n+\n+    \/**\n+     * 8331851 Calendar month and year roll for leap\/non-leap year\n+     *\/\n+    @Test\n+    public void testMonthYearRollUpDownNonLeapYear() {\n+        Calendar calendar = new GregorianCalendar(2024, FEBRUARY, 29);\n+        calendar.roll(MONTH, 1);\n+        calendar.roll(YEAR, -1);\n+        calendar.roll(MONTH, -1);\n+        assertEquals(28, calendar.get(DATE),\n+                \"testMonthYearRollUpDownNonLeapYear Expected 28th of February 2024 but got \" + calendar.getTime());\n+        assertEquals(FEBRUARY, calendar.get(MONTH),\n+                \"testMonthYearRollUpDownNonLeapYear Expected February but got \" + calendar.getDisplayName(MONTH, LONG, Locale.getDefault()));\n+        assertEquals(2023, calendar.get(YEAR),\n+                \"testMonthYearRollUpDownNonLeapYear Expected 2023 but got \" + calendar.get(YEAR));\n+    }\n+\n+    private static Stream<Arguments> calendarRollUpDownSource() {\n+        return Stream.of(\n+                Arguments.of(\"testMonthRollDownUpLeapYearReversed\", 31, MARCH, 2024, -1, 1, MONTH, 29, MARCH, 2024),\n+                Arguments.of(\"testMonthRollUpDownLeapYearReversed\", 29, FEBRUARY, 2024, 1, -1, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testYearRollUpDownLeapYear\", 29, FEBRUARY, 2024, 1, -1, YEAR, 1, MARCH, 2024),\n+                Arguments.of(\"testFourYearRollUpDownLeapYear\", 29, FEBRUARY, 2024, 4, -4, YEAR, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfYearRollUpDownLeapYear\", 29, FEBRUARY, 2024, 365, -365, DAY_OF_YEAR, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDateRollUpDownLeapYear\", 29, FEBRUARY, 2024, 365, -365, DATE, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testWeekOfYearRollUpDownLeapYear\", 29, FEBRUARY, 2024, 52, -52, WEEK_OF_YEAR, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfMonthRollUpDownLeapYear\", 29, FEBRUARY, 2024, 31, -31, DAY_OF_MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekInMonthRollUpDownLeapYear\", 29, FEBRUARY, 2024, 6, -6, DAY_OF_WEEK_IN_MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekRollUpDownLeapYear\", 29, FEBRUARY, 2024, 6, -6, DAY_OF_WEEK, 29, FEBRUARY, 2024)\n+        );\n+    }\n+\n+    private static Stream<Arguments> calendarRollSource() {\n+        return Stream.of(\n+                Arguments.of(\"testMonthRollUpLeapYear\", 29, FEBRUARY, 2024, 1, MONTH, 29, MARCH, 2024),\n+                Arguments.of(\"testOneMonthRollDownLeapYear\", 31, MARCH, 2024, -1, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testTwoMonthDownEndOfMonthLeapYear\", 30, APRIL, 2024, -2, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testTwoMonthDownSameDateLeapYear\", 29, APRIL, 2024, -2, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testFourYearRollUpLeapYear\", 29, FEBRUARY, 2024, 4, YEAR, 29, FEBRUARY, 2028),\n+                Arguments.of(\"testTwelveMonthRollDownLeapYear\", 29, FEBRUARY, 2024, 12, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testYearRollUpLeapYear\", 29, FEBRUARY, 2024, 1, YEAR, 1, MARCH, 2025),\n+                Arguments.of(\"testYearRollDownLeapYear\", 29, FEBRUARY, 2024, -1, YEAR, 1, MARCH, 2023),\n+                Arguments.of(\"testDayOfYearRollDownLeapYear\", 29, FEBRUARY, 2024, -1, DAY_OF_YEAR, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfYearRollUpLeapYear\", 29, FEBRUARY, 2024, 1, DAY_OF_YEAR, 1, MARCH, 2024),\n+                Arguments.of(\"testDateRollDownLeapYear\", 29, FEBRUARY, 2024, -1, DATE, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testDateRollUpLeapYear\", 29, FEBRUARY, 2024, 1, DATE, 1, FEBRUARY, 2024),\n+                Arguments.of(\"testWeekOfYearRollUpLeapYear\", 29, FEBRUARY, 2024, 1, WEEK_OF_YEAR, 7, MARCH, 2024),\n+                Arguments.of(\"testWeekOfYearRollDownLeapYear\", 29, FEBRUARY, 2024, -1, WEEK_OF_YEAR, 22, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfMonthRollUpLeapYear\", 29, FEBRUARY, 2024, 1, DAY_OF_MONTH, 1, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfMonthRollDownLeapYear\", 29, FEBRUARY, 2024, -1, DAY_OF_MONTH, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekInMonthRollUpLeapYear\", 29, FEBRUARY, 2024, 1, DAY_OF_WEEK_IN_MONTH, 1, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekInMonthRollDownLeapYear\", 29, FEBRUARY, 2024, -1, DAY_OF_WEEK_IN_MONTH, 22, FEBRUARY, 2024),\n+                Arguments.of(\"testDayOfWeekRollUpLeapYear\", 29, FEBRUARY, 2024, 1, DAY_OF_WEEK, 1, MARCH, 2024),\n+                Arguments.of(\"testDayOfWeekRollDownLeapYear\", 29, FEBRUARY, 2024, -1, DAY_OF_WEEK, 28, FEBRUARY, 2024)\n+        );\n+    }\n+\n+    private static Stream<Arguments> calendarBooleanRollSource() {\n+        return Stream.of(\n+                Arguments.of(\"testBooleanMonthRollDownLeapYear\", 31, MARCH, 2024, false, MONTH, 29, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanMonthRollUpLeapYear\", 29, FEBRUARY, 2024, true, MONTH, 29, MARCH, 2024),\n+                Arguments.of(\"testBooleanYearRollUpLeapYear\", 29, FEBRUARY, 2024, true, YEAR, 1, MARCH, 2025),\n+                Arguments.of(\"testBooleanYearRollDownLeapYear\", 29, FEBRUARY, 2024, false, YEAR, 1, MARCH, 2023),\n+                Arguments.of(\"testBooleanDayOfYearRollDownLeapYear\", 29, FEBRUARY, 2024, false, DAY_OF_YEAR, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanDayOfYearRollUpLeapYear\", 29, FEBRUARY, 2024, true, DAY_OF_YEAR, 1, MARCH, 2024),\n+                Arguments.of(\"testBooleanDateRollDownLeapYear\", 29, FEBRUARY, 2024, false, DATE, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanDateRollUpLeapYear\", 29, FEBRUARY, 2024, true, DATE, 1, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanWeekOfYearRollUpLeapYear\", 29, FEBRUARY, 2024, true, WEEK_OF_YEAR, 7, MARCH, 2024),\n+                Arguments.of(\"testBooleanWeekOfYearRollDownLeapYear\", 29, FEBRUARY, 2024, false, WEEK_OF_YEAR, 22, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanDayOfMonthRollUpLeapYear\", 29, FEBRUARY, 2024, true, DAY_OF_MONTH, 1, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanDayOfMonthRollDownLeapYear\", 29, FEBRUARY, 2024, false, DAY_OF_MONTH, 28, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanDayOfWeekInMonthRollUpLeapYear\", 29, FEBRUARY, 2024, true, DAY_OF_WEEK_IN_MONTH, 1, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanDayOfWeekInMonthRollDownLeapYear\", 29, FEBRUARY, 2024, false, DAY_OF_WEEK_IN_MONTH, 22, FEBRUARY, 2024),\n+                Arguments.of(\"testBooleanDayOfWeekRollUpLeapYear\", 29, FEBRUARY, 2024, true, DAY_OF_WEEK, 1, MARCH, 2024),\n+                Arguments.of(\"testBooleanDayOfWeekRollDownLeapYear\", 29, FEBRUARY, 2024, false, DAY_OF_WEEK, 28, FEBRUARY, 2024)\n+        );\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarLeapYearRollTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-    static void checkPredicates(RandomGeneratorFactory factory) {\n+    static void checkPredicates(RandomGeneratorFactory<RandomGenerator> factory) {\n@@ -159,1 +159,1 @@\n-    static void coverFactory(RandomGeneratorFactory factory) {\n+    static void coverFactory(RandomGeneratorFactory<RandomGenerator> factory) {\n@@ -174,2 +174,28 @@\n-        coverRandomGenerator(factory.create(12345L));\n-        coverRandomGenerator(factory.create(new byte[] {1, 2, 3, 4, 5, 6, 7, 8}));\n+        \/\/ test create(long)\n+        switch (factory.name()) {\n+            \/\/ SecureRandom doesn't have long constructors so we expect\n+            \/\/ UnsupportedOperationException\n+            case \"SecureRandom\" -> {\n+                try {\n+                    factory.create(12345L);\n+                    throw new AssertionError(\"RandomGeneratorFactory.create(long) was expected\" +\n+                            \"to throw UnsupportedOperationException for \" + factory.name() + \" but didn't\");\n+                } catch (UnsupportedOperationException ignored) {\n+                }\n+            }\n+            default -> coverRandomGenerator(factory.create(12345L));\n+        }\n+        \/\/ test create(byte[])\n+        switch (factory.name()) {\n+            \/\/ these don't have byte[] constructors so we expect UnsupportedOperationException\n+            case \"Random\",\n+                 \"SplittableRandom\" -> {\n+                try {\n+                    factory.create(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n+                    throw new AssertionError(\"RandomGeneratorFactory.create(byte[]) was expected\" +\n+                            \"to throw UnsupportedOperationException for \" + factory.name() + \" but didn't\");\n+                } catch (UnsupportedOperationException ignored) {\n+                }\n+            }\n+            default -> coverRandomGenerator(factory.create(new byte[] {1, 2, 3, 4, 5, 6, 7, 8}));\n+        }\n@@ -191,1 +217,1 @@\n-                .filter(f -> f.isStreamable())\n+                .filter(RandomGeneratorFactory::isStreamable)\n@@ -196,1 +222,1 @@\n-                .filter(f -> f.isSplittable())\n+                .filter(RandomGeneratorFactory::isSplittable)\n@@ -201,1 +227,1 @@\n-                .filter(f -> f.isJumpable())\n+                .filter(RandomGeneratorFactory::isJumpable)\n@@ -206,1 +232,1 @@\n-                .filter(f -> f.isLeapable())\n+                .filter(RandomGeneratorFactory::isLeapable)\n@@ -211,1 +237,1 @@\n-                .filter(f -> f.isArbitrarilyJumpable())\n+                .filter(RandomGeneratorFactory::isArbitrarilyJumpable)\n@@ -215,0 +241,2 @@\n+        RandomGeneratorFactory.all()\n+                .forEach(RandomTestCoverage::checkPredicates);\n@@ -218,0 +246,1 @@\n+        coverDefaults();\n","filename":"test\/jdk\/java\/util\/Random\/RandomTestCoverage.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -202,0 +202,7 @@\n+    void checkCancellationException(CancellationException thrown, String message) {\n+        assertTrue(message.equals(thrown.getMessage()));\n+\n+        assertTrue(thrown.getCause() instanceof CancellationException);\n+        assertTrue(thrown.getCause().getCause() == null);\n+    }\n+\n@@ -208,0 +215,1 @@\n+            checkCancellationException(success, \"get\");\n@@ -214,1 +222,3 @@\n-        } catch (CancellationException success) {}\n+        } catch (CancellationException success) {\n+            checkCancellationException(success, \"join\");\n+        }\n@@ -218,1 +228,3 @@\n-        } catch (CancellationException success) {}\n+        } catch (CancellationException success) {\n+            checkCancellationException(success, \"getNow\");\n+        }\n@@ -223,0 +235,1 @@\n+            checkCancellationException(success, \"get\");\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/CompletableFutureTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -670,0 +670,1 @@\n+                \"SynchronousQueue20Test\",\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group and released to the public domain, as explained at\n+ * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n+ * Other contributors include Andrew Wright, Jeffrey Hayes,\n+ * Pat Fisher, Mike Judd.\n+ *\/\n+\n+import junit.framework.Test;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class SynchronousQueue20Test extends JSR166TestCase {\n+\n+    public static void main(String[] args) {\n+        main(suite(), args);\n+    }\n+\n+    public static Test suite() {\n+        return newTestSuite(SynchronousQueue20Test.class);\n+    }\n+\n+    public void testFairDoesntLeak() throws InterruptedException {\n+        assertDoesntLeak(new SynchronousQueue<>(true));\n+    }\n+\n+    public void testUnfairDoesntLeak() throws InterruptedException {\n+        assertDoesntLeak(new SynchronousQueue<>(false));\n+    }\n+\n+    private void assertDoesntLeak(SynchronousQueue<Object> queue) throws InterruptedException {\n+        final int NUMBER_OF_ITEMS = 250;\n+        final int ROUND_WAIT_MILLIS = 50;\n+\n+        class Item {}\n+        final Map<Item, Void> survivors =\n+                Collections.synchronizedMap(WeakHashMap.newWeakHashMap(NUMBER_OF_ITEMS));\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            for(int i = 0;i < NUMBER_OF_ITEMS;++i) {\n+                executor.submit(() -> {\n+                    var item = new Item();\n+                    survivors.put(item, null);\n+                    queue.put(item);\n+                    return null;\n+                });\n+\n+                executor.submit(() -> {\n+                    queue.take();\n+                    return null;\n+                });\n+            }\n+        } \/\/ Close waits until all tasks are done\n+\n+        while(!survivors.isEmpty()) {\n+            System.gc();\n+            Thread.sleep(ROUND_WAIT_MILLIS); \/\/ We don't expect interruptions\n+        }\n+\n+        assertTrue(queue.isEmpty()); \/\/ Make sure that the queue survives until the end\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SynchronousQueue20Test.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -655,1 +655,0 @@\n-\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SynchronousQueueTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-            err = errAccumulator.result();\n+            err = errAccumulator.result().replaceAll(\".* VM warning:.* deprecated.*\\\\R\", \"\");\n","filename":"test\/jdk\/java\/util\/logging\/LoggingDeadlock2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,0 +608,21 @@\n+    @Test\n+    public void testCharacteristicsForSortedUnorderedStreamSpliterators() {\n+        assertValidCombinationOfSortedAndOrdered(\n+            DoubleStream.of(3d,2d,4d,1d,5d).sorted().unordered().spliterator()\n+        );\n+        assertValidCombinationOfSortedAndOrdered(\n+            IntStream.of(3,2,4,1,5).sorted().unordered().spliterator()\n+        );\n+        assertValidCombinationOfSortedAndOrdered(\n+            LongStream.of(3L,2L,4L,1L,5L).sorted().unordered().spliterator()\n+        );\n+        assertValidCombinationOfSortedAndOrdered(\n+            Stream.of(3,2,4,1,5).sorted().unordered().spliterator()\n+        );\n+    }\n+\n+    void assertValidCombinationOfSortedAndOrdered(Spliterator<?> s) {\n+        if (s.hasCharacteristics(Spliterator.SORTED))\n+            Assert.assertTrue(s.hasCharacteristics(Spliterator.ORDERED));\n+    }\n+\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/StreamSpliteratorTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-        a.stderrShouldMatch(\"\\\\A\\\\Z\");\n+        a.stderrShouldMatchIgnoreDeprecatedWarnings(\"\\\\A\\\\Z\");\n","filename":"test\/jdk\/java\/util\/zip\/EntryCount64k.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,1 +276,1 @@\n-                        ? new InetSocketAddress(\"localhost\", serverPort)\n+                        ? new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort)\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.net.InetAddress;\n@@ -337,1 +338,1 @@\n-                sock.connect(new InetSocketAddress(\"localhost\", serverPort));\n+                sock.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+\n+import javax.sound.midi.MidiSystem;\n+import javax.sound.midi.Sequence;\n+import javax.sound.midi.Track;\n+\n+\/**\n+ * @test\n+ * @bug 8319598\n+ * @summary SMFParser bug with running status, interrupted by Meta or SysEx messages\n+ *\/\n+public class SMFInterruptedRunningStatus {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        byte[][] files = new byte[][] {SMF_1, SMF_2, SMF_3};\n+        for (int i = 0; i < files.length; i++) {\n+            Sequence seq = MidiSystem.getSequence(\n+                    new ByteArrayInputStream(files[i]));\n+            testSequence(seq, i + 1);\n+        }\n+\n+        \/\/ no exception thrown, all files have been parsed correctly\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    private static void testSequence(Sequence seq, int fileNumber) {\n+\n+        \/\/ check number of tracks and number of events\n+        Track[] tracks = seq.getTracks();\n+        if (1 != tracks.length) {\n+            throw new RuntimeException(\"file number \"\n+                    + fileNumber + \" fails (incorrect number of tracks: \"\n+                    + tracks.length + \")\");\n+        }\n+        Track track = tracks[0];\n+        if (7 != track.size()) {\n+            throw new RuntimeException(\"file number \" + fileNumber\n+                    + \" fails (incorrect number of events: \"\n+                    + track.size() + \")\");\n+        }\n+\n+        \/\/ check status byte of each message\n+        int[] expectedStatusBytes = new int[] {\n+                0x90, 0xFF, 0x90, 0x90, 0x90, 0xFF, 0xFF};\n+        for (int i = 0; i < expectedStatusBytes.length; i++) {\n+            int expected = expectedStatusBytes[i];\n+            if (expected != track.get(i).getMessage().getStatus()) {\n+                throw new RuntimeException(\"file number \" + fileNumber\n+                        + \" fails (wrong status byte in event \" + i + \")\");\n+            }\n+        }\n+    }\n+\n+    \/\/ MIDI file without running status - should work equally before\n+    \/\/ and after the bugfix\n+    private static final byte[] SMF_1 = {\n+        0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06,  \/\/ file header (start)\n+        0x00, 0x01, 0x00, 0x01, 0x00, (byte) 0x80,       \/\/ file header (end)\n+        0x4D, 0x54, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x24,  \/\/ track header\n+        0x00,                                            \/\/ delta time\n+        (byte) 0x90, 0x3C, 0x7F,                         \/\/ Note-ON (C)\n+        0x40,                                            \/\/ delta time\n+        (byte) 0xFF, 0x01, 0x04, 0x54, 0x65, 0x73, 0x74, \/\/ META (text)\n+        0x20,                                            \/\/ delta time\n+        (byte) 0x90, 0x3C, 0x00,                         \/\/ Note-OFF (C)\n+        0x20,                                            \/\/ delta time\n+        (byte) 0x90, 0x3E, 0x7F,                         \/\/ Note-ON (D)\n+        0x60,                                            \/\/ delta time\n+        (byte) 0x90, 0x3E, 0x00,                         \/\/ Note-OFF (D)\n+        0x20,                                            \/\/ delta time\n+        (byte) 0xFF, 0x01, 0x04, 0x54, 0x65, 0x73, 0x74, \/\/ META (text)\n+        0x00,                                            \/\/ delta time\n+        (byte) 0xFF, 0x2F, 0x00                          \/\/ META (end of track)\n+    };\n+\n+    \/\/ MIDI file with running status, interrupted by a META message\n+    \/\/ - failed before the bugfix\n+    private static final byte[] SMF_2 = {\n+        0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06,  \/\/ file header (start)\n+        0x00, 0x01, 0x00, 0x01, 0x00, (byte) 0x80,       \/\/ file header (end)\n+        0x4D, 0x54, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x21,  \/\/ track header\n+        0x00,                                            \/\/ delta time\n+        (byte) 0x90, 0x3C, 0x7F,                         \/\/ Note-ON (C)\n+        0x40,                                            \/\/ delta time\n+        (byte) 0xFF, 0x01, 0x04, 0x54, 0x65, 0x73, 0x74, \/\/ META (interruptor)\n+        0x20,                                            \/\/ delta time\n+        0x3C, 0x00,                                      \/\/ Note-OFF (C) - running status\n+        0x20,                                            \/\/ delta time\n+        0x3E, 0x7F,                                      \/\/ Note-ON (D) - running status\n+        0x60,                                            \/\/ delta time\n+        0x3E, 0x00,                                      \/\/ Note-OFF (D) - running status\n+        0x20,                                            \/\/ delta time\n+        (byte) 0xFF, 0x01, 0x04, 0x54, 0x65, 0x73, 0x74, \/\/ META (text)\n+        0x00,                                            \/\/ delta time\n+        (byte) 0xFF, 0x2F, 0x00                          \/\/ META (end of track)\n+    };\n+\n+    \/\/ MIDI file with running status, interrupted by a META message\n+    \/\/ - succeeded before the bugfix but with wrong interpretation of the data\n+    private static final byte[] SMF_3 = {\n+        0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06,  \/\/ file header (start)\n+        0x00, 0x01, 0x00, 0x01, 0x00, (byte) 0x80,       \/\/ file header (end)\n+        0x4D, 0x54, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x21,  \/\/ track header\n+        0x00,                                            \/\/ delta time\n+        (byte) 0x90, 0x3C, 0x7F,                         \/\/ Note-ON (C)\n+        0x40,                                            \/\/ delta time\n+        (byte) 0xFF, 0x01, 0x04, 0x54, 0x65, 0x73, 0x74, \/\/ META (interruptor)\n+        0x20,                                            \/\/ delta time\n+        0x3C, 0x00,                                      \/\/ Note-OFF (C) - running status\n+        0x0D,                                            \/\/ delta time\n+        0x3E, 0x7F,                                      \/\/ Note-ON (D) - running status\n+        0x60,                                            \/\/ delta time\n+        0x3E, 0x00,                                      \/\/ Note-OFF (D) - running status\n+        0x20,                                            \/\/ delta time\n+        (byte) 0xFF, 0x01, 0x04, 0x54, 0x65, 0x73, 0x74, \/\/ META (text)\n+        0x00,                                            \/\/ delta time\n+        (byte) 0xFF, 0x2F, 0x00                          \/\/ META (end of track)\n+    };\n+}\n+\n","filename":"test\/jdk\/javax\/sound\/midi\/File\/SMFInterruptedRunningStatus.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -56,2 +56,2 @@\n-                .rows(12)\n-                .columns(42)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(48)\n@@ -68,1 +68,0 @@\n-\n@@ -70,3 +69,5 @@\n-        frame.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);\n-        frame.setLocale(Locale.ENGLISH);\n-        frame.setLayout(new BorderLayout());\n+\n+        frame.getContentPane().setComponentOrientation(\n+                               ComponentOrientation.RIGHT_TO_LEFT);\n+        frame.getContentPane().setLocale(Locale.ENGLISH);\n+        frame.getContentPane().setLayout(new BorderLayout());\n","filename":"test\/jdk\/javax\/swing\/JFrame\/bug4419914.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 4211731 4214512\n+ * @summary\n+ *     This test checks if menu bars lay out correctly when their\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT. This test is\n+ *     manual.  The tester is asked to compare left-to-right and\n+ *     right-to-left menu bars and judge whether they are mirror images of each\n+ *     other.\n+ * @library \/test\/jdk\/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RightLeftOrientation\n+ *\/\n+\n+import java.awt.ComponentOrientation;\n+import java.awt.Point;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.ButtonGroup;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JPanel;\n+import javax.swing.JRadioButton;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class RightLeftOrientation {\n+\n+    static JFrame ltrFrame;\n+    static JFrame rtlFrame;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        This test checks menu bars for correct Right-To-Left Component Orientation.\n+\n+        You should see two frames, each containing a menu bar.\n+\n+        One frame will be labelled \"Left To Right\" and will contain\n+        a menu bar with menus starting on its left side.\n+        The other frame will be labelled \"Right To Left\" and will\n+        contain a menu bar with menus starting on its right side.\n+\n+        The test will also contain radio buttons that can be used to set\n+        the look and feel of the menu bars.\n+        For each look and feel, you should compare the two menu\n+        bars and make sure they are mirror images of each other. \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                 .title(\"RTL test Instructions\")\n+                 .instructions(INSTRUCTIONS)\n+                 .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                 .columns(30)\n+                 .testUI(RightLeftOrientation::createTestUI)\n+                 .build()\n+                 .awaitAndCheck();\n+    }\n+\n+    private static JFrame createTestUI() {\n+        JFrame frame = new JFrame(\"RightLeftOrientation\");\n+        JPanel panel = new JPanel();\n+\n+        ButtonGroup group = new ButtonGroup();\n+        JRadioButton rb;\n+        ActionListener plafChanger = new PlafChanger();\n+\n+        UIManager.LookAndFeelInfo[] lafInfos = UIManager.getInstalledLookAndFeels();\n+        for (int i = 0; i < lafInfos.length; i++) {\n+            rb = new JRadioButton(lafInfos[i].getName());\n+            rb.setActionCommand(lafInfos[i].getClassName());\n+            rb.addActionListener(plafChanger);\n+            group.add(rb);\n+            panel.add(rb);\n+            if (i == 0) {\n+                rb.setSelected(true);\n+            }\n+        }\n+\n+        frame.add(panel);\n+\n+        ltrFrame = new JFrame(\"Left To Right\");\n+        ltrFrame.setJMenuBar(createMenuBar(ComponentOrientation.LEFT_TO_RIGHT));\n+        ltrFrame.setSize(400, 100);\n+        ltrFrame.setLocation(new Point(10, 10));\n+        ltrFrame.setVisible(true);\n+\n+        rtlFrame = new JFrame(\"Right To Left\");\n+        rtlFrame.setJMenuBar(createMenuBar(ComponentOrientation.RIGHT_TO_LEFT));\n+        rtlFrame.setSize(400, 100);\n+        rtlFrame.setLocation(new Point(10, 120));\n+        rtlFrame.setVisible(true);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    static class PlafChanger implements ActionListener {\n+        public void actionPerformed(ActionEvent e) {\n+            String lnfName = e.getActionCommand();\n+\n+            try {\n+                UIManager.setLookAndFeel(lnfName);\n+                SwingUtilities.updateComponentTreeUI(ltrFrame);\n+                SwingUtilities.updateComponentTreeUI(rtlFrame);\n+            }\n+            catch (Exception exc) {\n+                System.err.println(\"Could not load LookAndFeel: \" + lnfName);\n+            }\n+\n+        }\n+    }\n+\n+\n+    static JMenuBar createMenuBar(ComponentOrientation o) {\n+        JMenuBar menuBar = new JMenuBar();\n+        menuBar.setComponentOrientation(o);\n+\n+        JMenu menu = new JMenu(\"One\");\n+        menu.setComponentOrientation(o);\n+        menuBar.add(menu);\n+\n+        menu = new JMenu(\"Two\");\n+        menu.setComponentOrientation(o);\n+        menuBar.add(menu);\n+\n+        menu = new JMenu(\"Three\");\n+        menu.setComponentOrientation(o);\n+        menuBar.add(menu);\n+\n+        return menuBar;\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/RightLeftOrientation.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,4 @@\n+            } else if (laf.getClassName().contains(\"GTK\")) {\n+                System.out.println(\"GTK doesn't support color setting explicitly\" +\n+                        \" specified by user using UIManager property.\");\n+                continue;\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/4314194\/bug4314194.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.GridLayout;\n+import javax.swing.AbstractAction;\n+import javax.swing.AbstractButton;\n+import javax.swing.JButton;\n+import javax.swing.JCheckBox;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JTabbedPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\/*\n+ * @test\n+ * @bug 4690946 8226990 6462396\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"windows\" | os.family == \"linux\")\n+ * @summary Test JTabbedPane's contentarea, tab area and tab color\n+ *          for different LAFs when opacity is enabled or disabled.\n+ * @run main\/manual TestJTabbedPaneOpaqueColor\n+ *\/\n+\n+public class TestJTabbedPaneOpaqueColor {\n+    private static JFrame frame;\n+    private static JTabbedPane tabPane;\n+    private static final String INSTRUCTIONS = \"\"\"\n+            The background color of panel which contains the tabbed pane is green.\n+            The background color of the tabbed pane is red.\n+            The TabbedPane is not opaque initially.\n+            For 'Content Opaque' and 'Tabs Opaque' to have effect, tab pane opacity should\n+            be set to false i.e. Opaque checkbox should be unchecked.\n+            NOTE: For Nimbus LAF, tabs color are specific to nimbus style.\n+\n+            Check the default behaviour of the tabbed pane:\n+              - the area behind tabs is transparent (it must be green).\n+              - the tabs area is opaque (it must be red, except the selected tab which must be gray).\n+              - the content area is opaque (it must be gray).\n+\n+            Test Case 1 - Test TabPane Opacity:\n+            NOTE: For Nimbus LAF, tabs color are always gray in color.\n+\n+            Verify the following with 'opaque' option:\n+            when checked:\n+              - the area behind tabs is opaque (it must be red).\n+              - the tabs area is opaque (it must be red, except the selected tab which must be gray).\n+              - the content area is opaque (it must be gray).\n+            when unchecked:\n+              - the area behind tabs is transparent (it must be green).\n+              - the tabs area is opaque (it must be red, except the selected tab which must be gray).\n+              - the content area is opaque (it must be gray).\n+\n+            Check this behaviour by clicking on present L&F button and tab layout.\n+\n+            Test Case 2 - Test Content pane opacity:\n+            To test Content pane opacity, make sure \"Opaque checkbox\" is UNCHECKED.\n+\n+            Verify the following with 'content opaque' option:\n+            when checked:\n+              - the content area should be opaque (it must be gray).\n+            when unchecked:\n+              - the content area should be transparent (it must be green).\n+\n+            Check this behaviour by clicking on present L&F button and tab layout.\n+\n+            Test Case 3 - Test Tabs opacity:\n+            To test Tabs opacity, make sure \"Opaque checkbox\" is UNCHECKED.\n+            NOTE: For Nimbus LAF, tabs color are specific to nimbus style.\n+                  All tabs are gray in color if tabs opaque is checked.\n+\n+            Verify the following with 'tabs opaque' option:\n+            when checked:\n+              - the tabs are opaque (it must be red, except the selected tab which must be gray).\n+            when unchecked:\n+              - the tabs are transparent (it must be green).\n+\n+            Check this behaviour by clicking on present L&F button and tab layout.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+            .title(\"JTabbedPane Tab and Content Area Color Test Instructions\")\n+            .instructions(INSTRUCTIONS)\n+            .testTimeOut(10)\n+            .rows(25)\n+            .columns(60)\n+            .testUI(TestJTabbedPaneOpaqueColor::createAndShowUI)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    private static JFrame createAndShowUI() {\n+        int NUM_TABS = 15;\n+        frame = new JFrame(\"Test JTabbedPane Opaque Color\");\n+        JTabbedPane tabPane = new JTabbedPane();\n+        tabPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n+        tabPane.setTabPlacement(JTabbedPane.TOP);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        for (int i = 0; i < NUM_TABS; ++i) {\n+            tabPane.addTab(\"Tab \" + i , new JLabel(\"Content Area\"));\n+        }\n+        JPanel panel = new JPanel(new BorderLayout());\n+        panel.add(tabPane, BorderLayout.CENTER);\n+        panel.setBackground(Color.green);\n+        tabPane.setBackground(Color.red);\n+\n+        UIManager.LookAndFeelInfo[] laf = UIManager.getInstalledLookAndFeels();\n+        JPanel lafButtonPanel = new JPanel(new GridLayout(1, 3));\n+        for (int i = 0; i < laf.length; ++i) {\n+            if (laf[i].getName().contains(\"Motif\")\n+                || laf[i].getName().contains(\"Windows\")) {\n+                continue;\n+            }\n+            JButton button = new JButton(laf[i].getName());\n+            button.setText(laf[i].getName());\n+            button.addActionListener(new MyAction());\n+            lafButtonPanel.add(button);\n+        }\n+\n+        JButton scrollButton = new JButton(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n+            }\n+        });\n+        scrollButton.setText(\"SCROLL layout\");\n+\n+        JPanel layoutButtonPanel = new JPanel(new GridLayout(1, 2));\n+        JButton wrapButton = new JButton(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setTabLayoutPolicy(JTabbedPane.WRAP_TAB_LAYOUT);\n+            }\n+        });\n+        wrapButton.setText(\"WRAP layout\");\n+\n+        layoutButtonPanel.add(scrollButton);\n+        layoutButtonPanel.add(wrapButton);\n+\n+        JCheckBox contentOpaqueChkBox = new JCheckBox(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                if (((AbstractButton)e.getSource()).isSelected()) {\n+                    UIManager.put(\"TabbedPane.contentOpaque\", Boolean.TRUE);\n+                } else {\n+                    UIManager.put(\"TabbedPane.contentOpaque\", Boolean.FALSE);\n+                }\n+                tabPane.repaint();\n+                SwingUtilities.updateComponentTreeUI(frame);\n+            }\n+        });\n+        contentOpaqueChkBox.setText(\"Content Opaque\");\n+        contentOpaqueChkBox.setSelected(true);\n+        contentOpaqueChkBox.setEnabled(true);\n+\n+        JCheckBox tabOpaqueChkBox = new JCheckBox(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                if (((AbstractButton)e.getSource()).isSelected()) {\n+                    UIManager.put(\"TabbedPane.tabsOpaque\", Boolean.TRUE);\n+                } else {\n+                    UIManager.put(\"TabbedPane.tabsOpaque\", Boolean.FALSE);\n+                }\n+                tabPane.repaint();\n+                SwingUtilities.updateComponentTreeUI(frame);\n+            }\n+        });\n+        tabOpaqueChkBox.setText(\"Tabs Opaque\");\n+        tabOpaqueChkBox.setSelected(true);\n+        tabOpaqueChkBox.setEnabled(true);\n+\n+        JCheckBox tabPaneOpaqueChkBox = new JCheckBox(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setOpaque(((AbstractButton)e.getSource()).isSelected());\n+                contentOpaqueChkBox.setEnabled(!((AbstractButton)e.getSource()).isSelected());\n+                tabOpaqueChkBox.setEnabled(!((AbstractButton)e.getSource()).isSelected());\n+                tabPane.repaint();\n+                SwingUtilities.updateComponentTreeUI(frame);\n+            }\n+        });\n+        tabPaneOpaqueChkBox.setText(\"Opaque\");\n+\n+        JPanel checkBoxPanel = new JPanel();\n+        checkBoxPanel.add(tabPaneOpaqueChkBox);\n+        checkBoxPanel.add(contentOpaqueChkBox);\n+        checkBoxPanel.add(tabOpaqueChkBox);\n+\n+        JPanel nestedPanels = new JPanel(new GridLayout(2, 1));\n+        nestedPanels.add(lafButtonPanel);\n+        nestedPanels.add(layoutButtonPanel);\n+        panel.add(checkBoxPanel, BorderLayout.NORTH);\n+        panel.add(nestedPanels, BorderLayout.SOUTH);\n+        frame.add(panel);\n+        frame.setSize(500, 500);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+        return frame;\n+    }\n+\n+    public static class MyAction implements ActionListener {\n+        public void actionPerformed(ActionEvent ae) {\n+            String lafClassName = null;\n+            UIManager.LookAndFeelInfo lafs[] = UIManager.getInstalledLookAndFeels();\n+            for (int i = 0; i < lafs.length; i++) {\n+                if (ae.getActionCommand().equals(lafs[i].getName())) {\n+                    lafClassName = lafs[i].getClassName();\n+                    break;\n+                }\n+            }\n+            try {\n+                UIManager.setLookAndFeel(lafClassName);\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+                createAndShowUI();\n+            } catch (UnsupportedLookAndFeelException ignored) {\n+                System.out.println(\"Unsupported LAF: \" + lafClassName);\n+            } catch (ClassNotFoundException | InstantiationException\n+                     | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/TestJTabbedPaneOpaqueColor.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.swing.SwingUtilities;\n@@ -37,1 +36,0 @@\n-import javax.swing.table.TableCellRenderer;\n@@ -52,46 +50,1 @@\n-    static JFrame frame;\n-    public static PassFailJFrame passFailJFrame;\n-\n-    static void initTest() throws Exception {\n-        final String INSTRUCTIONS = \"\"\"\n-                Instructions to Test:\n-                1. Refer the below keyboard navigation specs\n-                 (referenced from bug report 4112270).\n-                2. Check all combinations of navigational keys in all four modes\n-                  shift and control verifying each change to the selection against\n-                  the spec. If it does, press \"pass\", otherwise press \"fail\".\n-\n-                  Navigate In - Tab, shift-tab, control-tab, shift-control-tab\n-                  Return\/shift-return - move focus one cell down\/up.\n-                  Tab\/shift-tab - move focus one cell right\/left.\n-                  Up\/down arrow - deselect current selection; move focus one cell up\/down\n-                  Left\/right arrow - deselect current selection; move focus one cell\n-                                             left\/right\n-                  PageUp\/PageDown - deselect current selection; scroll up\/down one\n-                                    JViewport view; first visible cell in current\n-                                    column gets focus\n-                  Control-PageUp\/PageDown - deselect current selection; scroll\n-                                            left\/right one JViewport view; first\n-                                            visible cell in current row gets\n-                                            focus\n-                  Home\/end - deselect current selection; move focus and view to\n-                                     first\/last cell in current row\n-                  Control-home\/end - deselect current selection; move focus and view to\n-                                             upper-left\/lower-right cell in table\n-                  F2 - Allows editing in a cell containing information without\n-                               overwriting the information\n-                  Esc - Resets the cell content back to the state it was in before\n-                                editing started\n-                  Ctrl+A, Ctrl+\/ = Select all\n-                  Ctrl+\\\\ = De-select all\n-                  Shift-up\/down arrow - extend selection up\/down one row\n-                  Shift-left\/right arrow - extend selection left\/right one column\n-                  Control-shift up\/down arrow - extend selection to top\/bottom of column\n-                  Shift-home\/end - extend selection to left\/right end of row\n-                  Control-shift-home\/end - extend selection to beginning\/end of data\n-                  Shift-PageUp\/PageDown - extend selection up\/down one view and scroll\n-                                          table\n-                  Control-shift-PageUp\/PageDown - extend selection left\/right one view\n-                                                          and scroll table\n-                \"\"\";\n-\n+    static JFrame initTest() {\n@@ -124,6 +77,1 @@\n-        frame = new JFrame(\"JTable Keyboard Navigation Test\");\n-        passFailJFrame = new PassFailJFrame(\"Test Instructions\",\n-                INSTRUCTIONS, 5L, 15, 50);\n-\n-        PassFailJFrame.addTestWindow(frame);\n-        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.VERTICAL);\n+        JFrame frame = new JFrame(\"JTable Keyboard Navigation Test\");\n@@ -154,3 +102,3 @@\n-        TableCellRenderer headerRenderer = colorColumn.getHeaderRenderer();\n-        if (headerRenderer instanceof DefaultTableCellRenderer)\n-            ((DefaultTableCellRenderer) headerRenderer).setToolTipText(\"Hi Mom!\");\n+        if (colorColumn.getHeaderRenderer() instanceof DefaultTableCellRenderer headerRenderer) {\n+            headerRenderer.setToolTipText(\"Hi Mom!\");\n+        }\n@@ -166,1 +114,1 @@\n-                int cellValue = (value instanceof Number) ? ((Number) value).intValue() : 0;\n+                int cellValue = (value instanceof Number number) ? number.intValue() : 0;\n@@ -175,0 +123,1 @@\n+        tableView.setColumnSelectionAllowed(true);\n@@ -181,1 +130,1 @@\n-        frame.setVisible(true);\n+        return frame;\n@@ -227,8 +176,123 @@\n-        SwingUtilities.invokeAndWait(() -> {\n-            try {\n-                initTest();\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-        passFailJFrame.awaitAndCheck();\n+        String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. Refer the below keyboard navigation specs\n+                 (referenced from bug report 4112270).\n+                2. Check all combinations of navigational keys mentioned below\n+                 and verifying each key combinations against the spec defined.\n+                 If it does, press \"pass\", otherwise press \"fail\".\n+\n+                \"\"\";\n+\n+        INSTRUCTIONS += getOSSpecificInstructions();\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows(30)\n+                .columns(50)\n+                .testUI(KeyBoardNavigation::initTest)\n+                .testTimeOut(10)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static String getOSSpecificInstructions() {\n+        final String WINDOWS_SPECIFIC = \"\"\"\n+                Tab, Shift-Tab - Navigate In.\n+                Return\/Shift-Return - Move focus one cell down\/up.\n+                Tab\/Shift-Tab -  Move focus one cell right\/left.\n+                Up\/Down Arrow - Deselect current selection; move focus one\n+                                cell up\/down\n+                Left\/Right Arrow - Deselect current selection; move focus\n+                                   one cell left\/right\n+                PageUp\/PageDown - Deselect current selection; scroll up\/down\n+                                  one JViewport view; first visible cell in\n+                                  current column gets focus\n+                Control-PageUp\/PageDown - Deselect current selection;\n+                                          move focus and view to\n+                                          first\/last cell in current row\n+                Home\/End - Deselect current selection; move focus and view to\n+                           first\/last cell in current row\n+                Control-Home\/End - Deselect current selection;\n+                                   scroll up\/down one  JViewport view;\n+                                   first\/last visible row of the table\n+                F2 - Allows editing in a cell containing information without\n+                     overwriting the information\n+                Esc -  Resets the cell content back to the state it was in\n+                       before editing started\n+                Ctrl+A, Ctrl+\/ - Select All\n+                Ctrl+\\\\ - Deselect all\n+                Shift-Up\/Down Arrow -  Extend selection up\/down one row\n+                Shift-Left\/Right Arrow - Extend selection left\/right one\n+                                         column\n+                Control-shift Up\/Down Arrow -  Extend selection to top\/bottom\n+                                                of column\n+                Shift-Home\/End -  Extend selection to left\/right end of row\n+                Control-Shift-Home\/End  - Extend selection to beginning\/end\n+                                          of data\n+                Shift-PageUp\/PageDown - Extend selection up\/down one view\n+                                        and scroll table\n+                Control-Shift-PageUp\/PageDown - Extend selection left\/right\n+                                                end of row\n+                \"\"\";\n+\n+        final String LINUX_SPECIFIC = \"\"\"\n+                Tab, Shift-Tab - Navigate In.\n+                Return\/Shift-Return - Move focus one cell down\/up.\n+                Tab\/Shift-Tab -  Move focus one cell right\/left.\n+                Up\/Down Arrow - Deselect current selection;\n+                                move focus one cell up\/down\n+                Left\/Right Arrow - Deselect current selection;\n+                                   move focus one cell left\/right\n+                PageUp\/PageDown - Deselect current selection;\n+                                  scroll up\/down one  JViewport view;\n+                                  first visible cell in current column gets focus\n+                Home\/End - Deselect current selection; move focus and view to\n+                                     first\/last cell in current row\n+                F2 - Allows editing in a cell containing information without\n+                     overwriting the information\n+                Esc -  Resets the cell content back to the state it was in\n+                       before editing started\n+                Ctrl+A, Ctrl+\/ - Select All\n+                Ctrl+\\\\ - Deselect all\n+                Shift-Up\/Down Arrow -  Extend selection up\/down one row\n+                Shift-Left\/Right Arrow - Extend selection left\/right one column\n+                Control-Shift Up\/Down Arrow -  Extend selection to top\/bottom of\n+                                               column\n+                Shift-Home\/End -  Extend selection to left\/right end of row\n+                Shift-PageUp\/PageDown - Extend selection up\/down one view and\n+                                        scroll  table\n+                \"\"\";\n+\n+        final String MAC_SPECIFIC = \"\"\"\n+                Tab, Shift-Tab - Navigate In.\n+                Return\/Shift-Return - Move focus one cell down\/up.\n+                Tab\/Shift-Tab -  Move focus one cell right\/left.\n+                Up\/Down Arrow - Deselect current selection; move focus one cell\n+                                up\/down\n+                Left\/Right Arrow - Deselect current selection;\n+                                   move focus one cell left\/right\n+                FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                                   scroll up\/down one JViewport view;\n+                                   first visible cell in current column gets focus\n+                Control-FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                                                    move focus and view to\n+                                                    first\/last cell in current row\n+                F2 - Allows editing in a cell containing information without\n+                     overwriting the information\n+                Esc -  Resets the cell content back to the state it was in\n+                       before editing started\n+                Ctrl+A, Ctrl+\/ - Select All\n+                Ctrl+\\\\ - Deselect all\n+                Shift-Up\/Down Arrow -  Extend selection up\/down one row\n+                Shift-Left\/Right Arrow - Extend selection left\/right one column\n+                FN-Shift Up\/Down Arrow -  Extend selection to top\/bottom of column\n+                Shift-PageUp\/PageDown - Extend selection up\/down one view and scroll\n+                                        table\n+                                \"\"\";\n+        String osName = System.getProperty(\"os.name\").toLowerCase();\n+        if (osName.startsWith(\"mac\")) {\n+            return MAC_SPECIFIC;\n+        } else if (osName.startsWith(\"win\")) {\n+            return WINDOWS_SPECIFIC;\n+        } else {\n+            return LINUX_SPECIFIC;\n+        }\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation.java","additions":131,"deletions":67,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 4214514\n+ * @summary\n+ *     This test checks if tool bars lay out correctly when their\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT. This test is\n+ *     manual.  The tester is asked to compare left-to-right and\n+ *     right-to-left tool bars and judge whether they are mirror images of each\n+ *     other.\n+ * @library \/test\/jdk\/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual RightLeftOrientation\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.ComponentOrientation;\n+import java.awt.Container;\n+import java.awt.Point;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.ButtonGroup;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JRadioButton;\n+import javax.swing.JToolBar;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class RightLeftOrientation {\n+\n+    static JFrame ltrFrame;\n+    static JFrame rtlFrame;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        This test checks tool bars for correct Right-To-Left Component Orientation.\n+\n+        You should see two frames, each containing a tool bar.\n+\n+        One frame will be labelled \"Left To Right\" and will contain\n+        a tool bar with buttons starting on its left side.\n+        The other frame will be labelled \"Right To Left\" and will\n+        contain a tool bar with buttons starting on its right side.\n+\n+        The test will also contain radio buttons that can be used to set\n+        the look and feel of the tool bars.\n+        For each look and feel, you should compare the two tool bars and\n+        make sure they are mirror images of each other.\n+        You should also drag the tool bars to each corner of the frame\n+        to make sure the docking behavior is consistent between the two frames.\"\"\";\n+\n+     public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                 .title(\"RTL test Instructions\")\n+                 .instructions(INSTRUCTIONS)\n+                 .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                 .columns(35)\n+                 .testUI(RightLeftOrientation::createTestUI)\n+                 .build()\n+                 .awaitAndCheck();\n+    }\n+\n+    private static JFrame createTestUI() {\n+        JFrame frame = new JFrame(\"RightLeftOrientation\");\n+        JPanel panel = new JPanel();\n+\n+        ButtonGroup group = new ButtonGroup();\n+        JRadioButton rb;\n+        ActionListener plafChanger = new PlafChanger();\n+\n+        UIManager.LookAndFeelInfo[] lafInfos = UIManager.getInstalledLookAndFeels();\n+        for (int i = 0; i < lafInfos.length; i++) {\n+            rb = new JRadioButton(lafInfos[i].getName());\n+            rb.setActionCommand(lafInfos[i].getClassName());\n+            rb.addActionListener(plafChanger);\n+            group.add(rb);\n+            panel.add(rb);\n+            if (i == 0) {\n+                rb.setSelected(true);\n+            }\n+        }\n+\n+        frame.add(panel);\n+\n+        ltrFrame = new JFrame(\"Left To Right\");\n+        Container contentPane = ltrFrame.getContentPane();\n+        contentPane.setLayout(new BorderLayout());\n+        panel = new JPanel();\n+        panel.setBackground(Color.white);\n+        contentPane.add(\"Center\",panel);\n+        contentPane.add(\"North\",\n+                        createToolBar(ComponentOrientation.LEFT_TO_RIGHT));\n+        ltrFrame.setSize(400, 140);\n+        ltrFrame.setLocation(new Point(10, 10));\n+        ltrFrame.setVisible(true);\n+\n+        rtlFrame = new JFrame(\"Right To Left\");\n+        contentPane = rtlFrame.getContentPane();\n+        contentPane.setLayout(new BorderLayout());\n+        panel = new JPanel();\n+        panel.setBackground(Color.white);\n+        contentPane.add(\"Center\",panel);\n+        contentPane.add(\"North\",\n+                        createToolBar(ComponentOrientation.RIGHT_TO_LEFT));\n+        rtlFrame.setSize(400, 140);\n+        rtlFrame.setLocation(new Point(420, 10));\n+        rtlFrame.setVisible(true);\n+\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    static class PlafChanger implements ActionListener {\n+        public void actionPerformed(ActionEvent e) {\n+            String lnfName = e.getActionCommand();\n+\n+            try {\n+                UIManager.setLookAndFeel(lnfName);\n+                SwingUtilities.updateComponentTreeUI(ltrFrame);\n+                SwingUtilities.updateComponentTreeUI(rtlFrame);\n+            }\n+            catch (Exception exc) {\n+                System.err.println(\"Could not load LookAndFeel: \" + lnfName);\n+            }\n+\n+        }\n+    }\n+\n+\n+    static JToolBar createToolBar(ComponentOrientation o) {\n+        JToolBar toolBar = new JToolBar();\n+        toolBar.setComponentOrientation(o);\n+\n+        JButton button = new JButton(\"One\");\n+        button.setComponentOrientation(o);\n+        toolBar.add(button);\n+\n+        button = new JButton(\"Two\");\n+        button.setComponentOrientation(o);\n+        toolBar.add(button);\n+\n+        button = new JButton(\"Three\");\n+        button.setComponentOrientation(o);\n+        toolBar.add(button);\n+\n+        return toolBar;\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JToolBar\/RightLeftOrientation.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+ * @requires os.family == \"windows\"\n@@ -166,1 +167,1 @@\n-            if (count > 0) {\n+            if (count > loaderCount.size() \/ 2) {\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/LoaderThreadCount.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import javax.imageio.ImageIO;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.plaf.nimbus.NimbusLookAndFeel;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/*\n+ * @test\n+ * @bug 4248210\n+ * @key headful\n+ * @summary Tests that HTML in JLabel is painted using LAF-defined\n+            foreground color\n+ * @run main bug4248210\n+ *\/\n+\n+public class bug4248210 {\n+    private static final Color labelColor = Color.red;\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            if (!(laf.getName().contains(\"Motif\") || laf.getName().contains(\"GTK\"))) {\n+                System.out.println(\"Testing LAF: \" + laf.getName());\n+                SwingUtilities.invokeAndWait(() -> test(laf));\n+            }\n+        }\n+    }\n+\n+    private static void test(UIManager.LookAndFeelInfo laf) {\n+        setLookAndFeel(laf);\n+        if (UIManager.getLookAndFeel() instanceof NimbusLookAndFeel) {\n+            \/\/ reset \"basic\" properties\n+            UIManager.getDefaults().put(\"Label.foreground\", null);\n+            \/\/ set \"synth - nimbus\" properties\n+            UIManager.getDefaults().put(\"Label[Enabled].textForeground\", labelColor);\n+        } else {\n+            \/\/ reset \"synth - nimbus\" properties\n+            UIManager.getDefaults().put(\"Label[Enabled].textForeground\", null);\n+            \/\/ set \"basic\" properties\n+            UIManager.getDefaults().put(\"Label.foreground\", labelColor);\n+        }\n+\n+        JLabel label = new JLabel(\"<html><body>Can You Read This?<\/body><\/html>\");\n+        label.setSize(150, 30);\n+\n+        BufferedImage img = paintToImage(label);\n+        if (!chkImgForegroundColor(img)) {\n+            try {\n+                ImageIO.write(img, \"png\", new File(\"Label_\" + laf.getName() + \".png\"));\n+            } catch (IOException ignored) {}\n+            throw new RuntimeException(\"JLabel not painted with LAF defined \" +\n+                    \"foreground color\");\n+        }\n+        System.out.println(\"Test Passed\");\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static BufferedImage paintToImage(JComponent content) {\n+        BufferedImage im = new BufferedImage(content.getWidth(), content.getHeight(),\n+                TYPE_INT_RGB);\n+        Graphics2D g = (Graphics2D) im.getGraphics();\n+        g.setBackground(Color.WHITE);\n+        g.clearRect(0, 0, content.getWidth(), content.getHeight());\n+        content.paint(g);\n+        g.dispose();\n+        return im;\n+    }\n+\n+    private static boolean chkImgForegroundColor(BufferedImage img) {\n+        for (int x = 0; x < img.getWidth(); ++x) {\n+            for (int y = 0; y < img.getHeight(); ++y) {\n+                if (img.getRGB(x, y) == labelColor.getRGB()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicHTML\/bug4248210.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -98,1 +98,1 @@\n-                    codeB.constantInstruction(i.opcode(), val);\n+                    codeB.loadConstant(i.opcode(), val);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                                    codeB.constantInstruction(Opcode.LDC, cde.constantValue());\n+                                    codeB.ldc(cde.constantValue());\n","filename":"test\/jdk\/jdk\/classfile\/BSMTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                              xb.returnInstruction(TypeKind.VoidType);\n+                              xb.return_();\n@@ -86,1 +86,1 @@\n-                              xb.nopInstruction();\n+                              xb.nop();\n@@ -90,1 +90,1 @@\n-                                  xxb.nopInstruction();\n+                                  xxb.nop();\n@@ -92,1 +92,1 @@\n-                              xb.returnInstruction(TypeKind.VoidType);\n+                              xb.return_();\n@@ -109,1 +109,1 @@\n-                                                    .ifThen(xxb -> xxb.iconst_1().returnInstruction(TypeKind.IntType))\n+                                                    .ifThen(xxb -> xxb.iconst_1().ireturn())\n@@ -111,1 +111,1 @@\n-                                                    .returnInstruction(TypeKind.IntType)));\n+                                                    .ireturn()));\n@@ -128,2 +128,2 @@\n-                                                    .ifThenElse(xxb -> xxb.iconst_1().returnInstruction(TypeKind.IntType),\n-                                                                xxb -> xxb.iconst_2().returnInstruction(TypeKind.IntType))));\n+                                                    .ifThenElse(xxb -> xxb.iconst_1().ireturn(),\n+                                                                xxb -> xxb.iconst_2().ireturn())));\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-                tb.constantInstruction(Opcode.LDC, \"IndexOutOfBoundsException\");\n-                tb.returnInstruction(TypeKind.ReferenceType);\n+                tb.ldc(\"IndexOutOfBoundsException\");\n+                tb.areturn();\n@@ -74,2 +74,2 @@\n-                tb.constantInstruction(Opcode.LDC, \"any\");\n-                tb.returnInstruction(TypeKind.ReferenceType);\n+                tb.ldc(\"any\");\n+                tb.areturn();\n@@ -94,1 +94,1 @@\n-                tb.constantInstruction(Opcode.LDC, \"IndexOutOfBoundsException\");\n+                tb.ldc(\"IndexOutOfBoundsException\");\n@@ -99,1 +99,1 @@\n-                tb.constantInstruction(Opcode.LDC, \"any\");\n+                tb.ldc(\"any\");\n@@ -135,2 +135,2 @@\n-                tb.constantInstruction(Opcode.LDC, \"IndexOutOfBoundsException\");\n-                tb.returnInstruction(TypeKind.ReferenceType);\n+                tb.ldc(\"IndexOutOfBoundsException\");\n+                tb.areturn();\n@@ -156,2 +156,2 @@\n-                tb.constantInstruction(Opcode.LDC, \"any\");\n-                tb.returnInstruction(TypeKind.ReferenceType);\n+                tb.ldc(\"any\");\n+                tb.areturn();\n@@ -190,1 +190,1 @@\n-                            xb.constantInstruction(\"S\");\n+                            xb.loadConstant(\"S\");\n@@ -201,2 +201,2 @@\n-                                        tb.constantInstruction(Opcode.LDC, \"any\");\n-                                        tb.returnInstruction(TypeKind.ReferenceType);\n+                                        tb.ldc(\"any\");\n+                                        tb.areturn();\n@@ -208,1 +208,1 @@\n-                            xb.returnInstruction(TypeKind.ReferenceType);\n+                            xb.areturn();\n@@ -221,1 +221,1 @@\n-                            xb.constantInstruction(\"S\");\n+                            xb.loadConstant(\"S\");\n@@ -228,1 +228,1 @@\n-                                tb.constantInstruction(0);\n+                                tb.loadConstant(0);\n@@ -243,1 +243,1 @@\n-                                    tb.constantInstruction(Math.PI);\n+                                    tb.loadConstant(Math.PI);\n@@ -253,1 +253,1 @@\n-                                    tb.constantInstruction(\"REF\");\n+                                    tb.loadConstant(\"REF\");\n@@ -263,1 +263,1 @@\n-                            xb.returnInstruction(TypeKind.ReferenceType);\n+                            xb.areturn();\n@@ -284,1 +284,1 @@\n-                            xb.constantInstruction(\"S\");\n+                            xb.loadConstant(\"S\");\n@@ -289,1 +289,1 @@\n-                                tb.constantInstruction(0);\n+                                tb.loadConstant(0);\n@@ -298,1 +298,1 @@\n-                            xb.returnInstruction(TypeKind.ReferenceType);\n+                            xb.areturn();\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-                            bb.constantInstruction(\"Hello\")\n+                            bb.loadConstant(\"Hello\")\n@@ -55,1 +55,1 @@\n-                            bb.constantInstruction(\"World\")\n+                            bb.loadConstant(\"World\")\n","filename":"test\/jdk\/jdk\/classfile\/DiscontinuedInstructionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,3 +52,3 @@\n-                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                              .returnInstruction(VoidType)\n+                      .withCode(codeb -> codeb.aload(0)\n+                                              .invokespecial(CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .return_()\n@@ -65,5 +65,5 @@\n-                                  c0.constantInstruction(LDC, \"string0\")\n-                                    .constantInstruction(LDC, \"string131\")\n-                                    .constantInstruction(LDC, \"string50\")\n-                                    .constantInstruction(-0.0f)\n-                                    .constantInstruction(-0.0d)\n+                                  c0.loadConstant(LDC, \"string0\")\n+                                    .loadConstant(LDC, \"string131\")\n+                                    .loadConstant(LDC, \"string50\")\n+                                    .loadConstant(-0.0f)\n+                                    .loadConstant(-0.0d)\n@@ -71,3 +71,3 @@\n-                                    .constantInstruction(0.0f)\n-                                    .constantInstruction(0.0d)\n-                                    .returnInstruction(VoidType);\n+                                    .loadConstant(0.0f)\n+                                    .loadConstant(0.0d)\n+                                    .return_();\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8320360 8330684\n+ * @bug 8320360 8330684 8331320 8331655 8331940 8332486\n@@ -30,0 +30,2 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BufWriter;\n@@ -34,0 +36,6 @@\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.attribute.LineNumberInfo;\n+import java.lang.classfile.attribute.LineNumberTableAttribute;\n+import java.lang.classfile.attribute.LocalVariableInfo;\n+import java.lang.classfile.attribute.LocalVariableTableAttribute;\n@@ -35,0 +43,5 @@\n+import java.lang.classfile.constantpool.IntegerEntry;\n+import java.lang.classfile.instruction.LocalVariable;\n+import java.util.List;\n+import jdk.internal.classfile.impl.DirectCodeBuilder;\n+import jdk.internal.classfile.impl.DirectMethodBuilder;\n@@ -36,0 +49,1 @@\n+import jdk.internal.classfile.impl.UnboundAttribute;\n@@ -102,0 +116,77 @@\n+\n+    @Test\n+    void testInvalidUtf8Entry() {\n+        var cp = ClassFile.of().parse(new byte[]{(byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE,\n+            0, 0, 0, 0, 0, 3, ClassFile.TAG_INTEGER, 0, 0, 0, 0, ClassFile.TAG_NAMEANDTYPE, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}).constantPool();\n+        assertTrue(cp.entryByIndex(1) instanceof IntegerEntry); \/\/parse valid int entry first\n+        assertThrows(ConstantPoolException.class, () -> cp.entryByIndex(2));\n+    }\n+\n+    @Test\n+    void testInvalidLookupSwitch() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"LookupSwitchClass\"), cb -> cb.withMethod(\n+                \"lookupSwitchMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, mb ->\n+                        ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                                @Override\n+                                public void writeBody(BufWriter b) {\n+                                    b.writeU2(-1);\/\/max stack\n+                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeInt(16);\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.NOP.bytecode());\n+                                    b.writeU1(Opcode.LOOKUPSWITCH.bytecode());\n+                                    b.writeU1(0); \/\/padding\n+                                    b.writeU2(0); \/\/padding\n+                                    b.writeInt(0); \/\/default\n+                                    b.writeInt(-2); \/\/npairs to jump back and cause OOME if not checked\n+                                    b.writeU2(0);\/\/exception handlers\n+                                    b.writeU2(0);\/\/attributes\n+                                }})))).methods().get(0).code().get().elementList());\n+    }\n+\n+    @Test\n+    void testInvalidTableSwitch() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"TableSwitchClass\"), cb -> cb.withMethod(\n+                \"tableSwitchMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, mb ->\n+                        ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                                @Override\n+                                public void writeBody(BufWriter b) {\n+                                    b.writeU2(-1);\/\/max stack\n+                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeInt(16);\n+                                    b.writeU1(Opcode.TABLESWITCH.bytecode());\n+                                    b.writeU1(0); \/\/padding\n+                                    b.writeU2(0); \/\/padding\n+                                    b.writeInt(0); \/\/default\n+                                    b.writeInt(0); \/\/low\n+                                    b.writeInt(-5); \/\/high to jump back and cause OOME if not checked\n+                                    b.writeU2(0);\/\/exception handlers\n+                                    b.writeU2(0);\/\/attributes\n+                                }})))).methods().get(0).code().get().elementList());\n+    }\n+\n+    @Test\n+    void testLineNumberOutOfBounds() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"LineNumberClass\"), cb -> cb.withMethodBody(\n+                \"lineNumberMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, cob -> ((DirectCodeBuilder)cob\n+                        .return_())\n+                        .writeAttribute(LineNumberTableAttribute.of(List.of(LineNumberInfo.of(500, 0))))\n+                ))).methods().get(0).code().get().elementList());\n+    }\n+\n+    @Test\n+    void testLocalVariableOutOfBounds() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"LocalVariableClass\"), cb -> cb.withMethodBody(\n+                \"localVariableMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, cob -> ((DirectCodeBuilder)cob\n+                        .return_())\n+                        .writeAttribute(LocalVariableTableAttribute.of(List.of(\n+                                new UnboundAttribute.UnboundLocalVariableInfo(0, 200,\n+                                        cob.constantPool().utf8Entry(\"a\"), cob.constantPool().utf8Entry(\"A\"), 0))))\n+                ))).methods().get(0).code().get().elementList());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -83,9 +83,9 @@\n-                              xb.invokeDynamicInstruction(indy);\n-                              xb.storeInstruction(TypeKind.ReferenceType, 1);\n-                              xb.loadInstruction(TypeKind.ReferenceType, 1);\n-                              xb.loadInstruction(TypeKind.IntType, 0);\n-                              xb.invokeInstruction(Opcode.INVOKEINTERFACE, ClassDesc.of(\"java.util.function.IntUnaryOperator\"),\n-                                                   \"applyAsInt\", MethodTypeDesc.ofDescriptor(\"(I)I\"), true);\n-                              xb.storeInstruction(TypeKind.IntType, 2);\n-                              xb.loadInstruction(TypeKind.IntType, 2);\n-                              xb.returnInstruction(TypeKind.IntType);\n+                              xb.invokedynamic(indy);\n+                              xb.astore(1);\n+                              xb.aload(1);\n+                              xb.iload(0);\n+                              xb.invokeinterface(ClassDesc.of(\"java.util.function.IntUnaryOperator\"),\n+                                                   \"applyAsInt\", MethodTypeDesc.ofDescriptor(\"(I)I\"));\n+                              xb.istore(2);\n+                              xb.iload(2);\n+                              xb.ireturn();\n","filename":"test\/jdk\/jdk\/classfile\/LowAdaptTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -125,3 +125,3 @@\n-                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                              .returnInstruction(VoidType)\n+                      .withCode(codeb -> codeb.aload(0)\n+                                              .invokespecial(CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .return_()\n@@ -149,2 +149,2 @@\n-                                    .constantInstruction(ICONST_1, 1)         \/\/ 0\n-                                    .storeInstruction(TypeKind.IntType, 1)          \/\/ 1\n+                                    .iconst_1()         \/\/ 0\n+                                    .istore(1)          \/\/ 1\n@@ -152,2 +152,2 @@\n-                                    .constantInstruction(ICONST_1, 1)         \/\/ 2\n-                                    .storeInstruction(TypeKind.IntType, 2)          \/\/ 3\n+                                    .iconst_1()         \/\/ 2\n+                                    .istore(2)          \/\/ 3\n@@ -155,9 +155,9 @@\n-                                    .loadInstruction(TypeKind.IntType, 2)           \/\/ 4\n-                                    .constantInstruction(BIPUSH, 10)         \/\/ 5\n-                                    .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n-                                    .loadInstruction(TypeKind.IntType, 1)           \/\/ 7\n-                                    .loadInstruction(TypeKind.IntType, 2)           \/\/ 8\n-                                    .operatorInstruction(IMUL)             \/\/ 9\n-                                    .storeInstruction(TypeKind.IntType, 1)          \/\/ 10\n-                                    .incrementInstruction(2, 1)    \/\/ 11\n-                                    .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                    .iload(2)           \/\/ 4\n+                                    .bipush(10)         \/\/ 5\n+                                    .if_icmpge(loopEnd) \/\/ 6\n+                                    .iload(1)           \/\/ 7\n+                                    .iload(2)           \/\/ 8\n+                                    .imul()             \/\/ 9\n+                                    .istore(1)          \/\/ 10\n+                                    .iinc(2, 1)    \/\/ 11\n+                                    .goto_(loopTop)     \/\/ 12\n@@ -165,3 +165,3 @@\n-                                    .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n-                                    .loadInstruction(TypeKind.IntType, 1)\n-                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n+                                    .getstatic(CD_System, \"out\", CD_PrintStream)   \/\/ 13\n+                                    .iload(1)\n+                                    .invokevirtual(CD_PrintStream, \"println\", MTD_INT_VOID)  \/\/ 15\n@@ -169,1 +169,1 @@\n-                                    .returnInstruction(VoidType)\n+                                    .return_()\n@@ -239,3 +239,3 @@\n-                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                              .returnInstruction(VoidType)\n+                      .withCode(codeb -> codeb.aload(0)\n+                                              .invokespecial(CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .return_()\n@@ -266,4 +266,4 @@\n-                                        .newObjectInstruction(ClassDesc.of(\"java.util.ArrayList\"))\n-                                        .stackInstruction(DUP)\n-                                        .invokeInstruction(INVOKESPECIAL, CD_ArrayList, \"<init>\", MTD_VOID, false)\n-                                        .storeInstruction(TypeKind.ReferenceType, 2)\n+                                        .new_(ClassDesc.of(\"java.util.ArrayList\"))\n+                                        .dup()\n+                                        .invokespecial(CD_ArrayList, \"<init>\", MTD_VOID, false)\n+                                        .astore(2)\n@@ -272,2 +272,2 @@\n-                                        .loadInstruction(TypeKind.ReferenceType, 1)\n-                                        .returnInstruction(TypeKind.ReferenceType)\n+                                        .aload(1)\n+                                        .areturn()\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -71,3 +71,3 @@\n-                                  .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                                          .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                                          .returnInstruction(TypeKind.VoidType)\n+                                  .withCode(codeb -> codeb.aload(0)\n+                                                          .invokespecial(CD_Object, \"<init>\", MTD_VOID, false)\n+                                                          .return_()\n@@ -83,4 +83,4 @@\n-                                                c0.constantInstruction(ICONST_1, 1)         \/\/ 0\n-                                                  .storeInstruction(TypeKind.IntType, fac)        \/\/ 1\n-                                                  .constantInstruction(ICONST_1, 1)         \/\/ 2\n-                                                  .storeInstruction(TypeKind.IntType, i)          \/\/ 3\n+                                                c0.iconst_1()         \/\/ 0\n+                                                  .istore(fac)        \/\/ 1\n+                                                  .iconst_1()         \/\/ 2\n+                                                  .istore(i)          \/\/ 3\n@@ -88,9 +88,9 @@\n-                                                  .loadInstruction(TypeKind.IntType, i)           \/\/ 4\n-                                                  .constantInstruction(BIPUSH, 10)         \/\/ 5\n-                                                  .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n-                                                  .loadInstruction(TypeKind.IntType, fac)         \/\/ 7\n-                                                  .loadInstruction(TypeKind.IntType, i)           \/\/ 8\n-                                                  .operatorInstruction(IMUL)             \/\/ 9\n-                                                  .storeInstruction(TypeKind.IntType, fac)        \/\/ 10\n-                                                  .incrementInstruction(i, 1)    \/\/ 11\n-                                                  .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                                  .iload(i)           \/\/ 4\n+                                                  .bipush(10)         \/\/ 5\n+                                                  .if_icmpge(loopEnd) \/\/ 6\n+                                                  .iload(fac)         \/\/ 7\n+                                                  .iload(i)           \/\/ 8\n+                                                  .imul()             \/\/ 9\n+                                                  .istore(fac)        \/\/ 10\n+                                                  .iinc(i, 1)         \/\/ 11\n+                                                  .goto_(loopTop)     \/\/ 12\n@@ -98,4 +98,4 @@\n-                                                  .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n-                                                  .loadInstruction(TypeKind.IntType, fac)\n-                                                  .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n-                                                  .returnInstruction(TypeKind.VoidType);\n+                                                  .getstatic(CD_System, \"out\", CD_PrintStream)   \/\/ 13\n+                                                  .iload(fac)\n+                                                  .invokevirtual(CD_PrintStream, \"println\", MTD_INT_VOID)  \/\/ 15\n+                                                  .return_();\n","filename":"test\/jdk\/jdk\/classfile\/OneToOneTest.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-                                              codeb -> codeb.constantInstruction(opcode, (ConstantDesc) constant))));\n+                                              codeb -> codeb.loadConstant(opcode, (ConstantDesc) constant))));\n@@ -127,1 +127,1 @@\n-                                codeb -> codeb.constantInstruction(opcode, (ConstantDesc)constant))));\n+                                codeb -> codeb.loadConstant(opcode, (ConstantDesc)constant))));\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/jdk\/jdk\/classfile\/OptionsTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-                cob.constantInstruction(CD_int);\n+                cob.loadConstant(CD_int);\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-                                    cob.branchInstruction(sample.jumpCode, target);\n+                                    cob.branch(sample.jumpCode, target);\n@@ -216,1 +216,1 @@\n-                                        cob.nopInstruction();\n+                                        cob.nop();\n@@ -231,1 +231,1 @@\n-                                        cob.nopInstruction();\n+                                        cob.nop();\n@@ -236,1 +236,1 @@\n-                                    cob.branchInstruction(sample.jumpCode, target);\n+                                    cob.branch(sample.jumpCode, target);\n@@ -247,1 +247,1 @@\n-                                            cob.nopInstruction();\n+                                            cob.nop();\n","filename":"test\/jdk\/jdk\/classfile\/ShortJumpsFixTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -186,3 +186,4 @@\n-        var innerSig = (ClassTypeSig) sig.superclassSignature() \/\/ ArrayList\n-                .typeArgs().getFirst() \/\/ Outer<String>.Inner<Long>\n-                .boundType().orElseThrow(); \/\/ assert it's exact bound\n+        var arrayListSig = sig.superclassSignature(); \/\/ ArrayList\n+        var arrayListTypeArg = (TypeArg.Bounded) arrayListSig.typeArgs().getFirst(); \/\/ Outer<String>.Inner<Long>\n+        assertEquals(TypeArg.Bounded.WildcardIndicator.NONE, arrayListTypeArg.wildcardIndicator());\n+        var innerSig = (ClassTypeSig) arrayListTypeArg.boundType();\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-                                           cb.constantInstruction(0.0d);\n+                                           cb.loadConstant(0.0d);\n@@ -292,1 +292,1 @@\n-                                           cb.constantInstruction(0);\n+                                           cb.loadConstant(0);\n@@ -307,1 +307,1 @@\n-                                           cb.constantInstruction(0.0f);\n+                                           cb.loadConstant(0.0f);\n@@ -310,1 +310,1 @@\n-                                           cb.constantInstruction(0);\n+                                           cb.loadConstant(0);\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                            thb.constantInstruction(ClassDesc.of(\"Phee\"));\n+                            thb.loadConstant(ClassDesc.of(\"Phee\"));\n@@ -94,1 +94,1 @@\n-                    stcb.constantInstruction(ClassDesc.of(\"Phee\")); \/\/stack instruction on unknown stack cause tracking lost\n+                    stcb.loadConstant(ClassDesc.of(\"Phee\")); \/\/stack instruction on unknown stack cause tracking lost\n","filename":"test\/jdk\/jdk\/classfile\/StackTrackerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-                            .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                    .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                    .returnInstruction(VoidType)\n+                            .withCode(codeb -> codeb.aload(0)\n+                                    .invokespecial(CD_Object, \"<init>\", MTD_VOID, false)\n+                                    .return_()\n","filename":"test\/jdk\/jdk\/classfile\/TempConstantPoolBuilderTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                b.constantInstruction(y);\n+                b.loadConstant(y);\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing TypeKind.\n+ * @bug 8331744\n+ * @run junit TypeKindTest\n+ *\/\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.classfile.TypeKind;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+class TypeKindTest {\n+    @Test\n+    void testContracts() {\n+        assertThrows(NullPointerException.class, () -> TypeKind.from(null));\n+\n+        assertThrows(NullPointerException.class, () -> TypeKind.fromDescriptor(null));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"\"));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromDescriptor(\"int\"));\n+\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromNewarrayCode(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeKind.fromNewarrayCode(21));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/TypeKindTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -199,2 +199,2 @@\n-                                                     mb -> mb.withCode(cb -> cb.constantInstruction(s)\n-                                                                               .returnInstruction(VoidType))));\n+                                                     mb -> mb.withCode(cb -> cb.loadConstant(s)\n+                                                                               .return_())));\n","filename":"test\/jdk\/jdk\/classfile\/Utf8EntryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\",\n+                      .withCode(codeb -> codeb.aload(0)\n+                                              .invokespecial(CD_Object, \"<init>\",\n@@ -60,1 +60,1 @@\n-                                              .returnInstruction(VoidType)\n+                                              .return_()\n@@ -69,4 +69,4 @@\n-                                          .constantInstruction(ICONST_1, 1)         \/\/ 0\n-                                          .storeInstruction(TypeKind.IntType, 1)          \/\/ 1\n-                                          .constantInstruction(ICONST_1, 1)         \/\/ 2\n-                                          .storeInstruction(TypeKind.IntType, 2)          \/\/ 3\n+                                          .iconst_1()         \/\/ 0\n+                                          .istore(1)          \/\/ 1\n+                                          .iconst_1()         \/\/ 2\n+                                          .istore(2)          \/\/ 3\n@@ -74,9 +74,9 @@\n-                                          .loadInstruction(TypeKind.IntType, 2)           \/\/ 4\n-                                          .constantInstruction(BIPUSH, 10)         \/\/ 5\n-                                          .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n-                                          .loadInstruction(TypeKind.IntType, 1)           \/\/ 7\n-                                          .loadInstruction(TypeKind.IntType, 2)           \/\/ 8\n-                                          .operatorInstruction(IMUL)             \/\/ 9\n-                                          .storeInstruction(TypeKind.IntType, 1)          \/\/ 10\n-                                          .incrementInstruction(2, 1)    \/\/ 11\n-                                          .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                          .iload(2)           \/\/ 4\n+                                          .bipush(10)         \/\/ 5\n+                                          .if_icmpge(loopEnd) \/\/ 6\n+                                          .iload(1)           \/\/ 7\n+                                          .iload(2)           \/\/ 8\n+                                          .imul()             \/\/ 9\n+                                          .istore(1)          \/\/ 10\n+                                          .iinc(2, 1)    \/\/ 11\n+                                          .goto_(loopTop)     \/\/ 12\n@@ -84,4 +84,4 @@\n-                                          .fieldInstruction(GETSTATIC, TestConstants.CD_System, \"out\", TestConstants.CD_PrintStream)   \/\/ 13\n-                                          .loadInstruction(TypeKind.IntType, 1)\n-                                          .invokeInstruction(INVOKEVIRTUAL, TestConstants.CD_PrintStream, \"println\", TestConstants.MTD_INT_VOID, false)  \/\/ 15\n-                                          .returnInstruction(VoidType);\n+                                          .getstatic(TestConstants.CD_System, \"out\", TestConstants.CD_PrintStream)   \/\/ 13\n+                                          .iload(1)\n+                                          .invokevirtual(TestConstants.CD_PrintStream, \"println\", TestConstants.MTD_INT_VOID)  \/\/ 15\n+                                          .return_();\n@@ -99,3 +99,3 @@\n-                      .withCode(codeb -> codeb.loadInstruction(ReferenceType, 0)\n-                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                              .returnInstruction(VoidType)\n+                      .withCode(codeb -> codeb.aload(0)\n+                                              .invokespecial(CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .return_()\n@@ -110,4 +110,4 @@\n-                                          .constantInstruction(ICONST_1, 1)        \/\/ 0\n-                                          .storeInstruction(IntType, 1)          \/\/ 1\n-                                          .constantInstruction(ICONST_1, 1)        \/\/ 2\n-                                          .storeInstruction(IntType, 2)          \/\/ 3\n+                                          .iconst_1()        \/\/ 0\n+                                          .istore(1)          \/\/ 1\n+                                          .iconst_1()        \/\/ 2\n+                                          .istore(2)          \/\/ 3\n@@ -115,9 +115,9 @@\n-                                          .loadInstruction(IntType, 2)           \/\/ 4\n-                                          .constantInstruction(BIPUSH, 10)         \/\/ 5\n-                                          .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n-                                          .loadInstruction(IntType, 1)           \/\/ 7\n-                                          .loadInstruction(IntType, 2)           \/\/ 8\n-                                          .operatorInstruction(IMUL)             \/\/ 9\n-                                          .storeInstruction(IntType, 1)          \/\/ 10\n-                                          .incrementInstruction(2, 1)    \/\/ 11\n-                                          .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                          .iload(2)           \/\/ 4\n+                                          .bipush(10)         \/\/ 5\n+                                          .if_icmpge(loopEnd) \/\/ 6\n+                                          .iload(1)           \/\/ 7\n+                                          .iload(2)           \/\/ 8\n+                                          .imul()             \/\/ 9\n+                                          .istore(1)          \/\/ 10\n+                                          .iinc(2, 1)    \/\/ 11\n+                                          .goto_(loopTop)     \/\/ 12\n@@ -125,4 +125,4 @@\n-                                          .fieldInstruction(GETSTATIC, TestConstants.CD_System, \"out\", TestConstants.CD_PrintStream)   \/\/ 13\n-                                          .loadInstruction(IntType, 1)\n-                                          .invokeInstruction(INVOKEVIRTUAL, TestConstants.CD_PrintStream, \"println\", TestConstants.MTD_INT_VOID, false)  \/\/ 15\n-                                          .returnInstruction(VoidType);\n+                                          .getstatic(TestConstants.CD_System, \"out\", TestConstants.CD_PrintStream)   \/\/ 13\n+                                          .iload(1)\n+                                          .invokevirtual(TestConstants.CD_PrintStream, \"println\", TestConstants.MTD_INT_VOID)  \/\/ 15\n+                                          .return_();\n","filename":"test\/jdk\/jdk\/classfile\/WriteTest.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-                    codeB.nopInstruction();\n+                    codeB.nop();\n@@ -268,1 +268,1 @@\n-                    codeB.nopInstruction();\n+                    codeB.nop();\n@@ -280,1 +280,1 @@\n-                        if (ci.constantValue() instanceof Integer i) codeB.constantInstruction(i + 1);\n+                        if (ci.constantValue() instanceof Integer i) codeB.loadConstant(i + 1);\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-                cb.loadInstruction(im.typeKind(), im.slot());\n+                cb.loadLocal(im.typeKind(), im.slot());\n@@ -40,1 +40,1 @@\n-                cb.storeInstruction(im.typeKind(), im.slot());\n+                cb.storeLocal(im.typeKind(), im.slot());\n@@ -42,1 +42,1 @@\n-                cb.incrementInstruction(im.slot(), im.constant());\n+                cb.iinc(im.slot(), im.constant());\n@@ -44,1 +44,1 @@\n-                cb.branchInstruction(im.opcode(), im.target());\n+                cb.branch(im.opcode(), im.target());\n@@ -46,1 +46,1 @@\n-                cb.lookupSwitchInstruction(im.defaultTarget(), im.cases());\n+                cb.lookupswitch(im.defaultTarget(), im.cases());\n@@ -48,1 +48,1 @@\n-                cb.tableSwitchInstruction(im.lowValue(), im.highValue(), im.defaultTarget(), im.cases());\n+                cb.tableswitch(im.lowValue(), im.highValue(), im.defaultTarget(), im.cases());\n@@ -50,1 +50,1 @@\n-                cb.returnInstruction(im.typeKind());\n+                cb.return_(im.typeKind());\n@@ -52,1 +52,1 @@\n-                cb.throwInstruction();\n+                cb.athrow();\n@@ -54,1 +54,1 @@\n-                cb.fieldInstruction(im.opcode(), im.owner().asSymbol(), im.name().stringValue(), im.typeSymbol());\n+                cb.fieldAccess(im.opcode(), im.owner().asSymbol(), im.name().stringValue(), im.typeSymbol());\n@@ -56,1 +56,1 @@\n-                cb.invokeInstruction(im.opcode(), im.owner().asSymbol(), im.name().stringValue(), im.typeSymbol(), im.isInterface());\n+                cb.invoke(im.opcode(), im.owner().asSymbol(), im.name().stringValue(), im.typeSymbol(), im.isInterface());\n@@ -58,1 +58,1 @@\n-                cb.invokeDynamicInstruction(DynamicCallSiteDesc.of(im.bootstrapMethod(), im.name().stringValue(), MethodTypeDesc.ofDescriptor(im.type().stringValue()), im.bootstrapArgs().toArray(ConstantDesc[]::new)));\n+                cb.invokedynamic(DynamicCallSiteDesc.of(im.bootstrapMethod(), im.name().stringValue(), MethodTypeDesc.ofDescriptor(im.type().stringValue()), im.bootstrapArgs().toArray(ConstantDesc[]::new)));\n@@ -60,1 +60,1 @@\n-                cb.newObjectInstruction(im.className().asSymbol());\n+                cb.new_(im.className().asSymbol());\n@@ -62,1 +62,1 @@\n-                cb.newPrimitiveArrayInstruction(im.typeKind());\n+                cb.newarray(im.typeKind());\n@@ -64,1 +64,1 @@\n-                cb.newReferenceArrayInstruction(im.componentType());\n+                cb.anewarray(im.componentType());\n@@ -66,1 +66,1 @@\n-                cb.newMultidimensionalArrayInstruction(im.dimensions(), im.arrayType());\n+                cb.multianewarray(im.arrayType(), im.dimensions());\n@@ -68,1 +68,1 @@\n-                cb.typeCheckInstruction(im.opcode(), im.type().asSymbol());\n+                cb.with(TypeCheckInstruction.of(im.opcode(), im.type().asSymbol()));\n@@ -70,1 +70,1 @@\n-                cb.arrayLoadInstruction(im.typeKind());\n+                cb.arrayLoad(im.typeKind());\n@@ -72,1 +72,1 @@\n-                cb.arrayStoreInstruction(im.typeKind());\n+                cb.arrayStore(im.typeKind());\n@@ -74,1 +74,1 @@\n-                cb.stackInstruction(im.opcode());\n+                cb.with(StackInstruction.of(im.opcode()));\n@@ -76,1 +76,1 @@\n-                cb.convertInstruction(im.fromType(), im.toType());\n+                cb.conversion(im.fromType(), im.toType());\n@@ -78,1 +78,1 @@\n-                cb.operatorInstruction(im.opcode());\n+                cb.with(OperatorInstruction.of(im.opcode()));\n@@ -80,1 +80,1 @@\n-                cb.constantInstruction(im.opcode(), im.constantValue());\n+                cb.loadConstant(im.opcode(), im.constantValue());\n@@ -82,1 +82,1 @@\n-                cb.monitorInstruction(im.opcode());\n+                cb.with(MonitorInstruction.of(im.opcode()));\n@@ -84,1 +84,1 @@\n-                cb.nopInstruction();\n+                cb.nop();\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/InstructionModelToCodeBuilder.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-                        else cob.constantInstruction(null);\n+                        else cob.loadConstant(null);\n@@ -286,1 +286,1 @@\n-                            else cob.constantInstruction(iVal);\n+                            else cob.loadConstant(iVal);\n@@ -291,1 +291,1 @@\n-                            else cob.constantInstruction(lVal);\n+                            else cob.loadConstant(lVal);\n@@ -297,1 +297,1 @@\n-                            else cob.constantInstruction(fVal);\n+                            else cob.loadConstant(fVal);\n@@ -302,1 +302,1 @@\n-                            else cob.constantInstruction(dVal);\n+                            else cob.loadConstant(dVal);\n@@ -304,1 +304,1 @@\n-                        default -> cob.constantInstruction(i.constantValue());\n+                        default -> cob.loadConstant(i.constantValue());\n@@ -553,1 +553,1 @@\n-                            case INSTANCEOF -> cob.instanceof_(i.type().asSymbol());\n+                            case INSTANCEOF -> cob.instanceOf(i.type().asSymbol());\n@@ -559,1 +559,1 @@\n-                            case INSTANCEOF -> cob.instanceof_(i.type());\n+                            case INSTANCEOF -> cob.instanceOf(i.type());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                                xb.nopInstruction();\n+                                xb.nop();\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @modules jdk.internal.le\/jdk.internal.org.jline.terminal\n+ * @modules jdk.internal.le\/jdk.internal.org.jline\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal\n@@ -30,0 +31,1 @@\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.spi\n@@ -42,0 +44,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -59,1 +62,4 @@\n-        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, false, SignalHandler.SIG_DFL, isWrapper) {\n+        var t = new AbstractWindowsTerminal<String>(null, SystemStream.Output, out,\n+                                                    \"test\", \"vt100\", null, false,\n+                                                    SignalHandler.SIG_DFL, \"\", 0,\n+                                                    \"\", 0, isWrapper) {\n@@ -61,1 +67,1 @@\n-            protected int getConsoleMode() {\n+            protected int getConsoleMode(String console) {\n@@ -66,1 +72,1 @@\n-            protected void setConsoleMode(int mode) {\n+            protected void setConsoleMode(String console, int mode) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/AbstractWindowsTerminalTest.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331535\n+ * @summary Verify the jdk.internal.le's console provider works properly.\n+ * @modules jdk.internal.le\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djdk.console=jdk.internal.le JLineConsoleProviderTest\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class JLineConsoleProviderTest {\n+\n+    public static void main(String... args) throws Throwable {\n+        for (Method m : JLineConsoleProviderTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                m.invoke(new JLineConsoleProviderTest());\n+            }\n+        }\n+    }\n+\n+    void testCorrectOutputReadLine() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadLine\", \"inp\", \"%s\");\n+    }\n+\n+    void testCorrectOutputReadPassword() throws Exception {\n+        doRunConsoleTest(\"testCorrectOutputReadPassword\", \"inp\", \"%s\");\n+    }\n+\n+    void doRunConsoleTest(String testName,\n+                          String input,\n+                          String expectedOut) throws Exception {\n+        ProcessBuilder builder =\n+                ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName(),\n+                                                          testName);\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder, input);\n+\n+        output.waitFor();\n+\n+        if (output.getExitValue() != 0) {\n+            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n+                                     \", actualOut: \" + output.getStdout() +\n+                                     \", actualErr: \" + output.getStderr());\n+        }\n+\n+        String actualOut = output.getStdout();\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+\n+        String expectedErr = \"\";\n+        String actualErr = output.getStderr();\n+\n+        if (!Objects.equals(expectedErr, actualErr)) {\n+            throw new AssertionError(\"Unexpected stderr content. \" +\n+                                     \"Expected: '\" + expectedErr + \"'\" +\n+                                     \", got: '\" + actualErr + \"'\");\n+        }\n+    }\n+\n+    public static class ConsoleTest {\n+        public static void main(String... args) {\n+            switch (args[0]) {\n+                case \"testCorrectOutputReadLine\" ->\n+                    System.console().readLine(\"%%s\");\n+                case \"testCorrectOutputReadPassword\" ->\n+                    System.console().readPassword(\"%%s\");\n+                default -> throw new UnsupportedOperationException(args[0]);\n+            }\n+\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/JLineConsoleProviderTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.spi\n@@ -39,0 +40,1 @@\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -61,2 +63,5 @@\n-        new AbstractWindowsTerminal(new StringWriter(), \"\", \"windows\", Charset.forName(\"UTF-8\"),\n-                                    true, SignalHandler.SIG_DFL, in -> in) {\n+        new AbstractWindowsTerminal<String>(null, SystemStream.Output,\n+                                            new StringWriter(), \"\", \"windows\",\n+                                            Charset.forName(\"UTF-8\"), true,\n+                                            SignalHandler.SIG_DFL, \"\", 0,\n+                                            \"\", 0, in -> in) {\n@@ -64,1 +69,1 @@\n-            protected int getConsoleMode() {\n+            protected int getConsoleMode(String console) {\n@@ -68,1 +73,1 @@\n-            protected void setConsoleMode(int mode) {\n+            protected void setConsoleMode(String console, int mode) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/KeyConversionTest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8330998\n+ * @summary Verify that even if the stdout is redirected java.io.Console will\n+ *          use it for writing.\n+ * @modules jdk.internal.le\n+ * @library \/test\/lib\n+ * @run main RedirectedStdOut runRedirectAllTest\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED RedirectedStdOut runRedirectOutOnly\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RedirectedStdOut {\n+    private static final String OUTPUT = \"Hello!\";\n+\n+    public static void main(String... args) throws Throwable {\n+        RedirectedStdOut.class.getDeclaredMethod(args[0])\n+                              .invoke(new RedirectedStdOut());\n+    }\n+\n+    \/\/verify the case where neither stdin\/out\/err is attached to a terminal,\n+    \/\/this test is weaker, but more reliable:\n+    void runRedirectAllTest() throws Exception {\n+        ProcessBuilder builder =\n+                ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName());\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n+\n+        output.waitFor();\n+\n+        if (output.getExitValue() != 0) {\n+            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n+                                     \", actualOut: \" + output.getStdout() +\n+                                     \", actualErr: \" + output.getStderr());\n+        }\n+\n+        String expectedOut = OUTPUT;\n+        String actualOut = output.getStdout();\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+\n+        String expectedErr = \"\";\n+        String actualErr = output.getStderr();\n+\n+        if (!Objects.equals(expectedErr, actualErr)) {\n+            throw new AssertionError(\"Unexpected stderr content. \" +\n+                                     \"Expected: '\" + expectedErr + \"'\" +\n+                                     \", got: '\" + actualErr + \"'\");\n+        }\n+    }\n+\n+    \/\/verify the case where stdin is attached to a terminal,\n+    \/\/this test allocates pty, and it might be skipped, if the appropriate\n+    \/\/native functions cannot be found\n+    \/\/it also leaves the VM in a broken state (with a pty attached), and so\n+    \/\/should run in a separate VM instance\n+    void runRedirectOutOnly() throws Throwable {\n+        Path stdout = Path.of(\".\", \"stdout.txt\").toAbsolutePath();\n+\n+        Files.deleteIfExists(stdout);\n+\n+        Linker linker = Linker.nativeLinker();\n+        SymbolLookup stdlib = linker.defaultLookup();\n+        MemorySegment parent = Arena.global().allocate(ValueLayout.ADDRESS);\n+        MemorySegment child = Arena.global().allocate(ValueLayout.ADDRESS);\n+        Optional<MemorySegment> openptyAddress = stdlib.find(\"openpty\");\n+\n+        if (openptyAddress.isEmpty()) {\n+            System.out.println(\"Cannot lookup openpty.\");\n+            \/\/does not have forkpty, ignore\n+            return ;\n+        }\n+\n+        Optional<MemorySegment> loginttyAddress = stdlib.find(\"login_tty\");\n+\n+        if (loginttyAddress.isEmpty()) {\n+            System.out.println(\"Cannot lookup login_tty.\");\n+            \/\/does not have forkpty, ignore\n+            return ;\n+        }\n+\n+        FunctionDescriptor openttyDescriptor =\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS,\n+                                      ValueLayout.ADDRESS);\n+        MethodHandle forkpty = linker.downcallHandle(openptyAddress.get(),\n+                                                     openttyDescriptor);\n+        int res = (int) forkpty.invoke(parent,\n+                                       child,\n+                                       MemorySegment.NULL,\n+                                       MemorySegment.NULL,\n+                                       MemorySegment.NULL);\n+\n+        if (res != 0) {\n+            throw new AssertionError();\n+        }\n+\n+        \/\/set the current VM's in\/out to the terminal:\n+        FunctionDescriptor loginttyDescriptor =\n+                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+                                      ValueLayout.JAVA_INT);\n+        MethodHandle logintty = linker.downcallHandle(loginttyAddress.get(),\n+                                                      loginttyDescriptor);\n+        logintty.invoke(child.get(ValueLayout.JAVA_INT, 0));\n+\n+        \/\/createTestJavaProcessBuilder logs to (current process') System.out, but\n+        \/\/that may not work since the redirect. Setting System.out to a scratch value:\n+        System.setOut(new PrintStream(new ByteArrayOutputStream()));\n+\n+        ProcessBuilder builder =\n+            ProcessTools.createTestJavaProcessBuilder(ConsoleTest.class.getName());\n+\n+        builder.inheritIO();\n+        builder.redirectOutput(stdout.toFile());\n+\n+        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n+\n+        output.waitFor();\n+\n+        String expectedOut = OUTPUT;\n+        String actualOut = Files.readString(stdout);\n+\n+        if (!Objects.equals(expectedOut, actualOut)) {\n+            throw new AssertionError(\"Unexpected stdout content. \" +\n+                                     \"Expected: '\" + expectedOut + \"'\" +\n+                                     \", got: '\" + actualOut + \"'\");\n+        }\n+    }\n+\n+    public static class ConsoleTest {\n+        public static void main(String... args) {\n+            System.console().printf(OUTPUT);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/RedirectedStdOut.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import com.sun.tools.classfile.*;\n-import static com.sun.tools.classfile.ConstantPool.*;\n@@ -28,1 +26,0 @@\n-import java.io.InputStream;\n@@ -30,0 +27,7 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n@@ -50,1 +54,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile jdk.jdeps\/com.sun.tools.jdeps\n+ * @enablePreview\n@@ -90,1 +94,0 @@\n-    private final ReferenceFinder finder;\n@@ -92,1 +95,0 @@\n-        this.finder = new ReferenceFinder(getFilter(), getVisitor());\n@@ -97,10 +99,29 @@\n-    private ReferenceFinder.Filter getFilter() {\n-        final String classname = \"jdk\/internal\/reflect\/Reflection\";\n-        final String method = \"getCallerClass\";\n-        return new ReferenceFinder.Filter() {\n-            public boolean accept(ConstantPool cpool, CPRefInfo cpref) {\n-                try {\n-                    CONSTANT_NameAndType_info nat = cpref.getNameAndTypeInfo();\n-                    return cpref.getClassName().equals(classname) && nat.getName().equals(method);\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n+    private void check(ClassModel clazz) {\n+        final String className = \"jdk\/internal\/reflect\/Reflection\";\n+        final String methodName = \"getCallerClass\";\n+        boolean checkMethods = false;\n+        for (var pe : clazz.constantPool()) {\n+            if (pe instanceof MethodRefEntry ref\n+                    && ref.owner().name().equalsString(className)\n+                    && ref.name().equalsString(methodName)) {\n+                checkMethods = true;\n+            }\n+        }\n+\n+        if (!checkMethods)\n+            return;\n+\n+        for (var method : clazz.methods()) {\n+            var code = method.code().orElse(null);\n+            if (code == null)\n+                continue;\n+\n+            boolean needsCsm = false;\n+            for (var element : code) {\n+                if (element instanceof InvokeInstruction invoke\n+                        && invoke.opcode() == Opcode.INVOKESTATIC\n+                        && invoke.method() instanceof MethodRefEntry ref\n+                        && ref.owner().name().equalsString(className)\n+                        && ref.name().equalsString(methodName)) {\n+                    needsCsm = true;\n+                    break;\n@@ -109,1 +130,5 @@\n-        };\n+\n+            if (needsCsm) {\n+                process(clazz, method);\n+            }\n+        }\n@@ -112,24 +137,16 @@\n-    private ReferenceFinder.Visitor getVisitor() {\n-        return new ReferenceFinder.Visitor() {\n-            public void visit(ClassFile cf, Method m,  List<CPRefInfo> refs) {\n-                try {\n-                    \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n-                    \/\/ which is a \"special\" delegate to the internal getCallerClass\n-                    if (cf.getName().equals(\"sun\/reflect\/Reflection\") &&\n-                        m.getName(cf.constant_pool).equals(\"getCallerClass\"))\n-                        return;\n-\n-                    String name = String.format(\"%s#%s %s\", cf.getName(),\n-                                                m.getName(cf.constant_pool),\n-                                                m.descriptor.getValue(cf.constant_pool));\n-                    if (!CallerSensitiveFinder.isCallerSensitive(m, cf.constant_pool)) {\n-                        csMethodsMissingAnnotation.add(name);\n-                        System.err.println(\"Missing @CallerSensitive: \" + name);\n-                    } else {\n-                        if (verbose) {\n-                            System.out.format(\"@CS  %s%n\", name);\n-                        }\n-                    }\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+    private void process(ClassModel cf, MethodModel m) {\n+        \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n+        \/\/ which is a \"special\" delegate to the internal getCallerClass\n+        if (cf.thisClass().name().equalsString(\"sun\/reflect\/Reflection\") &&\n+                m.methodName().equalsString(\"getCallerClass\"))\n+            return;\n+\n+        String name = cf.thisClass().asInternalName() + '#'\n+                + m.methodName().stringValue() + ' '\n+                + m.methodType().stringValue();\n+        if (!CallerSensitiveFinder.isCallerSensitive(m)) {\n+            csMethodsMissingAnnotation.add(name);\n+            System.err.println(\"Missing @CallerSensitive: \" + name);\n+        } else {\n+            if (verbose) {\n+                System.out.format(\"@CS  %s%n\", name);\n@@ -137,1 +154,1 @@\n-        };\n+        }\n@@ -141,1 +158,1 @@\n-            ExecutionException, ConstantPoolException\n+            ExecutionException, IllegalArgumentException\n@@ -149,5 +166,2 @@\n-    private static boolean isCallerSensitive(Method m, ConstantPool cp)\n-            throws ConstantPoolException\n-    {\n-        RuntimeAnnotations_attribute attr =\n-            (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeVisibleAnnotations);\n+    private static boolean isCallerSensitive(MethodModel m) {\n+        var attr = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n@@ -155,4 +169,2 @@\n-            for (int i = 0; i < attr.annotations.length; i++) {\n-                Annotation ann = attr.annotations[i];\n-                String annType = cp.getUTF8Value(ann.type_index);\n-                if (CALLER_SENSITIVE_ANNOTATION.equals(annType)) {\n+            for (var ann : attr.annotations()) {\n+                if (ann.className().equalsString(CALLER_SENSITIVE_ANNOTATION)) {\n@@ -177,2 +189,3 @@\n-                try (InputStream is = Files.newInputStream(p)) {\n-                    finder.parse(ClassFile.read(is));\n+                try {\n+                    var clz = ClassFile.of().parse(p); \/\/ propagate IllegalArgumentException\n+                    check(clz);\n@@ -181,2 +194,0 @@\n-                } catch (ConstantPoolException x) {\n-                    throw new RuntimeException(x);\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CallerSensitiveFinder.java","additions":68,"deletions":57,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,0 @@\n-import com.sun.tools.classfile.*;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_PRIVATE;\n-import static com.sun.tools.classfile.ConstantPool.*;\n@@ -30,1 +26,0 @@\n-import java.io.InputStream;\n@@ -32,0 +27,8 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.reflect.AccessFlag;\n@@ -38,1 +41,0 @@\n-import java.util.Arrays;\n@@ -53,0 +55,2 @@\n+import static java.lang.constant.ConstantDescs.CD_Class;\n+\n@@ -57,2 +61,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.jdeps\n+ * @enablePreview\n@@ -69,1 +72,1 @@\n-    private static Set<String> KNOWN_NON_FINAL_CSMS =\n+    private static final Set<String> KNOWN_NON_FINAL_CSMS =\n@@ -114,1 +117,0 @@\n-    private final ReferenceFinder finder;\n@@ -116,1 +118,0 @@\n-        this.finder = new ReferenceFinder(getFilter(), getVisitor());\n@@ -118,1 +119,0 @@\n-\n@@ -123,1 +123,1 @@\n-               ConstantPoolException\n+               IllegalArgumentException\n@@ -130,0 +130,11 @@\n+    private void check(ClassModel clazz) {\n+        final String className = \"jdk\/internal\/reflect\/Reflection\";\n+        final String methodName = \"getCallerClass\";\n+        boolean checkMethods = false;\n+        for (var pe : clazz.constantPool()) {\n+            if (pe instanceof MethodRefEntry ref\n+                    && ref.owner().name().equalsString(className)\n+                    && ref.name().equalsString(methodName)) {\n+                checkMethods = true;\n+            }\n+        }\n@@ -131,10 +142,17 @@\n-    private ReferenceFinder.Filter getFilter() {\n-        final String classname = \"jdk\/internal\/reflect\/Reflection\";\n-        final String method = \"getCallerClass\";\n-        return new ReferenceFinder.Filter() {\n-            public boolean accept(ConstantPool cpool, CPRefInfo cpref) {\n-                try {\n-                    CONSTANT_NameAndType_info nat = cpref.getNameAndTypeInfo();\n-                    return cpref.getClassName().equals(classname) && nat.getName().equals(method);\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n+        if (!checkMethods)\n+            return;\n+\n+        for (var method : clazz.methods()) {\n+            var code = method.code().orElse(null);\n+            if (code == null)\n+                continue;\n+\n+            boolean needsCsm = false;\n+            for (var element : code) {\n+                if (element instanceof InvokeInstruction invoke\n+                        && invoke.opcode() == Opcode.INVOKESTATIC\n+                        && invoke.method() instanceof MethodRefEntry ref\n+                        && ref.owner().name().equalsString(className)\n+                        && ref.name().equalsString(methodName)) {\n+                    needsCsm = true;\n+                    break;\n@@ -143,2 +161,0 @@\n-        };\n-    }\n@@ -146,31 +162,2 @@\n-    private ReferenceFinder.Visitor getVisitor() {\n-        return new ReferenceFinder.Visitor() {\n-            public void visit(ClassFile cf, Method m,  List<CPRefInfo> refs) {\n-                try {\n-                    \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n-                    \/\/ which is a \"special\" delegate to the internal getCallerClass\n-                    if (cf.getName().equals(\"sun\/reflect\/Reflection\") &&\n-                        m.getName(cf.constant_pool).equals(\"getCallerClass\"))\n-                        return;\n-\n-                    String name = methodSignature(cf, m);\n-                    if (!CheckCSMs.isStaticOrFinal(cf, m, cf.constant_pool)) {\n-                        System.err.println(\"Unsupported @CallerSensitive: \" + name);\n-                        nonFinalCSMs.add(name);\n-                    } else {\n-                        if (listCSMs) {\n-                            System.out.format(\"@CS  %s%n\", name);\n-                        }\n-                    }\n-\n-                    \/\/ find the adapter implementation for CSM with the caller parameter\n-                    if (!csmWithCallerParameter.containsKey(cf.getName())) {\n-                        Set<String> methods = Arrays.stream(cf.methods)\n-                                                    .filter(m0 -> csmWithCallerParameter(cf, m, m0))\n-                                                    .map(m0 -> methodSignature(cf, m0))\n-                                                    .collect(Collectors.toSet());\n-                        csmWithCallerParameter.put(cf.getName(), methods);\n-                    }\n-                } catch (ConstantPoolException ex) {\n-                    throw new RuntimeException(ex);\n-                }\n+            if (needsCsm) {\n+                process(clazz, method);\n@@ -178,1 +165,1 @@\n-        };\n+        }\n@@ -181,7 +168,15 @@\n-    private static String methodSignature(ClassFile cf, Method m) {\n-        try {\n-            return String.format(\"%s#%s %s\", cf.getName(),\n-                                 m.getName(cf.constant_pool),\n-                                 m.descriptor.getValue(cf.constant_pool));\n-        } catch (ConstantPoolException ex) {\n-            throw new RuntimeException(ex);\n+    private void process(ClassModel cf, MethodModel m) {\n+        \/\/ ignore jdk.unsupported\/sun.reflect.Reflection.getCallerClass\n+        \/\/ which is a \"special\" delegate to the internal getCallerClass\n+        if (cf.thisClass().name().equalsString(\"sun\/reflect\/Reflection\")\n+                && m.methodName().equalsString(\"getCallerClass\"))\n+            return;\n+\n+        String name = methodSignature(cf, m);\n+        if (!CheckCSMs.isStaticOrFinal(cf, m)) {\n+            System.err.println(\"Unsupported @CallerSensitive: \" + name);\n+            nonFinalCSMs.add(name);\n+        } else {\n+            if (listCSMs) {\n+                System.out.format(\"@CS  %s%n\", name);\n+            }\n@@ -189,0 +184,15 @@\n+\n+        \/\/ find the adapter implementation for CSM with the caller parameter\n+        if (!csmWithCallerParameter.containsKey(cf.thisClass().asInternalName())) {\n+            Set<String> methods = cf.methods().stream()\n+                    .filter(m0 -> csmWithCallerParameter(cf, m, m0))\n+                    .map(m0 -> methodSignature(cf, m0))\n+                    .collect(Collectors.toSet());\n+            csmWithCallerParameter.put(cf.thisClass().asInternalName(), methods);\n+        }\n+    }\n+\n+    private static String methodSignature(ClassModel cf, MethodModel m) {\n+        return cf.thisClass().asInternalName() + '#'\n+                + m.methodName().stringValue() + ' '\n+                + m.methodType().stringValue();\n@@ -191,9 +201,13 @@\n-    private static boolean csmWithCallerParameter(ClassFile cf, Method csm, Method m) {\n-        ConstantPool cp = cf.constant_pool;\n-        try {\n-            int csmParamCount = csm.descriptor.getParameterCount(cp);\n-            int paramCount = m.descriptor.getParameterCount(cp);\n-            \/\/ an adapter method must have the same name and return type and a trailing Class parameter\n-            if (!(csm.getName(cp).equals(m.getName(cp)) &&\n-                    paramCount == (csmParamCount+1) &&\n-                    m.descriptor.getReturnType(cp).equals(csm.descriptor.getReturnType(cp)))) {\n+    private static boolean csmWithCallerParameter(ClassModel cf, MethodModel csm, MethodModel m) {\n+        var csmType = csm.methodTypeSymbol();\n+        var mType = m.methodTypeSymbol();\n+        \/\/ an adapter method must have the same name and return type and a trailing Class parameter\n+        if (!(csm.methodName().equals(m.methodName()) &&\n+                mType.parameterCount() == (csmType.parameterCount() + 1) &&\n+                mType.returnType().equals(csmType.returnType()))) {\n+            return false;\n+        }\n+        \/\/ the descriptor of the adapter method must have the parameters\n+        \/\/ of the caller-sensitive method and an additional Class parameter\n+        for (int i = 0; i < csmType.parameterCount(); i++) {\n+            if (mType.parameterType(i) != csmType.parameterType(i)) {\n@@ -202,23 +216,0 @@\n-            \/\/ the descriptor of the adapter method must have the parameters\n-            \/\/ of the caller-sensitive method and an additional Class parameter\n-            String csmDesc = csm.descriptor.getParameterTypes(cp);\n-            String desc = m.descriptor.getParameterTypes(cp);\n-            int index = desc.indexOf(\", java.lang.Class)\");\n-            if (index == -1) {\n-                index = desc.indexOf(\"java.lang.Class)\");\n-                if (index == -1) return false;\n-            }\n-            String s = desc.substring(0, index) + \")\";\n-            if (s.equals(csmDesc)) {\n-                if (!m.access_flags.is(ACC_PRIVATE)) {\n-                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n-                            methodSignature(cf, csm) + \" must be private\");\n-                }\n-                if (!isCallerSensitiveAdapter(m, cp)) {\n-                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n-                            methodSignature(cf, csm) + \" must be annotated with @CallerSensitiveAdapter\");\n-                }\n-                return true;\n-            }\n-        } catch (ConstantPoolException|Descriptor.InvalidDescriptor e) {\n-            throw new RuntimeException(e);\n@@ -226,1 +217,14 @@\n-        return false;\n+\n+        if (!mType.parameterType(mType.parameterCount() - 1).equals(CD_Class)) {\n+            return false;\n+        }\n+\n+        if (!m.flags().has(AccessFlag.PRIVATE)) {\n+            throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                    methodSignature(cf, csm) + \" must be private\");\n+        }\n+        if (!isCallerSensitiveAdapter(m)) {\n+            throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                    methodSignature(cf, csm) + \" must be annotated with @CallerSensitiveAdapter\");\n+        }\n+        return true;\n@@ -234,2 +238,2 @@\n-    private static boolean isCallerSensitive(Method m, ConstantPool cp)\n-        throws ConstantPoolException\n+    private static boolean isCallerSensitive(MethodModel m)\n+        throws IllegalArgumentException\n@@ -237,2 +241,1 @@\n-        RuntimeAnnotations_attribute attr =\n-            (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeVisibleAnnotations);\n+        var attr = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n@@ -240,4 +243,2 @@\n-            for (int i = 0; i < attr.annotations.length; i++) {\n-                Annotation ann = attr.annotations[i];\n-                String annType = cp.getUTF8Value(ann.type_index);\n-                if (CALLER_SENSITIVE_ANNOTATION.equals(annType)) {\n+            for (var ann : attr.annotations()) {\n+                if (ann.className().equalsString(CALLER_SENSITIVE_ANNOTATION)) {\n@@ -251,5 +252,3 @@\n-    private static boolean isCallerSensitiveAdapter(Method m, ConstantPool cp)\n-            throws ConstantPoolException\n-    {\n-        RuntimeAnnotations_attribute attr =\n-                (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeInvisibleAnnotations);\n+    private static boolean isCallerSensitiveAdapter(MethodModel m) {\n+        var attr = m.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n+\n@@ -257,4 +256,2 @@\n-            for (int i = 0; i < attr.annotations.length; i++) {\n-                Annotation ann = attr.annotations[i];\n-                String annType = cp.getUTF8Value(ann.type_index);\n-                if (CALLER_SENSITIVE_ADAPTER_ANNOTATION.equals(annType)) {\n+            for (var ann : attr.annotations()) {\n+                if (ann.className().equalsString(CALLER_SENSITIVE_ADAPTER_ANNOTATION)) {\n@@ -268,4 +265,2 @@\n-    private static boolean isStaticOrFinal(ClassFile cf, Method m, ConstantPool cp)\n-        throws ConstantPoolException\n-    {\n-        if (!isCallerSensitive(m, cp))\n+    private static boolean isStaticOrFinal(ClassModel cf, MethodModel m) {\n+        if (!isCallerSensitive(m))\n@@ -275,3 +270,3 @@\n-        return m.access_flags.is(AccessFlags.ACC_STATIC) ||\n-               m.access_flags.is(AccessFlags.ACC_FINAL) ||\n-               cf.access_flags.is(AccessFlags.ACC_FINAL);\n+        return m.flags().has(AccessFlag.STATIC) ||\n+               m.flags().has(AccessFlag.FINAL) ||\n+               cf.flags().has(AccessFlag.FINAL);\n@@ -291,2 +286,3 @@\n-                try (InputStream is = Files.newInputStream(p)) {\n-                    finder.parse(ClassFile.read(is));\n+                try {\n+                    var clz = ClassFile.of().parse(p); \/\/ propagate IllegalArgumentException\n+                    check(clz);\n@@ -295,2 +291,0 @@\n-                } catch (ConstantPoolException x) {\n-                    throw new RuntimeException(x);\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CheckCSMs.java","additions":120,"deletions":126,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.jdeps\n+ * @enablePreview\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/MissingCallerSensitive.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.time.Instant;\n@@ -29,1 +30,1 @@\n-import java.util.concurrent.atomic.AtomicLong;\n+import java.util.Collections;\n@@ -109,2 +110,2 @@\n-        AtomicLong outerCount = new AtomicLong();\n-        AtomicLong innerCount = new AtomicLong();\n+        List<String> outerStream = Collections.synchronizedList(new ArrayList<>());\n+        List<String> innerStream = Collections.synchronizedList(new ArrayList<>());\n@@ -112,1 +113,1 @@\n-            outer.onEvent(e -> outerCount.incrementAndGet());\n+            outer.onEvent(e -> outerStream.add(eventToText(e)));\n@@ -122,1 +123,1 @@\n-                inner.onEvent(e -> innerCount.incrementAndGet());\n+                inner.onEvent(e -> innerStream.add(eventToText(e)));\n@@ -141,1 +142,1 @@\n-                System.out.println(\"RecordingStream outer:\");\n+                System.out.println(\"Outer dump:\");\n@@ -143,2 +144,4 @@\n-                System.out.println(dumpOuter);\n-                System.out.println(\"RecordingStream inner:\");\n+                for (RecordedEvent e : dumpOuter) {\n+                    System.out.println(eventToText(e));\n+                }\n+                System.out.println(\"Inner dump:\");\n@@ -146,3 +149,12 @@\n-                System.out.println(dumpInner);\n-                System.out.println(\"Outer count: \" + outerCount);\n-                System.out.println(\"Inner count: \" + innerCount);\n+                for (RecordedEvent e : dumpInner) {\n+                    System.out.println(eventToText(e));\n+                }\n+                System.out.println();\n+                System.out.println(\"Outer stream:\");\n+                for (String s : outerStream) {\n+                    System.out.println(s);\n+                }\n+                System.out.println(\"Inner stream:\");\n+                for (String s : innerStream) {\n+                    System.out.println(s);\n+                }\n@@ -152,1 +164,1 @@\n-                if (outerCount.get() != 3) {\n+                if (outerStream.size() != 3) {\n@@ -158,1 +170,1 @@\n-                if (innerCount.get() != 1) {\n+                if (innerStream.size() != 1) {\n@@ -165,0 +177,8 @@\n+    private static String eventToText(RecordedEvent event) {\n+        Instant timestamp = event.getEndTime();\n+        long s = timestamp.getEpochSecond();\n+        int n = timestamp.getNano();\n+        String id = event.getString(\"id\");\n+        return id + \": n=\" + n + \" s=\" + s + \" t=\" + timestamp;\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestStop.java","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -38,0 +37,6 @@\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -43,0 +48,1 @@\n+import java.util.stream.Stream;\n@@ -44,1 +50,5 @@\n-\/**\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+\n+\/*\n@@ -53,2 +63,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          jdk.jfr\n+ * @modules jdk.jfr\n+ * @enablePreview\n@@ -67,1 +77,1 @@\n-    private static final String TEST_CASE_CLASS_NAME = TestCase.class.getName().replace('.', '\/');\n+    private static final ClassDesc CD_TestCase = TestCase.class.describeConstable().orElseThrow();\n@@ -103,2 +113,2 @@\n-            if (caller.className.equals(TEST_CASE_CLASS_NAME) && (callee.className.equals(TEST_CASE_CLASS_NAME)\n-                    || (callee.className.equals(\"java\/lang\/Object\") && callee.methodName.equals(\"<init>\")))) {\n+            if (caller.className.equals(CD_TestCase) && (callee.className.equals(CD_TestCase)\n+                    || (callee.className.equals(CD_Object) && callee.methodName.equals(INIT_NAME)))) {\n@@ -135,1 +145,1 @@\n-        String internalClassName = method.getType().getName().replace('.', '\/');\n+        ClassDesc classDesc = ClassDesc.of(method.getType().getName());\n@@ -137,2 +147,2 @@\n-        String methodDescriptor = method.getValue(\"descriptor\");\n-        return new MethodDesc(internalClassName, methodName, methodDescriptor);\n+        MethodTypeDesc methodDescriptor = MethodTypeDesc.ofDescriptor(method.getValue(\"descriptor\"));\n+        return new MethodDesc(classDesc, methodName, methodDescriptor);\n@@ -142,1 +152,1 @@\n-        String internalClassName = ciMethod.getValue(\"type\");\n+        ClassDesc classDesc = ClassDesc.ofInternalName(ciMethod.getValue(\"type\"));\n@@ -144,2 +154,2 @@\n-        String methodDescriptor = ciMethod.getValue(\"descriptor\");\n-        return new MethodDesc(internalClassName, methodName, methodDescriptor);\n+        MethodTypeDesc methodDescriptor = MethodTypeDesc.ofDescriptor(ciMethod.getValue(\"descriptor\"));\n+        return new MethodDesc(classDesc, methodName, methodDescriptor);\n@@ -249,1 +259,1 @@\n-    public final String className;\n+    public final ClassDesc className;\n@@ -251,5 +261,1 @@\n-    public final String descriptor;\n-\n-    public MethodDesc(Class<?> aClass, String methodName, String descriptor) {\n-        this(aClass.getName().replace('.', '\/'), methodName, descriptor);\n-    }\n+    public final MethodTypeDesc descriptor;\n@@ -257,1 +263,1 @@\n-    public MethodDesc(String className, String methodName, String descriptor) {\n+    public MethodDesc(ClassDesc className, String methodName, MethodTypeDesc descriptor) {\n@@ -261,1 +267,1 @@\n-        this.className = className.replace('.', '\/');\n+        this.className = className;\n@@ -267,2 +273,2 @@\n-        Class<?> aClass = executable.getDeclaringClass();\n-        className = Type.getInternalName(aClass).replace('.', '\/');\n+        className = executable.getDeclaringClass().describeConstable().orElseThrow();\n+        ClassDesc retType;\n@@ -270,4 +276,1 @@\n-        if (executable instanceof Constructor<?>) {\n-            methodName = \"<init>\";\n-            descriptor = Type.getConstructorDescriptor((Constructor<?>) executable);\n-        } else {\n+        if (executable instanceof Method method) {\n@@ -275,1 +278,4 @@\n-            descriptor = Type.getMethodDescriptor((Method) executable);\n+            retType = method.getReturnType().describeConstable().orElseThrow();\n+        } else {\n+            methodName = INIT_NAME;\n+            retType = CD_void;\n@@ -278,0 +284,2 @@\n+        descriptor = MethodTypeDesc.of(retType, Stream.of(executable.getParameterTypes())\n+                .map(c -> c.describeConstable().orElseThrow()).toArray(ClassDesc[]::new));\n@@ -364,2 +372,1 @@\n-        ClassWriter cw;\n-        ClassReader cr;\n+        ClassModel clm;\n@@ -367,1 +374,6 @@\n-            cr = new ClassReader(aClass.getName());\n+            var stream = ClassLoader.getSystemResourceAsStream(aClass.getName()\n+                    .replace('.', '\/') + \".class\");\n+            if (stream == null) {\n+                throw new IOException(\"Cannot find class file for \" + aClass.getName());\n+            }\n+            clm = ClassFile.of().parse(stream.readAllBytes());\n@@ -371,10 +383,0 @@\n-        cw = new ClassWriter(cr, 0);\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {\n-            @Override\n-            public MethodVisitor visitMethod(int access, String name, String desc, String descriptor, String[] exceptions) {\n-                System.out.println(\"Method: \" +name);\n-                MethodVisitor mv = super.visitMethod(access, name, desc, descriptor, exceptions);\n-                return new CallTracer(aClass, name, desc, mv, calls);\n-            }\n-        };\n-        cr.accept(cv, 0);\n@@ -382,0 +384,23 @@\n+        clm.methods().forEach(mm -> {\n+            System.out.println(\"Method: \" + mm.methodName().stringValue());\n+            mm.code().ifPresent(com -> {\n+                MethodDesc caller = new MethodDesc(\n+                        clm.thisClass().asSymbol(),\n+                        mm.methodName().stringValue(),\n+                        mm.methodTypeSymbol()\n+                );\n+                int offset = 0;\n+                for (var ce : com.elements()) {\n+                    if (ce instanceof Instruction ins) {\n+                        if (ins instanceof InvokeInstruction inv) {\n+                            calls.add(new Call(caller, new MethodDesc(\n+                                    inv.owner().asSymbol(),\n+                                    inv.name().stringValue(),\n+                                    inv.typeSymbol()\n+                            ), offset));\n+                        }\n+                        offset += ins.sizeInBytes();\n+                    }\n+                }\n+            });\n+        });\n@@ -384,19 +409,0 @@\n-\n-    private static class CallTracer extends MethodVisitor {\n-        private final MethodDesc caller;\n-        private Collection<Call> calls;\n-\n-        public CallTracer(Class<?> aClass, String name, String desc, MethodVisitor mv, Collection<Call> calls) {\n-            super(Opcodes.ASM7, mv);\n-            caller = new MethodDesc(aClass.getName(), name, desc);\n-            this.calls = calls;\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-            Label label = new Label();\n-            visitLabel(label);\n-            super.visitMethodInsn(opcode, owner, name, desc, itf);\n-            calls.add(new Call(caller, new MethodDesc(owner, name, desc), label.getOffset()));\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerInlining.java","additions":67,"deletions":61,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,8 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +42,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -35,6 +45,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -44,0 +48,3 @@\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+\n@@ -51,2 +58,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.instrument\n+ * @modules java.instrument\n@@ -55,0 +61,2 @@\n+ * @enablePreview\n+ * @comment update --enable-preview in launchTest() too\n@@ -93,1 +101,1 @@\n-    private static final String[] instrMethodKeys = {\n+    private static final Set<MethodKey> instrMethodKeys = Stream.of(\n@@ -119,11 +127,5 @@\n-        \"sun\/nio\/ch\/FileChannelImpl::write::(Ljava\/nio\/ByteBuffer;)I\",\n-    };\n-\n-    private static String getInstrMethodKey(String className, String methodName, String signature) {\n-        \/\/ This key is used to identify a class and method. It is sent to callback(key)\n-        return className + \"::\" + methodName + \"::\" + signature;\n-    }\n-\n-    private static String getClassFromMethodKey(String methodKey) {\n-        return methodKey.split(\"::\")[0];\n-    }\n+        \"sun\/nio\/ch\/FileChannelImpl::write::(Ljava\/nio\/ByteBuffer;)I\"\n+    ).map(s -> {\n+        String[] a = s.split(\"::\");\n+        return new MethodKey(a[0], a[1], a[2]);\n+    }).collect(Collectors.toUnmodifiableSet());\n@@ -132,1 +134,1 @@\n-    private static Set<String> instrClassesTarget = null;\n+    private static Set<ClassDesc> instrClassesTarget = null;\n@@ -135,1 +137,1 @@\n-    private static Set<String> instrClassesDone = null;\n+    private static Set<ClassDesc> instrClassesDone = null;\n@@ -139,5 +141,4 @@\n-        instrClassesTarget = new HashSet<String>();\n-        instrClassesDone = new HashSet<String>();\n-        for (String s : instrMethodKeys) {\n-            String className = getClassFromMethodKey(s);\n-            instrClassesTarget.add(className);\n+        instrClassesTarget = new HashSet<>();\n+        instrClassesDone = new HashSet<>();\n+        for (MethodKey key : instrMethodKeys) {\n+            instrClassesTarget.add(key.owner());\n@@ -167,3 +168,4 @@\n-            Set<Class<?>> classes = new HashSet<Class<?>>();\n-            for (String className : instrClassesTarget) {\n-                Class<?> clazz = Class.forName(className.replaceAll(\"\/\", \".\"));\n+            Set<Class<?>> classes = new HashSet<>();\n+            for (ClassDesc className : instrClassesTarget) {\n+                var desc = className.descriptorString();\n+                Class<?> clazz = Class.forName(desc.substring(1, desc.length() - 1).replace('\/', '.'));\n@@ -200,2 +202,2 @@\n-                for (String key : instrMethodKeys) {\n-                    boolean gotCallback = callbackKeys.contains(key);\n+                for (MethodKey key : instrMethodKeys) {\n+                    boolean gotCallback = callbackKeys.contains(key.toString());\n@@ -203,1 +205,1 @@\n-                    String msg = String.format(\"key:%s, expects:%b\", key, expectsCallback);\n+                    String msg = String.format(\"status:%s, key:%s, expects:%b\", status, key, expectsCallback);\n@@ -217,1 +219,1 @@\n-        private static boolean isClassInstrumented(TransformStatus status, String key) throws Throwable {\n+        private static boolean isClassInstrumented(TransformStatus status, MethodKey key) throws Throwable {\n@@ -224,1 +226,1 @@\n-                String className = getClassFromMethodKey(key);\n+                var className = key.owner();\n@@ -282,1 +284,1 @@\n-            \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+            \"--enable-preview\",\n@@ -308,1 +310,2 @@\n-        if (!instrClassesTarget.contains(className)) {\n+        ClassDesc target = ClassDesc.ofInternalName(className);\n+        if (!instrClassesTarget.contains(target)) {\n@@ -315,23 +318,17 @@\n-        ClassReader reader = new ClassReader(bytes);\n-        ClassWriter writer = new ClassWriter(\n-                reader, ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n-        CallbackClassVisitor classVisitor = new CallbackClassVisitor(writer);\n-        reader.accept(classVisitor, 0);\n-        instrClassesDone.add(className);\n-        return writer.toByteArray();\n-    }\n-\n-    private static class CallbackClassVisitor extends ClassVisitor {\n-        private String className;\n-\n-        public CallbackClassVisitor(ClassVisitor cv) {\n-            super(Opcodes.ASM7, cv);\n-        }\n-\n-        @Override\n-        public void visit(\n-                int version, int access, String name, String signature,\n-                String superName, String[] interfaces) {\n-            cv.visit(version, access, name, signature, superName, interfaces);\n-            className = name;\n-        }\n+        instrClassesDone.add(target);\n+        var cf = ClassFile.of();\n+        return cf.transform(cf.parse(bytes), (clb, ce) -> {\n+            MethodKey key;\n+            if (ce instanceof MethodModel mm && instrMethodKeys.contains(key = new MethodKey(\n+                    target, mm.methodName().stringValue(), mm.methodTypeSymbol()))) {\n+                clb.transformMethod(mm, MethodTransform.transformingCode(new CodeTransform() {\n+                    private static final MethodTypeDesc MTD_callback = MethodTypeDesc.of(CD_void, CD_String);\n+                    private static final ClassDesc CD_InstrumentationCallback = InstrumentationCallback.class\n+                            .describeConstable().orElseThrow();\n+\n+                    @Override\n+                    public void atStart(CodeBuilder cb) {\n+                        cb.loadConstant(key.toString());\n+                        cb.invokestatic(CD_InstrumentationCallback, \"callback\", MTD_callback);\n+                        log(\"instrumented \" + key);\n+                    }\n@@ -339,9 +336,7 @@\n-        @Override\n-        public MethodVisitor visitMethod(\n-                int access, String methodName, String desc, String signature, String[] exceptions) {\n-            String methodKey = getInstrMethodKey(className, methodName, desc);\n-            boolean isInstrumentedMethod = Arrays.asList(instrMethodKeys).contains(methodKey);\n-            MethodVisitor mv = cv.visitMethod(access, methodName, desc, signature, exceptions);\n-            if (isInstrumentedMethod && mv != null) {\n-                mv = new CallbackMethodVisitor(mv, methodKey);\n-                log(\"instrumented \" + methodKey);\n+                    @Override\n+                    public void accept(CodeBuilder cb, CodeElement ce) {\n+                        cb.with(ce);\n+                    }\n+                }));\n+            } else {\n+                clb.with(ce);\n@@ -349,2 +344,1 @@\n-            return mv;\n-        }\n+        });\n@@ -353,6 +347,3 @@\n-    public static class CallbackMethodVisitor extends MethodVisitor {\n-        private String logMessage;\n-\n-        public CallbackMethodVisitor(MethodVisitor mv, String logMessage) {\n-            super(Opcodes.ASM7, mv);\n-            this.logMessage = logMessage;\n+    public record MethodKey(ClassDesc owner, String name, MethodTypeDesc desc) {\n+        public MethodKey(String className, String methodName, String signature) {\n+            this(ClassDesc.ofInternalName(className), methodName, MethodTypeDesc.ofDescriptor(signature));\n@@ -362,6 +353,3 @@\n-        public void visitCode() {\n-            mv.visitCode();\n-            String methodDescr = Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(String.class));\n-            String className = InstrumentationCallback.class.getName().replace('.', '\/');\n-            mv.visitLdcInsn(logMessage);\n-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, \"callback\", methodDescr);\n+        public String toString() {\n+            var ownerDesc = owner.descriptorString();\n+            return ownerDesc.substring(1, ownerDesc.length() - 1) + \"::\" + name + \"::\" + desc.descriptorString();\n@@ -370,1 +358,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestInstrumentation.java","additions":72,"deletions":85,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,7 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.constant.ClassDesc;\n@@ -32,7 +39,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-\n@@ -44,0 +44,3 @@\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+\n@@ -51,2 +54,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          jdk.jartool\/sun.tools.jar\n+ * @modules jdk.jartool\/sun.tools.jar\n+ * @enablePreview\n@@ -102,0 +105,3 @@\n+        private static final ClassDesc CD_InstrumentationEventCallback = InstrumentationEventCallback.class\n+                .describeConstable().orElseThrow();\n+\n@@ -112,7 +118,19 @@\n-                ClassReader reader = new ClassReader(bytes);\n-                ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\n-                CallbackClassVisitor classVisitor = new CallbackClassVisitor(writer);\n-\n-                \/\/ visit the reader's class by the classVisitor\n-                reader.accept(classVisitor, 0);\n-                result = writer.toByteArray();\n+                var cf = ClassFile.of();\n+                result = cf.transform(cf.parse(bytes), (clb, ce) -> {\n+                    if (ce instanceof MethodModel mm && mm.methodName().equalsString(INIT_NAME)) {\n+                        clb.transformMethod(mm, MethodTransform.transformingCode(new CodeTransform() {\n+                            @Override\n+                            public void atStart(CodeBuilder cb) {\n+                                cb.invokestatic(CD_InstrumentationEventCallback, \"callback\", MTD_void);\n+                                log(\"instrumented <init> in class \" + className);\n+                            }\n+\n+                            @Override\n+                            public void accept(CodeBuilder cb, CodeElement ce) {\n+                                cb.accept(ce);\n+                            }\n+                        }));\n+                    } else {\n+                        clb.with(ce);\n+                    }\n+                });\n@@ -126,44 +144,0 @@\n-\n-        private static class CallbackClassVisitor extends ClassVisitor {\n-            private String className;\n-\n-            public CallbackClassVisitor(ClassVisitor cv) {\n-                super(Opcodes.ASM7, cv);\n-            }\n-\n-            @Override\n-            public void visit(int version, int access, String name, String signature,\n-                              String superName, String[] interfaces) {\n-                \/\/ visit the header of the class - called per class header visit\n-                cv.visit(version, access, name, signature, superName, interfaces);\n-                className = name;\n-            }\n-\n-            @Override\n-            public MethodVisitor visitMethod(\n-                                             int access, String methodName, String desc,\n-                                             String signature, String[] exceptions) {\n-                \/\/ called for each method in a class\n-                boolean isInstrumentedMethod = methodName.contains(\"<init>\");\n-                MethodVisitor mv = cv.visitMethod(access, methodName, desc, signature, exceptions);\n-                if (isInstrumentedMethod) {\n-                    mv = new CallbackMethodVisitor(mv);\n-                    log(\"instrumented <init> in class \" + className);\n-                }\n-                return mv;\n-            }\n-        }\n-\n-        public static class CallbackMethodVisitor extends MethodVisitor {\n-            public CallbackMethodVisitor(MethodVisitor mv) {\n-                super(Opcodes.ASM7, mv);\n-            }\n-\n-            @Override\n-            public void visitCode() {\n-                mv.visitCode();\n-                String methodDescr = Type.getMethodDescriptor(Type.VOID_TYPE, Type.VOID_TYPE);\n-                String className = InstrumentationEventCallback.class.getName().replace('.', '\/');\n-                mv.visitMethodInsn(Opcodes.INVOKESTATIC, className, \"callback\", \"()V\", false);\n-            }\n-        }\n","filename":"test\/jdk\/jdk\/jfr\/javaagent\/TestEventInstrumentation.java","additions":35,"deletions":61,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n- *    java.base\/jdk.internal.org.objectweb.asm\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLargeJavaEvent512k.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n- *    java.base\/jdk.internal.org.objectweb.asm\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLargeJavaEvent64k.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                b.invokeInstruction(opcode, i.owner().asSymbol(),\n+                b.invoke(opcode, i.owner().asSymbol(),\n","filename":"test\/jdk\/jdk\/lambda\/separate\/ClassToInterfaceConverter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -514,0 +514,22 @@\n+\/*\n+ * @test id=globalsignr46\n+ * @bug 8316138\n+ * @summary Interoperability tests with GlobalSign Root R46\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n+ *\/\n+\n+\/*\n+ * @test id=globalsigne46\n+ * @bug 8316138\n+ * @summary Interoperability tests with GlobalSign Root E46\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException ValidatePathWithURL CAInterop\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n+ * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n+ *\/\n+\n@@ -683,0 +705,7 @@\n+            case \"globalsignr46\" ->\n+                    new CATestURLs(\"https:\/\/valid.r46.roots.globalsign.com\",\n+                            \"https:\/\/revoked.r46.roots.globalsign.com\");\n+            case \"globalsigne46\" ->\n+                    new CATestURLs(\"https:\/\/valid.e46.roots.globalsign.com\",\n+                            \"https:\/\/revoked.e46.roots.globalsign.com\");\n+\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @summary Http keep-alive implementation is not efficient\n@@ -29,1 +30,0 @@\n- * @summary Http keep-alive implementation is not efficient\n@@ -45,0 +45,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -51,0 +52,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -52,1 +55,1 @@\n- * The http client makes a connection to a URL whos content contains a lot of\n+ * The http client makes a connection to a URL whose content contains a lot of\n@@ -66,5 +69,1 @@\n-\n-    public static void main(String[] args) {\n-        startHttpServer();\n-        clientHttpCalls();\n-    }\n+    static ExecutorService executor = Executors.newSingleThreadExecutor();\n@@ -74,3 +73,1 @@\n-            server = HttpServer.create(new InetSocketAddress(InetAddress.getLocalHost(), 0), 10, \"\/\", new SimpleHttpTransactionHandler());\n-            server.setExecutor(Executors.newSingleThreadExecutor());\n-            server.start();\n+            server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 10, \"\/\", new SimpleHttpTransactionHandler());\n@@ -78,1 +75,1 @@\n-            e.printStackTrace();\n+            throw new RuntimeException(e);\n@@ -80,0 +77,3 @@\n+        server.setExecutor(executor);\n+        server.start();\n+        System.out.println(\"http server listens on: \" + server.getAddress());\n@@ -82,1 +82,6 @@\n-    public static void clientHttpCalls() {\n+    public static void stopHttpServer() {\n+        server.stop(1);\n+        executor.shutdown();\n+    }\n+\n+    public static void clientHttpCalls() throws Exception {\n@@ -87,5 +92,0 @@\n-        try {\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr =  InetAddress.getLocalHost().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n@@ -93,2 +93,13 @@\n-            URL bigDataURL = new URL (baseURLStr + \"firstCall\");\n-            URL smallDataURL = new URL (baseURLStr + \"secondCall\");\n+        URL bigDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/firstCall\")\n+                .toURL();\n+\n+        URL smallDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/secondCall\")\n+                .toURL();\n@@ -96,1 +107,1 @@\n-            HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n+        HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n@@ -98,2 +109,2 @@\n-            \/\/Only read 1 byte of response data and close the stream\n-            InputStream is = uc.getInputStream();\n+        \/\/ Only read 1 byte of response data and close the stream\n+        try (InputStream is = uc.getInputStream()) {\n@@ -102,41 +113,45 @@\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n-            uc.getResponseCode();\n-\n-            if (SimpleHttpTransactionHandler.failed)\n-                throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n-\n-            \/\/ Part 2\n-            URL part2Url = new URL (baseURLStr + \"part2\");\n-            uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n-            is = uc.getInputStream();\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n-            if (threadMXBean.isThreadCpuTimeSupported()) {\n-                long[] threads = threadMXBean.getAllThreadIds();\n-                ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n-                for (int i=0; i<threadInfo.length; i++) {\n-                    if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\"))  {\n-                        System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n-                        long threadID = threadInfo[i].getThreadId();\n-                        long before = threadMXBean.getThreadCpuTime(threadID);\n-                        try { Thread.sleep(2000); } catch (Exception e) {}\n-                        long after = threadMXBean.getThreadCpuTime(threadID);\n-\n-                        if (before ==-1 || after == -1)\n-                            break;  \/\/ thread has died, OK\n-\n-                        \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n-                        \/\/ can assume a recursive loop.\n-                        long total = after - before;\n-                        if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n-                            throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n-                    }\n+        }\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n+        uc.getResponseCode();\n+\n+        if (SimpleHttpTransactionHandler.failed)\n+            throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n+\n+        \/\/ Part 2\n+        URL part2Url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/part2\")\n+                .toURL();\n+\n+        uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n+        try (InputStream is = uc.getInputStream()) {}\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n+        if (threadMXBean.isThreadCpuTimeSupported()) {\n+            long[] threads = threadMXBean.getAllThreadIds();\n+            ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n+            for (int i = 0; i < threadInfo.length; i++) {\n+                if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\")) {\n+                    System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n+                    long threadID = threadInfo[i].getThreadId();\n+                    long before = threadMXBean.getThreadCpuTime(threadID);\n+                    try { Thread.sleep(2000); } catch (Exception e) {}\n+                    long after = threadMXBean.getThreadCpuTime(threadID);\n+\n+                    if (before ==-1 || after == -1)\n+                        break;  \/\/ thread has died, OK\n+\n+                    \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n+                    \/\/ can assume a recursive loop.\n+                    long total = after - before;\n+                    if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n+                        throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n@@ -145,5 +160,0 @@\n-\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        } finally {\n-            server.stop(1);\n@@ -155,1 +165,0 @@\n-}\n@@ -157,3 +166,2 @@\n-class SimpleHttpTransactionHandler implements HttpHandler\n-{\n-    static volatile boolean failed = false;\n+    static class SimpleHttpTransactionHandler implements HttpHandler {\n+        static volatile boolean failed = false;\n@@ -161,3 +169,3 @@\n-    \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n-    \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n-    static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n+        \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n+        \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n+        static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n@@ -165,1 +173,1 @@\n-    int port1;\n+        int port1;\n@@ -167,12 +175,36 @@\n-    public void handle(HttpExchange trans) {\n-        try {\n-            String path = trans.getRequestURI().getPath();\n-            if (path.equals(\"\/firstCall\")) {\n-                port1 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"First connection on client port = \" + port1);\n-\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                trans.sendResponseHeaders(200, responseBody.length);\n-                try (OutputStream os = trans.getResponseBody()) {\n+        public void handle(HttpExchange trans) {\n+            try {\n+                String path = trans.getRequestURI().getPath();\n+                if (path.equals(\"\/firstCall\")) {\n+                    port1 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"First connection on client port = \" + port1);\n+\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    trans.sendResponseHeaders(200, responseBody.length);\n+                    try (OutputStream os = trans.getResponseBody()) {\n+                        os.write(responseBody);\n+                    }\n+                } else if (path.equals(\"\/secondCall\")) {\n+                    int port2 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"Second connection on client port = \" + port2);\n+\n+                    if (port1 != port2)\n+                        failed = true;\n+\n+                     \/* Force the server to not respond for more that the timeout\n+                      * set by the keepalive cleaner (5000 millis). This ensures the\n+                      * timeout is correctly resets the default read timeout,\n+                      * infinity. See 6993490. *\/\n+                    System.out.println(\"server sleeping...\");\n+                    try {Thread.sleep(6000); } catch (InterruptedException e) {}\n+                    trans.sendResponseHeaders(200, -1);\n+                } else if (path.equals(\"\/part2\")) {\n+                    System.out.println(\"Call to \/part2\");\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    \/\/ override the Content-length header to be greater than the actual response body\n+                    trans.sendResponseHeaders(200, responseBody.length+1);\n+                    OutputStream os = trans.getResponseBody();\n@@ -180,0 +212,3 @@\n+                    \/\/ now close the socket\n+                    \/\/ closing the stream here would throw; close the exchange instead\n+                    trans.close();\n@@ -181,26 +216,3 @@\n-            } else if (path.equals(\"\/secondCall\")) {\n-                int port2 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"Second connection on client port = \" + port2);\n-\n-                if (port1 != port2)\n-                    failed = true;\n-\n-                 \/* Force the server to not respond for more that the timeout\n-                  * set by the keepalive cleaner (5000 millis). This ensures the\n-                  * timeout is correctly resets the default read timeout,\n-                  * infinity. See 6993490. *\/\n-                System.out.println(\"server sleeping...\");\n-                try {Thread.sleep(6000); } catch (InterruptedException e) {}\n-                trans.sendResponseHeaders(200, -1);\n-            } else if(path.equals(\"\/part2\")) {\n-                System.out.println(\"Call to \/part2\");\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                \/\/ override the Content-length header to be greater than the actual response body\n-                trans.sendResponseHeaders(200, responseBody.length+1);\n-                OutputStream os = trans.getResponseBody();\n-                os.write(responseBody);\n-                \/\/ now close the socket\n-                \/\/ closing the stream here would throw; close the exchange instead\n-                trans.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                failed = true;\n@@ -208,2 +220,9 @@\n-        } catch (Exception e) {\n-            e.printStackTrace();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        startHttpServer();\n+        try {\n+            clientHttpCalls();\n+        } finally {\n+            stopHttpServer();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B5045306.java","additions":136,"deletions":117,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 timeout\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 max\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637\n@@ -34,1 +34,4 @@\n-import java.net.*;\n+import java.net.HttpURLConnection;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n@@ -38,0 +41,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -41,3 +46,1 @@\n-    static class Server extends Thread {\n-        final ServerSocket serverSocket;\n-        final int port;\n+    static class Server extends Thread implements AutoCloseable {\n@@ -45,0 +48,2 @@\n+        final ServerSocket serverSocket = new ServerSocket(0);\n+        final int port;\n@@ -48,1 +53,1 @@\n-            serverSocket = new ServerSocket(0);\n+            this.param = param;\n@@ -51,1 +56,0 @@\n-            this.param = param;\n@@ -58,6 +62,4 @@\n-        public void close() {\n-            try {\n-                serverSocket.close();\n-                if (s != null)\n-                    s.close();\n-            } catch (IOException e) {}\n+        public void close() throws IOException {\n+            serverSocket.close();\n+            if (s != null)\n+                s.close();\n@@ -128,15 +130,13 @@\n-    public static void main(String[] args) throws Exception {\n-        Server server = new Server(args[0]);\n-        int port = server.getPort();\n-        server.start();\n-        URL url = new URL(\"http:\/\/127.0.0.1:\" + Integer.toString(port) + \"\/\");\n-        HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n-        InputStream i = urlc.getInputStream();\n-        int c,count=0;\n-        byte[] buf = new byte[256];\n-        while ((c=i.read(buf)) != -1) {\n-            count+=c;\n-        }\n-        i.close();\n-        System.out.println(\"Read \" + count );\n-        try {\n+    public static void runTest(String param) throws Exception {\n+        try (Server server = new Server(param)) {\n+            server.start();\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getPort())\n+                    .path(\"\/\")\n+                    .toURL();\n+            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n+            try (InputStream i = urlc.getInputStream()) {\n+                System.out.println(\"Read \" + i.readAllBytes().length);\n+            }\n@@ -148,2 +148,0 @@\n-        } finally {\n-            server.close();\n@@ -152,0 +150,5 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(\"timeout\");\n+        runTest(\"max\");\n+    }\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8291637.java","additions":35,"deletions":32,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -29,1 +30,0 @@\n- * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -32,9 +32,0 @@\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import javax.net.ssl.HandshakeCompletedListener;\n-import javax.net.ssl.HttpsURLConnection;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.SSLSocketFactory;\n@@ -56,0 +47,12 @@\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -76,4 +79,1 @@\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr = InetAddress.getLoopbackAddress().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n+            System.out.println(\"http server listens on: \" + server.getAddress().getPort());\n@@ -81,1 +81,5 @@\n-            URL testUrl = new URL (baseURLStr);\n+            URL testUrl = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .toURL();\n@@ -247,0 +251,1 @@\n+            t.getResponseBody().close();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8293562.java","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -28,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -33,4 +33,14 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.charset.*;\n-import java.util.logging.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n@@ -38,0 +48,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -29,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -33,2 +33,11 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+\n@@ -36,0 +45,1 @@\n+\n@@ -134,2 +144,0 @@\n-\n-        grp.destroy();\n@@ -137,1 +145,0 @@\n-\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveTimerThread.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.*;\n+\n+\/**\n+ * @test\n+ * @bug 8328864\n+ * @summary Test that ProviderList.getService checks configs when\n+ * ProviderList.getProvider fails for preferred providers.\n+ * @run main\/othervm\n+ *  -Djava.security.properties=${test.src}\/app-security.properties NullPreferredList\n+ *\/\n+\n+public class NullPreferredList {\n+\n+    public static void main(final String[] args) throws Exception {\n+        final KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        System.out.println(\"Got keystore \" + ks);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/jca\/NullPreferredList.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.security.provider.preferred=KeyStore.PKCS12:NonExistingProvider\n","filename":"test\/jdk\/sun\/security\/jca\/app-security.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- *      8321408\n+ *      8321408 8316138\n@@ -51,1 +51,1 @@\n-    private static final int COUNT = 108;\n+    private static final int COUNT = 110;\n@@ -56,1 +56,1 @@\n-            = \"C4:A2:41:9E:B6:4D:77:26:AA:21:02:83:51:C7:88:21:66:1E:D8:88:4A:AC:84:D5:B0:15:0C:7C:C6:45:85:AF\";\n+            = \"BD:80:65:81:68:E5:6C:51:64:ED:B9:08:53:9F:BB:2F:D9:6C:5D:D4:06:D4:16:59:39:10:8E:F8:24:81:8B:78\";\n@@ -281,0 +281,4 @@\n+            put(\"globalsignr46 [jdk]\",\n+                    \"4F:A3:12:6D:8D:3A:11:D1:C4:85:5A:4F:80:7C:BA:D6:CF:91:9D:3A:5A:88:B0:3B:EA:2C:63:72:D9:3C:40:C9\");\n+            put(\"globalsigne46 [jdk]\",\n+                    \"CB:B9:C4:4D:84:B8:04:3E:10:50:EA:31:A6:9F:51:49:55:D7:BF:D2:E2:C6:B4:93:01:01:9A:D6:1D:9F:50:58\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @key intermittent\n@@ -241,1 +240,1 @@\n-            t.join(1000L);\n+            t.join(4000L);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumptionUpdateBoundValues.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8228969 8244087 8255266 8302182\n+ * @bug 8228969 8244087 8255266 8302182 8331864\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/ParseNames.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,11 @@\n+# newGTLDs\n+\n+# This is not a GTLD\n+www.site.unknown        www.site.unknown    null\n+\n+# GTLD added in 1cbd6e7\n+www.site.wed            wed                 site.wed\n+\n+# GTLD removed in 1cbd6e7\n+www.site.oldnavy        www.site.oldnavy    null\n+\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/tests.dat","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,1 +36,1 @@\n- * @bug 8222491 8273187\n+ * @bug 8222491 8273187 8308033\n@@ -55,1 +57,13 @@\n-        launcher.addToolArg(\"Thread.print\");\n+        boolean isVirtualThread = Thread.currentThread().isVirtual();\n+        Path threadDumpFile = null;\n+        if (isVirtualThread) {\n+            \/\/ \"jcmd Thread.print\" will not print thread dumps of virtual threads.\n+            \/\/ So we use \"Thread.dump_to_file\" command instead and dump the thread\n+            \/\/ stacktraces in a file\n+            threadDumpFile = Files.createTempFile(Path.of(\".\"), \"jcmd\", \".tdump\").toAbsolutePath();\n+            launcher.addToolArg(\"Thread.dump_to_file\");\n+            launcher.addToolArg(\"-overwrite\");\n+            launcher.addToolArg(threadDumpFile.toString());\n+        } else {\n+            launcher.addToolArg(\"Thread.print\");\n+        }\n@@ -61,1 +75,20 @@\n-        output.shouldContain(marker);\n+        if (isVirtualThread) {\n+            \/\/ verify the file containing the thread dump has the expected text\n+            try (var br = Files.newBufferedReader(threadDumpFile, cs)) {\n+                String line = null;\n+                boolean found = false;\n+                while ((line = br.readLine()) != null) {\n+                    if (line.contains(marker)) {\n+                        found = true;\n+                        break;\n+                    }\n+                }\n+                if (!found) {\n+                    output.reportDiagnosticSummary();\n+                    throw new RuntimeException(\"'\" + marker + \"' missing in thread dump in file \"\n+                            + threadDumpFile);\n+                }\n+            }\n+        } else {\n+            output.shouldContain(marker);\n+        }\n","filename":"test\/jdk\/sun\/tools\/jcmd\/JcmdOutputEncodingTest.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -35,1 +37,1 @@\n- * @bug 8273187\n+ * @bug 8273187 8308033\n@@ -45,0 +47,7 @@\n+        if (Thread.currentThread().isVirtual()) {\n+            \/\/ This test runs jstack against the current process and then asserts the\n+            \/\/ presence of current thread in the stacktraces. We skip this test\n+            \/\/ when the current thread is a virtual thread since \"jstack\" command doesn't\n+            \/\/ print the stacktraces of virtual threads.\n+            throw new SkippedException(\"skipping test since current thread is a virtual thread\");\n+        }\n","filename":"test\/jdk\/sun\/tools\/jstack\/BasicJStackTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329691\n+ * @modules java.base\/sun.util.locale.provider\n+ *          java.base\/sun.util.cldr\n+ * @summary Tests CLDR's `nonlikelyScript` attribute is correctly implemented\n+ *      with the CLDRLocaleProviderAdapter\n+ * @run junit NonLikelyScriptTest\n+ *\/\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import sun.util.cldr.CLDRLocaleProviderAdapter;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class NonLikelyScriptTest {\n+    private static final CLDRLocaleProviderAdapter CLDR_LOCALE_PROVIDER_ADAPTER\n+        = (CLDRLocaleProviderAdapter) LocaleProviderAdapter.forType(LocaleProviderAdapter.Type.CLDR);\n+    private static final Locale AZ_ARAB = Locale.forLanguageTag(\"az-Arab\");\n+    private static final Locale AZ_CYRL = Locale.forLanguageTag(\"az-Cyrl\");\n+    private static final Locale AZ_LATN = Locale.forLanguageTag(\"az-Latn\");\n+    private static final Locale AZ_XXXX = Locale.forLanguageTag(\"az-Xxxx\");\n+    private static final Locale RU_LATN = Locale.forLanguageTag(\"ru-Latn\");\n+    private static final Locale RU_CYRL = Locale.forLanguageTag(\"ru-Cyrl\");\n+    private static final Locale RU_XXXX = Locale.forLanguageTag(\"ru-Xxxx\");\n+    private static final Locale EN_LATN = Locale.forLanguageTag(\"en-Latn\");\n+    private static final Locale EN_DSRT = Locale.forLanguageTag(\"en-Dsrt\");\n+    private static final Locale EN_XXXX = Locale.forLanguageTag(\"en-Xxxx\");\n+    private static final Locale ZH_HANT_MO = Locale.forLanguageTag(\"zh-Hant-MO\");\n+    private static final Locale ZH_HANS_SG = Locale.forLanguageTag(\"zh-Hans-SG\");\n+    private static final Locale ZH_HANS = Locale.forLanguageTag(\"zh-Hans\");\n+    private static final Locale ZH_HANT = Locale.forLanguageTag(\"zh-Hant\");\n+    private static final Locale ZH_XXXX = Locale.forLanguageTag(\"zh-Xxxx\");\n+\n+    private static Stream<Arguments> parentLocales() {\n+\n+        return Stream.of(\n+            \/\/ likely script\n+            Arguments.of(AZ_LATN, List.of(AZ_LATN, Locale.of(\"az\"), Locale.ROOT)),\n+            Arguments.of(RU_CYRL, List.of(RU_CYRL, Locale.of(\"ru\"), Locale.ROOT)),\n+            Arguments.of(EN_LATN, List.of(EN_LATN, Locale.ENGLISH, Locale.ROOT)),\n+            Arguments.of(ZH_HANS, List.of(ZH_HANS, Locale.CHINA, Locale.CHINESE, Locale.ROOT)),\n+            Arguments.of(Locale.CHINA, List.of(Locale.forLanguageTag(\"zh-Hans-CN\"), ZH_HANS, Locale.CHINA, Locale.CHINESE, Locale.ROOT)),\n+            Arguments.of(ZH_HANS_SG, List.of(ZH_HANS_SG, ZH_HANS, Locale.forLanguageTag(\"zh-SG\"), Locale.CHINESE, Locale.ROOT)),\n+\n+            \/\/ non-likely script, explicit (as of CLDR 45)\n+            Arguments.of(AZ_ARAB, List.of(AZ_ARAB, Locale.ROOT)),\n+            Arguments.of(AZ_CYRL, List.of(AZ_CYRL, Locale.ROOT)),\n+            Arguments.of(EN_DSRT, List.of(EN_DSRT, Locale.ROOT)),\n+            Arguments.of(ZH_HANT, List.of(ZH_HANT, Locale.ROOT)),\n+            Arguments.of(Locale.TAIWAN, List.of(Locale.forLanguageTag(\"zh-Hant-TW\"), ZH_HANT, Locale.ROOT)),\n+            Arguments.of(ZH_HANT_MO, List.of(ZH_HANT_MO, Locale.forLanguageTag(\"zh-Hant-HK\"), ZH_HANT, Locale.ROOT)),\n+\n+            \/\/ non-likely script, implicit\n+            Arguments.of(AZ_XXXX, List.of(AZ_XXXX, Locale.ROOT)),\n+            Arguments.of(RU_LATN, List.of(RU_LATN, Locale.ROOT)),\n+            Arguments.of(RU_XXXX, List.of(RU_XXXX, Locale.ROOT)),\n+            Arguments.of(EN_XXXX, List.of(EN_XXXX, Locale.ROOT)),\n+            Arguments.of(ZH_XXXX, List.of(ZH_XXXX, Locale.ROOT))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parentLocales\")\n+    public void checkParentLocales(Locale locale, List<Locale> expected) {\n+        var actual = CLDR_LOCALE_PROVIDER_ADAPTER.getCandidateLocales(\"\", locale);\n+        assertEquals(expected, actual);\n+    }\n+}\n","filename":"test\/jdk\/sun\/util\/locale\/provider\/NonLikelyScriptTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.MethodTypeDesc;\n@@ -32,0 +34,1 @@\n+import org.testng.Assert;\n@@ -40,1 +43,4 @@\n- \/*\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+\n+\/*\n@@ -42,1 +48,1 @@\n- * @bug 8252919\n+ * @bug 8252919 8327499\n@@ -125,0 +131,41 @@\n+    @Test\n+    public static void testInvokers() throws IOException {\n+        var fileString = \"[LF_RESOLVE] java.lang.invoke.Invokers$Holder invoker L3I_L (fail)\";\n+        Path invokersTrace = Files.createTempFile(\"invokers\", \"trace\");\n+        Files.writeString(invokersTrace, fileString, Charset.defaultCharset());\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(helper.createNewImageDir(\"jli-invokers\"))\n+                .option(\"--generate-jli-classes=@\" + invokersTrace.toString())\n+                .addMods(\"java.base\")\n+                .call();\n+\n+        var image = result.assertSuccess();\n+        var targetMtd = MethodTypeDesc.of(CD_Object, CD_Object, CD_Object, CD_Object, CD_int);\n+\n+        validateHolderClasses(image);\n+        JImageValidator.validate(image.resolve(\"lib\").resolve(\"modules\"),\n+                List.of(), List.of(), bytes -> {\n+                    var cf = ClassFile.of().parse(bytes);\n+                    if (!cf.thisClass().name().equalsString(\"java\/lang\/invoke\/Invokers$Holder\")) {\n+                        return;\n+                    }\n+\n+                    boolean found = false;\n+                    for (var m : cf.methods()) {\n+                        \/\/ LambdaForm.Kind\n+                        if (m.methodName().equalsString(\"invoker\") && m.methodTypeSymbol().equals(targetMtd)) {\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!found) {\n+                        var methodsInfo = cf.methods().stream()\n+                                .map(m -> m.methodName() + m.methodTypeSymbol().displayDescriptor())\n+                                .collect(Collectors.joining(\"\\n\"));\n+\n+                        Assert.fail(\"Missing invoker L3I_L in java.lang.invoke.Invokers$Holder, found:\\n\" + methodsInfo);\n+                    }\n+                });\n+    }\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/GenerateJLIClassesPluginTest.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -175,0 +176,5 @@\n+        validate(jimage, expectedLocations, unexpectedPaths, _ -> {});\n+    }\n+\n+    public static void validate(Path jimage, List<String> expectedLocations,\n+            List<String> unexpectedPaths, Consumer<byte[]> classChecker) throws IOException {\n@@ -198,0 +204,1 @@\n+                    classChecker.accept(r);\n@@ -225,1 +232,1 @@\n-    public static void readClass(byte[] clazz) throws IOException{\n+    public static void readClass(byte[] clazz) throws IOException {\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageValidator.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+langtools_slow = \\\n+    jdk\/internal\/shellsupport\/doc\/FullJavadocHelperTest.java\n+\n@@ -81,1 +84,2 @@\n-    -:langtools_jshell_unstable\n+    -:langtools_jshell_unstable \\\n+    -:langtools_slow\n@@ -85,1 +89,2 @@\n-    :langtools_jshell_unstable\n+    :langtools_jshell_unstable \\\n+    :langtools_slow\n","filename":"test\/langtools\/TEST.groups","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8189778\n+ * @summary Test JavadocHelper\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/jdk.internal.shellsupport.doc\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @run testng\/timeout=900\/othervm -Xmx1024m FullJavadocHelperTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class FullJavadocHelperTest {\n+\n+    \/*\n+     * Long-running test to retrieve doc comments for enclosed elements of all JDK classes.\n+     *\/\n+    public void testAllDocs() throws IOException {\n+        new JavadocHelperTest().retrieveDocComments(Boolean.TRUE::booleanValue);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/FullJavadocHelperTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n- * @run testng\/timeout=900\/othervm -Xmx1024m JavadocHelperTest\n+ * @run testng JavadocHelperTest\n+ * @key randomness\n@@ -49,0 +50,2 @@\n+import java.util.Random;\n+import java.util.function.BooleanSupplier;\n@@ -386,1 +389,29 @@\n-    public void testAllDocs() throws IOException {\n+    private static long getSeed() {\n+        long seed;\n+        try {\n+            \/\/ Throws NumberFormatException if the property is undefined\n+            seed = Long.parseLong(System.getProperty(\"seed\"));\n+        } catch (NumberFormatException e) {\n+            seed = new Random().nextLong();\n+        }\n+        System.out.println(\"Random Seed: \" + seed);\n+        return seed;\n+    }\n+\n+    \/*\n+     * Retrieves doc comments for a random subset of JDK classes.\n+     * Set the system property `seed` to a random seed to reproduce\n+     * a specific run of this test.\n+     *\/\n+    public void testRandomDocs() throws IOException {\n+        Random random = new Random(getSeed());\n+        \/\/ Run test on 2% of classes, which corresponds to ~ 140 classes\n+        retrieveDocComments(() -> random.nextInt(100) < 2);\n+    }\n+\n+    \/**\n+     * Retrieve documentation of enclosed elements for some or all JDK classes.\n+     *\n+     * @param shouldTest oracle function to decide whether a class should be tested\n+     *\/\n+    protected void retrieveDocComments(BooleanSupplier shouldTest) throws IOException {\n@@ -411,1 +442,1 @@\n-                        compiler.getStandardFileManager(null, null, null)) {\n+                             compiler.getStandardFileManager(null, null, null)) {\n@@ -423,2 +454,4 @@\n-                                    for (Element el : clazz.getEnclosedElements()) {\n-                                        helper.getResolvedDocComment(el);\n+                                    if (shouldTest.getAsBoolean()) {\n+                                        for (Element el : clazz.getEnclosedElements()) {\n+                                            helper.getResolvedDocComment(el);\n+                                        }\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/JavadocHelperTest.java","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8317621\n+ * @summary  --add-script should support JavaScript modules\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestJavaScriptModules\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestJavaScriptModules extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestJavaScriptModules();\n+        tester.setup().runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+    Path src;\n+\n+    TestJavaScriptModules setup() throws IOException {\n+        src = Path.of(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                   \/**\n+                    * Simple dummy class.\n+                    *\/\n+                   public class Test {}\n+                   \"\"\");\n+        tb.writeFile(\"module.mjs\", \"\"\"\n+                   var x = 1;\n+                   \"\"\");\n+        tb.writeFile(\"module1.js\", \"\"\"\n+                   const x = 1;\n+                   export class FooModule {}\n+                   \"\"\");\n+        tb.writeFile(\"module2.js\", \"\"\"\n+                   const x = 1;\n+                   export function f() {}\n+                   \"\"\");\n+        tb.writeFile(\"module3.js\", \"\"\"\n+                       const x = 1;\n+                       export async function a() {}\n+                   \"\"\");\n+        tb.writeFile(\"module4.js\", \"\"\"\n+                   \/\/ Another JS module\n+                   export const c = 3;\n+                   \"\"\");\n+        tb.writeFile(\"module5.js\", \"\"\"\n+                   export default class FooModule {}\n+                   \"\"\");\n+        tb.writeFile(\"module6.js\", \"\"\"\n+                   const x = 1;\n+                   export class FooModule {}\n+                   \"\"\");\n+        tb.writeFile(\"module7.js\", \"\"\"\n+                   function abc() {}\n+                   import * as foo from \"module1.js\";\n+                   \"\"\");\n+        tb.writeFile(\"module8.js\", \"\"\"\n+                   var z = false;\n+                   import { _A_, $b, C0 } from \"abc.js\";\n+                   \"\"\");\n+        tb.writeFile(\"script1.js\", \"\"\"\n+                   var z = false;\n+                   import(1, z);\n+                   \"\"\");\n+        tb.writeFile(\"script2.js\", \"\"\"\n+                   export(\"foo\");\n+                   \"\"\");\n+        tb.writeFile(\"script3.js\", \"\"\"\n+                   var import = 1;\n+                   \"\"\");\n+        return this;\n+    }\n+\n+    @Test\n+    public void test(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--add-script\", \"module.mjs\",\n+                \"--add-script\", \"module1.js\",\n+                \"--add-script\", \"module2.js\",\n+                \"--add-script\", \"module3.js\",\n+                \"--add-script\", \"module4.js\",\n+                \"--add-script\", \"module5.js\",\n+                \"--add-script\", \"module6.js\",\n+                \"--add-script\", \"module7.js\",\n+                \"--add-script\", \"module8.js\",\n+                \"--add-script\", \"script1.js\",\n+                \"--add-script\", \"script2.js\",\n+                \"--add-script\", \"script3.js\",\n+                src.resolve(\"Test.java\").toString());\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"Test.html\", true,\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module.mjs\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module1.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module2.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module3.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module4.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module5.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module6.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module7.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"module\" src=\"script-files\/module8.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"text\/javascript\" src=\"script-files\/script1.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"text\/javascript\" src=\"script-files\/script2.js\"><\/script>\"\"\",\n+                \"\"\"\n+                    <script type=\"text\/javascript\" src=\"script-files\/script3.js\"><\/script>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaScriptModules\/TestJavaScriptModules.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.UnknownInlineTagTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+\n+\/**\n+ * An inline taglet that generates output in a {@code <div>} element.\n+ *\/\n+public class DivTaglet implements Taglet {\n+    @Override\n+    public String getName() {\n+        return \"div\";\n+    }\n+\n+    @Override\n+    public Set<Location> getAllowedLocations() {\n+        return Set.of(Location.values());\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString(List<? extends DocTree> trees, Element e) {\n+        var children = ((UnknownInlineTagTree) trees.get(0)).getContent();\n+        return \"<div>\"\n+                + children.stream().map(DocTree::toString).collect(Collectors.joining())\n+                + \"<\/div>\";\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/DivTaglet.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.UnknownInlineTagTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+\n+\/**\n+ * An inline taglet that generates output in a {@code <span>} element.\n+ *\/\n+public class SpanTaglet implements Taglet {\n+    @Override\n+    public String getName() {\n+        return \"span\";\n+    }\n+\n+    @Override\n+    public Set<Location> getAllowedLocations() {\n+        return Set.of(Location.values());\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString(List<? extends DocTree> trees, Element e) {\n+        var children = ((UnknownInlineTagTree) trees.get(0)).getContent();\n+        return \"<span>\"\n+                + children.stream().map(DocTree::toString).collect(Collectors.joining())\n+                + \"<\/span>\";\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/SpanTaglet.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdown\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestMarkdown extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdown();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testMinimal(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Hello, _Markdown_ world!\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Hello, <em>Markdown<\/em> world!<\/div>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testMarkdownList(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Before list.\n+                    \/\/\/\n+                    \/\/\/ * item 1\n+                    \/\/\/ * item 2\n+                    \/\/\/ * item 3\n+                    \/\/\/\n+                    \/\/\/ After list.\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOrder(\"p\/C.html\",\n+                \"\"\"\n+                    <p>Before list.<\/p>\n+                    <ul>\n+                    <li>item 1<\/li>\n+                    <li>item 2<\/li>\n+                    <li>item 3<\/li>\n+                    <\/ul>\n+                    <p>After list.<\/p>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testMarkdownList2(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Before list.\n+                    \/\/\/\n+                    \/\/\/ - item 1\n+                    \/\/\/ - item 2\n+                    \/\/\/ - item 3\n+                    \/\/\/\n+                    \/\/\/ After list.\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOrder(\"p\/C.html\",\n+                \"\"\"\n+                    <p>Before list.<\/p>\n+                    <ul>\n+                    <li>item 1<\/li>\n+                    <li>item 2<\/li>\n+                    <li>item 3<\/li>\n+                    <\/ul>\n+                    <p>After list.<\/p>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testFont(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Regular, `Monospace`, _italic_, and **bold** font.\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Regular, <code>Monospace<\/code>, <em>italic<\/em>, and <strong>bold<\/strong> font.\"\"\");\n+    }\n+\n+    @Test\n+    public void testFFFC(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence. 1{@code 1}1 \\ufffc 2{@code 2}2\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence. 1<code>1<\/code>1 \\ufffc 2<code>2<\/code>2<\/div>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testEscape(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                \/\/ In the following, note the need to double the escape character,\n+                \/\/ so that the comment contains a single escape to precede the backtick.\n+                \/\/ Also, note that because the first backtick is escaped, the comment\n+                \/\/ is as-if there are two unmatched backticks, with an inline tag\n+                \/\/ between them, and not a code span enclosing literal text.\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Abc \\\\` def {@code xyz} ghi ` jkl.\n+                        \/\/\/ More.\n+                        public void m() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <span class=\"element-name\">m<\/span>()<\/div>\n+                    <div class=\"block\">Abc ` def <code>xyz<\/code> ghi ` jkl.\n+                    More.<\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testBacktickAt(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        \/\/ in the following, note that the @ following the backtick\n+        \/\/ is just a literal character and not part of any tag\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ First sentence.\n+                        \/\/\/ Abc `@' def.\n+                        \/\/\/ More.\n+                        public void m() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:syntax\", \/\/ enable check for \"no tag after '@'\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, false,\n+                \"C.java:4: error: no tag name after '@'\",\n+                \"unknown tag\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence.\n+                    Abc `@' def.\n+                    More.<\/div>\n+                    <\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testAnnos(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        \/\/ in the following, note that the @ following the backtick\n+        \/\/ is just a literal character and not part of any tag\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ First sentence.\n+                        \/\/\/ 1.  list item\n+                        \/\/\/\n+                        \/\/\/     \\\\@Anno1 plain\n+                        \/\/\/\n+                        \/\/\/     abc `\n+                        \/\/\/     @Anno2 in span\n+                        \/\/\/     `\n+                        \/\/\/\n+                        \/\/\/     ```\n+                        \/\/\/     @Anno3 fenced\n+                        \/\/\/     ```\n+                        \/\/\/\n+                        \/\/\/         @Anno4 indented\n+                        \/\/\/\n+                        \/\/\/     end of list item\n+                        \/\/\/\n+                        \/\/\/ end\n+                        public void m() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:syntax\", \/\/ enable check for \"no tag after '@'\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, false,\n+                \"C.java:4: error: no tag name after '@'\",\n+                \"unknown tag\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <ol>\n+                    <li>\n+                    <p>list item<\/p>\n+                    <p>@Anno1 plain<\/p>\n+                    <p>abc <code>@Anno2 in span<\/code><\/p>\n+                    <pre><code>@Anno3 fenced\n+                    <\/code><\/pre>\n+                    <pre><code>@Anno4 indented\n+                    <\/code><\/pre>\n+                    <p>end of list item<\/p>\n+                    <\/li>\n+                    <\/ol>\n+                    <p>end<\/p>\n+                    \"\"\");\n+\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdown.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,489 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownCodeBlocks\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests Markdown code blocks.\n+ *\n+ * Code blocks may be either \"fenced code blocks\" or \"indented code blocks\".\n+ * Within a code block, all text is \"literal text\" and not interpreted as\n+ * Markdown, HTML or javadoc tags.\n+ *\n+ * In the various test cases, javadoc tags are used as a way to determine\n+ * if the parser is correctly interpreting the text in its surrounding context.\n+ * Within a code block, character sequences resembling a tag are treated as\n+ * literal text, and appear \"as is\" in the generated output. Outside a\n+ * code block, character sequences resembling a tag are treated as tags and\n+ * are translated as appropriate in the generated output.\n+ *\n+ * A primary consideration in the test cases is use and handling of indentation,\n+ * especially as it relates to lists and nested lists.\n+ *\/\n+public class TestMarkdownCodeBlocks extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownCodeBlocks();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testCodeBlocks(Path base) throws Exception {\n+        \/\/ Test cases provide a fragment of content for a documentation comment\n+        \/\/ and a corresponding fragment of content to be found in the generated output.\n+        \/\/ The name of each member is used to generate the name of a declaration\n+        \/\/ with which the documentation comment is associated.\n+        enum TestCase {\n+            SIMPLE_INDENT(\n+                    \"\"\"\n+\n+                            {@code CODE}\n+                            @Anno\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_FENCE_BACKTICK(\n+                    \"\"\"\n+                        ```\n+                        {@code CODE}\n+                        @Anno\n+                        ```\n+                        end\"\"\",\n+                    \"\"\"\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_FENCE_TILDE(\n+                    \"\"\"\n+                        ~~~\n+                        {@code CODE}\n+                        @Anno\n+                        ~~~\n+                        end\"\"\",\n+                    \"\"\"\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"),\n+\n+            INDENT_TABS(\n+                    \"\"\"\n+\n+                        \\ttab\n+                         \\t1-space tab\n+                          \\t2-space tab\n+                           \\t3-space tab\n+                            \\t4-space tab\n+                        \\t\\t2-tab\n+\n+                        end\n+                        \"\"\",\n+                    \"\"\"\n+                        <pre><code>tab\n+                        1-space tab\n+                        2-space tab\n+                        3-space tab\n+                        \\t4-space tab\n+                        \\t2-tab\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"\n+            ),\n+\n+            UNCLOSED_FENCE(\n+                    \"\"\"\n+                        ```\n+                        {@code}\n+                        @Anno\n+                        \"\"\",\n+                    \"\"\"\n+                        <pre><code>{@code}\n+                        @Anno\n+                        <\/code><\/pre>\"\"\"\n+            ),\n+\n+            LIST_INDENT(\n+                    \"\"\"\n+                        * list item\n+\n+                              {@code CODE}\n+                              @Anno\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>\n+                        <p>list item<\/p>\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            LIST_FENCE_BACKTICK(\n+                    \"\"\"\n+                        * list item\n+                          ```\n+                          {@code CODE}\n+                          @Anno\n+                          ```\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>list item\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            LIST_FENCE_TILDE(\n+                    \"\"\"\n+                        1. list item\n+                           ~~~\n+                           {@code CODE}\n+                           @Anno\n+                           ~~~\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>list item\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"),\n+\n+            LIST_UNCLOSED_FENCE(\n+                    \"\"\"\n+                        1.  list item\n+                            ```\n+                            fenced-code\n+                            @Anno\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>list item\n+                        <pre><code>fenced-code\n+                        @Anno\n+\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ in the following, note the indentation of the list item is 5 spaces\n+            \/\/ and the block that follows is indented by just 4 spaces\n+            POST_LIST_INDENT(\n+                    \"\"\"\n+                         1.  list item\n+\n+                             second paragraph\n+\n+                            {@code CODE}\n+                            @Anno\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>\n+                        <p>list item<\/p>\n+                        <p>second paragraph<\/p>\n+                        <\/li>\n+                        <\/ol>\n+                        <pre><code>{@code CODE}\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <p>end<\/p>\"\"\"),\n+\n+            BLOCK_FENCE(\n+                    \"\"\"\n+                        > ```\n+                        > fenced code\n+                        > @Anno\n+                        > ```\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <pre><code>fenced code\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            BLOCK_UNCLOSED_FENCE(\n+                    \"\"\"\n+                        > ```\n+                        > fenced code\n+                        > @Anno\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <pre><code>fenced code\n+                        @Anno\n+                        <\/code><\/pre>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            NOT_INDENT_CONTINUATION(\n+                    \"\"\"\n+\n+                        paragraph\n+                                indented continuation {@code CODE}\n+                                more.\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>paragraph\n+                        indented continuation <code>CODE<\/code>\n+                        more.<\/p>\n+                        <p>end<\/p>\"\"\"\n+            ),\n+\n+            NOT_INDENT_IN_LIST(\n+                    \"\"\"\n+                        1.  list item\n+\n+                            list para, not indented block\n+                            {@code CODE}\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>\n+                        <p>list item<\/p>\n+                        <p>list para, not indented block\n+                        <code>CODE<\/code><\/p>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"),\n+\n+            COMBO(\n+                    \"\"\"\n+                        1. list item {@code TAG} lorem ipsum\n+\n+                           * nested list {@code TAG} lorem ipsum\n+\n+                               nested list para {@code TAG} lorem ipsum\n+\n+                                 nested indented block {@code TEXT} lorem ipsum\n+\n+                            outer list para {@code TAG} lorem ipsum\n+                            ```\n+                            outer list fenced block {@code TEXT} lorem ipsum\n+                            ```\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ol>\n+                        <li>\n+                        <p>list item <code>TAG<\/code> lorem ipsum<\/p>\n+                        <ul>\n+                        <li>\n+                        <p>nested list <code>TAG<\/code> lorem ipsum<\/p>\n+                        <p>nested list para <code>TAG<\/code> lorem ipsum<\/p>\n+                        <pre><code>nested indented block {@code TEXT} lorem ipsum\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ul>\n+                        <p>outer list para <code>TAG<\/code> lorem ipsum<\/p>\n+                        <pre><code>outer list fenced block {@code TEXT} lorem ipsum\n+                        <\/code><\/pre>\n+                        <\/li>\n+                        <\/ol>\n+                        <p>end<\/p>\"\"\"\n+            );\n+\n+            final String srcFragment;\n+            final String expect;\n+\n+            TestCase(String srcFragment, String expect) {\n+                this.srcFragment = srcFragment;\n+                this.expect = expect;\n+            }\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"\"\"\n+                    package p;\n+                    \/** Dummy. *\/\n+                    public class C {\n+                    private C() { }\n+                    \"\"\");\n+\n+        for (var tc: TestCase.values()) {\n+            sb.append(\"\"\"\n+                        \/\/\/ First sentence.\n+                        #FRAG#\n+                        public void #NAME#() { }\n+\n+                    \"\"\"\n+                    .replace(\"#FRAG#\", tc.srcFragment.lines()\n+                            .map(l -> \"\/\/\/ \" + l)\n+                            .collect(Collectors.joining(\"\\n    \")))\n+                    .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT)));\n+        }\n+\n+        sb.append(\"}\");\n+\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, sb.toString());\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(Output.OUT, false,\n+                \"unknown tag\");\n+\n+        for (var tc : TestCase.values()) {\n+            out.println(\"Test case: \" + tc);\n+            checkOutput(\"p\/C.html\", true,\n+                    \"\"\"\n+                        <span class=\"element-name\">#NAME#<\/span>()<\/div>\n+                        <div class=\"block\"><p>First sentence.<\/p>\n+                        #FRAG#\n+                        <\/div>\"\"\"\n+                            .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT))\n+                            .replace(\"#FRAG#\", tc.expect));\n+        }\n+    }\n+\n+    @Test\n+    public void testTypical(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ stand-in for the standard class, to avoid platform links\n+                    public class NullPointerException extends RuntimeException  { }\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ A class containing examples of \"typical\" usages.\n+                    public class C {\n+                        \/\/\/\n+                        \/\/\/ Here is an example:\n+                        \/\/\/\n+                        \/\/\/     @Deprecated\n+                        \/\/\/     public class Old { }\n+                        \/\/\/\n+                        \/\/\/ Here are some more examples:\n+                        \/\/\/\n+                        \/\/\/ 1.  ```\n+                        \/\/\/     @Deprecated(forRemoval=true)\n+                        \/\/\/     public class VeryOld { }\n+                        \/\/\/     ```\n+                        \/\/\/ 2.  ```\n+                        \/\/\/     public class C {\n+                        \/\/\/         @Override\n+                        \/\/\/         public boolean equals(Object other) {\n+                        \/\/\/             return false;\n+                        \/\/\/         }\n+                        \/\/\/         @Override\n+                        \/\/\/         public int hashCode() {\n+                        \/\/\/             return 0;\n+                        \/\/\/         }\n+                        \/\/\/     }\n+                        \/\/\/     ```\n+                        \/\/\/\n+                        \/\/\/ @param other another instance\n+                        \/\/\/ @throws NullPointerException if other is {@code null}\n+                        public C(C other) { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <p>Here is an example:<\/p>\n+                    <pre><code>@Deprecated\n+                    public class Old { }\n+                    <\/code><\/pre>\"\"\",\n+\n+                \"\"\"\n+                    <p>Here are some more examples:<\/p>\n+                    <ol>\n+                    <li>\n+                    <pre><code>@Deprecated(forRemoval=true)\n+                    public class VeryOld { }\n+                    <\/code><\/pre>\n+                    <\/li>\n+                    <li>\n+                    <pre><code>public class C {\n+                        @Override\n+                        public boolean equals(Object other) {\n+                            return false;\n+                        }\n+                        @Override\n+                        public int hashCode() {\n+                            return 0;\n+                        }\n+                    }\n+                    <\/code><\/pre>\n+                    <\/li>\n+                    <\/ol>\"\"\",\n+\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Parameters:<\/dt>\n+                    <dd><code>other<\/code> - another instance<\/dd>\n+                    <dt>Throws:<\/dt>\n+                    <dd><code><a href=\"NullPointerException.html\" title=\"class in p\">NullPointerException<\/a><\/code> - if other is <code>null<\/code><\/dd>\n+                    <\/dl>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownCodeBlocks.java","additions":489,"deletions":0,"binary":false,"changes":489,"status":"added"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownCodeSpans\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests Markdown code spans.\n+ *\n+ * Code spans are enclosed within a matching sequence of one or more backtick ({@code `})\n+ * characters and provide a way to specify \"literal text\" within a block,\n+ * such as a paragraph, list item, or block quote.  Code spans may span multiple lines\n+ * but not cross block boundaries: if a sequence of backtick characters is not matched within\n+ * a block, the sequence is treated as literal text, even if there is a matching sequence\n+ * in a subsequent block.\n+ *\n+ * In the various test cases, javadoc tags are used as a way to determine\n+ * if the parser is correctly interpreting the text in its surrounding context.\n+ * Within a code span, character sequences resembling a tag are treated as\n+ * literal text, and appear \"as is\" in the generated output. Outside a\n+ * code span, character sequences resembling a tag are treated as tags and\n+ * are translated as appropriate in the generated output.\n+ *\n+ * A primary consideration in the test cases is the use and handling of lines\n+ * that may or may not be part of the same block.  As such, the source for\n+ * each test case can be considered to be in two parts, each containing a backtick,\n+ * and which may or may not represent a code span.  Note that only some kinds\n+ * of lines (for paragraphs, list items and block quotes) may contain code spans.\n+ * All kinds of lines either continue a block or terminate it.\n+ *\/\n+public class TestMarkdownCodeSpans extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownCodeSpans();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testCodeSpans(Path base) throws Exception {\n+        \/\/ Test cases provide a fragment of content for a documentation comment\n+        \/\/ and a corresponding fragment of content to be found in the generated output.\n+        \/\/ The name of each member is used to generate the name of a declaration\n+        \/\/ with which the documentation comment is associated.\n+        \/\/\n+        \/\/ In the source fragments:\n+        \/\/ - when \"{@code TEXT}\" appears, it is expected it will appear \"as is\" in the output\n+        \/\/   enclosed within an HTML <code> element\n+        \/\/ - when \"{@code TAG}\" appears, it is expected it will be treated as a tag\n+        \/\/   and will appear in the output as \"<code>TAG<\/code>\"\n+        \/\/ Thus, the character sequence \"{@code TAG}\" should never appear in any output.\n+        \/\/\n+        \/\/ Note: for test cases involving ATX and setext headings, care must be taken to\n+        \/\/ ensure that the content is such that the auto-generated ids are unique,\n+        \/\/ so that we do not depend on the doclet to disambiguate the ids, based on the\n+        \/\/ order in which the headings are generated.\n+        enum TestCase {\n+            SIMPLE_PARA(\n+                    \"\"\"\n+\n+                        abc `p {@code TEXT} q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span\n+            PARA_PARA(\n+                    \"\"\"\n+\n+                        abc `p {@code TEXT}\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a paragraph with a heavily indented continuation line,\n+            \/\/ including a multi-line code span\n+            PARA_INDENT(\n+                    \"\"\"\n+\n+                        abc `p {@code TEXT}\n+                                      q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ blank line after a paragraph; no code spans, the tag is processed\n+            PARA_BLANK(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p <code>TAG<\/code><\/p>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ thematic break after a paragraph; no code spans, the tag is processed\n+            PARA_THEMATIC_BREAK_DASH(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+                        - - - - - - - - - - - -\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p <code>TAG<\/code><\/p>\n+                        <hr \/>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ thematic break after a paragraph; no code spans, the tag is processed\n+            PARA_THEMATIC_BREAK_ASTERISK(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+                        * * * * * * * * * *\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p <code>TAG<\/code><\/p>\n+                        <hr \/>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ ATX heading after a paragraph; no code spans, the tag is processed\n+            PARA_ATX(\n+                    \"\"\"\n+\n+                        abc `p1 {@code TAG}\n+                        # q1` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <p>abc `p1 <code>TAG<\/code><\/p>\n+                        <h4 id=\"q1-def-heading\">q1` def<\/h4>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ setext heading; no code spans, the tag is processed\n+            PARA_SETEXT(\n+                    \"\"\"\n+\n+                        abc `p {@code TAG}\n+                        ===================\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <h4 id=\"abc-p--heading\">abc `p <code>TAG<\/code><\/h4>\n+                        <p>q` def<\/p>\n+                        <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_LIST(\n+                    \"\"\"\n+\n+                        * abc `p {@code TEXT} q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>abc <code>p {@code TEXT} q<\/code> def<\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ two list items; no code spans, the tag is processed\n+            LIST_LIST(\n+                    \"\"\"\n+\n+                        * abc `p {@code TAG}\n+                        * q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <ul>\n+                        <li>abc `p <code>TAG<\/code><\/li>\n+                        <li>q` def<\/li>\n+                        <\/ul>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span in a multi-line list item\n+            LIST_PARA(\n+                    \"\"\"\n+\n+                        * abc `p {@code TEXT}\n+                        q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                <ul>\n+                <li>abc <code>p {@code TEXT} q<\/code> def<\/li>\n+                <\/ul>\n+                <p>end<\/p>\"\"\"),\n+\n+            \/\/ a list item with a heavily indented continuation line,\n+            \/\/ including a multi-line code span\n+            LIST_INDENT(\n+                    \"\"\"\n+\n+                        * abc `p {@code TEXT}\n+                                      q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                <ul>\n+                <li>abc <code>p {@code TEXT} q<\/code> def<\/li>\n+                <\/ul>\n+                <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_BLOCKQUOTE(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT} q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span in a multi-line block quote\n+            BLOCKQUOTE_BLOCKQUOTE(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT}\n+                        > q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <blockquote>\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a multi-line code span in a multi-line block quote\n+            BLOCKQUOTE_PARA(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT}\n+                          q` def\n+\n+                        end\"\"\",\n+                            \"\"\"\n+                        <blockquote>\n+                        <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                        <\/blockquote>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ a block quote with a heavily indented continuation line,\n+            \/\/ including a multi-line code span\n+            BLOCKQUOTE_INDENT(\n+                    \"\"\"\n+\n+                        > abc `p {@code TEXT}\n+                                    q` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                <blockquote>\n+                <p>abc <code>p {@code TEXT} q<\/code> def<\/p>\n+                <\/blockquote>\n+                <p>end<\/p>\"\"\"),\n+\n+            SIMPLE_ATX(\n+                    \"\"\"\n+\n+                        # abc `p2 {@code TEXT} q2` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <h4 id=\"abc-p2-code-text-q2-def-heading\">abc <code>p2 {@code TEXT} q2<\/code> def<\/h4>\n+                        <p>end<\/p>\"\"\"),\n+\n+            \/\/ two ATX headings; no code spans, the tag is processed\n+            ATX_ATX(\n+                    \"\"\"\n+\n+                        # abc `p3 {@code TAG}\n+                        # q3` def\n+\n+                        end\"\"\",\n+                    \"\"\"\n+                        <h4 id=\"abc-p3--heading\">abc `p3 <code>TAG<\/code><\/h4>\n+                        <h4 id=\"q3-def-heading\">q3` def<\/h4>\n+                        <p>end<\/p>\"\"\");\n+\n+            final String srcFragment;\n+            final String expect;\n+\n+            TestCase(String srcFragment, String expect) {\n+                this.srcFragment = srcFragment;\n+                this.expect = expect;\n+            }\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"\"\"\n+                    package p;\n+                    \/** Dummy. *\/\n+                    public class C {\n+                    private C() { }\n+                    \"\"\");\n+\n+        for (var tc: TestCase.values()) {\n+            sb.append(\"\"\"\n+                        \/\/\/ First sentence.\n+                        #FRAG#\n+                        public void #NAME#() { }\n+\n+                    \"\"\"\n+                    .replace(\"#FRAG#\", tc.srcFragment.lines()\n+                            .map(l -> \"\/\/\/ \" + l)\n+                            .collect(Collectors.joining(\"\\n    \")))\n+                    .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT)));\n+        }\n+\n+        sb.append(\"}\");\n+\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, sb.toString());\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ any\/all instances of \"{@code TAG}\" should be translated to \"<code>TAG<\/code>\"\n+        checkOutput(\"p\/C.html\", false,\n+                \"{@code TAG}\");\n+\n+        checkOutput(Output.OUT, false,\n+                \"unknown tag\");\n+\n+        for (var tc : TestCase.values()) {\n+            checkOutput(\"p\/C.html\", true,\n+                    \"\"\"\n+                        <span class=\"element-name\">#NAME#<\/span>()<\/div>\n+                        <div class=\"block\"><p>First sentence.<\/p>\n+                        #FRAG#\n+                        <\/div>\"\"\"\n+                            .replace(\"#NAME#\", tc.name().toLowerCase(Locale.ROOT))\n+                            .replace(\"#FRAG#\", tc.expect));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownCodeSpans.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownDeprecated\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestMarkdownDeprecated extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownDeprecated();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testDeprecated(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class Control {\n+                        \/**\n+                         * First sentence. Second sentence.\n+                         *\/\n+                         @Deprecated\n+                         public void anno_noTag() { }\n+                        \/**\n+                         * First sentence. Second sentence.\n+                         * @deprecated deprecated-text\n+                         *\/\n+                         public void noAnno_tag() { }\n+                        \/**\n+                         * First sentence. Second sentence.\n+                         * @deprecated deprecated-text\n+                         *\/\n+                        @Deprecated\n+                        public void anno_tag() { }\n+                    }\"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class MarkdownComments {\n+                        \/\/\/ First sentence. Second sentence.\n+                        @Deprecated\n+                        public void anno_noTag() { }\n+                        \/\/\/ First sentence. Second sentence.\n+                        \/\/\/ @deprecated deprecated-text.\n+                        public void noAnno_tag() { }\n+                        \/\/\/ First sentence. Second sentence.\n+                        \/\/\/ @deprecated deprecated-text\n+                        @Deprecated\n+                        public void anno_tag() { }\n+                    }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ Note: javadoc does not generate warnings about any mismatch\n+        \/\/ between @Deprecated annotations and @deprecated tags:\n+        \/\/ the mismatch is detected and reported by javac Attr phase,\n+        \/\/ when enabled by -Xlint:dep-ann.\n+\n+        \/\/ the output for these two files should be the same, except where it is not\n+        for (var f : List.of(\"p\/Control.html\", \"p\/MarkdownComments.html\")) {\n+            \/\/ in the following checks we check from the signature,\n+            \/\/ beginning at the name, through to the end of the main description.\n+            checkOutput(f, true,\n+                    \"\"\"\n+                        <span class=\"element-name\">anno_noTag<\/span>()<\/div>\n+                        <div class=\"deprecation-block\"><span class=\"deprecated-label\">Deprecated.<\/span><\/div>\n+                        <div class=\"block\">First sentence. Second sentence.<\/div>\"\"\",\n+\n+                    switch (f) {\n+                        \/\/ @deprecated but no annotation in a traditional comment implies deprecation\n+                        case \"p\/Control.html\" -> \"\"\"\n+                            <span class=\"element-name\">noAnno_tag<\/span>()<\/div>\n+                            <div class=\"deprecation-block\"><span class=\"deprecated-label\">Deprecated.<\/span>\n+                            <div class=\"deprecation-comment\">deprecated-text<\/div>\n+                            <\/div>\n+                            <div class=\"block\">First sentence. Second sentence.<\/div>\"\"\";\n+\n+                        \/\/ @deprecated but no annotation in a Markdown comment does not imply deprecation\n+                        case \"p\/MarkdownComments.html\" -> \"\"\"\n+                            <span class=\"element-name\">noAnno_tag<\/span>()<\/div>\n+                            <div class=\"block\">First sentence. Second sentence.<\/div>\"\"\";\n+\n+                        default -> throw new Error();\n+                    },\n+\n+                    \"\"\"\n+                        <span class=\"element-name\">anno_tag<\/span>()<\/div>\n+                        <div class=\"deprecation-block\"><span class=\"deprecated-label\">Deprecated.<\/span>\n+                        <div class=\"deprecation-comment\">deprecated-text<\/div>\n+                        <\/div>\n+                        <div class=\"block\">First sentence. Second sentence.<\/div>\"\"\");\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownDeprecated.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8332545\n+ * @summary  Fix handling of HTML5 entities in Markdown comments\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownEntities\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * Tests for use of HTML5 entities in Markdown.\n+ *\/\n+public class TestMarkdownEntities extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownEntities();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testEntities(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Simple common &lt;entities&gt; &amp;\n+                    \/\/\/ less common &ldquo;entities&rdquo;.\n+                    public class C {\n+                        private C() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">Simple common &lt;entities&gt; &amp;\n+                    less common \\u201centities\\u201d.<\/div>\n+                    \"\"\");\n+\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownEntities.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownFiles\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestMarkdownFiles extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownFiles();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testDocFile(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+                \/\/\/ First sentence.\n+                public class C { }\n+                \"\"\");\n+        tb.writeFile(src.resolve(\"p\").resolve(\"doc-files\").resolve(\"markdown.md\"),\n+                \"\"\"\n+                # This is a _Markdown_ heading\n+\n+                Lorem ipsum\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/doc-files\/markdown.html\", true,\n+                \"\"\"\n+                    <title>This is a Markdown heading<\/title>\n+                    \"\"\",\n+                \"\"\"\n+                    <main role=\"main\"><h1 id=\"this-is-a-markdown-heading-heading1\">This is a <em>Markdown<\/em> heading<\/h1>\n+                    <p>Lorem ipsum<\/p>\n+                    <\/main>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testOverview(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+                \/\/\/ First sentence.\n+                public class C { }\n+                \"\"\");\n+        var overviewFile = src.resolve(\"overview.md\");\n+        tb.writeFile(overviewFile,\n+                \"\"\"\n+                This is a _Markdown_ overview.\n+                Lorem ipsum\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"-overview\", overviewFile.toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"index.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">This is a <em>Markdown<\/em> overview.\n+                    Lorem ipsum<\/div>\"\"\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownFiles.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownFirstSentence\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestMarkdownFirstSentence extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownFirstSentence();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testFirstSentence(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ This is the _first_ sentence.\n+                        \/\/\/ This is the _second_ sentence.\n+                         public void m() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOrder(\"p\/C.html\",\n+                \"\"\"\n+                    <section class=\"method-summary\" id=\"method-summary\">\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">This is the <em>first<\/em> sentence.<\/div>\"\"\",\n+                \"\"\"\n+                    <section class=\"method-details\" id=\"method-detail\">\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">This is the <em>first<\/em> sentence.\n+                    This is the <em>second<\/em> sentence.<\/div>\"\"\");\n+    }\n+\n+    \/\/ Test the ability to put links in the first sentence of a description.\n+    \/\/ Note that user-defined reference links cannot be used in the first\n+    \/\/ sentence, and so in that case we verify the behavior is \"as expected\".\n+    @Test\n+    public void testFirstSentenceLinks(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        \/\/ Apart from the (control) case, the other cases exercise\n+        \/\/ various kinds of links in the first sentence of a description.\n+        \/\/ Note the last case is an explicit test of a link that is\n+        \/\/ _not_ currently supported, since the link reference definition\n+        \/\/ is not part of the first sentence.\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    import q.MyObject;\n+                    public class C {\n+                        \/\/\/ First sentence.\n+                        \/\/\/ Control: [MyObject]\n+                        public void m1() { }\n+\n+                        \/\/\/ Simple autoref in first sentence [MyObject].\n+                        \/\/\/ More.\n+                        public void m2() { }\n+\n+                        \/\/\/ Qualified autoref in first sentence [q.MyObject].\n+                        \/\/\/ More.\n+                        public void m3() { }\n+\n+                        \/\/\/ Standard link with periods [example.com](http:\/\/example.com).\n+                        \/\/\/ More.\n+                        public void m4() { }\n+\n+                        \/\/\/ Manual ref link [foo].\n+                        \/\/\/ More.\n+                        \/\/\/\n+                        \/\/\/ [foo]: http:example.com\n+                        public void m5() { }\n+                    }\"\"\",\n+                \/\/ use a simple class in a different package, to avoid platform links to system classes\n+                \"\"\"\n+                    package q;\n+                    public class MyObject { }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\", \"q\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ use checkOrder and the delimiter comments to ensure that\n+        \/\/ we check the strings in the method summary table, and not\n+        \/\/ subsequently in the method details section.\n+        checkOrder(\"p\/C.html\",\n+                \"<!-- ========== METHOD SUMMARY =========== -->\",\n+                \"\"\"\n+                    <div class=\"block\">Simple autoref in first sentence <a href=\"..\/q\/MyObject.html\" \\\n+                    title=\"class in q\"><code>MyObject<\/code><\/a>.<\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Qualified autoref in first sentence <a href=\"..\/q\/MyObject.html\" \\\n+                    title=\"class in q\"><code>MyObject<\/code><\/a>.<\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Standard link with periods \\\n+                    <a href=\"http:\/\/example.com\">example.com<\/a>.<\/div>\"\"\",\n+                \/\/ The following is a test of the regrettably expected behavior,\n+                \/\/ because the link reference definition is not carried into\n+                \/\/ the first sentence.\n+                \"\"\"\n+                    <div class=\"block\">Manual ref link [foo].<\/div>\"\"\",\n+                \"<!-- ============ METHOD DETAIL ========== -->\"\n+        );\n+    }\n+\n+    \/\/ Test that periods within certain constructs do not prematurely terminate\n+    \/\/ the first sentence.\n+    @Test\n+    public void testFirstSentencePeriods(Path base) throws Exception {\n+        testFirstSentencePeriods(base.resolve(\"no-bi\"), false);\n+        testFirstSentencePeriods(base.resolve(\"bi\"), true);\n+    }\n+\n+    void testFirstSentencePeriods(Path base, boolean useBreakIterator) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                        package p;\n+                        public class C {\n+                            \/\/\/ Code span `1.0` end.\n+                            \/\/\/ More.\n+                            public void m1() { }\n+                            \/\/\/ Complex code span ``` `1.0` ``` end.\n+                            \/\/\/ More.\n+                            public void m2() { }\n+                            \/\/\/ Period space `1.  2.  3.` end.\n+                            \/\/\/ More.\n+                            public void m3() { }\n+                            \/\/\/ Link [example.com](http:\/\/example.com) end.\n+                            \/\/\/ More.\n+                            public void m4() { }\n+                        }\n+                        \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                (useBreakIterator ? \"-breakiterator\" : \"-XDdummy\"),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ use checkOrder and the delimiter comments to ensure that\n+        \/\/ we check the strings in the method summary table, and not\n+        \/\/ subsequently in the method details section.\n+        checkOrder(\"p\/C.html\",\n+                \"<!-- ========== METHOD SUMMARY =========== -->\",\n+                \"\"\"\n+                    <div class=\"block\">Code span <code>1.0<\/code> end.<\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Complex code span <code>`1.0`<\/code> end.<\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Period space <code>1.  2.  3.<\/code> end.<\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Link <a href=\"http:\/\/example.com\">example.com<\/a> end.<\/div>\"\"\",\n+                \"<!-- ============ METHOD DETAIL ========== -->\"\n+        );\n+    }\n+\n+    @Test\n+    public void testIndentedInlineReturn(Path base) throws Exception {\n+        \/\/this is a Markdown-specific test, because leading whitespace is ignored in HTML comments\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Class description.\n+                    public class C {\n+                        \/\/\/    {@return an int}\n+                        \/\/\/ More description.\n+                        public int m() { return 0; }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <section class=\"detail\" id=\"m()\">\n+                    <h3>m<\/h3>\n+                    <div class=\"horizontal-scroll\">\n+                    <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>&nbsp;<span class=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">m<\/span>()<\/div>\n+                    <div class=\"block\">Returns an int.\n+                    More description.<\/div>\n+                    <dl class=\"notes\">\n+                    <dt>Returns:<\/dt>\n+                    <dd>an int<\/dd>\n+                    <\/dl>\n+                    <\/div>\n+                    <\/section>\"\"\");\n+    }\n+\n+    @Test\n+    public void testExtraPara(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ This is the class description.\n+                    \/\/\/\n+                    \/\/\/ # Heading\n+                    \/\/\/ Lorem ipsum\n+                    public class C { }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/package-summary.html\", true,\n+                \"\"\"\n+                    <div class=\"col-first even-row-color class-summary class-summary-tab2\"><a href=\"C.html\" title=\"clas\\\n+                    s in p\">C<\/a><\/div>\n+                    <div class=\"col-last even-row-color class-summary class-summary-tab2\">\n+                    <div class=\"block\">This is the class description.<\/div>\n+                    <\/div>\"\"\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                        <span class=\"element-name type-name-label\">C<\/span>\n+                        <span class=\"extends-implements\">extends java.lang.Object<\/span><\/div>\n+                        <div class=\"block\"><p>This is the class description.<\/p>\n+                        <h2 id=\"heading-heading\">Heading<\/h2>\n+                        <p>Lorem ipsum<\/p>\n+                        <\/div>\"\"\");\n+\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownFirstSentence.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownHeadings\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * Tests for Markdown headings.\n+ *\n+ * Markdown headings are handled specially when rendering the content.\n+ * In particular:\n+ * 1. heading levels are adjusted according to the context\n+ * 2. ids are automatically added\n+ * 3. top-level headings are added to the TOC\n+ *\n+ * Note that ids on headings are always automatically generated.\n+ * You cannot specify ids, such as with the pandoc header-attributes\n+ * extension.\n+ *\/\n+public class TestMarkdownHeadings extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownHeadings();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testHeading_ATX(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ # ATX-style heading for package\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    \/\/\/\n+                    \/\/\/ ## ATX-style subheading for package\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    package p;\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ # ATX-style heading for class\n+                    \/\/\/\n+                    \/\/\/ Lorum ipsum.\n+                    \/\/\/\n+                    \/\/\/ ## ATX-style subheading for class\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    public class C {\n+                        \/\/\/ Constructor.\n+                        \/\/\/\n+                        \/\/\/ # ATX-style heading for executable\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        \/\/\/\n+                        \/\/\/ ## ATX-style subheading for executable\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public C() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/package-summary.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"atx-style-heading-for-package-heading\">ATX-style heading for package<\/h2>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h3 id=\"atx-style-subheading-for-package-heading\">ATX-style subheading for package<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"atx-style-heading-for-class-heading\">ATX-style heading for class<\/h2>\n+                    <p>Lorum ipsum.<\/p>\n+                    <h3 id=\"atx-style-subheading-for-class-heading\">ATX-style subheading for class<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\", \"\"\"\n+                    <div class=\"block\"><p>Constructor.<\/p>\n+                    <h4 id=\"atx-style-heading-for-executable-heading\">ATX-style heading for executable<\/h4>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h5 id=\"atx-style-subheading-for-executable-heading\">ATX-style subheading for executable<\/h5>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testHeading_Setext(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ Setext-style heading for package\n+                    \/\/\/ ================================\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    \/\/\/\n+                    \/\/\/ Setext-style subheading for package\n+                    \/\/\/ -----------------------------------\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    package p;\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ Setext-style heading for class\n+                    \/\/\/ ==============================\n+                    \/\/\/\n+                    \/\/\/ Lorum ipsum.\n+                    \/\/\/\n+                    \/\/\/ Setext-style subheading for class\n+                    \/\/\/ ---------------------------------\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    public class C {\n+                        \/\/\/ Constructor.\n+                        \/\/\/\n+                        \/\/\/ Setext-style heading for executable\n+                        \/\/\/ ===================================\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        \/\/\/\n+                        \/\/\/ Setext-style subheading for executable\n+                        \/\/\/ --------------------------------------\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public C() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/package-summary.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"setext-style-heading-for-package-heading\">Setext-style heading for package<\/h2>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h3 id=\"setext-style-subheading-for-package-heading\">Setext-style subheading for package<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"setext-style-heading-for-class-heading\">Setext-style heading for class<\/h2>\n+                    <p>Lorum ipsum.<\/p>\n+                    <h3 id=\"setext-style-subheading-for-class-heading\">Setext-style subheading for class<\/h3>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\", \"\"\"\n+                    <div class=\"block\"><p>Constructor.<\/p>\n+                    <h4 id=\"setext-style-heading-for-executable-heading\">Setext-style heading for executable<\/h4>\n+                    <p>Lorem ipsum.<\/p>\n+                    <h5 id=\"setext-style-subheading-for-executable-heading\">Setext-style subheading for executable<\/h5>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testMaxHeadings(Path base) throws Exception {\n+\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ # Level 1 heading for class\n+                    \/\/\/ ## Level 2 subheading for class\n+                    \/\/\/ ### Level 3 subheading for class\n+                    \/\/\/ #### Level 4 heading for class\n+                    \/\/\/ ##### Level 5 subheading for class\n+                    \/\/\/ ###### Level 6 subheading for class\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum.\n+                    public class C {\n+                        \/\/\/ Constructor.\n+                        \/\/\/\n+                        \/\/\/ # Level 1 heading for member\n+                        \/\/\/ ## Level 2 subheading for member\n+                        \/\/\/ ### Level 3 subheading for member\n+                        \/\/\/ #### Level 4 heading for member\n+                        \/\/\/ ##### Level 5 subheading for member\n+                        \/\/\/ ###### Level 6 subheading for member\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public C() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <h2 id=\"level-1-heading-for-class-heading\">Level 1 heading for class<\/h2>\n+                    <h3 id=\"level-2-subheading-for-class-heading\">Level 2 subheading for class<\/h3>\n+                    <h4 id=\"level-3-subheading-for-class-heading\">Level 3 subheading for class<\/h4>\n+                    <h5 id=\"level-4-heading-for-class-heading\">Level 4 heading for class<\/h5>\n+                    <h6 id=\"level-5-subheading-for-class-heading\">Level 5 subheading for class<\/h6>\n+                    <h6 id=\"level-6-subheading-for-class-heading\">Level 6 subheading for class<\/h6>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\"><p>Constructor.<\/p>\n+                    <h4 id=\"level-1-heading-for-member-heading\">Level 1 heading for member<\/h4>\n+                    <h5 id=\"level-2-subheading-for-member-heading\">Level 2 subheading for member<\/h5>\n+                    <h6 id=\"level-3-subheading-for-member-heading\">Level 3 subheading for member<\/h6>\n+                    <h6 id=\"level-4-heading-for-member-heading\">Level 4 heading for member<\/h6>\n+                    <h6 id=\"level-5-subheading-for-member-heading\">Level 5 subheading for member<\/h6>\n+                    <h6 id=\"level-6-subheading-for-member-heading\">Level 6 subheading for member<\/h6>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testHeading_TOC(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/\n+                    \/\/\/ # ATX heading `code` _underline_ text\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum\n+                    \/\/\/\n+                    \/\/\/ ## ATX Subheading\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum\n+                    \/\/\/\n+                    \/\/\/ Setext heading\n+                    \/\/\/ ==============\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum\n+                    \/\/\/\n+                    \/\/\/ Setext subheading\n+                    \/\/\/ ------------------\n+                    \/\/\/\n+                    \/\/\/ Lorem ipsum\n+                    public class C {\n+                        \/\/\/ Method m.\n+                        \/\/\/ # subheading in m()\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum\n+                        public void m() { }\n+                    }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \/\/ note only the level 1 headings in the class description\n+                \"\"\"\n+                    <div class=\"toc-header\">Contents&nbsp;\n+                    <input type=\"text\" class=\"filter-input\" disabled placeholder=\"Filter\" aria-label=\"Filter table of contents\" autocomplete=\"off\">\n+                    <input type=\"reset\" class=\"reset-filter\" disabled value=\"Reset\">\n+                    <\/div>\n+                    <button class=\"hide-sidebar\"><span>Hide sidebar&nbsp;<\/span>&#10094;<\/button><button class=\"show-sidebar\">&#10095;<span>&nbsp;Show sidebar<\/span><\/button>\n+                    <ol class=\"toc-list\">\n+                    <li><a href=\"#\" tabindex=\"0\">Description<\/a>\n+                    <ol class=\"toc-list\">\n+                    <li><a href=\"#atx-heading-code-underline-text-heading\" tabindex=\"0\">ATX heading code underline text<\/a><\/li>\n+                    <li><a href=\"#setext-heading-heading\" tabindex=\"0\">Setext heading<\/a><\/li>\n+                    <\/ol>\n+                    <\/li>\n+                    <li><a href=\"#constructor-summary\" tabindex=\"0\">Constructor Summary<\/a><\/li>\n+                    <li><a href=\"#method-summary\" tabindex=\"0\">Method Summary<\/a><\/li>\n+                    <li><a href=\"#constructor-detail\" tabindex=\"0\">Constructor Details<\/a>\n+                    <ol class=\"toc-list\">\n+                    <li><a href=\"#%3Cinit%3E()\" tabindex=\"0\">C()<\/a><\/li>\n+                    <\/ol>\n+                    <\/li>\n+                    <li><a href=\"#method-detail\" tabindex=\"0\">Method Details<\/a>\n+                    <ol class=\"toc-list\">\n+                    <li><a href=\"#m()\" tabindex=\"0\">m()<\/a><\/li>\n+                    <\/ol>\n+                    <\/li>\n+                    <\/ol>\n+                    \"\"\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownHeadings.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownInheritDoc\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestMarkdownInheritDoc extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownInheritDoc();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testInherit_md_md(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws Exception Base _Markdown_\n+                        public void m() throws Exception { }\n+                    }\"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class Derived extends Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws {@inheritDoc}\n+                        public void m() throws Exception { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/Derived.html\", true,\n+                \"\"\"\n+                    <dt>Throws:<\/dt>\n+                    <dd><code>java.lang.Exception<\/code> - Base <em>Markdown<\/em><\/dd>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInherit_md_plain(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws Exception Base _Markdown_\n+                        public void m() throws Exception { }\n+                    }\"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class Derived extends Base {\n+                        \/**\n+                         * Plain comment.\n+                         * @throws {@inheritDoc}\n+                         *\/\n+                         public void m() throws Exception { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/Derived.html\", true,\n+                \"\"\"\n+                    <dt>Throws:<\/dt>\n+                    <dd><code>java.lang.Exception<\/code> - Base <em>Markdown<\/em><\/dd>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testInherit_plain_md(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class Base {\n+                        \/**\n+                         * Plain comment.\n+                         * @throws Exception Base _Not Markdown_\n+                         *\/\n+                         public void m() throws Exception { }\n+                    }\"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class Derived extends Base {\n+                        \/\/\/ Markdown comment.\n+                        \/\/\/ @throws {@inheritDoc}\n+                        public void m() throws Exception { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--no-platform-links\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/Derived.html\", true,\n+                \"\"\"\n+                    <dt>Throws:<\/dt>\n+                    <dd><code>java.lang.Exception<\/code> - Base _Not Markdown_<\/dd>\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownInheritDoc.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestMarkdownLinks\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestMarkdownLinks extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownLinks();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testSimpleLink(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from {@link #m2()}.\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from {@link #m1()}.\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><code>m2()<\/code><\/a>.\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testSimpleRefLink(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from [#m2()].\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from [#m1()].\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><code>m2()<\/code><\/a>.\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testLinkWithDescription(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from {@linkplain #m2() _Markdown_ m2}.\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from {@linkplain #m1() _Markdown_ m1}.\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><em>Markdown<\/em> m2\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testRefLinkWithDescription(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ This is different from [_Markdown_ m2][#m2()].\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ This is different from [_Markdown_ m1][#m1()]}.\n+                        public void m2() { }\n+                    }\n+                    \"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Method m1.\n+                    This is different from <a href=\"#m2()\"><em>Markdown<\/em> m2\"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testLinkToHeadingAnchor(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ # Lorem Ipsum.\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum [reference in same comment][##lorem-ipsum--heading].\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ Lorem ipsum [reference in another comment][##lorem-ipsum--heading].\n+                        public void m2() { }\n+                    }\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Lorem ipsum [reference in another class][C##lorem-ipsum--heading].\n+                    public class D {\n+                    }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+    }\n+\n+    @Test\n+    public void testLinkToUserAnchor(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ Method m1.\n+                        \/\/\/ <span id=\"lorem-ipsum\">Lorem Ipsum<\/span>.\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum [reference in same comment][##lorem-ipsum].\n+                        public void m1() { }\n+                        \/\/\/ Method m2.\n+                        \/\/\/ Lorem ipsum [reference in another comment][##lorem-ipsum].\n+                        public void m2() { }\n+                    }\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ Lorem ipsum [reference in another class][C##lorem-ipsum].\n+                    public class D {\n+                    }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+    }\n+\n+    @Test\n+    public void testLinkElementKinds(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                        package p;\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ * module [java.base\/]\n+                        \/\/\/ * package [java.util]\n+                        \/\/\/ * class [String] or interface [Runnable]\n+                        \/\/\/ * a field [String#CASE_INSENSITIVE_ORDER]\n+                        \/\/\/ * a constructor [String#String()]\n+                        \/\/\/ * a method [String#chars()]\n+                        public class C { }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        \/\/ in the following carefully avoid checking the URL host, which is of less importance and may vary over time;\n+        \/\/ the interesting part is the tail of the path after the host\n+        new OutputChecker(\"p\/C.html\")\n+                .setExpectOrdered(true)\n+                .check(\"module <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/module-summary.html\\\" class=\\\"external-link\\\"><code>java.base<\/code><\/a>\",\n+\n+                        \"package <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/util\/package-summary.html\\\" class=\\\"external-link\\\"><code>java.util<\/code><\/a>\",\n+\n+                        \"class <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String<\/code><\/a>\",\n+\n+                        \"interface <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/Runnable.html\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>Runnable<\/code><\/a>\",\n+\n+                        \"a field <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#CASE_INSENSITIVE_ORDER\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String.CASE_INSENSITIVE_ORDER<\/code><\/a>\",\n+\n+                        \"a constructor <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#%3Cinit%3E()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String()<\/code><\/a><\/li>\",\n+\n+                        \"a method <a href=\\\"https:\/\/\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#chars()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String.chars()<\/code><\/a>\");\n+    }\n+\n+    \/\/\/ Test the ability to include array elements in method signatures for\n+    \/\/\/ automatic links to program elements.\n+    @Test\n+    public void testReferenceWithArrays(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+\n+        \/\/ in the following,\n+        \/\/\n+        \/\/ * Link 0 is a simple control for a shortcut reference link (without any arrays)\n+        \/\/ * Link 1a and Link 2a are negative controls, in that they are _not_ valid links\n+        \/\/   because of the unescaped [] pair\n+        \/\/ * Link 1b and 2b are the positive tests, showing that the square brackets\n+        \/\/   need to be escaped in the source code, and that they are not escaped in\n+        \/\/   the generated HTML\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/ * Link 0 to [util.Arrays]\n+                    \/\/\/ * Link 1a to [Arrays-equals][util.Arrays#equals(Object[],Object[])]\n+                    \/\/\/ * Link 1b to [Arrays-equals][util.Arrays#equals(Object\\\\[\\\\],Object\\\\[\\\\])]\n+                    \/\/\/ * Link 2a to [util.Arrays#equals(Object[],Object[])]\n+                    \/\/\/ * Link 2b to [util.Arrays#equals(Object\\\\[\\\\],Object\\\\[\\\\])]\n+                    public class C { }\"\"\",\n+                \/\/ simulate java.util.Arrays.equals, to avoid links to platform references\n+                \"\"\"\n+                    package util;\n+                    public class Arrays {\n+                        public boolean equals(Object[] a, Object[] a2);\n+                    }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\", \"util\");\n+\n+        checkExit(Exit.OK);\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    Link 0 to <a href=\"..\/util\/Arrays.html\" title=\"class in util\"><code>Arrays<\/code><\/a>\"\"\",\n+                \"\"\"\n+                    Link 1a to [Arrays-equals][util.Arrays#equals(Object[],Object[])]\"\"\",\n+                \"\"\"\n+                    Link 1b to <a href=\"..\/util\/Arrays.html#equals(java.lang.Object%5B%5D,\\\n+                    java.lang.Object%5B%5D)\">Arrays-equals<\/a>\"\"\",\n+                \"\"\"\n+                    Link 2a to [util.Arrays#equals(Object[],Object[])]\"\"\",\n+                \"\"\"\n+                    Link 2b to <a href=\"..\/util\/Arrays.html#equals(java.lang.Object%5B%5D,\\\n+                    java.lang.Object%5B%5D)\"><code>Arrays.equals(Object[],Object[])<\/code><\/a>\"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testSee(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/\/\/ First sentence.\n+                    \/\/\/ @see \"A reference\"\n+                    \/\/\/ @see <a href=\"http:\/\/www.example.com\">Example<\/a>\n+                    \/\/\/ @see D a _Markdown_ description\n+                    public class C { }\n+                    \"\"\",\n+                \"\"\"\n+                    package p;\n+                    public class D { }\"\"\");\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <dt>See Also:<\/dt>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li>\"A reference\"<\/li>\n+                    <li><a href=\"http:\/\/www.example.com\">Example<\/a><\/li>\n+                    <li><a href=\"D.html\" title=\"class in p\">a <em>Markdown<\/em> description<\/a><\/li>\n+                    <\/ul>\n+                    <\/dd>\"\"\");\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownLinks.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.* DivTaglet SpanTaglet\n+ * @run main TestMarkdownTaglets\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public class TestMarkdownTaglets extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestMarkdownTaglets();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    \/\/ The following test checks whether the output of system taglets\n+    \/\/ is or is not wrapped in <p> tags, depending on the context within\n+    \/\/ the doc comment and the output generated by the taglet.\n+    \/\/\n+    \/\/ {@code ...} is used as an example of a tag that generates phrasing content.\n+    \/\/ {@snippet ...} is used as an example of a tag that generates block content.\n+    \/\/\n+    \/\/ See also: testUserTaglets\n+    @Test\n+    public void testSystemTaglets(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ {@code this is code_standalone}\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void code_standalone() { }\n+\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ Before.\n+                        \/\/\/ {@code this is code_wrapped}\n+                        \/\/\/ After.\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void code_wrapped() { }\n+\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ {@snippet :\n+                        \/\/\/    this is snippet_standalone\n+                        \/\/\/ }\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void snippet_standalone() { }\n+\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ Before.\n+                        \/\/\/ {@snippet :\n+                        \/\/\/    this is a snippet_wrapped\n+                        \/\/\/ }\n+                        \/\/\/ After.\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void snippet_wrapped() { }\n+                    }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <p><code>this is code_standalone<\/code><\/p>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <p>Before.\n+                    <code>this is code_wrapped<\/code>\n+                    After.<\/p>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <div class=\"snippet-container\"><button class=\"copy snippet-copy\" aria-label=\"Copy snippet\" \\\n+                    onclick=\"copySnippet(this)\"><span data-copied=\"Copied!\">Copy<\/span>\\\n+                    <img src=\"..\/resource-files\/copy.svg\" alt=\"Copy snippet\"><\/button>\n+                    <pre class=\"snippet\"><code>   this is snippet_standalone\n+                    <\/code><\/pre>\n+                    <\/div>\n+\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <p>Before.<\/p>\n+                    <div class=\"snippet-container\"><button class=\"copy snippet-copy\" aria-label=\"Copy snippet\" onclick=\"copySnippet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/resource-files\/copy.svg\" alt=\"Copy snippet\"><\/button>\n+                    <pre class=\"snippet\"><code>   this is a snippet_wrapped\n+                    <\/code><\/pre>\n+                    <\/div>\n+\n+                    <p>After.<\/p>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\");\n+    }\n+\n+    \/\/ The following test checks whether the output of user-defined taglets\n+    \/\/ is or is not wrapped in <p> tags, depending on the context within\n+    \/\/ the doc comment and the output generated by the taglet.\n+    \/\/\n+    \/\/ {@span ...} is used as an example of a taglet that generates phrasing content.\n+    \/\/ {@div ...} is used as an example of a taglet that generates block content.\n+    \/\/\n+    \/\/ See also: testSystemTaglets\n+    @Test\n+    public void testUserTaglets(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    public class C {\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ {@span this is phrasing_standalone}\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void phrasing_standalone() { }\n+\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ Before.\n+                        \/\/\/ {@span this is phrasing_wrapped}\n+                        \/\/\/ After.\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void phrasing_wrapped() { }\n+\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ {@div this is block_standalone}\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void block_standalone() { }\n+\n+                        \/\/\/ First sentence.\n+                        \/\/\/\n+                        \/\/\/ Before.\n+                        \/\/\/ {@div this is block_wrapped}\n+                        \/\/\/ After.\n+                        \/\/\/\n+                        \/\/\/ Lorem ipsum.\n+                        public void block_wrapped() { }\n+                    }\"\"\");\n+\n+        String testClasses = System.getProperty(\"test.classes\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-tagletpath\", testClasses,\n+                \"-taglet\", \"DivTaglet\",\n+                \"-taglet\", \"SpanTaglet\",\n+                \"-Xdoclint:none\",\n+                \"--source-path\", src.toString(),\n+                \"p\");\n+\n+        checkOutput(\"p\/C.html\", true, \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <p><span>this is phrasing_standalone<\/span><\/p>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <p>Before.\n+                    <span>this is phrasing_wrapped<\/span>\n+                    After.<\/p>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <div>this is block_standalone<\/div>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\"><p>First sentence.<\/p>\n+                    <p>Before.<\/p>\n+                    <div>this is block_wrapped<\/div>\n+                    <p>After.<\/p>\n+                    <p>Lorem ipsum.<\/p>\n+                    <\/div>\"\"\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownTaglets.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -69,1 +69,1 @@\n-    List<String> MISSING_IN_MAN_PAGE = List.of(\"--no-fonts\");\n+    List<String> MISSING_IN_MAN_PAGE = List.of();\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckManPageOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n+ * @enablePreview\n@@ -36,0 +36,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -40,1 +43,0 @@\n-import com.sun.tools.classfile.*;\n@@ -271,4 +273,4 @@\n-            ClassFile cf = ClassFile.read(in);\n-            for (ConstantPool.CPInfo cpinfo: cf.constant_pool.entries()) {\n-                if (cpinfo.getTag() == ConstantPool.CONSTANT_Utf8) {\n-                    String v = ((ConstantPool.CONSTANT_Utf8_info) cpinfo).value;\n+            ClassModel cf = ClassFile.of().parse(in.readAllBytes());\n+            for (var cpinfo : cf.constantPool()) {\n+                if (cpinfo instanceof Utf8Entry utf8Entry) {\n+                    String v = utf8Entry.stringValue();\n@@ -279,1 +281,1 @@\n-        } catch (ConstantPoolException ignore) {\n+        } catch (IllegalArgumentException ignore) {\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckResourceKeys.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import javax.lang.model.util.Elements.DocCommentKind;\n+\n@@ -55,0 +57,9 @@\n+    public DocCommentKind getCommentKind(JCTree tree) {\n+        Comment c = getComment(tree);\n+        return c == null ? null : switch (c.getStyle()) {\n+            case JAVADOC_BLOCK -> DocCommentKind.TRADITIONAL;\n+            case JAVADOC_LINE -> DocCommentKind.END_OF_LINE;\n+            default -> throw new IllegalStateException(c.getStyle().toString());\n+        };\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/sampleapi\/lib\/sampleapi\/util\/PoorDocCommentTable.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestLineCommentOption\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.stream.StreamSupport;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreeFactory;\n+import com.sun.source.util.DocTrees;\n+\n+import com.sun.tools.javac.api.JavacTrees;\n+\n+import javadoc.tester.JavadocTester;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.StandardDoclet;\n+import toolbox.ToolBox;\n+\n+public class TestLineCommentOption extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestLineCommentOption();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+\n+    \/\/ This is a somewhat worthless test case, given all the test cases for\n+    \/\/ Markdown content in line comments.\n+    @Test\n+    public void testNoOption(Path base) throws Exception {\n+        \/\/ use a dummy option\n+        \/\/ note that we cannot use -Xlint:dangling-doc-comments in javadoc\n+        test(base, \"-XDdummy\", \"Line comment\");\n+        \/\/ in the future, check for diagnostic output about a dangling comment\n+    }\n+\n+    @Test\n+    public void testOption(Path base) throws Exception {\n+        test(base, \"--disable-line-doc-comments\", \"Traditional comment\");\n+    }\n+\n+    void test(Path base, String option, String expect) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+            package p;\n+            \/**\n+             * Traditional comment.\n+             *\/\n+            \/\/\/ Line comment\n+            public class C {\n+                private C() { }\n+            }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"--source-path\", src.toString(),\n+                option,\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/C.html\", true,\n+                expect);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/testLineCommentOption\/TestLineCommentOption.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8298405\n+ * @summary  Markdown support in the standard doclet\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestTransformer\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.stream.StreamSupport;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreeFactory;\n+import com.sun.source.util.DocTrees;\n+\n+import com.sun.tools.javac.api.JavacTrees;\n+\n+import javadoc.tester.JavadocTester;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.StandardDoclet;\n+import toolbox.ToolBox;\n+\n+public class TestTransformer extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestTransformer();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testFindStandardTransformer_raw() {\n+        int count = 0;\n+        var sl = ServiceLoader.load(JavacTrees.DocCommentTreeTransformer.class);\n+        for (var t : sl) {\n+            if (t.name().equals(\"standard\")) {\n+                out.println(\"Found \" + t);\n+                count++;\n+            }\n+        }\n+        checking(\"transformer\");\n+        if (count == 1) {\n+            passed(\"expected transformer found\");\n+        } else {\n+            failed(\"expected transformer not found\");\n+        }\n+    }\n+\n+    @Test\n+    public void testFindStandardTransformer_stream() {\n+        var dct = getTransformer(\"standard\");\n+        checking(\"transformer\");\n+        if (dct.isPresent()) {\n+            out.println(\"Found \" + dct.get());\n+            passed(\"expected transformer found\");\n+        } else {\n+            failed(\"transformer not found\");\n+        }\n+    }\n+\n+    private Optional<JavacTrees.DocCommentTreeTransformer> getTransformer(String name) {\n+        var sl = ServiceLoader.load(JavacTrees.DocCommentTreeTransformer.class);\n+        return sl.stream()\n+                .map(ServiceLoader.Provider::get)\n+                .filter(t -> t.name().equals(name))\n+                .findFirst();\n+    }\n+\n+    public static class MyTransformer implements JavacTrees.DocCommentTreeTransformer {\n+\n+        private DocTreeFactory m;\n+        @Override\n+        public String name() {\n+            return getClass().getSimpleName();\n+        }\n+\n+        @Override\n+        public DocCommentTree transform(DocTrees trees, DocCommentTree tree) {\n+            m = trees.getDocTreeFactory();\n+            return m.newDocCommentTree(transform(tree.getFullBody()), tree.getBlockTags());\n+        }\n+\n+        private List<? extends DocTree> transform(List<? extends DocTree> list) {\n+            return list.stream().map(this::transform).toList();\n+        }\n+\n+        private DocTree transform(DocTree tree) {\n+            return switch (tree) {\n+                case TextTree tt ->\n+                        m.newTextTree(transform(tt.getBody()));\n+                case RawTextTree rtt ->\n+                        m.newRawTextTree(rtt.getKind(), transform(rtt.getContent()));\n+                default ->\n+                        tree;\n+            };\n+        }\n+\n+        private String transform(String s) {\n+            return s.replace(\"lowercase\", \"UPPERCASE\");\n+        }\n+    }\n+\n+    public static class MyDoclet extends StandardDoclet {\n+        @Override\n+        public boolean run(DocletEnvironment docEnv) {\n+            ((JavacTrees) docEnv.getDocTrees()).setDocCommentTreeTransformer(new MyTransformer());\n+            return super.run(docEnv);\n+        }\n+    }\n+\n+    @Test\n+    public void testMyTransformer(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package p;\n+                \/**\n+                 * This traditional comment contains a lowercase word.\n+                 *\/\n+                public class Trad { }\n+                \"\"\", \"\"\"\n+                package p;\n+                \/\/\/ This line comment contains a lowercase word.\n+                public class Line { }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"-XDaccessInternalAPI\", \/\/ required to access JavacTrees\n+                \"-doclet\", \"TestTransformer$MyDoclet\",\n+                \"-docletpath\", System.getProperty(\"test.classes\"),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/Line.html\", true, \"\"\"\n+                <div class=\"block\">This line comment contains a UPPERCASE word.<\/div>\"\"\");\n+        checkOutput(\"p\/Trad.html\", true, \"\"\"\n+                <div class=\"block\">This traditional comment contains a UPPERCASE word.<\/div>\"\"\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/testTransformer\/TestTransformer.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331535\n+ * @summary Test the JShell tool Console handling\n+ * @modules jdk.internal.le\/jdk.internal.org.jline.reader\n+ *          jdk.jshell\/jdk.internal.jshell.tool:+open\n+ * @build ConsoleToolTest ReplToolTesting\n+ * @run testng ConsoleToolTest\n+ *\/\n+\n+\n+import org.testng.annotations.Test;\n+\n+public class ConsoleToolTest extends ReplToolTesting {\n+\n+    @Test\n+    public void testOutput() {\n+        test(\n+             a -> {assertCommandWithOutputAndTerminal(a,\n+                                                      \"System.console().readLine(\\\"%%s\\\");\\ninput\", \/\/newline automatically appended\n+                                                      \"$1 ==> \\\"input\\\"\",\n+                                                      \"\"\"\n+                                                      \\u0005System.console().readLine(\\\"%%s\\\");\n+                                                      %sinput\n+                                                      \"\"\");},\n+             a -> {assertCommandWithOutputAndTerminal(a,\n+                                                      \"System.console().readPassword(\\\"%%s\\\");\\ninput!\", \/\/newline automatically appended\n+                                                      \"$2 ==> char[6] { 'i', 'n', 'p', 'u', 't', '!' }\",\n+                                                      \"\"\"\n+                                                      \\u0005System.console().readPassword(\\\"%%s\\\");\n+                                                      %s\n+                                                      \"\"\");}\n+            );\n+    }\n+\n+    void assertCommandWithOutputAndTerminal(boolean a, String command, String out, String terminalOut) {\n+        assertCommand(a, command, out, null, null, null, null, terminalOut);\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ConsoleToolTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- *          jdk.internal.le\/jdk.internal.org.jline.terminal.impl\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.impl.exec\n@@ -38,1 +38,2 @@\n-import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.impl.exec.ExecPty;\n+import jdk.internal.org.jline.terminal.spi.SystemStream;\n@@ -42,2 +43,2 @@\n-    public ExecPtyGetFlagsToSetTest(String name, TerminalProvider.Stream stream) {\n-        super(name, stream);\n+    public ExecPtyGetFlagsToSetTest(TerminalProvider provider, SystemStream stream, String name) {\n+        super(provider, stream, name);\n@@ -53,1 +54,1 @@\n-            new ExecPtyGetFlagsToSetTest(\"stty\", TerminalProvider.Stream.Output);\n+            new ExecPtyGetFlagsToSetTest(null, SystemStream.Output, \"stty\");\n","filename":"test\/langtools\/jdk\/jshell\/ExecPtyGetFlagsToSetTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8141415\n+ * @bug 8141415 8129418\n@@ -36,0 +36,1 @@\n+import java.lang.reflect.Method;\n@@ -38,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -40,0 +42,1 @@\n+import jdk.jshell.JShell;\n@@ -46,0 +49,1 @@\n+import static jdk.jshell.Snippet.SubKind.MODULE_IMPORT_SUBKIND;\n@@ -79,1 +83,0 @@\n-    @Test(enabled = false) \/\/ TODO 8129418\n@@ -84,1 +87,1 @@\n-                new ExpectedDiagnostic(\"compiler.err.doesnt.exist\", 7, 15, 7, -1, -1, Diagnostic.Kind.ERROR));\n+                new ExpectedDiagnostic(\"compiler.err.doesnt.exist\", 7, 14, 7, -1, -1, Diagnostic.Kind.ERROR));\n@@ -171,0 +174,16 @@\n+\n+    public void testImportModule() {\n+        assertImportKeyMatch(\"import module java.base;\", \"java.base\", MODULE_IMPORT_SUBKIND, added(VALID));\n+        assertEval(\"MethodHandle m;\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp(Method m) {\n+        switch (m.getName()) {\n+            case \"testImportModule\" ->\n+                super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+            default ->\n+                super.setUp(bc -> {});\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ImportTest.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,0 +271,1 @@\n+            case MODULE_IMPORT_SUBKIND:\n","filename":"test\/langtools\/jdk\/jshell\/KullaTesting.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,0 +224,6 @@\n+    public String getTerminalOutput() {\n+        String s = normalizeLineEndings(\"\\r\\n\", console.data.toString());\n+        console.data.reset();\n+        return s;\n+    }\n+\n@@ -479,0 +485,1 @@\n+\n@@ -535,0 +542,5 @@\n+        assertCommand(after, cmd, out, err, userinput, print, usererr, null);\n+    }\n+\n+    public void assertCommand(boolean after, String cmd, String out, String err,\n+            String userinput, String print, String usererr, String terminalOut) {\n@@ -549,0 +561,1 @@\n+            assertOutput(getTerminalOutput(), terminalOut, \"terminal output: \" + cmd);\n@@ -568,1 +581,5 @@\n-        return ANSI_CODE_PATTERN.matcher(text.replace(System.getProperty(\"line.separator\"), \"\\n\")).replaceAll(\"\");\n+        return normalizeLineEndings(System.getProperty(\"line.separator\"), text);\n+    }\n+\n+    private String normalizeLineEndings(String lineSeparator, String text) {\n+        return ANSI_CODE_PATTERN.matcher(text.replace(lineSeparator, \"\\n\")).replaceAll(\"\");\n@@ -849,0 +866,1 @@\n+        private final ByteArrayOutputStream data = new ByteArrayOutputStream();\n@@ -864,1 +882,2 @@\n-            } \/\/ For now, anything else is thrown away\n+            }\n+            data.write(b);\n","filename":"test\/langtools\/jdk\/jshell\/ReplToolTesting.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,0 +129,7 @@\n+    protected void startCheckUserOutput(Consumer<String> checkUserOutput,\n+            String... args) {\n+        runShell(args);\n+        check(userout, checkUserOutput, \"userout\");\n+        check(usererr, null, \"usererr\");\n+    }\n+\n@@ -361,0 +368,11 @@\n+    public void testPreviewEnabled() {\n+        String fn = writeToFile(\"System.out.println(\\\"prefix\\\");\\n\" +\n+                \"System.out.println(MethodHandle.class.getName());\\n\" +\n+                \"System.out.println(\\\"suffix\\\");\\n\" +\n+                \"\/exit\\n\");\n+        startCheckUserOutput(s -> assertEquals(s, \"prefix\\nsuffix\\n\"),\n+                             fn);\n+        startCheckUserOutput(s -> assertEquals(s, \"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\"),\n+                             \"--enable-preview\", fn);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/StartOptionTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.function.Consumer;\n@@ -61,0 +62,7 @@\n+    @Override\n+    protected void startCheckUserOutput(Consumer<String> checkUserOutput, String... args) {\n+        runShell(args);\n+        check(cmdout, checkUserOutput, \"userout\");\n+        check(usererr, null, \"usererr\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ToolProviderTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-TestImportStar.java:16:1: compiler.err.doesnt.exist: xxx\n+TestImportStar.java:16:8: compiler.err.doesnt.exist: xxx\n","filename":"test\/langtools\/tools\/javac\/7129225\/NegTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-TestImportStar.java:16:1: compiler.err.doesnt.exist: xxx\n+TestImportStar.java:16:8: compiler.err.doesnt.exist: xxx\n","filename":"test\/langtools\/tools\/javac\/7129225\/TestImportStar.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,2 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -source 16 -target 16 CheckACC_STRICTFlagOnclinitTest.java\n- * @run main CheckACC_STRICTFlagOnclinitTest\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n@@ -33,0 +32,7 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.nio.file.Path;\n@@ -35,1 +41,0 @@\n-import java.io.File;\n@@ -37,7 +42,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Method;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_STRICT;\n@@ -45,1 +43,1 @@\n-public strictfp class CheckACC_STRICTFlagOnclinitTest {\n+public class CheckACC_STRICTFlagOnclinitTest {\n@@ -52,4 +50,15 @@\n-    static {\n-        class Foo {\n-            class Bar {\n-                void m11() {}\n+    private static final String SOURCE = \"\"\"\n+            public strictfp class Test {\n+                static {\n+                    class Foo {\n+                        class Bar {\n+                            void m11() {}\n+                        }\n+                        void m1() {}\n+                    }\n+                }\n+                void m2() {\n+                    class Any {\n+                        void m21() {}\n+                    }\n+                }\n@@ -57,8 +66,1 @@\n-            void m1() {}\n-        }\n-    }\n-    void m2() {\n-        class Any {\n-            void m21() {}\n-        }\n-    }\n+            \"\"\";\n@@ -66,1 +68,1 @@\n-    private List<String> errors = new ArrayList<>();\n+    private final List<String> errors = new ArrayList<>();\n@@ -69,1 +71,1 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+            throws IOException {\n@@ -74,8 +76,12 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n-        String testClasses = System.getProperty(\"test.classes\");\n-        check(testClasses,\n-              \"CheckACC_STRICTFlagOnclinitTest.class\",\n-              \"CheckACC_STRICTFlagOnclinitTest$1Foo.class\",\n-              \"CheckACC_STRICTFlagOnclinitTest$1Foo$Bar.class\",\n-              \"CheckACC_STRICTFlagOnclinitTest$1Any.class\");\n-        if (errors.size() > 0) {\n+            throws IOException {\n+        Path in = Path.of(\"in\");\n+        Path out = Path.of(\"out\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(in, SOURCE);\n+        CompilerUtils.compile(in, out, \"--release\", \"16\");\n+        check(out,\n+              \"Test.class\",\n+              \"Test$1Foo.class\",\n+              \"Test$1Foo$Bar.class\",\n+              \"Test$1Any.class\");\n+        if (!errors.isEmpty()) {\n@@ -89,5 +95,1 @@\n-    void check(String dir, String... fileNames)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n+    void check(Path dir, String... fileNames) throws IOException {\n@@ -95,1 +97,1 @@\n-            ClassFile classFileToCheck = ClassFile.read(new File(dir, fileName));\n+            ClassModel classFileToCheck = ClassFile.of().parse(dir.resolve(fileName));\n@@ -97,2 +99,2 @@\n-            for (Method method : classFileToCheck.methods) {\n-                if ((method.access_flags.flags & ACC_STRICT) == 0) {\n+            for (MethodModel method : classFileToCheck.methods()) {\n+                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n@@ -100,2 +102,2 @@\n-                            method.getName(classFileToCheck.constant_pool),\n-                            classFileToCheck.getName()));\n+                            method.methodName().stringValue(),\n+                            classFileToCheck.thisClass().asInternalName()));\n@@ -106,16 +108,0 @@\n-\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    void check(String dir, String... fileNames) throws IOException{\n-\/\/        for (String fileName : fileNames) {\n-\/\/            ClassModel classFileToCheck = ClassFile.of().parse(new File(dir, fileName).toPath());\n-\/\/\n-\/\/            for (MethodModel method : classFileToCheck.methods()) {\n-\/\/                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n-\/\/                    errors.add(String.format(offendingMethodErrorMessage,\n-\/\/                            method.methodName().stringValue(),\n-\/\/                            classFileToCheck.thisClass().asInternalName()));\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/    }\n-\n","filename":"test\/langtools\/tools\/javac\/7166455\/CheckACC_STRICTFlagOnclinitTest.java","additions":47,"deletions":61,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,744 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8328481 8332236\n+ * @summary Check behavior of module imports.\n+ * @library \/tools\/lib\n+ * @modules java.logging\n+ *          java.sql\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ImportModule\n+*\/\n+\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskEvent.Kind;\n+import com.sun.source.util.TaskListener;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class ImportModule extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ImportModule().runTests();\n+    }\n+\n+    ImportModule() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testImportJavaBase(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                              public static void main(String... args) {\n+                                  List<String> l = new ArrayList<>();\n+                                  System.out.println(l.getClass().getName());\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\/\/with --release:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"test.Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+\n+        {\/\/with --source:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--source\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"test.Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySourceLevelCheck(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--release\", \"21\", \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:8: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.module.imports)\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:8: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.module.imports)\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testConflicts(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          public class Test {\n+                              Logger l;\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:5:5: compiler.err.ref.ambiguous: Logger, kindname.interface, java.lang.System.Logger, java.lang.System, kindname.class, java.util.logging.Logger, java.util.logging\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          import java.lang.System.Logger;\n+                          public class Test {\n+                              Logger l;\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          import java.util.logging.Logger;\n+                          public class Test {\n+                              Logger l;\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          import module java.sql;\n+                          public class Test {\n+                              Date d;\n+                          }\n+                          \"\"\");\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:5:5: compiler.err.ref.ambiguous: Date, kindname.class, java.sql.Date, java.sql, kindname.class, java.util.Date, java.util\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          import module java.sql;\n+                          import java.util.Date;\n+                          public class Test {\n+                              Date d;\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+    }\n+\n+    @Test\n+    public void testNoQualifiedExports(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+\n+        Path lib = current.resolve(\"lib\");\n+        Path libSrc = lib.resolve(\"src\");\n+        Path libClasses = lib.resolve(\"classes\");\n+        tb.writeJavaFiles(libSrc,\n+                          \"\"\"\n+                          module lib {\n+                              exports api;\n+                              exports impl to use;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api;\n+                          public class Api {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl;\n+                          public class Impl {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+            .outdir(libClasses)\n+            .files(tb.findJavaFiles(libSrc))\n+            .run()\n+            .writeAll();\n+\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module lib;\n+                          public class Test {\n+                              public static void main(String... args) {\n+                                  Api a;\n+                                  Impl i;\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-p\", libClasses.toString(),\n+                             \"--add-modules\", \"lib\",\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:6:9: compiler.err.cant.resolve.location: kindname.class, Impl, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-p\", libClasses.toString(),\n+                             \"-XDdev\",\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:1: compiler.err.import.module.does.not.read.unnamed: lib\",\n+                \"Test.java:6:9: compiler.err.cant.resolve.location: kindname.class, Impl, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module test.module {\n+                          }\n+                          \"\"\");\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-p\", libClasses.toString(),\n+                             \"-XDdev\",\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:1: compiler.err.import.module.does.not.read: test.module, lib\",\n+                \"Test.java:6:9: compiler.err.cant.resolve.location: kindname.class, Impl, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testTransitiveDependencies(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path lib = current.resolve(\"lib\");\n+        Path libSrc = lib.resolve(\"src\");\n+        Path libM1 = libSrc.resolve(\"m1\");\n+        tb.writeJavaFiles(libM1,\n+                          \"\"\"\n+                          module m1 {\n+                              requires transitive m2;\n+                              exports api1;\n+                              exports api2 to test;\n+                              exports api3 to m3;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api1;\n+                          public class Api1 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api2;\n+                          public class Api2 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api3;\n+                          public class Api3 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl1;\n+                          public class Impl1 {\n+                          }\n+                          \"\"\");\n+\n+        Path libM2 = libSrc.resolve(\"m2\");\n+        tb.writeJavaFiles(libM2,\n+                          \"\"\"\n+                          module m2 {\n+                              exports api4;\n+                              exports api5 to test;\n+                              exports api6 to m3;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api4;\n+                          public class Api4 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api5;\n+                          public class Api5 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api6;\n+                          public class Api6 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl2;\n+                          public class Impl2 {\n+                          }\n+                          \"\"\");\n+\n+        Path libClasses = lib.resolve(\"classes\");\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                     \"--module-source-path\", libSrc.toString(),\n+                     \"-XDrawDiagnostics\")\n+            .outdir(libClasses)\n+            .files(tb.findJavaFiles(libSrc))\n+            .run()\n+            .writeAll();\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module test {\n+                              requires m1;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          import module m1;\n+                          public class Test1 {\n+                              Api1 a1;\n+                              Api2 a2;\n+                              Api3 a3;\n+                              Impl1 i1;\n+                              Api4 a4;\n+                              Api5 a5;\n+                              Api6 a6;\n+                              Impl2 i2;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          import module m2;\n+                          public class Test2 {\n+                              Api1 a1;\n+                              Api2 a2;\n+                              Api3 a3;\n+                              Impl1 i1;\n+                              Api4 a4;\n+                              Api5 a5;\n+                              Api6 a6;\n+                              Impl2 i2;\n+                          }\n+                          \"\"\");\n+\n+        Path classes = current.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"--module-path\", libClasses.toString(),\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test1.java:6:5: compiler.err.cant.resolve.location: kindname.class, Api3, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test1.java:7:5: compiler.err.cant.resolve.location: kindname.class, Impl1, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test1.java:10:5: compiler.err.cant.resolve.location: kindname.class, Api6, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test1.java:11:5: compiler.err.cant.resolve.location: kindname.class, Impl2, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test2.java:4:5: compiler.err.cant.resolve.location: kindname.class, Api1, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:5:5: compiler.err.cant.resolve.location: kindname.class, Api2, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:6:5: compiler.err.cant.resolve.location: kindname.class, Api3, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:7:5: compiler.err.cant.resolve.location: kindname.class, Impl1, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:10:5: compiler.err.cant.resolve.location: kindname.class, Api6, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:11:5: compiler.err.cant.resolve.location: kindname.class, Impl2, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"- compiler.note.preview.plural: DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"10 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testModel(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+        List<String> kinds = new ArrayList<>();\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .callback(task -> {\n+                task.addTaskListener(new TaskListener() {\n+                    @Override\n+                    public void finished(TaskEvent e) {\n+                        if (e.getKind() == Kind.ANALYZE) {\n+                            for (Tree t : e.getCompilationUnit().getTypeDecls()) {\n+                                kinds.add(t.getKind().name());\n+                            }\n+                        }\n+                    }\n+                });\n+            })\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        List<String> expectedKinds = List.of(\n+            \"CLASS\"\n+        );\n+\n+        if (!Objects.equals(expectedKinds, kinds)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedKinds +\n+                                      \", actual: \" + kinds);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testModelDisambiguation(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module.*;\n+                          import module.ModuleClass;\n+                          import module.module.*;\n+                          import module.module.ModuleModuleClass;\n+                          public class Test {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package module;\n+                          public class ModuleClass{\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package module.module;\n+                          public class ModuleModuleClass {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+        List<String> kinds = new ArrayList<>();\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n+    @Test\n+    public void testImplicitlyDeclaredClass(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     import module java.base;\n+                     void main() {\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":744,"deletions":0,"binary":false,"changes":744,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,2 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.BootstrapMethods_attribute.BootstrapMethodSpecifier;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodHandle_info;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n@@ -29,1 +27,10 @@\n-import java.io.File;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BootstrapMethodEntry;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.constantpool.MethodHandleEntry;\n+import java.lang.classfile.instruction.InvokeDynamicInstruction;\n+import java.nio.file.Path;\n@@ -35,17 +42,3 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *\n- * @clean *\n- * @compile -source 8 -target 8 TestIndyStringConcat.java\n- * @run main TestIndyStringConcat false\n- *\n- * @clean *\n- * @compile -XDstringConcat=inline TestIndyStringConcat.java\n- * @run main TestIndyStringConcat false\n- *\n- * @clean *\n- * @compile -XDstringConcat=indy TestIndyStringConcat.java\n- * @run main TestIndyStringConcat true\n- *\n- * @clean *\n- * @compile -XDstringConcat=indyWithConstants TestIndyStringConcat.java\n- * @run main TestIndyStringConcat true\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n+ * @run main TestIndyStringConcat\n@@ -55,1 +48,3 @@\n-    static String other;\n+    private static final String SOURCE = \"\"\"\n+            public class IndyStringConcat {\n+                static String other;\n@@ -57,3 +52,5 @@\n-    public static String test() {\n-        return \"Foo\" + other;\n-    }\n+                public static String test() {\n+                    return \"Foo\" + other;\n+                }\n+            }\n+            \"\"\";\n@@ -62,11 +59,3 @@\n-        boolean expected = Boolean.valueOf(args[0]);\n-        boolean actual = hasStringConcatFactoryCall(\"test\");\n-        if (expected != actual) {\n-            throw new AssertionError(\"expected = \" + expected + \", actual = \" + actual);\n-        }\n-    }\n-\n-    public static boolean hasStringConcatFactoryCall(String methodName) throws Exception {\n-        ClassFile classFile = ClassFile.read(new File(System.getProperty(\"test.classes\", \".\"),\n-                TestIndyStringConcat.class.getName() + \".class\"));\n-        ConstantPool constantPool = classFile.constant_pool;\n+        Path src = Path.of(\"src\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(src, SOURCE);\n@@ -74,3 +63,5 @@\n-        BootstrapMethods_attribute bsm_attr =\n-                (BootstrapMethods_attribute)classFile\n-                        .getAttribute(Attribute.BootstrapMethods);\n+        int errors = 0;\n+        errors += test(false, \"java8\", \"-source\", \"8\", \"-target\", \"8\");\n+        errors += test(false, \"inline\", \"-XDstringConcat=inline\");\n+        errors += test(true, \"indy\", \"-XDstringConcat=indy\");\n+        errors += test(true, \"indyWithConstants\", \"-XDstringConcat=indyWithConstants\");\n@@ -78,8 +69,4 @@\n-        for (Method method : classFile.methods) {\n-            if (method.getName(constantPool).equals(methodName)) {\n-                Code_attribute code = (Code_attribute) method.attributes\n-                        .get(Attribute.Code);\n-                for (Instruction i : code.getInstructions()) {\n-                    if (i.getOpcode() == Opcode.INVOKEDYNAMIC) {\n-                        CONSTANT_InvokeDynamic_info indyInfo =\n-                                (CONSTANT_InvokeDynamic_info) constantPool.get(i.getUnsignedShort(1));\n+        if (errors > 0) {\n+            throw new AssertionError(errors + \" cases failed\");\n+        }\n+    }\n@@ -87,2 +74,10 @@\n-                        BootstrapMethodSpecifier bsmSpec =\n-                                bsm_attr.bootstrap_method_specifiers[indyInfo.bootstrap_method_attr_index];\n+    public static int test(boolean expected, String label, String... args) throws Exception {\n+        Path src = Path.of(\"src\");\n+        Path out = Path.of(label);\n+        CompilerUtils.compile(src, out, args);\n+        if (hasStringConcatFactoryCall(out.resolve(\"IndyStringConcat.class\"), \"test\") != expected) {\n+            System.err.println(\"Expected \" + expected + \" failed for case \" + label);\n+            return 1;\n+        }\n+        return 0;\n+    }\n@@ -90,2 +85,2 @@\n-                        CONSTANT_MethodHandle_info bsmInfo =\n-                                (CONSTANT_MethodHandle_info) constantPool.get(bsmSpec.bootstrap_method_ref);\n+    public static boolean hasStringConcatFactoryCall(Path file, String methodName) throws Exception {\n+        ClassModel classFile = ClassFile.of().parse(file);\n@@ -93,1 +88,8 @@\n-                        if (bsmInfo.getCPRefInfo().getClassName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n+        for (MethodModel method : classFile.methods()) {\n+            if (method.methodName().equalsString(methodName)) {\n+                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n+                for (CodeElement i : code.elementList()) {\n+                    if (i instanceof InvokeDynamicInstruction indy) {\n+                        BootstrapMethodEntry bsmSpec = indy.invokedynamic().bootstrap();\n+                        MethodHandleEntry bsmInfo = bsmSpec.bootstrapMethod();\n+                        if (bsmInfo.reference().owner().asInternalName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n@@ -103,23 +105,0 @@\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    public static boolean hasStringConcatFactoryCall(String methodName) throws Exception {\n-\/\/        ClassModel classFile = ClassFile.of().parse(new File(System.getProperty(\"test.classes\", \".\"),\n-\/\/                TestIndyStringConcat.class.getName() + \".class\").toPath());\n-\/\/\n-\/\/        for (MethodModel method : classFile.methods()) {\n-\/\/            if (method.methodName().equalsString(methodName)) {\n-\/\/                CodeAttribute code = method.findAttribute(Attributes.CODE).orElseThrow();\n-\/\/                for (CodeElement i : code.elementList()) {\n-\/\/                    if (i instanceof InvokeDynamicInstruction) {\n-\/\/                        InvokeDynamicInstruction indy = (InvokeDynamicInstruction) i;\n-\/\/                        BootstrapMethodEntry bsmSpec = indy.invokedynamic().bootstrap();\n-\/\/                        MethodHandleEntry bsmInfo = bsmSpec.bootstrapMethod();\n-\/\/                        if (bsmInfo.reference().owner().asInternalName().equals(\"java\/lang\/invoke\/StringConcatFactory\")) {\n-\/\/                            return true;\n-\/\/                        }\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/        return false;\n-\/\/    }\n-\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/TestIndyStringConcat.java","additions":56,"deletions":77,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.SourceFile_attribute;\n-\n-import java.io.InputStream;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import javax.tools.JavaFileObject;\n-\n-import toolbox.ToolBox;\n-\n-\/**\n- * Base class for Source file attribute tests. Checks expected file name for specified classes in the SourceFile attribute.\n- * To add new tests you should extend the SourceFileTestBase class and invoke {@link #test} for static sources\n- * or {@link #compileAndTest} for generated sources. For more information see corresponding methods.\n- *\n- * @see #test\n- * @see #compileAndTest\n- *\/\n-public class SourceFileTestBase_legacy extends TestBase {\n-    \/**\n-     * Checks expected fileName for the specified class in the SourceFile attribute.\n-     *\n-     * @param classToTest class to check its SourceFile attribute\n-     * @param fileName    expected name of the file from which the test file is compiled.\n-     *\/\n-    protected void test(Class<?> classToTest, String fileName) throws Exception {\n-        assertAttributePresent(ClassFile.read(getClassFile(classToTest)), fileName);\n-    }\n-\n-    \/**\n-     * Checks expected fileName for the specified class in the SourceFile attribute.\n-     *\n-     * @param classToTest class name to check its SourceFile attribute\n-     * @param fileName    expected name of the file from which the test file is compiled.\n-     *\/\n-    protected void test(String classToTest, String fileName) throws Exception {\n-        assertAttributePresent(ClassFile.read(getClassFile(classToTest + \".class\")), fileName);\n-    }\n-\n-    \/**\n-     * Checks expected fileName for the specified class in the SourceFile attribute.\n-     *\n-     * @param classToTest path of class to check its SourceFile attribute\n-     * @param fileName    expected name of the file from which the test file is compiled.\n-     *\/\n-    protected void test(Path classToTest, String fileName) throws Exception {\n-        assertAttributePresent(ClassFile.read(classToTest), fileName);\n-    }\n-\n-    \/**\n-     * Compiles sourceCode and for each specified class name checks the SourceFile attribute.\n-     * The file name is extracted from source code.\n-     *\n-     * @param sourceCode    source code to compile\n-     * @param classesToTest class names to check their SourceFile attribute.\n-     *\/\n-    protected void compileAndTest(String sourceCode, String... classesToTest) throws Exception {\n-\n-        Map<String, ? extends JavaFileObject> classes = compile(sourceCode).getClasses();\n-        String fileName = ToolBox.getJavaFileNameFromSource(sourceCode);\n-        for (String className : classesToTest) {\n-            ClassFile classFile;\n-            try (InputStream input = classes.get(className).openInputStream()) {\n-                classFile = ClassFile.read(input);\n-            }\n-            assertAttributePresent(classFile, fileName);\n-        }\n-    }\n-\n-    private void assertAttributePresent(ClassFile classFile, String fileName) throws Exception {\n-\n-        \/\/We need to count attributes with the same names because there is no appropriate API in the ClassFile.\n-\n-        List<SourceFile_attribute> sourceFileAttributes = new ArrayList<>();\n-        for (Attribute a : classFile.attributes.attrs) {\n-            if (Attribute.SourceFile.equals(a.getName(classFile.constant_pool))) {\n-                sourceFileAttributes.add((SourceFile_attribute) a);\n-            }\n-        }\n-\n-        assertEquals(sourceFileAttributes.size(), 1, \"Should be the only SourceFile attribute\");\n-\n-        SourceFile_attribute attribute = sourceFileAttributes.get(0);\n-\n-        assertEquals(classFile.constant_pool.getUTF8Info(attribute.attribute_name_index).value,\n-                Attribute.SourceFile, \"Incorrect attribute name\");\n-        assertEquals(classFile.constant_pool.getUTF8Info(attribute.sourcefile_index).value, fileName,\n-                \"Incorrect source file name\");\n-        assertEquals(attribute.attribute_length, 2, \"Incorrect attribute length\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/SourceFileTestBase_legacy.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/tools\/lib \/tools\/javac\/lib ..\/lib_legacy\n+ * @library \/tools\/lib \/tools\/javac\/lib \/test\/lib ..\/lib\n@@ -31,7 +31,4 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n- * @build toolbox.ToolBox InMemoryFileManager TestBase SourceFileTestBase_legacy\n- * @compile -source 10 -target 10 SyntheticClassTest.java\n- * @run main SyntheticClassTest true\n- * @clean SyntheticClassTest$1\n- * @compile SyntheticClassTest.java\n- * @run main SyntheticClassTest false\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build toolbox.ToolBox InMemoryFileManager TestBase SourceFileTestBase\n+ * @enablePreview\n+ * @run main SyntheticClassTest\n@@ -40,0 +37,3 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n@@ -41,0 +41,1 @@\n+import java.nio.file.Path;\n@@ -42,1 +43,1 @@\n-public class SyntheticClassTest extends SourceFileTestBase_legacy {\n+public class SyntheticClassTest extends SourceFileTestBase {\n@@ -44,2 +45,22 @@\n-        boolean expectSynthetic = Boolean.parseBoolean(args[0]);\n-        new Inner();\n+        String sourceCode = \"\"\"\n+                public class SyntheticClass {\n+                    static class Inner {\n+                        private Inner() {\n+                        }\n+                    }\n+\n+                    public SyntheticClass() {\n+                        new Inner();\n+                    }\n+                }\n+                \"\"\";\n+        Path srcDir = Path.of(\"src\");\n+        Path v10Dir = Path.of(\"out10\");\n+        Path modernDir = Path.of(\"out\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(srcDir, sourceCode);\n+        CompilerUtils.compile(srcDir, v10Dir, \"--release\", \"10\");\n+        CompilerUtils.compile(srcDir, modernDir);\n+        test(v10Dir, true);\n+        test(modernDir, false);\n+    }\n@@ -47,0 +68,1 @@\n+    private static void test(Path path, boolean expectSynthetic) throws Exception {\n@@ -48,1 +70,1 @@\n-            new SyntheticClassTest().test(\"SyntheticClassTest$1\", \"SyntheticClassTest.java\");\n+            new SyntheticClassTest().test(path.resolve(\"SyntheticClass$1.class\"), \"SyntheticClass.java\");\n@@ -58,5 +80,0 @@\n-\n-    static class Inner {\n-        private Inner() {\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/SyntheticClassTest.java","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,6 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n- * @library \/tools\/lib \/tools\/javac\/lib ..\/lib_legacy\n- * @build toolbox.ToolBox InMemoryFileManager TestResult TestBase\n- * @build SyntheticTestDriver_legacy ExpectedClass ExpectedClasses\n+ * @library \/tools\/lib \/tools\/javac\/lib ..\/lib\n+ * @build toolbox.ToolBox InMemoryFileManager\n+ *        ExpectedClass ExpectedClasses\n+ * @compile --enable-preview --source ${jdk.version} --target ${jdk.version}\n+ *          SyntheticTestDriver.java\n+ *          ..\/lib\/TestResult.java ..\/lib\/TestBase.java\n@@ -37,1 +39,1 @@\n- * @run main SyntheticTestDriver_legacy BridgeMethodsForLambdaTargetRelease14Test\n+ * @run main\/othervm --enable-preview SyntheticTestDriver BridgeMethodsForLambdaTargetRelease14Test\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/BridgeMethodsForLambdaTargetRelease14Test.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.regex.*;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import com.sun.tools.classfile.*;\n-\n-\/**\n- * The tests work as follows. Firstly, it looks through the test cases\n- * and extracts the appropriate compiled classes. Each test case contains\n- * a set of expected classes, methods and fields. Those class members must not have\n- * the Synthetic attribute, while other found classes, methods and fields must have\n- * the Synthetic attribute if they are not in the set of expected class members.\n- *\n- * Each test executes SyntheticTestDriver specifying the name of test cases and\n- * the number of expected synthetic classes. Each test class is annotated by\n- * annotations which contains non-synthetic class members.\n- *\n- * See the appropriate class for more information about a test case.\n- *\/\n-public class SyntheticTestDriver_legacy extends TestResult {\n-\n-    private static final String ACC_SYNTHETIC = \"ACC_SYNTHETIC\";\n-\n-    private final String testCaseName;\n-    private final Map<String, ClassFile> classes;\n-    private final Map<String, ExpectedClass> expectedClasses;\n-\n-    public static void main(String[] args)\n-            throws TestFailedException, ConstantPoolException, IOException, ClassNotFoundException {\n-        if (args.length != 1 && args.length != 2) {\n-            throw new IllegalArgumentException(\"Usage: SyntheticTestDriver <class-name> [<number-of-synthetic-classes>]\");\n-        }\n-        int numberOfSyntheticClasses = args.length == 1 ? 0 : Integer.parseInt(args[1]);\n-        new SyntheticTestDriver_legacy(args[0]).test(numberOfSyntheticClasses);\n-    }\n-\n-    public SyntheticTestDriver_legacy(String testCaseName) throws IOException, ConstantPoolException, ClassNotFoundException {\n-        Class<?> clazz = Class.forName(testCaseName);\n-        this.testCaseName = testCaseName;\n-        this.expectedClasses = Stream.of(clazz.getAnnotationsByType(ExpectedClass.class))\n-                .collect(Collectors.toMap(ExpectedClass::className, Function.identity()));\n-        this.classes = new HashMap<>();\n-        Path classDir = getClassDir().toPath();\n-        Pattern filePattern = Pattern.compile(Pattern.quote(testCaseName.replace('.', File.separatorChar)) + \".*\\\\.class\");\n-        List<Path> paths = Files.walk(classDir)\n-                .map(p -> classDir.relativize(p.toAbsolutePath()))\n-                .filter(p -> filePattern.matcher(p.toString()).matches())\n-                .collect(Collectors.toList());\n-        for (Path path : paths) {\n-            String className = path.toString().replace(\".class\", \"\").replace(File.separatorChar, '.');\n-            classes.put(className, readClassFile(classDir.resolve(path).toFile()));\n-        }\n-        if (classes.isEmpty()) {\n-            throw new RuntimeException(\"Classes have not been found.\");\n-        }\n-        boolean success = classes.entrySet().stream()\n-                .allMatch(e -> e.getKey().startsWith(testCaseName));\n-        if (!success) {\n-            classes.forEach((className, $) -> printf(\"Found class: %s\\n\", className));\n-            throw new RuntimeException(\"Found classes are not from the test case : \" + testCaseName);\n-        }\n-    }\n-\n-    private String getMethodName(ClassFile classFile, Method method)\n-            throws ConstantPoolException, Descriptor.InvalidDescriptor {\n-        String methodName = method.getName(classFile.constant_pool);\n-        String parameters = method.descriptor.getParameterTypes(classFile.constant_pool);\n-        return methodName + parameters;\n-    }\n-\n-    public void test(int expectedNumberOfSyntheticClasses) throws TestFailedException {\n-        try {\n-            addTestCase(testCaseName);\n-            Set<String> foundClasses = new HashSet<>();\n-\n-            int numberOfSyntheticClasses = 0;\n-            for (Map.Entry<String, ClassFile> entry : classes.entrySet()) {\n-                String className = entry.getKey();\n-                ClassFile classFile = entry.getValue();\n-                foundClasses.add(className);\n-                if (testAttribute(\n-                        classFile,\n-                        () -> (Synthetic_attribute) classFile.getAttribute(Attribute.Synthetic),\n-                        classFile.access_flags::getClassFlags,\n-                        expectedClasses.keySet(),\n-                        className,\n-                        \"Testing class \" + className)) {\n-                    ++numberOfSyntheticClasses;\n-                }\n-                ExpectedClass expectedClass = expectedClasses.get(className);\n-                Set<String> expectedMethods = expectedClass != null\n-                        ? toSet(expectedClass.expectedMethods())\n-                        : new HashSet<>();\n-                int numberOfSyntheticMethods = 0;\n-                Set<String> foundMethods = new HashSet<>();\n-                for (Method method : classFile.methods) {\n-                    String methodName = getMethodName(classFile, method);\n-                    foundMethods.add(methodName);\n-                    if (testAttribute(\n-                            classFile,\n-                            () -> (Synthetic_attribute) method.attributes.get(Attribute.Synthetic),\n-                            method.access_flags::getMethodFlags,\n-                            expectedMethods,\n-                            methodName,\n-                            \"Testing method \" + methodName + \" in class \"\n-                                    + className)) {\n-                        ++numberOfSyntheticMethods;\n-                    }\n-                }\n-                checkContains(foundMethods, expectedMethods,\n-                        \"Checking that all methods of class \" + className\n-                                + \" without Synthetic attribute have been found\");\n-                checkEquals(numberOfSyntheticMethods,\n-                        expectedClass == null ? 0 : expectedClass.expectedNumberOfSyntheticMethods(),\n-                        \"Checking number of synthetic methods in class: \" + className);\n-\n-                Set<String> expectedFields = expectedClass != null\n-                        ? toSet(expectedClass.expectedFields())\n-                        : new HashSet<>();\n-                int numberOfSyntheticFields = 0;\n-                Set<String> foundFields = new HashSet<>();\n-                for (Field field : classFile.fields) {\n-                    String fieldName = field.getName(classFile.constant_pool);\n-                    foundFields.add(fieldName);\n-                    if (testAttribute(\n-                            classFile,\n-                            () -> (Synthetic_attribute) field.attributes.get(Attribute.Synthetic),\n-                            field.access_flags::getFieldFlags,\n-                            expectedFields,\n-                            fieldName,\n-                            \"Testing field \" + fieldName + \" in class \"\n-                                    + className)) {\n-                        ++numberOfSyntheticFields;\n-                    }\n-                }\n-                checkContains(foundFields, expectedFields,\n-                        \"Checking that all fields of class \" + className\n-                                + \" without Synthetic attribute have been found\");\n-                checkEquals(numberOfSyntheticFields,\n-                        expectedClass == null ? 0 : expectedClass.expectedNumberOfSyntheticFields(),\n-                        \"Checking number of synthetic fields in class: \" + className);\n-            }\n-            checkContains(foundClasses, expectedClasses.keySet(),\n-                    \"Checking that all classes have been found\");\n-            checkEquals(numberOfSyntheticClasses, expectedNumberOfSyntheticClasses,\n-                    \"Checking number of synthetic classes\");\n-        } catch (Exception e) {\n-            addFailure(e);\n-        } finally {\n-            checkStatus();\n-        }\n-    }\n-\n-    private boolean testAttribute(ClassFile classFile,\n-                               Supplier<Synthetic_attribute> getSyntheticAttribute,\n-                               Supplier<Set<String>> getAccessFlags,\n-                               Set<String> expectedMembers, String memberName,\n-                               String info) throws ConstantPoolException {\n-        echo(info);\n-        String className = classFile.getName();\n-        Synthetic_attribute attr = getSyntheticAttribute.get();\n-        Set<String> flags = getAccessFlags.get();\n-        if (expectedMembers.contains(memberName)) {\n-            checkNull(attr, \"Member must not have synthetic attribute : \"\n-                    + memberName);\n-            checkFalse(flags.contains(ACC_SYNTHETIC),\n-                    \"Member must not have synthetic flag : \" + memberName\n-                            + \" in class : \" + className);\n-            return false;\n-        } else {\n-            return checkNull(attr, \"Synthetic attribute should not be generated\")\n-                    && checkTrue(flags.contains(ACC_SYNTHETIC), \"Member must have synthetic flag : \"\n-                                + memberName + \" in class : \" + className);\n-        }\n-    }\n-\n-    private Set<String> toSet(String[] strings) {\n-        HashSet<String> set = new HashSet<>();\n-        Collections.addAll(set, strings);\n-        return set;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/SyntheticTestDriver_legacy.java","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8042261\n+ * @bug 8042261 8298405\n@@ -70,0 +70,1 @@\n+                test(PACKAGE_INFO.replaceAll(\"@Deprecated\", \"\/\/\/ @deprecated\\n\"), src);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/deprecated\/DeprecatedPackageTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8042261\n+ * @bug 8042261 8298405\n@@ -226,0 +226,2 @@\n+                test(src.replaceAll(\"deprecated\", \"notDeprecated2\") \/\/ change element name\n+                        .replaceAll(\"@Deprecated\", \"\/\/\/ @deprecated\\n\"));\n@@ -239,3 +241,3 @@\n-            String outerClassName = classes.containsKey(\"deprecated\")\n-                    ? \"deprecated\"\n-                    : \"notDeprecated\";\n+            String outerClassName = classes.keySet().stream()\n+                    .filter(n -> !n.contains(\"$\"))\n+                    .findFirst().orElse(null);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/deprecated\/DeprecatedTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,284 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-import javax.tools.DiagnosticCollector;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileObject;\n-import javax.tools.ToolProvider;\n-\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-\n-import toolbox.JavacTask;\n-import toolbox.ToolBox;\n-\n-\/**\n- * Base class for class file attribute tests.\n- * Contains methods for compiling generated sources in memory,\n- * for reading files from disk and a lot of assert* methods.\n- *\/\n-public class TestBase {\n-\n-    public static final String LINE_SEPARATOR = System.lineSeparator();\n-    public static final boolean isDumpOfSourceEnabled = Boolean.getBoolean(\"dump.src\");\n-\n-    private <S> InMemoryFileManager compile(\n-            List<String> options,\n-            Function<S, ? extends JavaFileObject> src2JavaFileObject,\n-            List<S> sources)\n-            throws IOException, CompilationException {\n-\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        List<? extends JavaFileObject> src = sources.stream()\n-                .map(src2JavaFileObject)\n-                .collect(Collectors.toList());\n-\n-        DiagnosticCollector<? super JavaFileObject> dc = new DiagnosticCollector<>();\n-        try (InMemoryFileManager fileManager\n-                     = new InMemoryFileManager(compiler.getStandardFileManager(null, null, null))) {\n-            JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, dc, options, null, src);\n-            boolean success = task.call();\n-            if (!success) {\n-                String errorMessage = dc.getDiagnostics().stream()\n-                        .map(Object::toString)\n-                        .collect(Collectors.joining(\"\\n\"));\n-                throw new CompilationException(\"Compilation Error\\n\\n\" + errorMessage);\n-            }\n-            return fileManager;\n-        }\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param sources to compile\n-     * @return in-memory file manager which contains class files and class loader\n-     *\/\n-    public InMemoryFileManager compile(String... sources)\n-            throws IOException, CompilationException {\n-        return compile(Collections.emptyList(), sources);\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param options compiler options.\n-     * @param sources sources to compile.\n-     * @return in-memory file manager which contains class files and class loader.\n-     *\/\n-    public InMemoryFileManager compile(List<String> options, String... sources)\n-            throws IOException, CompilationException {\n-        return compile(options, ToolBox.JavaSource::new, Arrays.asList(sources));\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param sources sources[i][0] - name of file, sources[i][1] - sources.\n-     * @return in-memory file manager which contains class files and class loader.\n-     *\/\n-    public InMemoryFileManager compile(String[]... sources) throws IOException,\n-            CompilationException {\n-        return compile(Collections.emptyList(), sources);\n-    }\n-\n-    \/**\n-     * Compiles sources in memory.\n-     *\n-     * @param options compiler options\n-     * @param sources sources[i][0] - name of file, sources[i][1] - sources.\n-     * @return in-memory file manager which contains class files and class loader.\n-     *\/\n-    public InMemoryFileManager compile(List<String> options, String[]... sources)\n-            throws IOException, CompilationException {\n-        return compile(options, src -> new ToolBox.JavaSource(src[0], src[1]), Arrays.asList(sources));\n-    }\n-\n-    \/**\n-     * Returns class file that is read from {@code is}.\n-     *\n-     * @param is an input stream\n-     * @return class file that is read from {@code is}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(InputStream is) throws IOException, ConstantPoolException {\n-        return ClassFile.read(is);\n-    }\n-\n-    \/**\n-     * Returns class file that is read from {@code fileObject}.\n-     *\n-     * @param fileObject a file object\n-     * @return class file that is read from {@code fileObject}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(JavaFileObject fileObject) throws IOException, ConstantPoolException {\n-        try (InputStream is = fileObject.openInputStream()) {\n-            return readClassFile(is);\n-        }\n-    }\n-\n-    \/**\n-     * Returns class file that corresponds to {@code clazz}.\n-     *\n-     * @param clazz a class\n-     * @return class file that is read from {@code clazz}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(Class<?> clazz) throws IOException, ConstantPoolException {\n-        return readClassFile(getClassFile(clazz));\n-    }\n-\n-    \/**\n-     * Returns class file that corresponds to {@code className}.\n-     *\n-     * @param className a class name\n-     * @return class file that is read from {@code className}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(String className) throws IOException, ConstantPoolException {\n-        return readClassFile(getClassFile(className + \".class\"));\n-    }\n-\n-    \/**\n-     * Returns class file that is read from {@code file}.\n-     *\n-     * @param file a file\n-     * @return class file that is read from {@code file}\n-     * @throws IOException if I\/O error occurs\n-     * @throws ConstantPoolException if constant pool error occurs\n-     *\/\n-    public ClassFile readClassFile(File file) throws IOException, ConstantPoolException {\n-        try (InputStream is = new FileInputStream(file)) {\n-            return readClassFile(is);\n-        }\n-    }\n-\n-    public void assertEquals(Object actual, Object expected, String message) {\n-        if (!Objects.equals(actual, expected))\n-            throw new AssertionFailedException(String.format(\"%s%nGot: %s, Expected: %s\",\n-                    message, actual, expected));\n-    }\n-\n-    public void assertNull(Object actual, String message) {\n-        assertEquals(actual, null, message);\n-    }\n-\n-    public void assertNotNull(Object actual, String message) {\n-        if (Objects.isNull(actual)) {\n-            throw new AssertionFailedException(message + \" : Expected not null value\");\n-        }\n-    }\n-\n-    public void assertTrue(boolean actual, String message) {\n-        assertEquals(actual, true, message);\n-    }\n-\n-    public void assertFalse(boolean actual, String message) {\n-        assertEquals(actual, false, message);\n-    }\n-\n-    public void assertContains(Set<?> found, Set<?> expected, String message) {\n-        Set<?> copy = new HashSet<>(expected);\n-        copy.removeAll(found);\n-        assertTrue(found.containsAll(expected), message + \" : \" + copy);\n-    }\n-\n-    public void writeToFile(Path path, String source) throws IOException {\n-        try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n-            writer.write(source);\n-        }\n-    }\n-\n-    public void writeToFileIfEnabled(Path path, String source) throws IOException {\n-        if (isDumpOfSourceEnabled) {\n-            writeToFile(path, source);\n-        } else {\n-            System.err.println(\"Source dumping disabled. To enable, run the test with '-Ddump.src=true'\");\n-        }\n-    }\n-\n-    public File getSourceDir() {\n-        return new File(System.getProperty(\"test.src\", \".\"));\n-    }\n-\n-    public File getClassDir() {\n-        return new File(System.getProperty(\"test.classes\", TestBase.class.getResource(\".\").getPath()));\n-    }\n-\n-    public File getSourceFile(String fileName) {\n-        return new File(getSourceDir(), fileName);\n-    }\n-\n-    public File getClassFile(String fileName) {\n-        return new File(getClassDir(), fileName);\n-    }\n-\n-    public File getClassFile(Class clazz) {\n-        return getClassFile(clazz.getName().replace(\".\", \"\/\") + \".class\");\n-    }\n-\n-    \/**\n-     * Prints message to standard error. New lines are converted to system dependent NL.\n-     *\n-     * @param message string to print.\n-     *\/\n-    public void echo(String message) {\n-        printf(message + \"\\n\");\n-    }\n-\n-    \/**\n-     * Substitutes args in template and prints result to standard error.\n-     * New lines are converted to system dependent NL.\n-     *\n-     * @param template template in standard String.format(...) format.\n-     * @param args arguments to substitute in template.\n-     *\/\n-    public void printf(String template, Object... args) {\n-        System.err.printf(String.format(template, args).replace(\"\\n\", LINE_SEPARATOR));\n-    }\n-\n-    public static class CompilationException extends Exception {\n-\n-        public CompilationException(String message) {\n-            super(message);\n-        }\n-    }\n-\n-    public static class AssertionFailedException extends RuntimeException {\n-        public AssertionFailedException(String message) {\n-            super(message);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/lib_legacy\/TestBase.java","additions":0,"deletions":284,"binary":false,"changes":284,"status":"deleted"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.*;\n-\n-\/**\n- * This class accumulates test results. Test results can be checked with method {@code checkStatus}.\n- *\/\n-public class TestResult extends TestBase {\n-\n-    private final List<Info> testCasesInfo;\n-\n-    public TestResult() {\n-        testCasesInfo = new ArrayList<>();\n-    }\n-\n-    \/**\n-     * Adds new test case info.\n-     *\n-     * @param info the information about test case\n-     *\/\n-    public void addTestCase(String info) {\n-        System.err.println(\"Test case: \" + info);\n-        testCasesInfo.add(new Info(info));\n-    }\n-\n-    public boolean checkEquals(Object actual, Object expected, String message) {\n-        echo(\"Testing : \" + message);\n-        if (!Objects.equals(actual, expected)) {\n-            getLastTestCase().addAssert(String.format(\"%s\\n\" +\n-                    \"Expected: %s,\\n\" +\n-                    \"     Got: %s\", message, expected, actual));\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    public boolean checkNull(Object actual, String message) {\n-        return checkEquals(actual, null, message);\n-    }\n-\n-    public boolean checkNotNull(Object actual, String message) {\n-        echo(\"Testing : \" + message);\n-        if (Objects.isNull(actual)) {\n-            getLastTestCase().addAssert(message + \" : Expected not null value\");\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    public boolean checkFalse(boolean actual, String message) {\n-        return checkEquals(actual, false, message);\n-    }\n-\n-    public boolean checkTrue(boolean actual, String message) {\n-        return checkEquals(actual, true, message);\n-    }\n-\n-    public boolean checkContains(Collection<?> found, Collection<?> expected, String message) {\n-        Set<?> copy = new HashSet<>(expected);\n-        copy.removeAll(found);\n-        if (!found.containsAll(expected)) {\n-            return checkTrue(false, message + \" FAIL : not found elements : \" + copy + \"\\n\" +\n-                    \"Actual: \" + found);\n-        } else {\n-            return checkTrue(true, message + \" PASS : all elements found\");\n-        }\n-    }\n-\n-    public void addFailure(Throwable th) {\n-        if (testCasesInfo.isEmpty()) {\n-            testCasesInfo.add(new Info(\"Dummy info\"));\n-        }\n-        getLastTestCase().addFailure(th);\n-    }\n-\n-    private Info getLastTestCase() {\n-        if (testCasesInfo.isEmpty()) {\n-            throw new IllegalStateException(\"Test case should be created\");\n-        }\n-        return testCasesInfo.get(testCasesInfo.size() - 1);\n-    }\n-\n-    \/**\n-     * Throws {@code TestFailedException} if one of the checks are failed\n-     * or an exception occurs. Prints error message of failed test cases.\n-     *\n-     * @throws TestFailedException if one of the checks are failed\n-     *                             or an exception occurs\n-     *\/\n-    public void checkStatus() throws TestFailedException {\n-        int passed = 0;\n-        int failed = 0;\n-        for (Info testCaseInfo : testCasesInfo) {\n-            if (testCaseInfo.isFailed()) {\n-                String info = testCaseInfo.info().replace(\"\\n\", LINE_SEPARATOR);\n-                String errorMessage = testCaseInfo.getMessage().replace(\"\\n\", LINE_SEPARATOR);\n-                System.err.printf(\"Failure in test case:%n%s%n%s%n\", info, errorMessage);\n-                ++failed;\n-            } else {\n-                ++passed;\n-            }\n-        }\n-        System.err.printf(\"Test cases: passed: %d, failed: %d, total: %d.%n\", passed, failed, passed + failed);\n-        if (failed > 0) {\n-            throw new TestFailedException(\"Test failed\");\n-        }\n-        if (passed + failed == 0) {\n-            throw new TestFailedException(\"Test cases were not found\");\n-        }\n-    }\n-\n-    @Override\n-    public void printf(String template, Object... args) {\n-        getLastTestCase().printf(template, args);\n-    }\n-\n-    private static class Info {\n-\n-        private final String info;\n-        private final StringWriter writer;\n-        private boolean isFailed;\n-\n-        private Info(String info) {\n-            this.info = info;\n-            writer = new StringWriter();\n-        }\n-\n-        public String info() {\n-            return info;\n-        }\n-\n-        public boolean isFailed() {\n-            return isFailed;\n-        }\n-\n-        public void printf(String template, Object... args) {\n-            writer.write(String.format(template, args));\n-        }\n-\n-        public void addFailure(Throwable th) {\n-            isFailed = true;\n-            printf(\"[ERROR] : %s\\n\", getStackTrace(th));\n-        }\n-\n-        public void addAssert(String e) {\n-            isFailed = true;\n-            printf(\"[ASSERT] : %s\\n\", e);\n-        }\n-\n-        public String getMessage() {\n-            return writer.toString();\n-        }\n-\n-        public String getStackTrace(Throwable throwable) {\n-            StringWriter stringWriter = new StringWriter();\n-            try (PrintWriter printWriter = new PrintWriter(stringWriter)) {\n-                throwable.printStackTrace(printWriter);\n-            }\n-            return stringWriter.toString();\n-        }\n-    }\n-\n-    public static class TestFailedException extends Exception {\n-        public TestFailedException(String message) {\n-            super(message);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/lib_legacy\/TestResult.java","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -1,6 +1,6 @@\n-DanglingDocCommentsClass.java:8:1: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:11:1: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:12:8: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:12:69: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:13:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:17:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:10:1: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:13:1: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:14:8: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:14:69: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass.enabled.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,0 +8,2 @@\n+\/\/ This is a test of duplicate and misplaced doc comments in a class, using traditional comments\n+\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,7 @@\n+DanglingDocCommentsClass_Line.java:11:1: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:15:1: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:17:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:19:9: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n+6 warnings\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Line.enabled.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile -Xlint:dangling-doc-comments DanglingDocCommentsClass_Line.java\n+ * @compile\/ref=empty.out -XDrawDiagnostics DanglingDocCommentsClass_Line.java\n+ * @compile\/ref=DanglingDocCommentsClass_Line.enabled.out -XDrawDiagnostics -Xlint:dangling-doc-comments DanglingDocCommentsClass_Line.java\n+ * @compile\/ref=empty.out -XDrawDiagnostics --disable-line-doc-comments -Xlint:dangling-doc-comments DanglingDocCommentsClass_Line.java\n+ *\/\n+\n+\/\/ This is a test of duplicate and misplaced doc comments in a class, using end-of-line comments\n+\n+\/\/\/ Bad\/Extra Class Comment.\n+\n+\/\/\/ Good Class Comment.\n+@Deprecated\n+\/\/\/ Misplaced: after anno.\n+public\n+    \/\/\/ Misplaced: after mods.\n+    class DanglingDocCommentsClass_Line\n+        \/\/\/ Misplaced: after ident\n+    {\n+    \/\/\/ Bad\/Extra Field Comment.\n+\n+    \/\/\/ Good Field Comment.\n+    public int i;\n+\n+    \/\/\/ Bad\/Extra Method Comment.\n+\n+    \/\/\/ Good Method Comment.\n+    public void m1() { }\n+\n+    @SuppressWarnings(\"dangling-doc-comments\")\n+    \/\/\/ Bad\/misplaced\/suppressed comment.\n+    public void m2() { }\n+\n+    public void m3(boolean b) {\n+        \/\/\/------------------\n+        \/\/\/ Box comment\n+        \/\/\/------------------\n+        if (b) return;\n+    }\n+\n+    public void m4a() {\n+        \/\/\/ Not a doc comment.\n+        System.out.println();\n+        \/\/\/ Not a doc comment; not dangling for m4b\n+    }\n+\n+    \/\/\/ Good comment for m4b; no dangling comments.\n+    public void m4b() { }\n+\n+    \/\/\/ Comment ignored here: does not affect decls in block\n+    static {\n+        \/\/\/ Good comment.\n+        int i = 0;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Line.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Mixed.java:17:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Mixed.java:21:5: compiler.warn.dangling.doc.comment\n+3 warnings\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Mixed.enabled.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile -Xlint:dangling-doc-comments DanglingDocCommentsClass_Mixed.java\n+ * @compile\/ref=empty.out -XDrawDiagnostics DanglingDocCommentsClass_Mixed.java\n+ * @compile\/ref=DanglingDocCommentsClass_Mixed.enabled.out -XDrawDiagnostics -Xlint:dangling-doc-comments DanglingDocCommentsClass_Mixed.java\n+ * @compile\/ref=empty.out -XDrawDiagnostics --disable-line-doc-comments -Xlint:dangling-doc-comments DanglingDocCommentsClass_Mixed.java\n+ *\/\n+\n+\/\/ This is a test of duplicate doc comments in a class, using a mixture of traditional and end-of-line comments\n+\/\/ It is a useful test case for a real-world scenario in which an end-of-line comment is\n+\/\/ placed between a traditional doc comment and its declaration.\n+\n+\/** First Class Comment. *\/\n+\/\/\/ Second Class Comment.\n+@Deprecated public class DanglingDocCommentsClass_Mixed\n+    {\n+    \/** First Field Comment. *\/\n+    \/\/\/ Second Field Comment.\n+    public int i;\n+\n+    \/** First Method Comment. *\/\n+    \/\/\/ Second Method Comment.\n+    public void m1() { }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Mixed.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -1,7 +1,7 @@\n-DanglingDocCommentsEnum.java:8:1: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:11:1: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:12:8: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:12:67: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:14:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:20:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:26:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:10:1: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:13:1: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:14:8: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:14:67: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsEnum.enabled.out","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -8,0 +8,2 @@\n+\/\/ This is a test of duplicate and misplaced doc comments in an enum class, using traditional comments\n+\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsEnum.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -source 16 -target 16 CheckACC_STRICTFlagOnDefaultMethodTest.java\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n@@ -33,0 +33,7 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.nio.file.Path;\n@@ -35,1 +42,0 @@\n-import java.io.File;\n@@ -38,8 +44,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Method;\n-\n-import static com.sun.tools.classfile.AccessFlags.ACC_STRICT;\n-\n@@ -52,0 +50,6 @@\n+    private static final String SOURCE = \"\"\"\n+            strictfp interface StrictfpInterface {\n+                default void default_interface_method() {}\n+                static void static_interface_method() {}\n+            }\n+            \"\"\";\n@@ -56,1 +60,1 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n+            throws IOException {\n@@ -61,5 +65,8 @@\n-            throws IOException, ConstantPoolException, InvalidDescriptor {\n-        String testClasses = System.getProperty(\"test.classes\");\n-        check(testClasses,\n-                \"CheckACC_STRICTFlagOnDefaultMethodTest$StrictfpInterface.class\");\n-        if (errors.size() > 0) {\n+            throws IOException {\n+        Path src = Path.of(\"src\");\n+        Path out = Path.of(\"out\");\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(src, SOURCE);\n+        CompilerUtils.compile(src, out, \"--release\", \"16\");\n+        check(out, \"StrictfpInterface.class\");\n+        if (!errors.isEmpty()) {\n@@ -73,5 +80,1 @@\n-    void check(String dir, String... fileNames)\n-        throws\n-            IOException,\n-            ConstantPoolException,\n-            Descriptor.InvalidDescriptor {\n+    void check(Path dir, String... fileNames) throws IOException {\n@@ -79,1 +82,1 @@\n-            ClassFile classFileToCheck = ClassFile.read(new File(dir, fileName));\n+            ClassModel classFileToCheck = ClassFile.of().parse(dir.resolve(fileName));\n@@ -81,2 +84,2 @@\n-            for (Method method : classFileToCheck.methods) {\n-                if ((method.access_flags.flags & ACC_STRICT) == 0) {\n+            for (MethodModel method : classFileToCheck.methods()) {\n+                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n@@ -84,2 +87,2 @@\n-                            method.getName(classFileToCheck.constant_pool),\n-                            classFileToCheck.getName()));\n+                            method.methodName().stringValue(),\n+                            classFileToCheck.thisClass().asInternalName()));\n@@ -90,21 +93,0 @@\n-\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    void check(String dir, String... fileNames) throws IOException {\n-\/\/        for (String fileName : fileNames) {\n-\/\/            ClassModel classFileToCheck = ClassFile.of().parse(new File(dir, fileName).toPath());\n-\/\/\n-\/\/            for (MethodModel method : classFileToCheck.methods()) {\n-\/\/                if ((method.flags().flagsMask() & ClassFile.ACC_STRICT) == 0) {\n-\/\/                    errors.add(String.format(offendingMethodErrorMessage,\n-\/\/                            method.methodName().stringValue(),\n-\/\/                            classFileToCheck.thisClass().asInternalName()));\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/    }\n-\n-    strictfp interface StrictfpInterface {\n-        default void default_interface_method() {}\n-        static void static_interface_method() {}\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/CheckACC_STRICTFlagOnDefaultMethodTest.java","additions":31,"deletions":49,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.module.imports\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: --release ${jdk.version} --enable-preview -Xlint:preview\n+\n+import module java.base;\n+\n+public class ImportModule {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModule.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.import.module.does.not.read\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --release ${jdk.version} --enable-preview\n+module m {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleDoesNotRead\/module-info.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import module java.compiler;\n+\n+public class Test {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleDoesNotRead\/test\/Test.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.import.module.does.not.read.unnamed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --release ${jdk.version} --enable-preview --limit-modules java.base\n+\n+import module java.compiler;\n+\n+public class ImportModuleDoesNotReadUnnamed {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleDoesNotReadUnnamed.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.import.module.not.found\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: --release ${jdk.version} --enable-preview\n+\n+import module unknown;\n+\n+public class ImportModuleNotFound {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleNotFound.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import java.io.File;\n-import java.io.FileWriter;\n@@ -30,0 +28,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -40,0 +40,1 @@\n+import javax.lang.model.util.Elements;\n@@ -44,1 +45,41 @@\n-import com.sun.source.doctree.*;\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.AuthorTree;\n+import com.sun.source.doctree.CommentTree;\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocRootTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.DocTreeVisitor;\n+import com.sun.source.doctree.DocTypeTree;\n+import com.sun.source.doctree.EndElementTree;\n+import com.sun.source.doctree.EntityTree;\n+import com.sun.source.doctree.ErroneousTree;\n+import com.sun.source.doctree.EscapeTree;\n+import com.sun.source.doctree.HiddenTree;\n+import com.sun.source.doctree.IdentifierTree;\n+import com.sun.source.doctree.IndexTree;\n+import com.sun.source.doctree.InheritDocTree;\n+import com.sun.source.doctree.LinkTree;\n+import com.sun.source.doctree.LiteralTree;\n+import com.sun.source.doctree.ParamTree;\n+import com.sun.source.doctree.ProvidesTree;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.ReturnTree;\n+import com.sun.source.doctree.SeeTree;\n+import com.sun.source.doctree.SerialDataTree;\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n+import com.sun.source.doctree.SinceTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.SpecTree;\n+import com.sun.source.doctree.StartElementTree;\n+import com.sun.source.doctree.SummaryTree;\n+import com.sun.source.doctree.SystemPropertyTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.doctree.ThrowsTree;\n+import com.sun.source.doctree.UnknownBlockTagTree;\n+import com.sun.source.doctree.UnknownInlineTagTree;\n+import com.sun.source.doctree.UsesTree;\n+import com.sun.source.doctree.ValueTree;\n+import com.sun.source.doctree.VersionTree;\n@@ -56,0 +97,1 @@\n+import com.sun.tools.javac.api.JavacTrees;\n@@ -75,1 +117,4 @@\n-            new DocCommentTester(true).run(list);\n+            new DocCommentTester(true, true).run(list);\n+        } else if (!list.isEmpty() && \"-useStandardTransformer\".equals(list.get(0))) {\n+            list.remove(0);\n+            new DocCommentTester(false, false).run(list);\n@@ -77,1 +122,1 @@\n-            new DocCommentTester(false).run(list);\n+            new DocCommentTester(false, true).run(list);\n@@ -84,1 +129,3 @@\n-    public DocCommentTester(boolean useBreakIterator) {\n+    public final boolean useIdentityTransformer;\n+\n+    public DocCommentTester(boolean useBreakIterator, boolean useIdentityTtransformer) {\n@@ -86,0 +133,1 @@\n+        this.useIdentityTransformer = useIdentityTtransformer;\n@@ -91,2 +139,2 @@\n-        List<File> files = args.stream()\n-                .map(arg -> new File(testSrc, arg))\n+        List<Path> files = args.stream()\n+                .map(arg -> Path.of(testSrc, arg))\n@@ -98,1 +146,1 @@\n-        Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromFiles(files);\n+        Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromPaths(files);\n@@ -101,1 +149,7 @@\n-        final DocTrees trees = DocTrees.instance(t);\n+        final JavacTrees trees = (JavacTrees) DocTrees.instance(t);\n+\n+        if (useIdentityTransformer) {\n+            \/\/ disable default use of the \"standard\" transformer, so that we can examine\n+            \/\/ the trees as created by DocCommentParser.\n+            trees.setDocCommentTreeTransformer(new JavacTrees.IdentityTransformer());\n+        }\n@@ -246,0 +300,1 @@\n+            assert start >= 0 : \"start of AST comment not found\";\n@@ -247,0 +302,1 @@\n+            assert end >= 0 : \"end of AST comment not found\";\n@@ -270,2 +326,2 @@\n-            List<File> files = new ArrayList<>();\n-            File o = null;\n+            List<Path> files = new ArrayList<>();\n+            Path o = null;\n@@ -275,1 +331,1 @@\n-                    o = new File(args[++i]);\n+                    o = Path.of(args[++i]);\n@@ -279,1 +335,1 @@\n-                    files.add(new File(arg));\n+                    files.add(Path.of(arg));\n@@ -285,1 +341,1 @@\n-            final File outDir = o;\n+            final Path outDir = o;\n@@ -289,1 +345,1 @@\n-            Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromFiles(files);\n+            Iterable<? extends JavaFileObject> fos = fm.getJavaFileObjectsFromPaths(files);\n@@ -308,0 +364,1 @@\n+                    assert start >= 0 : \"cannot find initial '{'\";\n@@ -310,0 +367,1 @@\n+                        assert end >= 0 : \"cannot find end of comment\";\n@@ -317,2 +375,2 @@\n-                    File f = new File(tree.getSourceFile().getName());\n-                    File outFile = new File(outDir, f.getName());\n+                    var treeSourceFileName = tree.getSourceFile().getName();\n+                    var outFile = outDir.resolve(treeSourceFileName);\n@@ -320,3 +378,1 @@\n-                        try (FileWriter out = new FileWriter(outFile)) {\n-                            out.write(source);\n-                        }\n+                        Files.writeString(outFile, source);\n@@ -324,1 +380,1 @@\n-                        System.err.println(\"Can't write \" + tree.getSourceFile().getName()\n+                        System.err.println(\"Can't write \" + treeSourceFileName\n@@ -545,0 +601,5 @@\n+            public Void visitRawText(RawTextTree node, Void p) {\n+                header(node, compress(node.getContent()));\n+                return null;\n+            }\n+\n@@ -866,0 +927,2 @@\n+                                System.err.println(\"node: \" + node.getKind());\n+                                System.err.println(\"startPos: \" + startPos + \" \" + showPos(cs, (int) startPos));\n@@ -898,0 +961,11 @@\n+\n+        String showPos(CharSequence cs, int pos) {\n+            String s = cs.toString();\n+            return (s.substring(Math.max(0, pos - 10), pos)\n+                    + \"[\"\n+                    + s.charAt(pos)\n+                    + \"]\"\n+                    + s.substring(pos + 1, Math.min(s.length(), pos + 10)))\n+                    .replace('\\n', '|')\n+                    .replace(' ', '_');\n+        }\n@@ -920,2 +994,4 @@\n-            String raw = trees.getDocComment(path);\n-            String normRaw = normalize(raw, normalizeTags);\n+            Elements.DocCommentKind ck = trees.getDocCommentKind(path);\n+            boolean isLineComment = ck == Elements.DocCommentKind.END_OF_LINE;\n+            String raw = trees.getDocComment(path).stripTrailing();\n+            String normRaw = normalize(raw, isLineComment, normalizeTags);\n@@ -930,1 +1006,3 @@\n-                System.err.println(\"*** expected:\");\n+                System.err.println(\"*** raw: (\" + raw.length() + \")\");\n+                System.err.println(raw.replace(\" \", \"_\"));\n+                System.err.println(\"*** expected: (\" + normRaw.length() + \")\");\n@@ -932,1 +1010,1 @@\n-                System.err.println(\"*** found:\");\n+                System.err.println(\"*** found: (\" + pretty.length() + \")\");\n@@ -948,2 +1026,3 @@\n-        String normalize(String s, boolean normalizeTags) {\n-            String s2 = s.trim().replaceFirst(\"\\\\.\\\\s*\\\\n *@(?![@*])\", \".\\n@\");\n+        String normalize(String s, boolean isLineComment, boolean normalizeTags) {\n+            String s2 = (isLineComment ? s : s.trim())\n+                    .replaceFirst(\"\\\\.\\\\s*\\\\n *@(?![@*])\", \".\\n@\"); \/\/ Between block tags\n@@ -968,1 +1047,1 @@\n-            return s.replaceAll(\"\\n[ \\t]+@(?![@*])\", \"\\n@\");\n+            return s.replaceAll(\"\\n[ \\t]+@(?!([@*]|dummy))\", \"\\n@\");\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":109,"deletions":30,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8078320 8247788 8273244\n+ * @bug 7021614 8078320 8247788 8273244 8298405\n@@ -239,0 +239,12 @@\n+\/\/ In Markdown mode, < does not introduce an element\n+    \/\/\/abc < def\n+    public void markdown() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_<_def]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n","filename":"test\/langtools\/tools\/javac\/doctree\/ElementTest.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8273244 8284908\n+ * @bug 7021614 8273244 8284908 8298405\n@@ -167,0 +167,11 @@\n+*\/\n+\n+    \/\/\/abc & def\n+    public void markdown() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_&_def]\n+  body: empty\n+  block tags: empty\n+]\n","filename":"test\/langtools\/tools\/javac\/doctree\/EntityTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -406,0 +406,142 @@\n+*\/\n+    \/\/\/Abc.\n+    \/\/\/Def.\n+    void simpleMarkdown() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, Def.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, Def.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/Abc `p.q` def.\n+    \/\/\/Ghi.\n+    void markdownWithCodeSpan() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc_`p.q`_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:15, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc_`p.q`_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:15, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/Abc {@code p.q} def.\n+    \/\/\/Ghi.\n+    void markdownWithCodeTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 3\n+    RawText[MARKDOWN, pos:0, Abc_]\n+    Literal[CODE, pos:4, p.q]\n+    RawText[MARKDOWN, pos:15, _def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:21, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 3\n+    RawText[MARKDOWN, pos:0, Abc_]\n+    Literal[CODE, pos:4, p.q]\n+    RawText[MARKDOWN, pos:15, _def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:21, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/Abc <a href=\"example.com\">example<\/a> def.\n+    \/\/\/Ghi.\n+    void markdownWithHtml() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc_<a_href=\"example.com\">example<\/a>_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:43, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc_<a_href=\"example.com\">example<\/a>_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:43, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/Abc [example.com][example] def.\n+    \/\/\/Ghi.\n+    void markdownWithLinks() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc_[example.com][example]_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:32, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc_[example.com][example]_def.]\n+  body: 1\n+    RawText[MARKDOWN, pos:32, Ghi.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/Abc\n+    \/\/\/\n+    \/\/\/Def.\n+    void markdownEndParaNoPeriod() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, Def.]\n+  block tags: empty\n+]\n+*\/\n+\/*\n+BREAK_ITERATOR\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Abc]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, Def.]\n+  block tags: empty\n+]\n","filename":"test\/langtools\/tools\/javac\/doctree\/FirstSentenceTest.java","additions":143,"deletions":1,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8298405\n+ * @summary Make sure MDPrinter.java compiles\n+ * @modules jdk.internal.md\/jdk.internal.org.commonmark.node\n+ *          jdk.internal.md\/jdk.internal.org.commonmark.parser\n+ * @compile MDPrinter.java\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import jdk.internal.org.commonmark.node.BlockQuote;\n+import jdk.internal.org.commonmark.node.BulletList;\n+import jdk.internal.org.commonmark.node.Code;\n+import jdk.internal.org.commonmark.node.CustomBlock;\n+import jdk.internal.org.commonmark.node.CustomNode;\n+import jdk.internal.org.commonmark.node.Document;\n+import jdk.internal.org.commonmark.node.Emphasis;\n+import jdk.internal.org.commonmark.node.FencedCodeBlock;\n+import jdk.internal.org.commonmark.node.HardLineBreak;\n+import jdk.internal.org.commonmark.node.Heading;\n+import jdk.internal.org.commonmark.node.HtmlBlock;\n+import jdk.internal.org.commonmark.node.HtmlInline;\n+import jdk.internal.org.commonmark.node.Image;\n+import jdk.internal.org.commonmark.node.IndentedCodeBlock;\n+import jdk.internal.org.commonmark.node.Link;\n+import jdk.internal.org.commonmark.node.LinkReferenceDefinition;\n+import jdk.internal.org.commonmark.node.ListItem;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.node.OrderedList;\n+import jdk.internal.org.commonmark.node.Paragraph;\n+import jdk.internal.org.commonmark.node.SoftLineBreak;\n+import jdk.internal.org.commonmark.node.SourceSpan;\n+import jdk.internal.org.commonmark.node.StrongEmphasis;\n+import jdk.internal.org.commonmark.node.Text;\n+import jdk.internal.org.commonmark.node.ThematicBreak;\n+import jdk.internal.org.commonmark.node.Visitor;\n+import jdk.internal.org.commonmark.parser.IncludeSourceSpans;\n+import jdk.internal.org.commonmark.parser.Parser;\n+\n+\/**\n+ * Debug printer for CommonMark nodes.\n+ *\n+ * Requires access to {@code jdk.internal.org.commonmark.node.*}.\n+ *\n+ * Conceptually based on javac's {@code DPrinter}.\n+ *\/\n+public class MDPrinter {\n+    static class MDVisitor implements Visitor {\n+\n+        MDVisitor(String source, PrintStream out) {\n+            this.source = source;\n+            lines = source == null ? null : source.lines().toList();\n+            this.out = out;\n+        }\n+\n+        void visit(Node node) {\n+            if (node == null) {\n+                out.print(\"    \".repeat(depth));\n+                out.println(\"*null*\");\n+            } else {\n+                node.accept(this);\n+            }\n+        }\n+\n+        @Override\n+        public void visit(BlockQuote blockQuote) {\n+            defaultAction(blockQuote);\n+        }\n+\n+        @Override\n+        public void visit(BulletList bulletList) {\n+            defaultAction(bulletList);\n+        }\n+\n+        @Override\n+        public void visit(Code code) {\n+            defaultAction(code);\n+        }\n+\n+        @Override\n+        public void visit(Document document) {\n+            defaultAction(document);\n+        }\n+\n+        @Override\n+        public void visit(Emphasis emphasis) {\n+            defaultAction(emphasis);\n+        }\n+\n+        @Override\n+        public void visit(FencedCodeBlock fencedCodeBlock) {\n+            defaultAction(fencedCodeBlock);\n+        }\n+\n+        @Override\n+        public void visit(HardLineBreak hardLineBreak) {\n+            defaultAction(hardLineBreak);\n+        }\n+\n+        @Override\n+        public void visit(Heading heading) {\n+            defaultAction(heading);\n+        }\n+\n+        @Override\n+        public void visit(ThematicBreak thematicBreak) {\n+            defaultAction(thematicBreak);\n+        }\n+\n+        @Override\n+        public void visit(HtmlInline htmlInline) {\n+            defaultAction(htmlInline);\n+        }\n+\n+        @Override\n+        public void visit(HtmlBlock htmlBlock) {\n+            defaultAction(htmlBlock);\n+        }\n+\n+        @Override\n+        public void visit(Image image) {\n+            defaultAction(image);\n+        }\n+\n+        @Override\n+        public void visit(IndentedCodeBlock indentedCodeBlock) {\n+            defaultAction(indentedCodeBlock);\n+        }\n+\n+        @Override\n+        public void visit(Link link) {\n+            defaultAction(link);\n+        }\n+\n+        @Override\n+        public void visit(ListItem listItem) {\n+            defaultAction(listItem);\n+        }\n+\n+        @Override\n+        public void visit(OrderedList orderedList) {\n+            defaultAction(orderedList);\n+        }\n+\n+        @Override\n+        public void visit(Paragraph paragraph) {\n+            defaultAction(paragraph);\n+        }\n+\n+        @Override\n+        public void visit(SoftLineBreak softLineBreak) {\n+            defaultAction(softLineBreak);\n+        }\n+\n+        @Override\n+        public void visit(StrongEmphasis strongEmphasis) {\n+            defaultAction(strongEmphasis);\n+        }\n+\n+        @Override\n+        public void visit(Text text) {\n+            defaultAction(text);\n+        }\n+\n+        @Override\n+        public void visit(LinkReferenceDefinition linkReferenceDefinition) {\n+            defaultAction(linkReferenceDefinition);\n+        }\n+\n+        @Override\n+        public void visit(CustomBlock customBlock) {\n+            defaultAction(customBlock);\n+        }\n+\n+        @Override\n+        public void visit(CustomNode customNode) {\n+            defaultAction(customNode);\n+        }\n+\n+        private final String source;\n+        private final List<String> lines;\n+        private final PrintStream out;\n+\n+        int depth = 0;\n+\n+        protected void defaultAction(Node node) {\n+            out.print(\"    \".repeat(depth));\n+            out.print(node.getClass().getSimpleName());\n+            out.print(\" \");\n+            out.println(abbrev(node.toString(), 64));\n+            int i = 0;\n+            for (var ss : node.getSourceSpans()) {\n+                out.print(\"    \".repeat(depth));\n+                out.print(\"  span[\" + (i++) + \"]: \" + ss);\n+                out.println(abbrev(source(ss).replace(' ', '_').replace('\\n', '|'), 64));\n+            }\n+            depth++;\n+            try {\n+                for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n+                    c.accept(this);\n+                }\n+            } finally {\n+                depth--;\n+            }\n+        }\n+\n+        String source(SourceSpan ss) {\n+            if (source == null) {\n+                return \"no source\";\n+            }\n+            if (ss.getLineIndex() >= lines.size()) {\n+                return \"error: insufficient lines [\" + lines.size() + \"]\";\n+            }\n+            String line = lines.get(ss.getLineIndex());\n+            if (ss.getColumnIndex() + ss.getLength() > line.length()) {\n+                return \"error: bounds\";\n+            }\n+            return line.substring(ss.getColumnIndex(), ss.getColumnIndex() + ss.getLength());\n+        }\n+\n+        String abbrev(String s, int maxLen) {\n+            return s.length() < maxLen ? s\n+                    : s.substring(0, maxLen \/ 2) + \"...\" + s.substring(s.length() - maxLen \/ 2);\n+\n+        }\n+    }\n+\n+    public static void main(String... args) throws IOException {\n+        show(Files.readString(Path.of(args[0])));\n+    }\n+\n+    public static void show(String source) {\n+        Parser parser = Parser.builder()\n+                .includeSourceSpans(IncludeSourceSpans.BLOCKS_AND_INLINES)\n+                .build();\n+        Node document = parser.parse(source);\n+\n+        show(document, source, System.err);\n+    }\n+\n+    public static void show(Node node, String source, PrintStream out) {\n+        new MDVisitor(source, out).visit(node);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/MDPrinter.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,617 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298405\n+ * @summary Markdown support in the standard doclet\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build DocCommentTester\n+ * @run main DocCommentTester MarkdownTest.java\n+ * @run main DocCommentTester -useStandardTransformer MarkdownTest.java\n+ *\/\n+\n+\/*\n+ * Test for handling Markdown content.\n+ *\n+ * In the tests for code spans and code blocks, \"@dummy\" is used as a dummy inline\n+ * or block tag to verify that it is skipped as part of the code span or code block.\n+ * In other words, \"@dummy\" should appear as a literal part of the Markdown content.\n+ * Conversely, standard tags are used to verify that a fragment of text is not being\n+ * skipped as a code span or code block. In other words, they should be recognized as tags\n+ * and not skipped as part of any Markdown content.\n+ *\n+ * \"@dummy\" is also known to DocCommentTester and will not have any preceding whitespace\n+ * removed during normalization.\n+ *\/\n+\n+class MarkdownTest {\n+    \/\/\/abc < def & ghi {@code 123} jkl {@unknown} mno.\n+    void descriptionMix() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 5\n+    RawText[MARKDOWN, pos:0, abc_<_def_&_ghi_]\n+    Literal[CODE, pos:16, 123]\n+    RawText[MARKDOWN, pos:27, _jkl_]\n+    UnknownInlineTag[UNKNOWN_INLINE_TAG, pos:32\n+      tag:unknown\n+      content: 1\n+        Text[TEXT, pos:41]\n+    ]\n+    RawText[MARKDOWN, pos:42, _mno.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/@since abc < def & ghi {@code 123} jkl {@unknown} mno.\n+    void blockTagMix() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: empty\n+  body: empty\n+  block tags: 1\n+    Since[SINCE, pos:0\n+      body: 5\n+        RawText[MARKDOWN, pos:7, abc_<_def_&_ghi_]\n+        Literal[CODE, pos:23, 123]\n+        RawText[MARKDOWN, pos:34, _jkl_]\n+        UnknownInlineTag[UNKNOWN_INLINE_TAG, pos:39\n+          tag:unknown\n+          content: 1\n+            Text[TEXT, pos:48]\n+        ]\n+        RawText[MARKDOWN, pos:49, _mno.]\n+    ]\n+]\n+*\/\n+\n+    \/\/\/123 {@link Object abc < def & ghi {@code 123} jkl {@unknown} mno} 456.\n+    void inlineTagMix() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 3\n+    RawText[MARKDOWN, pos:0, 123_]\n+    Link[LINK, pos:4\n+      reference:\n+        Reference[REFERENCE, pos:11, Object]\n+      body: 5\n+        RawText[MARKDOWN, pos:18, abc_<_def_&_ghi_]\n+        Literal[CODE, pos:34, 123]\n+        RawText[MARKDOWN, pos:45, _jkl_]\n+        UnknownInlineTag[UNKNOWN_INLINE_TAG, pos:50\n+          tag:unknown\n+          content: 1\n+            Text[TEXT, pos:59]\n+        ]\n+        RawText[MARKDOWN, pos:60, _mno]\n+    ]\n+    RawText[MARKDOWN, pos:65, _456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 `abc` 456.\n+    void simpleCodeSpan() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_`abc`_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 `abc`\n+    void simpleCodeSpanAtEndOfInput() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_`abc`]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc``` 456.\n+    void mediumCodeSpan() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc`def``` 456.\n+    void mediumCodeSpanWithBackTicks() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc`def```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc{@dummy ...}def``` 456.\n+    void mediumCodeSpanWithNotInlineTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc{@dummy_...}def```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123 ```abc\n+    \/\/\/@dummy def``` 456.\n+    void mediumCodeSpanWithNotBlockTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123_```abc|@dummy_def```_456.]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc\n+    \/\/\/```\n+    \/\/\/456.\n+    void simpleFencedCodeBlock_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc|```|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/~~~\n+    \/\/\/abc\n+    \/\/\/{@dummy ...}\n+    \/\/\/~~~\n+    \/\/\/456.\n+    void simpleFencedCodeBlock_tilde() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ~~~|abc|{@dummy_...}|~~~|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc\n+    \/\/\/```\n+    void simpleFencedCodeBlock_atEndOfInput() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc|```]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc {@dummy def} ghi\n+    \/\/\/```\n+    \/\/\/456.\n+    void fencedCodeBlockWithInlineTag_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc_{@dummy_def}_ghi|```|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc ``` ghi\n+    \/\/\/{@dummy ...}\n+    \/\/\/```\n+    \/\/\/456.\n+    void fencedCodeBlockWithBackTicks_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|abc_```_ghi|{@dummy_...}|```|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```abc`def``` 456.\n+    void codeSpanNotCodeBlock() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```abc`def```_456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/{@code ...}\n+    \/\/\/~~~\n+    \/\/\/456.\n+    void mismatchedFences() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, ```|{@code_...}|~~~|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/`````\n+    \/\/\/``` ghi\n+    \/\/\/{@dummy ...}\n+    \/\/\/`````\n+    \/\/\/456.\n+    void fencedCodeBlockWithShortFence_backtick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 1\n+    RawText[MARKDOWN, pos:5, `````|```_ghi|{@dummy_...}|`````|456.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterBlank() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:10, abc_{@dummy_...}|____@dummy|____def||456_]\n+    Literal[CODE, pos:51, ...]\n+    RawText[MARKDOWN, pos:62, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/### heading\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterATX() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, ###_heading|____abc_{@dummy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:61, ...]\n+    RawText[MARKDOWN, pos:72, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/Heading\n+    \/\/\/-------\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterSetext() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, Heading|-------|____abc_{@dummy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:65, ...]\n+    RawText[MARKDOWN, pos:76, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/- - - - -\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterThematicBreak() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, -_-_-_-_-|____abc_{@dummy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:59, ...]\n+    RawText[MARKDOWN, pos:70, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/```\n+    \/\/\/abc\n+    \/\/\/{@dummy}\n+    \/\/\/def\n+    \/\/\/```\n+    \/\/\/    abc {@dummy ...}\n+    \/\/\/    @dummy\n+    \/\/\/    def\n+    \/\/\/456 {@code ...}.\n+    void indentedCodeBlock_afterFencedCodeBlock() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:5, ```|abc|{@dummy}|def|```|____abc...mmy_...}|____@dummy|____def|456_]\n+    Literal[CODE, pos:74, ...]\n+    RawText[MARKDOWN, pos:85, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/\n+    \/\/\/```\n+    \/\/\/public class HelloWorld {\n+    \/\/\/    @dummy\n+    \/\/\/    public static void main(String... args) {\n+    \/\/\/        System.out.println(\"Hello World\");\n+    \/\/\/    }\n+    \/\/\/}\n+    \/\/\/```\n+    \/\/\/456 {@code ...}.\n+    void fencedHelloWorld() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:6, ```|public_class_HelloWorld_{|__...\"Hello_World\");|____}|}|```|456_]\n+    Literal[CODE, pos:152, ...]\n+    RawText[MARKDOWN, pos:163, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/123.\n+    \/\/\/\n+    \/\/\/    public class HelloWorld {\n+    \/\/\/        @dummy\n+    \/\/\/        public static void main(String... args) {\n+    \/\/\/            System.out.println(\"Hello World\");\n+    \/\/\/        }\n+    \/\/\/    }\n+    \/\/\/\n+    \/\/\/456 {@code ...}.\n+    void indentedHelloWorld() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, 123.]\n+  body: 3\n+    RawText[MARKDOWN, pos:10, public_class_HelloWorld_{|______...o_World\");|________}|____}||456_]\n+    Literal[CODE, pos:169, ...]\n+    RawText[MARKDOWN, pos:180, .]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/{@summary abc ``code-span {@dummy ...}`` def {@code ...} }\n+    \/\/\/rest.\n+    void codeSpanInInlineTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    Summary[SUMMARY, pos:0\n+      summary: 3\n+        RawText[MARKDOWN, pos:10, abc_``code-span_{@dummy_...}``_def_]\n+        Literal[CODE, pos:45, ...]\n+        RawText[MARKDOWN, pos:56, _]\n+    ]\n+  body: 1\n+    RawText[MARKDOWN, pos:58, |rest.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/{@summary abc\n+    \/\/\/```code-block\n+    \/\/\/  {@dummy ...}\n+    \/\/\/```\n+    \/\/\/def {@code ...} }\n+    \/\/\/rest.\n+    void codeBlockInInlineTag() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    Summary[SUMMARY, pos:0\n+      summary: 3\n+        RawText[MARKDOWN, pos:10, abc|```code-block|__{@dummy_...}|```|def_]\n+        Literal[CODE, pos:51, ...]\n+        RawText[MARKDOWN, pos:62, _]\n+    ]\n+  body: 1\n+    RawText[MARKDOWN, pos:64, |rest.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/abc `\n+    \/\/\/def\n+    void unmatchedBackTick() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, abc_`|def]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/{@summary abc `\n+    \/\/\/def}\n+    \/\/\/rest\n+    void unmatchedBackTickInInline() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    Summary[SUMMARY, pos:0\n+      summary: 1\n+        RawText[MARKDOWN, pos:10, abc_`|def]\n+    ]\n+  body: 1\n+    RawText[MARKDOWN, pos:20, |rest]\n+  block tags: empty\n+]\n+*\/\n+\n+\/\/ While this is an important test case, it is also a negative one\n+\/\/ (that is, the AST contains an Erroneous node).\n+\/\/ Note how the backticks \"match\" across the end of the inline tag.\n+\/\/ That's unfortunate, but cannot reasonably be detected without\n+\/\/ examining the contents of a code span.\n+\/\/ Not surprisingly, some of the checks fail for this (bad) test case.\n+\/\/ * PrettyChecker fails because it does not handle an unterminated inline tag.\n+\/\/ * StartEndPosChecker fails because it does not handle an unterminated inline tag.\n+\/\/\n+\/\/ Disabled until we can either enhance the checkers or select which\n+\/\/ checkers to use.\n+\n+\/\/    \/\/\/{@summary abc `\n+\/\/    \/\/\/def}\n+\/\/    \/\/\/rest `more`\n+\/\/    \/\/\/\n+\/\/    void unmatchedBackTickInInline2() { }\n+\/\/\/*\n+\/\/DocComment[DOC_COMMENT, pos:0\n+\/\/  firstSentence: 1\n+\/\/    Summary[SUMMARY, pos:0\n+\/\/      summary: 1\n+\/\/        Erroneous[ERRONEOUS, pos:10, prefPos:31\n+\/\/          code: compiler.err.dc.unterminated.inline.tag\n+\/\/          body: abc_`|def}|rest_`more`\n+\/\/        ]\n+\/\/    ]\n+\/\/  body: empty\n+\/\/  block tags: empty\n+\/\/]\n+\/\/*\/\n+\n+    \/\/\/Indented by 0.\n+    \/\/\/\n+    \/\/\/   * list\n+    \/\/\/\n+    \/\/\/    code block\n+    \/\/\/\n+    \/\/\/done.\n+    void indent0() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Indented_by_0.]\n+  body: 1\n+    RawText[MARKDOWN, pos:19, *_list||____code_block||done.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/ Indented by 1.\n+    \/\/\/\n+    \/\/\/    * list\n+    \/\/\/\n+    \/\/\/     code block\n+    \/\/\/\n+    \/\/\/ done.\n+    void indent1() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Indented_by_1.]\n+  body: 1\n+    RawText[MARKDOWN, pos:19, *_list||____code_block||done.]\n+  block tags: empty\n+]\n+*\/\n+\n+    \/\/\/        Indented by 8.\n+    \/\/\/\n+    \/\/\/           * list\n+    \/\/\/\n+    \/\/\/            code block\n+    \/\/\/\n+    \/\/\/        done.\n+    void indent8() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: 1\n+    RawText[MARKDOWN, pos:0, Indented_by_8.]\n+  body: 1\n+    RawText[MARKDOWN, pos:19, *_list||____code_block||done.]\n+  block tags: empty\n+]\n+*\/\n+\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTest.java","additions":617,"deletions":0,"binary":false,"changes":617,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test case for Markdown positions\n+ * @run main\/othervm --limit-modules jdk.compiler MarkdownTransformerPositionTest\n+ * @run main MarkdownTransformerPositionTest\n+ *\/\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.RawTextTree;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.*;\n+\n+import java.net.URI;\n+import java.util.*;\n+import javax.lang.model.element.Element;\n+import javax.tools.*;\n+\n+\/*\n+ * Custom test case for positions of RawTextTree nodes after passing through\n+ * main MarkdownTransformer, or not.\n+ * See https:\/\/github.com\/openjdk\/jdk\/pull\/16388#discussion_r1479306878\n+ *\/\n+public class MarkdownTransformerPositionTest {\n+\n+    public static void main(String... args) throws Exception {\n+        MarkdownTransformerPositionTest t = new MarkdownTransformerPositionTest();\n+\n+        t.simpleTest();\n+        t.testWithReplacements();\n+    }\n+\n+    private void simpleTest() throws Exception {\n+        runTest(\"\"\"\n+                \/\/\/ Markdown test\n+                \/\/\/\n+                \/\/\/ @author testAuthor\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"Markdown test\",\n+                \"testAuthor\");\n+    }\n+\n+    private void testWithReplacements() throws Exception {\n+        runTest(\"\"\"\n+                \/\/\/ Markdown \\uFFFC test \\uFFFC with \\uFFFC replacements.\n+                \/\/\/\n+                \/\/\/ @author testAuthor\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"Markdown \\uFFFC test \\uFFFC with \\uFFFC replacements.\",\n+                \"testAuthor\");\n+    }\n+\n+    private void runTest(String source, String... expectedRawSpans) throws Exception {\n+        JavaCompiler comp = ToolProvider.getSystemJavaCompiler();\n+        JavacTask task = (JavacTask)comp.getTask(null, null, null, null, null, Arrays.asList(new JavaSource(source)));\n+        CompilationUnitTree cu = task.parse().iterator().next();\n+        task.analyze();\n+        DocTrees trees = DocTrees.instance(task);\n+        List<String> rawSpans = new ArrayList<>();\n+        TreePath clazzTP = new TreePath(new TreePath(cu), cu.getTypeDecls().get(0));\n+        Element clazz = trees.getElement(clazzTP);\n+        DocCommentTree docComment = trees.getDocCommentTree(clazz);\n+\n+        new DocTreeScanner<Void, Void>() {\n+            @Override\n+            public Void visitRawText(RawTextTree node, Void p) {\n+                int start = (int) trees.getSourcePositions().getStartPosition(cu, docComment, node);\n+                int end = (int) trees.getSourcePositions().getEndPosition(cu, docComment, node);\n+                rawSpans.add(source.substring(start, end));\n+                return super.visitRawText(node, p);\n+            }\n+        }.scan(docComment, null);\n+\n+        List<String> expectedRawSpansList = List.of(expectedRawSpans);\n+\n+        if (!expectedRawSpansList.equals(rawSpans)) {\n+            throw new AssertionError(\"Incorrect raw text spans, should be: \" +\n+                    expectedRawSpansList + \", but is: \" + rawSpans);\n+        }\n+\n+        System.err.println(\"Test result: success, boot modules: \" + ModuleLayer.boot().modules());\n+    }\n+\n+    static class JavaSource extends SimpleJavaFileObject {\n+\n+        private final String source;\n+\n+        public JavaSource(String source) {\n+            super(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE);\n+            this.source = source;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return source;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTransformerPositionTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324809\n+ * @summary compiler can crash with SOE while proving if two recursive types are disjoint\n+ * @compile SOEWhileProvingDisjointnessTest.java\n+ *\/\n+\n+class SOEWhileProvingDisjointnessTest {\n+    class Criteria<B extends Builder<? extends Criteria>> {\n+        public <D extends Builder<E>, E extends Criteria<D>> D builder() {\n+            return (D) new Builder<>();\n+        }\n+    }\n+\n+    class Builder<C extends Criteria<? extends Builder<C>>> {}\n+}\n","filename":"test\/langtools\/tools\/javac\/generics\/wildcards\/SOEWhileProvingDisjointnessTest.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-ImportIsFullyQualified.java:11:1: compiler.err.doesnt.exist: JobAttributes\n+ImportIsFullyQualified.java:11:8: compiler.err.doesnt.exist: JobAttributes\n","filename":"test\/langtools\/tools\/javac\/importChecks\/ImportIsFullyQualified.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-ImportsObservable.java:9:1: compiler.err.doesnt.exist: javax\n+ImportsObservable.java:9:8: compiler.err.doesnt.exist: javax\n","filename":"test\/langtools\/tools\/javac\/importChecks\/ImportsObservable.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -source 16 -target 16 LambdaTestStrictFPFlag.java\n+ * @library \/tools\/lib \/test\/lib\n+ * @enablePreview\n@@ -33,3 +33,7 @@\n-import java.io.*;\n-import java.net.URL;\n-import com.sun.tools.classfile.*;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.nio.file.Path;\n@@ -38,0 +42,12 @@\n+    private static final String SOURCE = \"\"\"\n+            class Test {\n+                strictfp void test() {\n+                    Face itf = () -> { };\n+                }\n+            }\n+\n+            interface Face {\n+                void m();\n+            }\n+            \"\"\";\n+\n@@ -43,2 +59,8 @@\n-        ClassFile cf = getClassFile(\"LambdaTestStrictFPFlag$Test.class\");\n-        ConstantPool cp = cf.constant_pool;\n+        Path src = Path.of(\"src\");\n+        Path out = Path.of(\"out\");\n+\n+        ToolBox toolBox = new ToolBox();\n+        toolBox.writeJavaFiles(src, SOURCE);\n+        CompilerUtils.compile(src, out, \"--release\", \"16\");\n+\n+        ClassModel cm = ClassFile.of().parse(out.resolve(\"Test.class\"));\n@@ -46,3 +68,3 @@\n-        for (Method meth: cf.methods) {\n-            if (meth.getName(cp).startsWith(\"lambda$\")) {\n-                if ((meth.access_flags.flags & AccessFlags.ACC_STRICT) == 0) {\n+        for (MethodModel meth: cm.methods()) {\n+            if (meth.methodName().stringValue().startsWith(\"lambda$\")) {\n+                if ((meth.flags().flagsMask() & ClassFile.ACC_STRICT) == 0){\n@@ -58,37 +80,0 @@\n-\n-\/\/ this version of the code can be used when ClassFile API in not in a preview\n-\/\/    void run() throws Exception {\n-\/\/        ClassModel cm = getClassFile(\"LambdaTestStrictFPFlag$Test.class\");\n-\/\/        boolean found = false;\n-\/\/        for (MethodModel meth: cm.methods()) {\n-\/\/            if (meth.methodName().stringValue().startsWith(\"lambda$\")) {\n-\/\/                if ((meth.flags().flagsMask() & ClassFile.ACC_STRICT) == 0){\n-\/\/                    throw new Exception(\"strict flag missing from lambda\");\n-\/\/                }\n-\/\/                found = true;\n-\/\/            }\n-\/\/        }\n-\/\/        if (!found) {\n-\/\/            throw new Exception(\"did not find lambda method\");\n-\/\/        }\n-\/\/    }\n-\n-    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n-        URL url = getClass().getResource(name);\n-        InputStream in = url.openStream();\n-        try {\n-            return ClassFile.read(in);\n-        } finally {\n-            in.close();\n-        }\n-    }\n-\n-    class Test {\n-        strictfp void test() {\n-            Face itf = () -> { };\n-        }\n-    }\n-\n-    interface Face {\n-        void m();\n-    }\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaTestStrictFPFlag.java","additions":33,"deletions":48,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/langtools\/tools\/javac\/launcher\/BasicSourceLauncherTests.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/langtools\/tools\/javac\/launcher\/ModuleSourceLauncherTests.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/langtools\/tools\/javac\/launcher\/MultiFileSourceLauncherTests.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/langtools\/tools\/javac\/launcher\/ProgramDescriptorTests.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/langtools\/tools\/javac\/launcher\/Run.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/langtools\/tools\/javac\/launcher\/src\/p\/q\/CLTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,524 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298405\n+ * @summary Proper lexing of comments, especially \/\/\/ comments\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.TestRunner\n+ * @run main CommentTest\n+ *\/\n+\n+import java.util.Objects;\n+\n+import com.sun.tools.javac.parser.ScannerFactory;\n+import com.sun.tools.javac.parser.Tokens;\n+import com.sun.tools.javac.util.Context;\n+\n+import toolbox.TestRunner;\n+\n+public class CommentTest extends TestRunner {\n+    public static void main(String... args) throws Exception {\n+        new CommentTest().runTests();\n+    }\n+\n+    CommentTest() {\n+        super(System.err);\n+    }\n+\n+    \/**\n+     * Control: a simple comment with no blank lines or incidental whitespace.\n+     *\/\n+    @Test\n+    public void testControl() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+                \/\/\/def\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Whitespace before the comment is completely ignored.\n+     *\/\n+    @Test\n+    public void testRaggedInitialIndent() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/abc\n+                      \/\/\/def\n+                    \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Leading blank lines are preserved.\n+     *\/\n+    @Test\n+    public void testLeadingBlankLine_1() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/\n+                  \/\/\/abc\n+                  \/\/\/def\n+                  \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Leading blank lines do not affect the amount of incidental whitespace.\n+     *\/\n+    @Test\n+    public void testLeadingBlankLine_2() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/\n+                  \/\/\/    abc\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines are preserved.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_1() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/abc\n+                  \/\/\/\n+                  \/\/\/def\n+                  \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines do not affect the amount of incidental whitespace.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_2() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines do not affect the amount of incidental whitespace,\n+     * but may have whitespace removed, perhaps resulting in an empty line.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_3() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/  \\s\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Inner blank lines do not affect the amount of incidental whitespace,\n+     * but may have whitespace removed.\n+     *\/\n+    @Test\n+    public void testInnerBlankLine_4() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/          \\s\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                      \\s\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Trailing blank lines are preserved.\n+     *\/\n+    @Test\n+    public void testTrailingBlankLine_1() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/abc\n+                  \/\/\/def\n+                  \/\/\/ghi\n+                  \/\/\/\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\n+                \"\"\");\n+    }\n+\n+    \/**\n+     * Trailing blank lines do not affect the amount of incidental whitespace.\n+     *\/\n+    @Test\n+    public void testTrailingBlankLine_2() {\n+        test(\"\"\"\n+                [\n+\n+                  \/\/\/    abc\n+                  \/\/\/    def\n+                  \/\/\/    ghi\n+                  \/\/\/\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\n+                \"\"\");\n+    }\n+\n+    \/**\n+     * Small amounts of incidental whitespace are removed.\n+     *\/\n+    @Test\n+    public void testIncidental_small() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/ abc\n+                \/\/\/ def\n+                \/\/\/ ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Large amounts of incidental whitespace are removed.\n+     *\/\n+    @Test\n+    public void testIncidental_large() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/        def\n+                \/\/\/        ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Additional leading whitespace may remain after incidental whitespace is removed.\n+     *\/\n+    @Test\n+    public void testIncidental_mixed() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/            def\n+                \/\/\/          ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                    def\n+                  ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Tabs and spaces are treated equally, as whitespace characters.\n+     *\/\n+    @Test\n+    public void testIncidental_withTabs() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/\\t       def\n+                \/\/\/\\t\\t      ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Leading tabs may remain after incidental whitespace is removed.\n+     *\/\n+    @Test\n+    public void testTabAfterIncidental() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/        abc\n+                \/\/\/        \\tdef\n+                \/\/\/        ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                \\tdef\n+                ghi\"\"\");\n+    }\n+\n+    \/**\n+     * Trailing spaces are never removed.\n+     *\/\n+    @Test\n+    public void testTrailingSpaces() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+                \/\/\/def    \\s\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def    \\s\n+                ghi\"\"\");\n+\n+    }\n+\n+    \/**\n+     * Trailing tabs are never removed.\n+     *\/\n+    @Test\n+    public void testTrailingTabs() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+                \/\/\/def    \\t\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                def    \\t\n+                ghi\"\"\");\n+\n+    }\n+\n+    \/**\n+     * Tabs may appear in incidental whitespace, and may remain in the leading\n+     * whitespace after incidental whitespace is removed.\n+     *\/\n+    @Test\n+    public void testMixedTabs() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/\\t \\t abc\n+                \/\/\/\\t \\t \\tdef\n+                \/\/\/\\t \\t ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                abc\n+                \\tdef\n+                ghi\"\"\");\n+\n+    }\n+\n+    \/**\n+     * A blank line between two \/\/\/ comments is significant, and separates the two comments.\n+     *\/\n+    @Test\n+    public void testMultipleComments() {\n+        \/\/ When there is more than one comment, the most recent comment is first in the list\n+        \/\/ stored in the token.\n+        \/\/\n+        \/\/ (For JavaDoc, only the most recent comment is used; any preceding comments are ignored.)\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/abc\n+\n+                \/\/\/ghi\n+\n+                ]\n+                \"\"\", \"\"\"\n+                ghi\"\"\", \"\"\"\n+                abc\"\"\");\n+\n+    }\n+\n+    \/**\n+     * An example of pseudo-typical Markdown, containing various Markdown constructs,\n+     * like lists and code blocks.\n+     *\/\n+    @Test\n+    public void testSampleMarkdown() {\n+        test(\"\"\"\n+                [\n+\n+                \/\/\/ Lorem ipsum dolor sit amet,\n+                \/\/\/ consectetur adipiscing elit.\n+                \/\/\/\n+                \/\/\/ * item 1\n+                \/\/\/ * item 2\n+                \/\/\/\n+                \/\/\/ ```\n+                \/\/\/ fenced code block\n+                \/\/\/ ```\n+                \/\/\/\n+                \/\/\/ Ut enim ad minim veniam, quis nostrud\n+                \/\/\/ exercitation ullamco laboris nisi ut\n+                \/\/\/ aliquip ex ea commodo consequat.\n+                \/\/\/\n+                \/\/\/     indented code block\n+                \/\/\/     ...\n+                \/\/\/\n+                \/\/\/ Duis aute irure dolor in reprehenderit\n+                \/\/\/ in voluptate velit esse cillum dolore\n+                \/\/\/ eu fugiat nulla pariatur.\n+                ]\n+                \"\"\", \"\"\"\n+                Lorem ipsum dolor sit amet,\n+                consectetur adipiscing elit.\n+\n+                * item 1\n+                * item 2\n+\n+                ```\n+                fenced code block\n+                ```\n+\n+                Ut enim ad minim veniam, quis nostrud\n+                exercitation ullamco laboris nisi ut\n+                aliquip ex ea commodo consequat.\n+\n+                    indented code block\n+                    ...\n+\n+                Duis aute irure dolor in reprehenderit\n+                in voluptate velit esse cillum dolore\n+                eu fugiat nulla pariatur.\"\"\");\n+\n+    }\n+\n+    private void test(String input, String... expect) {\n+        var ctx = new Context();\n+        var sf = ScannerFactory.instance(ctx);\n+        var s = sf.newScanner(input, true);\n+        s. nextToken();\n+        var skipToken = s.token();\n+        checkEqual(skipToken.kind, Tokens.TokenKind.LBRACKET);\n+\n+        s.nextToken();\n+        var t = s.token();\n+        var comments = t.comments;\n+        if (comments == null) {\n+            error(\"no comments\");\n+        } else if (comments.size() == expect.length) {\n+            for (var i = 0; i < comments.size(); i++) {\n+                checkEqual(comments.get(i).getText(), expect[i]);\n+            }\n+        } else {\n+            error(\"Unexpected comments: \" + comments);\n+            out.println(\"  expected \" + expect.length + \" comments\");\n+            out.println(\"     found \" + comments.size() + \" comments\");\n+        }\n+    }\n+\n+    private void checkEqual(Object found, Object expect) {\n+        if (!Objects.equals(found, expect)) {\n+            error(\"mismatch\");\n+            out.println(\"  expect: \" + String.valueOf(expect).replace(\"\\n\", \"|\"));\n+            out.println(\"   found: \" + String.valueOf(found).replace(\"\\n\", \"|\"));\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/lexer\/CommentTest.java","additions":524,"deletions":0,"binary":false,"changes":524,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1110,0 +1110,5 @@\n+        public Void visitRawText(RawTextTree node, Void p) {\n+            printLimitedEscapedString(\"content\", node.getContent());\n+            return visitTree(node, null);\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/lib\/DPrinter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -802,1 +802,1 @@\n-                \"Test.java:1:31: compiler.err.doesnt.exist: ma\",\n+                \"Test.java:1:38: compiler.err.doesnt.exist: ma\",\n@@ -830,1 +830,1 @@\n-                \"Test.java:1:15: compiler.err.doesnt.exist: ma\",\n+                \"Test.java:1:22: compiler.err.doesnt.exist: ma\",\n@@ -864,1 +864,1 @@\n-                \"Test.java:1:15: compiler.err.doesnt.exist: ma\",\n+                \"Test.java:1:22: compiler.err.doesnt.exist: ma\",\n","filename":"test\/langtools\/tools\/javac\/modules\/ConvenientAccessErrorsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304487\n+ * @bug 8304487 8327683 8330387\n@@ -45,0 +45,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing3());\n@@ -117,0 +118,5 @@\n+    public static boolean wideningReferenceConversionUnboxing3() {\n+        R_generic<Integer> i = new R_generic<Integer>(0x1000000);\n+        return i instanceof R_generic(float _);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithRecordPatterns.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257\n+ * @bug 8304487 8325257 8327683 8330387\n@@ -47,0 +47,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing3(0x1000000));\n@@ -124,0 +125,4 @@\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing3(T i) {\n+        return i instanceof float ff;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithTopLevelPatterns.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304487 8325257\n+ * @bug 8304487 8325257 8327683 8330387\n@@ -47,0 +47,1 @@\n+        assertEquals(true,  wideningReferenceConversionUnboxing3(0x1000000));\n@@ -124,0 +125,4 @@\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing3(T i) {\n+        return i instanceof float;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfTypeComparisonOp.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8304487 8325653\n+ * @bug 8304487 8325653 8332463\n@@ -62,1 +62,1 @@\n-            case byte ip     -> ip; \/\/ Error - dominated!\n+            case byte ip     -> ip; \/\/ OK - not dominated!\n@@ -264,0 +264,4 @@\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndNarrowingPrimitive(T i) {\n+        return i instanceof byte b;  \/\/ not allowed as a conversion\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n-PrimitivePatternsSwitchErrors.java:62:18: compiler.err.pattern.dominated\n@@ -32,0 +31,1 @@\n+PrimitivePatternsSwitchErrors.java:266:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: T, byte)\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8326404\n+ * @summary Assertion error when trying to compile switch with fallthrough with pattern\n+ * @compile T8326404.java\n+ * @run main T8326404\n+ *\/\n+public class T8326404 {\n+    private static final record R<T>(T a) {}\n+\n+    public static void main(String[] args) {\n+        assertEquals(4, run1(\"\"));\n+        assertEquals(3, run1(new R(\"\")));\n+        assertEquals(2, run1(new R(42)));\n+\n+        assertEquals(2, run1_break1(\"\"));\n+        assertEquals(1, run1_break1(new R(\"\")));\n+        assertEquals(2, run1_break1(new R(42)));\n+\n+        assertEquals(3, run2(\"\"));\n+        assertEquals(4, run2(new R(\"\")));\n+        assertEquals(2, run2(new R(42)));\n+\n+        assertEquals(1, run2_break1(\"\"));\n+        assertEquals(2, run2_break1(new R(\"\")));\n+        assertEquals(2, run2_break1(new R(42)));\n+\n+        assertEquals(2, run3(\"\"));\n+        assertEquals(4, run3(new R(\"\")));\n+        assertEquals(3, run3(new R(42)));\n+\n+        assertEquals(2, run3_break1(\"\"));\n+        assertEquals(2, run3_break1(new R(\"\")));\n+        assertEquals(1, run3_break1(new R(42)));\n+    }\n+\n+    private static int run1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case String _:\n+                i++;\n+            case R(String _):\n+                i++;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run1_break1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case String s:\n+                i++;\n+            case R(String _):\n+                i++;\n+                break;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run2(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case String _:\n+                i++;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run2_break1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case String _:\n+                i++;\n+                break;\n+            case R(Integer _):\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run3(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case R(Integer _):\n+                i++;\n+            case String _:\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    private static int run3_break1(Object o) {\n+        int i = 0;\n+        switch (o) {\n+            case R(String _):\n+                i++;\n+            case R(Integer _):\n+                i++;\n+                break;\n+            case String _:\n+                i++;\n+            default:\n+                i++;\n+        }\n+        return i;\n+    }\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8326404.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332463\n+ * @summary Byte conditional pattern case element dominates short constant case element\n+ * @compile --enable-preview --source ${jdk.version} T8332463a.java\n+ *\/\n+public class T8332463a {\n+    public int test2() {\n+        Byte i = (byte) 42;\n+        return switch (i) {\n+            case Byte ib  -> 1;\n+            case short s  -> 2;\n+        };\n+    }\n+\n+    public int test4() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer ib -> 1;\n+            case byte ip    -> 2;\n+        };\n+    }\n+\n+    public int test3() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer ib -> 1;\n+            case (byte) 0   -> 2;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463a.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332463\n+ * @summary Byte conditional pattern case element dominates short constant case element\n+ * @enablePreview\n+ * @compile T8332463b.java\n+ *  @compile --enable-preview --source ${jdk.version} T8332463b.java\n+ *\/\n+public class T8332463b {\n+    public int test1() {\n+        Byte i = (byte) 42;\n+        return switch (i) {\n+            case Byte ib   -> 1;\n+            case (short) 0 -> 2;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463b.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8331027\n+ * @summary Verify classfile inside ct.sym\n+ * @enablePreview\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.platform\n+ *          jdk.compiler\/com.sun.tools.javac.util:+open\n+ * @build toolbox.ToolBox VerifyCTSymClassFiles\n+ * @run main VerifyCTSymClassFiles\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class VerifyCTSymClassFiles {\n+\n+    public static void main(String... args) throws IOException, URISyntaxException {\n+        VerifyCTSymClassFiles t = new VerifyCTSymClassFiles();\n+\n+        t.checkClassFiles();\n+    }\n+\n+    void checkClassFiles() throws IOException {\n+        Path ctSym = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"ct.sym\");\n+\n+        if (!Files.exists(ctSym)) {\n+            \/\/no ct.sym, nothing to check:\n+            return ;\n+        }\n+        try (FileSystem fs = FileSystems.newFileSystem(ctSym)) {\n+            Files.walk(fs.getRootDirectories().iterator().next())\n+                 .filter(p -> Files.isRegularFile(p))\n+                 .forEach(p -> checkClassFile(p));\n+        }\n+    }\n+\n+    void checkClassFile(Path p) {\n+        if (!\"module-info.sig\".equals(p.getFileName().toString())) {\n+            return ;\n+        }\n+        try {\n+            ClassFile.of().parse(p).attributes().forEach(attr -> {\n+                if (attr instanceof ModuleMainClassAttribute mmca) {\n+                    mmca.mainClass();\n+                }\n+            });\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/VerifyCTSymClassFiles.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8072480 8277106\n+ * @bug 8072480 8277106 8331027\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -104,0 +105,3 @@\n+                                              \"--enable-preview\",\n+                                              \"--source\",\n+                                              \"\" + System.getProperty(\"java.specification.version\"),\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModulePackagesAttribute;\n+import java.lang.constant.PackageDesc;\n@@ -61,8 +66,5 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.attribute.ModuleMainClassAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -984,0 +986,5 @@\n+        return prepareVersionedCTSym(code7, code8, _ -> {});\n+    }\n+\n+    Path prepareVersionedCTSym(String[] code7, String[] code8,\n+                               Consumer<Path> adjustClassFiles) throws Exception {\n@@ -989,1 +996,1 @@\n-        compileAndPack(output, ver7Jar, code7);\n+        compileAndPack(output, ver7Jar, adjustClassFiles, code7);\n@@ -991,1 +998,1 @@\n-        compileAndPack(output, ver8Jar, code8);\n+        compileAndPack(output, ver8Jar, adjustClassFiles, code8);\n@@ -1051,0 +1058,100 @@\n+    @Test\n+    void testModuleMainClass() throws Exception {\n+        ClassFile cf = ClassFile.of();\n+        ToolBox tb = new ToolBox();\n+        String testClasses = System.getProperty(\"test.classes\");\n+        Path output = Paths.get(testClasses, \"test-data\" + i++);\n+        deleteRecursively(output);\n+        Files.createDirectories(output);\n+        Path ver9Jar = output.resolve(\"9.jar\");\n+        compileAndPack(output,\n+                       ver9Jar,\n+                       classesDir -> {\n+                           try {\n+                               Path moduleInfo = classesDir.resolve(\"module-info.class\");\n+                               byte[] newClassData =\n+                                       cf.transform(cf.parse(moduleInfo),\n+                                                    (builder, element) -> {\n+                                                        builder.with(element);\n+                                                        if (element instanceof ModuleAttribute) {\n+                                                            builder.with(ModuleMainClassAttribute.of(ClassDesc.of(\"main.Main\")));\n+                                                        }\n+                                                    });\n+                               try (OutputStream out = Files.newOutputStream(moduleInfo)) {\n+                                   out.write(newClassData);\n+                               }\n+                           } catch (IOException ex) {\n+                               throw new UncheckedIOException(ex);\n+                           }\n+                       },\n+                       \"\"\"\n+                       module m {\n+                       }\n+                       \"\"\",\n+                       \"\"\"\n+                       package main;\n+                       public class Main {}\n+                       \"\"\");\n+\n+\n+        Path ctSym = output.resolve(\"ct.sym\");\n+\n+        deleteRecursively(ctSym);\n+\n+        CreateSymbols.ALLOW_NON_EXISTING_CLASSES = true;\n+        CreateSymbols.EXTENSION = \".class\";\n+\n+        List<VersionDescription> versions =\n+                Arrays.asList(new VersionDescription(ver9Jar.toAbsolutePath().toString(), \"9\", null));\n+\n+        ExcludeIncludeList acceptAll = new ExcludeIncludeList(null, null) {\n+            @Override public boolean accepts(String className, boolean includePrivateClasses) {\n+                return true;\n+            }\n+        };\n+        new CreateSymbols().createBaseLine(versions, acceptAll, ctSym, new String[0]);\n+        Path symbolsDesc = ctSym.resolve(\"symbols\");\n+        Path modules = ctSym.resolve(\"modules\");\n+        Path modulesList = ctSym.resolve(\"modules-list\");\n+\n+        Files.createDirectories(modules);\n+        try (Writer w = Files.newBufferedWriter(modulesList)) {}\n+\n+        Path classesZip = output.resolve(\"classes.zip\");\n+        Path classesDir = output.resolve(\"classes\");\n+\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", \"\", modules.toString(), modulesList.toString());\n+\n+        try (JarFile jf = new JarFile(classesZip.toFile())) {\n+            Enumeration<JarEntry> en = jf.entries();\n+\n+            while (en.hasMoreElements()) {\n+                JarEntry je = en.nextElement();\n+                if (je.isDirectory()) continue;\n+                Path target = classesDir.resolve(je.getName());\n+                Files.createDirectories(target.getParent());\n+                Files.copy(jf.getInputStream(je), target);\n+            }\n+        }\n+\n+        Path moduleInfo = classesDir.resolve(\"9\")\n+                                    .resolve(\"m\")\n+                                    .resolve(\"module-info.class\");\n+\n+        cf.parse(moduleInfo)\n+          .attributes()\n+          .stream()\n+          .filter(attr -> attr instanceof ModuleMainClassAttribute)\n+          .forEach(attr -> {\n+              String expectedMain = \"Lmain\/Main;\";\n+              String mainClass =\n+                      ((ModuleMainClassAttribute) attr).mainClass()\n+                                                       .asSymbol()\n+                                                       .descriptorString();\n+              if (!Objects.equals(expectedMain, mainClass)) {\n+                  throw new AssertionError(\"Expected \" + expectedMain + \" as a main class, \" +\n+                                           \"but got: \" + mainClass);\n+              }\n+          });\n+    }\n+\n@@ -1052,0 +1159,5 @@\n+        compileAndPack(output, outputFile, _ -> {}, code);\n+    }\n+\n+    void compileAndPack(Path output, Path outputFile,\n+                        Consumer<Path> adjustClassFiles, String... code) throws Exception {\n@@ -1068,17 +1180,10 @@\n-            ClassFile cf = ClassFile.read(moduleInfo);\n-            List<CPInfo> cp = new ArrayList<>();\n-            cp.add(null);\n-            cf.constant_pool.entries().forEach(cp::add);\n-            Map<String, Attribute> attrs = new HashMap<>(cf.attributes.map);\n-            int[] encodedPackages = new int[packages.size()];\n-            int i = 0;\n-            for (String p : packages) {\n-                int nameIndex = cp.size();\n-                cp.add(new CONSTANT_Utf8_info(p));\n-                encodedPackages[i++] = cp.size();\n-                cp.add(new ConstantPool.CONSTANT_Package_info(null, nameIndex));\n-            }\n-            int attrName = cp.size();\n-            cp.add(new CONSTANT_Utf8_info(Attribute.ModulePackages));\n-            attrs.put(Attribute.ModulePackages, new ModulePackages_attribute(attrName, encodedPackages));\n-            ClassFile newFile = new ClassFile(cf.magic, cf.minor_version, cf.major_version, new ConstantPool(cp.toArray(new CPInfo[0])), cf.access_flags, cf.this_class, cf.super_class, cf.interfaces, cf.fields, cf.methods, new Attributes(attrs));\n+            ClassFile cf = ClassFile.of();\n+            ClassModel cm = cf.parse(moduleInfo);\n+            byte[] newData = cf.transform(cm, (builder, element) -> {\n+                builder.with(element);\n+                if (element instanceof ModuleAttribute) {\n+                    builder.with(ModulePackagesAttribute.ofNames(packages.stream()\n+                                                                         .map(pack -> PackageDesc.of(pack))\n+                                                                         .toList()));\n+                }\n+            });\n@@ -1086,1 +1191,1 @@\n-                new ClassWriter().write(newFile, out);\n+                out.write(newData);\n@@ -1089,0 +1194,1 @@\n+        adjustClassFiles.accept(scratch);\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":134,"deletions":28,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332297\n+ * @summary annotation processor that generates records sometimes fails due to NPE in javac\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.Task\n+ * @build RecordGenerationTest JavacTestingAbstractProcessor\n+ * @run main RecordGenerationTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Set;\n+\n+import javax.annotation.processing.FilerException;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedOptions;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.StandardLocation;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class RecordGenerationTest {\n+    public static void main(String... args) throws Exception {\n+        new RecordGenerationTest().run();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws Exception {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    void run() throws Exception {\n+        Path allInOne = Paths.get(\"allInOne\");\n+        if (Files.isDirectory(allInOne)) {\n+            tb.cleanDirectory(allInOne);\n+        }\n+        Files.deleteIfExists(allInOne);\n+        tb.createDirectories(allInOne);\n+\n+        tb.writeJavaFiles(allInOne,\n+                \"\"\"\n+                import java.io.IOException;\n+                import java.io.OutputStream;\n+                import java.io.Writer;\n+                import java.nio.file.Files;\n+                import java.nio.file.Path;\n+                import java.nio.file.Paths;\n+                import java.util.Set;\n+\n+                import javax.annotation.processing.AbstractProcessor;\n+                import javax.annotation.processing.FilerException;\n+                import javax.annotation.processing.RoundEnvironment;\n+                import javax.annotation.processing.SupportedOptions;\n+                import javax.annotation.processing.SupportedAnnotationTypes;\n+\n+                import javax.lang.model.element.TypeElement;\n+                import javax.tools.StandardLocation;\n+\n+                @SupportedAnnotationTypes(\"*\")\n+                public class AP extends AbstractProcessor {\n+                    @Override\n+                    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+                        if (roundEnv.processingOver()) {\n+                            try (Writer w = processingEnv.getFiler().createSourceFile(\"ConfRecord\").openWriter()) {\n+                                w.append(\"@RecordBuilder public record ConfRecord(int maxConcurrency) implements Conf {}\");\n+                            } catch (IOException ex) {\n+                                throw new IllegalStateException(ex);\n+                            }\n+                        }\n+                        return true;\n+                    }\n+                }\n+                \"\"\"\n+        );\n+\n+        new JavacTask(tb).options(\"-d\", allInOne.toString())\n+                .files(findJavaFiles(allInOne))\n+                .run()\n+                .writeAll();\n+\n+        tb.writeJavaFiles(allInOne,\n+                \"\"\"\n+                interface Conf {\n+                    int maxConcurrency( );\n+                }\n+                \"\"\",\n+                \"\"\"\n+                import java.lang.annotation.*;\n+                public @interface RecordBuilder {\n+                }\n+                \"\"\"\n+        );\n+\n+        Path confSource = Paths.get(allInOne.toString(), \"Conf.java\");\n+        new JavacTask(tb).options(\"-processor\", \"AP\",\n+                \"-cp\", allInOne.toString(),\n+                \"-d\", allInOne.toString())\n+                .files(confSource)\n+                .run()\n+                .writeAll();\n+\n+        \/* the bug reported at JDK-8332297 was reproducible only every other time this is why we reproduce\n+         * the same compilation command as above basically the second time the compiler is completing the\n+         * record symbol from the class file produced during the first compilation\n+         *\/\n+        new JavacTask(tb).options(\"-processor\", \"AP\",\n+                \"-cp\", allInOne.toString(),\n+                \"-d\", allInOne.toString())\n+                .files(confSource)\n+                .run()\n+                .writeAll();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/RecordGenerationTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307184\n+ * @summary Test basic operation of Elements.getDocCommentKind\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @build   toolbox.ToolBox JavacTestingAbstractProcessor TestGetDocCommentKind\n+ * @compile -processor TestGetDocCommentKind -proc:only TestGetDocCommentKind.java\n+ *\/\n+\n+import java.util.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.*;\n+import javax.lang.model.util.Elements.DocCommentKind;\n+\n+public class TestGetDocCommentKind extends JavacTestingAbstractProcessor {\n+    final Elements vacuousElements = new VacuousElements();\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            boolean elementSeen = false;\n+\n+            for (TypeElement typeRoot : ElementFilter.typesIn(roundEnv.getRootElements()) ) {\n+                for (Element element : typeRoot.getEnclosedElements()) {\n+                    ExpectedKind expectedKind = element.getAnnotation(ExpectedKind.class);\n+                    if (expectedKind != null ) {\n+                        elementSeen = true;\n+\n+                        checkKind(element, elements, expectedKind.value());\n+                        checkKind(element, vacuousElements, null);\n+                    }\n+                }\n+\n+                if (!elementSeen) {\n+                    throw new RuntimeException(\"No elements seen.\");\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    void checkKind(Element e, Elements elementUtils, DocCommentKind expectedKind) {\n+        var actualKind = elementUtils.getDocCommentKind(e);\n+        if (actualKind != expectedKind) {\n+            messager.printError(\"Unexpected doc comment kind found: \" + actualKind\n+                    + \"expected: \" + expectedKind, e);\n+        }\n+    }\n+\n+    @interface ExpectedKind {\n+        DocCommentKind value();\n+    }\n+\n+    \/**\n+     * Traditional comment.\n+     *\/\n+    @ExpectedKind(DocCommentKind.TRADITIONAL)\n+    public void traditionalComment() { }\n+\n+    \/\/\/ End-of-line comment.\n+    @ExpectedKind(DocCommentKind.END_OF_LINE)\n+    public void endOfLineComment() { }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestGetDocCommentKind.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Test basic operation of Elements.getDocComments\n+ * @summary Test basic operation of Elements.getDocComment\n@@ -29,2 +29,2 @@\n- * @build   toolbox.ToolBox JavacTestingAbstractProcessor TestGetDocComments\n- * @compile -processor TestGetDocComments -proc:only TestGetDocComments.java\n+ * @build   toolbox.ToolBox JavacTestingAbstractProcessor TestGetDocComment_Block\n+ * @compile -processor TestGetDocComment_Block -proc:only TestGetDocComment_Block.java\n@@ -33,1 +33,0 @@\n-import java.io.Writer;\n@@ -35,1 +34,0 @@\n-import java.util.function.*;\n@@ -42,1 +40,1 @@\n- * Test basic workings of Elements.getDocComments\n+ * Test basic operation of Elements.getDocComment for block comments\n@@ -44,1 +42,1 @@\n-public class TestGetDocComments extends JavacTestingAbstractProcessor {\n+public class TestGetDocComment_Block extends JavacTestingAbstractProcessor {\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestGetDocComment_Block.java","additions":6,"deletions":8,"binary":false,"changes":14,"previous_filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestGetDocComments.java","status":"renamed"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307184\n+ * @summary Test basic operation of Elements.getDocComment\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @build   toolbox.ToolBox JavacTestingAbstractProcessor TestGetDocComment_Line\n+ * @compile -processor TestGetDocComment_Line -proc:only TestGetDocComment_Line.java\n+ *\/\n+\n+import java.util.Set;\n+\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.util.ElementFilter;\n+\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Test basic operation of Elements.getDocComment for line comments\n+ *\/\n+public class TestGetDocComment_Line extends JavacTestingAbstractProcessor {\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            boolean elementSeen = false;\n+\n+            for (TypeElement typeRoot : ElementFilter.typesIn(roundEnv.getRootElements()) ) {\n+                for (Element element : typeRoot.getEnclosedElements()) {\n+                    ExpectedComment expectedComment = element.getAnnotation(ExpectedComment.class);\n+                    if (expectedComment != null ) {\n+                        elementSeen = true;\n+                        String expectedCommentStr = expectedComment.value();\n+                        String actualComment = elements.getDocComment(element);\n+\n+                        if (!expectedCommentStr.equals(actualComment)) {\n+                            messager.printError(\"Unexpected doc comment found\", element);\n+                            System.err.println(\"expect>>\" + expectedCommentStr + \"<<\");\n+                            System.err.println(\"actual>>\" + actualComment + \"<<\");\n+                            (new ToolBox()).checkEqual(expectedCommentStr.lines().toList(),\n+                                                       actualComment.lines().toList());\n+                        }\n+                    }\n+                }\n+\n+                if (!elementSeen) {\n+                    throw new RuntimeException(\"No elements seen.\");\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @interface ExpectedComment {\n+        String value();\n+    }\n+\n+    \/\/ Basic processing of interior lines\n+    \/\/\/Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n+    \/\/\/eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut\n+    \/\/\/enim ad minim veniam, quis nostrud exercitation ullamco laboris\n+    \/\/\/nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\n+    \/\/\/in reprehenderit in voluptate velit esse cillum dolore eu\n+    \/\/\/fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\n+    \/\/\/proident, sunt in culpa qui officia deserunt mollit anim id est\n+    \/\/\/laborum.\n+    @ExpectedComment(\"\"\"\n+     Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n+     eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut\n+     enim ad minim veniam, quis nostrud exercitation ullamco laboris\n+     nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\n+     in reprehenderit in voluptate velit esse cillum dolore eu\n+     fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\n+     proident, sunt in culpa qui officia deserunt mollit anim id est\n+     laborum.\"\"\")\n+    \/\/ End-of-line-style comment\n+    @SuppressWarnings(\"\") \/\/ A second preceding annotation\n+    \/* Traditional comment *\/\n+    private void foo() {return ;}\n+\n+\n+    \/\/ Check removal of space characters;\n+    \/\/ excess \/ characters are not removed\n+    \/\/ use Unicode escape to test tab removal\n+\/\/\/Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n+\/\/\/\/eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut\n+\/\/\/\/\/enim ad minim veniam, quis nostrud exercitation ullamco laboris\n+\/\/\/\/\/\/nisi ut aliquip ex ea commodo consequat.\n+ \\u0009\/\/\/Duis aute irure dolor in reprehenderit in voluptate velit esse\n+ \/\/\/\/cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat\n+  \/\/\/\/\/cupidatat non proident, sunt in culpa qui officia deserunt mollit\n+                                            \/\/\/anim id est laborum.\n+    @ExpectedComment(\"\"\"\n+       Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n+       \/eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut\n+       \/\/enim ad minim veniam, quis nostrud exercitation ullamco laboris\n+       \/\/\/nisi ut aliquip ex ea commodo consequat.\n+       Duis aute irure dolor in reprehenderit in voluptate velit esse\n+       \/cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat\n+       \/\/cupidatat non proident, sunt in culpa qui officia deserunt mollit\n+       anim id est laborum.\"\"\")\n+    @SuppressWarnings(\"\") \/\/ A second preceding annotation\n+    \/\/ End-of-line-style comment\n+    \/*\n+     * Traditional comment over multiple lines.\n+     *\/\n+    private void bar() {return ;}\n+\n+    \/\/ Incidental whitespace _after_ the \/\/\/ prefix is deleted;\n+    \/\/ additional indentation is _not_ deleted\n+    \/\/\/  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n+    \/\/\/  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut\n+    \/\/\/   enim ad minim veniam, quis nostrud exercitation ullamco laboris\n+    \/\/\/    nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\n+    \/\/\/     in reprehenderit in voluptate velit esse cillum dolore eu\n+    \/\/\/  fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\n+    \/\/\/  proident, sunt in culpa qui officia deserunt mollit anim id est\n+    \/\/\/  laborum.\n+    @ExpectedComment(\"\"\"\n+     Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n+     eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut\n+      enim ad minim veniam, quis nostrud exercitation ullamco laboris\n+       nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor\n+        in reprehenderit in voluptate velit esse cillum dolore eu\n+     fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\n+     proident, sunt in culpa qui officia deserunt mollit anim id est\n+     laborum.\"\"\")\n+    private void baz() {return ;}\n+\n+    \/\/ Incidental space after \/\/\/ is removed, but not space at the end of the line\n+    \/\/\/   Totality\\u0020\n+    @ExpectedComment(\"Totality \")\n+    private void quux() {return ;}\n+\n+    \/\/\/\n+    @ExpectedComment(\"\")\n+    private void empty() {return ;}\n+\n+    \/\/\/ tail\\u0020\n+    @ExpectedComment(\"tail \")\n+    private void tail() {return ;}\n+\n+    \/\/ Testing of line terminators, javac implementation normalizes them:\n+    \/\/ * newline: \\u000A\n+    \/\/ * carriage return: \\u000D\n+    \/\/ * * carriage return + newline: \\u000D\\u000A\n+    \/\/\/ Lorem\\u000A\/\/\/ \\u000D\/\/\/ \\u000D\\u000A\/\/\/ ipsum\n+    @ExpectedComment(\"Lorem\\n\\n\\nipsum\")\n+    private void wombat2() {return ;}\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestGetDocComment_Line.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8328481\n+ * @summary Verify the Trees model for module imports\n+ * @library \/tools\/lib\n+ * @modules java.logging\n+ *          java.sql\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main Imports\n+*\/\n+\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskEvent.Kind;\n+import com.sun.source.util.TaskListener;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class Imports extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new Imports().runTests();\n+    }\n+\n+    Imports() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testModuleImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        AtomicInteger seenImports = new AtomicInteger(-1);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .callback(task -> {\n+                task.addTaskListener(new TaskListener() {\n+                    @Override\n+                    public void finished(TaskEvent e) {\n+                        if (e.getKind() != Kind.PARSE) {\n+                            return ;\n+                        }\n+\n+                        var imports = e.getCompilationUnit().getImports();\n+\n+                        seenImports.set(imports.size());\n+\n+                        if (imports.size() != 1) {\n+                            throw new AssertionError(\"Exception 1 import, \" +\n+                                                     \"but got: \" + imports.size());\n+                        }\n+\n+                        ImportTree it = imports.get(0);\n+\n+                        if (!it.isModule()) {\n+                            throw new AssertionError(\"Expected module import, but got ordinary one.\");\n+                        }\n+\n+                        if (!\"java.base\".equals(it.getQualifiedIdentifier().toString())) {\n+                            throw new AssertionError(\"Expected module import for java.base, \" +\n+                                                     \"but got: \" + it.getQualifiedIdentifier());\n+                        }\n+\n+                        String expectedImportToString = \"import module java.base;\\n\";\n+                        String actualImportToString = it.toString()\n+                                                        .replaceAll(\"\\\\R\", \"\\n\");\n+\n+                        if (!expectedImportToString.equals(actualImportToString)) {\n+                            throw new AssertionError(\"Expected '\" + expectedImportToString + \"', \" +\n+                                                     \"but got: '\" + it + \"'\");\n+                        }\n+                    }\n+                });\n+            })\n+            .run(Task.Expect.SUCCESS);\n+\n+        if (seenImports.get() == (-1)) {\n+            throw new AssertionError(\"Did not verify any imports!\");\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/tree\/Imports.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.javap\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n@@ -33,1 +32,0 @@\n-import java.util.*;\n","filename":"test\/langtools\/tools\/javap\/T6866657.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.jdeps\/com.sun.tools.javap\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n@@ -32,2 +31,0 @@\n-import java.io.*;\n-import java.util.*;\n","filename":"test\/langtools\/tools\/javap\/T7186925.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,15 +315,8 @@\n-            switch (type.wildcardIndicator()) {\n-                case UNBOUNDED -> {\n-                    return \"W{?}\";\n-                }\n-                case EXTENDS -> {\n-                    return \"W{e,\" + print(type.boundType().get()) + \"}\";\n-                }\n-                case SUPER -> {\n-                    return \"W{s,\" + print(type.boundType().get()) + \"}\";\n-                }\n-                default -> {\n-                    if (type.boundType().isPresent()) return print(type.boundType().get());\n-                    else throw new AssertionError();\n-                }\n-            }\n+            return switch (type) {\n+                case Signature.TypeArg.Unbounded _ -> \"W{?}\";\n+                case Signature.TypeArg.Bounded b -> switch (b.wildcardIndicator()) {\n+                    case EXTENDS -> \"W{e,\" + print(b.boundType()) + \"}\";\n+                    case SUPER -> \"W{s,\" + print(b.boundType()) + \"}\";\n+                    case NONE -> print(b.boundType());\n+                };\n+            };\n","filename":"test\/langtools\/tools\/javap\/classfile\/6888367\/T6888367.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n@@ -29,3 +31,4 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.Dependencies.*;\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependencies;\n+import com.sun.tools.jdeps.Dependencies.*;\n+import com.sun.tools.jdeps.Dependency;\n+import com.sun.tools.jdeps.Dependency.Location;\n@@ -143,1 +146,1 @@\n-        public ClassFile getClassFile(String className) throws ClassFileNotFoundException {\n+        public ClassModel getClassFile(String className) throws ClassFileNotFoundException {\n@@ -154,1 +157,1 @@\n-                    return ClassFile.read(in);\n+                    return ClassFile.of().parse(in.readAllBytes());\n@@ -158,1 +161,1 @@\n-            } catch (ConstantPoolException e) {\n+            } catch (IllegalArgumentException e) {\n","filename":"test\/langtools\/tools\/javap\/classfile\/deps\/GetDeps.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules jdk.jdeps\/com.sun.tools.jdeps\n@@ -30,0 +30,1 @@\n+ * @enablePreview\n","filename":"test\/langtools\/tools\/javap\/classfile\/deps\/T6907575.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Simple tests for method signature parsing\n- * @modules jdk.jdeps\/com.sun.tools.jdeprscan.scan\n- * @build TestMethodSig\n- * @run testng jdk.jdeprscan.TestMethodSig\n- *\/\n-\n-package jdk.jdeprscan;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-import static com.sun.tools.jdeprscan.scan.MethodSig.fromDesc;\n-\n-public class TestMethodSig {\n-    @Test\n-    public void testSimple() {\n-        assertEquals(fromDesc(\"(Ljava\/rmi\/RMISecurityManager;)Ljava\/lang\/Object;\").toString(),\n-                     \"parameters 0=Ljava\/rmi\/RMISecurityManager; return Ljava\/lang\/Object;\");\n-    }\n-\n-    @Test\n-    public void testMultParamVoidReturn() {\n-        assertEquals(fromDesc(\"([[IZLjava\/lang\/String;B[J)V\").toString(),\n-                     \"parameters 0=[[I 1=Z 2=Ljava\/lang\/String; 3=B 4=[J return V\");\n-    }\n-\n-    @Test\n-    public void testNoParams() {\n-        assertEquals(fromDesc(\"()J\").toString(),\n-                     \"parameters none return J\");\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testMissingReturnType() {\n-        fromDesc(\"(ISJZ)\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/jdeprscan\/tests\/jdk\/jdeprscan\/TestMethodSig.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n@@ -107,1 +106,1 @@\n-             new String[] {\"g.G\", \"sun.security.x509.X509CertInfo\", \"com.sun.tools.classfile.ClassFile\",\n+             new String[] {\"g.G\", \"sun.security.x509.X509CertInfo\", \"com.sun.tools.jdeps.Analyzer\",\n@@ -113,1 +112,1 @@\n-             new String[] {\"sun.security.x509.X509CertInfo\", \"com.sun.tools.classfile.ClassFile\"},\n+             new String[] {\"sun.security.x509.X509CertInfo\", \"com.sun.tools.jdeps.Analyzer\"},\n@@ -117,1 +116,1 @@\n-             new String[] {\"com.sun.tools.classfile.ClassFile\",\n+             new String[] {\"com.sun.tools.jdeps.Analyzer\",\n","filename":"test\/langtools\/tools\/jdeps\/APIDeps.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+                                \"java.base\/jdk.internal.javac\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-    public com.sun.tools.classfile.ClassFile cf;     \/\/ not exported\n+    public com.sun.tools.jdeps.Analyzer analyzer;     \/\/ not exported\n","filename":"test\/langtools\/tools\/jdeps\/m\/Gee.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -750,0 +750,2 @@\n+        private final static Pattern importModulePattern =\n+                Pattern.compile(\"import\\\\s+module\\\\s+(((?:\\\\w+\\\\.)*)\\\\w+);\");\n@@ -764,9 +766,4 @@\n-            StringBuilder sb = new StringBuilder();\n-            Matcher matcher = commentPattern.matcher(source);\n-            int start = 0;\n-            while (matcher.find()) {\n-                sb.append(source, start, matcher.start());\n-                start = matcher.end();\n-            }\n-            sb.append(source.substring(start));\n-            source = sb.toString();\n+            source = removeMatchingSpans(source, commentPattern);\n+            source = removeMatchingSpans(source, importModulePattern);\n+\n+            Matcher matcher;\n@@ -798,0 +795,14 @@\n+\n+        static String removeMatchingSpans(String source, Pattern toRemove) {\n+            StringBuilder sb = new StringBuilder();\n+            Matcher matcher = toRemove.matcher(source);\n+            int start = 0;\n+\n+            while (matcher.find()) {\n+                sb.append(source, start, matcher.start());\n+                start = matcher.end();\n+            }\n+\n+            sb.append(source.substring(start));\n+            return sb.toString();\n+        }\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-                \"isHardenedOSX\", \"hasOSXPlistEntries\", \"isOracleLinux7\");\n+                \"isHardenedOSX\", \"hasOSXPlistEntries\", \"isOracleLinux7\", \"isOnWayland\");\n","filename":"test\/lib-test\/jdk\/test\/lib\/TestMutuallyExclusivePlatformPredicates.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -476,0 +476,9 @@\n+\n+    \/**\n+     * Checks if the current system is running on Wayland display server on Linux.\n+     *\n+     * @return {@code true} if the system is running on Wayland display server\n+     *\/\n+    public static boolean isOnWayland() {\n+        return System.getenv(\"WAYLAND_DISPLAY\") != null;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -668,1 +668,1 @@\n-     * after filtering out the Hotespot warning messages\n+     * after filtering out the Hotspot warning messages\n@@ -684,0 +684,18 @@\n+    \/**\n+     * Verify that the stderr contents of output buffer matches the pattern,\n+     * after filtering out the Hotspot deprecation warning messages\n+     *\n+     * @param pattern\n+     * @throws RuntimeException If the pattern was not found\n+     *\/\n+    public OutputAnalyzer stderrShouldMatchIgnoreDeprecatedWarnings(String pattern) {\n+        String stderr = getStderr().replaceAll(deprecatedmsg + \"\\\\R\", \"\");\n+        Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);\n+        if (!matcher.find()) {\n+            reportDiagnosticSummary();\n+            throw new RuntimeException(\"'\" + pattern\n+                  + \"' missing from stderr\");\n+        }\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.classfile;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Performance of conversion from type descriptor objects to type kind.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 1)\n+@State(Scope.Thread)\n+public class TypeKindBench {\n+\n+    public enum ClassType {\n+        PRIMITIVE, REFERENCE, MIXED;\n+    }\n+\n+    @Param\n+    ClassType type;\n+    Class<?>[] classes;\n+    ClassDesc[] classDescs;\n+\n+    @Setup\n+    public void setup() {\n+        var references = List.of(Character.class, String.class, Integer.class,\n+                Long.class, Object.class, int[].class, TypeKindBench.class,\n+                Byte[].class, boolean[][].class);\n+        var primitives = List.of(int.class, long.class, void.class, double.class,\n+                float.class, boolean.class, char.class, short.class, byte.class);\n+        final List<Class<?>> candidates = switch (type) {\n+            case REFERENCE -> references;\n+            case PRIMITIVE -> primitives;\n+            case MIXED -> {\n+                var list = new ArrayList<Class<?>>(references.size() + primitives.size());\n+                list.addAll(references);\n+                list.addAll(primitives);\n+                yield list;\n+            }\n+        };\n+\n+        \/\/ Use fixed seed to ensure results are comparable across\n+        \/\/ different JVMs\n+        classes = new Random(0xbf5fe40dd887d9e2L)\n+                .ints(100, 0, candidates.size())\n+                .mapToObj(candidates::get)\n+                .toArray(Class<?>[]::new);\n+        classDescs = Arrays.stream(classes)\n+                .map(cl -> cl.describeConstable().orElseThrow())\n+                .toArray(ClassDesc[]::new);\n+    }\n+\n+    @Benchmark\n+    public void fromClasses(Blackhole bh) {\n+        for (var clz : classes) {\n+            bh.consume(TypeKind.from(clz));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fromClassDescs(Blackhole bh) {\n+        for (var clz : classDescs) {\n+            bh.consume(TypeKind.from(clz));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/classfile\/TypeKindBench.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -63,0 +64,15 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Warmup(iterations = 3, time = 2)\n+    @Measurement(iterations = 6, time = 1)\n+    @Fork(1)\n+    @State(Scope.Thread)\n+    public static class ReferenceOnly {\n+        public ClassDesc desc = ConstantDescs.CD_Object;\n+        @Benchmark\n+        public ClassDesc ofNested() {\n+            return desc.nested(\"Foo\");\n+        }\n+\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/ClassDescFactories.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Test various operations on\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class ClassDescMethods {\n+\n+    @Benchmark\n+    public String packageName() {\n+        return ConstantDescs.CD_Object.packageName();\n+    }\n+\n+    @Benchmark\n+    public String displayName() {\n+        return ConstantDescs.CD_Object.displayName();\n+    }\n+\n+    @Benchmark\n+    public void arrayType(Blackhole bh) {\n+        bh.consume(ConstantDescs.CD_Object.arrayType());\n+        bh.consume(ConstantDescs.CD_boolean.arrayType());\n+    }\n+\n+    @Benchmark\n+    public void arrayType1(Blackhole bh) {\n+        bh.consume(ConstantDescs.CD_Object.arrayType(1));\n+        bh.consume(ConstantDescs.CD_boolean.arrayType(1));\n+    }\n+\n+    @Benchmark\n+    public void arrayType2(Blackhole bh) {\n+        bh.consume(ConstantDescs.CD_Object.arrayType(2));\n+        bh.consume(ConstantDescs.CD_boolean.arrayType(2));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/ClassDescMethods.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -40,0 +41,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -60,0 +63,7 @@\n+    static final VarHandle VH_SEQ_INT = bindToZeroOffset(MemoryLayout.sequenceLayout(ELEM_SIZE, JAVA_INT).varHandle(PathElement.sequenceElement()));\n+    static final VarHandle VH_SEQ_INT_UNALIGNED = bindToZeroOffset(MemoryLayout.sequenceLayout(ELEM_SIZE, JAVA_INT.withByteAlignment(1)).varHandle(PathElement.sequenceElement()));\n+\n+    static VarHandle bindToZeroOffset(VarHandle varHandle) {\n+        return MethodHandles.insertCoordinates(varHandle, 1, 0L);\n+    }\n+\n@@ -135,0 +145,18 @@\n+    @Benchmark\n+    public int segment_loop_nested() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_SEQ_INT.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_nested_unaligned() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_SEQ_INT_UNALIGNED.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToJavaString.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-                    cob.constantInstruction(100L);\n+                    cob.loadConstant(100L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/LazyStaticColdStart.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,9 +136,0 @@\n-    \/** Invokes the toString method of BigDecimal with various different values. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testToString(Blackhole bh) {\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(s.toString());\n-        }\n-    }\n-\n@@ -197,1 +188,1 @@\n-    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n+    \/** Test divide with huge\/small numbers *\/\n@@ -199,5 +190,6 @@\n-    @OperationsPerInvocation(TEST_SIZE - 1)\n-    public void testCompareTo(Blackhole bh) {\n-        BigDecimal c = bigDecimals[0];\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(c.compareTo(s));\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testHugeSmallDivide(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            for (BigDecimal t : smallArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -207,1 +199,1 @@\n-    \/** Test BigDecimal.toString() with huge numbers larger than MAX_LONG *\/\n+    \/** Test divide with large\/small numbers *\/\n@@ -209,4 +201,6 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testHugeToString(Blackhole bh) {\n-        for (BigDecimal s : hugeArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testLargeSmallDivide(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            for (BigDecimal t : smallArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -216,1 +210,1 @@\n-    \/** Test BigDecimal.toString() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    \/** Test divide with huge\/large numbers *\/\n@@ -218,4 +212,6 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testLargeToString(Blackhole bh) {\n-        for (BigDecimal s : largeArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE * TEST_SIZE)\n+    public void testHugeLargeDivide(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            for (BigDecimal t : largeArray) {\n+                bh.consume(s.divide(t, RoundingMode.DOWN));\n+            }\n@@ -225,1 +221,1 @@\n-    \/** Test BigDecimal.toString() with small numbers less than MAX_INT *\/\n+    \/** Invokes the compareTo method of BigDecimal with various different values. *\/\n@@ -227,4 +223,5 @@\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testSmallToString(Blackhole bh) {\n-        for (BigDecimal s : smallArray) {\n-            bh.consume(s.toString());\n+    @OperationsPerInvocation(TEST_SIZE - 1)\n+    public void testCompareTo(Blackhole bh) {\n+        BigDecimal c = bigDecimals[0];\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(c.compareTo(s));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":28,"deletions":31,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,33 @@\n+    \/** Test divide with huge\/small numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testHugeSmallDivide(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            for (BigInteger t : smallArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n+    \/** Test divide with large\/small numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testLargeSmallDivide(Blackhole bh) {\n+        for (BigInteger s : largeArray) {\n+            for (BigInteger t : smallArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n+    \/** Test divide with huge\/large numbers *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE * TESTSIZE)\n+    public void testHugeLargeDivide(Blackhole bh) {\n+        for (BigInteger s : hugeArray) {\n+            for (BigInteger t : largeArray) {\n+                bh.consume(s.divide(t));\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegers.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -111,2 +111,5 @@\n-        InflaterInputStream iis = new InflaterInputStream(deflated);\n-        while (iis.read(inflated, 0, inflated.length) != -1);\n+        \/\/ We close the InflaterInputStream to release underlying native resources of the Inflater.\n+        \/\/ The \"deflated\" ByteArrayInputStream remains unaffected.\n+        try (InflaterInputStream iis = new InflaterInputStream(deflated)) {\n+            while (iis.read(inflated, 0, inflated.length) != -1);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/zip\/InflaterInputStreams.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import sun.security.util.math.intpoly.MontgomeryIntegerPolynomialP256;\n+import sun.security.util.math.intpoly.IntegerPolynomialP256;\n+import sun.security.util.math.MutableIntegerModuloP;\n+import sun.security.util.math.ImmutableIntegerModuloP;\n+\n+@Fork(jvmArgsAppend = {\"-XX:+AlwaysPreTouch\",\n+    \"--add-exports\", \"java.base\/sun.security.util.math.intpoly=ALL-UNNAMED\",\n+    \"--add-exports\", \"java.base\/sun.security.util.math=ALL-UNNAMED\"}, value = 1)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+public class PolynomialP256Bench {\n+    final MontgomeryIntegerPolynomialP256 montField = MontgomeryIntegerPolynomialP256.ONE;\n+    final IntegerPolynomialP256 residueField = IntegerPolynomialP256.ONE;\n+    final BigInteger refx =\n+        new BigInteger(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16);\n+    final ImmutableIntegerModuloP x = residueField.getElement(refx);\n+    final ImmutableIntegerModuloP X = montField.getElement(refx);\n+    final ImmutableIntegerModuloP one = montField.get1();\n+\n+    @Param({\"true\", \"false\"})\n+    private boolean isMontBench;\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchMultiply() {\n+        MutableIntegerModuloP test;\n+        if (isMontBench) {\n+            test = X.mutable();\n+        } else {\n+            test = x.mutable();\n+        }\n+\n+        for (int i = 0; i< 10000; i++) {\n+            test = test.setProduct(test);\n+        }\n+        return test;\n+    }\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchSquare() {\n+        MutableIntegerModuloP test;\n+        if (isMontBench) {\n+            test = X.mutable();\n+        } else {\n+            test = x.mutable();\n+        }\n+\n+        for (int i = 0; i< 10000; i++) {\n+            test = test.setSquare();\n+        }\n+        return test;\n+    }\n+\n+    @Benchmark\n+    public MutableIntegerModuloP benchAssign() {\n+        MutableIntegerModuloP test1 = X.mutable();\n+        MutableIntegerModuloP test2 = one.mutable();\n+        for (int i = 0; i< 10000; i++) {\n+            test1.conditionalSet(test2, 0);\n+            test1.conditionalSet(test2, 1);\n+            test2.conditionalSet(test1, 0);\n+            test2.conditionalSet(test1, 1);\n+        }\n+        return test2;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/PolynomialP256Bench.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -94,1 +94,1 @@\n-                    cob.fieldInstruction(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                    cob.fieldAccess(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n@@ -98,1 +98,1 @@\n-                    cob.invokeInstruction(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), i.isInterface());\n+                    cob.invoke(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), i.isInterface());\n@@ -106,1 +106,1 @@\n-                    cob.typeCheckInstruction(i.opcode(), i.type().asSymbol());\n+                    cob.with(TypeCheckInstruction.of(i.opcode(), i.type().asSymbol()));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RebuildMethodBodies.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-                                xb.nopInstruction();\n+                                xb.nop();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,3 +144,3 @@\n-                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                              .invokeInstruction(INVOKESPECIAL, CD_Object, INIT_NAME, MTD_void, false)\n-                                              .returnInstruction(VoidType)\n+                      .withCode(codeb -> codeb.loadLocal(TypeKind.ReferenceType, 0)\n+                                              .invoke(INVOKESPECIAL, CD_Object, INIT_NAME, MTD_void, false)\n+                                              .return_(VoidType)\n@@ -157,4 +157,4 @@\n-                                  c0.constantInstruction(ICONST_1, 1)         \/\/ 0\n-                                    .storeInstruction(IntType, vFac)        \/\/ 1\n-                                    .constantInstruction(ICONST_1, 1)         \/\/ 2\n-                                    .storeInstruction(IntType, vI)          \/\/ 3\n+                                  c0.iconst_1()         \/\/ 0\n+                                    .istore(vFac)       \/\/ 1\n+                                    .iconst_1()         \/\/ 2\n+                                    .istore(vI)         \/\/ 3\n@@ -162,9 +162,9 @@\n-                                    .loadInstruction(IntType, vI)           \/\/ 4\n-                                    .constantInstruction(BIPUSH, 10)         \/\/ 5\n-                                    .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n-                                    .loadInstruction(IntType, vFac)         \/\/ 7\n-                                    .loadInstruction(IntType, vI)           \/\/ 8\n-                                    .operatorInstruction(IMUL)             \/\/ 9\n-                                    .storeInstruction(IntType, vFac)        \/\/ 10\n-                                    .incrementInstruction(vI, 1)    \/\/ 11\n-                                    .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                    .iload(vI)          \/\/ 4\n+                                    .bipush(10)         \/\/ 5\n+                                    .if_icmpge(loopEnd) \/\/ 6\n+                                    .iload(vFac)        \/\/ 7\n+                                    .iload(vI)          \/\/ 8\n+                                    .imul()             \/\/ 9\n+                                    .istore(vFac)       \/\/ 10\n+                                    .iinc(vI, 1)        \/\/ 11\n+                                    .goto_(loopTop)     \/\/ 12\n@@ -172,4 +172,4 @@\n-                                    .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n-                                    .loadInstruction(IntType, vFac)\n-                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_void_int, false)  \/\/ 15\n-                                    .returnInstruction(VoidType);\n+                                    .getstatic(CD_System, \"out\", CD_PrintStream) \/\/ 13\n+                                    .iload(vFac)\n+                                    .invokevirtual(CD_PrintStream, \"println\", MTD_void_int) \/\/ 15\n+                                    .return_();\n@@ -192,3 +192,3 @@\n-                          mb -> mb.withCode(codeb -> codeb.loadInstruction(ReferenceType, 0)\n-                                                          .invokeInstruction(INVOKESPECIAL, CD_Object, INIT_NAME, MTD_void, false)\n-                                                          .returnInstruction(VoidType)\n+                          mb -> mb.withCode(codeb -> codeb.loadLocal(ReferenceType, 0)\n+                                                          .invokespecial(CD_Object, INIT_NAME, MTD_void, false)\n+                                                          .return_()\n@@ -205,4 +205,4 @@\n-                                  c0.constantInstruction(ICONST_1, 1)        \/\/ 0\n-                                    .storeInstruction(IntType, 1)          \/\/ 1\n-                                    .constantInstruction(ICONST_1, 1)        \/\/ 2\n-                                    .storeInstruction(IntType, 2)          \/\/ 3\n+                                  c0.iconst_1()         \/\/ 0\n+                                    .istore(1)          \/\/ 1\n+                                    .iconst_1()         \/\/ 2\n+                                    .istore(2)          \/\/ 3\n@@ -210,9 +210,9 @@\n-                                    .loadInstruction(IntType, 2)           \/\/ 4\n-                                    .constantInstruction(BIPUSH, 10)         \/\/ 5\n-                                    .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n-                                    .loadInstruction(IntType, 1)           \/\/ 7\n-                                    .loadInstruction(IntType, 2)           \/\/ 8\n-                                    .operatorInstruction(IMUL)             \/\/ 9\n-                                    .storeInstruction(IntType, 1)          \/\/ 10\n-                                    .incrementInstruction(2, 1)    \/\/ 11\n-                                    .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                    .iload(2)           \/\/ 4\n+                                    .bipush(10)         \/\/ 5\n+                                    .if_icmpge(loopEnd) \/\/ 6\n+                                    .iload(1)           \/\/ 7\n+                                    .iload(2)           \/\/ 8\n+                                    .imul()             \/\/ 9\n+                                    .istore(1)          \/\/ 10\n+                                    .iinc(2, 1)         \/\/ 11\n+                                    .goto_(loopTop)     \/\/ 12\n@@ -220,4 +220,4 @@\n-                                    .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n-                                    .loadInstruction(IntType, 1)\n-                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_void_int, false)  \/\/ 15\n-                                    .returnInstruction(VoidType);\n+                                    .getstatic(CD_System, \"out\", CD_PrintStream)  \/\/ 13\n+                                    .iload(1)\n+                                    .invokevirtual(CD_PrintStream, \"println\", MTD_void_int)  \/\/ 15\n+                                    .return_();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStores.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}